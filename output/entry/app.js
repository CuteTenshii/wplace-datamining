const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["../nodes/0.CpSVMNhN.js", "../chunks/_4b585Q4.js", "../chunks/Bk98XZ95.js", "../chunks/DRybHg5Z.js", "../chunks/D2YHGc7S.js", "../chunks/Bdr-ftgJ.js", "../chunks/B_2Nf69T.js", "../chunks/CvoRFl76.js", "../chunks/BqVjMzRy.js", "../chunks/CLjns3l8.js", "../chunks/DscCFUQ8.js", "../chunks/CxIl7U_E.js", "../chunks/oXVwaawB.js", "../chunks/CH9a9qxL.js", "../chunks/CMxWU-I2.js", "../chunks/BxiYvU3t.js", "../chunks/pDkeFBdA.js", "../assets/0.BPsufKpl.css", "../nodes/1.CYhu7mxU.js", "../chunks/CxdbN5br.js", "../chunks/C_8hNSVn.js", "../chunks/DYvS4Itf.js", "../nodes/2.D6dZkZ6v.js", "../chunks/B4IXZ_jM.js", "../chunks/g6UYX15S.js", "../chunks/hz57GhkG.js", "../chunks/Zcs0SyIA.js", "../nodes/3.DAZn6mk_.js", "../nodes/4.D4IHJFSN.js", "../chunks/B4MNwZu_.js", "../chunks/B9knutSO.js", "../chunks/Clz1iRWZ.js", "../chunks/DuykBIyf.js", "../chunks/DwNvVRGL.js", "../chunks/VHKbpQlZ.js", "../chunks/Bt7n9ppm.js", "../chunks/BCe0qenG.js", "../chunks/UY0UN4q1.js", "../chunks/_pm1_Zww.js", "../chunks/CODWMHt0.js", "../chunks/xQAsm05l.js", "../chunks/CMNwhB-n.js", "../assets/ProfileAvatarWithLevel.6dmPRSfx.css", "../chunks/bUKkIo1p.js", "../chunks/DMIP7PJG.js", "../assets/LoginForm.CxMG0irz.css", "../chunks/CjiSeOk2.js", "../chunks/F7XtKV2x.js", "../chunks/C91tUGlv.js", "../chunks/B4oA93Qk.js", "../chunks/JHoM_3VZ.js", "../chunks/LBRjJfeo.js", "../chunks/CQVFqYag.js", "../assets/4.BtKF873c.css", "../nodes/5.DbvDYKvQ.js", "../nodes/6.DIkhzORW.js", "../nodes/7.wGtuT1wI.js", "../chunks/DCf5hggk.js", "../chunks/CVv-AxMc.js", "../chunks/BA5CASyd.js", "../chunks/DTpD9Vui.js", "../nodes/8.3ihRAo2m.js", "../chunks/BrXL-XFY.js", "../chunks/CdtBZ0Ob.js", "../chunks/Bnpv769X.js", "../nodes/9.DTXaImJt.js", "../chunks/DUnPMx0P.js", "../nodes/10.CPCdNj68.js", "../nodes/11.L4BDnh04.js", "../chunks/D3b4ilCW.js", "../nodes/12.c_25KQyb.js", "../nodes/13.YNVVb1_T.js", "../chunks/BPDd8TsH.js", "../chunks/Wzg0GtZ7.js", "../chunks/Ldt-8rMU.js", "../nodes/14.BnSA5oFs.js", "../chunks/DIl4nGP2.js", "../nodes/15.DOmo8Lv1.js", "../chunks/Cky4D_IG.js", "../nodes/16.CDg8S4Qe.js", "../nodes/17.uMccEkTe.js", "../nodes/18.efjpvq-t.js", "../nodes/19.BkdJdeOt.js", "../nodes/20.DQqCNqYZ.js", "../nodes/21.I9LXRG0n.js", "../assets/21.BD1hRFPA.css", "../nodes/22.pZ-xouhR.js", "../nodes/23.DzNJH28Y.js", "../nodes/24.puEbL3R3.js", "../nodes/25.DgsHKk23.js"]))) => i.map(i => d[i]);
var Jn = t => {
  throw TypeError(t)
};
var Kn = (t, e, n) => e.has(t) || Jn("Cannot " + n);
var $ = (t, e, n) => (Kn(t, e, "read from private field"), n ? n.call(t) : e.get(t)),
  Kt = (t, e, n) => e.has(t) ? Jn("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n),
  Qt = (t, e, n, r) => (Kn(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n);
import {
  _ as w
} from "../chunks/CjiSeOk2.js";
import {
  D as E,
  d as g,
  g as _e,
  G as F,
  a as G,
  b as W,
  S as Me,
  c as Pt,
  e as Vr,
  T as Wr,
  n as oa,
  f as ca,
  h as st,
  i as Zt,
  j as Ne,
  k as R,
  l as mn,
  m as Mt,
  o as at,
  p as it,
  t as q,
  q as Ee,
  r as x,
  u as ua,
  v as Xe,
  w as Z,
  x as da,
  y as la,
  z as Ue,
  A as Cn,
  B as N,
  C as Qn,
  E as C,
  F as St,
  H as Zn,
  I as fa,
  J as Gr,
  K as Le,
  L as On,
  M as Ht,
  N as Yr,
  O as zr,
  _ as Bt,
  P as pa,
  Q as Tt,
  R as $t,
  U as Xr,
  V as ma,
  W as Jr,
  X as kt,
  Y as ga,
  Z as Ut,
  $ as ha,
  a0 as yt,
  a1 as er,
  a2 as Ze,
  a3 as tr,
  a4 as Ce,
  a5 as _a,
  a6 as Kr,
  a7 as Ea,
  a8 as Sa,
  a9 as Qr,
  aa as Nt,
  ab as Zr,
  ac as Ta,
  ad as gn,
  ae as ya,
  af as qt,
  ag as nr,
  ah as va,
  ai as ba,
  aj as Ia,
  ak as Ra,
  al as wa,
  am as Aa,
  an as Dn,
  ao as Pe,
  ap as he,
  aq as Lt,
  ar as Pa,
  as as V,
  at as rr,
  au as sr,
  av as es,
  aw as ts,
  ax as ka,
  ay as ns,
  az as et,
  aA as ot,
  aB as Na,
  aC as hn,
  aD as tt,
  aE as rs,
  aF as ss,
  aG as ar,
  aH as La,
  aI as xn,
  aJ as Ca,
  aK as Oa,
  aL as Y,
  aM as pe,
  aN as as,
  aO as Je,
  aP as Da,
  aQ as He,
  aR as ir,
  aS as or,
  aT as cr,
  aU as is,
  aV as xa,
  aW as Fa,
  aX as Ma,
  aY as Ha
} from "../chunks/CLjns3l8.js";
import {
  s as Ba
} from "../chunks/DYvS4Itf.js";
import {
  e as vt,
  b4 as $a,
  h as j,
  aQ as Ua,
  bo as qa,
  ab as ja,
  p as Va,
  J as Wa,
  K as Ga,
  g as en,
  aW as Ya,
  f as os,
  a as ae,
  s as za,
  b as K,
  c as Xa,
  A as le,
  d as Ja,
  r as Ka,
  u as Re,
  B as Qa,
  t as Za
} from "../chunks/DRybHg5Z.js";
import {
  h as ei,
  m as ti,
  u as ni,
  s as ri
} from "../chunks/D2YHGc7S.js";
import "../chunks/_4b585Q4.js";
import {
  o as si
} from "../chunks/Bk98XZ95.js";
import {
  p as Ye,
  i as ze
} from "../chunks/CxIl7U_E.js";
import {
  c as we
} from "../chunks/BxiYvU3t.js";
import {
  b as Ae
} from "../chunks/CMxWU-I2.js";
(function() {
  try {
    var t = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
    t.SENTRY_RELEASE = {
      id: "52c32908d40da7633c03ed8a85ce90814a387626"
    }
  } catch {}
})();
try {
  (function() {
    var t = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {},
      e = new t.Error().stack;
    e && (t._sentryDebugIds = t._sentryDebugIds || {}, t._sentryDebugIds[e] = "cc88a0f7-8a56-4f15-a39e-4ec99da628ff", t._sentryDebugIdIdentifier = "sentry-dbid-cc88a0f7-8a56-4f15-a39e-4ec99da628ff")
  })()
} catch {}

function ai(t) {
  return class extends ii {
    constructor(e) {
      super({
        component: t,
        ...e
      })
    }
  }
}
var fe, Q;
class ii {
  constructor(e) {
    Kt(this, fe);
    Kt(this, Q);
    var a;
    var n = new Map,
      r = (i, o) => {
        var c = ja(o, !1, !1);
        return n.set(i, c), c
      };
    const s = new Proxy({
      ...e.props || {},
      $$events: {}
    }, {
      get(i, o) {
        return j(n.get(o) ?? r(o, Reflect.get(i, o)))
      },
      has(i, o) {
        return o === $a ? !0 : (j(n.get(o) ?? r(o, Reflect.get(i, o))), Reflect.has(i, o))
      },
      set(i, o, c) {
        return vt(n.get(o) ?? r(o, c), c), Reflect.set(i, o, c)
      }
    });
    Qt(this, Q, (e.hydrate ? ei : ti)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: s,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    })), (!((a = e == null ? void 0 : e.props) != null && a.$$host) || e.sync === !1) && Ua(), Qt(this, fe, s.$$events);
    for (const i of Object.keys($(this, Q))) i === "$set" || i === "$destroy" || i === "$on" || qa(this, i, {
      get() {
        return $(this, Q)[i]
      },
      set(o) {
        $(this, Q)[i] = o
      },
      enumerable: !0
    });
    $(this, Q).$set = i => {
      Object.assign(s, i)
    }, $(this, Q).$destroy = () => {
      ni($(this, Q))
    }
  }
  $set(e) {
    $(this, Q).$set(e)
  }
  $on(e, n) {
    $(this, fe)[e] = $(this, fe)[e] || [];
    const r = (...s) => n.call(this, ...s);
    return $(this, fe)[e].push(r), () => {
      $(this, fe)[e] = $(this, fe)[e].filter(s => s !== r)
    }
  }
  $destroy() {
    $(this, Q).$destroy()
  }
}
fe = new WeakMap, Q = new WeakMap;
const bt = {},
  ur = {};

function ye(t, e) {
  bt[t] = bt[t] || [], bt[t].push(e)
}

function ve(t, e) {
  if (!ur[t]) {
    ur[t] = !0;
    try {
      e()
    } catch (n) {
      E && g.error(`Error while instrumenting ${t}`, n)
    }
  }
}

function ee(t, e) {
  const n = t && bt[t];
  if (n)
    for (const r of n) try {
      r(e)
    } catch (s) {
      E && g.error(`Error while triggering instrumentation handler.
Type: ${t}
Name: ${_e(r)}
Error:`, s)
    }
}
let tn = null;

function cs(t) {
  const e = "error";
  ye(e, t), ve(e, oi)
}

function oi() {
  tn = F.onerror, F.onerror = function(t, e, n, r, s) {
    return ee("error", {
      column: r,
      error: s,
      line: n,
      msg: t,
      url: e
    }), tn ? tn.apply(this, arguments) : !1
  }, F.onerror.__SENTRY_INSTRUMENTED__ = !0
}
let nn = null;

function us(t) {
  const e = "unhandledrejection";
  ye(e, t), ve(e, ci)
}

function ci() {
  nn = F.onunhandledrejection, F.onunhandledrejection = function(t) {
    return ee("unhandledrejection", t), nn ? nn.apply(this, arguments) : !0
  }, F.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
}
let dr = !1;

function ui() {
  if (dr) return;

  function t() {
    const e = G(),
      n = e && W(e);
    if (n) {
      const r = "internal_error";
      E && g.log(`[Tracing] Root span: ${r} -> Global error occurred`), n.setStatus({
        code: Me,
        message: r
      })
    }
  }
  t.tag = "sentry_tracingErrorCallback", dr = !0, cs(t), us(t)
}
class Se {
  constructor(e = {}) {
    this._traceId = e.traceId || Pt(), this._spanId = e.spanId || Vr()
  }
  spanContext() {
    return {
      spanId: this._spanId,
      traceId: this._traceId,
      traceFlags: Wr
    }
  }
  end(e) {}
  setAttribute(e, n) {
    return this
  }
  setAttributes(e) {
    return this
  }
  setStatus(e) {
    return this
  }
  updateName(e) {
    return this
  }
  isRecording() {
    return !1
  }
  addEvent(e, n, r) {
    return this
  }
  addLink(e) {
    return this
  }
  addLinks(e) {
    return this
  }
  recordException(e, n) {}
}

function qe(t, e = []) {
  return [t, e]
}

function di(t, e) {
  const [n, r] = t;
  return [n, [...r, e]]
}

function lr(t, e) {
  const n = t[1];
  for (const r of n) {
    const s = r[0].type;
    if (e(r, s)) return !0
  }
  return !1
}

function _n(t) {
  const e = ca(F);
  return e.encodePolyfill ? e.encodePolyfill(t) : new TextEncoder().encode(t)
}

function li(t) {
  const [e, n] = t;
  let r = JSON.stringify(e);

  function s(a) {
    typeof r == "string" ? r = typeof a == "string" ? r + a : [_n(r), a] : r.push(typeof a == "string" ? _n(a) : a)
  }
  for (const a of n) {
    const [i, o] = a;
    if (s(`
${JSON.stringify(i)}
`), typeof o == "string" || o instanceof Uint8Array) s(o);
    else {
      let c;
      try {
        c = JSON.stringify(o)
      } catch {
        c = JSON.stringify(oa(o))
      }
      s(c)
    }
  }
  return typeof r == "string" ? r : fi(r)
}

function fi(t) {
  const e = t.reduce((s, a) => s + a.length, 0),
    n = new Uint8Array(e);
  let r = 0;
  for (const s of t) n.set(s, r), r += s.length;
  return n
}

function pi(t) {
  return [{
    type: "span"
  }, t]
}

function mi(t) {
  const e = typeof t.data == "string" ? _n(t.data) : t.data;
  return [{
    type: "attachment",
    length: e.length,
    filename: t.filename,
    content_type: t.contentType,
    attachment_type: t.attachmentType
  }, e]
}
const gi = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  profile_chunk: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  raw_security: "security",
  log: "log_item"
};

function fr(t) {
  return gi[t]
}

function ds(t) {
  if (!(t != null && t.sdk)) return;
  const {
    name: e,
    version: n
  } = t.sdk;
  return {
    name: e,
    version: n
  }
}

function hi(t, e, n, r) {
  var a;
  const s = (a = t.sdkProcessingMetadata) == null ? void 0 : a.dynamicSamplingContext;
  return {
    event_id: t.event_id,
    sent_at: new Date().toISOString(),
    ...e && {
      sdk: e
    },
    ...!!n && r && {
      dsn: st(r)
    },
    ...s && {
      trace: s
    }
  }
}

function En(t, e) {
  if (!(e != null && e.length) || !t.description) return !1;
  for (const n of e) {
    if (Ei(n)) {
      if (Zt(t.description, n)) return !0;
      continue
    }
    if (!n.name && !n.op) continue;
    const r = n.name ? Zt(t.description, n.name) : !0,
      s = n.op ? t.op && Zt(t.op, n.op) : !0;
    if (r && s) return !0
  }
  return !1
}

function _i(t, e) {
  const n = e.parent_span_id,
    r = e.span_id;
  if (n)
    for (const s of t) s.parent_span_id === r && (s.parent_span_id = n)
}

function Ei(t) {
  return typeof t == "string" || t instanceof RegExp
}

function Si(t, e) {
  var r, s, a, i;
  if (!e) return t;
  const n = t.sdk || {};
  return t.sdk = {
    ...n,
    name: n.name || e.name,
    version: n.version || e.version,
    integrations: [...((r = t.sdk) == null ? void 0 : r.integrations) || [], ...e.integrations || []],
    packages: [...((s = t.sdk) == null ? void 0 : s.packages) || [], ...e.packages || []],
    settings: (a = t.sdk) != null && a.settings || e.settings ? {
      ...(i = t.sdk) == null ? void 0 : i.settings,
      ...e.settings
    } : void 0
  }, t
}

function Ti(t, e, n, r) {
  const s = ds(n),
    a = {
      sent_at: new Date().toISOString(),
      ...s && {
        sdk: s
      },
      ...!!r && e && {
        dsn: st(e)
      }
    },
    i = "aggregates" in t ? [{
      type: "sessions"
    }, t] : [{
      type: "session"
    }, t.toJSON()];
  return qe(a, [i])
}

function yi(t, e, n, r) {
  const s = ds(n),
    a = t.type && t.type !== "replay_event" ? t.type : "event";
  Si(t, n == null ? void 0 : n.sdk);
  const i = hi(t, s, r, e);
  return delete t.sdkProcessingMetadata, qe(i, [
    [{
      type: a
    }, t]
  ])
}

function vi(t, e) {
  function n(f) {
    return !!f.trace_id && !!f.public_key
  }
  const r = Ne(t[0]),
    s = e == null ? void 0 : e.getDsn(),
    a = e == null ? void 0 : e.getOptions().tunnel,
    i = {
      sent_at: new Date().toISOString(),
      ...n(r) && {
        trace: r
      },
      ...!!a && s && {
        dsn: st(s)
      }
    },
    {
      beforeSendSpan: o,
      ignoreSpans: c
    } = (e == null ? void 0 : e.getOptions()) || {},
    u = c != null && c.length ? t.filter(f => !En(R(f), c)) : t,
    l = t.length - u.length;
  l && (e == null || e.recordDroppedEvent("before_send", "span", l));
  const d = o ? f => {
      const m = R(f),
        h = o(m);
      return h || (mn(), m)
    } : R,
    p = [];
  for (const f of u) {
    const m = d(f);
    m && p.push(pi(m))
  }
  return qe(i, p)
}

function bi(t) {
  if (!E) return;
  const {
    description: e = "< unknown name >",
    op: n = "< unknown op >",
    parent_span_id: r
  } = R(t), {
    spanId: s
  } = t.spanContext(), a = Mt(t), i = W(t), o = i === t, c = `[Tracing] Starting ${a?"sampled":"unsampled"} ${o?"root ":""}span`, u = [`op: ${n}`, `name: ${e}`, `ID: ${s}`];
  if (r && u.push(`parent ID: ${r}`), !o) {
    const {
      op: l,
      description: d
    } = R(i);
    u.push(`root ID: ${i.spanContext().spanId}`), l && u.push(`root op: ${l}`), d && u.push(`root description: ${d}`)
  }
  g.log(`${c}
  ${u.join(`
  `)}`)
}

function Ii(t) {
  if (!E) return;
  const {
    description: e = "< unknown name >",
    op: n = "< unknown op >"
  } = R(t), {
    spanId: r
  } = t.spanContext(), a = W(t) === t, i = `[Tracing] Finishing "${n}" ${a?"root ":""}span "${e}" with ID ${r}`;
  g.log(i)
}

function Ri(t, e, n, r = G()) {
  const s = r && W(r);
  s && (E && g.log(`[Measurement] Setting measurement on root span: ${t} = ${e} ${n}`), s.addEvent(t, {
    [it]: e,
    [at]: n
  }))
}

function pr(t) {
  if (!t || t.length === 0) return;
  const e = {};
  return t.forEach(n => {
    const r = n.attributes || {},
      s = r[at],
      a = r[it];
    typeof s == "string" && typeof a == "number" && (e[n.name] = {
      value: a,
      unit: s
    })
  }), e
}
const mr = 1e3;
class jt {
  constructor(e = {}) {
    this._traceId = e.traceId || Pt(), this._spanId = e.spanId || Vr(), this._startTime = e.startTimestamp || q(), this._links = e.links, this._attributes = {}, this.setAttributes({
      [x]: "manual",
      [Ee]: e.op,
      ...e.attributes
    }), this._name = e.name, e.parentSpanId && (this._parentSpanId = e.parentSpanId), "sampled" in e && (this._sampled = e.sampled), e.endTimestamp && (this._endTime = e.endTimestamp), this._events = [], this._isStandaloneSpan = e.isStandalone, this._endTime && this._onSpanEnded()
  }
  addLink(e) {
    return this._links ? this._links.push(e) : this._links = [e], this
  }
  addLinks(e) {
    return this._links ? this._links.push(...e) : this._links = e, this
  }
  recordException(e, n) {}
  spanContext() {
    const {
      _spanId: e,
      _traceId: n,
      _sampled: r
    } = this;
    return {
      spanId: e,
      traceId: n,
      traceFlags: r ? ua : Wr
    }
  }
  setAttribute(e, n) {
    return n === void 0 ? delete this._attributes[e] : this._attributes[e] = n, this
  }
  setAttributes(e) {
    return Object.keys(e).forEach(n => this.setAttribute(n, e[n])), this
  }
  updateStartTime(e) {
    this._startTime = Xe(e)
  }
  setStatus(e) {
    return this._status = e, this
  }
  updateName(e) {
    return this._name = e, this.setAttribute(Z, "custom"), this
  }
  end(e) {
    this._endTime || (this._endTime = Xe(e), Ii(this), this._onSpanEnded())
  }
  getSpanJSON() {
    return {
      data: this._attributes,
      description: this._name,
      op: this._attributes[Ee],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: la(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[x],
      profile_id: this._attributes[Cn],
      exclusive_time: this._attributes[Ue],
      measurements: pr(this._events),
      is_segment: this._isStandaloneSpan && W(this) === this || void 0,
      segment_id: this._isStandaloneSpan ? W(this).spanContext().spanId : void 0,
      links: da(this._links)
    }
  }
  isRecording() {
    return !this._endTime && !!this._sampled
  }
  addEvent(e, n, r) {
    E && g.log("[Tracing] Adding an event to span:", e);
    const s = gr(n) ? n : r || q(),
      a = gr(n) ? {} : n || {},
      i = {
        name: e,
        time: Xe(s),
        attributes: a
      };
    return this._events.push(i), this
  }
  isStandaloneSpan() {
    return !!this._isStandaloneSpan
  }
  _onSpanEnded() {
    const e = N();
    if (e && e.emit("spanEnd", this), !(this._isStandaloneSpan || this === W(this))) return;
    if (this._isStandaloneSpan) {
      this._sampled ? Ai(vi([this], e)) : (E && g.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled."), e && e.recordDroppedEvent("sample_rate", "span"));
      return
    }
    const r = this._convertSpanToTransaction();
    r && (Qn(this).scope || C()).captureEvent(r)
  }
  _convertSpanToTransaction() {
    var l;
    if (!hr(R(this))) return;
    this._name || (E && g.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this._name = "<unlabeled transaction>");
    const {
      scope: e,
      isolationScope: n
    } = Qn(this), r = (l = e == null ? void 0 : e.getScopeData().sdkProcessingMetadata) == null ? void 0 : l.normalizedRequest;
    if (this._sampled !== !0) return;
    const a = St(this).filter(d => d !== this && !wi(d)).map(d => R(d)).filter(hr),
      i = this._attributes[Z];
    delete this._attributes[Zn], a.forEach(d => {
      delete d.data[Zn]
    });
    const o = {
        contexts: {
          trace: fa(this)
        },
        spans: a.length > mr ? a.sort((d, p) => d.start_timestamp - p.start_timestamp).slice(0, mr) : a,
        start_timestamp: this._startTime,
        timestamp: this._endTime,
        transaction: this._name,
        type: "transaction",
        sdkProcessingMetadata: {
          capturedSpanScope: e,
          capturedSpanIsolationScope: n,
          dynamicSamplingContext: Ne(this)
        },
        request: r,
        ...i && {
          transaction_info: {
            source: i
          }
        }
      },
      c = pr(this._events);
    return c && Object.keys(c).length && (E && g.log("[Measurements] Adding measurements to transaction event", JSON.stringify(c, void 0, 2)), o.measurements = c), o
  }
}

function gr(t) {
  return t && typeof t == "number" || t instanceof Date || Array.isArray(t)
}

function hr(t) {
  return !!t.start_timestamp && !!t.timestamp && !!t.span_id && !!t.trace_id
}

function wi(t) {
  return t instanceof jt && t.isStandaloneSpan()
}

function Ai(t) {
  const e = N();
  if (!e) return;
  const n = t[1];
  if (!n || n.length === 0) {
    e.recordDroppedEvent("before_send", "span");
    return
  }
  e.sendEnvelope(t)
}

function Pi(t, e, n = () => {}) {
  let r;
  try {
    r = t()
  } catch (s) {
    throw e(s), n(), s
  }
  return ki(r, e, n)
}

function ki(t, e, n) {
  return Gr(t) ? t.then(r => (n(), r), r => {
    throw e(r), n(), r
  }) : (n(), t)
}

function Ni(t, e, n) {
  if (!Le(t)) return [!1];
  let r, s;
  typeof t.tracesSampler == "function" ? (s = t.tracesSampler({
    ...e,
    inheritOrSampleWith: o => typeof e.parentSampleRate == "number" ? e.parentSampleRate : typeof e.parentSampled == "boolean" ? Number(e.parentSampled) : o
  }), r = !0) : e.parentSampled !== void 0 ? s = e.parentSampled : typeof t.tracesSampleRate < "u" && (s = t.tracesSampleRate, r = !0);
  const a = On(s);
  if (a === void 0) return E && g.warn(`[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(s)} of type ${JSON.stringify(typeof s)}.`), [!1];
  if (!a) return E && g.log(`[Tracing] Discarding transaction because ${typeof t.tracesSampler=="function"?"tracesSampler returned 0 or false":"a negative sampling decision was inherited or tracesSampleRate is set to 0"}`), [!1, a, r];
  const i = n < a;
  return i || E && g.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(s)})`), [i, a, r]
}
const ls = "__SENTRY_SUPPRESS_TRACING__";

function Li(t, e) {
  const n = Mn();
  if (n.startSpan) return n.startSpan(t, e);
  const r = ps(t),
    {
      forceTransaction: s,
      parentSpan: a,
      scope: i
    } = t,
    o = i == null ? void 0 : i.clone();
  return Ht(o, () => Oi(a)(() => {
    const u = C(),
      l = ms(u, a),
      p = t.onlyIfParent && !l ? new Se : fs({
        parentSpan: l,
        spanArguments: r,
        forceTransaction: s,
        scope: u
      });
    return Bt(u, p), Pi(() => e(p), () => {
      const {
        status: f
      } = R(p);
      p.isRecording() && (!f || f === "ok") && p.setStatus({
        code: Me,
        message: "internal_error"
      })
    }, () => {
      p.end()
    })
  }))
}

function De(t) {
  const e = Mn();
  if (e.startInactiveSpan) return e.startInactiveSpan(t);
  const n = ps(t),
    {
      forceTransaction: r,
      parentSpan: s
    } = t;
  return (t.scope ? i => Ht(t.scope, i) : s !== void 0 ? i => Fn(s, i) : i => i())(() => {
    const i = C(),
      o = ms(i, s);
    return t.onlyIfParent && !o ? new Se : fs({
      parentSpan: o,
      spanArguments: n,
      forceTransaction: r,
      scope: i
    })
  })
}

function Fn(t, e) {
  const n = Mn();
  return n.withActiveSpan ? n.withActiveSpan(t, e) : Ht(r => (Bt(r, t || void 0), e(r)))
}

function fs({
  parentSpan: t,
  spanArguments: e,
  forceTransaction: n,
  scope: r
}) {
  if (!Le()) {
    const i = new Se;
    if (n || !t) {
      const o = {
        sampled: "false",
        sample_rate: "0",
        transaction: e.name,
        ...Ne(i)
      };
      Tt(i, o)
    }
    return i
  }
  const s = $t();
  let a;
  if (t && !n) a = Ci(t, r, e), Xr(t, a);
  else if (t) {
    const i = Ne(t),
      {
        traceId: o,
        spanId: c
      } = t.spanContext(),
      u = Mt(t);
    a = _r({
      traceId: o,
      parentSpanId: c,
      ...e
    }, r, u), Tt(a, i)
  } else {
    const {
      traceId: i,
      dsc: o,
      parentSpanId: c,
      sampled: u
    } = {
      ...s.getPropagationContext(),
      ...r.getPropagationContext()
    };
    a = _r({
      traceId: i,
      parentSpanId: c,
      ...e
    }, r, u), o && Tt(a, o)
  }
  return bi(a), ma(a, r, s), a
}

function ps(t) {
  const n = {
    isStandalone: (t.experimental || {}).standalone,
    ...t
  };
  if (t.startTime) {
    const r = {
      ...n
    };
    return r.startTimestamp = Xe(t.startTime), delete r.startTime, r
  }
  return n
}

function Mn() {
  const t = Yr();
  return zr(t)
}

function _r(t, e, n) {
  var m;
  const r = N(),
    s = (r == null ? void 0 : r.getOptions()) || {},
    {
      name: a = ""
    } = t,
    i = {
      spanAttributes: {
        ...t.attributes
      },
      spanName: a,
      parentSampled: n
    };
  r == null || r.emit("beforeSampling", i, {
    decision: !1
  });
  const o = i.parentSampled ?? n,
    c = i.spanAttributes,
    u = e.getPropagationContext(),
    [l, d, p] = e.getScopeData().sdkProcessingMetadata[ls] ? [!1] : Ni(s, {
      name: a,
      parentSampled: o,
      attributes: c,
      parentSampleRate: On((m = u.dsc) == null ? void 0 : m.sample_rate)
    }, u.sampleRand),
    f = new jt({
      ...t,
      attributes: {
        [Z]: "custom",
        [Jr]: d !== void 0 && p ? d : void 0,
        ...c
      },
      sampled: l
    });
  return !l && r && (E && g.log("[Tracing] Discarding root span because its trace was not chosen to be sampled."), r.recordDroppedEvent("sample_rate", "transaction")), r && r.emit("spanStart", f), f
}

function Ci(t, e, n) {
  const {
    spanId: r,
    traceId: s
  } = t.spanContext(), a = e.getScopeData().sdkProcessingMetadata[ls] ? !1 : Mt(t), i = a ? new jt({
    ...n,
    parentSpanId: r,
    traceId: s,
    sampled: a
  }) : new Se({
    traceId: s
  });
  Xr(t, i);
  const o = N();
  return o && (o.emit("spanStart", i), n.endTimestamp && o.emit("spanEnd", i)), i
}

function ms(t, e) {
  if (e) return e;
  if (e === null) return;
  const n = pa(t);
  if (!n) return;
  const r = N();
  return (r ? r.getOptions() : {}).parentSpanIsAlwaysRootSpan ? W(n) : n
}

function Oi(t) {
  return t !== void 0 ? e => Fn(t, e) : e => e()
}
const It = {
    idleTimeout: 1e3,
    finalTimeout: 3e4,
    childSpanTimeout: 15e3
  },
  Di = "heartbeatFailed",
  xi = "idleTimeout",
  Fi = "finalTimeout",
  Mi = "externalFinish";

function gs(t, e = {}) {
  const n = new Map;
  let r = !1,
    s, a = Mi,
    i = !e.disableAutoFinish;
  const o = [],
    {
      idleTimeout: c = It.idleTimeout,
      finalTimeout: u = It.finalTimeout,
      childSpanTimeout: l = It.childSpanTimeout,
      beforeSpanEnd: d
    } = e,
    p = N();
  if (!p || !Le()) {
    const S = new Se,
      b = {
        sample_rate: "0",
        sampled: "false",
        ...Ne(S)
      };
    return Tt(S, b), S
  }
  const f = C(),
    m = G(),
    h = Hi(t);
  h.end = new Proxy(h.end, {
    apply(S, b, be) {
      if (d && d(h), b instanceof Se) return;
      const [me, ...ge] = be, ce = me || q(), L = Xe(ce), H = St(h).filter(k => k !== h);
      if (!H.length) return z(L), Reflect.apply(S, b, [L, ...ge]);
      const X = H.map(k => R(k).timestamp).filter(k => !!k),
        y = X.length ? Math.max(...X) : void 0,
        P = R(h).start_timestamp,
        v = Math.min(P ? P + u / 1e3 : 1 / 0, Math.max(P || -1 / 0, Math.min(L, y || 1 / 0)));
      return z(v), Reflect.apply(S, b, [v, ...ge])
    }
  });

  function D() {
    s && (clearTimeout(s), s = void 0)
  }

  function I(S) {
    D(), s = setTimeout(() => {
      !r && n.size === 0 && i && (a = xi, h.end(S))
    }, c)
  }

  function M(S) {
    s = setTimeout(() => {
      !r && i && (a = Di, h.end(S))
    }, l)
  }

  function B(S) {
    D(), n.set(S, !0);
    const b = q();
    M(b + l / 1e3)
  }

  function oe(S) {
    if (n.has(S) && n.delete(S), n.size === 0) {
      const b = q();
      I(b + c / 1e3)
    }
  }

  function z(S) {
    r = !0, n.clear(), o.forEach(L => L()), Bt(f, m);
    const b = R(h),
      {
        start_timestamp: be
      } = b;
    if (!be) return;
    b.data[kt] || h.setAttribute(kt, a), g.log(`[Tracing] Idle span "${b.op}" finished`);
    const ge = St(h).filter(L => L !== h);
    let ce = 0;
    ge.forEach(L => {
      L.isRecording() && (L.setStatus({
        code: Me,
        message: "cancelled"
      }), L.end(S), E && g.log("[Tracing] Cancelling span since span ended early", JSON.stringify(L, void 0, 2)));
      const H = R(L),
        {
          timestamp: X = 0,
          start_timestamp: y = 0
        } = H,
        P = y <= S,
        v = (u + c) / 1e3,
        k = X - y <= v;
      if (E) {
        const A = JSON.stringify(L, void 0, 2);
        P ? k || g.log("[Tracing] Discarding span since it finished after idle span final timeout", A) : g.log("[Tracing] Discarding span since it happened after idle span was finished", A)
      }(!k || !P) && (ga(h, L), ce++)
    }), ce > 0 && h.setAttribute("sentry.idle_span_discarded_spans", ce)
  }
  return o.push(p.on("spanStart", S => {
    if (r || S === h || R(S).timestamp || S instanceof jt && S.isStandaloneSpan()) return;
    St(h).includes(S) && B(S.spanContext().spanId)
  })), o.push(p.on("spanEnd", S => {
    r || oe(S.spanContext().spanId)
  })), o.push(p.on("idleSpanEnableAutoFinish", S => {
    S === h && (i = !0, I(), n.size && M())
  })), e.disableAutoFinish || I(), setTimeout(() => {
    r || (h.setStatus({
      code: Me,
      message: "deadline_exceeded"
    }), a = Fi, h.end())
  }, u), h
}

function Hi(t) {
  const e = De(t);
  return Bt(C(), e), E && g.log("[Tracing] Started span is an idle span"), e
}
const Bi = "7";

function $i(t) {
  const e = t.protocol ? `${t.protocol}:` : "",
    n = t.port ? `:${t.port}` : "";
  return `${e}//${t.host}${n}${t.path?`/${t.path}`:""}/api/`
}

function Ui(t) {
  return `${$i(t)}${t.projectId}/envelope/`
}

function qi(t, e) {
  const n = {
    sentry_version: Bi
  };
  return t.publicKey && (n.sentry_key = t.publicKey), e && (n.sentry_client = `${e.name}/${e.version}`), new URLSearchParams(n).toString()
}

function ji(t, e, n) {
  return e || `${Ui(t)}?${qi(t,n)}`
}
const Er = [];

function Vi(t) {
  const e = {};
  return t.forEach(n => {
    const {
      name: r
    } = n, s = e[r];
    s && !s.isDefaultInstance && n.isDefaultInstance || (e[r] = n)
  }), Object.values(e)
}

function Wi(t) {
  const e = t.defaultIntegrations || [],
    n = t.integrations;
  e.forEach(s => {
    s.isDefaultInstance = !0
  });
  let r;
  if (Array.isArray(n)) r = [...e, ...n];
  else if (typeof n == "function") {
    const s = n(e);
    r = Array.isArray(s) ? s : [s]
  } else r = e;
  return Vi(r)
}

function Gi(t, e) {
  const n = {};
  return e.forEach(r => {
    r && hs(t, r, n)
  }), n
}

function Sr(t, e) {
  for (const n of e) n != null && n.afterAllSetup && n.afterAllSetup(t)
}

function hs(t, e, n) {
  if (n[e.name]) {
    E && g.log(`Integration skipped because it was already installed: ${e.name}`);
    return
  }
  if (n[e.name] = e, Er.indexOf(e.name) === -1 && typeof e.setupOnce == "function" && (e.setupOnce(), Er.push(e.name)), e.setup && typeof e.setup == "function" && e.setup(t), typeof e.preprocessEvent == "function") {
    const r = e.preprocessEvent.bind(e);
    t.on("preprocessEvent", (s, a) => r(s, a, t))
  }
  if (typeof e.processEvent == "function") {
    const r = e.processEvent.bind(e),
      s = Object.assign((a, i) => r(a, i, t), {
        id: e.name
      });
    t.addEventProcessor(s)
  }
  E && g.log(`Integration installed: ${e.name}`)
}

function Yi(t, e, n) {
  const r = [{
    type: "client_report"
  }, {
    timestamp: Ut(),
    discarded_events: t
  }];
  return qe(e ? {
    dsn: e
  } : {}, [r])
}

function _s(t) {
  const e = [];
  t.message && e.push(t.message);
  try {
    const n = t.exception.values[t.exception.values.length - 1];
    n != null && n.value && (e.push(n.value), n.type && e.push(`${n.type}: ${n.value}`))
  } catch {}
  return e
}

function zi(t) {
  var c;
  const {
    trace_id: e,
    parent_span_id: n,
    span_id: r,
    status: s,
    origin: a,
    data: i,
    op: o
  } = ((c = t.contexts) == null ? void 0 : c.trace) ?? {};
  return {
    data: i ?? {},
    description: t.transaction,
    op: o,
    parent_span_id: n,
    span_id: r ?? "",
    start_timestamp: t.start_timestamp ?? 0,
    status: s,
    timestamp: t.timestamp,
    trace_id: e ?? "",
    origin: a,
    profile_id: i == null ? void 0 : i[Cn],
    exclusive_time: i == null ? void 0 : i[Ue],
    measurements: t.measurements,
    is_segment: !0
  }
}

function Xi(t) {
  return {
    type: "transaction",
    timestamp: t.timestamp,
    start_timestamp: t.start_timestamp,
    transaction: t.description,
    contexts: {
      trace: {
        trace_id: t.trace_id,
        span_id: t.span_id,
        parent_span_id: t.parent_span_id,
        op: t.op,
        status: t.status,
        origin: t.origin,
        data: {
          ...t.data,
          ...t.profile_id && {
            [Cn]: t.profile_id
          },
          ...t.exclusive_time && {
            [Ue]: t.exclusive_time
          }
        }
      }
    },
    measurements: t.measurements
  }
}
const Tr = "Not capturing exception because it's already been captured.",
  yr = "Discarded session because of missing or non-string release",
  Es = Symbol.for("SentryInternalError"),
  Ss = Symbol.for("SentryDoNotSendEventError");

function Rt(t) {
  return {
    message: t,
    [Es]: !0
  }
}

function rn(t) {
  return {
    message: t,
    [Ss]: !0
  }
}

function vr(t) {
  return !!t && typeof t == "object" && Es in t
}

function br(t) {
  return !!t && typeof t == "object" && Ss in t
}
class Ji {
  constructor(e) {
    if (this._options = e, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], e.dsn ? this._dsn = ha(e.dsn) : E && g.warn("No DSN provided, client will not send events."), this._dsn) {
      const n = ji(this._dsn, e.tunnel, e._metadata ? e._metadata.sdk : void 0);
      this._transport = e.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...e.transportOptions,
        url: n
      })
    }
  }
  captureException(e, n, r) {
    const s = yt();
    if (er(e)) return E && g.log(Tr), s;
    const a = {
      event_id: s,
      ...n
    };
    return this._process(this.eventFromException(e, a).then(i => this._captureEvent(i, a, r))), a.event_id
  }
  captureMessage(e, n, r, s) {
    const a = {
        event_id: yt(),
        ...r
      },
      i = Zr(e) ? e : String(e),
      o = Ze(e) ? this.eventFromMessage(i, n, a) : this.eventFromException(e, a);
    return this._process(o.then(c => this._captureEvent(c, a, s))), a.event_id
  }
  captureEvent(e, n, r) {
    const s = yt();
    if (n != null && n.originalException && er(n.originalException)) return E && g.log(Tr), s;
    const a = {
        event_id: s,
        ...n
      },
      i = e.sdkProcessingMetadata || {},
      o = i.capturedSpanScope,
      c = i.capturedSpanIsolationScope;
    return this._process(this._captureEvent(e, a, o || r, c)), a.event_id
  }
  captureSession(e) {
    this.sendSession(e), tr(e, {
      init: !1
    })
  }
  getDsn() {
    return this._dsn
  }
  getOptions() {
    return this._options
  }
  getSdkMetadata() {
    return this._options._metadata
  }
  getTransport() {
    return this._transport
  }
  flush(e) {
    const n = this._transport;
    return n ? (this.emit("flush"), this._isClientDoneProcessing(e).then(r => n.flush(e).then(s => r && s))) : Ce(!0)
  }
  close(e) {
    return this.flush(e).then(n => (this.getOptions().enabled = !1, this.emit("close"), n))
  }
  getEventProcessors() {
    return this._eventProcessors
  }
  addEventProcessor(e) {
    this._eventProcessors.push(e)
  }
  init() {
    (this._isEnabled() || this._options.integrations.some(({
      name: e
    }) => e.startsWith("Spotlight"))) && this._setupIntegrations()
  }
  getIntegrationByName(e) {
    return this._integrations[e]
  }
  addIntegration(e) {
    const n = this._integrations[e.name];
    hs(this, e, this._integrations), n || Sr(this, [e])
  }
  sendEvent(e, n = {}) {
    this.emit("beforeSendEvent", e, n);
    let r = yi(e, this._dsn, this._options._metadata, this._options.tunnel);
    for (const a of n.attachments || []) r = di(r, mi(a));
    const s = this.sendEnvelope(r);
    s && s.then(a => this.emit("afterSendEvent", e, a), null)
  }
  sendSession(e) {
    const {
      release: n,
      environment: r = _a
    } = this._options;
    if ("aggregates" in e) {
      const a = e.attrs || {};
      if (!a.release && !n) {
        E && g.warn(yr);
        return
      }
      a.release = a.release || n, a.environment = a.environment || r, e.attrs = a
    } else {
      if (!e.release && !n) {
        E && g.warn(yr);
        return
      }
      e.release = e.release || n, e.environment = e.environment || r
    }
    this.emit("beforeSendSession", e);
    const s = Ti(e, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(s)
  }
  recordDroppedEvent(e, n, r = 1) {
    if (this._options.sendClientReports) {
      const s = `${e}:${n}`;
      E && g.log(`Recording outcome: "${s}"${r>1?` (${r} times)`:""}`), this._outcomes[s] = (this._outcomes[s] || 0) + r
    }
  }
  on(e, n) {
    const r = this._hooks[e] = this._hooks[e] || [];
    return r.push(n), () => {
      const s = r.indexOf(n);
      s > -1 && r.splice(s, 1)
    }
  }
  emit(e, ...n) {
    const r = this._hooks[e];
    r && r.forEach(s => s(...n))
  }
  sendEnvelope(e) {
    return this.emit("beforeEnvelope", e), this._isEnabled() && this._transport ? this._transport.send(e).then(null, n => (E && g.error("Error while sending envelope:", n), n)) : (E && g.error("Transport disabled"), Ce({}))
  }
  _setupIntegrations() {
    const {
      integrations: e
    } = this._options;
    this._integrations = Gi(this, e), Sr(this, e)
  }
  _updateSessionFromEvent(e, n) {
    var c;
    let r = n.level === "fatal",
      s = !1;
    const a = (c = n.exception) == null ? void 0 : c.values;
    if (a) {
      s = !0;
      for (const u of a) {
        const l = u.mechanism;
        if ((l == null ? void 0 : l.handled) === !1) {
          r = !0;
          break
        }
      }
    }
    const i = e.status === "ok";
    (i && e.errors === 0 || i && r) && (tr(e, {
      ...r && {
        status: "crashed"
      },
      errors: e.errors || Number(s || r)
    }), this.captureSession(e))
  }
  _isClientDoneProcessing(e) {
    return new Kr(n => {
      let r = 0;
      const s = 1,
        a = setInterval(() => {
          this._numProcessing == 0 ? (clearInterval(a), n(!0)) : (r += s, e && r >= e && (clearInterval(a), n(!1)))
        }, s)
    })
  }
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0
  }
  _prepareEvent(e, n, r, s) {
    const a = this.getOptions(),
      i = Object.keys(this._integrations);
    return !n.integrations && (i != null && i.length) && (n.integrations = i), this.emit("preprocessEvent", e, n), e.type || s.setLastEventId(e.event_id || n.event_id), Ea(a, e, n, r, this, s).then(o => {
      if (o === null) return o;
      this.emit("postprocessEvent", o, n), o.contexts = {
        trace: Sa(r),
        ...o.contexts
      };
      const c = Qr(this, r);
      return o.sdkProcessingMetadata = {
        dynamicSamplingContext: c,
        ...o.sdkProcessingMetadata
      }, o
    })
  }
  _captureEvent(e, n = {}, r = C(), s = $t()) {
    return E && Sn(e) && g.log(`Captured error event \`${_s(e)[0]||"<unknown>"}\``), this._processEvent(e, n, r, s).then(a => a.event_id, a => {
      E && (br(a) ? g.log(a.message) : vr(a) ? g.warn(a.message) : g.warn(a))
    })
  }
  _processEvent(e, n, r, s) {
    const a = this.getOptions(),
      {
        sampleRate: i
      } = a,
      o = Ts(e),
      c = Sn(e),
      u = e.type || "error",
      l = `before send for type \`${u}\``,
      d = typeof i > "u" ? void 0 : On(i);
    if (c && typeof d == "number" && Math.random() > d) return this.recordDroppedEvent("sample_rate", "error"), Nt(rn(`Discarding event because it's not included in the random sample (sampling rate = ${i})`));
    const p = u === "replay_event" ? "replay" : u;
    return this._prepareEvent(e, n, r, s).then(f => {
      if (f === null) throw this.recordDroppedEvent("event_processor", p), rn("An event processor returned `null`, will not send event.");
      if (n.data && n.data.__sentry__ === !0) return f;
      const h = Qi(this, a, f, n);
      return Ki(h, l)
    }).then(f => {
      var D;
      if (f === null) {
        if (this.recordDroppedEvent("before_send", p), o) {
          const M = 1 + (e.spans || []).length;
          this.recordDroppedEvent("before_send", "span", M)
        }
        throw rn(`${l} returned \`null\`, will not send event.`)
      }
      const m = r.getSession() || s.getSession();
      if (c && m && this._updateSessionFromEvent(m, f), o) {
        const I = ((D = f.sdkProcessingMetadata) == null ? void 0 : D.spanCountBeforeProcessing) || 0,
          M = f.spans ? f.spans.length : 0,
          B = I - M;
        B > 0 && this.recordDroppedEvent("before_send", "span", B)
      }
      const h = f.transaction_info;
      if (o && h && f.transaction !== e.transaction) {
        const I = "custom";
        f.transaction_info = {
          ...h,
          source: I
        }
      }
      return this.sendEvent(f, n), f
    }).then(null, f => {
      throw br(f) || vr(f) ? f : (this.captureException(f, {
        mechanism: {
          handled: !1,
          type: "internal"
        },
        data: {
          __sentry__: !0
        },
        originalException: f
      }), Rt(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${f}`))
    })
  }
  _process(e) {
    this._numProcessing++, e.then(n => (this._numProcessing--, n), n => (this._numProcessing--, n))
  }
  _clearOutcomes() {
    const e = this._outcomes;
    return this._outcomes = {}, Object.entries(e).map(([n, r]) => {
      const [s, a] = n.split(":");
      return {
        reason: s,
        category: a,
        quantity: r
      }
    })
  }
  _flushOutcomes() {
    E && g.log("Flushing outcomes...");
    const e = this._clearOutcomes();
    if (e.length === 0) {
      E && g.log("No outcomes to send");
      return
    }
    if (!this._dsn) {
      E && g.log("No dsn provided, will not send outcomes");
      return
    }
    E && g.log("Sending outcomes:", e);
    const n = Yi(e, this._options.tunnel && st(this._dsn));
    this.sendEnvelope(n)
  }
}

function Ki(t, e) {
  const n = `${e} must return \`null\` or a valid event.`;
  if (Gr(t)) return t.then(r => {
    if (!gn(r) && r !== null) throw Rt(n);
    return r
  }, r => {
    throw Rt(`${e} rejected with ${r}`)
  });
  if (!gn(t) && t !== null) throw Rt(n);
  return t
}

function Qi(t, e, n, r) {
  const {
    beforeSend: s,
    beforeSendTransaction: a,
    beforeSendSpan: i,
    ignoreSpans: o
  } = e;
  let c = n;
  if (Sn(c) && s) return s(c, r);
  if (Ts(c)) {
    if (i || o) {
      const u = zi(c);
      if (o != null && o.length && En(u, o)) return null;
      if (i) {
        const l = i(u);
        l ? c = Ta(n, Xi(l)) : mn()
      }
      if (c.spans) {
        const l = [],
          d = c.spans;
        for (const f of d) {
          if (o != null && o.length && En(f, o)) {
            _i(d, f);
            continue
          }
          if (i) {
            const m = i(f);
            m ? l.push(m) : (mn(), l.push(f))
          } else l.push(f)
        }
        const p = c.spans.length - l.length;
        p && t.recordDroppedEvent("before_send", "span", p), c.spans = l
      }
    }
    if (a) {
      if (c.spans) {
        const u = c.spans.length;
        c.sdkProcessingMetadata = {
          ...n.sdkProcessingMetadata,
          spanCountBeforeProcessing: u
        }
      }
      return a(c, r)
    }
  }
  return c
}

function Sn(t) {
  return t.type === void 0
}

function Ts(t) {
  return t.type === "transaction"
}

function Zi(t) {
  return [{
    type: "log",
    item_count: t.length,
    content_type: "application/vnd.sentry.items.log+json"
  }, {
    items: t
  }]
}

function eo(t, e, n, r) {
  const s = {};
  return e != null && e.sdk && (s.sdk = {
    name: e.sdk.name,
    version: e.sdk.version
  }), n && r && (s.dsn = st(r)), qe(s, [Zi(t)])
}

function sn(t, e) {
  const n = to(t) ?? [];
  if (n.length === 0) return;
  const r = t.getOptions(),
    s = eo(n, r._metadata, r.tunnel, t.getDsn());
  ys().set(t, []), t.emit("flushLogs"), t.sendEnvelope(s)
}

function to(t) {
  return ys().get(t)
}

function ys() {
  return ya("clientToLogBufferMap", () => new WeakMap)
}

function no(t, e) {
  e.debug === !0 && (E ? g.enable() : qt(() => {
    console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.")
  })), C().update(e.initialScope);
  const r = new t(e);
  return ro(r), r.init(), r
}

function ro(t) {
  C().setClient(t)
}
const vs = Symbol.for("SentryBufferFullError");

function so(t) {
  const e = [];

  function n() {
    return t === void 0 || e.length < t
  }

  function r(i) {
    return e.splice(e.indexOf(i), 1)[0] || Promise.resolve(void 0)
  }

  function s(i) {
    if (!n()) return Nt(vs);
    const o = i();
    return e.indexOf(o) === -1 && e.push(o), o.then(() => r(o)).then(null, () => r(o).then(null, () => {})), o
  }

  function a(i) {
    return new Kr((o, c) => {
      let u = e.length;
      if (!u) return o(!0);
      const l = setTimeout(() => {
        i && i > 0 && o(!1)
      }, i);
      e.forEach(d => {
        Ce(d).then(() => {
          --u || (clearTimeout(l), o(!0))
        }, c)
      })
    })
  }
  return {
    $: e,
    add: s,
    drain: a
  }
}
const ao = 60 * 1e3;

function io(t, e = Date.now()) {
  const n = parseInt(`${t}`, 10);
  if (!isNaN(n)) return n * 1e3;
  const r = Date.parse(`${t}`);
  return isNaN(r) ? ao : r - e
}

function oo(t, e) {
  return t[e] || t.all || 0
}

function co(t, e, n = Date.now()) {
  return oo(t, e) > n
}

function uo(t, {
  statusCode: e,
  headers: n
}, r = Date.now()) {
  const s = {
      ...t
    },
    a = n == null ? void 0 : n["x-sentry-rate-limits"],
    i = n == null ? void 0 : n["retry-after"];
  if (a)
    for (const o of a.trim().split(",")) {
      const [c, u, , , l] = o.split(":", 5), d = parseInt(c, 10), p = (isNaN(d) ? 60 : d) * 1e3;
      if (!u) s.all = r + p;
      else
        for (const f of u.split(";")) f === "metric_bucket" ? (!l || l.split(";").includes("custom")) && (s[f] = r + p) : s[f] = r + p
    } else i ? s.all = r + io(i, r) : e === 429 && (s.all = r + 60 * 1e3);
  return s
}
const lo = 64;

function fo(t, e, n = so(t.bufferSize || lo)) {
  let r = {};
  const s = i => n.drain(i);

  function a(i) {
    const o = [];
    if (lr(i, (d, p) => {
        const f = fr(p);
        co(r, f) ? t.recordDroppedEvent("ratelimit_backoff", f) : o.push(d)
      }), o.length === 0) return Ce({});
    const c = qe(i[0], o),
      u = d => {
        lr(c, (p, f) => {
          t.recordDroppedEvent(d, fr(f))
        })
      },
      l = () => e({
        body: li(c)
      }).then(d => (d.statusCode !== void 0 && (d.statusCode < 200 || d.statusCode >= 300) && E && g.warn(`Sentry responded with status code ${d.statusCode} to sent event.`), r = uo(r, d), d), d => {
        throw u("network_error"), E && g.error("Encountered error running transport request:", d), d
      });
    return n.add(l).then(d => d, d => {
      if (d === vs) return E && g.error("Skipped sending event because buffer is full."), u("queue_overflow"), Ce({});
      throw d
    })
  }
  return {
    send: a,
    flush: s
  }
}
const po = "thismessage:/";

function bs(t) {
  return "isRelative" in t
}

function Is(t, e) {
  const n = t.indexOf("://") <= 0 && t.indexOf("//") !== 0,
    r = n ? po : void 0;
  try {
    if ("canParse" in URL && !URL.canParse(t, r)) return;
    const s = new URL(t, r);
    return n ? {
      isRelative: n,
      pathname: s.pathname,
      search: s.search,
      hash: s.hash
    } : s
  } catch {}
}

function mo(t) {
  if (bs(t)) return t.pathname;
  const e = new URL(t);
  return e.search = "", e.hash = "", ["80", "443"].includes(e.port) && (e.port = ""), e.password && (e.password = "%filtered%"), e.username && (e.username = "%filtered%"), e.toString()
}

function ke(t) {
  if (!t) return {};
  const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!e) return {};
  const n = e[6] || "",
    r = e[8] || "";
  return {
    host: e[4],
    path: e[5],
    protocol: e[2],
    search: n,
    hash: r,
    relative: e[5] + n + r
  }
}

function go(t) {
  return t.split(/[?#]/, 1)[0]
}

function ho(t) {
  var e;
  "aggregates" in t ? ((e = t.attrs) == null ? void 0 : e.ip_address) === void 0 && (t.attrs = {
    ...t.attrs,
    ip_address: "{{auto}}"
  }) : t.ipAddress === void 0 && (t.ipAddress = "{{auto}}")
}

function Hn(t, e, n = [e], r = "npm") {
  const s = t._metadata || {};
  s.sdk || (s.sdk = {
    name: `sentry.javascript.${e}`,
    packages: n.map(a => ({
      name: `${r}:@sentry/${a}`,
      version: nr
    })),
    version: nr
  }), t._metadata = s
}

function Rs(t = {}) {
  const e = t.client || N();
  if (!va() || !e) return {};
  const n = Yr(),
    r = zr(n);
  if (r.getTraceData) return r.getTraceData(t);
  const s = t.scope || C(),
    a = t.span || G(),
    i = a ? ba(a) : _o(s),
    o = a ? Ne(a) : Qr(e, s),
    c = Ia(o);
  if (!Ra.test(i)) return g.warn("Invalid sentry-trace data. Cannot generate trace data"), {};
  const l = {
    "sentry-trace": i,
    baggage: c
  };
  if (t.propagateTraceparent) {
    const d = Eo(i);
    d && (l.traceparent = d)
  }
  return l
}

function _o(t) {
  const {
    traceId: e,
    sampled: n,
    propagationSpanId: r
  } = t.getPropagationContext();
  return wa(e, r, n)
}

function Eo(t) {
  const {
    traceId: e,
    parentSpanId: n,
    parentSampled: r
  } = Aa(t) || {};
  if (!(!e || !n)) return `00-${e}-${n}-${r?"01":"00"}`
}
const So = 100;

function Oe(t, e) {
  const n = N(),
    r = $t();
  if (!n) return;
  const {
    beforeBreadcrumb: s = null,
    maxBreadcrumbs: a = So
  } = n.getOptions();
  if (a <= 0) return;
  const o = {
      timestamp: Ut(),
      ...t
    },
    c = s ? qt(() => s(o, e)) : o;
  c !== null && (n.emit && n.emit("beforeAddBreadcrumb", c, e), r.addBreadcrumb(c, a))
}
let Ir;
const To = "FunctionToString",
  Rr = new WeakMap,
  yo = (() => ({
    name: To,
    setupOnce() {
      Ir = Function.prototype.toString;
      try {
        Function.prototype.toString = function(...t) {
          const e = Dn(this),
            n = Rr.has(N()) && e !== void 0 ? e : this;
          return Ir.apply(n, t)
        }
      } catch {}
    },
    setup(t) {
      Rr.set(t, !0)
    }
  })),
  vo = yo,
  bo = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, /^Can't find variable: gmo$/, /^undefined is not an object \(evaluating 'a\.[A-Z]'\)$/, `can't redefine non-configurable property "solana"`, "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler", /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/, /^Java exception was raised during method invocation$/],
  Io = "EventFilters",
  Ro = (t = {}) => {
    let e;
    return {
      name: Io,
      setup(n) {
        const r = n.getOptions();
        e = wr(t, r)
      },
      processEvent(n, r, s) {
        if (!e) {
          const a = s.getOptions();
          e = wr(t, a)
        }
        return Ao(n, e) ? null : n
      }
    }
  },
  wo = ((t = {}) => ({
    ...Ro(t),
    name: "InboundFilters"
  }));

function wr(t = {}, e = {}) {
  return {
    allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
    denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
    ignoreErrors: [...t.ignoreErrors || [], ...e.ignoreErrors || [], ...t.disableErrorDefaults ? [] : bo],
    ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || []]
  }
}

function Ao(t, e) {
  if (t.type) {
    if (t.type === "transaction" && ko(t, e.ignoreTransactions)) return E && g.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${Pe(t)}`), !0
  } else {
    if (Po(t, e.ignoreErrors)) return E && g.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${Pe(t)}`), !0;
    if (Oo(t)) return E && g.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${Pe(t)}`), !0;
    if (No(t, e.denyUrls)) return E && g.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${Pe(t)}.
Url: ${Ct(t)}`), !0;
    if (!Lo(t, e.allowUrls)) return E && g.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${Pe(t)}.
Url: ${Ct(t)}`), !0
  }
  return !1
}

function Po(t, e) {
  return e != null && e.length ? _s(t).some(n => he(n, e)) : !1
}

function ko(t, e) {
  if (!(e != null && e.length)) return !1;
  const n = t.transaction;
  return n ? he(n, e) : !1
}

function No(t, e) {
  if (!(e != null && e.length)) return !1;
  const n = Ct(t);
  return n ? he(n, e) : !1
}

function Lo(t, e) {
  if (!(e != null && e.length)) return !0;
  const n = Ct(t);
  return n ? he(n, e) : !0
}

function Co(t = []) {
  for (let e = t.length - 1; e >= 0; e--) {
    const n = t[e];
    if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]") return n.filename || null
  }
  return null
}

function Ct(t) {
  var e, n;
  try {
    const r = [...((e = t.exception) == null ? void 0 : e.values) ?? []].reverse().find(a => {
        var i, o, c;
        return ((i = a.mechanism) == null ? void 0 : i.parent_id) === void 0 && ((c = (o = a.stacktrace) == null ? void 0 : o.frames) == null ? void 0 : c.length)
      }),
      s = (n = r == null ? void 0 : r.stacktrace) == null ? void 0 : n.frames;
    return s ? Co(s) : null
  } catch {
    return E && g.error(`Cannot extract url for event ${Pe(t)}`), null
  }
}

function Oo(t) {
  var e, n;
  return (n = (e = t.exception) == null ? void 0 : e.values) != null && n.length ? !t.message && !t.exception.values.some(r => r.stacktrace || r.type && r.type !== "Error" || r.value) : !1
}

function Do(t, e, n, r, s, a) {
  var o;
  if (!((o = s.exception) != null && o.values) || !a || !Lt(a.originalException, Error)) return;
  const i = s.exception.values.length > 0 ? s.exception.values[s.exception.values.length - 1] : void 0;
  i && (s.exception.values = Tn(t, e, r, a.originalException, n, s.exception.values, i, 0))
}

function Tn(t, e, n, r, s, a, i, o) {
  if (a.length >= n + 1) return a;
  let c = [...a];
  if (Lt(r[s], Error)) {
    Ar(i, o);
    const u = t(e, r[s]),
      l = c.length;
    Pr(u, s, l, o), c = Tn(t, e, n, r[s], s, [u, ...c], u, l)
  }
  return Array.isArray(r.errors) && r.errors.forEach((u, l) => {
    if (Lt(u, Error)) {
      Ar(i, o);
      const d = t(e, u),
        p = c.length;
      Pr(d, `errors[${l}]`, p, o), c = Tn(t, e, n, u, s, [d, ...c], d, p)
    }
  }), c
}

function Ar(t, e) {
  t.mechanism = t.mechanism || {
    type: "generic",
    handled: !0
  }, t.mechanism = {
    ...t.mechanism,
    ...t.type === "AggregateError" && {
      is_exception_group: !0
    },
    exception_id: e
  }
}

function Pr(t, e, n, r) {
  t.mechanism = t.mechanism || {
    type: "generic",
    handled: !0
  }, t.mechanism = {
    ...t.mechanism,
    type: "chained",
    source: e,
    exception_id: n,
    parent_id: r
  }
}

function xo(t) {
  const e = "console";
  ye(e, t), ve(e, Fo)
}

function Fo() {
  "console" in F && Pa.forEach(function(t) {
    t in F.console && V(F.console, t, function(e) {
      return rr[t] = e,
        function(...n) {
          ee("console", {
            args: n,
            level: t
          });
          const s = rr[t];
          s == null || s.apply(F.console, n)
        }
    })
  })
}

function Mo(t) {
  return t === "warn" ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(t) ? t : "log"
}
const Ho = "Dedupe",
  Bo = (() => {
    let t;
    return {
      name: Ho,
      processEvent(e) {
        if (e.type) return e;
        try {
          if (Uo(e, t)) return E && g.warn("Event dropped due to being a duplicate of previously captured event."), null
        } catch {}
        return t = e
      }
    }
  }),
  $o = Bo;

function Uo(t, e) {
  return e ? !!(qo(t, e) || jo(t, e)) : !1
}

function qo(t, e) {
  const n = t.message,
    r = e.message;
  return !(!n && !r || n && !r || !n && r || n !== r || !As(t, e) || !ws(t, e))
}

function jo(t, e) {
  const n = kr(e),
    r = kr(t);
  return !(!n || !r || n.type !== r.type || n.value !== r.value || !As(t, e) || !ws(t, e))
}

function ws(t, e) {
  let n = sr(t),
    r = sr(e);
  if (!n && !r) return !0;
  if (n && !r || !n && r || (n = n, r = r, r.length !== n.length)) return !1;
  for (let s = 0; s < r.length; s++) {
    const a = r[s],
      i = n[s];
    if (a.filename !== i.filename || a.lineno !== i.lineno || a.colno !== i.colno || a.function !== i.function) return !1
  }
  return !0
}

function As(t, e) {
  let n = t.fingerprint,
    r = e.fingerprint;
  if (!n && !r) return !0;
  if (n && !r || !n && r) return !1;
  n = n, r = r;
  try {
    return n.join("") === r.join("")
  } catch {
    return !1
  }
}

function kr(t) {
  var e, n;
  return (n = (e = t.exception) == null ? void 0 : e.values) == null ? void 0 : n[0]
}

function Vo(t, e, n, r, s) {
  if (!t.fetchData) return;
  const {
    method: a,
    url: i
  } = t.fetchData, o = Le() && e(i);
  if (t.endTimestamp && o) {
    const f = t.fetchData.__span;
    if (!f) return;
    const m = r[f];
    m && (Go(m, t), delete r[f]);
    return
  }
  const {
    spanOrigin: c = "auto.http.browser",
    propagateTraceparent: u = !1
  } = typeof s == "object" ? s : {
    spanOrigin: s
  }, l = !!G(), d = o && l ? De(zo(i, a, c)) : new Se;
  if (t.fetchData.__span = d.spanContext().spanId, r[d.spanContext().spanId] = d, n(t.fetchData.url)) {
    const f = t.args[0],
      m = t.args[1] || {},
      h = Wo(f, m, Le() && l ? d : void 0, u);
    h && (t.args[1] = m, m.headers = h)
  }
  const p = N();
  if (p) {
    const f = {
      input: t.args,
      response: t.response,
      startTimestamp: t.startTimestamp,
      endTimestamp: t.endTimestamp
    };
    p.emit("beforeOutgoingRequestSpan", d, f)
  }
  return d
}

function Wo(t, e, n, r) {
  const s = Rs({
      span: n,
      propagateTraceparent: r
    }),
    a = s["sentry-trace"],
    i = s.baggage,
    o = s.traceparent;
  if (!a) return;
  const c = e.headers || (ts(t) ? t.headers : void 0);
  if (c)
    if (Yo(c)) {
      const u = new Headers(c);
      if (u.get("sentry-trace") || u.set("sentry-trace", a), r && o && !u.get("traceparent") && u.set("traceparent", o), i) {
        const l = u.get("baggage");
        l ? mt(l) || u.set("baggage", `${l},${i}`) : u.set("baggage", i)
      }
      return u
    } else if (Array.isArray(c)) {
    const u = [...c];
    c.find(d => d[0] === "sentry-trace") || u.push(["sentry-trace", a]), r && o && !c.find(d => d[0] === "traceparent") && u.push(["traceparent", o]);
    const l = c.find(d => d[0] === "baggage" && mt(d[1]));
    return i && !l && u.push(["baggage", i]), u
  } else {
    const u = "sentry-trace" in c ? c["sentry-trace"] : void 0,
      l = "traceparent" in c ? c.traceparent : void 0,
      d = "baggage" in c ? c.baggage : void 0,
      p = d ? Array.isArray(d) ? [...d] : [d] : [],
      f = d && (Array.isArray(d) ? d.find(h => mt(h)) : mt(d));
    i && !f && p.push(i);
    const m = {
      ...c,
      "sentry-trace": u ?? a,
      baggage: p.length > 0 ? p.join(",") : void 0
    };
    return r && o && !l && (m.traceparent = o), m
  } else return {
    ...s
  }
}

function Go(t, e) {
  var n, r;
  if (e.response) {
    es(t, e.response.status);
    const s = (r = (n = e.response) == null ? void 0 : n.headers) == null ? void 0 : r.get("content-length");
    if (s) {
      const a = parseInt(s);
      a > 0 && t.setAttribute("http.response_content_length", a)
    }
  } else e.error && t.setStatus({
    code: Me,
    message: "internal_error"
  });
  t.end()
}

function mt(t) {
  return t.split(",").some(e => e.trim().startsWith(ka))
}

function Yo(t) {
  return typeof Headers < "u" && Lt(t, Headers)
}

function zo(t, e, n) {
  const r = Is(t);
  return {
    name: r ? `${e} ${mo(r)}` : e,
    attributes: Xo(t, r, e, n)
  }
}

function Xo(t, e, n, r) {
  const s = {
    url: t,
    type: "fetch",
    "http.method": n,
    [x]: r,
    [Ee]: "http.client"
  };
  return e && (bs(e) || (s["http.url"] = e.href, s["server.address"] = e.host), e.search && (s["http.query"] = e.search), e.hash && (s["http.fragment"] = e.hash)), s
}

function Ps(t) {
  if (t !== void 0) return t >= 400 && t < 500 ? "warning" : t >= 500 ? "error" : void 0
}
const nt = F;

function Jo() {
  return "history" in nt && !!nt.history
}

function Ko() {
  if (!("fetch" in nt)) return !1;
  try {
    return new Headers, new Request("http://www.example.com"), new Response, !0
  } catch {
    return !1
  }
}

function yn(t) {
  return t && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
}

function Qo() {
  var n;
  if (typeof EdgeRuntime == "string") return !0;
  if (!Ko()) return !1;
  if (yn(nt.fetch)) return !0;
  let t = !1;
  const e = nt.document;
  if (e && typeof e.createElement == "function") try {
    const r = e.createElement("iframe");
    r.hidden = !0, e.head.appendChild(r), (n = r.contentWindow) != null && n.fetch && (t = yn(r.contentWindow.fetch)), e.head.removeChild(r)
  } catch (r) {
    E && g.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", r)
  }
  return t
}

function ks(t, e) {
  const n = "fetch";
  ye(n, t), ve(n, () => Ns(void 0, e))
}

function Zo(t) {
  const e = "fetch-body-resolved";
  ye(e, t), ve(e, () => Ns(tc))
}

function Ns(t, e = !1) {
  e && !Qo() || V(F, "fetch", function(n) {
    return function(...r) {
      const s = new Error,
        {
          method: a,
          url: i
        } = nc(r),
        o = {
          args: r,
          fetchData: {
            method: a,
            url: i
          },
          startTimestamp: q() * 1e3,
          virtualError: s,
          headers: rc(r)
        };
      return t || ee("fetch", {
        ...o
      }), n.apply(F, r).then(async c => (t ? t(c) : ee("fetch", {
        ...o,
        endTimestamp: q() * 1e3,
        response: c
      }), c), c => {
        if (ee("fetch", {
            ...o,
            endTimestamp: q() * 1e3,
            error: c
          }), ns(c) && c.stack === void 0 && (c.stack = s.stack, et(c, "framesToPop", 1)), c instanceof TypeError && (c.message === "Failed to fetch" || c.message === "Load failed" || c.message === "NetworkError when attempting to fetch resource.")) try {
          const u = new URL(o.fetchData.url);
          c.message = `${c.message} (${u.host})`
        } catch {}
        throw c
      })
    }
  })
}
async function ec(t, e) {
  if (t != null && t.body) {
    const n = t.body,
      r = n.getReader(),
      s = setTimeout(() => {
        n.cancel().then(null, () => {})
      }, 90 * 1e3);
    let a = !0;
    for (; a;) {
      let i;
      try {
        i = setTimeout(() => {
          n.cancel().then(null, () => {})
        }, 5e3);
        const {
          done: o
        } = await r.read();
        clearTimeout(i), o && (e(), a = !1)
      } catch {
        a = !1
      } finally {
        clearTimeout(i)
      }
    }
    clearTimeout(s), r.releaseLock(), n.cancel().then(null, () => {})
  }
}

function tc(t) {
  let e;
  try {
    e = t.clone()
  } catch {
    return
  }
  ec(e, () => {
    ee("fetch-body-resolved", {
      endTimestamp: q() * 1e3,
      response: t
    })
  })
}

function vn(t, e) {
  return !!t && typeof t == "object" && !!t[e]
}

function Nr(t) {
  return typeof t == "string" ? t : t ? vn(t, "url") ? t.url : t.toString ? t.toString() : "" : ""
}

function nc(t) {
  if (t.length === 0) return {
    method: "GET",
    url: ""
  };
  if (t.length === 2) {
    const [n, r] = t;
    return {
      url: Nr(n),
      method: vn(r, "method") ? String(r.method).toUpperCase() : "GET"
    }
  }
  const e = t[0];
  return {
    url: Nr(e),
    method: vn(e, "method") ? String(e.method).toUpperCase() : "GET"
  }
}

function rc(t) {
  const [e, n] = t;
  try {
    if (typeof n == "object" && n !== null && "headers" in n && n.headers) return new Headers(n.headers);
    if (ts(e)) return new Headers(e.headers)
  } catch {}
}

function sc() {
  return "npm"
}
const T = F;
let bn = 0;

function Ls() {
  return bn > 0
}

function ac() {
  bn++, setTimeout(() => {
    bn--
  })
}

function Be(t, e = {}) {
  function n(s) {
    return typeof s == "function"
  }
  if (!n(t)) return t;
  try {
    const s = t.__sentry_wrapped__;
    if (s) return typeof s == "function" ? s : t;
    if (Dn(t)) return t
  } catch {
    return t
  }
  const r = function(...s) {
    try {
      const a = s.map(i => Be(i, e));
      return t.apply(this, a)
    } catch (a) {
      throw ac(), Ht(i => {
        i.addEventProcessor(o => (e.mechanism && (hn(o, void 0), tt(o, e.mechanism)), o.extra = {
          ...o.extra,
          arguments: s
        }, o)), rs(a)
      }), a
    }
  };
  try {
    for (const s in t) Object.prototype.hasOwnProperty.call(t, s) && (r[s] = t[s])
  } catch {}
  Na(r, t), et(t, "__sentry_wrapped__", r);
  try {
    Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
      get() {
        return t.name
      }
    })
  } catch {}
  return r
}

function Bn() {
  const t = ot(),
    {
      referrer: e
    } = T.document || {},
    {
      userAgent: n
    } = T.navigator || {},
    r = {
      ...e && {
        Referer: e
      },
      ...n && {
        "User-Agent": n
      }
    };
  return {
    url: t,
    headers: r
  }
}

function $n(t, e) {
  const n = Un(t, e),
    r = {
      type: dc(e),
      value: lc(e)
    };
  return n.length && (r.stacktrace = {
    frames: n
  }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r
}

function ic(t, e, n, r) {
  const s = N(),
    a = s == null ? void 0 : s.getOptions().normalizeDepth,
    i = hc(e),
    o = {
      __serialized__: Ca(e, a)
    };
  if (i) return {
    exception: {
      values: [$n(t, i)]
    },
    extra: o
  };
  const c = {
    exception: {
      values: [{
        type: xn(e) ? e.constructor.name : r ? "UnhandledRejection" : "Error",
        value: mc(e, {
          isUnhandledRejection: r
        })
      }]
    },
    extra: o
  };
  if (n) {
    const u = Un(t, n);
    u.length && (c.exception.values[0].stacktrace = {
      frames: u
    })
  }
  return c
}

function an(t, e) {
  return {
    exception: {
      values: [$n(t, e)]
    }
  }
}

function Un(t, e) {
  const n = e.stacktrace || e.stack || "",
    r = cc(e),
    s = uc(e);
  try {
    return t(n, r, s)
  } catch {}
  return []
}
const oc = /Minified React error #\d+;/i;

function cc(t) {
  return t && oc.test(t.message) ? 1 : 0
}

function uc(t) {
  return typeof t.framesToPop == "number" ? t.framesToPop : 0
}

function Cs(t) {
  return typeof WebAssembly < "u" && typeof WebAssembly.Exception < "u" ? t instanceof WebAssembly.Exception : !1
}

function dc(t) {
  const e = t == null ? void 0 : t.name;
  return !e && Cs(t) ? t.message && Array.isArray(t.message) && t.message.length == 2 ? t.message[0] : "WebAssembly.Exception" : e
}

function lc(t) {
  const e = t == null ? void 0 : t.message;
  return Cs(t) ? Array.isArray(t.message) && t.message.length == 2 ? t.message[1] : "wasm exception" : e ? e.error && typeof e.error.message == "string" ? e.error.message : e : "No error message"
}

function fc(t, e, n, r) {
  const s = (n == null ? void 0 : n.syntheticException) || void 0,
    a = qn(t, e, s, r);
  return tt(a), a.level = "error", n != null && n.event_id && (a.event_id = n.event_id), Ce(a)
}

function pc(t, e, n = "info", r, s) {
  const a = (r == null ? void 0 : r.syntheticException) || void 0,
    i = In(t, e, a, s);
  return i.level = n, r != null && r.event_id && (i.event_id = r.event_id), Ce(i)
}

function qn(t, e, n, r, s) {
  let a;
  if (ss(e) && e.error) return an(t, e.error);
  if (ar(e) || La(e)) {
    const i = e;
    if ("stack" in e) a = an(t, e);
    else {
      const o = i.name || (ar(i) ? "DOMError" : "DOMException"),
        c = i.message ? `${o}: ${i.message}` : o;
      a = In(t, c, n, r), hn(a, c)
    }
    return "code" in i && (a.tags = {
      ...a.tags,
      "DOMException.code": `${i.code}`
    }), a
  }
  return ns(e) ? an(t, e) : gn(e) || xn(e) ? (a = ic(t, e, n, s), tt(a, {
    synthetic: !0
  }), a) : (a = In(t, e, n, r), hn(a, `${e}`), tt(a, {
    synthetic: !0
  }), a)
}

function In(t, e, n, r) {
  const s = {};
  if (r && n) {
    const a = Un(t, n);
    a.length && (s.exception = {
      values: [{
        value: e,
        stacktrace: {
          frames: a
        }
      }]
    }), tt(s, {
      synthetic: !0
    })
  }
  if (Zr(e)) {
    const {
      __sentry_template_string__: a,
      __sentry_template_values__: i
    } = e;
    return s.logentry = {
      message: a,
      params: i
    }, s
  }
  return s.message = e, s
}

function mc(t, {
  isUnhandledRejection: e
}) {
  const n = Oa(t),
    r = e ? "promise rejection" : "exception";
  return ss(t) ? `Event \`ErrorEvent\` captured as ${r} with message \`${t.message}\`` : xn(t) ? `Event \`${gc(t)}\` (type=${t.type}) captured as ${r}` : `Object captured as ${r} with keys: ${n}`
}

function gc(t) {
  try {
    const e = Object.getPrototypeOf(t);
    return e ? e.constructor.name : void 0
  } catch {}
}

function hc(t) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e)) {
      const n = t[e];
      if (n instanceof Error) return n
    }
}
const _c = 5e3;
class Ec extends Ji {
  constructor(e) {
    var o;
    const n = Sc(e),
      r = T.SENTRY_SDK_SOURCE || sc();
    Hn(n, "browser", ["browser"], r), (o = n._metadata) != null && o.sdk && (n._metadata.sdk.settings = {
      infer_ip: n.sendDefaultPii ? "auto" : "never",
      ...n._metadata.sdk.settings
    }), super(n);
    const {
      sendDefaultPii: s,
      sendClientReports: a,
      enableLogs: i
    } = this._options;
    T.document && (a || i) && T.document.addEventListener("visibilitychange", () => {
      T.document.visibilityState === "hidden" && (a && this._flushOutcomes(), i && sn(this))
    }), i && (this.on("flush", () => {
      sn(this)
    }), this.on("afterCaptureLog", () => {
      this._logFlushIdleTimeout && clearTimeout(this._logFlushIdleTimeout), this._logFlushIdleTimeout = setTimeout(() => {
        sn(this)
      }, _c)
    })), s && this.on("beforeSendSession", ho)
  }
  eventFromException(e, n) {
    return fc(this._options.stackParser, e, n, this._options.attachStacktrace)
  }
  eventFromMessage(e, n = "info", r) {
    return pc(this._options.stackParser, e, n, r, this._options.attachStacktrace)
  }
  _prepareEvent(e, n, r, s) {
    return e.platform = e.platform || "javascript", super._prepareEvent(e, n, r, s)
  }
}

function Sc(t) {
  var e;
  return {
    release: typeof __SENTRY_RELEASE__ == "string" ? __SENTRY_RELEASE__ : (e = T.SENTRY_RELEASE) == null ? void 0 : e.id,
    sendClientReports: !0,
    parentSpanIsAlwaysRootSpan: !0,
    ...t
  }
}
const Vt = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  _ = F,
  Tc = (t, e) => t > e[1] ? "poor" : t > e[0] ? "needs-improvement" : "good",
  ct = (t, e, n, r) => {
    let s, a;
    return i => {
      e.value >= 0 && (i || r) && (a = e.value - (s ?? 0), (a || s === void 0) && (s = e.value, e.delta = a, e.rating = Tc(e.value, n), t(e)))
    }
  },
  yc = () => `v5-${Date.now()}-${Math.floor(Math.random()*(9e12-1))+1e12}`,
  ut = (t = !0) => {
    var n, r;
    const e = (r = (n = _.performance) == null ? void 0 : n.getEntriesByType) == null ? void 0 : r.call(n, "navigation")[0];
    if (!t || e && e.responseStart > 0 && e.responseStart < performance.now()) return e
  },
  je = () => {
    const t = ut();
    return (t == null ? void 0 : t.activationStart) ?? 0
  },
  dt = (t, e = -1) => {
    var a, i;
    const n = ut();
    let r = "navigate";
    return n && ((a = _.document) != null && a.prerendering || je() > 0 ? r = "prerender" : (i = _.document) != null && i.wasDiscarded ? r = "restore" : n.type && (r = n.type.replace(/_/g, "-"))), {
      name: t,
      value: e,
      rating: "good",
      delta: 0,
      entries: [],
      id: yc(),
      navigationType: r
    }
  },
  on = new WeakMap;

function jn(t, e) {
  return on.get(t) || on.set(t, new e), on.get(t)
}
class Ot {
  constructor() {
    Ot.prototype.__init.call(this), Ot.prototype.__init2.call(this)
  }
  __init() {
    this._sessionValue = 0
  }
  __init2() {
    this._sessionEntries = []
  }
  _processEntry(e) {
    var s;
    if (e.hadRecentInput) return;
    const n = this._sessionEntries[0],
      r = this._sessionEntries[this._sessionEntries.length - 1];
    this._sessionValue && n && r && e.startTime - r.startTime < 1e3 && e.startTime - n.startTime < 5e3 ? (this._sessionValue += e.value, this._sessionEntries.push(e)) : (this._sessionValue = e.value, this._sessionEntries = [e]), (s = this._onAfterProcessingUnexpectedShift) == null || s.call(this, e)
  }
}
const Ve = (t, e, n = {}) => {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(t)) {
        const r = new PerformanceObserver(s => {
          Promise.resolve().then(() => {
            e(s.getEntries())
          })
        });
        return r.observe({
          type: t,
          buffered: !0,
          ...n
        }), r
      }
    } catch {}
  },
  Vn = t => {
    let e = !1;
    return () => {
      e || (t(), e = !0)
    }
  };
let Ke = -1;
const vc = () => {
    var t, e;
    return ((t = _.document) == null ? void 0 : t.visibilityState) === "hidden" && !((e = _.document) != null && e.prerendering) ? 0 : 1 / 0
  },
  Dt = t => {
    _.document.visibilityState === "hidden" && Ke > -1 && (Ke = t.type === "visibilitychange" ? t.timeStamp : 0, Ic())
  },
  bc = () => {
    addEventListener("visibilitychange", Dt, !0), addEventListener("prerenderingchange", Dt, !0)
  },
  Ic = () => {
    removeEventListener("visibilitychange", Dt, !0), removeEventListener("prerenderingchange", Dt, !0)
  },
  Wn = () => {
    var t;
    if (_.document && Ke < 0) {
      const e = je();
      Ke = (_.document.prerendering || (t = globalThis.performance.getEntriesByType("visibility-state").filter(r => r.name === "hidden" && r.startTime > e)[0]) == null ? void 0 : t.startTime) ?? vc(), bc()
    }
    return {
      get firstHiddenTime() {
        return Ke
      }
    }
  },
  Wt = t => {
    var e;
    (e = _.document) != null && e.prerendering ? addEventListener("prerenderingchange", () => t(), !0) : t()
  },
  Rc = [1800, 3e3],
  wc = (t, e = {}) => {
    Wt(() => {
      const n = Wn(),
        r = dt("FCP");
      let s;
      const i = Ve("paint", o => {
        for (const c of o) c.name === "first-contentful-paint" && (i.disconnect(), c.startTime < n.firstHiddenTime && (r.value = Math.max(c.startTime - je(), 0), r.entries.push(c), s(!0)))
      });
      i && (s = ct(t, r, Rc, e.reportAllChanges))
    })
  },
  Ac = [.1, .25],
  Pc = (t, e = {}) => {
    wc(Vn(() => {
      var o, c;
      const n = dt("CLS", 0);
      let r;
      const s = jn(e, Ot),
        a = u => {
          for (const l of u) s._processEntry(l);
          s._sessionValue > n.value && (n.value = s._sessionValue, n.entries = s._sessionEntries, r())
        },
        i = Ve("layout-shift", a);
      i && (r = ct(t, n, Ac, e.reportAllChanges), (o = _.document) == null || o.addEventListener("visibilitychange", () => {
        var u;
        ((u = _.document) == null ? void 0 : u.visibilityState) === "hidden" && (a(i.takeRecords()), r(!0))
      }), (c = _ == null ? void 0 : _.setTimeout) == null || c.call(_, r))
    }))
  };
let Os = 0,
  cn = 1 / 0,
  gt = 0;
const kc = t => {
  t.forEach(e => {
    e.interactionId && (cn = Math.min(cn, e.interactionId), gt = Math.max(gt, e.interactionId), Os = gt ? (gt - cn) / 7 + 1 : 0)
  })
};
let Rn;
const Ds = () => Rn ? Os : performance.interactionCount || 0,
  Nc = () => {
    "interactionCount" in performance || Rn || (Rn = Ve("event", kc, {
      type: "event",
      buffered: !0,
      durationThreshold: 0
    }))
  },
  un = 10;
let xs = 0;
const Lc = () => Ds() - xs;
class xt {
  constructor() {
    xt.prototype.__init.call(this), xt.prototype.__init2.call(this)
  }
  __init() {
    this._longestInteractionList = []
  }
  __init2() {
    this._longestInteractionMap = new Map
  }
  _resetInteractions() {
    xs = Ds(), this._longestInteractionList.length = 0, this._longestInteractionMap.clear()
  }
  _estimateP98LongestInteraction() {
    const e = Math.min(this._longestInteractionList.length - 1, Math.floor(Lc() / 50));
    return this._longestInteractionList[e]
  }
  _processEntry(e) {
    var s, a;
    if ((s = this._onBeforeProcessingEntry) == null || s.call(this, e), !(e.interactionId || e.entryType === "first-input")) return;
    const n = this._longestInteractionList.at(-1);
    let r = this._longestInteractionMap.get(e.interactionId);
    if (r || this._longestInteractionList.length < un || e.duration > n._latency) {
      if (r ? e.duration > r._latency ? (r.entries = [e], r._latency = e.duration) : e.duration === r._latency && e.startTime === r.entries[0].startTime && r.entries.push(e) : (r = {
          id: e.interactionId,
          entries: [e],
          _latency: e.duration
        }, this._longestInteractionMap.set(r.id, r), this._longestInteractionList.push(r)), this._longestInteractionList.sort((i, o) => o._latency - i._latency), this._longestInteractionList.length > un) {
        const i = this._longestInteractionList.splice(un);
        for (const o of i) this._longestInteractionMap.delete(o.id)
      }(a = this._onAfterProcessingINPCandidate) == null || a.call(this, r)
    }
  }
}
const Gn = t => {
    const e = n => {
      var r;
      (n.type === "pagehide" || ((r = _.document) == null ? void 0 : r.visibilityState) === "hidden") && t(n)
    };
    _.document && (addEventListener("visibilitychange", e, !0), addEventListener("pagehide", e, !0))
  },
  Fs = t => {
    var n;
    const e = _.requestIdleCallback || _.setTimeout;
    ((n = _.document) == null ? void 0 : n.visibilityState) === "hidden" ? t(): (t = Vn(t), e(t), Gn(t))
  },
  Cc = [200, 500],
  Oc = 40,
  Dc = (t, e = {}) => {
    globalThis.PerformanceEventTiming && "interactionId" in PerformanceEventTiming.prototype && Wt(() => {
      Nc();
      const n = dt("INP");
      let r;
      const s = jn(e, xt),
        a = o => {
          Fs(() => {
            for (const u of o) s._processEntry(u);
            const c = s._estimateP98LongestInteraction();
            c && c._latency !== n.value && (n.value = c._latency, n.entries = c.entries, r())
          })
        },
        i = Ve("event", a, {
          durationThreshold: e.durationThreshold ?? Oc
        });
      r = ct(t, n, Cc, e.reportAllChanges), i && (i.observe({
        type: "first-input",
        buffered: !0
      }), Gn(() => {
        a(i.takeRecords()), r(!0)
      }))
    })
  };
class xc {
  _processEntry(e) {
    var n;
    (n = this._onBeforeProcessingEntry) == null || n.call(this, e)
  }
}
const Fc = [2500, 4e3],
  Mc = (t, e = {}) => {
    Wt(() => {
      const n = Wn(),
        r = dt("LCP");
      let s;
      const a = jn(e, xc),
        i = c => {
          e.reportAllChanges || (c = c.slice(-1));
          for (const u of c) a._processEntry(u), u.startTime < n.firstHiddenTime && (r.value = Math.max(u.startTime - je(), 0), r.entries = [u], s())
        },
        o = Ve("largest-contentful-paint", i);
      if (o) {
        s = ct(t, r, Fc, e.reportAllChanges);
        const c = Vn(() => {
          i(o.takeRecords()), o.disconnect(), s(!0)
        });
        for (const u of ["keydown", "click", "visibilitychange"]) _.document && addEventListener(u, () => Fs(c), {
          capture: !0,
          once: !0
        })
      }
    })
  },
  Hc = [800, 1800],
  wn = t => {
    var e, n;
    (e = _.document) != null && e.prerendering ? Wt(() => wn(t)) : ((n = _.document) == null ? void 0 : n.readyState) !== "complete" ? addEventListener("load", () => wn(t), !0) : setTimeout(t)
  },
  Bc = (t, e = {}) => {
    const n = dt("TTFB"),
      r = ct(t, n, Hc, e.reportAllChanges);
    wn(() => {
      const s = ut();
      s && (n.value = Math.max(s.responseStart - je(), 0), n.entries = [s], r(!0))
    })
  },
  Qe = {},
  Ft = {};
let Ms, Hs, Bs, $s;

function Us(t, e = !1) {
  return Gt("cls", t, qc, Ms, e)
}

function qs(t, e = !1) {
  return Gt("lcp", t, jc, Hs, e)
}

function $c(t) {
  return Gt("ttfb", t, Vc, Bs)
}

function Uc(t) {
  return Gt("inp", t, Wc, $s)
}

function $e(t, e) {
  return js(t, e), Ft[t] || (Gc(t), Ft[t] = !0), Vs(t, e)
}

function lt(t, e) {
  const n = Qe[t];
  if (n != null && n.length)
    for (const r of n) try {
      r(e)
    } catch (s) {
      Vt && g.error(`Error while triggering instrumentation handler.
Type: ${t}
Name: ${_e(r)}
Error:`, s)
    }
}

function qc() {
  return Pc(t => {
    lt("cls", {
      metric: t
    }), Ms = t
  }, {
    reportAllChanges: !0
  })
}

function jc() {
  return Mc(t => {
    lt("lcp", {
      metric: t
    }), Hs = t
  }, {
    reportAllChanges: !0
  })
}

function Vc() {
  return Bc(t => {
    lt("ttfb", {
      metric: t
    }), Bs = t
  })
}

function Wc() {
  return Dc(t => {
    lt("inp", {
      metric: t
    }), $s = t
  })
}

function Gt(t, e, n, r, s = !1) {
  js(t, e);
  let a;
  return Ft[t] || (a = n(), Ft[t] = !0), r && e({
    metric: r
  }), Vs(t, e, s ? a : void 0)
}

function Gc(t) {
  const e = {};
  t === "event" && (e.durationThreshold = 0), Ve(t, n => {
    lt(t, {
      entries: n
    })
  }, e)
}

function js(t, e) {
  Qe[t] = Qe[t] || [], Qe[t].push(e)
}

function Vs(t, e, n) {
  return () => {
    n && n();
    const r = Qe[t];
    if (!r) return;
    const s = r.indexOf(e);
    s !== -1 && r.splice(s, 1)
  }
}

function Yc(t) {
  return "duration" in t
}

function dn(t) {
  return typeof t == "number" && isFinite(t)
}

function Te(t, e, n, {
  ...r
}) {
  const s = R(t).start_timestamp;
  return s && s > e && typeof t.updateStartTime == "function" && t.updateStartTime(e), Fn(t, () => {
    const a = De({
      startTime: e,
      ...r
    });
    return a && a.end(n), a
  })
}

function Yn(t) {
  var D;
  const e = N();
  if (!e) return;
  const {
    name: n,
    transaction: r,
    attributes: s,
    startTime: a
  } = t, {
    release: i,
    environment: o,
    sendDefaultPii: c
  } = e.getOptions(), u = e.getIntegrationByName("Replay"), l = u == null ? void 0 : u.getReplayId(), d = C(), p = d.getUser(), f = p !== void 0 ? p.email || p.id || p.ip_address : void 0;
  let m;
  try {
    m = d.getScopeData().contexts.profile.profile_id
  } catch {}
  const h = {
    release: i,
    environment: o,
    user: f || void 0,
    profile_id: m || void 0,
    replay_id: l || void 0,
    transaction: r,
    "user_agent.original": (D = _.navigator) == null ? void 0 : D.userAgent,
    "client.address": c ? "{{auto}}" : void 0,
    ...s
  };
  return De({
    name: n,
    attributes: h,
    startTime: a,
    experimental: {
      standalone: !0
    }
  })
}

function Yt() {
  return _.addEventListener && _.performance
}

function O(t) {
  return t / 1e3
}

function Ws(t) {
  let e = "unknown",
    n = "unknown",
    r = "";
  for (const s of t) {
    if (s === "/") {
      [e, n] = t.split("/");
      break
    }
    if (!isNaN(Number(s))) {
      e = r === "h" ? "http" : r, n = t.split(r)[1];
      break
    }
    r += s
  }
  return r === t && (e = r), {
    name: e,
    version: n
  }
}

function Gs(t) {
  try {
    return PerformanceObserver.supportedEntryTypes.includes(t)
  } catch {
    return !1
  }
}

function Ys(t, e) {
  let n, r = !1;

  function s(o) {
    !r && n && e(o, n), r = !0
  }
  Gn(() => {
    s("pagehide")
  });
  const a = t.on("beforeStartNavigationSpan", (o, c) => {
      c != null && c.isRedirect || (s("navigation"), Lr(a, i))
    }),
    i = t.on("afterStartPageLoadSpan", o => {
      n = o.spanContext().spanId, Lr(i)
    })
}

function Lr(...t) {
  t.forEach(e => e && setTimeout(e, 0))
}

function zc(t) {
  let e = 0,
    n;
  if (!Gs("layout-shift")) return;
  const r = Us(({
    metric: s
  }) => {
    const a = s.entries[s.entries.length - 1];
    a && (e = s.value, n = a)
  }, !0);
  Ys(t, (s, a) => {
    Xc(e, n, a, s), r()
  })
}

function Xc(t, e, n, r) {
  var u;
  Vt && g.log(`Sending CLS span (${t})`);
  const s = O((Y() || 0) + ((e == null ? void 0 : e.startTime) || 0)),
    a = C().getScopeData().transactionName,
    i = e ? pe((u = e.sources[0]) == null ? void 0 : u.node) : "Layout shift",
    o = {
      [x]: "auto.http.browser.cls",
      [Ee]: "ui.webvital.cls",
      [Ue]: (e == null ? void 0 : e.duration) || 0,
      "sentry.pageload.span_id": n,
      "sentry.report_event": r
    };
  e != null && e.sources && e.sources.forEach((l, d) => {
    o[`cls.source.${d+1}`] = pe(l.node)
  });
  const c = Yn({
    name: i,
    transaction: a,
    attributes: o,
    startTime: s
  });
  c && (c.addEvent("cls", {
    [at]: "",
    [it]: t
  }), c.end(s))
}

function Jc(t) {
  let e = 0,
    n;
  if (!Gs("largest-contentful-paint")) return;
  const r = qs(({
    metric: s
  }) => {
    const a = s.entries[s.entries.length - 1];
    a && (e = s.value, n = a)
  }, !0);
  Ys(t, (s, a) => {
    Kc(e, n, a, s), r()
  })
}

function Kc(t, e, n, r) {
  Vt && g.log(`Sending LCP span (${t})`);
  const s = O((Y() || 0) + ((e == null ? void 0 : e.startTime) || 0)),
    a = C().getScopeData().transactionName,
    i = e ? pe(e.element) : "Largest contentful paint",
    o = {
      [x]: "auto.http.browser.lcp",
      [Ee]: "ui.webvital.lcp",
      [Ue]: 0,
      "sentry.pageload.span_id": n,
      "sentry.report_event": r
    };
  e && (e.element && (o["lcp.element"] = pe(e.element)), e.id && (o["lcp.id"] = e.id), e.url && (o["lcp.url"] = e.url.trim().slice(0, 200)), e.loadTime != null && (o["lcp.loadTime"] = e.loadTime), e.renderTime != null && (o["lcp.renderTime"] = e.renderTime), e.size != null && (o["lcp.size"] = e.size));
  const c = Yn({
    name: i,
    transaction: a,
    attributes: o,
    startTime: s
  });
  c && (c.addEvent("lcp", {
    [at]: "millisecond",
    [it]: t
  }), c.end(s))
}
const Qc = 2147483647;
let Cr = 0,
  re = {},
  U, xe;

function Zc({
  recordClsStandaloneSpans: t,
  recordLcpStandaloneSpans: e,
  client: n
}) {
  const r = Yt();
  if (r && Y()) {
    r.mark && _.performance.mark("sentry-tracing-init");
    const s = e ? Jc(n) : su(),
      a = au(),
      i = t ? zc(n) : ru();
    return () => {
      s == null || s(), a(), i == null || i()
    }
  }
  return () => {}
}

function eu() {
  $e("longtask", ({
    entries: t
  }) => {
    const e = G();
    if (!e) return;
    const {
      op: n,
      start_timestamp: r
    } = R(e);
    for (const s of t) {
      const a = O(Y() + s.startTime),
        i = O(s.duration);
      n === "navigation" && r && a < r || Te(e, a, a + i, {
        name: "Main UI thread blocked",
        op: "ui.long-task",
        attributes: {
          [x]: "auto.ui.browser.metrics"
        }
      })
    }
  })
}

function tu() {
  new PerformanceObserver(e => {
    const n = G();
    if (n)
      for (const r of e.getEntries()) {
        if (!r.scripts[0]) continue;
        const s = O(Y() + r.startTime),
          {
            start_timestamp: a,
            op: i
          } = R(n);
        if (i === "navigation" && a && s < a) continue;
        const o = O(r.duration),
          c = {
            [x]: "auto.ui.browser.metrics"
          },
          u = r.scripts[0],
          {
            invoker: l,
            invokerType: d,
            sourceURL: p,
            sourceFunctionName: f,
            sourceCharPosition: m
          } = u;
        c["browser.script.invoker"] = l, c["browser.script.invoker_type"] = d, p && (c["code.filepath"] = p), f && (c["code.function"] = f), m !== -1 && (c["browser.script.source_char_position"] = m), Te(n, s, s + o, {
          name: "Main UI thread blocked",
          op: "ui.long-animation-frame",
          attributes: c
        })
      }
  }).observe({
    type: "long-animation-frame",
    buffered: !0
  })
}

function nu() {
  $e("event", ({
    entries: t
  }) => {
    const e = G();
    if (e) {
      for (const n of t)
        if (n.name === "click") {
          const r = O(Y() + n.startTime),
            s = O(n.duration),
            a = {
              name: pe(n.target),
              op: `ui.interaction.${n.name}`,
              startTime: r,
              attributes: {
                [x]: "auto.ui.browser.metrics"
              }
            },
            i = as(n.target);
          i && (a.attributes["ui.component_name"] = i), Te(e, r, r + s, a)
        }
    }
  })
}

function ru() {
  return Us(({
    metric: t
  }) => {
    const e = t.entries[t.entries.length - 1];
    e && (re.cls = {
      value: t.value,
      unit: ""
    }, xe = e)
  }, !0)
}

function su() {
  return qs(({
    metric: t
  }) => {
    const e = t.entries[t.entries.length - 1];
    e && (re.lcp = {
      value: t.value,
      unit: "millisecond"
    }, U = e)
  }, !0)
}

function au() {
  return $c(({
    metric: t
  }) => {
    t.entries[t.entries.length - 1] && (re.ttfb = {
      value: t.value,
      unit: "millisecond"
    })
  })
}

function iu(t, e) {
  const n = Yt(),
    r = Y();
  if (!(n != null && n.getEntries) || !r) return;
  const s = O(r),
    a = n.getEntries(),
    {
      op: i,
      start_timestamp: o
    } = R(t);
  a.slice(Cr).forEach(c => {
    const u = O(c.startTime),
      l = O(Math.max(0, c.duration));
    if (!(i === "navigation" && o && s + u < o)) switch (c.entryType) {
      case "navigation": {
        uu(t, c, s);
        break
      }
      case "mark":
      case "paint":
      case "measure": {
        ou(t, c, u, l, s, e.ignorePerformanceApiSpans);
        const d = Wn(),
          p = c.startTime < d.firstHiddenTime;
        c.name === "first-paint" && p && (re.fp = {
          value: c.startTime,
          unit: "millisecond"
        }), c.name === "first-contentful-paint" && p && (re.fcp = {
          value: c.startTime,
          unit: "millisecond"
        });
        break
      }
      case "resource": {
        fu(t, c, c.name, u, l, s, e.ignoreResourceSpans);
        break
      }
    }
  }), Cr = Math.max(a.length - 1, 0), pu(t), i === "pageload" && (gu(re), e.recordClsOnPageloadSpan || delete re.cls, e.recordLcpOnPageloadSpan || delete re.lcp, Object.entries(re).forEach(([c, u]) => {
    Ri(c, u.value, u.unit)
  }), t.setAttribute("performance.timeOrigin", s), t.setAttribute("performance.activationStart", je()), mu(t, e)), U = void 0, xe = void 0, re = {}
}

function ou(t, e, n, r, s, a) {
  if (["mark", "measure"].includes(e.entryType) && he(e.name, a)) return;
  const i = ut(!1),
    o = O(i ? i.requestStart : 0),
    c = s + Math.max(n, o),
    u = s + n,
    l = u + r,
    d = {
      [x]: "auto.resource.browser.metrics"
    };
  c !== u && (d["sentry.browser.measure_happened_before_request"] = !0, d["sentry.browser.measure_start_time"] = c), cu(d, e), c <= l && Te(t, c, l, {
    name: e.name,
    op: e.entryType,
    attributes: d
  })
}

function cu(t, e) {
  try {
    const n = e.detail;
    if (!n) return;
    if (typeof n == "object") {
      for (const [r, s] of Object.entries(n))
        if (s && Ze(s)) t[`sentry.browser.measure.detail.${r}`] = s;
        else if (s !== void 0) try {
        t[`sentry.browser.measure.detail.${r}`] = JSON.stringify(s)
      } catch {}
      return
    }
    if (Ze(n)) {
      t["sentry.browser.measure.detail"] = n;
      return
    }
    try {
      t["sentry.browser.measure.detail"] = JSON.stringify(n)
    } catch {}
  } catch {}
}

function uu(t, e, n) {
  ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(r => {
    ht(t, e, r, n)
  }), ht(t, e, "secureConnection", n, "TLS/SSL"), ht(t, e, "fetch", n, "cache"), ht(t, e, "domainLookup", n, "DNS"), lu(t, e, n)
}

function ht(t, e, n, r, s = n) {
  const a = du(n),
    i = e[a],
    o = e[`${n}Start`];
  !o || !i || Te(t, r + O(o), r + O(i), {
    op: `browser.${s}`,
    name: e.name,
    attributes: {
      [x]: "auto.ui.browser.metrics",
      ...n === "redirect" && e.redirectCount != null ? {
        "http.redirect_count": e.redirectCount
      } : {}
    }
  })
}

function du(t) {
  return t === "secureConnection" ? "connectEnd" : t === "fetch" ? "domainLookupStart" : `${t}End`
}

function lu(t, e, n) {
  const r = n + O(e.requestStart),
    s = n + O(e.responseEnd),
    a = n + O(e.responseStart);
  e.responseEnd && (Te(t, r, s, {
    op: "browser.request",
    name: e.name,
    attributes: {
      [x]: "auto.ui.browser.metrics"
    }
  }), Te(t, a, s, {
    op: "browser.response",
    name: e.name,
    attributes: {
      [x]: "auto.ui.browser.metrics"
    }
  }))
}

function fu(t, e, n, r, s, a, i) {
  if (e.initiatorType === "xmlhttprequest" || e.initiatorType === "fetch") return;
  const o = e.initiatorType ? `resource.${e.initiatorType}` : "resource.other";
  if (i != null && i.includes(o)) return;
  const c = ke(n),
    u = {
      [x]: "auto.resource.browser.metrics"
    };
  ln(u, e, "transferSize", "http.response_transfer_size"), ln(u, e, "encodedBodySize", "http.response_content_length"), ln(u, e, "decodedBodySize", "http.decoded_response_content_length");
  const l = e.deliveryType;
  l != null && (u["http.response_delivery_type"] = l);
  const d = e.renderBlockingStatus;
  if (d && (u["resource.render_blocking_status"] = d), c.protocol && (u["url.scheme"] = c.protocol.split(":").pop()), c.host && (u["server.address"] = c.host), u["url.same_origin"] = n.includes(_.location.origin), e.nextHopProtocol != null) {
    const {
      name: m,
      version: h
    } = Ws(e.nextHopProtocol);
    u["network.protocol.name"] = m, u["network.protocol.version"] = h
  }
  const p = a + r,
    f = p + s;
  Te(t, p, f, {
    name: n.replace(_.location.origin, ""),
    op: o,
    attributes: u
  })
}

function pu(t) {
  const e = _.navigator;
  if (!e) return;
  const n = e.connection;
  n && (n.effectiveType && t.setAttribute("effectiveConnectionType", n.effectiveType), n.type && t.setAttribute("connectionType", n.type), dn(n.rtt) && (re["connection.rtt"] = {
    value: n.rtt,
    unit: "millisecond"
  })), dn(e.deviceMemory) && t.setAttribute("deviceMemory", `${e.deviceMemory} GB`), dn(e.hardwareConcurrency) && t.setAttribute("hardwareConcurrency", String(e.hardwareConcurrency))
}

function mu(t, e) {
  U && e.recordLcpOnPageloadSpan && (U.element && t.setAttribute("lcp.element", pe(U.element)), U.id && t.setAttribute("lcp.id", U.id), U.url && t.setAttribute("lcp.url", U.url.trim().slice(0, 200)), U.loadTime != null && t.setAttribute("lcp.loadTime", U.loadTime), U.renderTime != null && t.setAttribute("lcp.renderTime", U.renderTime), t.setAttribute("lcp.size", U.size)), xe != null && xe.sources && e.recordClsOnPageloadSpan && xe.sources.forEach((n, r) => t.setAttribute(`cls.source.${r+1}`, pe(n.node)))
}

function ln(t, e, n, r) {
  const s = e[n];
  s != null && s < Qc && (t[r] = s)
}

function gu(t) {
  const e = ut(!1);
  if (!e) return;
  const {
    responseStart: n,
    requestStart: r
  } = e;
  r <= n && (t["ttfb.requestTime"] = {
    value: n - r,
    unit: "millisecond"
  })
}

function hu() {
  return Yt() && Y() ? $e("element", _u) : () => {}
}
const _u = ({
    entries: t
  }) => {
    const e = G(),
      n = e ? W(e) : void 0,
      r = n ? R(n).description : C().getScopeData().transactionName;
    t.forEach(s => {
      var f, m;
      const a = s;
      if (!a.identifier) return;
      const i = a.name,
        o = a.renderTime,
        c = a.loadTime,
        [u, l] = c ? [O(c), "load-time"] : o ? [O(o), "render-time"] : [q(), "entry-emission"],
        d = i === "image-paint" ? O(Math.max(0, (o ?? 0) - (c ?? 0))) : 0,
        p = {
          [x]: "auto.ui.browser.elementtiming",
          [Ee]: "ui.elementtiming",
          [Z]: "component",
          "sentry.span_start_time_source": l,
          "sentry.transaction_name": r,
          "element.id": a.id,
          "element.type": ((m = (f = a.element) == null ? void 0 : f.tagName) == null ? void 0 : m.toLowerCase()) || "unknown",
          "element.size": a.naturalWidth && a.naturalHeight ? `${a.naturalWidth}x${a.naturalHeight}` : void 0,
          "element.render_time": o,
          "element.load_time": c,
          "element.url": a.url || void 0,
          "element.identifier": a.identifier,
          "element.paint_type": i
        };
      Li({
        name: `element[${a.identifier}]`,
        attributes: p,
        startTime: u,
        onlyIfParent: !0
      }, h => {
        h.end(u + d)
      })
    })
  },
  Eu = 1e3;
let Or, An, Pn;

function Su(t) {
  ye("dom", t), ve("dom", Tu)
}

function Tu() {
  if (!_.document) return;
  const t = ee.bind(null, "dom"),
    e = Dr(t, !0);
  _.document.addEventListener("click", e, !1), _.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach(n => {
    var a, i;
    const s = (a = _[n]) == null ? void 0 : a.prototype;
    (i = s == null ? void 0 : s.hasOwnProperty) != null && i.call(s, "addEventListener") && (V(s, "addEventListener", function(o) {
      return function(c, u, l) {
        if (c === "click" || c == "keypress") try {
          const d = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {},
            p = d[c] = d[c] || {
              refCount: 0
            };
          if (!p.handler) {
            const f = Dr(t);
            p.handler = f, o.call(this, c, f, l)
          }
          p.refCount++
        } catch {}
        return o.call(this, c, u, l)
      }
    }), V(s, "removeEventListener", function(o) {
      return function(c, u, l) {
        if (c === "click" || c == "keypress") try {
          const d = this.__sentry_instrumentation_handlers__ || {},
            p = d[c];
          p && (p.refCount--, p.refCount <= 0 && (o.call(this, c, p.handler, l), p.handler = void 0, delete d[c]), Object.keys(d).length === 0 && delete this.__sentry_instrumentation_handlers__)
        } catch {}
        return o.call(this, c, u, l)
      }
    }))
  })
}

function yu(t) {
  if (t.type !== An) return !1;
  try {
    if (!t.target || t.target._sentryId !== Pn) return !1
  } catch {}
  return !0
}

function vu(t, e) {
  return t !== "keypress" ? !1 : e != null && e.tagName ? !(e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.isContentEditable) : !0
}

function Dr(t, e = !1) {
  return n => {
    if (!n || n._sentryCaptured) return;
    const r = bu(n);
    if (vu(n.type, r)) return;
    et(n, "_sentryCaptured", !0), r && !r._sentryId && et(r, "_sentryId", yt());
    const s = n.type === "keypress" ? "input" : n.type;
    yu(n) || (t({
      event: n,
      name: s,
      global: e
    }), An = n.type, Pn = r ? r._sentryId : void 0), clearTimeout(Or), Or = _.setTimeout(() => {
      Pn = void 0, An = void 0
    }, Eu)
  }
}

function bu(t) {
  try {
    return t.target
  } catch {
    return null
  }
}
let _t;

function zn(t) {
  const e = "history";
  ye(e, t), ve(e, Iu)
}

function Iu() {
  if (_.addEventListener("popstate", () => {
      const e = _.location.href,
        n = _t;
      if (_t = e, n === e) return;
      ee("history", {
        from: n,
        to: e
      })
    }), !Jo()) return;

  function t(e) {
    return function(...n) {
      const r = n.length > 2 ? n[2] : void 0;
      if (r) {
        const s = _t,
          a = Ru(String(r));
        if (_t = a, s === a) return e.apply(this, n);
        ee("history", {
          from: s,
          to: a
        })
      }
      return e.apply(this, n)
    }
  }
  V(_.history, "pushState", t), V(_.history, "replaceState", t)
}

function Ru(t) {
  try {
    return new URL(t, _.location.origin).toString()
  } catch {
    return t
  }
}
const wt = {};

function wu(t) {
  const e = wt[t];
  if (e) return e;
  let n = _[t];
  if (yn(n)) return wt[t] = n.bind(_);
  const r = _.document;
  if (r && typeof r.createElement == "function") try {
    const s = r.createElement("iframe");
    s.hidden = !0, r.head.appendChild(s);
    const a = s.contentWindow;
    a != null && a[t] && (n = a[t]), r.head.removeChild(s)
  } catch (s) {
    Vt && g.warn(`Could not create sandbox iframe for ${t} check, bailing to window.${t}: `, s)
  }
  return n && (wt[t] = n.bind(_))
}

function xr(t) {
  wt[t] = void 0
}
const Fe = "__sentry_xhr_v3__";

function zs(t) {
  ye("xhr", t), ve("xhr", Au)
}

function Au() {
  if (!_.XMLHttpRequest) return;
  const t = XMLHttpRequest.prototype;
  t.open = new Proxy(t.open, {
    apply(e, n, r) {
      const s = new Error,
        a = q() * 1e3,
        i = Je(r[0]) ? r[0].toUpperCase() : void 0,
        o = Pu(r[1]);
      if (!i || !o) return e.apply(n, r);
      n[Fe] = {
        method: i,
        url: o,
        request_headers: {}
      }, i === "POST" && o.match(/sentry_key/) && (n.__sentry_own_request__ = !0);
      const c = () => {
        const u = n[Fe];
        if (u && n.readyState === 4) {
          try {
            u.status_code = n.status
          } catch {}
          const l = {
            endTimestamp: q() * 1e3,
            startTimestamp: a,
            xhr: n,
            virtualError: s
          };
          ee("xhr", l)
        }
      };
      return "onreadystatechange" in n && typeof n.onreadystatechange == "function" ? n.onreadystatechange = new Proxy(n.onreadystatechange, {
        apply(u, l, d) {
          return c(), u.apply(l, d)
        }
      }) : n.addEventListener("readystatechange", c), n.setRequestHeader = new Proxy(n.setRequestHeader, {
        apply(u, l, d) {
          const [p, f] = d, m = l[Fe];
          return m && Je(p) && Je(f) && (m.request_headers[p.toLowerCase()] = f), u.apply(l, d)
        }
      }), e.apply(n, r)
    }
  }), t.send = new Proxy(t.send, {
    apply(e, n, r) {
      const s = n[Fe];
      if (!s) return e.apply(n, r);
      r[0] !== void 0 && (s.body = r[0]);
      const a = {
        startTimestamp: q() * 1e3,
        xhr: n
      };
      return ee("xhr", a), e.apply(n, r)
    }
  })
}

function Pu(t) {
  if (Je(t)) return t;
  try {
    return t.toString()
  } catch {}
}
const fn = [],
  At = new Map,
  ku = 60;

function Nu() {
  if (Yt() && Y()) {
    const e = Lu();
    return () => {
      e()
    }
  }
  return () => {}
}
const Fr = {
  click: "click",
  pointerdown: "click",
  pointerup: "click",
  mousedown: "click",
  mouseup: "click",
  touchstart: "click",
  touchend: "click",
  mouseover: "hover",
  mouseout: "hover",
  mouseenter: "hover",
  mouseleave: "hover",
  pointerover: "hover",
  pointerout: "hover",
  pointerenter: "hover",
  pointerleave: "hover",
  dragstart: "drag",
  dragend: "drag",
  drag: "drag",
  dragenter: "drag",
  dragleave: "drag",
  dragover: "drag",
  drop: "drag",
  keydown: "press",
  keyup: "press",
  keypress: "press",
  input: "press"
};

function Lu() {
  return Uc(Cu)
}
const Cu = ({
  metric: t
}) => {
  if (t.value == null) return;
  const e = O(t.value);
  if (e > ku) return;
  const n = t.entries.find(m => m.duration === t.value && Fr[m.name]);
  if (!n) return;
  const {
    interactionId: r
  } = n, s = Fr[n.name], a = O(Y() + n.startTime), i = G(), o = i ? W(i) : void 0, u = (r != null ? At.get(r) : void 0) || o, l = u ? R(u).description : C().getScopeData().transactionName, d = pe(n.target), p = {
    [x]: "auto.http.browser.inp",
    [Ee]: `ui.interaction.${s}`,
    [Ue]: n.duration
  }, f = Yn({
    name: d,
    transaction: l,
    attributes: p,
    startTime: a
  });
  f && (f.addEvent("inp", {
    [at]: "millisecond",
    [it]: t.value
  }), f.end(a + e))
};

function Ou() {
  const t = ({
    entries: e
  }) => {
    const n = G(),
      r = n && W(n);
    e.forEach(s => {
      if (!Yc(s) || !r) return;
      const a = s.interactionId;
      if (a != null && !At.has(a)) {
        if (fn.length > 10) {
          const i = fn.shift();
          At.delete(i)
        }
        fn.push(a), At.set(a, r)
      }
    })
  };
  $e("event", t), $e("first-input", t)
}

function Du(t, e = wu("fetch")) {
  let n = 0,
    r = 0;

  function s(a) {
    const i = a.body.length;
    n += i, r++;
    const o = {
      body: a.body,
      method: "POST",
      referrerPolicy: "strict-origin",
      headers: t.headers,
      keepalive: n <= 6e4 && r < 15,
      ...t.fetchOptions
    };
    if (!e) return xr("fetch"), Nt("No fetch implementation available");
    try {
      return e(t.url, o).then(c => (n -= i, r--, {
        statusCode: c.status,
        headers: {
          "x-sentry-rate-limits": c.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": c.headers.get("Retry-After")
        }
      }))
    } catch (c) {
      return xr("fetch"), n -= i, r--, Nt(c)
    }
  }
  return fo(t, s)
}
const xu = 30,
  Fu = 50;

function kn(t, e, n, r) {
  const s = {
    filename: t,
    function: e === "<anonymous>" ? He : e,
    in_app: !0
  };
  return n !== void 0 && (s.lineno = n), r !== void 0 && (s.colno = r), s
}
const Mu = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i,
  Hu = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
  Bu = /\((\S*)(?::(\d+))(?::(\d+))\)/,
  $u = /at (.+?) ?\(data:(.+?),/,
  Uu = t => {
    const e = t.match($u);
    if (e) return {
      filename: `<data:${e[2]}>`,
      function: e[1]
    };
    const n = Mu.exec(t);
    if (n) {
      const [, s, a, i] = n;
      return kn(s, He, +a, +i)
    }
    const r = Hu.exec(t);
    if (r) {
      if (r[2] && r[2].indexOf("eval") === 0) {
        const o = Bu.exec(r[2]);
        o && (r[2] = o[1], r[3] = o[2], r[4] = o[3])
      }
      const [a, i] = Xs(r[1] || He, r[2]);
      return kn(i, a, r[3] ? +r[3] : void 0, r[4] ? +r[4] : void 0)
    }
  },
  qu = [xu, Uu],
  ju = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
  Vu = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
  Wu = t => {
    const e = ju.exec(t);
    if (e) {
      if (e[3] && e[3].indexOf(" > eval") > -1) {
        const a = Vu.exec(e[3]);
        a && (e[1] = e[1] || "eval", e[3] = a[1], e[4] = a[2], e[5] = "")
      }
      let r = e[3],
        s = e[1] || He;
      return [s, r] = Xs(s, r), kn(r, s, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
    }
  },
  Gu = [Fu, Wu],
  Yu = [qu, Gu],
  zu = Da(...Yu),
  Xs = (t, e) => {
    const n = t.indexOf("safari-extension") !== -1,
      r = t.indexOf("safari-web-extension") !== -1;
    return n || r ? [t.indexOf("@") !== -1 ? t.split("@")[0] : He, n ? `safari-extension:${e}` : `safari-web-extension:${e}`] : [t, e]
  },
  te = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  Et = 1024,
  Xu = "Breadcrumbs",
  Ju = ((t = {}) => {
    const e = {
      console: !0,
      dom: !0,
      fetch: !0,
      history: !0,
      sentry: !0,
      xhr: !0,
      ...t
    };
    return {
      name: Xu,
      setup(n) {
        e.console && xo(ed(n)), e.dom && Su(Zu(n, e.dom)), e.xhr && zs(td(n)), e.fetch && ks(nd(n)), e.history && zn(rd(n)), e.sentry && n.on("beforeSendEvent", Qu(n))
      }
    }
  }),
  Ku = Ju;

function Qu(t) {
  return function(n) {
    N() === t && Oe({
      category: `sentry.${n.type==="transaction"?"transaction":"event"}`,
      event_id: n.event_id,
      level: n.level,
      message: Pe(n)
    }, {
      event: n
    })
  }
}

function Zu(t, e) {
  return function(r) {
    if (N() !== t) return;
    let s, a, i = typeof e == "object" ? e.serializeAttribute : void 0,
      o = typeof e == "object" && typeof e.maxStringLength == "number" ? e.maxStringLength : void 0;
    o && o > Et && (te && g.warn(`\`dom.maxStringLength\` cannot exceed ${Et}, but a value of ${o} was configured. Sentry will use ${Et} instead.`), o = Et), typeof i == "string" && (i = [i]);
    try {
      const u = r.event,
        l = sd(u) ? u.target : u;
      s = pe(l, {
        keyAttrs: i,
        maxStringLength: o
      }), a = as(l)
    } catch {
      s = "<unknown>"
    }
    if (s.length === 0) return;
    const c = {
      category: `ui.${r.name}`,
      message: s
    };
    a && (c.data = {
      "ui.component_name": a
    }), Oe(c, {
      event: r.event,
      name: r.name,
      global: r.global
    })
  }
}

function ed(t) {
  return function(n) {
    if (N() !== t) return;
    const r = {
      category: "console",
      data: {
        arguments: n.args,
        logger: "console"
      },
      level: Mo(n.level),
      message: ir(n.args, " ")
    };
    if (n.level === "assert")
      if (n.args[0] === !1) r.message = `Assertion failed: ${ir(n.args.slice(1)," ")||"console.assert"}`, r.data.arguments = n.args.slice(1);
      else return;
    Oe(r, {
      input: n.args,
      level: n.level
    })
  }
}

function td(t) {
  return function(n) {
    if (N() !== t) return;
    const {
      startTimestamp: r,
      endTimestamp: s
    } = n, a = n.xhr[Fe];
    if (!r || !s || !a) return;
    const {
      method: i,
      url: o,
      status_code: c,
      body: u
    } = a, l = {
      method: i,
      url: o,
      status_code: c
    }, d = {
      xhr: n.xhr,
      input: u,
      startTimestamp: r,
      endTimestamp: s
    }, p = {
      category: "xhr",
      data: l,
      type: "http",
      level: Ps(c)
    };
    t.emit("beforeOutgoingRequestBreadcrumb", p, d), Oe(p, d)
  }
}

function nd(t) {
  return function(n) {
    if (N() !== t) return;
    const {
      startTimestamp: r,
      endTimestamp: s
    } = n;
    if (s && !(n.fetchData.url.match(/sentry_key/) && n.fetchData.method === "POST"))
      if (n.fetchData.method, n.fetchData.url, n.error) {
        const a = n.fetchData,
          i = {
            data: n.error,
            input: n.args,
            startTimestamp: r,
            endTimestamp: s
          },
          o = {
            category: "fetch",
            data: a,
            level: "error",
            type: "http"
          };
        t.emit("beforeOutgoingRequestBreadcrumb", o, i), Oe(o, i)
      } else {
        const a = n.response,
          i = {
            ...n.fetchData,
            status_code: a == null ? void 0 : a.status
          };
        n.fetchData.request_body_size, n.fetchData.response_body_size, a == null || a.status;
        const o = {
            input: n.args,
            response: a,
            startTimestamp: r,
            endTimestamp: s
          },
          c = {
            category: "fetch",
            data: i,
            type: "http",
            level: Ps(i.status_code)
          };
        t.emit("beforeOutgoingRequestBreadcrumb", c, o), Oe(c, o)
      }
  }
}

function rd(t) {
  return function(n) {
    if (N() !== t) return;
    let r = n.from,
      s = n.to;
    const a = ke(T.location.href);
    let i = r ? ke(r) : void 0;
    const o = ke(s);
    i != null && i.path || (i = a), a.protocol === o.protocol && a.host === o.host && (s = o.relative), a.protocol === i.protocol && a.host === i.host && (r = i.relative), Oe({
      category: "navigation",
      data: {
        from: r,
        to: s
      }
    })
  }
}

function sd(t) {
  return !!t && !!t.target
}
const ad = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"],
  id = "BrowserApiErrors",
  od = ((t = {}) => {
    const e = {
      XMLHttpRequest: !0,
      eventTarget: !0,
      requestAnimationFrame: !0,
      setInterval: !0,
      setTimeout: !0,
      unregisterOriginalCallbacks: !1,
      ...t
    };
    return {
      name: id,
      setupOnce() {
        e.setTimeout && V(T, "setTimeout", Mr), e.setInterval && V(T, "setInterval", Mr), e.requestAnimationFrame && V(T, "requestAnimationFrame", ud), e.XMLHttpRequest && "XMLHttpRequest" in T && V(XMLHttpRequest.prototype, "send", dd);
        const n = e.eventTarget;
        n && (Array.isArray(n) ? n : ad).forEach(s => ld(s, e))
      }
    }
  }),
  cd = od;

function Mr(t) {
  return function(...e) {
    const n = e[0];
    return e[0] = Be(n, {
      mechanism: {
        handled: !1,
        type: `auto.browser.browserapierrors.${_e(t)}`
      }
    }), t.apply(this, e)
  }
}

function ud(t) {
  return function(e) {
    return t.apply(this, [Be(e, {
      mechanism: {
        data: {
          handler: _e(t)
        },
        handled: !1,
        type: "auto.browser.browserapierrors.requestAnimationFrame"
      }
    })])
  }
}

function dd(t) {
  return function(...e) {
    const n = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(s => {
      s in n && typeof n[s] == "function" && V(n, s, function(a) {
        const i = {
            mechanism: {
              data: {
                handler: _e(a)
              },
              handled: !1,
              type: `auto.browser.browserapierrors.xhr.${s}`
            }
          },
          o = Dn(a);
        return o && (i.mechanism.data.handler = _e(o)), Be(a, i)
      })
    }), t.apply(this, e)
  }
}

function ld(t, e) {
  var s, a;
  const r = (s = T[t]) == null ? void 0 : s.prototype;
  (a = r == null ? void 0 : r.hasOwnProperty) != null && a.call(r, "addEventListener") && (V(r, "addEventListener", function(i) {
    return function(o, c, u) {
      try {
        fd(c) && (c.handleEvent = Be(c.handleEvent, {
          mechanism: {
            data: {
              handler: _e(c),
              target: t
            },
            handled: !1,
            type: "auto.browser.browserapierrors.handleEvent"
          }
        }))
      } catch {}
      return e.unregisterOriginalCallbacks && pd(this, o, c), i.apply(this, [o, Be(c, {
        mechanism: {
          data: {
            handler: _e(c),
            target: t
          },
          handled: !1,
          type: "auto.browser.browserapierrors.addEventListener"
        }
      }), u])
    }
  }), V(r, "removeEventListener", function(i) {
    return function(o, c, u) {
      try {
        const l = c.__sentry_wrapped__;
        l && i.call(this, o, l, u)
      } catch {}
      return i.call(this, o, c, u)
    }
  }))
}

function fd(t) {
  return typeof t.handleEvent == "function"
}

function pd(t, e, n) {
  t && typeof t == "object" && "removeEventListener" in t && typeof t.removeEventListener == "function" && t.removeEventListener(e, n)
}
const md = () => ({
    name: "BrowserSession",
    setupOnce() {
      if (typeof T.document > "u") {
        te && g.warn("Using the `browserSessionIntegration` in non-browser environments is not supported.");
        return
      }
      or({
        ignoreDuration: !0
      }), cr(), zn(({
        from: t,
        to: e
      }) => {
        t !== void 0 && t !== e && (or({
          ignoreDuration: !0
        }), cr())
      })
    }
  }),
  gd = "GlobalHandlers",
  hd = ((t = {}) => {
    const e = {
      onerror: !0,
      onunhandledrejection: !0,
      ...t
    };
    return {
      name: gd,
      setupOnce() {
        Error.stackTraceLimit = 50
      },
      setup(n) {
        e.onerror && (Ed(n), Hr("onerror")), e.onunhandledrejection && (Sd(n), Hr("onunhandledrejection"))
      }
    }
  }),
  _d = hd;

function Ed(t) {
  cs(e => {
    const {
      stackParser: n,
      attachStacktrace: r
    } = Js();
    if (N() !== t || Ls()) return;
    const {
      msg: s,
      url: a,
      line: i,
      column: o,
      error: c
    } = e, u = vd(qn(n, c || s, void 0, r, !1), a, i, o);
    u.level = "error", is(u, {
      originalException: c,
      mechanism: {
        handled: !1,
        type: "auto.browser.global_handlers.onerror"
      }
    })
  })
}

function Sd(t) {
  us(e => {
    const {
      stackParser: n,
      attachStacktrace: r
    } = Js();
    if (N() !== t || Ls()) return;
    const s = Td(e),
      a = Ze(s) ? yd(s) : qn(n, s, void 0, r, !0);
    a.level = "error", is(a, {
      originalException: s,
      mechanism: {
        handled: !1,
        type: "auto.browser.global_handlers.onunhandledrejection"
      }
    })
  })
}

function Td(t) {
  if (Ze(t)) return t;
  try {
    if ("reason" in t) return t.reason;
    if ("detail" in t && "reason" in t.detail) return t.detail.reason
  } catch {}
  return t
}

function yd(t) {
  return {
    exception: {
      values: [{
        type: "UnhandledRejection",
        value: `Non-Error promise rejection captured with value: ${String(t)}`
      }]
    }
  }
}

function vd(t, e, n, r) {
  const s = t.exception = t.exception || {},
    a = s.values = s.values || [],
    i = a[0] = a[0] || {},
    o = i.stacktrace = i.stacktrace || {},
    c = o.frames = o.frames || [],
    u = r,
    l = n,
    d = bd(e) ?? ot();
  return c.length === 0 && c.push({
    colno: u,
    filename: d,
    function: He,
    in_app: !0,
    lineno: l
  }), t
}

function Hr(t) {
  te && g.log(`Global Handler attached: ${t}`)
}

function Js() {
  const t = N();
  return (t == null ? void 0 : t.getOptions()) || {
    stackParser: () => [],
    attachStacktrace: !1
  }
}

function bd(t) {
  if (!(!Je(t) || t.length === 0)) {
    if (t.startsWith("data:")) {
      const e = t.match(/^data:([^;]+)/),
        n = e ? e[1] : "text/javascript",
        r = t.includes("base64,");
      return `<data:${n}${r?",base64":""}>`
    }
    return t.slice(0, 1024)
  }
}
const Id = () => ({
    name: "HttpContext",
    preprocessEvent(t) {
      var r;
      if (!T.navigator && !T.location && !T.document) return;
      const e = Bn(),
        n = {
          ...e.headers,
          ...(r = t.request) == null ? void 0 : r.headers
        };
      t.request = {
        ...e,
        ...t.request,
        headers: n
      }
    }
  }),
  Rd = "cause",
  wd = 5,
  Ad = "LinkedErrors",
  Pd = ((t = {}) => {
    const e = t.limit || wd,
      n = t.key || Rd;
    return {
      name: Ad,
      preprocessEvent(r, s, a) {
        const i = a.getOptions();
        Do($n, i.stackParser, n, e, r, s)
      }
    }
  }),
  kd = Pd;

function Nd() {
  return Ld() ? (te && qt(() => {
    console.error("[Sentry] You cannot use Sentry.init() in a browser extension, see: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/")
  }), !0) : !1
}

function Ld() {
  var a;
  if (typeof T.window > "u") return !1;
  const t = T;
  if (t.nw) return !1;
  const e = t.chrome || t.browser;
  if (!((a = e == null ? void 0 : e.runtime) != null && a.id)) return !1;
  const n = ot(),
    r = ["chrome-extension", "moz-extension", "ms-browser-extension", "safari-web-extension"];
  return !(T === T.top && r.some(i => n.startsWith(`${i}://`)))
}

function Nn(t) {
  return [wo(), vo(), cd(), Ku(), _d(), kd(), $o(), Id(), md()]
}

function Cd(t = {}) {
  const e = !t.skipBrowserExtensionCheck && Nd(),
    n = {
      ...t,
      enabled: e ? !1 : t.enabled,
      stackParser: xa(t.stackParser || zu),
      integrations: Wi({
        integrations: t.integrations,
        defaultIntegrations: t.defaultIntegrations == null ? Nn() : t.defaultIntegrations
      }),
      transport: t.transport || Du
    };
  return no(Ec, n)
}

function ie(t = 0) {
  return ((Y() || performance.timeOrigin) + t) / 1e3
}

function Od(t) {
  const e = [];
  if (t.nextHopProtocol != null) {
    const {
      name: n,
      version: r
    } = Ws(t.nextHopProtocol);
    e.push(["network.protocol.version", r], ["network.protocol.name", n])
  }
  return Y() ? [...e, ["http.request.redirect_start", ie(t.redirectStart)],
    ["http.request.fetch_start", ie(t.fetchStart)],
    ["http.request.domain_lookup_start", ie(t.domainLookupStart)],
    ["http.request.domain_lookup_end", ie(t.domainLookupEnd)],
    ["http.request.connect_start", ie(t.connectStart)],
    ["http.request.secure_connection_start", ie(t.secureConnectionStart)],
    ["http.request.connection_end", ie(t.connectEnd)],
    ["http.request.request_start", ie(t.requestStart)],
    ["http.request.response_start", ie(t.responseStart)],
    ["http.request.response_end", ie(t.responseEnd)]
  ] : e
}
const Br = new WeakMap,
  pn = new Map,
  Ks = {
    traceFetch: !0,
    traceXHR: !0,
    enableHTTPTimings: !0,
    trackFetchStreamPerformance: !1
  };

function Dd(t, e) {
  const {
    traceFetch: n,
    traceXHR: r,
    trackFetchStreamPerformance: s,
    shouldCreateSpanForRequest: a,
    enableHTTPTimings: i,
    tracePropagationTargets: o,
    onRequestSpanStart: c
  } = {
    ...Ks,
    ...e
  }, u = typeof a == "function" ? a : f => !0, l = f => Fd(f, o), d = {}, p = t.getOptions().propagateTraceparent;
  n && (t.addEventProcessor(f => (f.type === "transaction" && f.spans && f.spans.forEach(m => {
    if (m.op === "http.client") {
      const h = pn.get(m.span_id);
      h && (m.timestamp = h / 1e3, pn.delete(m.span_id))
    }
  }), f)), s && Zo(f => {
    if (f.response) {
      const m = Br.get(f.response);
      m && f.endTimestamp && pn.set(m, f.endTimestamp)
    }
  }), ks(f => {
    const m = Vo(f, u, l, d, {
      propagateTraceparent: p
    });
    if (f.response && f.fetchData.__span && Br.set(f.response, f.fetchData.__span), m) {
      const h = Qs(f.fetchData.url),
        D = h ? ke(h).host : void 0;
      m.setAttributes({
        "http.url": h,
        "server.address": D
      }), i && $r(m), c == null || c(m, {
        headers: f.headers
      })
    }
  })), r && zs(f => {
    var h;
    const m = Md(f, u, l, d, p);
    if (m) {
      i && $r(m);
      let D;
      try {
        D = new Headers((h = f.xhr.__sentry_xhr_v3__) == null ? void 0 : h.request_headers)
      } catch {}
      c == null || c(m, {
        headers: D
      })
    }
  })
}

function xd(t) {
  return t.entryType === "resource" && "initiatorType" in t && typeof t.nextHopProtocol == "string" && (t.initiatorType === "fetch" || t.initiatorType === "xmlhttprequest")
}

function $r(t) {
  const {
    url: e
  } = R(t).data;
  if (!e || typeof e != "string") return;
  const n = $e("resource", ({
    entries: r
  }) => {
    r.forEach(s => {
      xd(s) && s.name.endsWith(e) && (Od(s).forEach(i => t.setAttribute(...i)), setTimeout(n))
    })
  })
}

function Fd(t, e) {
  const n = ot();
  if (n) {
    let r, s;
    try {
      r = new URL(t, n), s = new URL(n).origin
    } catch {
      return !1
    }
    const a = r.origin === s;
    return e ? he(r.toString(), e) || a && he(r.pathname, e) : a
  } else {
    const r = !!t.match(/^\/(?!\/)/);
    return e ? he(t, e) : r
  }
}

function Md(t, e, n, r, s) {
  const a = t.xhr,
    i = a == null ? void 0 : a[Fe];
  if (!a || a.__sentry_own_request__ || !i) return;
  const {
    url: o,
    method: c
  } = i, u = Le() && e(o);
  if (t.endTimestamp && u) {
    const D = a.__sentry_xhr_span_id__;
    if (!D) return;
    const I = r[D];
    I && i.status_code !== void 0 && (es(I, i.status_code), I.end(), delete r[D]);
    return
  }
  const l = Qs(o),
    d = ke(l || o),
    p = go(o),
    f = !!G(),
    m = u && f ? De({
      name: `${c} ${p}`,
      attributes: {
        url: o,
        type: "xhr",
        "http.method": c,
        "http.url": l,
        "server.address": d == null ? void 0 : d.host,
        [x]: "auto.http.browser",
        [Ee]: "http.client",
        ...(d == null ? void 0 : d.search) && {
          "http.query": d == null ? void 0 : d.search
        },
        ...(d == null ? void 0 : d.hash) && {
          "http.fragment": d == null ? void 0 : d.hash
        }
      }
    }) : new Se;
  a.__sentry_xhr_span_id__ = m.spanContext().spanId, r[a.__sentry_xhr_span_id__] = m, n(o) && Hd(a, Le() && f ? m : void 0, s);
  const h = N();
  return h && h.emit("beforeOutgoingRequestSpan", m, t), m
}

function Hd(t, e, n) {
  const {
    "sentry-trace": r,
    baggage: s,
    traceparent: a
  } = Rs({
    span: e,
    propagateTraceparent: n
  });
  r && Bd(t, r, s, a)
}

function Bd(t, e, n, r) {
  var a;
  const s = (a = t.__sentry_xhr_v3__) == null ? void 0 : a.request_headers;
  if (!(s != null && s["sentry-trace"] || !t.setRequestHeader)) try {
    if (t.setRequestHeader("sentry-trace", e), r && !(s != null && s.traceparent) && t.setRequestHeader("traceparent", r), n) {
      const i = s == null ? void 0 : s.baggage;
      (!i || !$d(i)) && t.setRequestHeader("baggage", n)
    }
  } catch {}
}

function $d(t) {
  return t.split(",").some(e => e.trim().startsWith("sentry-"))
}

function Qs(t) {
  try {
    return new URL(t, T.location.origin).href
  } catch {
    return
  }
}

function Ud() {
  T.document ? T.document.addEventListener("visibilitychange", () => {
    const t = G();
    if (!t) return;
    const e = W(t);
    if (T.document.hidden && e) {
      const n = "cancelled",
        {
          op: r,
          status: s
        } = R(e);
      te && g.log(`[Tracing] Transaction: ${n} -> since tab moved to the background, op: ${r}`), s || e.setStatus({
        code: Me,
        message: n
      }), e.setAttribute("sentry.cancellation_reason", "document.hidden"), e.end()
    }
  }) : te && g.warn("[Tracing] Could not set up background tab detection due to lack of global document")
}
const qd = 3600,
  Zs = "sentry_previous_trace",
  jd = "sentry.previous_trace";

function Vd(t, {
  linkPreviousTrace: e,
  consistentTraceSampling: n
}) {
  const r = e === "session-storage";
  let s = r ? Yd() : void 0;
  t.on("spanStart", i => {
    if (W(i) !== i) return;
    const o = C().getPropagationContext();
    s = Wd(s, i, o), r && Gd(s)
  });
  let a = !0;
  n && t.on("beforeSampling", i => {
    if (!s) return;
    const o = C(),
      c = o.getPropagationContext();
    if (a && c.parentSpanId) {
      a = !1;
      return
    }
    o.setPropagationContext({
      ...c,
      dsc: {
        ...c.dsc,
        sample_rate: String(s.sampleRate),
        sampled: String(Ln(s.spanContext))
      },
      sampleRand: s.sampleRand
    }), i.parentSampled = Ln(s.spanContext), i.parentSampleRate = s.sampleRate, i.spanAttributes = {
      ...i.spanAttributes,
      [Fa]: s.sampleRate
    }
  })
}

function Wd(t, e, n) {
  const r = R(e);

  function s() {
    var o, c;
    try {
      return Number((o = n.dsc) == null ? void 0 : o.sample_rate) ?? Number((c = r.data) == null ? void 0 : c[Jr])
    } catch {
      return 0
    }
  }
  const a = {
    spanContext: e.spanContext(),
    startTimestamp: r.start_timestamp,
    sampleRate: s(),
    sampleRand: n.sampleRand
  };
  if (!t) return a;
  const i = t.spanContext;
  return i.traceId === r.trace_id ? t : (Date.now() / 1e3 - t.startTimestamp <= qd && (te && g.log(`Adding previous_trace ${i} link to span ${{op:r.op,...e.spanContext()}}`), e.addLink({
    context: i,
    attributes: {
      [Ma]: "previous_trace"
    }
  }), e.setAttribute(jd, `${i.traceId}-${i.spanId}-${Ln(i)?1:0}`)), a)
}

function Gd(t) {
  try {
    T.sessionStorage.setItem(Zs, JSON.stringify(t))
  } catch (e) {
    te && g.warn("Could not store previous trace in sessionStorage", e)
  }
}

function Yd() {
  var t;
  try {
    const e = (t = T.sessionStorage) == null ? void 0 : t.getItem(Zs);
    return JSON.parse(e)
  } catch {
    return
  }
}

function Ln(t) {
  return t.traceFlags === 1
}
const zd = "BrowserTracing",
  Xd = {
    ...It,
    instrumentNavigation: !0,
    instrumentPageLoad: !0,
    markBackgroundSpan: !0,
    enableLongTask: !0,
    enableLongAnimationFrame: !0,
    enableInp: !0,
    enableElementTiming: !0,
    ignoreResourceSpans: [],
    ignorePerformanceApiSpans: [],
    detectRedirects: !0,
    linkPreviousTrace: "in-memory",
    consistentTraceSampling: !1,
    _experiments: {},
    ...Ks
  },
  Jd = ((t = {}) => {
    const e = {
        name: void 0,
        source: void 0
      },
      n = T.document,
      {
        enableInp: r,
        enableElementTiming: s,
        enableLongTask: a,
        enableLongAnimationFrame: i,
        _experiments: {
          enableInteractions: o,
          enableStandaloneClsSpans: c,
          enableStandaloneLcpSpans: u
        },
        beforeStartSpan: l,
        idleTimeout: d,
        finalTimeout: p,
        childSpanTimeout: f,
        markBackgroundSpan: m,
        traceFetch: h,
        traceXHR: D,
        trackFetchStreamPerformance: I,
        shouldCreateSpanForRequest: M,
        enableHTTPTimings: B,
        ignoreResourceSpans: oe,
        ignorePerformanceApiSpans: z,
        instrumentPageLoad: S,
        instrumentNavigation: b,
        detectRedirects: be,
        linkPreviousTrace: me,
        consistentTraceSampling: ge,
        onRequestSpanStart: ce
      } = {
        ...Xd,
        ...t
      };
    let L, H;

    function X(y, P, v = !0) {
      const k = P.op === "pageload",
        A = P.name,
        J = l ? l(P) : P,
        se = J.attributes || {};
      if (A !== J.name && (se[Z] = "custom", J.attributes = se), !v) {
        const Ie = Ut();
        De({
          ...J,
          startTime: Ie
        }).end(Ie);
        return
      }
      e.name = J.name, e.source = se[Z];
      const ue = gs(J, {
        idleTimeout: d,
        finalTimeout: p,
        childSpanTimeout: f,
        disableAutoFinish: k,
        beforeSpanEnd: Ie => {
          L == null || L(), iu(Ie, {
            recordClsOnPageloadSpan: !c,
            recordLcpOnPageloadSpan: !u,
            ignoreResourceSpans: oe,
            ignorePerformanceApiSpans: z
          }), qr(y, void 0);
          const de = C(),
            We = de.getPropagationContext();
          de.setPropagationContext({
            ...We,
            traceId: ue.spanContext().traceId,
            sampled: Mt(ue),
            dsc: Ne(Ie)
          })
        }
      });
      qr(y, ue);

      function ft() {
        n && ["interactive", "complete"].includes(n.readyState) && y.emit("idleSpanEnableAutoFinish", ue)
      }
      k && n && (n.addEventListener("readystatechange", () => {
        ft()
      }), ft())
    }
    return {
      name: zd,
      setup(y) {
        if (ui(), L = Zc({
            recordClsStandaloneSpans: c || !1,
            recordLcpStandaloneSpans: u || !1,
            client: y
          }), r && Nu(), s && hu(), i && F.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes("long-animation-frame") ? tu() : a && eu(), o && nu(), be && n) {
          const v = () => {
            H = q()
          };
          addEventListener("click", v, {
            capture: !0
          }), addEventListener("keydown", v, {
            capture: !0,
            passive: !0
          })
        }

        function P() {
          const v = rt(y);
          v && !R(v).timestamp && (te && g.log(`[Tracing] Finishing current active span with op: ${R(v).op}`), v.setAttribute(kt, "cancelled"), v.end())
        }
        y.on("startNavigationSpan", (v, k) => {
          if (N() !== y) return;
          if (k != null && k.isRedirect) {
            te && g.warn("[Tracing] Detected redirect, navigation span will not be the root span, but a child span."), X(y, {
              op: "navigation.redirect",
              ...v
            }, !1);
            return
          }
          H = void 0, P(), $t().setPropagationContext({
            traceId: Pt(),
            sampleRand: Math.random()
          });
          const A = C();
          A.setPropagationContext({
            traceId: Pt(),
            sampleRand: Math.random()
          }), A.setSDKProcessingMetadata({
            normalizedRequest: void 0
          }), X(y, {
            op: "navigation",
            ...v
          })
        }), y.on("startPageLoadSpan", (v, k = {}) => {
          if (N() !== y) return;
          P();
          const A = k.sentryTrace || Ur("sentry-trace"),
            J = k.baggage || Ur("baggage"),
            se = Ha(A, J),
            ue = C();
          ue.setPropagationContext(se), ue.setSDKProcessingMetadata({
            normalizedRequest: Bn()
          }), X(y, {
            op: "pageload",
            ...v
          })
        })
      },
      afterAllSetup(y) {
        let P = ot();
        if (me !== "off" && Vd(y, {
            linkPreviousTrace: me,
            consistentTraceSampling: ge
          }), T.location) {
          if (S) {
            const v = Y();
            ea(y, {
              name: T.location.pathname,
              startTime: v ? v / 1e3 : void 0,
              attributes: {
                [Z]: "url",
                [x]: "auto.pageload.browser"
              }
            })
          }
          b && zn(({
            to: v,
            from: k
          }) => {
            if (k === void 0 && (P == null ? void 0 : P.indexOf(v)) !== -1) {
              P = void 0;
              return
            }
            P = void 0;
            const A = Is(v),
              J = rt(y),
              se = J && be && Qd(J, H);
            ta(y, {
              name: (A == null ? void 0 : A.pathname) || T.location.pathname,
              attributes: {
                [Z]: "url",
                [x]: "auto.navigation.browser"
              }
            }, {
              url: v,
              isRedirect: se
            })
          })
        }
        m && Ud(), o && Kd(y, d, p, f, e), r && Ou(), Dd(y, {
          traceFetch: h,
          traceXHR: D,
          trackFetchStreamPerformance: I,
          tracePropagationTargets: y.getOptions().tracePropagationTargets,
          shouldCreateSpanForRequest: M,
          enableHTTPTimings: B,
          onRequestSpanStart: ce
        })
      }
    }
  });

function ea(t, e, n) {
  t.emit("startPageLoadSpan", e, n), C().setTransactionName(e.name);
  const r = rt(t);
  return r && t.emit("afterStartPageLoadSpan", r), r
}

function ta(t, e, n) {
  const {
    url: r,
    isRedirect: s
  } = n || {};
  t.emit("beforeStartNavigationSpan", e, {
    isRedirect: s
  }), t.emit("startNavigationSpan", e, {
    isRedirect: s
  });
  const a = C();
  return a.setTransactionName(e.name), r && !s && a.setSDKProcessingMetadata({
    normalizedRequest: {
      ...Bn(),
      url: r
    }
  }), rt(t)
}

function Ur(t) {
  const e = T.document,
    n = e == null ? void 0 : e.querySelector(`meta[name=${t}]`);
  return (n == null ? void 0 : n.getAttribute("content")) || void 0
}

function Kd(t, e, n, r, s) {
  const a = T.document;
  let i;
  const o = () => {
    const c = "ui.action.click",
      u = rt(t);
    if (u) {
      const l = R(u).op;
      if (["navigation", "pageload"].includes(l)) {
        te && g.warn(`[Tracing] Did not create ${c} span because a pageload or navigation span is in progress.`);
        return
      }
    }
    if (i && (i.setAttribute(kt, "interactionInterrupted"), i.end(), i = void 0), !s.name) {
      te && g.warn(`[Tracing] Did not create ${c} transaction because _latestRouteName is missing.`);
      return
    }
    i = gs({
      name: s.name,
      op: c,
      attributes: {
        [Z]: s.source || "url"
      }
    }, {
      idleTimeout: e,
      finalTimeout: n,
      childSpanTimeout: r
    })
  };
  a && addEventListener("click", o, {
    capture: !0
  })
}
const na = "_sentry_idleSpan";

function rt(t) {
  return t[na]
}

function qr(t, e) {
  et(t, na, e)
}
const jr = 1.5;

function Qd(t, e) {
  const n = R(t),
    r = Ut(),
    s = n.start_timestamp;
  return !(r - s > jr || e && r - e <= jr)
}

function Zd(t) {
  const e = {
    ...t
  };
  return Hn(e, "svelte"), Cd(e)
}
const ra = () => {
    const t = Ba;
    return {
      page: {
        subscribe: t.page.subscribe
      },
      navigating: {
        subscribe: t.navigating.subscribe
      },
      updated: t.updated
    }
  },
  el = {
    subscribe(t) {
      return ra().page.subscribe(t)
    }
  },
  tl = {
    subscribe(t) {
      return ra().navigating.subscribe(t)
    }
  };

function nl(t = {}) {
  const e = {
    ...Jd({
      ...t,
      instrumentNavigation: !1,
      instrumentPageLoad: !1
    })
  };
  return {
    ...e,
    afterAllSetup: n => {
      e.afterAllSetup(n), t.instrumentPageLoad !== !1 && rl(n), t.instrumentNavigation !== !1 && sl(n)
    }
  }
}

function rl(t) {
  var r;
  const e = (r = T.location) == null ? void 0 : r.pathname,
    n = ea(t, {
      name: e,
      op: "pageload",
      attributes: {
        [x]: "auto.pageload.sveltekit",
        [Z]: "url"
      }
    });
  n && el.subscribe(s => {
    var i;
    if (!s) return;
    const a = (i = s.route) == null ? void 0 : i.id;
    a && (n.updateName(a), n.setAttribute(Z, "route"), C().setTransactionName(a))
  })
}

function sl(t) {
  let e;
  tl.subscribe(n => {
    var l;
    if (!n) {
      e && (e.end(), e = void 0);
      return
    }
    const r = n.from,
      s = n.to,
      a = (r == null ? void 0 : r.url.pathname) || ((l = T.location) == null ? void 0 : l.pathname),
      i = s == null ? void 0 : s.url.pathname;
    if (a === i) return;
    const o = r == null ? void 0 : r.route.id,
      c = s == null ? void 0 : s.route.id;
    e && e.end();
    const u = {
      "sentry.sveltekit.navigation.type": n.type,
      "sentry.sveltekit.navigation.from": o || void 0,
      "sentry.sveltekit.navigation.to": c || void 0
    };
    ta(t, {
      name: c || i || "unknown",
      op: "navigation",
      attributes: {
        [x]: "auto.navigation.sveltekit",
        [Z]: c ? "route" : "url",
        ...u
      }
    }), e = De({
      op: "ui.sveltekit.routing",
      name: "SvelteKit Route Change",
      attributes: {
        [x]: "auto.ui.sveltekit",
        ...u
      },
      onlyIfParent: !0
    })
  })
}

function al(t) {
  const e = {
    defaultIntegrations: il(),
    ...t
  };
  Hn(e, "sveltekit", ["sveltekit", "svelte"]);
  const n = ol(),
    r = Zd(e);
  return n && cl(n), r
}

function il(t) {
  return typeof __SENTRY_TRACING__ > "u" || __SENTRY_TRACING__ ? [...Nn(), nl()] : Nn()
}

function ol() {
  const t = T,
    e = t.fetch;
  if (t._sentryFetchProxy && e) return t.fetch = t._sentryFetchProxy, e
}

function cl(t) {
  const e = T;
  e._sentryFetchProxy = e.fetch, e.fetch = t
}

function ul({
  error: t
}) {
  qt(() => {
    console.error(t)
  })
}

function dl(t) {
  const e = ul;
  return n => (ll(n) || rs(n.error, {
    mechanism: {
      type: "sveltekit",
      handled: !1
    }
  }), e(n))
}

function ll(t) {
  const {
    status: e
  } = t;
  return e ? e >= 400 && e < 500 : !1
}
al({
  dsn: "https://ef9fc09cd53942366f18dbc146ea7350@o4509998160805888.ingest.us.sentry.io/4509998167687168",
  tracesSampleRate: 1,
  enableLogs: !0,
  environment: "prod",
  replaysOnErrorSampleRate: 1
});
const fl = dl(),
  Nl = {};
var pl = os('<div id="svelte-announcer" aria-live="assertive" aria-atomic="true" style="position: absolute; left: 0; top: 0; clip: rect(0 0 0 0); clip-path: inset(50%); overflow: hidden; white-space: nowrap; width: 1px; height: 1px"><!></div>'),
  ml = os("<!> <!>", 1);

function gl(t, e) {
  Va(e, !0);
  let n = Ye(e, "components", 23, () => []),
    r = Ye(e, "data_0", 3, null),
    s = Ye(e, "data_1", 3, null),
    a = Ye(e, "data_2", 3, null),
    i = Ye(e, "data_3", 3, null);
  Wa(() => e.stores.page.set(e.page)), Ga(() => {
    e.stores, e.page, e.constructors, n(), e.form, r(), s(), a(), i(), e.stores.page.notify()
  });
  let o = en(!1),
    c = en(!1),
    u = en(null);
  si(() => {
    const I = e.stores.page.subscribe(() => {
      j(o) && (vt(c, !0), Ya().then(() => {
        vt(u, document.title || "untitled page", !0)
      }))
    });
    return vt(o, !0), I
  });
  const l = Re(() => e.constructors[3]);
  var d = ml(),
    p = ae(d);
  {
    var f = I => {
        const M = Re(() => e.constructors[0]);
        var B = le(),
          oe = ae(B);
        we(oe, () => j(M), (z, S) => {
          Ae(S(z, {
            get data() {
              return r()
            },
            get form() {
              return e.form
            },
            get params() {
              return e.page.params
            },
            children: (b, be) => {
              var me = le(),
                ge = ae(me);
              {
                var ce = H => {
                    const X = Re(() => e.constructors[1]);
                    var y = le(),
                      P = ae(y);
                    we(P, () => j(X), (v, k) => {
                      Ae(k(v, {
                        get data() {
                          return s()
                        },
                        get form() {
                          return e.form
                        },
                        get params() {
                          return e.page.params
                        },
                        children: (A, J) => {
                          var se = le(),
                            ue = ae(se);
                          {
                            var ft = de => {
                                const We = Re(() => e.constructors[2]);
                                var Ge = le(),
                                  zt = ae(Ge);
                                we(zt, () => j(We), (Xt, Jt) => {
                                  Ae(Jt(Xt, {
                                    get data() {
                                      return a()
                                    },
                                    get form() {
                                      return e.form
                                    },
                                    get params() {
                                      return e.page.params
                                    },
                                    children: (ne, El) => {
                                      var Xn = le(),
                                        sa = ae(Xn);
                                      we(sa, () => j(l), (aa, ia) => {
                                        Ae(ia(aa, {
                                          get data() {
                                            return i()
                                          },
                                          get form() {
                                            return e.form
                                          },
                                          get params() {
                                            return e.page.params
                                          }
                                        }), pt => n()[3] = pt, () => {
                                          var pt;
                                          return (pt = n()) == null ? void 0 : pt[3]
                                        })
                                      }), K(ne, Xn)
                                    },
                                    $$slots: {
                                      default: !0
                                    }
                                  }), ne => n()[2] = ne, () => {
                                    var ne;
                                    return (ne = n()) == null ? void 0 : ne[2]
                                  })
                                }), K(de, Ge)
                              },
                              Ie = de => {
                                const We = Re(() => e.constructors[2]);
                                var Ge = le(),
                                  zt = ae(Ge);
                                we(zt, () => j(We), (Xt, Jt) => {
                                  Ae(Jt(Xt, {
                                    get data() {
                                      return a()
                                    },
                                    get form() {
                                      return e.form
                                    },
                                    get params() {
                                      return e.page.params
                                    }
                                  }), ne => n()[2] = ne, () => {
                                    var ne;
                                    return (ne = n()) == null ? void 0 : ne[2]
                                  })
                                }), K(de, Ge)
                              };
                            ze(ue, de => {
                              e.constructors[3] ? de(ft) : de(Ie, !1)
                            })
                          }
                          K(A, se)
                        },
                        $$slots: {
                          default: !0
                        }
                      }), A => n()[1] = A, () => {
                        var A;
                        return (A = n()) == null ? void 0 : A[1]
                      })
                    }), K(H, y)
                  },
                  L = H => {
                    const X = Re(() => e.constructors[1]);
                    var y = le(),
                      P = ae(y);
                    we(P, () => j(X), (v, k) => {
                      Ae(k(v, {
                        get data() {
                          return s()
                        },
                        get form() {
                          return e.form
                        },
                        get params() {
                          return e.page.params
                        }
                      }), A => n()[1] = A, () => {
                        var A;
                        return (A = n()) == null ? void 0 : A[1]
                      })
                    }), K(H, y)
                  };
                ze(ge, H => {
                  e.constructors[2] ? H(ce) : H(L, !1)
                })
              }
              K(b, me)
            },
            $$slots: {
              default: !0
            }
          }), b => n()[0] = b, () => {
            var b;
            return (b = n()) == null ? void 0 : b[0]
          })
        }), K(I, B)
      },
      m = I => {
        const M = Re(() => e.constructors[0]);
        var B = le(),
          oe = ae(B);
        we(oe, () => j(M), (z, S) => {
          Ae(S(z, {
            get data() {
              return r()
            },
            get form() {
              return e.form
            },
            get params() {
              return e.page.params
            }
          }), b => n()[0] = b, () => {
            var b;
            return (b = n()) == null ? void 0 : b[0]
          })
        }), K(I, B)
      };
    ze(p, I => {
      e.constructors[1] ? I(f) : I(m, !1)
    })
  }
  var h = za(p, 2);
  {
    var D = I => {
      var M = pl(),
        B = Ja(M);
      {
        var oe = z => {
          var S = Qa();
          Za(() => ri(S, j(u))), K(z, S)
        };
        ze(B, z => {
          j(c) && z(oe)
        })
      }
      Ka(M), K(I, M)
    };
    ze(h, I => {
      j(o) && I(D)
    })
  }
  K(t, d), Xa()
}
const Ll = ai(gl),
  Cl = [() => w(() => import("../nodes/0.CpSVMNhN.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]), import.meta.url), () => w(() => import("../nodes/1.CYhu7mxU.js"), __vite__mapDeps([18, 1, 16, 3, 4, 5, 19, 20, 21, 2]), import.meta.url), () => w(() => import("../nodes/2.D6dZkZ6v.js"), __vite__mapDeps([22, 1, 2, 3, 4, 5, 11, 23, 12, 13, 24, 20, 21, 7, 6, 8, 9, 25, 26]), import.meta.url), () => w(() => import("../nodes/3.DAZn6mk_.js"), __vite__mapDeps([27, 1, 3, 4, 5, 2, 23, 12, 13, 24, 20, 21, 26]), import.meta.url), () => w(() => import("../nodes/4.D4IHJFSN.js"), __vite__mapDeps([28, 1, 2, 3, 4, 5, 11, 13, 24, 12, 21, 20, 6, 7, 8, 9, 10, 29, 30, 14, 31, 32, 33, 34, 35, 36, 37, 38, 26, 39, 23, 40, 41, 42, 43, 16, 19, 25, 15, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53]), import.meta.url), () => w(() => import("../nodes/5.DbvDYKvQ.js"), __vite__mapDeps([54, 1, 16, 3, 25, 11, 13]), import.meta.url), () => w(() => import("../nodes/6.DIkhzORW.js"), __vite__mapDeps([55, 1, 16, 3, 2, 4, 5, 19, 8, 21]), import.meta.url), () => w(() => import("../nodes/7.wGtuT1wI.js"), __vite__mapDeps([56, 1, 3, 4, 5, 11, 23, 12, 13, 24, 32, 21, 2, 20, 7, 6, 8, 9, 31, 36, 30, 34, 50, 52, 33, 47, 39, 37, 57, 58, 59, 60, 38, 26]), import.meta.url), () => w(() => import("../nodes/8.3ihRAo2m.js"), __vite__mapDeps([61, 1, 2, 3, 4, 5, 11, 12, 13, 32, 21, 7, 6, 8, 9, 31, 50, 62, 57, 58, 63, 64]), import.meta.url), () => w(() => import("../nodes/9.DTXaImJt.js"), __vite__mapDeps([65, 1, 2, 3, 4, 5, 11, 12, 13, 32, 21, 7, 6, 8, 9, 36, 30, 50, 57, 58, 63, 66, 64]), import.meta.url), () => w(() => import("../nodes/10.CPCdNj68.js"), __vite__mapDeps([67, 1, 16, 3, 5, 8, 21, 2, 4]), import.meta.url), () => w(() => import("../nodes/11.L4BDnh04.js"), __vite__mapDeps([68, 1, 2, 3, 4, 5, 11, 12, 13, 32, 21, 7, 6, 8, 9, 36, 30, 50, 58, 63, 66, 64, 69, 59]), import.meta.url), () => w(() => import("../nodes/12.c_25KQyb.js"), __vite__mapDeps([70, 1, 2, 3, 4, 5, 11, 12, 13, 32, 21, 7, 6, 8, 9, 36, 30, 50, 58, 63, 66, 64, 69]), import.meta.url), () => w(() => import("../nodes/13.YNVVb1_T.js"), __vite__mapDeps([71, 1, 3, 4, 5, 11, 23, 12, 13, 32, 21, 2, 20, 7, 6, 8, 9, 35, 24, 14, 31, 36, 30, 33, 37, 38, 26, 43, 48, 34, 72, 50, 52, 73, 58, 63, 66, 60, 74]), import.meta.url), () => w(() => import("../nodes/14.BnSA5oFs.js"), __vite__mapDeps([75, 1, 2, 3, 4, 5, 11, 23, 12, 13, 32, 20, 21, 7, 6, 8, 9, 36, 30, 43, 34, 72, 50, 73, 74, 76, 38]), import.meta.url), () => w(() => import("../nodes/15.DOmo8Lv1.js"), __vite__mapDeps([77, 1, 2, 3, 4, 5, 11, 21, 20, 7, 6, 8, 9, 44, 13, 25, 45, 78]), import.meta.url), () => w(() => import("../nodes/16.CDg8S4Qe.js"), __vite__mapDeps([79, 1, 2, 3, 4, 5, 11, 23, 12, 13, 24, 14, 21, 20, 7, 6, 8, 9, 29, 36, 30, 40, 43, 48, 34, 72, 50, 52, 62, 76, 38]), import.meta.url), () => w(() => import("../nodes/17.uMccEkTe.js"), __vite__mapDeps([80, 1, 16, 3, 4, 5, 19, 25, 11, 13, 50, 51, 8, 52]), import.meta.url), () => w(() => import("../nodes/18.efjpvq-t.js"), __vite__mapDeps([81, 1, 2, 3, 4, 5, 11, 30, 20, 21, 7, 6, 8, 9, 25, 13, 49, 78]), import.meta.url), () => w(() => import("../nodes/19.BkdJdeOt.js"), __vite__mapDeps([82, 1, 3, 4, 5, 11, 12, 13, 32, 14, 21, 2, 6, 7, 8, 9, 41, 20, 40, 36, 30, 42, 33, 47, 73, 38]), import.meta.url), () => w(() => import("../nodes/20.DQqCNqYZ.js"), __vite__mapDeps([83, 1, 3, 4, 5, 11, 12, 13, 25]), import.meta.url), () => w(() => import("../nodes/21.I9LXRG0n.js"), __vite__mapDeps([84, 1, 16, 3, 5, 25, 11, 13, 85]), import.meta.url), () => w(() => import("../nodes/22.pZ-xouhR.js"), __vite__mapDeps([86, 1, 16, 3, 5, 25, 11, 13]), import.meta.url), () => w(() => import("../nodes/23.DzNJH28Y.js"), __vite__mapDeps([87, 1, 16, 3, 5, 25, 11, 13]), import.meta.url), () => w(() => import("../nodes/24.puEbL3R3.js"), __vite__mapDeps([88, 1, 16, 3, 5, 25, 11, 13, 85]), import.meta.url), () => w(() => import("../nodes/25.DgsHKk23.js"), __vite__mapDeps([89, 1, 2, 3, 4, 5, 11, 30, 21, 44, 13, 6, 8, 25, 45, 78]), import.meta.url)],
  Ol = [],
  Dl = {
    "/": [4],
    "/404": [5],
    "/admin": [6, [2]],
    "/admin/alliances": [7, [2]],
    "/admin/dashboard": [8, [2]],
    "/admin/logs": [9, [2]],
    "/admin/mods": [10, [2, 3]],
    "/admin/mods/leaderboard-reports": [12, [2, 3]],
    "/admin/mods/leaderboard": [11, [2, 3]],
    "/admin/users": [13, [2]],
    "/appeal": [14],
    "/join": [15],
    "/moderation": [16],
    "/offline": [17],
    "/payment/success": [18],
    "/profile-picture": [19],
    "/terms/code-of-conduct": [20],
    "/terms/privacy": [21],
    "/terms/return": [22],
    "/terms/return/pt": [23],
    "/terms/terms-of-service": [24],
    "/twitch-migration": [25]
  },
  hl = {
    handleError: fl || (({
      error: t
    }) => {
      console.error(t)
    }),
    init: void 0,
    reroute: (() => {}),
    transport: {}
  },
  _l = Object.fromEntries(Object.entries(hl.transport).map(([t, e]) => [t, e.decode])),
  xl = !1,
  Fl = (t, e) => _l[t](e);
export {
  Fl as decode, _l as decoders, Dl as dictionary, xl as hash, hl as hooks, Nl as matchers, Cl as nodes, Ll as root, Ol as server_loads
};