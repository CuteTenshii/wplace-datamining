const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["../nodes/0.CjLk6r6x.js", "../chunks/DfRvk52k.js", "../chunks/DFGWYax0.js", "../chunks/ZybFQ5qV.js", "../chunks/BwiGtDz0.js", "../chunks/DBMHNJRO.js", "../chunks/xbe0KMIm.js", "../chunks/BAGYynGw.js", "../chunks/BnZUZ40m.js", "../chunks/BY5gzsGG.js", "../chunks/DiCZbe8_.js", "../chunks/DwjA8j88.js", "../chunks/D7VrOeQp.js", "../chunks/BHPeit1R.js", "../chunks/k2mnPrds.js", "../chunks/CiC96CXU.js", "../chunks/2A8UTHN3.js", "../chunks/CHDPkJcN.js", "../assets/0.CGYLTIDx.css", "../nodes/1.BdMFEqYB.js", "../chunks/DhrqjP2W.js", "../chunks/BmBZBfiC.js", "../chunks/ePa96SXn.js", "../nodes/2.DZTzkQMz.js", "../chunks/Obsdhe0b.js", "../chunks/gDkltKG3.js", "../chunks/BQ1ehMYi.js", "../chunks/Dw5gdsdf.js", "../chunks/lYMBOy5-.js", "../chunks/CVJUl7Dl.js", "../chunks/Cnitcz-j.js", "../chunks/Cm_1g1CP.js", "../chunks/CzRIVPhn.js", "../chunks/BIdiUnnP.js", "../chunks/9TspzA6K.js", "../chunks/Bm8drNcS.js", "../chunks/CXml0tTN.js", "../chunks/DJJ0qG27.js", "../nodes/3.BU92DUVz.js", "../chunks/D4_xQL8y.js", "../chunks/CZr97Ckl.js", "../chunks/C8E-Ft-_.js", "../nodes/4.D8tZYwKh.js", "../chunks/z9HDbiY3.js", "../chunks/ycar7J_T.js", "../chunks/DRAg-pc8.js", "../chunks/D4_l2s2g.js", "../chunks/gCvdNZfr.js", "../chunks/CSENNo1E.js", "../chunks/D2jLwwkV.js", "../assets/ProfileAvatarWithLevel.C1r4yqVt.css", "../chunks/DFbH2Efj.js", "../chunks/B3IT31Gk.js", "../chunks/DmLofR0I.js", "../chunks/DCja5aGr.js", "../chunks/CUDd5Sbe.js", "../chunks/KtG8_IlV.js", "../chunks/HVVRYNE7.js", "../chunks/nrLv431J.js", "../chunks/DNuRs3gv.js", "../chunks/DFYoTr9Y.js", "../chunks/CrX_BgIb.js", "../chunks/BIvSv_J5.js", "../chunks/CTdjNOgE.js", "../chunks/9IipguxC.js", "../chunks/BnTTp0Dl.js", "../assets/LoginForm.DGOu-WIi.css", "../chunks/D_mj-7hT.js", "../chunks/CwQCKeB6.js", "../chunks/00t6eRxH.js", "../chunks/CsieLdXk.js", "../chunks/kqWxQGX6.js", "../chunks/CVn4oaQR.js", "../chunks/Cm_BSD6T.js", "../chunks/CQjZqkp-.js", "../assets/4.CscrmUqz.css", "../nodes/5.CSjNJ3H-.js", "../nodes/6.CGb-3gDS.js", "../chunks/DWRrI7kP.js", "../chunks/BYyAFwHi.js", "../chunks/OVqz_Wya.js", "../chunks/CMFkLR4U.js", "../chunks/BWmFbsGQ.js", "../chunks/CO4Mgxts.js", "../nodes/7.B5PP93-T.js", "../chunks/CrmRNy-o.js", "../chunks/C1BVaIqD.js", "../chunks/Ban2NmYz.js", "../chunks/CpcgbqvR.js", "../chunks/C5ILUcH5.js", "../chunks/Cm2Ikmif.js", "../nodes/8.3DV0tG2O.js", "../chunks/CYkRuLjb.js", "../chunks/D4C5G3LN.js", "../chunks/zVSTjlFk.js", "../chunks/DLLnL5aD.js", "../chunks/Dyqg9ryZ.js", "../chunks/B2bRjkL4.js", "../nodes/9.DAiN1P8F.js", "../chunks/JoMoDwDv.js", "../nodes/10.LfabLcqM.js", "../nodes/11.8mJU1Xsl.js", "../chunks/Cyp1hmzE.js", "../nodes/12.DoDjKBcz.js", "../nodes/13.rWnKomii.js", "../chunks/BmwEbQ0K.js", "../chunks/C1jv1jM-.js", "../nodes/14.Dr_EuPQT.js", "../nodes/15.DaS6BCUm.js", "../chunks/DF9vEciK.js", "../nodes/16.DtPc6HJ1.js", "../chunks/CevIoCiJ.js", "../nodes/17.aIGv_P3x.js", "../nodes/18.Cvu8ofJ3.js", "../nodes/19.Cn2CqAyb.js", "../nodes/20.Csw6SLm6.js", "../nodes/21.ChTa7_IY.js", "../assets/21.AmQai5Pb.css", "../nodes/22.B_8IH7OC.js", "../nodes/23.DaDtOaNx.js", "../nodes/24.B0d7XhOa.js", "../nodes/25.DBUrYUdP.js", "../nodes/26.D9xkntej.js", "../nodes/27.UJoS7atv.js"]))) => i.map(i => d[i]);
var Jn = t => {
  throw TypeError(t)
};
var Kn = (t, e, n) => e.has(t) || Jn("Cannot " + n);
var j = (t, e, n) => (Kn(t, e, "read from private field"), n ? n.call(t) : e.get(t)),
  Zt = (t, e, n) => e.has(t) ? Jn("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n),
  Qt = (t, e, n, r) => (Kn(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n);
import {
  D as E,
  d as g,
  g as be,
  G as x,
  a as J,
  b as X,
  S as qe,
  i as en,
  e as Mt,
  f as et,
  T as Wr,
  n as ga,
  h as _a,
  j as ze,
  k as Ce,
  l as A,
  m as pn,
  o as qt,
  p as dt,
  q as ft,
  t as q,
  r as Te,
  u as O,
  v as ha,
  w as tt,
  x as ne,
  y as Ea,
  z as Sa,
  A as Ye,
  B as Ln,
  C as k,
  E as Zn,
  F as L,
  H as Rt,
  I as Qn,
  J as ya,
  K as Gr,
  L as pe,
  M as Cn,
  N as jt,
  O as zr,
  P as Yr,
  _ as Vt,
  Q as ba,
  R as wt,
  U as Wt,
  V as Xr,
  W as Ta,
  X as Jr,
  Y as at,
  Z as va,
  $ as Kr,
  a0 as Gt,
  a1 as Ia,
  a2 as At,
  a3 as er,
  a4 as je,
  a5 as tr,
  a6 as Ra,
  a7 as wa,
  a8 as Aa,
  a9 as Zr,
  aa as Qr,
  ab as es,
  ac as Pa,
  ad as mn,
  ae as zt,
  af as On,
  ag as nr,
  ah as ka,
  ai as Na,
  aj as La,
  ak as Ca,
  al as Oa,
  am as Ma,
  an as Da,
  ao as Mn,
  ap as Ne,
  aq as ye,
  ar as Dt,
  as as xa,
  at as Y,
  au as rr,
  av as sr,
  aw as ts,
  ax as ns,
  ay as Fa,
  az as rs,
  aA as ot,
  aB as lt,
  aC as Ha,
  aD as gn,
  aE as it,
  c as ss,
  aF as as,
  aG as ar,
  aH as Ba,
  aI as Dn,
  aJ as $a,
  aK as Ua,
  aL as K,
  aM as fe,
  aN as os,
  aO as nt,
  aP as qa,
  aQ as Ve,
  aR as or,
  aS as ir,
  aT as cr,
  aU as is,
  aV as ja,
  aW as Va,
  aX as Wa,
  aY as Ga
} from "../chunks/BY5gzsGG.js";
import {
  s as za
} from "../chunks/ePa96SXn.js";
import {
  i as Pt,
  aP as Ya,
  j as z,
  az as Xa,
  bA as Ja,
  a6 as Ka,
  p as Za,
  J as Qa,
  K as eo,
  e as tn,
  w as to,
  f as cs,
  a as le,
  s as no,
  b as Q,
  c as ro,
  h as Ee,
  d as so,
  r as ao,
  u as Ae,
  aR as oo,
  t as io
} from "../chunks/ZybFQ5qV.js";
import {
  h as co,
  m as uo,
  u as fo,
  s as lo
} from "../chunks/BwiGtDz0.js";
import "../chunks/DfRvk52k.js";
import {
  o as po
} from "../chunks/DFGWYax0.js";
import {
  i as Ze
} from "../chunks/DwjA8j88.js";
import {
  c as Pe
} from "../chunks/2A8UTHN3.js";
import {
  b as ke
} from "../chunks/k2mnPrds.js";
import {
  p as Qe
} from "../chunks/CiC96CXU.js";
(function() {
  try {
    var t = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
    t.SENTRY_RELEASE = {
      id: "1dc76760b5957a0899b63650345eafb40d771701"
    }
  } catch {}
})();
try {
  (function() {
    var t = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {},
      e = new t.Error().stack;
    e && (t._sentryDebugIds = t._sentryDebugIds || {}, t._sentryDebugIds[e] = "bc9ccabc-c023-43bd-a167-48e46650cb9e", t._sentryDebugIdIdentifier = "sentry-dbid-bc9ccabc-c023-43bd-a167-48e46650cb9e")
  })()
} catch {}

function mo(t) {
  return class extends go {
    constructor(e) {
      super({
        component: t,
        ...e
      })
    }
  }
}
var Se, te;
class go {
  constructor(e) {
    Zt(this, Se);
    Zt(this, te);
    var a;
    var n = new Map,
      r = (o, c) => {
        var i = Ka(c, !1, !1);
        return n.set(o, i), i
      };
    const s = new Proxy({
      ...e.props || {},
      $$events: {}
    }, {
      get(o, c) {
        return z(n.get(c) ?? r(c, Reflect.get(o, c)))
      },
      has(o, c) {
        return c === Ya ? !0 : (z(n.get(c) ?? r(c, Reflect.get(o, c))), Reflect.has(o, c))
      },
      set(o, c, i) {
        return Pt(n.get(c) ?? r(c, i), i), Reflect.set(o, c, i)
      }
    });
    Qt(this, te, (e.hydrate ? co : uo)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: s,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    })), (!((a = e == null ? void 0 : e.props) != null && a.$$host) || e.sync === !1) && Xa(), Qt(this, Se, s.$$events);
    for (const o of Object.keys(j(this, te))) o === "$set" || o === "$destroy" || o === "$on" || Ja(this, o, {
      get() {
        return j(this, te)[o]
      },
      set(c) {
        j(this, te)[o] = c
      },
      enumerable: !0
    });
    j(this, te).$set = o => {
      Object.assign(s, o)
    }, j(this, te).$destroy = () => {
      fo(j(this, te))
    }
  }
  $set(e) {
    j(this, te).$set(e)
  }
  $on(e, n) {
    j(this, Se)[e] = j(this, Se)[e] || [];
    const r = (...s) => n.call(this, ...s);
    return j(this, Se)[e].push(r), () => {
      j(this, Se)[e] = j(this, Se)[e].filter(s => s !== r)
    }
  }
  $destroy() {
    j(this, te).$destroy()
  }
}
Se = new WeakMap, te = new WeakMap;
const _o = "modulepreload",
  ho = function(t, e) {
    return new URL(t, e).href
  },
  ur = {},
  w = function(e, n, r) {
    let s = Promise.resolve();
    if (n && n.length > 0) {
      let o = function(f) {
        return Promise.all(f.map(d => Promise.resolve(d).then(l => ({
          status: "fulfilled",
          value: l
        }), l => ({
          status: "rejected",
          reason: l
        }))))
      };
      const c = document.getElementsByTagName("link"),
        i = document.querySelector("meta[property=csp-nonce]"),
        u = (i == null ? void 0 : i.nonce) || (i == null ? void 0 : i.getAttribute("nonce"));
      s = o(n.map(f => {
        if (f = ho(f, r), f in ur) return;
        ur[f] = !0;
        const d = f.endsWith(".css"),
          l = d ? '[rel="stylesheet"]' : "";
        if (!!r)
          for (let _ = c.length - 1; _ >= 0; _--) {
            const h = c[_];
            if (h.href === f && (!d || h.rel === "stylesheet")) return
          } else if (document.querySelector(`link[href="${f}"]${l}`)) return;
        const m = document.createElement("link");
        if (m.rel = d ? "stylesheet" : _o, d || (m.as = "script"), m.crossOrigin = "", m.href = f, u && m.setAttribute("nonce", u), document.head.appendChild(m), d) return new Promise((_, h) => {
          m.addEventListener("load", _), m.addEventListener("error", () => h(new Error(`Unable to preload CSS for ${f}`)))
        })
      }))
    }

    function a(o) {
      const c = new Event("vite:preloadError", {
        cancelable: !0
      });
      if (c.payload = o, window.dispatchEvent(c), !c.defaultPrevented) throw o
    }
    return s.then(o => {
      for (const c of o || []) c.status === "rejected" && a(c.reason);
      return e().catch(a)
    })
  },
  kt = {},
  dr = {};

function Re(t, e) {
  kt[t] = kt[t] || [], kt[t].push(e)
}

function we(t, e) {
  if (!dr[t]) {
    dr[t] = !0;
    try {
      e()
    } catch (n) {
      E && g.error(`Error while instrumenting ${t}`, n)
    }
  }
}

function re(t, e) {
  const n = t && kt[t];
  if (n)
    for (const r of n) try {
      r(e)
    } catch (s) {
      E && g.error(`Error while triggering instrumentation handler.
Type: ${t}
Name: ${be(r)}
Error:`, s)
    }
}
let nn = null;

function us(t) {
  const e = "error";
  Re(e, t), we(e, Eo)
}

function Eo() {
  nn = x.onerror, x.onerror = function(t, e, n, r, s) {
    return re("error", {
      column: r,
      error: s,
      line: n,
      msg: t,
      url: e
    }), nn ? nn.apply(this, arguments) : !1
  }, x.onerror.__SENTRY_INSTRUMENTED__ = !0
}
let rn = null;

function ds(t) {
  const e = "unhandledrejection";
  Re(e, t), we(e, So)
}

function So() {
  rn = x.onunhandledrejection, x.onunhandledrejection = function(t) {
    return re("unhandledrejection", t), rn ? rn.apply(this, arguments) : !0
  }, x.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
}
let fr = !1;

function yo() {
  if (fr) return;

  function t() {
    const e = J(),
      n = e && X(e);
    if (n) {
      const r = "internal_error";
      E && g.log(`[Tracing] Root span: ${r} -> Global error occurred`), n.setStatus({
        code: qe,
        message: r
      })
    }
  }
  t.tag = "sentry_tracingErrorCallback", fr = !0, us(t), ds(t)
}

function lr(t) {
  g.log(`Ignoring span ${t.op} - ${t.description} because it matches \`ignoreSpans\`.`)
}

function xt(t, e) {
  if (!(e != null && e.length) || !t.description) return !1;
  for (const n of e) {
    if (To(n)) {
      if (en(t.description, n)) return E && lr(t), !0;
      continue
    }
    if (!n.name && !n.op) continue;
    const r = n.name ? en(t.description, n.name) : !0,
      s = n.op ? t.op && en(t.op, n.op) : !0;
    if (r && s) return E && lr(t), !0
  }
  return !1
}

function bo(t, e) {
  const n = e.parent_span_id,
    r = e.span_id;
  if (n)
    for (const s of t) s.parent_span_id === r && (s.parent_span_id = n)
}

function To(t) {
  return typeof t == "string" || t instanceof RegExp
}
class ve {
  constructor(e = {}) {
    this._traceId = e.traceId || Mt(), this._spanId = e.spanId || et()
  }
  spanContext() {
    return {
      spanId: this._spanId,
      traceId: this._traceId,
      traceFlags: Wr
    }
  }
  end(e) {}
  setAttribute(e, n) {
    return this
  }
  setAttributes(e) {
    return this
  }
  setStatus(e) {
    return this
  }
  updateName(e) {
    return this
  }
  isRecording() {
    return !1
  }
  addEvent(e, n, r) {
    return this
  }
  addLink(e) {
    return this
  }
  addLinks(e) {
    return this
  }
  recordException(e, n) {}
}

function Me(t, e = []) {
  return [t, e]
}

function vo(t, e) {
  const [n, r] = t;
  return [n, [...r, e]]
}

function pr(t, e) {
  const n = t[1];
  for (const r of n) {
    const s = r[0].type;
    if (e(r, s)) return !0
  }
  return !1
}

function _n(t) {
  const e = _a(x);
  return e.encodePolyfill ? e.encodePolyfill(t) : new TextEncoder().encode(t)
}

function Io(t) {
  const [e, n] = t;
  let r = JSON.stringify(e);

  function s(a) {
    typeof r == "string" ? r = typeof a == "string" ? r + a : [_n(r), a] : r.push(typeof a == "string" ? _n(a) : a)
  }
  for (const a of n) {
    const [o, c] = a;
    if (s(`
${JSON.stringify(o)}
`), typeof c == "string" || c instanceof Uint8Array) s(c);
    else {
      let i;
      try {
        i = JSON.stringify(c)
      } catch {
        i = JSON.stringify(ga(c))
      }
      s(i)
    }
  }
  return typeof r == "string" ? r : Ro(r)
}

function Ro(t) {
  const e = t.reduce((s, a) => s + a.length, 0),
    n = new Uint8Array(e);
  let r = 0;
  for (const s of t) n.set(s, r), r += s.length;
  return n
}

function wo(t) {
  return [{
    type: "span"
  }, t]
}

function Ao(t) {
  const e = typeof t.data == "string" ? _n(t.data) : t.data;
  return [{
    type: "attachment",
    length: e.length,
    filename: t.filename,
    content_type: t.contentType,
    attachment_type: t.attachmentType
  }, e]
}
const Po = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  profile_chunk: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  raw_security: "security",
  log: "log_item",
  metric: "metric",
  trace_metric: "metric"
};

function mr(t) {
  return Po[t]
}

function fs(t) {
  if (!(t != null && t.sdk)) return;
  const {
    name: e,
    version: n
  } = t.sdk;
  return {
    name: e,
    version: n
  }
}

function ko(t, e, n, r) {
  var a;
  const s = (a = t.sdkProcessingMetadata) == null ? void 0 : a.dynamicSamplingContext;
  return {
    event_id: t.event_id,
    sent_at: new Date().toISOString(),
    ...e && {
      sdk: e
    },
    ...!!n && r && {
      dsn: ze(r)
    },
    ...s && {
      trace: s
    }
  }
}

function No(t, e) {
  var r, s, a, o;
  if (!e) return t;
  const n = t.sdk || {};
  return t.sdk = {
    ...n,
    name: n.name || e.name,
    version: n.version || e.version,
    integrations: [...((r = t.sdk) == null ? void 0 : r.integrations) || [], ...e.integrations || []],
    packages: [...((s = t.sdk) == null ? void 0 : s.packages) || [], ...e.packages || []],
    settings: (a = t.sdk) != null && a.settings || e.settings ? {
      ...(o = t.sdk) == null ? void 0 : o.settings,
      ...e.settings
    } : void 0
  }, t
}

function Lo(t, e, n, r) {
  const s = fs(n),
    a = {
      sent_at: new Date().toISOString(),
      ...s && {
        sdk: s
      },
      ...!!r && e && {
        dsn: ze(e)
      }
    },
    o = "aggregates" in t ? [{
      type: "sessions"
    }, t] : [{
      type: "session"
    }, t.toJSON()];
  return Me(a, [o])
}

function Co(t, e, n, r) {
  const s = fs(n),
    a = t.type && t.type !== "replay_event" ? t.type : "event";
  No(t, n == null ? void 0 : n.sdk);
  const o = ko(t, s, r, e);
  return delete t.sdkProcessingMetadata, Me(o, [
    [{
      type: a
    }, t]
  ])
}

function Oo(t, e) {
  function n(p) {
    return !!p.trace_id && !!p.public_key
  }
  const r = Ce(t[0]),
    s = e == null ? void 0 : e.getDsn(),
    a = e == null ? void 0 : e.getOptions().tunnel,
    o = {
      sent_at: new Date().toISOString(),
      ...n(r) && {
        trace: r
      },
      ...!!a && s && {
        dsn: ze(s)
      }
    },
    {
      beforeSendSpan: c,
      ignoreSpans: i
    } = (e == null ? void 0 : e.getOptions()) || {},
    u = i != null && i.length ? t.filter(p => !xt(A(p), i)) : t,
    f = t.length - u.length;
  f && (e == null || e.recordDroppedEvent("before_send", "span", f));
  const d = c ? p => {
      const m = A(p),
        _ = c(m);
      return _ || (pn(), m)
    } : A,
    l = [];
  for (const p of u) {
    const m = d(p);
    m && l.push(wo(m))
  }
  return Me(o, l)
}

function Mo(t) {
  if (!E) return;
  const {
    description: e = "< unknown name >",
    op: n = "< unknown op >",
    parent_span_id: r
  } = A(t), {
    spanId: s
  } = t.spanContext(), a = qt(t), o = X(t), c = o === t, i = `[Tracing] Starting ${a?"sampled":"unsampled"} ${c?"root ":""}span`, u = [`op: ${n}`, `name: ${e}`, `ID: ${s}`];
  if (r && u.push(`parent ID: ${r}`), !c) {
    const {
      op: f,
      description: d
    } = A(o);
    u.push(`root ID: ${o.spanContext().spanId}`), f && u.push(`root op: ${f}`), d && u.push(`root description: ${d}`)
  }
  g.log(`${i}
  ${u.join(`
  `)}`)
}

function Do(t) {
  if (!E) return;
  const {
    description: e = "< unknown name >",
    op: n = "< unknown op >"
  } = A(t), {
    spanId: r
  } = t.spanContext(), a = X(t) === t, o = `[Tracing] Finishing "${n}" ${a?"root ":""}span "${e}" with ID ${r}`;
  g.log(o)
}

function xo(t, e, n, r = J()) {
  const s = r && X(r);
  s && (E && g.log(`[Measurement] Setting measurement on root span: ${t} = ${e} ${n}`), s.addEvent(t, {
    [ft]: e,
    [dt]: n
  }))
}

function gr(t) {
  if (!t || t.length === 0) return;
  const e = {};
  return t.forEach(n => {
    const r = n.attributes || {},
      s = r[dt],
      a = r[ft];
    typeof s == "string" && typeof a == "number" && (e[n.name] = {
      value: a,
      unit: s
    })
  }), e
}
const _r = 1e3;
class Yt {
  constructor(e = {}) {
    this._traceId = e.traceId || Mt(), this._spanId = e.spanId || et(), this._startTime = e.startTimestamp || q(), this._links = e.links, this._attributes = {}, this.setAttributes({
      [O]: "manual",
      [Te]: e.op,
      ...e.attributes
    }), this._name = e.name, e.parentSpanId && (this._parentSpanId = e.parentSpanId), "sampled" in e && (this._sampled = e.sampled), e.endTimestamp && (this._endTime = e.endTimestamp), this._events = [], this._isStandaloneSpan = e.isStandalone, this._endTime && this._onSpanEnded()
  }
  addLink(e) {
    return this._links ? this._links.push(e) : this._links = [e], this
  }
  addLinks(e) {
    return this._links ? this._links.push(...e) : this._links = e, this
  }
  recordException(e, n) {}
  spanContext() {
    const {
      _spanId: e,
      _traceId: n,
      _sampled: r
    } = this;
    return {
      spanId: e,
      traceId: n,
      traceFlags: r ? ha : Wr
    }
  }
  setAttribute(e, n) {
    return n === void 0 ? delete this._attributes[e] : this._attributes[e] = n, this
  }
  setAttributes(e) {
    return Object.keys(e).forEach(n => this.setAttribute(n, e[n])), this
  }
  updateStartTime(e) {
    this._startTime = tt(e)
  }
  setStatus(e) {
    return this._status = e, this
  }
  updateName(e) {
    return this._name = e, this.setAttribute(ne, "custom"), this
  }
  end(e) {
    this._endTime || (this._endTime = tt(e), Do(this), this._onSpanEnded())
  }
  getSpanJSON() {
    return {
      data: this._attributes,
      description: this._name,
      op: this._attributes[Te],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: Sa(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[O],
      profile_id: this._attributes[Ln],
      exclusive_time: this._attributes[Ye],
      measurements: gr(this._events),
      is_segment: this._isStandaloneSpan && X(this) === this || void 0,
      segment_id: this._isStandaloneSpan ? X(this).spanContext().spanId : void 0,
      links: Ea(this._links)
    }
  }
  isRecording() {
    return !this._endTime && !!this._sampled
  }
  addEvent(e, n, r) {
    E && g.log("[Tracing] Adding an event to span:", e);
    const s = hr(n) ? n : r || q(),
      a = hr(n) ? {} : n || {},
      o = {
        name: e,
        time: tt(s),
        attributes: a
      };
    return this._events.push(o), this
  }
  isStandaloneSpan() {
    return !!this._isStandaloneSpan
  }
  _onSpanEnded() {
    const e = k();
    if (e && e.emit("spanEnd", this), !(this._isStandaloneSpan || this === X(this))) return;
    if (this._isStandaloneSpan) {
      this._sampled ? Ho(Oo([this], e)) : (E && g.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled."), e && e.recordDroppedEvent("sample_rate", "span"));
      return
    }
    const r = this._convertSpanToTransaction();
    r && (Zn(this).scope || L()).captureEvent(r)
  }
  _convertSpanToTransaction() {
    var f;
    if (!Er(A(this))) return;
    this._name || (E && g.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this._name = "<unlabeled transaction>");
    const {
      scope: e,
      isolationScope: n
    } = Zn(this), r = (f = e == null ? void 0 : e.getScopeData().sdkProcessingMetadata) == null ? void 0 : f.normalizedRequest;
    if (this._sampled !== !0) return;
    const a = Rt(this).filter(d => d !== this && !Fo(d)).map(d => A(d)).filter(Er),
      o = this._attributes[ne];
    delete this._attributes[Qn], a.forEach(d => {
      delete d.data[Qn]
    });
    const c = {
        contexts: {
          trace: ya(this)
        },
        spans: a.length > _r ? a.sort((d, l) => d.start_timestamp - l.start_timestamp).slice(0, _r) : a,
        start_timestamp: this._startTime,
        timestamp: this._endTime,
        transaction: this._name,
        type: "transaction",
        sdkProcessingMetadata: {
          capturedSpanScope: e,
          capturedSpanIsolationScope: n,
          dynamicSamplingContext: Ce(this)
        },
        request: r,
        ...o && {
          transaction_info: {
            source: o
          }
        }
      },
      i = gr(this._events);
    return i && Object.keys(i).length && (E && g.log("[Measurements] Adding measurements to transaction event", JSON.stringify(i, void 0, 2)), c.measurements = i), c
  }
}

function hr(t) {
  return t && typeof t == "number" || t instanceof Date || Array.isArray(t)
}

function Er(t) {
  return !!t.start_timestamp && !!t.timestamp && !!t.span_id && !!t.trace_id
}

function Fo(t) {
  return t instanceof Yt && t.isStandaloneSpan()
}

function Ho(t) {
  const e = k();
  if (!e) return;
  const n = t[1];
  if (!n || n.length === 0) {
    e.recordDroppedEvent("before_send", "span");
    return
  }
  e.sendEnvelope(t)
}

function Bo(t, e, n = () => {}, r = () => {}) {
  let s;
  try {
    s = t()
  } catch (a) {
    throw e(a), n(), a
  }
  return $o(s, e, n, r)
}

function $o(t, e, n, r) {
  return Gr(t) ? t.then(s => (n(), r(s), s), s => {
    throw e(s), n(), s
  }) : (n(), r(t), t)
}

function Uo(t, e, n) {
  if (!pe(t)) return [!1];
  let r, s;
  typeof t.tracesSampler == "function" ? (s = t.tracesSampler({
    ...e,
    inheritOrSampleWith: c => typeof e.parentSampleRate == "number" ? e.parentSampleRate : typeof e.parentSampled == "boolean" ? Number(e.parentSampled) : c
  }), r = !0) : e.parentSampled !== void 0 ? s = e.parentSampled : typeof t.tracesSampleRate < "u" && (s = t.tracesSampleRate, r = !0);
  const a = Cn(s);
  if (a === void 0) return E && g.warn(`[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(s)} of type ${JSON.stringify(typeof s)}.`), [!1];
  if (!a) return E && g.log(`[Tracing] Discarding transaction because ${typeof t.tracesSampler=="function"?"tracesSampler returned 0 or false":"a negative sampling decision was inherited or tracesSampleRate is set to 0"}`), [!1, a, r];
  const o = n < a;
  return o || E && g.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(s)})`), [o, a, r]
}
const ls = "__SENTRY_SUPPRESS_TRACING__";

function qo(t, e) {
  const n = Fn();
  if (n.startSpan) return n.startSpan(t, e);
  const r = ms(t),
    {
      forceTransaction: s,
      parentSpan: a,
      scope: o
    } = t,
    c = o == null ? void 0 : o.clone();
  return jt(c, () => Vo(a)(() => {
    const u = L(),
      f = gs(u, a),
      l = t.onlyIfParent && !f ? new ve : ps({
        parentSpan: f,
        spanArguments: r,
        forceTransaction: s,
        scope: u
      });
    return Vt(u, l), Bo(() => e(l), () => {
      const {
        status: p
      } = A(l);
      l.isRecording() && (!p || p === "ok") && l.setStatus({
        code: qe,
        message: "internal_error"
      })
    }, () => {
      l.end()
    })
  }))
}

function De(t) {
  const e = Fn();
  if (e.startInactiveSpan) return e.startInactiveSpan(t);
  const n = ms(t),
    {
      forceTransaction: r,
      parentSpan: s
    } = t;
  return (t.scope ? o => jt(t.scope, o) : s !== void 0 ? o => xn(s, o) : o => o())(() => {
    const o = L(),
      c = gs(o, s);
    return t.onlyIfParent && !c ? new ve : ps({
      parentSpan: c,
      spanArguments: n,
      forceTransaction: r,
      scope: o
    })
  })
}

function xn(t, e) {
  const n = Fn();
  return n.withActiveSpan ? n.withActiveSpan(t, e) : jt(r => (Vt(r, t || void 0), e(r)))
}

function ps({
  parentSpan: t,
  spanArguments: e,
  forceTransaction: n,
  scope: r
}) {
  if (!pe()) {
    const o = new ve;
    if (n || !t) {
      const c = {
        sampled: "false",
        sample_rate: "0",
        transaction: e.name,
        ...Ce(o)
      };
      wt(o, c)
    }
    return o
  }
  const s = Wt();
  let a;
  if (t && !n) a = jo(t, r, e), Xr(t, a);
  else if (t) {
    const o = Ce(t),
      {
        traceId: c,
        spanId: i
      } = t.spanContext(),
      u = qt(t);
    a = Sr({
      traceId: c,
      parentSpanId: i,
      ...e
    }, r, u), wt(a, o)
  } else {
    const {
      traceId: o,
      dsc: c,
      parentSpanId: i,
      sampled: u
    } = {
      ...s.getPropagationContext(),
      ...r.getPropagationContext()
    };
    a = Sr({
      traceId: o,
      parentSpanId: i,
      ...e
    }, r, u), c && wt(a, c)
  }
  return Mo(a), Ta(a, r, s), a
}

function ms(t) {
  const n = {
    isStandalone: (t.experimental || {}).standalone,
    ...t
  };
  if (t.startTime) {
    const r = {
      ...n
    };
    return r.startTimestamp = tt(t.startTime), delete r.startTime, r
  }
  return n
}

function Fn() {
  const t = zr();
  return Yr(t)
}

function Sr(t, e, n) {
  var m;
  const r = k(),
    s = (r == null ? void 0 : r.getOptions()) || {},
    {
      name: a = ""
    } = t,
    o = {
      spanAttributes: {
        ...t.attributes
      },
      spanName: a,
      parentSampled: n
    };
  r == null || r.emit("beforeSampling", o, {
    decision: !1
  });
  const c = o.parentSampled ?? n,
    i = o.spanAttributes,
    u = e.getPropagationContext(),
    [f, d, l] = e.getScopeData().sdkProcessingMetadata[ls] ? [!1] : Uo(s, {
      name: a,
      parentSampled: c,
      attributes: i,
      parentSampleRate: Cn((m = u.dsc) == null ? void 0 : m.sample_rate)
    }, u.sampleRand),
    p = new Yt({
      ...t,
      attributes: {
        [ne]: "custom",
        [Jr]: d !== void 0 && l ? d : void 0,
        ...i
      },
      sampled: f
    });
  return !f && r && (E && g.log("[Tracing] Discarding root span because its trace was not chosen to be sampled."), r.recordDroppedEvent("sample_rate", "transaction")), r && r.emit("spanStart", p), p
}

function jo(t, e, n) {
  const {
    spanId: r,
    traceId: s
  } = t.spanContext(), a = e.getScopeData().sdkProcessingMetadata[ls] ? !1 : qt(t), o = a ? new Yt({
    ...n,
    parentSpanId: r,
    traceId: s,
    sampled: a
  }) : new ve({
    traceId: s
  });
  Xr(t, o);
  const c = k();
  return c && (c.emit("spanStart", o), n.endTimestamp && c.emit("spanEnd", o)), o
}

function gs(t, e) {
  if (e) return e;
  if (e === null) return;
  const n = ba(t);
  if (!n) return;
  const r = k();
  return (r ? r.getOptions() : {}).parentSpanIsAlwaysRootSpan ? X(n) : n
}

function Vo(t) {
  return t !== void 0 ? e => xn(t, e) : e => e()
}
const Nt = {
    idleTimeout: 1e3,
    finalTimeout: 3e4,
    childSpanTimeout: 15e3
  },
  Wo = "heartbeatFailed",
  Go = "idleTimeout",
  zo = "finalTimeout",
  Yo = "externalFinish";

function _s(t, e = {}) {
  const n = new Map;
  let r = !1,
    s, a = Yo,
    o = !e.disableAutoFinish;
  const c = [],
    {
      idleTimeout: i = Nt.idleTimeout,
      finalTimeout: u = Nt.finalTimeout,
      childSpanTimeout: f = Nt.childSpanTimeout,
      beforeSpanEnd: d,
      trimIdleSpanEndTimestamp: l = !0
    } = e,
    p = k();
  if (!p || !pe()) {
    const y = new ve,
      M = {
        sample_rate: "0",
        sampled: "false",
        ...Ce(y)
      };
    return wt(y, M), y
  }
  const m = L(),
    _ = J(),
    h = Xo(t);
  h.end = new Proxy(h.end, {
    apply(y, M, ge) {
      if (d && d(h), M instanceof ve) return;
      const [xe, ...ie] = ge, _e = xe || q(), P = tt(_e), $ = Rt(h).filter(T => T !== h), W = A(h);
      if (!$.length || !l) return oe(P), Reflect.apply(y, M, [P, ...ie]);
      const U = p.getOptions().ignoreSpans,
        Z = $ == null ? void 0 : $.reduce((T, D) => {
          const F = A(D);
          return !F.timestamp || U && xt(F, U) ? T : T ? Math.max(T, F.timestamp) : F.timestamp
        }, void 0),
        v = W.start_timestamp,
        I = Math.min(v ? v + u / 1e3 : 1 / 0, Math.max(v || -1 / 0, Math.min(P, Z || 1 / 0)));
      return oe(I), Reflect.apply(y, M, [I, ...ie])
    }
  });

  function R() {
    s && (clearTimeout(s), s = void 0)
  }

  function N(y) {
    R(), s = setTimeout(() => {
      !r && n.size === 0 && o && (a = Go, h.end(y))
    }, i)
  }

  function B(y) {
    s = setTimeout(() => {
      !r && o && (a = Wo, h.end(y))
    }, f)
  }

  function me(y) {
    R(), n.set(y, !0);
    const M = q();
    B(M + f / 1e3)
  }

  function ae(y) {
    if (n.has(y) && n.delete(y), n.size === 0) {
      const M = q();
      N(M + i / 1e3)
    }
  }

  function oe(y) {
    r = !0, n.clear(), c.forEach(P => P()), Vt(m, _);
    const M = A(h),
      {
        start_timestamp: ge
      } = M;
    if (!ge) return;
    M.data[at] || h.setAttribute(at, a), g.log(`[Tracing] Idle span "${M.op}" finished`);
    const ie = Rt(h).filter(P => P !== h);
    let _e = 0;
    ie.forEach(P => {
      P.isRecording() && (P.setStatus({
        code: qe,
        message: "cancelled"
      }), P.end(y), E && g.log("[Tracing] Cancelling span since span ended early", JSON.stringify(P, void 0, 2)));
      const $ = A(P),
        {
          timestamp: W = 0,
          start_timestamp: U = 0
        } = $,
        Z = U <= y,
        v = (u + i) / 1e3,
        I = W - U <= v;
      if (E) {
        const T = JSON.stringify(P, void 0, 2);
        Z ? I || g.log("[Tracing] Discarding span since it finished after idle span final timeout", T) : g.log("[Tracing] Discarding span since it happened after idle span was finished", T)
      }(!I || !Z) && (va(h, P), _e++)
    }), _e > 0 && h.setAttribute("sentry.idle_span_discarded_spans", _e)
  }
  return c.push(p.on("spanStart", y => {
    if (r || y === h || A(y).timestamp || y instanceof Yt && y.isStandaloneSpan()) return;
    Rt(h).includes(y) && me(y.spanContext().spanId)
  })), c.push(p.on("spanEnd", y => {
    r || ae(y.spanContext().spanId)
  })), c.push(p.on("idleSpanEnableAutoFinish", y => {
    y === h && (o = !0, N(), n.size && B())
  })), e.disableAutoFinish || N(), setTimeout(() => {
    r || (h.setStatus({
      code: qe,
      message: "deadline_exceeded"
    }), a = zo, h.end())
  }, u), h
}

function Xo(t) {
  const e = De(t);
  return Vt(L(), e), E && g.log("[Tracing] Started span is an idle span"), e
}
const Jo = "7";

function Ko(t) {
  const e = t.protocol ? `${t.protocol}:` : "",
    n = t.port ? `:${t.port}` : "";
  return `${e}//${t.host}${n}${t.path?`/${t.path}`:""}/api/`
}

function Zo(t) {
  return `${Ko(t)}${t.projectId}/envelope/`
}

function Qo(t, e) {
  const n = {
    sentry_version: Jo
  };
  return t.publicKey && (n.sentry_key = t.publicKey), e && (n.sentry_client = `${e.name}/${e.version}`), new URLSearchParams(n).toString()
}

function ei(t, e, n) {
  return e || `${Zo(t)}?${Qo(t,n)}`
}
const yr = [];

function ti(t) {
  const e = {};
  return t.forEach(n => {
    const {
      name: r
    } = n, s = e[r];
    s && !s.isDefaultInstance && n.isDefaultInstance || (e[r] = n)
  }), Object.values(e)
}

function ni(t) {
  const e = t.defaultIntegrations || [],
    n = t.integrations;
  e.forEach(s => {
    s.isDefaultInstance = !0
  });
  let r;
  if (Array.isArray(n)) r = [...e, ...n];
  else if (typeof n == "function") {
    const s = n(e);
    r = Array.isArray(s) ? s : [s]
  } else r = e;
  return ti(r)
}

function ri(t, e) {
  const n = {};
  return e.forEach(r => {
    r && hs(t, r, n)
  }), n
}

function br(t, e) {
  for (const n of e) n != null && n.afterAllSetup && n.afterAllSetup(t)
}

function hs(t, e, n) {
  if (n[e.name]) {
    E && g.log(`Integration skipped because it was already installed: ${e.name}`);
    return
  }
  if (n[e.name] = e, yr.indexOf(e.name) === -1 && typeof e.setupOnce == "function" && (e.setupOnce(), yr.push(e.name)), e.setup && typeof e.setup == "function" && e.setup(t), typeof e.preprocessEvent == "function") {
    const r = e.preprocessEvent.bind(e);
    t.on("preprocessEvent", (s, a) => r(s, a, t))
  }
  if (typeof e.processEvent == "function") {
    const r = e.processEvent.bind(e),
      s = Object.assign((a, o) => r(a, o, t), {
        id: e.name
      });
    t.addEventProcessor(s)
  }
  E && g.log(`Integration installed: ${e.name}`)
}

function si(t) {
  return [{
    type: "log",
    item_count: t.length,
    content_type: "application/vnd.sentry.items.log+json"
  }, {
    items: t
  }]
}

function ai(t, e, n, r) {
  const s = {};
  return e != null && e.sdk && (s.sdk = {
    name: e.sdk.name,
    version: e.sdk.version
  }), n && r && (s.dsn = ze(r)), Me(s, [si(t)])
}

function Es(t, e) {
  const n = e ?? oi(t) ?? [];
  if (n.length === 0) return;
  const r = t.getOptions(),
    s = ai(n, r._metadata, r.tunnel, t.getDsn());
  Ss().set(t, []), t.emit("flushLogs"), t.sendEnvelope(s)
}

function oi(t) {
  return Ss().get(t)
}

function Ss() {
  return Kr("clientToLogBufferMap", () => new WeakMap)
}

function ii(t) {
  return [{
    type: "trace_metric",
    item_count: t.length,
    content_type: "application/vnd.sentry.items.trace-metric+json"
  }, {
    items: t
  }]
}

function ci(t, e, n, r) {
  const s = {};
  return e != null && e.sdk && (s.sdk = {
    name: e.sdk.name,
    version: e.sdk.version
  }), n && r && (s.dsn = ze(r)), Me(s, [ii(t)])
}

function ys(t, e) {
  const n = e ?? ui(t) ?? [];
  if (n.length === 0) return;
  const r = t.getOptions(),
    s = ci(n, r._metadata, r.tunnel, t.getDsn());
  bs().set(t, []), t.emit("flushMetrics"), t.sendEnvelope(s)
}

function ui(t) {
  return bs().get(t)
}

function bs() {
  return Kr("clientToMetricBufferMap", () => new WeakMap)
}

function di(t, e, n) {
  const r = [{
    type: "client_report"
  }, {
    timestamp: Gt(),
    discarded_events: t
  }];
  return Me(e ? {
    dsn: e
  } : {}, [r])
}

function Ts(t) {
  const e = [];
  t.message && e.push(t.message);
  try {
    const n = t.exception.values[t.exception.values.length - 1];
    n != null && n.value && (e.push(n.value), n.type && e.push(`${n.type}: ${n.value}`))
  } catch {}
  return e
}

function fi(t) {
  var i;
  const {
    trace_id: e,
    parent_span_id: n,
    span_id: r,
    status: s,
    origin: a,
    data: o,
    op: c
  } = ((i = t.contexts) == null ? void 0 : i.trace) ?? {};
  return {
    data: o ?? {},
    description: t.transaction,
    op: c,
    parent_span_id: n,
    span_id: r ?? "",
    start_timestamp: t.start_timestamp ?? 0,
    status: s,
    timestamp: t.timestamp,
    trace_id: e ?? "",
    origin: a,
    profile_id: o == null ? void 0 : o[Ln],
    exclusive_time: o == null ? void 0 : o[Ye],
    measurements: t.measurements,
    is_segment: !0
  }
}

function li(t) {
  return {
    type: "transaction",
    timestamp: t.timestamp,
    start_timestamp: t.start_timestamp,
    transaction: t.description,
    contexts: {
      trace: {
        trace_id: t.trace_id,
        span_id: t.span_id,
        parent_span_id: t.parent_span_id,
        op: t.op,
        status: t.status,
        origin: t.origin,
        data: {
          ...t.data,
          ...t.profile_id && {
            [Ln]: t.profile_id
          },
          ...t.exclusive_time && {
            [Ye]: t.exclusive_time
          }
        }
      }
    },
    measurements: t.measurements
  }
}
const Tr = "Not capturing exception because it's already been captured.",
  vr = "Discarded session because of missing or non-string release",
  vs = Symbol.for("SentryInternalError"),
  Is = Symbol.for("SentryDoNotSendEventError"),
  pi = 5e3;

function Lt(t) {
  return {
    message: t,
    [vs]: !0
  }
}

function sn(t) {
  return {
    message: t,
    [Is]: !0
  }
}

function Ir(t) {
  return !!t && typeof t == "object" && vs in t
}

function Rr(t) {
  return !!t && typeof t == "object" && Is in t
}

function wr(t, e, n, r, s) {
  let a = 0,
    o;
  t.on(n, () => {
    a = 0, clearTimeout(o)
  }), t.on(e, c => {
    a += r(c), a >= 8e5 ? s(t) : (clearTimeout(o), o = setTimeout(() => {
      s(t)
    }, pi))
  }), t.on("flush", () => {
    s(t)
  })
}
class mi {
  constructor(e) {
    var r;
    if (this._options = e, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], e.dsn ? this._dsn = Ia(e.dsn) : E && g.warn("No DSN provided, client will not send events."), this._dsn) {
      const s = ei(this._dsn, e.tunnel, e._metadata ? e._metadata.sdk : void 0);
      this._transport = e.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...e.transportOptions,
        url: s
      })
    }
    this._options.enableLogs && wr(this, "afterCaptureLog", "flushLogs", Ei, Es), (this._options.enableMetrics ?? ((r = this._options._experiments) == null ? void 0 : r.enableMetrics) ?? !0) && wr(this, "afterCaptureMetric", "flushMetrics", hi, ys)
  }
  captureException(e, n, r) {
    const s = At();
    if (er(e)) return E && g.log(Tr), s;
    const a = {
      event_id: s,
      ...n
    };
    return this._process(this.eventFromException(e, a).then(o => this._captureEvent(o, a, r))), a.event_id
  }
  captureMessage(e, n, r, s) {
    const a = {
        event_id: At(),
        ...r
      },
      o = es(e) ? e : String(e),
      c = je(e) ? this.eventFromMessage(o, n, a) : this.eventFromException(e, a);
    return this._process(c.then(i => this._captureEvent(i, a, s))), a.event_id
  }
  captureEvent(e, n, r) {
    const s = At();
    if (n != null && n.originalException && er(n.originalException)) return E && g.log(Tr), s;
    const a = {
        event_id: s,
        ...n
      },
      o = e.sdkProcessingMetadata || {},
      c = o.capturedSpanScope,
      i = o.capturedSpanIsolationScope;
    return this._process(this._captureEvent(e, a, c || r, i)), a.event_id
  }
  captureSession(e) {
    this.sendSession(e), tr(e, {
      init: !1
    })
  }
  getDsn() {
    return this._dsn
  }
  getOptions() {
    return this._options
  }
  getSdkMetadata() {
    return this._options._metadata
  }
  getTransport() {
    return this._transport
  }
  async flush(e) {
    const n = this._transport;
    if (!n) return !0;
    this.emit("flush");
    const r = await this._isClientDoneProcessing(e),
      s = await n.flush(e);
    return r && s
  }
  async close(e) {
    const n = await this.flush(e);
    return this.getOptions().enabled = !1, this.emit("close"), n
  }
  getEventProcessors() {
    return this._eventProcessors
  }
  addEventProcessor(e) {
    this._eventProcessors.push(e)
  }
  init() {
    (this._isEnabled() || this._options.integrations.some(({
      name: e
    }) => e.startsWith("Spotlight"))) && this._setupIntegrations()
  }
  getIntegrationByName(e) {
    return this._integrations[e]
  }
  addIntegration(e) {
    const n = this._integrations[e.name];
    hs(this, e, this._integrations), n || br(this, [e])
  }
  sendEvent(e, n = {}) {
    this.emit("beforeSendEvent", e, n);
    let r = Co(e, this._dsn, this._options._metadata, this._options.tunnel);
    for (const s of n.attachments || []) r = vo(r, Ao(s));
    this.sendEnvelope(r).then(s => this.emit("afterSendEvent", e, s))
  }
  sendSession(e) {
    const {
      release: n,
      environment: r = Ra
    } = this._options;
    if ("aggregates" in e) {
      const a = e.attrs || {};
      if (!a.release && !n) {
        E && g.warn(vr);
        return
      }
      a.release = a.release || n, a.environment = a.environment || r, e.attrs = a
    } else {
      if (!e.release && !n) {
        E && g.warn(vr);
        return
      }
      e.release = e.release || n, e.environment = e.environment || r
    }
    this.emit("beforeSendSession", e);
    const s = Lo(e, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(s)
  }
  recordDroppedEvent(e, n, r = 1) {
    if (this._options.sendClientReports) {
      const s = `${e}:${n}`;
      E && g.log(`Recording outcome: "${s}"${r>1?` (${r} times)`:""}`), this._outcomes[s] = (this._outcomes[s] || 0) + r
    }
  }
  on(e, n) {
    const r = this._hooks[e] = this._hooks[e] || new Set,
      s = (...a) => n(...a);
    return r.add(s), () => {
      r.delete(s)
    }
  }
  emit(e, ...n) {
    const r = this._hooks[e];
    r && r.forEach(s => s(...n))
  }
  async sendEnvelope(e) {
    if (this.emit("beforeEnvelope", e), this._isEnabled() && this._transport) try {
      return await this._transport.send(e)
    } catch (n) {
      return E && g.error("Error while sending envelope:", n), {}
    }
    return E && g.error("Transport disabled"), {}
  }
  _setupIntegrations() {
    const {
      integrations: e
    } = this._options;
    this._integrations = ri(this, e), br(this, e)
  }
  _updateSessionFromEvent(e, n) {
    var i, u;
    let r = n.level === "fatal",
      s = !1;
    const a = (i = n.exception) == null ? void 0 : i.values;
    if (a) {
      s = !0, r = !1;
      for (const f of a)
        if (((u = f.mechanism) == null ? void 0 : u.handled) === !1) {
          r = !0;
          break
        }
    }
    const o = e.status === "ok";
    (o && e.errors === 0 || o && r) && (tr(e, {
      ...r && {
        status: "crashed"
      },
      errors: e.errors || Number(s || r)
    }), this.captureSession(e))
  }
  async _isClientDoneProcessing(e) {
    let n = 0;
    for (; !e || n < e;) {
      if (await new Promise(r => setTimeout(r, 1)), !this._numProcessing) return !0;
      n++
    }
    return !1
  }
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0
  }
  _prepareEvent(e, n, r, s) {
    const a = this.getOptions(),
      o = Object.keys(this._integrations);
    return !n.integrations && (o != null && o.length) && (n.integrations = o), this.emit("preprocessEvent", e, n), e.type || s.setLastEventId(e.event_id || n.event_id), wa(a, e, n, r, this, s).then(c => {
      if (c === null) return c;
      this.emit("postprocessEvent", c, n), c.contexts = {
        trace: Aa(r),
        ...c.contexts
      };
      const i = Zr(this, r);
      return c.sdkProcessingMetadata = {
        dynamicSamplingContext: i,
        ...c.sdkProcessingMetadata
      }, c
    })
  }
  _captureEvent(e, n = {}, r = L(), s = Wt()) {
    return E && hn(e) && g.log(`Captured error event \`${Ts(e)[0]||"<unknown>"}\``), this._processEvent(e, n, r, s).then(a => a.event_id, a => {
      E && (Rr(a) ? g.log(a.message) : Ir(a) ? g.warn(a.message) : g.warn(a))
    })
  }
  _processEvent(e, n, r, s) {
    const a = this.getOptions(),
      {
        sampleRate: o
      } = a,
      c = Rs(e),
      i = hn(e),
      u = e.type || "error",
      f = `before send for type \`${u}\``,
      d = typeof o > "u" ? void 0 : Cn(o);
    if (i && typeof d == "number" && Math.random() > d) return this.recordDroppedEvent("sample_rate", "error"), Qr(sn(`Discarding event because it's not included in the random sample (sampling rate = ${o})`));
    const l = u === "replay_event" ? "replay" : u;
    return this._prepareEvent(e, n, r, s).then(p => {
      if (p === null) throw this.recordDroppedEvent("event_processor", l), sn("An event processor returned `null`, will not send event.");
      if (n.data && n.data.__sentry__ === !0) return p;
      const _ = _i(this, a, p, n);
      return gi(_, f)
    }).then(p => {
      var h;
      if (p === null) {
        if (this.recordDroppedEvent("before_send", l), c) {
          const N = 1 + (e.spans || []).length;
          this.recordDroppedEvent("before_send", "span", N)
        }
        throw sn(`${f} returned \`null\`, will not send event.`)
      }
      const m = r.getSession() || s.getSession();
      if (i && m && this._updateSessionFromEvent(m, p), c) {
        const R = ((h = p.sdkProcessingMetadata) == null ? void 0 : h.spanCountBeforeProcessing) || 0,
          N = p.spans ? p.spans.length : 0,
          B = R - N;
        B > 0 && this.recordDroppedEvent("before_send", "span", B)
      }
      const _ = p.transaction_info;
      if (c && _ && p.transaction !== e.transaction) {
        const R = "custom";
        p.transaction_info = {
          ..._,
          source: R
        }
      }
      return this.sendEvent(p, n), p
    }).then(null, p => {
      throw Rr(p) || Ir(p) ? p : (this.captureException(p, {
        mechanism: {
          handled: !1,
          type: "internal"
        },
        data: {
          __sentry__: !0
        },
        originalException: p
      }), Lt(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${p}`))
    })
  }
  _process(e) {
    this._numProcessing++, e.then(n => (this._numProcessing--, n), n => (this._numProcessing--, n))
  }
  _clearOutcomes() {
    const e = this._outcomes;
    return this._outcomes = {}, Object.entries(e).map(([n, r]) => {
      const [s, a] = n.split(":");
      return {
        reason: s,
        category: a,
        quantity: r
      }
    })
  }
  _flushOutcomes() {
    E && g.log("Flushing outcomes...");
    const e = this._clearOutcomes();
    if (e.length === 0) {
      E && g.log("No outcomes to send");
      return
    }
    if (!this._dsn) {
      E && g.log("No dsn provided, will not send outcomes");
      return
    }
    E && g.log("Sending outcomes:", e);
    const n = di(e, this._options.tunnel && ze(this._dsn));
    this.sendEnvelope(n)
  }
}

function gi(t, e) {
  const n = `${e} must return \`null\` or a valid event.`;
  if (Gr(t)) return t.then(r => {
    if (!mn(r) && r !== null) throw Lt(n);
    return r
  }, r => {
    throw Lt(`${e} rejected with ${r}`)
  });
  if (!mn(t) && t !== null) throw Lt(n);
  return t
}

function _i(t, e, n, r) {
  const {
    beforeSend: s,
    beforeSendTransaction: a,
    beforeSendSpan: o,
    ignoreSpans: c
  } = e;
  let i = n;
  if (hn(i) && s) return s(i, r);
  if (Rs(i)) {
    if (o || c) {
      const u = fi(i);
      if (c != null && c.length && xt(u, c)) return null;
      if (o) {
        const f = o(u);
        f ? i = Pa(n, li(f)) : pn()
      }
      if (i.spans) {
        const f = [],
          d = i.spans;
        for (const p of d) {
          if (c != null && c.length && xt(p, c)) {
            bo(d, p);
            continue
          }
          if (o) {
            const m = o(p);
            m ? f.push(m) : (pn(), f.push(p))
          } else f.push(p)
        }
        const l = i.spans.length - f.length;
        l && t.recordDroppedEvent("before_send", "span", l), i.spans = f
      }
    }
    if (a) {
      if (i.spans) {
        const u = i.spans.length;
        i.sdkProcessingMetadata = {
          ...n.sdkProcessingMetadata,
          spanCountBeforeProcessing: u
        }
      }
      return a(i, r)
    }
  }
  return i
}

function hn(t) {
  return t.type === void 0
}

function Rs(t) {
  return t.type === "transaction"
}

function hi(t) {
  let e = 0;
  return t.name && (e += t.name.length * 2), e += 8, e + ws(t.attributes)
}

function Ei(t) {
  let e = 0;
  return t.message && (e += t.message.length * 2), e + ws(t.attributes)
}

function ws(t) {
  if (!t) return 0;
  let e = 0;
  return Object.values(t).forEach(n => {
    Array.isArray(n) ? e += n.length * Ar(n[0]) : je(n) ? e += Ar(n) : e += 100
  }), e
}

function Ar(t) {
  return typeof t == "string" ? t.length * 2 : typeof t == "number" ? 8 : typeof t == "boolean" ? 4 : 0
}

function Si(t, e) {
  e.debug === !0 && (E ? g.enable() : zt(() => {
    console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.")
  })), L().update(e.initialScope);
  const r = new t(e);
  return yi(r), r.init(), r
}

function yi(t) {
  L().setClient(t)
}
const As = Symbol.for("SentryBufferFullError");

function Ps(t = 100) {
  const e = new Set;

  function n() {
    return e.size < t
  }

  function r(o) {
    e.delete(o)
  }

  function s(o) {
    if (!n()) return Qr(As);
    const c = o();
    return e.add(c), c.then(() => r(c), () => r(c)), c
  }

  function a(o) {
    if (!e.size) return On(!0);
    const c = Promise.allSettled(Array.from(e)).then(() => !0);
    if (!o) return c;
    const i = [c, new Promise(u => setTimeout(() => u(!1), o))];
    return Promise.race(i)
  }
  return {
    get $() {
      return Array.from(e)
    },
    add: s,
    drain: a
  }
}
const bi = 60 * 1e3;

function Ti(t, e = Date.now()) {
  const n = parseInt(`${t}`, 10);
  if (!isNaN(n)) return n * 1e3;
  const r = Date.parse(`${t}`);
  return isNaN(r) ? bi : r - e
}

function vi(t, e) {
  return t[e] || t.all || 0
}

function Ii(t, e, n = Date.now()) {
  return vi(t, e) > n
}

function Ri(t, {
  statusCode: e,
  headers: n
}, r = Date.now()) {
  const s = {
      ...t
    },
    a = n == null ? void 0 : n["x-sentry-rate-limits"],
    o = n == null ? void 0 : n["retry-after"];
  if (a)
    for (const c of a.trim().split(",")) {
      const [i, u, , , f] = c.split(":", 5), d = parseInt(i, 10), l = (isNaN(d) ? 60 : d) * 1e3;
      if (!u) s.all = r + l;
      else
        for (const p of u.split(";")) p === "metric_bucket" ? (!f || f.split(";").includes("custom")) && (s[p] = r + l) : s[p] = r + l
    } else o ? s.all = r + Ti(o, r) : e === 429 && (s.all = r + 60 * 1e3);
  return s
}
const wi = 64;

function Ai(t, e, n = Ps(t.bufferSize || wi)) {
  let r = {};
  const s = o => n.drain(o);

  function a(o) {
    const c = [];
    if (pr(o, (d, l) => {
        const p = mr(l);
        Ii(r, p) ? t.recordDroppedEvent("ratelimit_backoff", p) : c.push(d)
      }), c.length === 0) return Promise.resolve({});
    const i = Me(o[0], c),
      u = d => {
        pr(i, (l, p) => {
          t.recordDroppedEvent(d, mr(p))
        })
      },
      f = () => e({
        body: Io(i)
      }).then(d => (d.statusCode !== void 0 && (d.statusCode < 200 || d.statusCode >= 300) && E && g.warn(`Sentry responded with status code ${d.statusCode} to sent event.`), r = Ri(r, d), d), d => {
        throw u("network_error"), E && g.error("Encountered error running transport request:", d), d
      });
    return n.add(f).then(d => d, d => {
      if (d === As) return E && g.error("Skipped sending event because buffer is full."), u("queue_overflow"), Promise.resolve({});
      throw d
    })
  }
  return {
    send: a,
    flush: s
  }
}
const Pi = "thismessage:/";

function ks(t) {
  return "isRelative" in t
}

function Ns(t, e) {
  const n = t.indexOf("://") <= 0 && t.indexOf("//") !== 0,
    r = n ? Pi : void 0;
  try {
    if ("canParse" in URL && !URL.canParse(t, r)) return;
    const s = new URL(t, r);
    return n ? {
      isRelative: n,
      pathname: s.pathname,
      search: s.search,
      hash: s.hash
    } : s
  } catch {}
}

function ki(t) {
  if (ks(t)) return t.pathname;
  const e = new URL(t);
  return e.search = "", e.hash = "", ["80", "443"].includes(e.port) && (e.port = ""), e.password && (e.password = "%filtered%"), e.username && (e.username = "%filtered%"), e.toString()
}

function Le(t) {
  if (!t) return {};
  const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!e) return {};
  const n = e[6] || "",
    r = e[8] || "";
  return {
    host: e[4],
    path: e[5],
    protocol: e[2],
    search: n,
    hash: r,
    relative: e[5] + n + r
  }
}

function Ni(t) {
  return t.split(/[?#]/, 1)[0]
}

function Li(t) {
  var e;
  "aggregates" in t ? ((e = t.attrs) == null ? void 0 : e.ip_address) === void 0 && (t.attrs = {
    ...t.attrs,
    ip_address: "{{auto}}"
  }) : t.ipAddress === void 0 && (t.ipAddress = "{{auto}}")
}

function Hn(t, e, n = [e], r = "npm") {
  const s = t._metadata || {};
  s.sdk || (s.sdk = {
    name: `sentry.javascript.${e}`,
    packages: n.map(a => ({
      name: `${r}:@sentry/${a}`,
      version: nr
    })),
    version: nr
  }), t._metadata = s
}

function Ls(t = {}) {
  const e = t.client || k();
  if (!ka() || !e) return {};
  const n = zr(),
    r = Yr(n);
  if (r.getTraceData) return r.getTraceData(t);
  const s = t.scope || L(),
    a = t.span || J(),
    o = a ? Na(a) : Ci(s),
    c = a ? Ce(a) : Zr(e, s),
    i = La(c);
  if (!Ca.test(o)) return g.warn("Invalid sentry-trace data. Cannot generate trace data"), {};
  const f = {
    "sentry-trace": o,
    baggage: i
  };
  if (t.propagateTraceparent) {
    const d = a ? Oa(a) : Oi(s);
    d && (f.traceparent = d)
  }
  return f
}

function Ci(t) {
  const {
    traceId: e,
    sampled: n,
    propagationSpanId: r
  } = t.getPropagationContext();
  return Ma(e, r, n)
}

function Oi(t) {
  const {
    traceId: e,
    sampled: n,
    propagationSpanId: r
  } = t.getPropagationContext();
  return Da(e, r, n)
}
const Mi = 100;

function Oe(t, e) {
  const n = k(),
    r = Wt();
  if (!n) return;
  const {
    beforeBreadcrumb: s = null,
    maxBreadcrumbs: a = Mi
  } = n.getOptions();
  if (a <= 0) return;
  const c = {
      timestamp: Gt(),
      ...t
    },
    i = s ? zt(() => s(c, e)) : c;
  i !== null && (n.emit && n.emit("beforeAddBreadcrumb", i, e), r.addBreadcrumb(i, a))
}
let Pr;
const Di = "FunctionToString",
  kr = new WeakMap,
  xi = (() => ({
    name: Di,
    setupOnce() {
      Pr = Function.prototype.toString;
      try {
        Function.prototype.toString = function(...t) {
          const e = Mn(this),
            n = kr.has(k()) && e !== void 0 ? e : this;
          return Pr.apply(n, t)
        }
      } catch {}
    },
    setup(t) {
      kr.set(t, !0)
    }
  })),
  Fi = xi,
  Hi = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, /^Can't find variable: gmo$/, /^undefined is not an object \(evaluating 'a\.[A-Z]'\)$/, `can't redefine non-configurable property "solana"`, "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler", /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/, /^Java exception was raised during method invocation$/],
  Bi = "EventFilters",
  $i = (t = {}) => {
    let e;
    return {
      name: Bi,
      setup(n) {
        const r = n.getOptions();
        e = Nr(t, r)
      },
      processEvent(n, r, s) {
        if (!e) {
          const a = s.getOptions();
          e = Nr(t, a)
        }
        return qi(n, e) ? null : n
      }
    }
  },
  Ui = ((t = {}) => ({
    ...$i(t),
    name: "InboundFilters"
  }));

function Nr(t = {}, e = {}) {
  return {
    allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
    denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
    ignoreErrors: [...t.ignoreErrors || [], ...e.ignoreErrors || [], ...t.disableErrorDefaults ? [] : Hi],
    ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || []]
  }
}

function qi(t, e) {
  if (t.type) {
    if (t.type === "transaction" && Vi(t, e.ignoreTransactions)) return E && g.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${Ne(t)}`), !0
  } else {
    if (ji(t, e.ignoreErrors)) return E && g.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${Ne(t)}`), !0;
    if (Yi(t)) return E && g.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${Ne(t)}`), !0;
    if (Wi(t, e.denyUrls)) return E && g.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${Ne(t)}.
Url: ${Ft(t)}`), !0;
    if (!Gi(t, e.allowUrls)) return E && g.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${Ne(t)}.
Url: ${Ft(t)}`), !0
  }
  return !1
}

function ji(t, e) {
  return e != null && e.length ? Ts(t).some(n => ye(n, e)) : !1
}

function Vi(t, e) {
  if (!(e != null && e.length)) return !1;
  const n = t.transaction;
  return n ? ye(n, e) : !1
}

function Wi(t, e) {
  if (!(e != null && e.length)) return !1;
  const n = Ft(t);
  return n ? ye(n, e) : !1
}

function Gi(t, e) {
  if (!(e != null && e.length)) return !0;
  const n = Ft(t);
  return n ? ye(n, e) : !0
}

function zi(t = []) {
  for (let e = t.length - 1; e >= 0; e--) {
    const n = t[e];
    if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]") return n.filename || null
  }
  return null
}

function Ft(t) {
  var e, n;
  try {
    const r = [...((e = t.exception) == null ? void 0 : e.values) ?? []].reverse().find(a => {
        var o, c, i;
        return ((o = a.mechanism) == null ? void 0 : o.parent_id) === void 0 && ((i = (c = a.stacktrace) == null ? void 0 : c.frames) == null ? void 0 : i.length)
      }),
      s = (n = r == null ? void 0 : r.stacktrace) == null ? void 0 : n.frames;
    return s ? zi(s) : null
  } catch {
    return E && g.error(`Cannot extract url for event ${Ne(t)}`), null
  }
}

function Yi(t) {
  var e, n;
  return (n = (e = t.exception) == null ? void 0 : e.values) != null && n.length ? !t.message && !t.exception.values.some(r => r.stacktrace || r.type && r.type !== "Error" || r.value) : !1
}

function Xi(t, e, n, r, s, a) {
  var c;
  if (!((c = s.exception) != null && c.values) || !a || !Dt(a.originalException, Error)) return;
  const o = s.exception.values.length > 0 ? s.exception.values[s.exception.values.length - 1] : void 0;
  o && (s.exception.values = En(t, e, r, a.originalException, n, s.exception.values, o, 0))
}

function En(t, e, n, r, s, a, o, c) {
  if (a.length >= n + 1) return a;
  let i = [...a];
  if (Dt(r[s], Error)) {
    Lr(o, c);
    const u = t(e, r[s]),
      f = i.length;
    Cr(u, s, f, c), i = En(t, e, n, r[s], s, [u, ...i], u, f)
  }
  return Array.isArray(r.errors) && r.errors.forEach((u, f) => {
    if (Dt(u, Error)) {
      Lr(o, c);
      const d = t(e, u),
        l = i.length;
      Cr(d, `errors[${f}]`, l, c), i = En(t, e, n, u, s, [d, ...i], d, l)
    }
  }), i
}

function Lr(t, e) {
  t.mechanism = {
    handled: !0,
    type: "auto.core.linked_errors",
    ...t.mechanism,
    ...t.type === "AggregateError" && {
      is_exception_group: !0
    },
    exception_id: e
  }
}

function Cr(t, e, n, r) {
  t.mechanism = {
    handled: !0,
    ...t.mechanism,
    type: "chained",
    source: e,
    exception_id: n,
    parent_id: r
  }
}

function Ji(t) {
  const e = "console";
  Re(e, t), we(e, Ki)
}

function Ki() {
  "console" in x && xa.forEach(function(t) {
    t in x.console && Y(x.console, t, function(e) {
      return rr[t] = e,
        function(...n) {
          re("console", {
            args: n,
            level: t
          });
          const s = rr[t];
          s == null || s.apply(x.console, n)
        }
    })
  })
}

function Zi(t) {
  return t === "warn" ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(t) ? t : "log"
}
const Qi = "Dedupe",
  ec = (() => {
    let t;
    return {
      name: Qi,
      processEvent(e) {
        if (e.type) return e;
        try {
          if (nc(e, t)) return E && g.warn("Event dropped due to being a duplicate of previously captured event."), null
        } catch {}
        return t = e
      }
    }
  }),
  tc = ec;

function nc(t, e) {
  return e ? !!(rc(t, e) || sc(t, e)) : !1
}

function rc(t, e) {
  const n = t.message,
    r = e.message;
  return !(!n && !r || n && !r || !n && r || n !== r || !Os(t, e) || !Cs(t, e))
}

function sc(t, e) {
  const n = Or(e),
    r = Or(t);
  return !(!n || !r || n.type !== r.type || n.value !== r.value || !Os(t, e) || !Cs(t, e))
}

function Cs(t, e) {
  let n = sr(t),
    r = sr(e);
  if (!n && !r) return !0;
  if (n && !r || !n && r || (n = n, r = r, r.length !== n.length)) return !1;
  for (let s = 0; s < r.length; s++) {
    const a = r[s],
      o = n[s];
    if (a.filename !== o.filename || a.lineno !== o.lineno || a.colno !== o.colno || a.function !== o.function) return !1
  }
  return !0
}

function Os(t, e) {
  let n = t.fingerprint,
    r = e.fingerprint;
  if (!n && !r) return !0;
  if (n && !r || !n && r) return !1;
  n = n, r = r;
  try {
    return n.join("") === r.join("")
  } catch {
    return !1
  }
}

function Or(t) {
  var e, n;
  return (n = (e = t.exception) == null ? void 0 : e.values) == null ? void 0 : n[0]
}

function ac(t, e, n, r, s) {
  if (!t.fetchData) return;
  const {
    method: a,
    url: o
  } = t.fetchData, c = pe() && e(o);
  if (t.endTimestamp && c) {
    const p = t.fetchData.__span;
    if (!p) return;
    const m = r[p];
    m && (cc(m, t), oc(m, t, s), delete r[p]);
    return
  }
  const {
    spanOrigin: i = "auto.http.browser",
    propagateTraceparent: u = !1
  } = typeof s == "object" ? s : {
    spanOrigin: s
  }, f = !!J(), d = c && f ? De(dc(o, a, i)) : new ve;
  if (t.fetchData.__span = d.spanContext().spanId, r[d.spanContext().spanId] = d, n(t.fetchData.url)) {
    const p = t.args[0],
      m = t.args[1] || {},
      _ = ic(p, m, pe() && f ? d : void 0, u);
    _ && (t.args[1] = m, m.headers = _)
  }
  const l = k();
  if (l) {
    const p = {
      input: t.args,
      response: t.response,
      startTimestamp: t.startTimestamp,
      endTimestamp: t.endTimestamp
    };
    l.emit("beforeOutgoingRequestSpan", d, p)
  }
  return d
}

function oc(t, e, n) {
  var s;
  const r = typeof n == "object" && n !== null ? n.onRequestSpanEnd : void 0;
  r == null || r(t, {
    headers: (s = e.response) == null ? void 0 : s.headers,
    error: e.error
  })
}

function ic(t, e, n, r) {
  const s = Ls({
      span: n,
      propagateTraceparent: r
    }),
    a = s["sentry-trace"],
    o = s.baggage,
    c = s.traceparent;
  if (!a) return;
  const i = e.headers || (ns(t) ? t.headers : void 0);
  if (i)
    if (uc(i)) {
      const u = new Headers(i);
      if (u.get("sentry-trace") || u.set("sentry-trace", a), r && c && !u.get("traceparent") && u.set("traceparent", c), o) {
        const f = u.get("baggage");
        f ? yt(f) || u.set("baggage", `${f},${o}`) : u.set("baggage", o)
      }
      return u
    } else if (Array.isArray(i)) {
    const u = [...i];
    i.find(d => d[0] === "sentry-trace") || u.push(["sentry-trace", a]), r && c && !i.find(d => d[0] === "traceparent") && u.push(["traceparent", c]);
    const f = i.find(d => d[0] === "baggage" && yt(d[1]));
    return o && !f && u.push(["baggage", o]), u
  } else {
    const u = "sentry-trace" in i ? i["sentry-trace"] : void 0,
      f = "traceparent" in i ? i.traceparent : void 0,
      d = "baggage" in i ? i.baggage : void 0,
      l = d ? Array.isArray(d) ? [...d] : [d] : [],
      p = d && (Array.isArray(d) ? d.find(_ => yt(_)) : yt(d));
    o && !p && l.push(o);
    const m = {
      ...i,
      "sentry-trace": u ?? a,
      baggage: l.length > 0 ? l.join(",") : void 0
    };
    return r && c && !f && (m.traceparent = c), m
  } else return {
    ...s
  }
}

function cc(t, e) {
  var n, r;
  if (e.response) {
    ts(t, e.response.status);
    const s = (r = (n = e.response) == null ? void 0 : n.headers) == null ? void 0 : r.get("content-length");
    if (s) {
      const a = parseInt(s);
      a > 0 && t.setAttribute("http.response_content_length", a)
    }
  } else e.error && t.setStatus({
    code: qe,
    message: "internal_error"
  });
  t.end()
}

function yt(t) {
  return t.split(",").some(e => e.trim().startsWith(Fa))
}

function uc(t) {
  return typeof Headers < "u" && Dt(t, Headers)
}

function dc(t, e, n) {
  const r = Ns(t);
  return {
    name: r ? `${e} ${ki(r)}` : e,
    attributes: fc(t, r, e, n)
  }
}

function fc(t, e, n, r) {
  const s = {
    url: t,
    type: "fetch",
    "http.method": n,
    [O]: r,
    [Te]: "http.client"
  };
  return e && (ks(e) || (s["http.url"] = e.href, s["server.address"] = e.host), e.search && (s["http.query"] = e.search), e.hash && (s["http.fragment"] = e.hash)), s
}

function Ms(t) {
  if (t !== void 0) return t >= 400 && t < 500 ? "warning" : t >= 500 ? "error" : void 0
}
const ct = x;

function lc() {
  return "history" in ct && !!ct.history
}

function pc() {
  if (!("fetch" in ct)) return !1;
  try {
    return new Headers, new Request("http://www.example.com"), new Response, !0
  } catch {
    return !1
  }
}

function Sn(t) {
  return t && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
}

function mc() {
  var n;
  if (typeof EdgeRuntime == "string") return !0;
  if (!pc()) return !1;
  if (Sn(ct.fetch)) return !0;
  let t = !1;
  const e = ct.document;
  if (e && typeof e.createElement == "function") try {
    const r = e.createElement("iframe");
    r.hidden = !0, e.head.appendChild(r), (n = r.contentWindow) != null && n.fetch && (t = Sn(r.contentWindow.fetch)), e.head.removeChild(r)
  } catch (r) {
    E && g.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", r)
  }
  return t
}

function Ds(t, e) {
  const n = "fetch";
  Re(n, t), we(n, () => xs(void 0, e))
}

function gc(t) {
  const e = "fetch-body-resolved";
  Re(e, t), we(e, () => xs(hc))
}

function xs(t, e = !1) {
  e && !mc() || Y(x, "fetch", function(n) {
    return function(...r) {
      const s = new Error,
        {
          method: a,
          url: o
        } = Ec(r),
        c = {
          args: r,
          fetchData: {
            method: a,
            url: o
          },
          startTimestamp: q() * 1e3,
          virtualError: s,
          headers: Sc(r)
        };
      return t || re("fetch", {
        ...c
      }), n.apply(x, r).then(async i => (t ? t(i) : re("fetch", {
        ...c,
        endTimestamp: q() * 1e3,
        response: i
      }), i), i => {
        if (re("fetch", {
            ...c,
            endTimestamp: q() * 1e3,
            error: i
          }), rs(i) && i.stack === void 0 && (i.stack = s.stack, ot(i, "framesToPop", 1)), i instanceof TypeError && (i.message === "Failed to fetch" || i.message === "Load failed" || i.message === "NetworkError when attempting to fetch resource.")) try {
          const u = new URL(c.fetchData.url);
          i.message = `${i.message} (${u.host})`
        } catch {}
        throw i
      })
    }
  })
}
async function _c(t, e) {
  if (t != null && t.body) {
    const n = t.body,
      r = n.getReader(),
      s = setTimeout(() => {
        n.cancel().then(null, () => {})
      }, 90 * 1e3);
    let a = !0;
    for (; a;) {
      let o;
      try {
        o = setTimeout(() => {
          n.cancel().then(null, () => {})
        }, 5e3);
        const {
          done: c
        } = await r.read();
        clearTimeout(o), c && (e(), a = !1)
      } catch {
        a = !1
      } finally {
        clearTimeout(o)
      }
    }
    clearTimeout(s), r.releaseLock(), n.cancel().then(null, () => {})
  }
}

function hc(t) {
  let e;
  try {
    e = t.clone()
  } catch {
    return
  }
  _c(e, () => {
    re("fetch-body-resolved", {
      endTimestamp: q() * 1e3,
      response: t
    })
  })
}

function yn(t, e) {
  return !!t && typeof t == "object" && !!t[e]
}

function Mr(t) {
  return typeof t == "string" ? t : t ? yn(t, "url") ? t.url : t.toString ? t.toString() : "" : ""
}

function Ec(t) {
  if (t.length === 0) return {
    method: "GET",
    url: ""
  };
  if (t.length === 2) {
    const [n, r] = t;
    return {
      url: Mr(n),
      method: yn(r, "method") ? String(r.method).toUpperCase() : "GET"
    }
  }
  const e = t[0];
  return {
    url: Mr(e),
    method: yn(e, "method") ? String(e.method).toUpperCase() : "GET"
  }
}

function Sc(t) {
  const [e, n] = t;
  try {
    if (typeof n == "object" && n !== null && "headers" in n && n.headers) return new Headers(n.headers);
    if (ns(e)) return new Headers(e.headers)
  } catch {}
}

function yc() {
  return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__
}

function bc() {
  return "npm"
}

function Tc() {
  return !yc() && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]"
}

function vc() {
  return typeof window < "u" && (!Tc() || Ic())
}

function Ic() {
  const t = x.process;
  return (t == null ? void 0 : t.type) === "renderer"
}
const b = x;
let bn = 0;

function Fs() {
  return bn > 0
}

function Rc() {
  bn++, setTimeout(() => {
    bn--
  })
}

function We(t, e = {}) {
  function n(s) {
    return typeof s == "function"
  }
  if (!n(t)) return t;
  try {
    const s = t.__sentry_wrapped__;
    if (s) return typeof s == "function" ? s : t;
    if (Mn(t)) return t
  } catch {
    return t
  }
  const r = function(...s) {
    try {
      const a = s.map(o => We(o, e));
      return t.apply(this, a)
    } catch (a) {
      throw Rc(), jt(o => {
        o.addEventProcessor(c => (e.mechanism && (gn(c, void 0), it(c, e.mechanism)), c.extra = {
          ...c.extra,
          arguments: s
        }, c)), ss(a)
      }), a
    }
  };
  try {
    for (const s in t) Object.prototype.hasOwnProperty.call(t, s) && (r[s] = t[s])
  } catch {}
  Ha(r, t), ot(t, "__sentry_wrapped__", r);
  try {
    Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
      get() {
        return t.name
      }
    })
  } catch {}
  return r
}

function Bn() {
  const t = lt(),
    {
      referrer: e
    } = b.document || {},
    {
      userAgent: n
    } = b.navigator || {},
    r = {
      ...e && {
        Referer: e
      },
      ...n && {
        "User-Agent": n
      }
    };
  return {
    url: t,
    headers: r
  }
}

function $n(t, e) {
  const n = Un(t, e),
    r = {
      type: Nc(e),
      value: Lc(e)
    };
  return n.length && (r.stacktrace = {
    frames: n
  }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r
}

function wc(t, e, n, r) {
  const s = k(),
    a = s == null ? void 0 : s.getOptions().normalizeDepth,
    o = xc(e),
    c = {
      __serialized__: $a(e, a)
    };
  if (o) return {
    exception: {
      values: [$n(t, o)]
    },
    extra: c
  };
  const i = {
    exception: {
      values: [{
        type: Dn(e) ? e.constructor.name : r ? "UnhandledRejection" : "Error",
        value: Mc(e, {
          isUnhandledRejection: r
        })
      }]
    },
    extra: c
  };
  if (n) {
    const u = Un(t, n);
    u.length && (i.exception.values[0].stacktrace = {
      frames: u
    })
  }
  return i
}

function an(t, e) {
  return {
    exception: {
      values: [$n(t, e)]
    }
  }
}

function Un(t, e) {
  const n = e.stacktrace || e.stack || "",
    r = Pc(e),
    s = kc(e);
  try {
    return t(n, r, s)
  } catch {}
  return []
}
const Ac = /Minified React error #\d+;/i;

function Pc(t) {
  return t && Ac.test(t.message) ? 1 : 0
}

function kc(t) {
  return typeof t.framesToPop == "number" ? t.framesToPop : 0
}

function Hs(t) {
  return typeof WebAssembly < "u" && typeof WebAssembly.Exception < "u" ? t instanceof WebAssembly.Exception : !1
}

function Nc(t) {
  const e = t == null ? void 0 : t.name;
  return !e && Hs(t) ? t.message && Array.isArray(t.message) && t.message.length == 2 ? t.message[0] : "WebAssembly.Exception" : e
}

function Lc(t) {
  const e = t == null ? void 0 : t.message;
  return Hs(t) ? Array.isArray(t.message) && t.message.length == 2 ? t.message[1] : "wasm exception" : e ? e.error && typeof e.error.message == "string" ? e.error.message : e : "No error message"
}

function Cc(t, e, n, r) {
  const s = (n == null ? void 0 : n.syntheticException) || void 0,
    a = qn(t, e, s, r);
  return it(a), a.level = "error", n != null && n.event_id && (a.event_id = n.event_id), On(a)
}

function Oc(t, e, n = "info", r, s) {
  const a = (r == null ? void 0 : r.syntheticException) || void 0,
    o = Tn(t, e, a, s);
  return o.level = n, r != null && r.event_id && (o.event_id = r.event_id), On(o)
}

function qn(t, e, n, r, s) {
  let a;
  if (as(e) && e.error) return an(t, e.error);
  if (ar(e) || Ba(e)) {
    const o = e;
    if ("stack" in e) a = an(t, e);
    else {
      const c = o.name || (ar(o) ? "DOMError" : "DOMException"),
        i = o.message ? `${c}: ${o.message}` : c;
      a = Tn(t, i, n, r), gn(a, i)
    }
    return "code" in o && (a.tags = {
      ...a.tags,
      "DOMException.code": `${o.code}`
    }), a
  }
  return rs(e) ? an(t, e) : mn(e) || Dn(e) ? (a = wc(t, e, n, s), it(a, {
    synthetic: !0
  }), a) : (a = Tn(t, e, n, r), gn(a, `${e}`), it(a, {
    synthetic: !0
  }), a)
}

function Tn(t, e, n, r) {
  const s = {};
  if (r && n) {
    const a = Un(t, n);
    a.length && (s.exception = {
      values: [{
        value: e,
        stacktrace: {
          frames: a
        }
      }]
    }), it(s, {
      synthetic: !0
    })
  }
  if (es(e)) {
    const {
      __sentry_template_string__: a,
      __sentry_template_values__: o
    } = e;
    return s.logentry = {
      message: a,
      params: o
    }, s
  }
  return s.message = e, s
}

function Mc(t, {
  isUnhandledRejection: e
}) {
  const n = Ua(t),
    r = e ? "promise rejection" : "exception";
  return as(t) ? `Event \`ErrorEvent\` captured as ${r} with message \`${t.message}\`` : Dn(t) ? `Event \`${Dc(t)}\` (type=${t.type}) captured as ${r}` : `Object captured as ${r} with keys: ${n}`
}

function Dc(t) {
  try {
    const e = Object.getPrototypeOf(t);
    return e ? e.constructor.name : void 0
  } catch {}
}

function xc(t) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e)) {
      const n = t[e];
      if (n instanceof Error) return n
    }
}
class Fc extends mi {
  constructor(e) {
    var f;
    const n = Hc(e),
      r = b.SENTRY_SDK_SOURCE || bc();
    Hn(n, "browser", ["browser"], r), (f = n._metadata) != null && f.sdk && (n._metadata.sdk.settings = {
      infer_ip: n.sendDefaultPii ? "auto" : "never",
      ...n._metadata.sdk.settings
    }), super(n);
    const {
      sendDefaultPii: s,
      sendClientReports: a,
      enableLogs: o,
      _experiments: c,
      enableMetrics: i
    } = this._options, u = i ?? (c == null ? void 0 : c.enableMetrics) ?? !0;
    b.document && (a || o || u) && b.document.addEventListener("visibilitychange", () => {
      b.document.visibilityState === "hidden" && (a && this._flushOutcomes(), o && Es(this), u && ys(this))
    }), s && this.on("beforeSendSession", Li)
  }
  eventFromException(e, n) {
    return Cc(this._options.stackParser, e, n, this._options.attachStacktrace)
  }
  eventFromMessage(e, n = "info", r) {
    return Oc(this._options.stackParser, e, n, r, this._options.attachStacktrace)
  }
  _prepareEvent(e, n, r, s) {
    return e.platform = e.platform || "javascript", super._prepareEvent(e, n, r, s)
  }
}

function Hc(t) {
  var e;
  return {
    release: typeof __SENTRY_RELEASE__ == "string" ? __SENTRY_RELEASE__ : (e = b.SENTRY_RELEASE) == null ? void 0 : e.id,
    sendClientReports: !0,
    parentSpanIsAlwaysRootSpan: !0,
    ...t
  }
}
const pt = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  S = x,
  Bc = (t, e) => t > e[1] ? "poor" : t > e[0] ? "needs-improvement" : "good",
  mt = (t, e, n, r) => {
    let s, a;
    return o => {
      e.value >= 0 && (o || r) && (a = e.value - (s ?? 0), (a || s === void 0) && (s = e.value, e.delta = a, e.rating = Bc(e.value, n), t(e)))
    }
  },
  $c = () => `v5-${Date.now()}-${Math.floor(Math.random()*(9e12-1))+1e12}`,
  gt = (t = !0) => {
    var n, r;
    const e = (r = (n = S.performance) == null ? void 0 : n.getEntriesByType) == null ? void 0 : r.call(n, "navigation")[0];
    if (!t || e && e.responseStart > 0 && e.responseStart < performance.now()) return e
  },
  Xe = () => {
    const t = gt();
    return (t == null ? void 0 : t.activationStart) ?? 0
  },
  _t = (t, e = -1) => {
    var a, o;
    const n = gt();
    let r = "navigate";
    return n && ((a = S.document) != null && a.prerendering || Xe() > 0 ? r = "prerender" : (o = S.document) != null && o.wasDiscarded ? r = "restore" : n.type && (r = n.type.replace(/_/g, "-"))), {
      name: t,
      value: e,
      rating: "good",
      delta: 0,
      entries: [],
      id: $c(),
      navigationType: r
    }
  },
  on = new WeakMap;

function jn(t, e) {
  return on.get(t) || on.set(t, new e), on.get(t)
}
class Ht {
  constructor() {
    Ht.prototype.__init.call(this), Ht.prototype.__init2.call(this)
  }
  __init() {
    this._sessionValue = 0
  }
  __init2() {
    this._sessionEntries = []
  }
  _processEntry(e) {
    var s;
    if (e.hadRecentInput) return;
    const n = this._sessionEntries[0],
      r = this._sessionEntries[this._sessionEntries.length - 1];
    this._sessionValue && n && r && e.startTime - r.startTime < 1e3 && e.startTime - n.startTime < 5e3 ? (this._sessionValue += e.value, this._sessionEntries.push(e)) : (this._sessionValue = e.value, this._sessionEntries = [e]), (s = this._onAfterProcessingUnexpectedShift) == null || s.call(this, e)
  }
}
const Je = (t, e, n = {}) => {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(t)) {
        const r = new PerformanceObserver(s => {
          Promise.resolve().then(() => {
            e(s.getEntries())
          })
        });
        return r.observe({
          type: t,
          buffered: !0,
          ...n
        }), r
      }
    } catch {}
  },
  Vn = t => {
    let e = !1;
    return () => {
      e || (t(), e = !0)
    }
  };
let rt = -1;
const Uc = () => {
    var t, e;
    return ((t = S.document) == null ? void 0 : t.visibilityState) === "hidden" && !((e = S.document) != null && e.prerendering) ? 0 : 1 / 0
  },
  Bt = t => {
    S.document.visibilityState === "hidden" && rt > -1 && (rt = t.type === "visibilitychange" ? t.timeStamp : 0, jc())
  },
  qc = () => {
    addEventListener("visibilitychange", Bt, !0), addEventListener("prerenderingchange", Bt, !0)
  },
  jc = () => {
    removeEventListener("visibilitychange", Bt, !0), removeEventListener("prerenderingchange", Bt, !0)
  },
  Wn = () => {
    var t;
    if (S.document && rt < 0) {
      const e = Xe();
      rt = (S.document.prerendering || (t = globalThis.performance.getEntriesByType("visibility-state").filter(r => r.name === "hidden" && r.startTime > e)[0]) == null ? void 0 : t.startTime) ?? Uc(), qc()
    }
    return {
      get firstHiddenTime() {
        return rt
      }
    }
  },
  Xt = t => {
    var e;
    (e = S.document) != null && e.prerendering ? addEventListener("prerenderingchange", () => t(), !0) : t()
  },
  Vc = [1800, 3e3],
  Wc = (t, e = {}) => {
    Xt(() => {
      const n = Wn(),
        r = _t("FCP");
      let s;
      const o = Je("paint", c => {
        for (const i of c) i.name === "first-contentful-paint" && (o.disconnect(), i.startTime < n.firstHiddenTime && (r.value = Math.max(i.startTime - Xe(), 0), r.entries.push(i), s(!0)))
      });
      o && (s = mt(t, r, Vc, e.reportAllChanges))
    })
  },
  Gc = [.1, .25],
  zc = (t, e = {}) => {
    Wc(Vn(() => {
      var c, i;
      const n = _t("CLS", 0);
      let r;
      const s = jn(e, Ht),
        a = u => {
          for (const f of u) s._processEntry(f);
          s._sessionValue > n.value && (n.value = s._sessionValue, n.entries = s._sessionEntries, r())
        },
        o = Je("layout-shift", a);
      o && (r = mt(t, n, Gc, e.reportAllChanges), (c = S.document) == null || c.addEventListener("visibilitychange", () => {
        var u;
        ((u = S.document) == null ? void 0 : u.visibilityState) === "hidden" && (a(o.takeRecords()), r(!0))
      }), (i = S == null ? void 0 : S.setTimeout) == null || i.call(S, r))
    }))
  };
let Bs = 0,
  cn = 1 / 0,
  bt = 0;
const Yc = t => {
  t.forEach(e => {
    e.interactionId && (cn = Math.min(cn, e.interactionId), bt = Math.max(bt, e.interactionId), Bs = bt ? (bt - cn) / 7 + 1 : 0)
  })
};
let vn;
const $s = () => vn ? Bs : performance.interactionCount || 0,
  Xc = () => {
    "interactionCount" in performance || vn || (vn = Je("event", Yc, {
      type: "event",
      buffered: !0,
      durationThreshold: 0
    }))
  },
  un = 10;
let Us = 0;
const Jc = () => $s() - Us;
class $t {
  constructor() {
    $t.prototype.__init.call(this), $t.prototype.__init2.call(this)
  }
  __init() {
    this._longestInteractionList = []
  }
  __init2() {
    this._longestInteractionMap = new Map
  }
  _resetInteractions() {
    Us = $s(), this._longestInteractionList.length = 0, this._longestInteractionMap.clear()
  }
  _estimateP98LongestInteraction() {
    const e = Math.min(this._longestInteractionList.length - 1, Math.floor(Jc() / 50));
    return this._longestInteractionList[e]
  }
  _processEntry(e) {
    var s, a;
    if ((s = this._onBeforeProcessingEntry) == null || s.call(this, e), !(e.interactionId || e.entryType === "first-input")) return;
    const n = this._longestInteractionList.at(-1);
    let r = this._longestInteractionMap.get(e.interactionId);
    if (r || this._longestInteractionList.length < un || e.duration > n._latency) {
      if (r ? e.duration > r._latency ? (r.entries = [e], r._latency = e.duration) : e.duration === r._latency && e.startTime === r.entries[0].startTime && r.entries.push(e) : (r = {
          id: e.interactionId,
          entries: [e],
          _latency: e.duration
        }, this._longestInteractionMap.set(r.id, r), this._longestInteractionList.push(r)), this._longestInteractionList.sort((o, c) => c._latency - o._latency), this._longestInteractionList.length > un) {
        const o = this._longestInteractionList.splice(un);
        for (const c of o) this._longestInteractionMap.delete(c.id)
      }(a = this._onAfterProcessingINPCandidate) == null || a.call(this, r)
    }
  }
}
const Gn = t => {
    const e = n => {
      var r;
      (n.type === "pagehide" || ((r = S.document) == null ? void 0 : r.visibilityState) === "hidden") && t(n)
    };
    S.document && (addEventListener("visibilitychange", e, !0), addEventListener("pagehide", e, !0))
  },
  qs = t => {
    var n;
    const e = S.requestIdleCallback || S.setTimeout;
    ((n = S.document) == null ? void 0 : n.visibilityState) === "hidden" ? t(): (t = Vn(t), e(t), Gn(t))
  },
  Kc = [200, 500],
  Zc = 40,
  Qc = (t, e = {}) => {
    globalThis.PerformanceEventTiming && "interactionId" in PerformanceEventTiming.prototype && Xt(() => {
      Xc();
      const n = _t("INP");
      let r;
      const s = jn(e, $t),
        a = c => {
          qs(() => {
            for (const u of c) s._processEntry(u);
            const i = s._estimateP98LongestInteraction();
            i && i._latency !== n.value && (n.value = i._latency, n.entries = i.entries, r())
          })
        },
        o = Je("event", a, {
          durationThreshold: e.durationThreshold ?? Zc
        });
      r = mt(t, n, Kc, e.reportAllChanges), o && (o.observe({
        type: "first-input",
        buffered: !0
      }), Gn(() => {
        a(o.takeRecords()), r(!0)
      }))
    })
  };
class eu {
  _processEntry(e) {
    var n;
    (n = this._onBeforeProcessingEntry) == null || n.call(this, e)
  }
}
const tu = [2500, 4e3],
  nu = (t, e = {}) => {
    Xt(() => {
      const n = Wn(),
        r = _t("LCP");
      let s;
      const a = jn(e, eu),
        o = i => {
          e.reportAllChanges || (i = i.slice(-1));
          for (const u of i) a._processEntry(u), u.startTime < n.firstHiddenTime && (r.value = Math.max(u.startTime - Xe(), 0), r.entries = [u], s())
        },
        c = Je("largest-contentful-paint", o);
      if (c) {
        s = mt(t, r, tu, e.reportAllChanges);
        const i = Vn(() => {
          o(c.takeRecords()), c.disconnect(), s(!0)
        });
        for (const u of ["keydown", "click", "visibilitychange"]) S.document && addEventListener(u, () => qs(i), {
          capture: !0,
          once: !0
        })
      }
    })
  },
  ru = [800, 1800],
  In = t => {
    var e, n;
    (e = S.document) != null && e.prerendering ? Xt(() => In(t)) : ((n = S.document) == null ? void 0 : n.readyState) !== "complete" ? addEventListener("load", () => In(t), !0) : setTimeout(t)
  },
  su = (t, e = {}) => {
    const n = _t("TTFB"),
      r = mt(t, n, ru, e.reportAllChanges);
    In(() => {
      const s = gt();
      s && (n.value = Math.max(s.responseStart - Xe(), 0), n.entries = [s], r(!0))
    })
  },
  st = {},
  Ut = {};
let js, Vs, Ws, Gs;

function zs(t, e = !1) {
  return Jt("cls", t, iu, js, e)
}

function Ys(t, e = !1) {
  return Jt("lcp", t, cu, Vs, e)
}

function au(t) {
  return Jt("ttfb", t, uu, Ws)
}

function ou(t) {
  return Jt("inp", t, du, Gs)
}

function Ge(t, e) {
  return Xs(t, e), Ut[t] || (fu(t), Ut[t] = !0), Js(t, e)
}

function ht(t, e) {
  const n = st[t];
  if (n != null && n.length)
    for (const r of n) try {
      r(e)
    } catch (s) {
      pt && g.error(`Error while triggering instrumentation handler.
Type: ${t}
Name: ${be(r)}
Error:`, s)
    }
}

function iu() {
  return zc(t => {
    ht("cls", {
      metric: t
    }), js = t
  }, {
    reportAllChanges: !0
  })
}

function cu() {
  return nu(t => {
    ht("lcp", {
      metric: t
    }), Vs = t
  }, {
    reportAllChanges: !0
  })
}

function uu() {
  return su(t => {
    ht("ttfb", {
      metric: t
    }), Ws = t
  })
}

function du() {
  return Qc(t => {
    ht("inp", {
      metric: t
    }), Gs = t
  })
}

function Jt(t, e, n, r, s = !1) {
  Xs(t, e);
  let a;
  return Ut[t] || (a = n(), Ut[t] = !0), r && e({
    metric: r
  }), Js(t, e, s ? a : void 0)
}

function fu(t) {
  const e = {};
  t === "event" && (e.durationThreshold = 0), Je(t, n => {
    ht(t, {
      entries: n
    })
  }, e)
}

function Xs(t, e) {
  st[t] = st[t] || [], st[t].push(e)
}

function Js(t, e, n) {
  return () => {
    n && n();
    const r = st[t];
    if (!r) return;
    const s = r.indexOf(e);
    s !== -1 && r.splice(s, 1)
  }
}

function lu(t) {
  return "duration" in t
}

function dn(t) {
  return typeof t == "number" && isFinite(t)
}

function Ie(t, e, n, {
  ...r
}) {
  const s = A(t).start_timestamp;
  return s && s > e && typeof t.updateStartTime == "function" && t.updateStartTime(e), xn(t, () => {
    const a = De({
      startTime: e,
      ...r
    });
    return a && a.end(n), a
  })
}

function zn(t) {
  var h;
  const e = k();
  if (!e) return;
  const {
    name: n,
    transaction: r,
    attributes: s,
    startTime: a
  } = t, {
    release: o,
    environment: c,
    sendDefaultPii: i
  } = e.getOptions(), u = e.getIntegrationByName("Replay"), f = u == null ? void 0 : u.getReplayId(), d = L(), l = d.getUser(), p = l !== void 0 ? l.email || l.id || l.ip_address : void 0;
  let m;
  try {
    m = d.getScopeData().contexts.profile.profile_id
  } catch {}
  const _ = {
    release: o,
    environment: c,
    user: p || void 0,
    profile_id: m || void 0,
    replay_id: f || void 0,
    transaction: r,
    "user_agent.original": (h = S.navigator) == null ? void 0 : h.userAgent,
    "client.address": i ? "{{auto}}" : void 0,
    ...s
  };
  return De({
    name: n,
    attributes: _,
    startTime: a,
    experimental: {
      standalone: !0
    }
  })
}

function Et() {
  return S.addEventListener && S.performance
}

function C(t) {
  return t / 1e3
}

function pu(t) {
  let e = "unknown",
    n = "unknown",
    r = "";
  for (const s of t) {
    if (s === "/") {
      [e, n] = t.split("/");
      break
    }
    if (!isNaN(Number(s))) {
      e = r === "h" ? "http" : r, n = t.split(r)[1];
      break
    }
    r += s
  }
  return r === t && (e = r), {
    name: e,
    version: n
  }
}

function Ks(t) {
  try {
    return PerformanceObserver.supportedEntryTypes.includes(t)
  } catch {
    return !1
  }
}

function Zs(t, e) {
  let n, r = !1;

  function s(c) {
    !r && n && e(c, n), r = !0
  }
  Gn(() => {
    s("pagehide")
  });
  const a = t.on("beforeStartNavigationSpan", (c, i) => {
      i != null && i.isRedirect || (s("navigation"), a(), o())
    }),
    o = t.on("afterStartPageLoadSpan", c => {
      n = c.spanContext().spanId, o()
    })
}

function mu(t) {
  let e = 0,
    n;
  if (!Ks("layout-shift")) return;
  const r = zs(({
    metric: s
  }) => {
    const a = s.entries[s.entries.length - 1];
    a && (e = s.value, n = a)
  }, !0);
  Zs(t, (s, a) => {
    gu(e, n, a, s), r()
  })
}

function gu(t, e, n, r) {
  var u;
  pt && g.log(`Sending CLS span (${t})`);
  const s = e ? C((K() || 0) + e.startTime) : q(),
    a = L().getScopeData().transactionName,
    o = e ? fe((u = e.sources[0]) == null ? void 0 : u.node) : "Layout shift",
    c = {
      [O]: "auto.http.browser.cls",
      [Te]: "ui.webvital.cls",
      [Ye]: 0,
      "sentry.pageload.span_id": n,
      "sentry.report_event": r
    };
  e != null && e.sources && e.sources.forEach((f, d) => {
    c[`cls.source.${d+1}`] = fe(f.node)
  });
  const i = zn({
    name: o,
    transaction: a,
    attributes: c,
    startTime: s
  });
  i && (i.addEvent("cls", {
    [dt]: "",
    [ft]: t
  }), i.end(s))
}

function _u(t) {
  let e = 0,
    n;
  if (!Ks("largest-contentful-paint")) return;
  const r = Ys(({
    metric: s
  }) => {
    const a = s.entries[s.entries.length - 1];
    a && (e = s.value, n = a)
  }, !0);
  Zs(t, (s, a) => {
    hu(e, n, a, s), r()
  })
}

function hu(t, e, n, r) {
  pt && g.log(`Sending LCP span (${t})`);
  const s = C((K() || 0) + ((e == null ? void 0 : e.startTime) || 0)),
    a = L().getScopeData().transactionName,
    o = e ? fe(e.element) : "Largest contentful paint",
    c = {
      [O]: "auto.http.browser.lcp",
      [Te]: "ui.webvital.lcp",
      [Ye]: 0,
      "sentry.pageload.span_id": n,
      "sentry.report_event": r
    };
  e && (e.element && (c["lcp.element"] = fe(e.element)), e.id && (c["lcp.id"] = e.id), e.url && (c["lcp.url"] = e.url), e.loadTime != null && (c["lcp.loadTime"] = e.loadTime), e.renderTime != null && (c["lcp.renderTime"] = e.renderTime), e.size != null && (c["lcp.size"] = e.size));
  const i = zn({
    name: o,
    transaction: a,
    attributes: c,
    startTime: s
  });
  i && (i.addEvent("lcp", {
    [dt]: "millisecond",
    [ft]: t
  }), i.end(s))
}

function ee(t) {
  return t && ((K() || performance.timeOrigin) + t) / 1e3
}

function Qs(t) {
  var n;
  const e = {};
  if (t.nextHopProtocol != null) {
    const {
      name: r,
      version: s
    } = pu(t.nextHopProtocol);
    e["network.protocol.version"] = s, e["network.protocol.name"] = r
  }
  return K() || (n = Et()) != null && n.timeOrigin ? Eu({
    ...e,
    "http.request.redirect_start": ee(t.redirectStart),
    "http.request.redirect_end": ee(t.redirectEnd),
    "http.request.worker_start": ee(t.workerStart),
    "http.request.fetch_start": ee(t.fetchStart),
    "http.request.domain_lookup_start": ee(t.domainLookupStart),
    "http.request.domain_lookup_end": ee(t.domainLookupEnd),
    "http.request.connect_start": ee(t.connectStart),
    "http.request.secure_connection_start": ee(t.secureConnectionStart),
    "http.request.connection_end": ee(t.connectEnd),
    "http.request.request_start": ee(t.requestStart),
    "http.request.response_start": ee(t.responseStart),
    "http.request.response_end": ee(t.responseEnd),
    "http.request.time_to_first_byte": t.responseStart != null ? t.responseStart / 1e3 : void 0
  }) : e
}

function Eu(t) {
  return Object.fromEntries(Object.entries(t).filter(([, e]) => e != null))
}
const Su = 2147483647;
let Dr = 0,
  de = {},
  V, $e;

function yu({
  recordClsStandaloneSpans: t,
  recordLcpStandaloneSpans: e,
  client: n
}) {
  const r = Et();
  if (r && K()) {
    r.mark && S.performance.mark("sentry-tracing-init");
    const s = e ? _u(n) : Ru(),
      a = wu(),
      o = t ? mu(n) : Iu();
    return () => {
      s == null || s(), a(), o == null || o()
    }
  }
  return () => {}
}

function bu() {
  Ge("longtask", ({
    entries: t
  }) => {
    const e = J();
    if (!e) return;
    const {
      op: n,
      start_timestamp: r
    } = A(e);
    for (const s of t) {
      const a = C(K() + s.startTime),
        o = C(s.duration);
      n === "navigation" && r && a < r || Ie(e, a, a + o, {
        name: "Main UI thread blocked",
        op: "ui.long-task",
        attributes: {
          [O]: "auto.ui.browser.metrics"
        }
      })
    }
  })
}

function Tu() {
  new PerformanceObserver(e => {
    const n = J();
    if (n)
      for (const r of e.getEntries()) {
        if (!r.scripts[0]) continue;
        const s = C(K() + r.startTime),
          {
            start_timestamp: a,
            op: o
          } = A(n);
        if (o === "navigation" && a && s < a) continue;
        const c = C(r.duration),
          i = {
            [O]: "auto.ui.browser.metrics"
          },
          u = r.scripts[0],
          {
            invoker: f,
            invokerType: d,
            sourceURL: l,
            sourceFunctionName: p,
            sourceCharPosition: m
          } = u;
        i["browser.script.invoker"] = f, i["browser.script.invoker_type"] = d, l && (i["code.filepath"] = l), p && (i["code.function"] = p), m !== -1 && (i["browser.script.source_char_position"] = m), Ie(n, s, s + c, {
          name: "Main UI thread blocked",
          op: "ui.long-animation-frame",
          attributes: i
        })
      }
  }).observe({
    type: "long-animation-frame",
    buffered: !0
  })
}

function vu() {
  Ge("event", ({
    entries: t
  }) => {
    const e = J();
    if (e) {
      for (const n of t)
        if (n.name === "click") {
          const r = C(K() + n.startTime),
            s = C(n.duration),
            a = {
              name: fe(n.target),
              op: `ui.interaction.${n.name}`,
              startTime: r,
              attributes: {
                [O]: "auto.ui.browser.metrics"
              }
            },
            o = os(n.target);
          o && (a.attributes["ui.component_name"] = o), Ie(e, r, r + s, a)
        }
    }
  })
}

function Iu() {
  return zs(({
    metric: t
  }) => {
    const e = t.entries[t.entries.length - 1];
    e && (de.cls = {
      value: t.value,
      unit: ""
    }, $e = e)
  }, !0)
}

function Ru() {
  return Ys(({
    metric: t
  }) => {
    const e = t.entries[t.entries.length - 1];
    e && (de.lcp = {
      value: t.value,
      unit: "millisecond"
    }, V = e)
  }, !0)
}

function wu() {
  return au(({
    metric: t
  }) => {
    t.entries[t.entries.length - 1] && (de.ttfb = {
      value: t.value,
      unit: "millisecond"
    })
  })
}

function Au(t, e) {
  const n = Et(),
    r = K();
  if (!(n != null && n.getEntries) || !r) return;
  const s = C(r),
    a = n.getEntries(),
    {
      op: o,
      start_timestamp: c
    } = A(t);
  a.slice(Dr).forEach(i => {
    const u = C(i.startTime),
      f = C(Math.max(0, i.duration));
    if (!(o === "navigation" && c && s + u < c)) switch (i.entryType) {
      case "navigation": {
        Lu(t, i, s);
        break
      }
      case "mark":
      case "paint":
      case "measure": {
        ku(t, i, u, f, s, e.ignorePerformanceApiSpans);
        const d = Wn(),
          l = i.startTime < d.firstHiddenTime;
        i.name === "first-paint" && l && (de.fp = {
          value: i.startTime,
          unit: "millisecond"
        }), i.name === "first-contentful-paint" && l && (de.fcp = {
          value: i.startTime,
          unit: "millisecond"
        });
        break
      }
      case "resource": {
        Mu(t, i, i.name, u, f, s, e.ignoreResourceSpans);
        break
      }
    }
  }), Dr = Math.max(a.length - 1, 0), Du(t), o === "pageload" && (Hu(de), e.recordClsOnPageloadSpan || delete de.cls, e.recordLcpOnPageloadSpan || delete de.lcp, Object.entries(de).forEach(([i, u]) => {
    xo(i, u.value, u.unit)
  }), t.setAttribute("performance.timeOrigin", s), t.setAttribute("performance.activationStart", Xe()), xu(t, e)), V = void 0, $e = void 0, de = {}
}

function Pu(t) {
  if ((t == null ? void 0 : t.entryType) === "measure") try {
    return t.detail.devtools.track === "Components "
  } catch {
    return
  }
}

function ku(t, e, n, r, s, a) {
  if (Pu(e) || ["mark", "measure"].includes(e.entryType) && ye(e.name, a)) return;
  const o = gt(!1),
    c = C(o ? o.requestStart : 0),
    i = s + Math.max(n, c),
    u = s + n,
    f = u + r,
    d = {
      [O]: "auto.resource.browser.metrics"
    };
  i !== u && (d["sentry.browser.measure_happened_before_request"] = !0, d["sentry.browser.measure_start_time"] = i), Nu(d, e), i <= f && Ie(t, i, f, {
    name: e.name,
    op: e.entryType,
    attributes: d
  })
}

function Nu(t, e) {
  try {
    const n = e.detail;
    if (!n) return;
    if (typeof n == "object") {
      for (const [r, s] of Object.entries(n))
        if (s && je(s)) t[`sentry.browser.measure.detail.${r}`] = s;
        else if (s !== void 0) try {
        t[`sentry.browser.measure.detail.${r}`] = JSON.stringify(s)
      } catch {}
      return
    }
    if (je(n)) {
      t["sentry.browser.measure.detail"] = n;
      return
    }
    try {
      t["sentry.browser.measure.detail"] = JSON.stringify(n)
    } catch {}
  } catch {}
}

function Lu(t, e, n) {
  ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(r => {
    Tt(t, e, r, n)
  }), Tt(t, e, "secureConnection", n, "TLS/SSL"), Tt(t, e, "fetch", n, "cache"), Tt(t, e, "domainLookup", n, "DNS"), Ou(t, e, n)
}

function Tt(t, e, n, r, s = n) {
  const a = Cu(n),
    o = e[a],
    c = e[`${n}Start`];
  !c || !o || Ie(t, r + C(c), r + C(o), {
    op: `browser.${s}`,
    name: e.name,
    attributes: {
      [O]: "auto.ui.browser.metrics",
      ...n === "redirect" && e.redirectCount != null ? {
        "http.redirect_count": e.redirectCount
      } : {}
    }
  })
}

function Cu(t) {
  return t === "secureConnection" ? "connectEnd" : t === "fetch" ? "domainLookupStart" : `${t}End`
}

function Ou(t, e, n) {
  const r = n + C(e.requestStart),
    s = n + C(e.responseEnd),
    a = n + C(e.responseStart);
  e.responseEnd && (Ie(t, r, s, {
    op: "browser.request",
    name: e.name,
    attributes: {
      [O]: "auto.ui.browser.metrics"
    }
  }), Ie(t, a, s, {
    op: "browser.response",
    name: e.name,
    attributes: {
      [O]: "auto.ui.browser.metrics"
    }
  }))
}

function Mu(t, e, n, r, s, a, o) {
  if (e.initiatorType === "xmlhttprequest" || e.initiatorType === "fetch") return;
  const c = e.initiatorType ? `resource.${e.initiatorType}` : "resource.other";
  if (o != null && o.includes(c)) return;
  const i = {
      [O]: "auto.resource.browser.metrics"
    },
    u = Le(n);
  u.protocol && (i["url.scheme"] = u.protocol.split(":").pop()), u.host && (i["server.address"] = u.host), i["url.same_origin"] = n.includes(S.location.origin), Fu(e, i, [
    ["responseStatus", "http.response.status_code"],
    ["transferSize", "http.response_transfer_size"],
    ["encodedBodySize", "http.response_content_length"],
    ["decodedBodySize", "http.decoded_response_content_length"],
    ["renderBlockingStatus", "resource.render_blocking_status"],
    ["deliveryType", "http.response_delivery_type"]
  ]);
  const f = {
      ...i,
      ...Qs(e)
    },
    d = a + r,
    l = d + s;
  Ie(t, d, l, {
    name: n.replace(S.location.origin, ""),
    op: c,
    attributes: f
  })
}

function Du(t) {
  const e = S.navigator;
  if (!e) return;
  const n = e.connection;
  n && (n.effectiveType && t.setAttribute("effectiveConnectionType", n.effectiveType), n.type && t.setAttribute("connectionType", n.type), dn(n.rtt) && (de["connection.rtt"] = {
    value: n.rtt,
    unit: "millisecond"
  })), dn(e.deviceMemory) && t.setAttribute("deviceMemory", `${e.deviceMemory} GB`), dn(e.hardwareConcurrency) && t.setAttribute("hardwareConcurrency", String(e.hardwareConcurrency))
}

function xu(t, e) {
  V && e.recordLcpOnPageloadSpan && (V.element && t.setAttribute("lcp.element", fe(V.element)), V.id && t.setAttribute("lcp.id", V.id), V.url && t.setAttribute("lcp.url", V.url.trim().slice(0, 200)), V.loadTime != null && t.setAttribute("lcp.loadTime", V.loadTime), V.renderTime != null && t.setAttribute("lcp.renderTime", V.renderTime), t.setAttribute("lcp.size", V.size)), $e != null && $e.sources && e.recordClsOnPageloadSpan && $e.sources.forEach((n, r) => t.setAttribute(`cls.source.${r+1}`, fe(n.node)))
}

function Fu(t, e, n) {
  n.forEach(([r, s]) => {
    const a = t[r];
    a != null && (typeof a == "number" && a < Su || typeof a == "string") && (e[s] = a)
  })
}

function Hu(t) {
  const e = gt(!1);
  if (!e) return;
  const {
    responseStart: n,
    requestStart: r
  } = e;
  r <= n && (t["ttfb.requestTime"] = {
    value: n - r,
    unit: "millisecond"
  })
}

function Bu() {
  return Et() && K() ? Ge("element", $u) : () => {}
}
const $u = ({
    entries: t
  }) => {
    const e = J(),
      n = e ? X(e) : void 0,
      r = n ? A(n).description : L().getScopeData().transactionName;
    t.forEach(s => {
      var p, m;
      const a = s;
      if (!a.identifier) return;
      const o = a.name,
        c = a.renderTime,
        i = a.loadTime,
        [u, f] = i ? [C(i), "load-time"] : c ? [C(c), "render-time"] : [q(), "entry-emission"],
        d = o === "image-paint" ? C(Math.max(0, (c ?? 0) - (i ?? 0))) : 0,
        l = {
          [O]: "auto.ui.browser.elementtiming",
          [Te]: "ui.elementtiming",
          [ne]: "component",
          "sentry.span_start_time_source": f,
          "sentry.transaction_name": r,
          "element.id": a.id,
          "element.type": ((m = (p = a.element) == null ? void 0 : p.tagName) == null ? void 0 : m.toLowerCase()) || "unknown",
          "element.size": a.naturalWidth && a.naturalHeight ? `${a.naturalWidth}x${a.naturalHeight}` : void 0,
          "element.render_time": c,
          "element.load_time": i,
          "element.url": a.url || void 0,
          "element.identifier": a.identifier,
          "element.paint_type": o
        };
      qo({
        name: `element[${a.identifier}]`,
        attributes: l,
        startTime: u,
        onlyIfParent: !0
      }, _ => {
        _.end(u + d)
      })
    })
  },
  Uu = 1e3;
let xr, Rn, wn;

function qu(t) {
  Re("dom", t), we("dom", ju)
}

function ju() {
  if (!S.document) return;
  const t = re.bind(null, "dom"),
    e = Fr(t, !0);
  S.document.addEventListener("click", e, !1), S.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach(n => {
    var a, o;
    const s = (a = S[n]) == null ? void 0 : a.prototype;
    (o = s == null ? void 0 : s.hasOwnProperty) != null && o.call(s, "addEventListener") && (Y(s, "addEventListener", function(c) {
      return function(i, u, f) {
        if (i === "click" || i == "keypress") try {
          const d = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {},
            l = d[i] = d[i] || {
              refCount: 0
            };
          if (!l.handler) {
            const p = Fr(t);
            l.handler = p, c.call(this, i, p, f)
          }
          l.refCount++
        } catch {}
        return c.call(this, i, u, f)
      }
    }), Y(s, "removeEventListener", function(c) {
      return function(i, u, f) {
        if (i === "click" || i == "keypress") try {
          const d = this.__sentry_instrumentation_handlers__ || {},
            l = d[i];
          l && (l.refCount--, l.refCount <= 0 && (c.call(this, i, l.handler, f), l.handler = void 0, delete d[i]), Object.keys(d).length === 0 && delete this.__sentry_instrumentation_handlers__)
        } catch {}
        return c.call(this, i, u, f)
      }
    }))
  })
}

function Vu(t) {
  if (t.type !== Rn) return !1;
  try {
    if (!t.target || t.target._sentryId !== wn) return !1
  } catch {}
  return !0
}

function Wu(t, e) {
  return t !== "keypress" ? !1 : e != null && e.tagName ? !(e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.isContentEditable) : !0
}

function Fr(t, e = !1) {
  return n => {
    if (!n || n._sentryCaptured) return;
    const r = Gu(n);
    if (Wu(n.type, r)) return;
    ot(n, "_sentryCaptured", !0), r && !r._sentryId && ot(r, "_sentryId", At());
    const s = n.type === "keypress" ? "input" : n.type;
    Vu(n) || (t({
      event: n,
      name: s,
      global: e
    }), Rn = n.type, wn = r ? r._sentryId : void 0), clearTimeout(xr), xr = S.setTimeout(() => {
      wn = void 0, Rn = void 0
    }, Uu)
  }
}

function Gu(t) {
  try {
    return t.target
  } catch {
    return null
  }
}
let vt;

function Yn(t) {
  const e = "history";
  Re(e, t), we(e, zu)
}

function zu() {
  if (S.addEventListener("popstate", () => {
      const e = S.location.href,
        n = vt;
      if (vt = e, n === e) return;
      re("history", {
        from: n,
        to: e
      })
    }), !lc()) return;

  function t(e) {
    return function(...n) {
      const r = n.length > 2 ? n[2] : void 0;
      if (r) {
        const s = vt,
          a = Yu(String(r));
        if (vt = a, s === a) return e.apply(this, n);
        re("history", {
          from: s,
          to: a
        })
      }
      return e.apply(this, n)
    }
  }
  Y(S.history, "pushState", t), Y(S.history, "replaceState", t)
}

function Yu(t) {
  try {
    return new URL(t, S.location.origin).toString()
  } catch {
    return t
  }
}
const Ct = {};

function Xu(t) {
  const e = Ct[t];
  if (e) return e;
  let n = S[t];
  if (Sn(n)) return Ct[t] = n.bind(S);
  const r = S.document;
  if (r && typeof r.createElement == "function") try {
    const s = r.createElement("iframe");
    s.hidden = !0, r.head.appendChild(s);
    const a = s.contentWindow;
    a != null && a[t] && (n = a[t]), r.head.removeChild(s)
  } catch (s) {
    pt && g.warn(`Could not create sandbox iframe for ${t} check, bailing to window.${t}: `, s)
  }
  return n && (Ct[t] = n.bind(S))
}

function Ju(t) {
  Ct[t] = void 0
}
const Ue = "__sentry_xhr_v3__";

function ea(t) {
  Re("xhr", t), we("xhr", Ku)
}

function Ku() {
  if (!S.XMLHttpRequest) return;
  const t = XMLHttpRequest.prototype;
  t.open = new Proxy(t.open, {
    apply(e, n, r) {
      const s = new Error,
        a = q() * 1e3,
        o = nt(r[0]) ? r[0].toUpperCase() : void 0,
        c = Zu(r[1]);
      if (!o || !c) return e.apply(n, r);
      n[Ue] = {
        method: o,
        url: c,
        request_headers: {}
      }, o === "POST" && c.match(/sentry_key/) && (n.__sentry_own_request__ = !0);
      const i = () => {
        const u = n[Ue];
        if (u && n.readyState === 4) {
          try {
            u.status_code = n.status
          } catch {}
          const f = {
            endTimestamp: q() * 1e3,
            startTimestamp: a,
            xhr: n,
            virtualError: s
          };
          re("xhr", f)
        }
      };
      return "onreadystatechange" in n && typeof n.onreadystatechange == "function" ? n.onreadystatechange = new Proxy(n.onreadystatechange, {
        apply(u, f, d) {
          return i(), u.apply(f, d)
        }
      }) : n.addEventListener("readystatechange", i), n.setRequestHeader = new Proxy(n.setRequestHeader, {
        apply(u, f, d) {
          const [l, p] = d, m = f[Ue];
          return m && nt(l) && nt(p) && (m.request_headers[l.toLowerCase()] = p), u.apply(f, d)
        }
      }), e.apply(n, r)
    }
  }), t.send = new Proxy(t.send, {
    apply(e, n, r) {
      const s = n[Ue];
      if (!s) return e.apply(n, r);
      r[0] !== void 0 && (s.body = r[0]);
      const a = {
        startTimestamp: q() * 1e3,
        xhr: n
      };
      return re("xhr", a), e.apply(n, r)
    }
  })
}

function Zu(t) {
  if (nt(t)) return t;
  try {
    return t.toString()
  } catch {}
}

function Qu(t) {
  let e;
  try {
    e = t.getAllResponseHeaders()
  } catch (n) {
    return pt && g.error(n, "Failed to get xhr response headers", t), {}
  }
  return e ? e.split(`\r
`).reduce((n, r) => {
    const [s, a] = r.split(": ");
    return a && (n[s.toLowerCase()] = a), n
  }, {}) : {}
}
const fn = [],
  Ot = new Map,
  Be = new Map,
  ed = 60;

function td() {
  if (Et() && K()) {
    const e = nd();
    return () => {
      e()
    }
  }
  return () => {}
}
const An = {
  click: "click",
  pointerdown: "click",
  pointerup: "click",
  mousedown: "click",
  mouseup: "click",
  touchstart: "click",
  touchend: "click",
  mouseover: "hover",
  mouseout: "hover",
  mouseenter: "hover",
  mouseleave: "hover",
  pointerover: "hover",
  pointerout: "hover",
  pointerenter: "hover",
  pointerleave: "hover",
  dragstart: "drag",
  dragend: "drag",
  drag: "drag",
  dragenter: "drag",
  dragleave: "drag",
  dragover: "drag",
  drop: "drag",
  keydown: "press",
  keyup: "press",
  keypress: "press",
  input: "press"
};

function nd() {
  return ou(rd)
}
const rd = ({
  metric: t
}) => {
  if (t.value == null) return;
  const e = C(t.value);
  if (e > ed) return;
  const n = t.entries.find(m => m.duration === t.value && An[m.name]);
  if (!n) return;
  const {
    interactionId: r
  } = n, s = An[n.name], a = C(K() + n.startTime), o = J(), c = o ? X(o) : void 0, i = r != null ? Ot.get(r) : void 0, u = (i == null ? void 0 : i.span) || c, f = u ? A(u).description : L().getScopeData().transactionName, d = (i == null ? void 0 : i.elementName) || fe(n.target), l = {
    [O]: "auto.http.browser.inp",
    [Te]: `ui.interaction.${s}`,
    [Ye]: n.duration
  }, p = zn({
    name: d,
    transaction: f,
    attributes: l,
    startTime: a
  });
  p && (p.addEvent("inp", {
    [dt]: "millisecond",
    [ft]: t.value
  }), p.end(a + e))
};

function sd() {
  const t = Object.keys(An);
  vc() && t.forEach(s => {
    S.addEventListener(s, e, {
      capture: !0,
      passive: !0
    })
  });

  function e(s) {
    const a = s.target;
    if (!a) return;
    const o = fe(a),
      c = Math.round(s.timeStamp);
    if (Be.set(c, o), Be.size > 50) {
      const i = Be.keys().next().value;
      i !== void 0 && Be.delete(i)
    }
  }

  function n(s) {
    const a = Math.round(s.startTime);
    let o = Be.get(a);
    if (!o)
      for (let c = -5; c <= 5; c++) {
        const i = Be.get(a + c);
        if (i) {
          o = i;
          break
        }
      }
    return o || "<unknown>"
  }
  const r = ({
    entries: s
  }) => {
    const a = J(),
      o = a && X(a);
    s.forEach(c => {
      if (!lu(c)) return;
      const i = c.interactionId;
      if (i == null || Ot.has(i)) return;
      const u = c.target ? fe(c.target) : n(c);
      if (fn.length > 10) {
        const f = fn.shift();
        Ot.delete(f)
      }
      fn.push(i), Ot.set(i, {
        span: o,
        elementName: u
      })
    })
  };
  Ge("event", r), Ge("first-input", r)
}
const ad = 40;

function od(t, e = Xu("fetch")) {
  let n = 0,
    r = 0;
  async function s(a) {
    const o = a.body.length;
    n += o, r++;
    const c = {
      body: a.body,
      method: "POST",
      referrerPolicy: "strict-origin",
      headers: t.headers,
      keepalive: n <= 6e4 && r < 15,
      ...t.fetchOptions
    };
    try {
      const i = await e(t.url, c);
      return {
        statusCode: i.status,
        headers: {
          "x-sentry-rate-limits": i.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": i.headers.get("Retry-After")
        }
      }
    } catch (i) {
      throw Ju("fetch"), i
    } finally {
      n -= o, r--
    }
  }
  return Ai(t, s, Ps(t.bufferSize || ad))
}
const id = 30,
  cd = 50;

function Pn(t, e, n, r) {
  const s = {
    filename: t,
    function: e === "<anonymous>" ? Ve : e,
    in_app: !0
  };
  return n !== void 0 && (s.lineno = n), r !== void 0 && (s.colno = r), s
}
const ud = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i,
  dd = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
  fd = /\((\S*)(?::(\d+))(?::(\d+))\)/,
  ld = /at (.+?) ?\(data:(.+?),/,
  pd = t => {
    const e = t.match(ld);
    if (e) return {
      filename: `<data:${e[2]}>`,
      function: e[1]
    };
    const n = ud.exec(t);
    if (n) {
      const [, s, a, o] = n;
      return Pn(s, Ve, +a, +o)
    }
    const r = dd.exec(t);
    if (r) {
      if (r[2] && r[2].indexOf("eval") === 0) {
        const c = fd.exec(r[2]);
        c && (r[2] = c[1], r[3] = c[2], r[4] = c[3])
      }
      const [a, o] = ta(r[1] || Ve, r[2]);
      return Pn(o, a, r[3] ? +r[3] : void 0, r[4] ? +r[4] : void 0)
    }
  },
  md = [id, pd],
  gd = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
  _d = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
  hd = t => {
    const e = gd.exec(t);
    if (e) {
      if (e[3] && e[3].indexOf(" > eval") > -1) {
        const a = _d.exec(e[3]);
        a && (e[1] = e[1] || "eval", e[3] = a[1], e[4] = a[2], e[5] = "")
      }
      let r = e[3],
        s = e[1] || Ve;
      return [s, r] = ta(s, r), Pn(r, s, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
    }
  },
  Ed = [cd, hd],
  Sd = [md, Ed],
  yd = qa(...Sd),
  ta = (t, e) => {
    const n = t.indexOf("safari-extension") !== -1,
      r = t.indexOf("safari-web-extension") !== -1;
    return n || r ? [t.indexOf("@") !== -1 ? t.split("@")[0] : Ve, n ? `safari-extension:${e}` : `safari-web-extension:${e}`] : [t, e]
  },
  se = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  It = 1024,
  bd = "Breadcrumbs",
  Td = ((t = {}) => {
    const e = {
      console: !0,
      dom: !0,
      fetch: !0,
      history: !0,
      sentry: !0,
      xhr: !0,
      ...t
    };
    return {
      name: bd,
      setup(n) {
        e.console && Ji(wd(n)), e.dom && qu(Rd(n, e.dom)), e.xhr && ea(Ad(n)), e.fetch && Ds(Pd(n)), e.history && Yn(kd(n)), e.sentry && n.on("beforeSendEvent", Id(n))
      }
    }
  }),
  vd = Td;

function Id(t) {
  return function(n) {
    k() === t && Oe({
      category: `sentry.${n.type==="transaction"?"transaction":"event"}`,
      event_id: n.event_id,
      level: n.level,
      message: Ne(n)
    }, {
      event: n
    })
  }
}

function Rd(t, e) {
  return function(r) {
    if (k() !== t) return;
    let s, a, o = typeof e == "object" ? e.serializeAttribute : void 0,
      c = typeof e == "object" && typeof e.maxStringLength == "number" ? e.maxStringLength : void 0;
    c && c > It && (se && g.warn(`\`dom.maxStringLength\` cannot exceed ${It}, but a value of ${c} was configured. Sentry will use ${It} instead.`), c = It), typeof o == "string" && (o = [o]);
    try {
      const u = r.event,
        f = Nd(u) ? u.target : u;
      s = fe(f, {
        keyAttrs: o,
        maxStringLength: c
      }), a = os(f)
    } catch {
      s = "<unknown>"
    }
    if (s.length === 0) return;
    const i = {
      category: `ui.${r.name}`,
      message: s
    };
    a && (i.data = {
      "ui.component_name": a
    }), Oe(i, {
      event: r.event,
      name: r.name,
      global: r.global
    })
  }
}

function wd(t) {
  return function(n) {
    if (k() !== t) return;
    const r = {
      category: "console",
      data: {
        arguments: n.args,
        logger: "console"
      },
      level: Zi(n.level),
      message: or(n.args, " ")
    };
    if (n.level === "assert")
      if (n.args[0] === !1) r.message = `Assertion failed: ${or(n.args.slice(1)," ")||"console.assert"}`, r.data.arguments = n.args.slice(1);
      else return;
    Oe(r, {
      input: n.args,
      level: n.level
    })
  }
}

function Ad(t) {
  return function(n) {
    if (k() !== t) return;
    const {
      startTimestamp: r,
      endTimestamp: s
    } = n, a = n.xhr[Ue];
    if (!r || !s || !a) return;
    const {
      method: o,
      url: c,
      status_code: i,
      body: u
    } = a, f = {
      method: o,
      url: c,
      status_code: i
    }, d = {
      xhr: n.xhr,
      input: u,
      startTimestamp: r,
      endTimestamp: s
    }, l = {
      category: "xhr",
      data: f,
      type: "http",
      level: Ms(i)
    };
    t.emit("beforeOutgoingRequestBreadcrumb", l, d), Oe(l, d)
  }
}

function Pd(t) {
  return function(n) {
    if (k() !== t) return;
    const {
      startTimestamp: r,
      endTimestamp: s
    } = n;
    if (s && !(n.fetchData.url.match(/sentry_key/) && n.fetchData.method === "POST"))
      if (n.fetchData.method, n.fetchData.url, n.error) {
        const a = n.fetchData,
          o = {
            data: n.error,
            input: n.args,
            startTimestamp: r,
            endTimestamp: s
          },
          c = {
            category: "fetch",
            data: a,
            level: "error",
            type: "http"
          };
        t.emit("beforeOutgoingRequestBreadcrumb", c, o), Oe(c, o)
      } else {
        const a = n.response,
          o = {
            ...n.fetchData,
            status_code: a == null ? void 0 : a.status
          };
        n.fetchData.request_body_size, n.fetchData.response_body_size, a == null || a.status;
        const c = {
            input: n.args,
            response: a,
            startTimestamp: r,
            endTimestamp: s
          },
          i = {
            category: "fetch",
            data: o,
            type: "http",
            level: Ms(o.status_code)
          };
        t.emit("beforeOutgoingRequestBreadcrumb", i, c), Oe(i, c)
      }
  }
}

function kd(t) {
  return function(n) {
    if (k() !== t) return;
    let r = n.from,
      s = n.to;
    const a = Le(b.location.href);
    let o = r ? Le(r) : void 0;
    const c = Le(s);
    o != null && o.path || (o = a), a.protocol === c.protocol && a.host === c.host && (s = c.relative), a.protocol === o.protocol && a.host === o.host && (r = o.relative), Oe({
      category: "navigation",
      data: {
        from: r,
        to: s
      }
    })
  }
}

function Nd(t) {
  return !!t && !!t.target
}
const Ld = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"],
  Cd = "BrowserApiErrors",
  Od = ((t = {}) => {
    const e = {
      XMLHttpRequest: !0,
      eventTarget: !0,
      requestAnimationFrame: !0,
      setInterval: !0,
      setTimeout: !0,
      unregisterOriginalCallbacks: !1,
      ...t
    };
    return {
      name: Cd,
      setupOnce() {
        e.setTimeout && Y(b, "setTimeout", Hr), e.setInterval && Y(b, "setInterval", Hr), e.requestAnimationFrame && Y(b, "requestAnimationFrame", Dd), e.XMLHttpRequest && "XMLHttpRequest" in b && Y(XMLHttpRequest.prototype, "send", xd);
        const n = e.eventTarget;
        n && (Array.isArray(n) ? n : Ld).forEach(s => Fd(s, e))
      }
    }
  }),
  Md = Od;

function Hr(t) {
  return function(...e) {
    const n = e[0];
    return e[0] = We(n, {
      mechanism: {
        handled: !1,
        type: `auto.browser.browserapierrors.${be(t)}`
      }
    }), t.apply(this, e)
  }
}

function Dd(t) {
  return function(e) {
    return t.apply(this, [We(e, {
      mechanism: {
        data: {
          handler: be(t)
        },
        handled: !1,
        type: "auto.browser.browserapierrors.requestAnimationFrame"
      }
    })])
  }
}

function xd(t) {
  return function(...e) {
    const n = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(s => {
      s in n && typeof n[s] == "function" && Y(n, s, function(a) {
        const o = {
            mechanism: {
              data: {
                handler: be(a)
              },
              handled: !1,
              type: `auto.browser.browserapierrors.xhr.${s}`
            }
          },
          c = Mn(a);
        return c && (o.mechanism.data.handler = be(c)), We(a, o)
      })
    }), t.apply(this, e)
  }
}

function Fd(t, e) {
  var s, a;
  const r = (s = b[t]) == null ? void 0 : s.prototype;
  (a = r == null ? void 0 : r.hasOwnProperty) != null && a.call(r, "addEventListener") && (Y(r, "addEventListener", function(o) {
    return function(c, i, u) {
      try {
        Hd(i) && (i.handleEvent = We(i.handleEvent, {
          mechanism: {
            data: {
              handler: be(i),
              target: t
            },
            handled: !1,
            type: "auto.browser.browserapierrors.handleEvent"
          }
        }))
      } catch {}
      return e.unregisterOriginalCallbacks && Bd(this, c, i), o.apply(this, [c, We(i, {
        mechanism: {
          data: {
            handler: be(i),
            target: t
          },
          handled: !1,
          type: "auto.browser.browserapierrors.addEventListener"
        }
      }), u])
    }
  }), Y(r, "removeEventListener", function(o) {
    return function(c, i, u) {
      try {
        const f = i.__sentry_wrapped__;
        f && o.call(this, c, f, u)
      } catch {}
      return o.call(this, c, i, u)
    }
  }))
}

function Hd(t) {
  return typeof t.handleEvent == "function"
}

function Bd(t, e, n) {
  t && typeof t == "object" && "removeEventListener" in t && typeof t.removeEventListener == "function" && t.removeEventListener(e, n)
}
const $d = () => ({
    name: "BrowserSession",
    setupOnce() {
      if (typeof b.document > "u") {
        se && g.warn("Using the `browserSessionIntegration` in non-browser environments is not supported.");
        return
      }
      ir({
        ignoreDuration: !0
      }), cr(), Yn(({
        from: t,
        to: e
      }) => {
        t !== void 0 && t !== e && (ir({
          ignoreDuration: !0
        }), cr())
      })
    }
  }),
  Ud = "GlobalHandlers",
  qd = ((t = {}) => {
    const e = {
      onerror: !0,
      onunhandledrejection: !0,
      ...t
    };
    return {
      name: Ud,
      setupOnce() {
        Error.stackTraceLimit = 50
      },
      setup(n) {
        e.onerror && (Vd(n), Br("onerror")), e.onunhandledrejection && (Wd(n), Br("onunhandledrejection"))
      }
    }
  }),
  jd = qd;

function Vd(t) {
  us(e => {
    const {
      stackParser: n,
      attachStacktrace: r
    } = na();
    if (k() !== t || Fs()) return;
    const {
      msg: s,
      url: a,
      line: o,
      column: c,
      error: i
    } = e, u = Yd(qn(n, i || s, void 0, r, !1), a, o, c);
    u.level = "error", is(u, {
      originalException: i,
      mechanism: {
        handled: !1,
        type: "auto.browser.global_handlers.onerror"
      }
    })
  })
}

function Wd(t) {
  ds(e => {
    const {
      stackParser: n,
      attachStacktrace: r
    } = na();
    if (k() !== t || Fs()) return;
    const s = Gd(e),
      a = je(s) ? zd(s) : qn(n, s, void 0, r, !0);
    a.level = "error", is(a, {
      originalException: s,
      mechanism: {
        handled: !1,
        type: "auto.browser.global_handlers.onunhandledrejection"
      }
    })
  })
}

function Gd(t) {
  if (je(t)) return t;
  try {
    if ("reason" in t) return t.reason;
    if ("detail" in t && "reason" in t.detail) return t.detail.reason
  } catch {}
  return t
}

function zd(t) {
  return {
    exception: {
      values: [{
        type: "UnhandledRejection",
        value: `Non-Error promise rejection captured with value: ${String(t)}`
      }]
    }
  }
}

function Yd(t, e, n, r) {
  const s = t.exception = t.exception || {},
    a = s.values = s.values || [],
    o = a[0] = a[0] || {},
    c = o.stacktrace = o.stacktrace || {},
    i = c.frames = c.frames || [],
    u = r,
    f = n,
    d = Xd(e) ?? lt();
  return i.length === 0 && i.push({
    colno: u,
    filename: d,
    function: Ve,
    in_app: !0,
    lineno: f
  }), t
}

function Br(t) {
  se && g.log(`Global Handler attached: ${t}`)
}

function na() {
  const t = k();
  return (t == null ? void 0 : t.getOptions()) || {
    stackParser: () => [],
    attachStacktrace: !1
  }
}

function Xd(t) {
  if (!(!nt(t) || t.length === 0)) {
    if (t.startsWith("data:")) {
      const e = t.match(/^data:([^;]+)/),
        n = e ? e[1] : "text/javascript",
        r = t.includes("base64,");
      return `<data:${n}${r?",base64":""}>`
    }
    return t
  }
}
const Jd = () => ({
    name: "HttpContext",
    preprocessEvent(t) {
      var r;
      if (!b.navigator && !b.location && !b.document) return;
      const e = Bn(),
        n = {
          ...e.headers,
          ...(r = t.request) == null ? void 0 : r.headers
        };
      t.request = {
        ...e,
        ...t.request,
        headers: n
      }
    }
  }),
  Kd = "cause",
  Zd = 5,
  Qd = "LinkedErrors",
  ef = ((t = {}) => {
    const e = t.limit || Zd,
      n = t.key || Kd;
    return {
      name: Qd,
      preprocessEvent(r, s, a) {
        const o = a.getOptions();
        Xi($n, o.stackParser, n, e, r, s)
      }
    }
  }),
  tf = ef;

function nf() {
  return rf() ? (se && zt(() => {
    console.error("[Sentry] You cannot use Sentry.init() in a browser extension, see: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/")
  }), !0) : !1
}

function rf() {
  var a;
  if (typeof b.window > "u") return !1;
  const t = b;
  if (t.nw) return !1;
  const e = t.chrome || t.browser;
  if (!((a = e == null ? void 0 : e.runtime) != null && a.id)) return !1;
  const n = lt(),
    r = ["chrome-extension", "moz-extension", "ms-browser-extension", "safari-web-extension"];
  return !(b === b.top && r.some(o => n.startsWith(`${o}://`)))
}

function kn(t) {
  return [Ui(), Fi(), Md(), vd(), jd(), tf(), tc(), Jd(), $d()]
}

function sf(t = {}) {
  const e = !t.skipBrowserExtensionCheck && nf();
  let n = t.defaultIntegrations == null ? kn() : t.defaultIntegrations;
  const r = {
    ...t,
    enabled: e ? !1 : t.enabled,
    stackParser: ja(t.stackParser || yd),
    integrations: ni({
      integrations: t.integrations,
      defaultIntegrations: n
    }),
    transport: t.transport || od
  };
  return Si(Fc, r)
}

function af(t) {
  return t.split(",").some(e => e.trim().startsWith("sentry-"))
}

function ra(t) {
  try {
    return new URL(t, b.location.origin).href
  } catch {
    return
  }
}

function of(t) {
  return t.entryType === "resource" && "initiatorType" in t && typeof t.nextHopProtocol == "string" && (t.initiatorType === "fetch" || t.initiatorType === "xmlhttprequest")
}

function sa(t) {
  try {
    return new Headers(t)
  } catch {
    return
  }
}
const $r = new WeakMap,
  ln = new Map,
  aa = {
    traceFetch: !0,
    traceXHR: !0,
    enableHTTPTimings: !0,
    trackFetchStreamPerformance: !1
  };

function cf(t, e) {
  const {
    traceFetch: n,
    traceXHR: r,
    trackFetchStreamPerformance: s,
    shouldCreateSpanForRequest: a,
    enableHTTPTimings: o,
    tracePropagationTargets: c,
    onRequestSpanStart: i,
    onRequestSpanEnd: u
  } = {
    ...aa,
    ...e
  }, f = typeof a == "function" ? a : m => !0, d = m => uf(m, c), l = {}, p = t.getOptions().propagateTraceparent;
  n && (t.addEventProcessor(m => (m.type === "transaction" && m.spans && m.spans.forEach(_ => {
    if (_.op === "http.client") {
      const h = ln.get(_.span_id);
      h && (_.timestamp = h / 1e3, ln.delete(_.span_id))
    }
  }), m)), s && gc(m => {
    if (m.response) {
      const _ = $r.get(m.response);
      _ && m.endTimestamp && ln.set(_, m.endTimestamp)
    }
  }), Ds(m => {
    const _ = ac(m, f, d, l, {
      propagateTraceparent: p,
      onRequestSpanEnd: u
    });
    if (m.response && m.fetchData.__span && $r.set(m.response, m.fetchData.__span), _) {
      const h = ra(m.fetchData.url),
        R = h ? Le(h).host : void 0;
      _.setAttributes({
        "http.url": h,
        "server.address": R
      }), o && Ur(_), i == null || i(_, {
        headers: m.headers
      })
    }
  })), r && ea(m => {
    var h;
    const _ = df(m, f, d, l, p, u);
    _ && (o && Ur(_), i == null || i(_, {
      headers: sa((h = m.xhr.__sentry_xhr_v3__) == null ? void 0 : h.request_headers)
    }))
  })
}

function Ur(t) {
  const {
    url: e
  } = A(t).data;
  if (!e || typeof e != "string") return;
  const n = Ge("resource", ({
    entries: r
  }) => {
    r.forEach(s => {
      of(s) && s.name.endsWith(e) && (t.setAttributes(Qs(s)), setTimeout(n))
    })
  })
}

function uf(t, e) {
  const n = lt();
  if (n) {
    let r, s;
    try {
      r = new URL(t, n), s = new URL(n).origin
    } catch {
      return !1
    }
    const a = r.origin === s;
    return e ? ye(r.toString(), e) || a && ye(r.pathname, e) : a
  } else {
    const r = !!t.match(/^\/(?!\/)/);
    return e ? ye(t, e) : r
  }
}

function df(t, e, n, r, s, a) {
  const o = t.xhr,
    c = o == null ? void 0 : o[Ue];
  if (!o || o.__sentry_own_request__ || !c) return;
  const {
    url: i,
    method: u
  } = c, f = pe() && e(i);
  if (t.endTimestamp && f) {
    const R = o.__sentry_xhr_span_id__;
    if (!R) return;
    const N = r[R];
    N && c.status_code !== void 0 && (ts(N, c.status_code), N.end(), a == null || a(N, {
      headers: sa(Qu(o)),
      error: t.error
    }), delete r[R]);
    return
  }
  const d = ra(i),
    l = Le(d || i),
    p = Ni(i),
    m = !!J(),
    _ = f && m ? De({
      name: `${u} ${p}`,
      attributes: {
        url: i,
        type: "xhr",
        "http.method": u,
        "http.url": d,
        "server.address": l == null ? void 0 : l.host,
        [O]: "auto.http.browser",
        [Te]: "http.client",
        ...(l == null ? void 0 : l.search) && {
          "http.query": l == null ? void 0 : l.search
        },
        ...(l == null ? void 0 : l.hash) && {
          "http.fragment": l == null ? void 0 : l.hash
        }
      }
    }) : new ve;
  o.__sentry_xhr_span_id__ = _.spanContext().spanId, r[o.__sentry_xhr_span_id__] = _, n(i) && ff(o, pe() && m ? _ : void 0, s);
  const h = k();
  return h && h.emit("beforeOutgoingRequestSpan", _, t), _
}

function ff(t, e, n) {
  const {
    "sentry-trace": r,
    baggage: s,
    traceparent: a
  } = Ls({
    span: e,
    propagateTraceparent: n
  });
  r && lf(t, r, s, a)
}

function lf(t, e, n, r) {
  var a;
  const s = (a = t.__sentry_xhr_v3__) == null ? void 0 : a.request_headers;
  if (!(s != null && s["sentry-trace"] || !t.setRequestHeader)) try {
    if (t.setRequestHeader("sentry-trace", e), r && !(s != null && s.traceparent) && t.setRequestHeader("traceparent", r), n) {
      const o = s == null ? void 0 : s.baggage;
      (!o || !af(o)) && t.setRequestHeader("baggage", n)
    }
  } catch {}
}

function pf() {
  b.document ? b.document.addEventListener("visibilitychange", () => {
    const t = J();
    if (!t) return;
    const e = X(t);
    if (b.document.hidden && e) {
      const n = "cancelled",
        {
          op: r,
          status: s
        } = A(e);
      se && g.log(`[Tracing] Transaction: ${n} -> since tab moved to the background, op: ${r}`), s || e.setStatus({
        code: qe,
        message: n
      }), e.setAttribute("sentry.cancellation_reason", "document.hidden"), e.end()
    }
  }) : se && g.warn("[Tracing] Could not set up background tab detection due to lack of global document")
}
const mf = 3600,
  oa = "sentry_previous_trace",
  gf = "sentry.previous_trace";

function _f(t, {
  linkPreviousTrace: e,
  consistentTraceSampling: n
}) {
  const r = e === "session-storage";
  let s = r ? Sf() : void 0;
  t.on("spanStart", o => {
    if (X(o) !== o) return;
    const c = L().getPropagationContext();
    s = hf(s, o, c), r && Ef(s)
  });
  let a = !0;
  n && t.on("beforeSampling", o => {
    if (!s) return;
    const c = L(),
      i = c.getPropagationContext();
    if (a && i.parentSpanId) {
      a = !1;
      return
    }
    c.setPropagationContext({
      ...i,
      dsc: {
        ...i.dsc,
        sample_rate: String(s.sampleRate),
        sampled: String(Nn(s.spanContext))
      },
      sampleRand: s.sampleRand
    }), o.parentSampled = Nn(s.spanContext), o.parentSampleRate = s.sampleRate, o.spanAttributes = {
      ...o.spanAttributes,
      [Va]: s.sampleRate
    }
  })
}

function hf(t, e, n) {
  const r = A(e);

  function s() {
    var c, i;
    try {
      return Number((c = n.dsc) == null ? void 0 : c.sample_rate) ?? Number((i = r.data) == null ? void 0 : i[Jr])
    } catch {
      return 0
    }
  }
  const a = {
    spanContext: e.spanContext(),
    startTimestamp: r.start_timestamp,
    sampleRate: s(),
    sampleRand: n.sampleRand
  };
  if (!t) return a;
  const o = t.spanContext;
  return o.traceId === r.trace_id ? t : (Date.now() / 1e3 - t.startTimestamp <= mf && (se && g.log(`Adding previous_trace ${o} link to span ${{op:r.op,...e.spanContext()}}`), e.addLink({
    context: o,
    attributes: {
      [Wa]: "previous_trace"
    }
  }), e.setAttribute(gf, `${o.traceId}-${o.spanId}-${Nn(o)?1:0}`)), a)
}

function Ef(t) {
  try {
    b.sessionStorage.setItem(oa, JSON.stringify(t))
  } catch (e) {
    se && g.warn("Could not store previous trace in sessionStorage", e)
  }
}

function Sf() {
  var t;
  try {
    const e = (t = b.sessionStorage) == null ? void 0 : t.getItem(oa);
    return JSON.parse(e)
  } catch {
    return
  }
}

function Nn(t) {
  return t.traceFlags === 1
}
const yf = "BrowserTracing",
  bf = {
    ...Nt,
    instrumentNavigation: !0,
    instrumentPageLoad: !0,
    markBackgroundSpan: !0,
    enableLongTask: !0,
    enableLongAnimationFrame: !0,
    enableInp: !0,
    enableElementTiming: !0,
    ignoreResourceSpans: [],
    ignorePerformanceApiSpans: [],
    detectRedirects: !0,
    linkPreviousTrace: "in-memory",
    consistentTraceSampling: !1,
    enableReportPageLoaded: !1,
    _experiments: {},
    ...aa
  },
  Tf = ((t = {}) => {
    const e = {
        name: void 0,
        source: void 0
      },
      n = b.document,
      {
        enableInp: r,
        enableElementTiming: s,
        enableLongTask: a,
        enableLongAnimationFrame: o,
        _experiments: {
          enableInteractions: c,
          enableStandaloneClsSpans: i,
          enableStandaloneLcpSpans: u
        },
        beforeStartSpan: f,
        idleTimeout: d,
        finalTimeout: l,
        childSpanTimeout: p,
        markBackgroundSpan: m,
        traceFetch: _,
        traceXHR: h,
        trackFetchStreamPerformance: R,
        shouldCreateSpanForRequest: N,
        enableHTTPTimings: B,
        ignoreResourceSpans: me,
        ignorePerformanceApiSpans: ae,
        instrumentPageLoad: oe,
        instrumentNavigation: y,
        detectRedirects: M,
        linkPreviousTrace: ge,
        consistentTraceSampling: xe,
        enableReportPageLoaded: ie,
        onRequestSpanStart: _e,
        onRequestSpanEnd: P
      } = {
        ...bf,
        ...t
      };
    let $, W, U;

    function Z(v, I, T = !0) {
      const D = I.op === "pageload",
        F = I.name,
        G = f ? f(I) : I,
        he = G.attributes || {};
      if (F !== G.name && (he[ne] = "custom", G.attributes = he), !T) {
        const ce = Gt();
        De({
          ...G,
          startTime: ce
        }).end(ce);
        return
      }
      e.name = G.name, e.source = he[ne];
      const H = _s(G, {
        idleTimeout: d,
        finalTimeout: l,
        childSpanTimeout: p,
        disableAutoFinish: D,
        beforeSpanEnd: ce => {
          $ == null || $(), Au(ce, {
            recordClsOnPageloadSpan: !i,
            recordLcpOnPageloadSpan: !u,
            ignoreResourceSpans: me,
            ignorePerformanceApiSpans: ae
          }), jr(v, void 0);
          const He = L(),
            Ke = He.getPropagationContext();
          He.setPropagationContext({
            ...Ke,
            traceId: H.spanContext().traceId,
            sampled: qt(H),
            dsc: Ce(ce)
          }), D && (U = void 0)
        },
        trimIdleSpanEndTimestamp: !ie
      });
      D && ie && (U = H), jr(v, H);

      function Fe() {
        n && ["interactive", "complete"].includes(n.readyState) && v.emit("idleSpanEnableAutoFinish", H)
      }
      D && !ie && n && (n.addEventListener("readystatechange", () => {
        Fe()
      }), Fe())
    }
    return {
      name: yf,
      setup(v) {
        if (yo(), $ = yu({
            recordClsStandaloneSpans: i || !1,
            recordLcpStandaloneSpans: u || !1,
            client: v
          }), r && td(), s && Bu(), o && x.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes("long-animation-frame") ? Tu() : a && bu(), c && vu(), M && n) {
          const T = () => {
            W = q()
          };
          addEventListener("click", T, {
            capture: !0
          }), addEventListener("keydown", T, {
            capture: !0,
            passive: !0
          })
        }

        function I() {
          const T = ut(v);
          T && !A(T).timestamp && (se && g.log(`[Tracing] Finishing current active span with op: ${A(T).op}`), T.setAttribute(at, "cancelled"), T.end())
        }
        v.on("startNavigationSpan", (T, D) => {
          if (k() !== v) return;
          if (D != null && D.isRedirect) {
            se && g.warn("[Tracing] Detected redirect, navigation span will not be the root span, but a child span."), Z(v, {
              op: "navigation.redirect",
              ...T
            }, !1);
            return
          }
          W = void 0, I(), Wt().setPropagationContext({
            traceId: Mt(),
            sampleRand: Math.random(),
            propagationSpanId: pe() ? void 0 : et()
          });
          const F = L();
          F.setPropagationContext({
            traceId: Mt(),
            sampleRand: Math.random(),
            propagationSpanId: pe() ? void 0 : et()
          }), F.setSDKProcessingMetadata({
            normalizedRequest: void 0
          }), Z(v, {
            op: "navigation",
            ...T,
            parentSpan: null,
            forceTransaction: !0
          })
        }), v.on("startPageLoadSpan", (T, D = {}) => {
          if (k() !== v) return;
          I();
          const F = D.sentryTrace || qr("sentry-trace"),
            G = D.baggage || qr("baggage"),
            he = Ga(F, G),
            H = L();
          H.setPropagationContext(he), pe() || (H.getPropagationContext().propagationSpanId = et()), H.setSDKProcessingMetadata({
            normalizedRequest: Bn()
          }), Z(v, {
            op: "pageload",
            ...T
          })
        }), v.on("endPageloadSpan", () => {
          ie && U && (U.setAttribute(at, "reportPageLoaded"), U.end())
        })
      },
      afterAllSetup(v) {
        let I = lt();
        if (ge !== "off" && _f(v, {
            linkPreviousTrace: ge,
            consistentTraceSampling: xe
          }), b.location) {
          if (oe) {
            const T = K();
            ia(v, {
              name: b.location.pathname,
              startTime: T ? T / 1e3 : void 0,
              attributes: {
                [ne]: "url",
                [O]: "auto.pageload.browser"
              }
            })
          }
          y && Yn(({
            to: T,
            from: D
          }) => {
            if (D === void 0 && (I == null ? void 0 : I.indexOf(T)) !== -1) {
              I = void 0;
              return
            }
            I = void 0;
            const F = Ns(T),
              G = ut(v),
              he = G && M && If(G, W);
            ca(v, {
              name: (F == null ? void 0 : F.pathname) || b.location.pathname,
              attributes: {
                [ne]: "url",
                [O]: "auto.navigation.browser"
              }
            }, {
              url: T,
              isRedirect: he
            })
          })
        }
        m && pf(), c && vf(v, d, l, p, e), r && sd(), cf(v, {
          traceFetch: _,
          traceXHR: h,
          trackFetchStreamPerformance: R,
          tracePropagationTargets: v.getOptions().tracePropagationTargets,
          shouldCreateSpanForRequest: N,
          enableHTTPTimings: B,
          onRequestSpanStart: _e,
          onRequestSpanEnd: P
        })
      }
    }
  });

function ia(t, e, n) {
  t.emit("startPageLoadSpan", e, n), L().setTransactionName(e.name);
  const r = ut(t);
  return r && t.emit("afterStartPageLoadSpan", r), r
}

function ca(t, e, n) {
  const {
    url: r,
    isRedirect: s
  } = n || {};
  t.emit("beforeStartNavigationSpan", e, {
    isRedirect: s
  }), t.emit("startNavigationSpan", e, {
    isRedirect: s
  });
  const a = L();
  return a.setTransactionName(e.name), r && !s && a.setSDKProcessingMetadata({
    normalizedRequest: {
      ...Bn(),
      url: r
    }
  }), ut(t)
}

function qr(t) {
  const e = b.document,
    n = e == null ? void 0 : e.querySelector(`meta[name=${t}]`);
  return (n == null ? void 0 : n.getAttribute("content")) || void 0
}

function vf(t, e, n, r, s) {
  const a = b.document;
  let o;
  const c = () => {
    const i = "ui.action.click",
      u = ut(t);
    if (u) {
      const f = A(u).op;
      if (["navigation", "pageload"].includes(f)) {
        se && g.warn(`[Tracing] Did not create ${i} span because a pageload or navigation span is in progress.`);
        return
      }
    }
    if (o && (o.setAttribute(at, "interactionInterrupted"), o.end(), o = void 0), !s.name) {
      se && g.warn(`[Tracing] Did not create ${i} transaction because _latestRouteName is missing.`);
      return
    }
    o = _s({
      name: s.name,
      op: i,
      attributes: {
        [ne]: s.source || "url"
      }
    }, {
      idleTimeout: e,
      finalTimeout: n,
      childSpanTimeout: r
    })
  };
  a && addEventListener("click", c, {
    capture: !0
  })
}
const ua = "_sentry_idleSpan";

function ut(t) {
  return t[ua]
}

function jr(t, e) {
  ot(t, ua, e)
}
const Vr = 1.5;

function If(t, e) {
  const n = A(t),
    r = Gt(),
    s = n.start_timestamp;
  return !(r - s > Vr || e && r - e <= Vr)
}

function Rf(t) {
  const e = {
    ...t
  };
  return Hn(e, "svelte"), sf(e)
}
const da = () => {
    const t = za;
    return {
      page: {
        subscribe: t.page.subscribe
      },
      navigating: {
        subscribe: t.navigating.subscribe
      },
      updated: t.updated
    }
  },
  wf = {
    subscribe(t) {
      return da().page.subscribe(t)
    }
  },
  Af = {
    subscribe(t) {
      return da().navigating.subscribe(t)
    }
  };

function Pf(t = {}) {
  const e = {
    ...Tf({
      ...t,
      instrumentNavigation: !1,
      instrumentPageLoad: !1
    })
  };
  return {
    ...e,
    afterAllSetup: n => {
      e.afterAllSetup(n), t.instrumentPageLoad !== !1 && kf(n), t.instrumentNavigation !== !1 && Nf(n)
    }
  }
}

function kf(t) {
  var r;
  const e = (r = b.location) == null ? void 0 : r.pathname,
    n = ia(t, {
      name: e,
      op: "pageload",
      attributes: {
        [O]: "auto.pageload.sveltekit",
        [ne]: "url"
      }
    });
  n && wf.subscribe(s => {
    var o;
    if (!s) return;
    const a = (o = s.route) == null ? void 0 : o.id;
    a && (n.updateName(a), n.setAttribute(ne, "route"), L().setTransactionName(a))
  })
}

function Nf(t) {
  let e;
  Af.subscribe(n => {
    var f;
    if (!n) {
      e && (e.end(), e = void 0);
      return
    }
    const r = n.from,
      s = n.to,
      a = (r == null ? void 0 : r.url.pathname) || ((f = b.location) == null ? void 0 : f.pathname),
      o = s == null ? void 0 : s.url.pathname;
    if (a === o) return;
    const c = r == null ? void 0 : r.route.id,
      i = s == null ? void 0 : s.route.id;
    e && e.end();
    const u = {
      "sentry.sveltekit.navigation.type": n.type,
      "sentry.sveltekit.navigation.from": c || void 0,
      "sentry.sveltekit.navigation.to": i || void 0
    };
    ca(t, {
      name: i || o || "unknown",
      op: "navigation",
      attributes: {
        [O]: "auto.navigation.sveltekit",
        [ne]: i ? "route" : "url",
        ...u
      }
    }), e = De({
      op: "ui.sveltekit.routing",
      name: "SvelteKit Route Change",
      attributes: {
        [O]: "auto.ui.sveltekit",
        ...u
      },
      onlyIfParent: !0
    })
  })
}

function Lf(t) {
  const e = {
    defaultIntegrations: Cf(),
    ...t
  };
  Hn(e, "sveltekit", ["sveltekit", "svelte"]);
  const n = Of(),
    r = Rf(e);
  return n && Mf(n), r
}

function Cf(t) {
  return typeof __SENTRY_TRACING__ > "u" || __SENTRY_TRACING__ ? [...kn(), Pf()] : kn()
}

function Of() {
  const t = b,
    e = t.fetch;
  if (t._sentryFetchProxy && e) return t.fetch = t._sentryFetchProxy, e
}

function Mf(t) {
  const e = b;
  e._sentryFetchProxy = e.fetch, e.fetch = t
}

function Df({
  error: t
}) {
  zt(() => {
    console.error(t)
  })
}

function xf(t) {
  const e = Df;
  return n => (Ff(n) || ss(n.error, {
    mechanism: {
      type: "auto.function.sveltekit.handle_error",
      handled: !1
    }
  }), e(n))
}

function Ff(t) {
  const {
    status: e
  } = t;
  return e ? e >= 400 && e < 500 : !1
}
Lf({
  dsn: "https://ef9fc09cd53942366f18dbc146ea7350@o4509998160805888.ingest.us.sentry.io/4509998167687168",
  tracesSampleRate: 1,
  enableLogs: !0,
  environment: "prod",
  replaysOnErrorSampleRate: 1
});
const Hf = xf(),
  tl = {};
var Bf = cs('<div id="svelte-announcer" aria-live="assertive" aria-atomic="true" style="position: absolute; left: 0; top: 0; clip: rect(0 0 0 0); clip-path: inset(50%); overflow: hidden; white-space: nowrap; width: 1px; height: 1px"><!></div>'),
  $f = cs("<!> <!>", 1);

function Uf(t, e) {
  Za(e, !0);
  let n = Qe(e, "components", 23, () => []),
    r = Qe(e, "data_0", 3, null),
    s = Qe(e, "data_1", 3, null),
    a = Qe(e, "data_2", 3, null),
    o = Qe(e, "data_3", 3, null);
  Qa(() => e.stores.page.set(e.page)), eo(() => {
    e.stores, e.page, e.constructors, n(), e.form, r(), s(), a(), o(), e.stores.page.notify()
  });
  let c = tn(!1),
    i = tn(!1),
    u = tn(null);
  po(() => {
    const R = e.stores.page.subscribe(() => {
      z(c) && (Pt(i, !0), to().then(() => {
        Pt(u, document.title || "untitled page", !0)
      }))
    });
    return Pt(c, !0), R
  });
  const f = Ae(() => e.constructors[3]);
  var d = $f(),
    l = le(d);
  {
    var p = R => {
        const N = Ae(() => e.constructors[0]);
        var B = Ee(),
          me = le(B);
        Pe(me, () => z(N), (ae, oe) => {
          ke(oe(ae, {
            get data() {
              return r()
            },
            get form() {
              return e.form
            },
            get params() {
              return e.page.params
            },
            children: (y, M) => {
              var ge = Ee(),
                xe = le(ge);
              {
                var ie = P => {
                    const $ = Ae(() => e.constructors[1]);
                    var W = Ee(),
                      U = le(W);
                    Pe(U, () => z($), (Z, v) => {
                      ke(v(Z, {
                        get data() {
                          return s()
                        },
                        get form() {
                          return e.form
                        },
                        get params() {
                          return e.page.params
                        },
                        children: (I, T) => {
                          var D = Ee(),
                            F = le(D);
                          {
                            var G = H => {
                                const Fe = Ae(() => e.constructors[2]);
                                var ce = Ee(),
                                  He = le(ce);
                                Pe(He, () => z(Fe), (Ke, Kt) => {
                                  ke(Kt(Ke, {
                                    get data() {
                                      return a()
                                    },
                                    get form() {
                                      return e.form
                                    },
                                    get params() {
                                      return e.page.params
                                    },
                                    children: (ue, jf) => {
                                      var Xn = Ee(),
                                        la = le(Xn);
                                      Pe(la, () => z(f), (pa, ma) => {
                                        ke(ma(pa, {
                                          get data() {
                                            return o()
                                          },
                                          get form() {
                                            return e.form
                                          },
                                          get params() {
                                            return e.page.params
                                          }
                                        }), St => n()[3] = St, () => {
                                          var St;
                                          return (St = n()) == null ? void 0 : St[3]
                                        })
                                      }), Q(ue, Xn)
                                    },
                                    $$slots: {
                                      default: !0
                                    }
                                  }), ue => n()[2] = ue, () => {
                                    var ue;
                                    return (ue = n()) == null ? void 0 : ue[2]
                                  })
                                }), Q(H, ce)
                              },
                              he = H => {
                                const Fe = Ae(() => e.constructors[2]);
                                var ce = Ee(),
                                  He = le(ce);
                                Pe(He, () => z(Fe), (Ke, Kt) => {
                                  ke(Kt(Ke, {
                                    get data() {
                                      return a()
                                    },
                                    get form() {
                                      return e.form
                                    },
                                    get params() {
                                      return e.page.params
                                    }
                                  }), ue => n()[2] = ue, () => {
                                    var ue;
                                    return (ue = n()) == null ? void 0 : ue[2]
                                  })
                                }), Q(H, ce)
                              };
                            Ze(F, H => {
                              e.constructors[3] ? H(G) : H(he, !1)
                            })
                          }
                          Q(I, D)
                        },
                        $$slots: {
                          default: !0
                        }
                      }), I => n()[1] = I, () => {
                        var I;
                        return (I = n()) == null ? void 0 : I[1]
                      })
                    }), Q(P, W)
                  },
                  _e = P => {
                    const $ = Ae(() => e.constructors[1]);
                    var W = Ee(),
                      U = le(W);
                    Pe(U, () => z($), (Z, v) => {
                      ke(v(Z, {
                        get data() {
                          return s()
                        },
                        get form() {
                          return e.form
                        },
                        get params() {
                          return e.page.params
                        }
                      }), I => n()[1] = I, () => {
                        var I;
                        return (I = n()) == null ? void 0 : I[1]
                      })
                    }), Q(P, W)
                  };
                Ze(xe, P => {
                  e.constructors[2] ? P(ie) : P(_e, !1)
                })
              }
              Q(y, ge)
            },
            $$slots: {
              default: !0
            }
          }), y => n()[0] = y, () => {
            var y;
            return (y = n()) == null ? void 0 : y[0]
          })
        }), Q(R, B)
      },
      m = R => {
        const N = Ae(() => e.constructors[0]);
        var B = Ee(),
          me = le(B);
        Pe(me, () => z(N), (ae, oe) => {
          ke(oe(ae, {
            get data() {
              return r()
            },
            get form() {
              return e.form
            },
            get params() {
              return e.page.params
            }
          }), y => n()[0] = y, () => {
            var y;
            return (y = n()) == null ? void 0 : y[0]
          })
        }), Q(R, B)
      };
    Ze(l, R => {
      e.constructors[1] ? R(p) : R(m, !1)
    })
  }
  var _ = no(l, 2);
  {
    var h = R => {
      var N = Bf(),
        B = so(N);
      {
        var me = ae => {
          var oe = oo();
          io(() => lo(oe, z(u))), Q(ae, oe)
        };
        Ze(B, ae => {
          z(i) && ae(me)
        })
      }
      ao(N), Q(R, N)
    };
    Ze(_, R => {
      z(c) && R(h)
    })
  }
  Q(t, d), ro()
}
const nl = mo(Uf),
  rl = [() => w(() => import("../nodes/0.CjLk6r6x.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]), import.meta.url), () => w(() => import("../nodes/1.BdMFEqYB.js"), __vite__mapDeps([19, 1, 17, 3, 4, 20, 21, 22, 2, 5]), import.meta.url), () => w(() => import("../nodes/2.DZTzkQMz.js"), __vite__mapDeps([23, 1, 2, 3, 4, 11, 24, 12, 25, 13, 26, 22, 5, 21, 27, 7, 8, 6, 9, 28, 15, 29, 30, 31, 32, 33, 34, 35, 36, 37]), import.meta.url), () => w(() => import("../nodes/3.BU92DUVz.js"), __vite__mapDeps([38, 1, 2, 3, 4, 24, 12, 25, 13, 26, 8, 39, 40, 35, 41, 21, 22, 5, 37, 7, 6, 9, 27]), import.meta.url), () => w(() => import("../nodes/4.D8tZYwKh.js"), __vite__mapDeps([42, 1, 2, 3, 4, 11, 25, 13, 26, 12, 22, 5, 21, 6, 7, 8, 9, 10, 27, 17, 43, 14, 20, 15, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 37, 61, 62, 24, 63, 36, 39, 64, 28, 16, 29, 65, 66, 67, 68, 32, 69, 70, 71, 72, 73, 74, 75]), import.meta.url), () => w(() => import("../nodes/5.CSjNJ3H-.js"), __vite__mapDeps([76, 1, 17, 3, 28, 11, 13, 15]), import.meta.url), () => w(() => import("../nodes/6.CGb-3gDS.js"), __vite__mapDeps([77, 1, 2, 3, 4, 11, 24, 12, 25, 13, 43, 21, 22, 5, 7, 8, 6, 9, 27, 48, 49, 69, 17, 20, 15, 70, 28, 64, 54, 78, 72, 79, 80, 68, 57, 81, 82, 40, 83, 51]), import.meta.url), () => w(() => import("../nodes/7.B5PP93-T.js"), __vite__mapDeps([84, 1, 2, 3, 4, 11, 24, 12, 25, 13, 26, 43, 22, 5, 21, 7, 8, 6, 9, 27, 52, 15, 48, 49, 54, 72, 85, 29, 53, 86, 67, 58, 87, 88, 61, 74, 89, 90, 51, 37]), import.meta.url), () => w(() => import("../nodes/8.3DV0tG2O.js"), __vite__mapDeps([91, 1, 2, 3, 4, 11, 12, 25, 13, 43, 22, 5, 7, 8, 6, 9, 27, 48, 49, 72, 15, 92, 30, 93, 86, 81, 94, 95, 87, 88, 82, 96, 59, 97, 63]), import.meta.url), () => w(() => import("../nodes/9.DAiN1P8F.js"), __vite__mapDeps([98, 1, 2, 3, 4, 11, 12, 25, 7, 8, 6, 9, 27, 31, 57, 81, 94, 99]), import.meta.url), () => w(() => import("../nodes/10.LfabLcqM.js"), __vite__mapDeps([100, 1, 2, 3, 4, 11, 12, 25, 13, 43, 7, 8, 6, 9, 27, 69, 17, 20, 15, 70, 28, 44, 72, 85, 68, 33, 51, 14]), import.meta.url), () => w(() => import("../nodes/11.8mJU1Xsl.js"), __vite__mapDeps([101, 1, 2, 3, 4, 11, 12, 25, 13, 43, 7, 8, 6, 9, 52, 15, 72, 92, 86, 88, 102, 34, 60, 27]), import.meta.url), () => w(() => import("../nodes/12.DoDjKBcz.js"), __vite__mapDeps([103, 1, 17, 3, 2, 4, 25, 20, 8, 35, 7, 6, 9, 27, 22, 5]), import.meta.url), () => w(() => import("../nodes/13.rWnKomii.js"), __vite__mapDeps([104, 1, 2, 3, 4, 11, 12, 25, 13, 43, 22, 5, 7, 8, 6, 9, 48, 49, 72, 15, 92, 105, 93, 95, 106, 39, 88, 74, 40, 89, 35, 59, 97, 90, 70, 27]), import.meta.url), () => w(() => import("../nodes/14.Dr_EuPQT.js"), __vite__mapDeps([107, 1, 2, 3, 4, 11, 12, 25, 13, 43, 22, 5, 7, 8, 6, 9, 48, 49, 72, 15, 92, 105, 93, 95, 106, 39, 88, 74, 89, 35, 59, 90, 70, 27]), import.meta.url), () => w(() => import("../nodes/15.DaS6BCUm.js"), __vite__mapDeps([108, 1, 2, 3, 4, 11, 24, 12, 25, 13, 43, 22, 5, 21, 7, 8, 6, 9, 55, 26, 14, 15, 52, 48, 49, 56, 57, 53, 58, 59, 60, 51, 37, 64, 54, 78, 72, 79, 80, 109, 92, 81, 95, 106, 87, 88, 82, 74, 96, 89, 99, 97, 63, 36, 27, 69, 17, 20, 70, 28]), import.meta.url), () => w(() => import("../nodes/16.DtPc6HJ1.js"), __vite__mapDeps([110, 1, 2, 3, 4, 11, 25, 22, 5, 21, 7, 8, 6, 9, 65, 13, 15, 46, 28, 66, 111]), import.meta.url), () => w(() => import("../nodes/17.aIGv_P3x.js"), __vite__mapDeps([112, 1, 17, 3, 4, 25, 20, 28, 11, 13, 15, 72, 73, 8, 74]), import.meta.url), () => w(() => import("../nodes/18.Cvu8ofJ3.js"), __vite__mapDeps([113, 1, 2, 3, 4, 11, 49, 25, 21, 22, 5, 7, 8, 6, 9, 28, 13, 15, 71, 111]), import.meta.url), () => w(() => import("../nodes/19.Cn2CqAyb.js"), __vite__mapDeps([114, 1, 3, 4, 11, 12, 13, 43, 14, 22, 2, 5, 6, 7, 8, 9, 45, 15, 46, 47, 48, 49, 50, 79, 53, 67, 51]), import.meta.url), () => w(() => import("../nodes/20.Csw6SLm6.js"), __vite__mapDeps([115, 1, 3, 4, 11, 12, 25, 13, 28, 15]), import.meta.url), () => w(() => import("../nodes/21.ChTa7_IY.js"), __vite__mapDeps([116, 1, 17, 3, 25, 28, 11, 13, 15, 117]), import.meta.url), () => w(() => import("../nodes/22.B_8IH7OC.js"), __vite__mapDeps([118, 1, 17, 3, 25, 28, 11, 13, 15]), import.meta.url), () => w(() => import("../nodes/23.DaDtOaNx.js"), __vite__mapDeps([119, 1, 17, 3, 25, 28, 11, 13, 15]), import.meta.url), () => w(() => import("../nodes/24.B0d7XhOa.js"), __vite__mapDeps([120, 1, 3, 4, 11, 12, 25, 13, 28, 15]), import.meta.url), () => w(() => import("../nodes/25.DBUrYUdP.js"), __vite__mapDeps([121, 1, 3, 4, 11, 12, 25, 13, 28, 15]), import.meta.url), () => w(() => import("../nodes/26.D9xkntej.js"), __vite__mapDeps([122, 1, 2, 3, 4, 11, 24, 12, 25, 13, 26, 14, 22, 5, 21, 7, 8, 6, 9, 27, 48, 49, 69, 17, 20, 15, 70, 28, 47, 64, 56, 54, 78, 72, 109, 102, 74, 83, 41, 59, 97, 51, 62]), import.meta.url), () => w(() => import("../nodes/27.UJoS7atv.js"), __vite__mapDeps([123, 1, 2, 3, 4, 11, 49, 25, 22, 5, 65, 13, 15, 6, 46, 8, 28, 66, 111]), import.meta.url)],
  sl = [],
  al = {
    "/": [4],
    "/404": [5],
    "/appeals": [6],
    "/dashboard/alliances": [7, [2]],
    "/dashboard/audit-logs": [8, [2]],
    "/dashboard/ban-waves": [9, [2]],
    "/dashboard/permissions": [10, [2]],
    "/dashboard/summary": [11, [2]],
    "/dashboard/team": [12, [2, 3]],
    "/dashboard/team/leaderboard-reports": [13, [2, 3]],
    "/dashboard/team/leaderboard-tickets": [14, [2, 3]],
    "/dashboard/users": [15, [2]],
    "/join": [16],
    "/offline": [17],
    "/payment/success": [18],
    "/profile-picture": [19],
    "/terms/code-of-conduct": [20],
    "/terms/privacy": [21],
    "/terms/return": [22],
    "/terms/return/pt": [23],
    "/terms/terms-of-service": [24],
    "/terms/terms-of-service/pt": [25],
    "/tickets": [26],
    "/twitch-migration": [27]
  },
  fa = {
    handleError: Hf || (({
      error: t
    }) => {
      console.error(t)
    }),
    init: void 0,
    reroute: (() => {}),
    transport: {}
  },
  qf = Object.fromEntries(Object.entries(fa.transport).map(([t, e]) => [t, e.decode])),
  ol = Object.fromEntries(Object.entries(fa.transport).map(([t, e]) => [t, e.encode])),
  il = !1,
  cl = (t, e) => qf[t](e);
export {
  cl as decode, qf as decoders, al as dictionary, ol as encoders, il as hash, fa as hooks, tl as matchers, rl as nodes, nl as root, sl as server_loads
};