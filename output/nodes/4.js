var jb = Object.defineProperty;
var Fb = Object.getPrototypeOf;
var Bb = Reflect.get;
var dv = d => {
  throw TypeError(d)
};
var Ob = (d, s, r) => s in d ? jb(d, s, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: r
}) : d[s] = r;
var vn = (d, s, r) => Ob(d, typeof s != "symbol" ? s + "" : s, r),
  Xf = (d, s, r) => s.has(d) || dv("Cannot " + r);
var tr = (d, s, r) => (Xf(d, s, "read from private field"), r ? r.call(d) : s.get(d)),
  yn = (d, s, r) => s.has(d) ? dv("Cannot add the same private member more than once") : s instanceof WeakSet ? s.add(d) : s.set(d, r),
  _a = (d, s, r, x) => (Xf(d, s, "write to private field"), x ? x.call(d, r) : s.set(d, r), r),
  on = (d, s, r) => (Xf(d, s, "access private method"), r);
var pv = (d, s, r) => Bb(Fb(d), r, s);
import "../chunks/B4ChKoOX.js";
import {
  o as Wi,
  a as qb,
  s as Ei
} from "../chunks/CpOIMieA.js";
import {
  a9 as Nb,
  bm as Vb,
  bB as Ub,
  bo as Zb,
  F as c0,
  x as ma,
  bC as Gb,
  aX as $b,
  bD as Wb,
  e as We,
  bE as fv,
  a7 as Hb,
  j as g,
  i as G,
  a_ as Xu,
  o as $r,
  b as O,
  p as Qr,
  a6 as ea,
  bF as Yf,
  bG as Xb,
  f as se,
  as as Pn,
  bx as Vs,
  a as Pt,
  d as S,
  r as P,
  s as L,
  n as bn,
  c as en,
  t as ze,
  h as Ir,
  bH as _v,
  H as Yb,
  bI as Kb,
  aR as vi,
  g as Pi,
  ar as Yn,
  u as xt,
  K as rn,
  bz as xp,
  J as X_,
  aD as Jb,
  aC as mv,
  aE as Qb,
  w as Y_,
  bJ as _s,
  aY as Qa,
  bK as u0,
  $ as e1
} from "../chunks/I4j7of_K.js";
import {
  s as ee,
  c as h0
} from "../chunks/C0iZJtfJ.js";
import {
  i as we
} from "../chunks/DfRO1b1n.js";
import {
  h as t1
} from "../chunks/ClLSv-PP.js";
import {
  b as Dr,
  a as Or,
  s as or,
  f as Io,
  r as sa,
  g as K_,
  e as r1,
  d as Li,
  i as sp,
  c as Us,
  h as gv
} from "../chunks/BhOu8MeW.js";
import {
  a as vl,
  t as oa
} from "../chunks/CdBYQkH9.js";
import {
  g as bp,
  b as n1
} from "../chunks/f60V-VlV.js";
import {
  p as xi
} from "../chunks/CfKXZ5Ln.js";
import {
  g as $i,
  P as i1,
  b as d0
} from "../chunks/NRQqekWX.js";
import {
  a as Ia,
  u as Rt,
  t as rr,
  b as pn,
  r as qo,
  v as a1,
  w as o1,
  x as s1,
  y as l1,
  f as c1,
  m as u1,
  c as h1,
  z as d1,
  C as vv,
  P as Kf,
  A as p1
} from "../chunks/CBmzf2X6.js";
import {
  A as gi,
  p as J_,
  c as u_,
  g as Jf,
  a as f1
} from "../chunks/DFzSdYg6.js";
import {
  P as Fi
} from "../chunks/DDo5Atus.js";
import "../chunks/CmLGfQ7b.js";
import {
  e as li,
  i as Bc
} from "../chunks/hM79ghPV.js";
import {
  a as wp,
  b as Oc,
  c as Q_
} from "../chunks/CjZxZnEs.js";
import {
  b as oo
} from "../chunks/OfzC1c_w.js";
import {
  i as em
} from "../chunks/Bh4ptAM3.js";
import {
  r as Lr,
  p as sr,
  s as qc,
  u as yv
} from "../chunks/GI-gjqpA.js";
import {
  C as ms,
  S as _1,
  U as m1,
  a as g1,
  r as v1
} from "../chunks/BPpKeVRd.js";
import {
  U as y1,
  A as p0,
  D as f0,
  a as Rp,
  I as h_,
  e as x1,
  r as b1,
  p as w1,
  c as k1,
  P as _0,
  b as T1
} from "../chunks/Xnl3bQ0s.js";
import {
  c as kp,
  b as m0,
  g as ta,
  a as jp
} from "../chunks/DuGiU6r3.js";
import {
  h as Fp
} from "../chunks/CuwIxQrF.js";
import {
  L as g0
} from "../chunks/BjhdGn2O.js";
import {
  g as Se,
  l as P1
} from "../chunks/JcMV53SJ.js";
import {
  c as Nc
} from "../chunks/g2b7u76f.js";
import {
  d as S1,
  L as wl,
  p as tm
} from "../chunks/RwGaOBj4.js";
import {
  j as d_,
  E as p_,
  k as Bp,
  D as rm,
  d as kc,
  f as M1,
  g as xv,
  W as I1,
  s as C1,
  i as A1,
  l as v0,
  b as z1,
  c as E1,
  h as L1,
  r as D1,
  t as R1,
  n as j1,
  o as F1,
  m as bv,
  a as B1,
  p as O1,
  R as q1,
  u as N1,
  q as wv
} from "../chunks/DT1SGNG2.js";
import {
  P as Fa,
  t as V1
} from "../chunks/DImBJHQM.js";
import {
  l as U1,
  v as lp,
  a as y0,
  s as x0
} from "../chunks/CHn4iONF.js";
import {
  p as nm,
  m as b0
} from "../chunks/CRXPhtJU.js";
import {
  f as yl
} from "../chunks/CCNv4epn.js";
import {
  k as kl
} from "../chunks/1Wq73AqV.js";
import {
  A as w0,
  c as Ja
} from "../chunks/BHhbwSKr.js";
import {
  b as im
} from "../chunks/9xXTz8hp.js";
import {
  u as Z1
} from "../chunks/pjMUUqN6.js";
import {
  u as G1
} from "../chunks/9JiFNft0.js";
import {
  l as am
} from "../chunks/IDsxQrjb.js";
import {
  f as Ka,
  a as $1,
  s as cp
} from "../chunks/CNS-79Ys.js";
import {
  C as om
} from "../chunks/kcmbNJnh.js";
import {
  e as W1
} from "../chunks/CWtZRiIw.js";
import {
  L as k0
} from "../chunks/TS-OoBFm.js";
import {
  t as H1,
  r as T0,
  g as X1
} from "../chunks/CsY2i36d.js";
import {
  c as ka
} from "../chunks/Cf6XykBD.js";
import {
  a as P0
} from "../chunks/CjhgrfX5.js";
import {
  L as Y1
} from "../chunks/DFzNGT2v.js";
import {
  b as K1
} from "../chunks/bNRYOhS3.js";
import {
  c as S0
} from "../chunks/CzuEwGsd.js";
import {
  e as J1
} from "../chunks/C_ULqMki.js";
import {
  a as Q1
} from "../chunks/D7yX_d_X.js";
import {
  d as e2
} from "../chunks/DhFlkwhj.js";
import {
  R as M0
} from "../chunks/DXSh4Hl8.js";
import {
  T as nh,
  G as Tp,
  c as t2
} from "../chunks/f5m17HE7.js";
import {
  t as I0
} from "../chunks/Dr0lwnOn.js";
import {
  C as r2
} from "../chunks/DTptgrTQ.js";
import {
  R as n2
} from "../chunks/BrGtCPJ3.js";
import {
  W as i2
} from "../chunks/dmeecx2k.js";
import {
  r as a2
} from "../chunks/MCYJYFdJ.js";
(function() {
  try {
    var d = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
    d.SENTRY_RELEASE = {
      id: "5f26df466977fd01d18eb1a4a8743e0ce83f1b4f"
    }
  } catch {}
})();
try {
  (function() {
    var d = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {},
      s = new d.Error().stack;
    s && (d._sentryDebugIds = d._sentryDebugIds || {}, d._sentryDebugIds[s] = "d362b9bc-8ef8-417f-9175-4ea261a71964", d._sentryDebugIdIdentifier = "sentry-dbid-d362b9bc-8ef8-417f-9175-4ea261a71964")
  })()
} catch {}
const o2 = [];

function s2(d, s = !1, r = !1) {
  return up(d, new Map, "", o2, null, r)
}

function up(d, s, r, x, A = null, E = !1) {
  if (typeof d == "object" && d !== null) {
    var k = s.get(d);
    if (k !== void 0) return k;
    if (d instanceof Map) return new Map(d);
    if (d instanceof Set) return new Set(d);
    if (Nb(d)) {
      var l = Array(d.length);
      s.set(d, l), A !== null && s.set(A, l);
      for (var j = 0; j < d.length; j += 1) {
        var W = d[j];
        j in d && (l[j] = up(W, s, r, x, null, E))
      }
      return l
    }
    if (Vb(d) === Ub) {
      l = {}, s.set(d, l), A !== null && s.set(A, l);
      for (var $ in d) l[$] = up(d[$], s, r, x, null, E);
      return l
    }
    if (d instanceof Date) return structuredClone(d);
    if (typeof d.toJSON == "function" && !E) return up(d.toJSON(), s, r, x, d)
  }
  if (d instanceof EventTarget) return d;
  try {
    return structuredClone(d)
  } catch {
    return d
  }
}

function l2() {
  return Symbol(Zb)
}
var Os, zc, sh, Ap, C0;
const zp = class zp {
  constructor(s) {
    yn(this, Ap);
    yn(this, Os, new WeakMap);
    yn(this, zc);
    yn(this, sh);
    _a(this, sh, s)
  }
  observe(s, r) {
    var x = tr(this, Os).get(s) || new Set;
    return x.add(r), tr(this, Os).set(s, x), on(this, Ap, C0).call(this).observe(s, tr(this, sh)), () => {
      var A = tr(this, Os).get(s);
      A.delete(r), A.size === 0 && (tr(this, Os).delete(s), tr(this, zc).unobserve(s))
    }
  }
};
Os = new WeakMap, zc = new WeakMap, sh = new WeakMap, Ap = new WeakSet, C0 = function() {
  return tr(this, zc) ?? _a(this, zc, new ResizeObserver(s => {
    for (var r of s) {
      zp.entries.set(r.target, r);
      for (var x of tr(this, Os).get(r.target) || []) x(r)
    }
  }))
}, vn(zp, "entries", new WeakMap);
let f_ = zp;
var c2 = new f_({
  box: "border-box"
});

function u2(d, s, r) {
  var x = c2.observe(d, () => r(d[s]));
  c0(() => (ma(() => r(d[s])), x))
}

function Fh(d, s) {
  Gb(window, ["resize"], () => $b(() => s(window[d])))
}

function h2(d) {
  return function(...s) {
    var r = s[0];
    return r.preventDefault(), d == null ? void 0 : d.apply(this, s)
  }
}
const d2 = Wb;
var Bo, Oo, ds, Ep, Mo, Ju, hp;
const km = class km extends Map {
  constructor(r) {
    super();
    yn(this, Mo);
    yn(this, Bo, new Map);
    yn(this, Oo, We(0));
    yn(this, ds, We(0));
    yn(this, Ep, fv || -1);
    if (r) {
      for (var [x, A] of r) super.set(x, A);
      tr(this, ds).v = super.size
    }
  }
  has(r) {
    var x = tr(this, Bo),
      A = x.get(r);
    if (A === void 0) {
      var E = super.get(r);
      if (E !== void 0) A = on(this, Mo, Ju).call(this, 0), x.set(r, A);
      else return g(tr(this, Oo)), !1
    }
    return g(A), !0
  }
  forEach(r, x) {
    on(this, Mo, hp).call(this), super.forEach(r, x)
  }
  get(r) {
    var x = tr(this, Bo),
      A = x.get(r);
    if (A === void 0) {
      var E = super.get(r);
      if (E !== void 0) A = on(this, Mo, Ju).call(this, 0), x.set(r, A);
      else {
        g(tr(this, Oo));
        return
      }
    }
    return g(A), super.get(r)
  }
  set(r, x) {
    var J;
    var A = tr(this, Bo),
      E = A.get(r),
      k = super.get(r),
      l = super.set(r, x),
      j = tr(this, Oo);
    if (E === void 0) E = on(this, Mo, Ju).call(this, 0), A.set(r, E), G(tr(this, ds), super.size), Xu(j);
    else if (k !== x) {
      Xu(E);
      var W = j.reactions === null ? null : new Set(j.reactions),
        $ = W === null || !((J = E.reactions) != null && J.every(ce => W.has(ce)));
      $ && Xu(j)
    }
    return l
  }
  delete(r) {
    var x = tr(this, Bo),
      A = x.get(r),
      E = super.delete(r);
    return A !== void 0 && (x.delete(r), G(tr(this, ds), super.size), G(A, -1), Xu(tr(this, Oo))), E
  }
  clear() {
    if (super.size !== 0) {
      super.clear();
      var r = tr(this, Bo);
      G(tr(this, ds), 0);
      for (var x of r.values()) G(x, -1);
      Xu(tr(this, Oo)), r.clear()
    }
  }
  keys() {
    return g(tr(this, Oo)), super.keys()
  }
  values() {
    return on(this, Mo, hp).call(this), super.values()
  }
  entries() {
    return on(this, Mo, hp).call(this), super.entries()
  } [Symbol.iterator]() {
    return this.entries()
  }
  get size() {
    return g(tr(this, ds)), super.size
  }
};
Bo = new WeakMap, Oo = new WeakMap, ds = new WeakMap, Ep = new WeakMap, Mo = new WeakSet, Ju = function(r) {
  return fv === tr(this, Ep) ? We(r) : Hb(r)
}, hp = function() {
  g(tr(this, Oo));
  var r = tr(this, Bo);
  if (tr(this, ds).v !== r.size) {
    for (var x of pv(km.prototype, this, "keys").call(this))
      if (!r.has(x)) {
        var A = on(this, Mo, Ju).call(this, 0);
        r.set(x, A)
      }
  }
  for ([, A] of tr(this, Bo)) g(A)
};
let Pp = km;
const p2 = () => "OR",
  f2 = () => "OU",
  _2 = () => "æˆ–",
  m2 = () => "ODER",
  g2 = () => "O",
  v2 = () => "OU",
  y2 = () => "O",
  x2 = () => "ã¾ãŸã¯",
  b2 = () => "LUB",
  w2 = () => "Ğ˜Ğ›Ğ˜",
  k2 = () => "ĞĞ‘Ğ",
  T2 = () => "HOáº¶C",
  P2 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? p2() : r === "pt" ? f2() : r === "ch" ? _2() : r === "de" ? m2() : r === "es" ? g2() : r === "fr" ? v2() : r === "it" ? y2() : r === "jp" ? x2() : r === "pl" ? b2() : r === "ru" ? w2() : r === "uk" ? k2() : T2()
  },
  S2 = () => "SPACE",
  M2 = () => "ESPAÃ‡O",
  I2 = () => "ç©ºæ ¼é”®",
  C2 = () => "LEERTASTE",
  A2 = () => "ESPACIO",
  z2 = () => "ESPACE",
  E2 = () => "SPAZIO",
  L2 = () => "ã‚¹ãƒšãƒ¼ã‚¹",
  D2 = () => "SPACJA",
  R2 = () => "ĞŸĞ ĞĞ‘Ğ•Ğ›",
  j2 = () => "ĞŸĞ ĞĞ‘Ğ†Ğ›",
  F2 = () => "PHÃM CÃCH",
  B2 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? S2() : r === "pt" ? M2() : r === "ch" ? I2() : r === "de" ? C2() : r === "es" ? A2() : r === "fr" ? z2() : r === "it" ? E2() : r === "jp" ? L2() : r === "pl" ? D2() : r === "ru" ? R2() : r === "uk" ? j2() : F2()
  },
  O2 = () => "Account Enforcement Policy and Code of Conduct",
  q2 = () => "PolÃ­tica de AplicaÃ§Ã£o da Conta e CÃ³digo de Conduta",
  N2 = () => "è´¦å·æ‰§è¡Œæ”¿ç­–ä¸è¡Œä¸ºå®ˆåˆ™",
  V2 = () => "Richtlinie zur Kontodurchsetzung und Verhaltenskodex",
  U2 = () => "PolÃ­tica de Cumplimiento de Cuenta y CÃ³digo de Conducta",
  Z2 = () => "Politique dâ€™application du compte et Code de conduite",
  G2 = () => "Norme di applicazione dell'account e Codice di condotta",
  $2 = () => "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆåˆ¶è£ãƒãƒªã‚·ãƒ¼ã¨è¡Œå‹•è¦ç¯„",
  W2 = () => "Polityka egzekwowania zasad konta i kodeks postÄ™powania",
  H2 = () => "ĞŸĞ¾Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑĞ°Ğ½ĞºÑ†Ğ¸Ğ¹ Ğº Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°Ğ¼ Ğ¸ ĞšĞ¾Ğ´ĞµĞºÑ Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ñ",
  X2 = () => "ĞŸĞ¾Ğ»Ñ–Ñ‚Ğ¸ĞºĞ° Ğ·Ğ°ÑÑ‚Ğ¾ÑÑƒĞ²Ğ°Ğ½Ğ½Ñ ÑĞ°Ğ½ĞºÑ†Ñ–Ğ¹ Ğ´Ğ¾ Ğ°ĞºĞ°ÑƒĞ½Ñ‚Ñ–Ğ² Ñ‚Ğ° ĞšĞ¾Ğ´ĞµĞºÑ Ğ¿Ğ¾Ğ²ĞµĞ´Ñ–Ğ½ĞºĞ¸",
  Y2 = () => "ChÃ­nh sÃ¡ch Xá»­ lÃ½ TÃ i khoáº£n vÃ  Quy táº¯c á»¨ng xá»­",
  K2 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? O2() : r === "pt" ? q2() : r === "ch" ? N2() : r === "de" ? V2() : r === "es" ? U2() : r === "fr" ? Z2() : r === "it" ? G2() : r === "jp" ? $2() : r === "pl" ? W2() : r === "ru" ? H2() : r === "uk" ? X2() : Y2()
  },
  J2 = () => "Account successfully deleted",
  Q2 = () => "Conta deletada com sucesso",
  ew = () => "è´¦å·å·²æˆåŠŸåˆ é™¤",
  tw = () => "Konto erfolgreich gelÃ¶scht",
  rw = () => "Cuenta eliminada correctamente",
  nw = () => "Compte supprimÃ© avec succÃ¨s",
  iw = () => "Account eliminato con successo",
  aw = () => "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚",
  ow = () => "Konto zostaÅ‚o pomyÅ›lnie usuniÄ™te",
  sw = () => "ĞĞºĞºĞ°ÑƒĞ½Ñ‚ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½",
  lw = () => "ĞĞ±Ğ»Ñ–ĞºĞ¾Ğ²Ğ¸Ğ¹ Ğ·Ğ°Ğ¿Ğ¸Ñ ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾ Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ¾",
  cw = () => "ÄÃ£ xÃ³a tÃ i khoáº£n thÃ nh cÃ´ng",
  uw = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? J2() : r === "pt" ? Q2() : r === "ch" ? ew() : r === "de" ? tw() : r === "es" ? rw() : r === "fr" ? nw() : r === "it" ? iw() : r === "jp" ? aw() : r === "pl" ? ow() : r === "ru" ? sw() : r === "uk" ? lw() : cw()
  },
  hw = () => "Add a new 16x16 profile picture",
  dw = () => "Adicionar uma nova imagem de perfil 16x16",
  pw = () => "æ·»åŠ æ–°çš„ 16x16 å¤´åƒ",
  fw = () => "Neues 16x16-Profilbild hinzufÃ¼gen",
  _w = () => "AÃ±adir una nueva imagen de perfil 16x16",
  mw = () => "Ajouter une nouvelle image de profil 16x16",
  gw = () => "Aggiungi una nuova immagine del profilo 16x16",
  vw = () => "æ–°ã—ã„16x16ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç”»åƒã‚’è¿½åŠ ã™ã‚‹",
  yw = () => "Dodaj nowy awatar 16x16",
  xw = () => "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ 16x16",
  bw = () => "Ğ”Ğ¾Ğ´Ğ°Ñ‚Ğ¸ Ğ½Ğ¾Ğ²Ğµ Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»Ñ 16x16",
  ww = () => "ThÃªm áº£nh Ä‘áº¡i diá»‡n má»›i 16x16",
  kw = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? hw() : r === "pt" ? dw() : r === "ch" ? pw() : r === "de" ? fw() : r === "es" ? _w() : r === "fr" ? mw() : r === "it" ? gw() : r === "jp" ? vw() : r === "pl" ? yw() : r === "ru" ? xw() : r === "uk" ? bw() : ww()
  },
  Tw = () => "All time",
  Pw = () => "Geral",
  Sw = () => "å…¨éƒ¨æ—¶é—´",
  Mw = () => "Gesamt",
  Iw = () => "Todo el tiempo",
  Cw = () => "Tout le temps",
  Aw = () => "Tutto il tempo",
  zw = () => "å…¨æœŸé–“",
  Ew = () => "CaÅ‚y czas",
  Lw = () => "Ğ—Ğ° Ğ²ÑÑ‘ Ğ²Ñ€ĞµĞ¼Ñ",
  Dw = () => "Ğ—Ğ° Ğ²ĞµÑÑŒ Ñ‡Ğ°Ñ",
  Rw = () => "ToÃ n thá»i gian",
  jw = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Tw() : r === "pt" ? Pw() : r === "ch" ? Sw() : r === "de" ? Mw() : r === "es" ? Iw() : r === "fr" ? Cw() : r === "it" ? Aw() : r === "jp" ? zw() : r === "pl" ? Ew() : r === "ru" ? Lw() : r === "uk" ? Dw() : Rw()
  },
  Fw = () => "Alliance Name",
  Bw = () => "Nome da alianÃ§a",
  Ow = () => "è”ç›Ÿåç§°",
  qw = () => "Allianznamen",
  Nw = () => "Nombre de la alianza",
  Vw = () => "Nom de lâ€™alliance",
  Uw = () => "Nome dell'alleanza",
  Zw = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹å",
  Gw = () => "Nazwa sojuszu",
  $w = () => "ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ°Ğ»ÑŒÑĞ½ÑĞ°",
  Ww = () => "ĞĞ°Ğ·Ğ²Ğ° Ğ°Ğ»ÑŒÑĞ½ÑÑƒ",
  Hw = () => "TÃªn liÃªn minh",
  Xw = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Fw() : r === "pt" ? Bw() : r === "ch" ? Ow() : r === "de" ? qw() : r === "es" ? Nw() : r === "fr" ? Vw() : r === "it" ? Uw() : r === "jp" ? Zw() : r === "pl" ? Gw() : r === "ru" ? $w() : r === "uk" ? Ww() : Hw()
  },
  Yw = d => `+${d.amount} Max. Charges`,
  Kw = d => `+${d.amount} Tinta mÃ¡xima`,
  Jw = d => `+${d.amount} æœ€å¤§å……èƒ½ä¸Šé™`,
  Qw = d => `+${d.amount} maximale Ladungen`,
  e5 = d => `+${d.amount} cargas mÃ¡ximas`,
  t5 = d => `+${d.amount} charges max`,
  r5 = d => `+${d.amount} cariche massime`,
  n5 = d => `æœ€å¤§ãƒãƒ£ãƒ¼ã‚¸ +${d.amount}`,
  i5 = d => `+${d.amount} maks. Å‚adunkÃ³w`,
  a5 = d => `+${d.amount} Ğ¼Ğ°ĞºÑ. Ğ·Ğ°Ñ€ÑĞ´Ğ¾Ğ²`,
  o5 = d => `+${d.amount} Ğ¼Ğ°ĞºÑ. Ğ·Ğ°Ñ€ÑĞ´Ñ–Ğ²`,
  s5 = d => `+${d.amount} lÆ°á»£t tÃ´ tá»‘i Ä‘a`,
  A0 = (d, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Yw(d) : r === "pt" ? Kw(d) : r === "ch" ? Jw(d) : r === "de" ? Qw(d) : r === "es" ? e5(d) : r === "fr" ? t5(d) : r === "it" ? r5(d) : r === "jp" ? n5(d) : r === "pl" ? i5(d) : r === "ru" ? a5(d) : r === "uk" ? o5(d) : s5(d)
  },
  l5 = d => `+${d.amount} Paint Charges`,
  c5 = d => `+${d.amount} Tintas`,
  u5 = d => `+${d.amount} ç»˜åˆ¶å……èƒ½`,
  h5 = d => `+${d.amount} Pixel-Ladungen`,
  d5 = d => `+${d.amount} cargas de pintura`,
  p5 = d => `+${d.amount} charges de peinture`,
  f5 = d => `+${d.amount} cariche di vernice`,
  _5 = d => `ãƒšã‚¤ãƒ³ãƒˆãƒãƒ£ãƒ¼ã‚¸ +${d.amount}`,
  m5 = d => `+${d.amount} Å‚adunkÃ³w malowania`,
  g5 = d => `+${d.amount} Ğ·Ğ°Ñ€ÑĞ´Ğ¾Ğ²`,
  v5 = d => `+${d.amount} Ğ·Ğ°Ñ€ÑĞ´Ñ–Ğ² Ñ„Ğ°Ñ€Ğ±Ğ¸`,
  y5 = d => `+${d.amount} lÆ°á»£t tÃ´`,
  z0 = (d, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? l5(d) : r === "pt" ? c5(d) : r === "ch" ? u5(d) : r === "de" ? h5(d) : r === "es" ? d5(d) : r === "fr" ? p5(d) : r === "it" ? f5(d) : r === "jp" ? _5(d) : r === "pl" ? m5(d) : r === "ru" ? g5(d) : r === "uk" ? v5(d) : y5(d)
  },
  x5 = () => "and move your cursor over the map.",
  b5 = () => "e mova seu cursor sobre o mapa.",
  w5 = () => "ç„¶åæŠŠé¼ æ ‡ç§»åŠ¨åˆ°åœ°å›¾ä¸Šã€‚",
  k5 = () => "gedrÃ¼ckt und bewege deinen Cursor Ã¼ber die Karte.",
  T5 = () => "y mueve el cursor sobre el mapa.",
  P5 = () => "et dÃ©placez votre curseur sur la carte.",
  S5 = () => "e muovi il cursore sopra la mappa.",
  M5 = () => "ãã—ã¦ã€ãƒãƒƒãƒ—ä¸Šã§ã‚«ãƒ¼ã‚½ãƒ«ã‚’å‹•ã‹ã—ã¦ãã ã•ã„ã€‚",
  I5 = () => "i przesuÅ„ kursor po mapie.",
  C5 = () => "Ğ¸ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰Ğ°Ğ¹Ñ‚Ğµ ĞºÑƒÑ€ÑĞ¾Ñ€ Ğ¿Ğ¾ ĞºĞ°Ñ€Ñ‚Ğµ.",
  A5 = () => "Ñ– Ğ¿Ñ€Ğ¾Ğ²ĞµĞ´Ñ–Ñ‚ÑŒ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ¾Ğ¼ Ğ¿Ğ¾ ĞºĞ°Ñ€Ñ‚Ñ–.",
  z5 = () => "vÃ  di chuyá»ƒn con trá» cá»§a báº¡n trÃªn báº£n Ä‘á»“.",
  E5 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? x5() : r === "pt" ? b5() : r === "ch" ? w5() : r === "de" ? k5() : r === "es" ? T5() : r === "fr" ? P5() : r === "it" ? S5() : r === "jp" ? M5() : r === "pl" ? I5() : r === "ru" ? C5() : r === "uk" ? A5() : z5()
  },
  L5 = d => `You can send another appeal in ${d.days} days`,
  D5 = d => `VocÃª pode enviar outro apelo em ${d.days} dias`,
  R5 = d => `ä½ å¯ä»¥åœ¨ ${d.days} å¤©åå†æ¬¡æäº¤ç”³è¯‰`,
  j5 = d => `Du kannst in ${d.days} Tagen erneut Einspruch einlegen`,
  F5 = d => `PodrÃ¡s enviar otra apelaciÃ³n en ${d.days} dÃ­as`,
  B5 = d => `Vous pouvez envoyer un nouveau recours dans ${d.days} jours`,
  O5 = d => `Puoi inviare un altro ricorso tra ${d.days} giorni`,
  q5 = d => `${d.days}æ—¥å¾Œã«ã‚‚ã†ä¸€åº¦ç•°è­°ç”³ç«‹ã¦ã‚’é€ä¿¡ã§ãã¾ã™ã€‚`,
  N5 = d => `MoÅ¼esz wysÅ‚aÄ‡ kolejne odwoÅ‚anie za ${d.days} dni`,
  V5 = d => `Ğ’Ñ‹ ÑĞ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ Ğ°Ğ¿ĞµĞ»Ğ»ÑÑ†Ğ¸Ñ Ñ‡ĞµÑ€ĞµĞ· ${d.days} Ğ´Ğ½.`,
  U5 = d => `Ğ’Ğ¸ Ğ·Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ½Ğ°Ğ´Ñ–ÑĞ»Ğ°Ñ‚Ğ¸ Ñ‰Ğµ Ğ¾Ğ´Ğ½Ñƒ Ğ°Ğ¿ĞµĞ»ÑÑ†Ñ–Ñ Ñ‡ĞµÑ€ĞµĞ· ${d.days} Ğ´Ğ½Ñ–Ğ²`,
  Z5 = d => `Báº¡n cÃ³ thá»ƒ gá»­i khÃ¡ng cÃ¡o khÃ¡c sau ${d.days} ngÃ y`,
  G5 = (d, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? L5(d) : r === "pt" ? D5(d) : r === "ch" ? R5(d) : r === "de" ? j5(d) : r === "es" ? F5(d) : r === "fr" ? B5(d) : r === "it" ? O5(d) : r === "jp" ? q5(d) : r === "pl" ? N5(d) : r === "ru" ? V5(d) : r === "uk" ? U5(d) : Z5(d)
  },
  $5 = () => `If you believe your suspension was a mistake, you can send one appeal <b>every 90 days</b> to have your case reviewed again.

Please note that submitting an appeal <b>does not guarantee that your suspension will be lifted</b>; however, our team will review your situation.

Reviews usually take up to <b>a week</b>.`,
  W5 = () => `Se vocÃª acredita que sua suspensÃ£o foi um erro, vocÃª pode enviar um apelo <b>a cada 90 dias</b> para que seu caso seja revisado novamente.

Por favor, note que enviar um recurso <b>nÃ£o garante que sua suspensÃ£o serÃ¡ removida</b>; no entanto, nossa equipe analisarÃ¡ a sua situaÃ§Ã£o novamente.

As revisÃµes geralmente levam atÃ© <b>uma semana</b>.`,
  H5 = () => `å¦‚æœä½ è®¤ä¸ºä½ çš„å°ç¦æ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œä½ å¯ä»¥æ¯ <b>90 å¤©</b> æäº¤ä¸€æ¬¡ç”³è¯‰ï¼Œä»¥ä¾¿æˆ‘ä»¬é‡æ–°å®¡æ ¸ä½ çš„æƒ…å†µã€‚

è¯·æ³¨æ„ï¼Œæäº¤ç”³è¯‰<b>å¹¶ä¸ä¿è¯</b>ä¼šè§£é™¤å°ç¦ï¼Œä½†æˆ‘ä»¬çš„å›¢é˜Ÿä¼šé‡æ–°å®¡æŸ¥ä½ çš„æƒ…å†µã€‚

å®¡æ ¸é€šå¸¸æœ€å¤šéœ€è¦ <b>ä¸€å‘¨</b> æ—¶é—´ã€‚`,
  X5 = () => `Wenn du glaubst, dass deine Sperre ein Fehler war, kannst du alle <b>90 Tage</b> einen Einspruch einreichen, damit dein Fall erneut geprÃ¼ft wird.

Bitte beachte, dass das Einreichen eines Einspruchs <b>nicht garantiert, dass deine Sperre aufgehoben wird</b>; unser Team wird deine Situation jedoch prÃ¼fen.

ÃœberprÃ¼fungen dauern in der Regel bis zu <b>eine Woche</b>.`,
  Y5 = () => `Si crees que tu suspensiÃ³n fue un error, puedes enviar una apelaciÃ³n <b>cada 90 dÃ­as</b> para que tu caso sea revisado de nuevo.

Ten en cuenta que enviar una apelaciÃ³n <b>no garantiza que se levante la suspensiÃ³n</b>; sin embargo, nuestro equipo revisarÃ¡ tu situaciÃ³n.

Las revisiones suelen tardar hasta <b>una semana</b>.`,
  K5 = () => `Si vous pensez que votre suspension est une erreur, vous pouvez envoyer un recours <b>tous les 90 jours</b> pour que votre cas soit rÃ©examinÃ©.

Veuillez noter que lâ€™envoi dâ€™un recours <b>ne garantit pas que votre suspension sera levÃ©e</b>; cependant, notre Ã©quipe analysera votre situation.

Les analyses prennent gÃ©nÃ©ralement jusquâ€™Ã  <b>une semaine</b>.`,
  J5 = () => `Se ritieni che la tua sospensione sia un errore, puoi inviare un ricorso <b>ogni 90 giorni</b> per far riesaminare il tuo caso.

Tieni presente che l'invio di un ricorso <b>non garantisce che la sospensione venga rimossa</b>; tuttavia, il nostro team analizzerÃ  di nuovo la tua situazione.

Le revisioni solitamente richiedono fino a <b>una settimana</b>.`,
  Q5 = () => `åœæ­¢ãŒèª¤ã‚Šã ã¨æ€ã†å ´åˆã¯ã€<b>90æ—¥ã”ã¨ã«1å›</b>ç•°è­°ç”³ç«‹ã¦ã‚’é€ä¿¡ã—ã€å†å¯©æŸ»ã‚’ä¾é ¼ã§ãã¾ã™ã€‚

ãŸã ã—ã€ç•°è­°ç”³ç«‹ã¦ã‚’è¡Œã£ã¦ã‚‚<b>å¿…ãšã—ã‚‚åœæ­¢ãŒè§£é™¤ã•ã‚Œã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“</b>ã€‚ãƒãƒ¼ãƒ ãŒçŠ¶æ³ã‚’ç¢ºèªã—ã¾ã™ã€‚

å¯©æŸ»ã«ã¯é€šå¸¸<b>æœ€å¤§1é€±é–“</b>ã‹ã‹ã‚Šã¾ã™ã€‚`,
  e3 = () => `JeÅ›li uwaÅ¼asz, Å¼e Twoje zawieszenie jest bÅ‚Ä™dem, moÅ¼esz wysÅ‚aÄ‡ jedno odwoÅ‚anie <b>co 90 dni</b>, aby ponownie rozpatrzyÄ‡ TwojÄ… sprawÄ™.

PamiÄ™taj, Å¼e wysÅ‚anie odwoÅ‚ania <b>nie gwarantuje, Å¼e zawieszenie zostanie zniesione</b>; nasz zespÃ³Å‚ ponownie przeanalizuje jednak TwojÄ… sytuacjÄ™.

Rozpatrywanie zwykle trwa do <b>tygodnia</b>.`,
  t3 = () => `Ğ•ÑĞ»Ğ¸ Ğ²Ñ‹ ÑÑ‡Ğ¸Ñ‚Ğ°ĞµÑ‚Ğµ, Ñ‡Ñ‚Ğ¾ Ğ²Ğ°ÑˆĞ° Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ±Ñ‹Ğ»Ğ° Ğ²Ñ‹Ğ½ĞµÑĞµĞ½Ğ° Ğ¿Ğ¾ Ğ¾ÑˆĞ¸Ğ±ĞºĞµ, Ğ²Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ°Ğ¿ĞµĞ»Ğ»ÑÑ†Ğ¸Ñ <b>Ñ€Ğ°Ğ· Ğ² 90 Ğ´Ğ½ĞµĞ¹</b>, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ğ°Ñˆ ÑĞ»ÑƒÑ‡Ğ°Ğ¹ Ğ±Ñ‹Ğ» Ğ¿ĞµÑ€ĞµÑĞ¼Ğ¾Ñ‚Ñ€ĞµĞ½.

ĞĞ±Ñ€Ğ°Ñ‚Ğ¸Ñ‚Ğµ Ğ²Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾Ğ´Ğ°Ñ‡Ğ° Ğ°Ğ¿ĞµĞ»Ğ»ÑÑ†Ğ¸Ğ¸ <b>Ğ½Ğµ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑĞ½ÑÑ‚Ğ¸Ğµ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸</b>, Ğ¾Ğ´Ğ½Ğ°ĞºĞ¾ Ğ½Ğ°ÑˆĞ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ· Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ğ²Ğ°ÑˆÑƒ ÑĞ¸Ñ‚ÑƒĞ°Ñ†Ğ¸Ñ.

ĞĞ±Ñ‹Ñ‡Ğ½Ğ¾ Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ Ğ´Ğ¾ <b>Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ½ĞµĞ´ĞµĞ»Ğ¸</b>.`,
  r3 = () => `Ğ¯ĞºÑ‰Ğ¾ Ğ²Ğ¸ Ğ²Ğ²Ğ°Ğ¶Ğ°Ñ”Ñ‚Ğµ, Ñ‰Ğ¾ Ğ²Ğ°ÑˆÑƒ Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ±ÑƒĞ»Ğ¾ Ğ·Ğ´Ñ–Ğ¹ÑĞ½ĞµĞ½Ğ¾ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ¾Ğ²Ğ¾, Ğ²Ğ¸ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ½Ğ°Ğ´ÑĞ¸Ğ»Ğ°Ñ‚Ğ¸ Ğ°Ğ¿ĞµĞ»ÑÑ†Ñ–Ñ <b>Ñ€Ğ°Ğ· Ğ½Ğ° 90 Ğ´Ğ½Ñ–Ğ²</b>, Ñ‰Ğ¾Ğ± Ğ¼Ğ¸ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¾ Ñ€Ğ¾Ğ·Ğ³Ğ»ÑĞ½ÑƒĞ»Ğ¸ Ğ²Ğ°Ñˆ Ğ²Ğ¸Ğ¿Ğ°Ğ´Ğ¾Ğº.

Ğ—Ğ²ĞµÑ€Ğ½Ñ–Ñ‚ÑŒ ÑƒĞ²Ğ°Ğ³Ñƒ, Ñ‰Ğ¾ Ğ½Ğ°Ğ´ÑĞ¸Ğ»Ğ°Ğ½Ğ½Ñ Ğ°Ğ¿ĞµĞ»ÑÑ†Ñ–Ñ— <b>Ğ½Ğµ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚ÑƒÑ” Ğ·Ğ½ÑÑ‚Ñ‚Ñ Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ğ½Ğ½Ñ</b>, Ğ¾Ğ´Ğ½Ğ°Ğº Ğ½Ğ°ÑˆĞ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ğ¿ĞµÑ€ĞµĞ³Ğ»ÑĞ½Ğµ Ğ²Ğ°ÑˆÑƒ ÑĞ¸Ñ‚ÑƒĞ°Ñ†Ñ–Ñ.

Ğ—Ğ°Ğ·Ğ²Ğ¸Ñ‡Ğ°Ğ¹ Ñ€Ğ¾Ğ·Ğ³Ğ»ÑĞ´ Ğ·Ğ°Ğ¹Ğ¼Ğ°Ñ” Ğ´Ğ¾ <b>Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¶Ğ½Ñ</b>.`,
  n3 = () => `Náº¿u báº¡n tin ráº±ng viá»‡c Ä‘Ã¬nh chá»‰ tÃ i khoáº£n lÃ  má»™t sai sÃ³t, báº¡n cÃ³ thá»ƒ gá»­i má»™t khÃ¡ng cÃ¡o <b>má»—i 90 ngÃ y</b> Ä‘á»ƒ yÃªu cáº§u xem xÃ©t láº¡i.

LÆ°u Ã½ ráº±ng gá»­i khÃ¡ng cÃ¡o <b>khÃ´ng Ä‘áº£m báº£o tÃ i khoáº£n cá»§a báº¡n sáº½ Ä‘Æ°á»£c má»Ÿ khÃ³a</b>; tuy nhiÃªn Ä‘á»™i ngÅ© cá»§a chÃºng tÃ´i sáº½ xem xÃ©t láº¡i trÆ°á»ng há»£p cá»§a báº¡n.

Viá»‡c xem xÃ©t thÆ°á»ng máº¥t Ä‘áº¿n <b>má»™t tuáº§n</b>.`,
  i3 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? $5() : r === "pt" ? W5() : r === "ch" ? H5() : r === "de" ? X5() : r === "es" ? Y5() : r === "fr" ? K5() : r === "it" ? J5() : r === "jp" ? Q5() : r === "pl" ? e3() : r === "ru" ? t3() : r === "uk" ? r3() : n3()
  },
  a3 = () => "Why your suspension should be lifted?",
  o3 = () => "Por que sua suspensÃ£o deve ser reconsiderada?",
  s3 = () => "ä¸ºä»€ä¹ˆåº”è¯¥è§£é™¤ä½ çš„å°ç¦ï¼Ÿ",
  l3 = () => "Warum sollte deine Sperre aufgehoben werden?",
  c3 = () => "Â¿Por quÃ© deberÃ­a levantarse tu suspensiÃ³n?",
  u3 = () => "Pourquoi votre suspension devrait-elle Ãªtre levÃ©e ?",
  h3 = () => "PerchÃ© la tua sospensione dovrebbe essere rivalutata?",
  d3 = () => "ãªãœåœæ­¢ã‚’è§£é™¤ã™ã¹ãã ã¨æ€ã†ã®ã‹æ•™ãˆã¦ãã ã•ã„ã€‚",
  p3 = () => "Dlaczego Twoje zawieszenie powinno zostaÄ‡ cofniÄ™te?",
  f3 = () => "ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ, Ğ¿Ğ¾ Ğ²Ğ°ÑˆĞµĞ¼Ñƒ Ğ¼Ğ½ĞµĞ½Ğ¸Ñ, Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ ÑĞ½ÑÑ‚Ğ°?",
  _3 = () => "Ğ§Ğ¾Ğ¼Ñƒ, Ğ½Ğ° Ğ²Ğ°ÑˆÑƒ Ğ´ÑƒĞ¼ĞºÑƒ, Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¼Ğ°Ñ” Ğ±ÑƒÑ‚Ğ¸ ÑĞºĞ°ÑĞ¾Ğ²Ğ°Ğ½Ğ¾?",
  m3 = () => "VÃ¬ sao viá»‡c Ä‘Ã¬nh chá»‰ tÃ i khoáº£n cá»§a báº¡n nÃªn Ä‘Æ°á»£c gá»¡ bá»?",
  g3 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? a3() : r === "pt" ? o3() : r === "ch" ? s3() : r === "de" ? l3() : r === "es" ? c3() : r === "fr" ? u3() : r === "it" ? h3() : r === "jp" ? d3() : r === "pl" ? p3() : r === "ru" ? f3() : r === "uk" ? _3() : m3()
  },
  v3 = () => "Tell us why you think your suspension should be reconsidered",
  y3 = () => "Explique por que vocÃª acha que sua suspensÃ£o deve ser reconsiderada",
  x3 = () => "å‘Šè¯‰æˆ‘ä»¬ä½ è®¤ä¸ºå°ç¦åº”è¢«é‡æ–°è€ƒè™‘çš„åŸå› ",
  b3 = () => "ErklÃ¤re uns, warum deine Sperre deiner Meinung nach Ã¼berprÃ¼ft werden sollte",
  w3 = () => "CuÃ©ntanos por quÃ© crees que tu suspensiÃ³n deberÃ­a ser reconsiderada",
  k3 = () => "Expliquez-nous pourquoi vous pensez que votre suspension devrait Ãªtre reconsidÃ©rÃ©e",
  T3 = () => "Spiega perchÃ© ritieni che la tua sospensione dovrebbe essere rivista",
  P3 = () => "åœæ­¢ã‚’å†æ¤œè¨ã™ã¹ãã ã¨æ€ã†ç†ç”±ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
  S3 = () => "WyjaÅ›nij, dlaczego Twoje zawieszenie powinno zostaÄ‡ ponownie rozwaÅ¼one",
  M3 = () => "Ğ Ğ°ÑÑĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ, Ğ¿Ğ¾Ñ‡ĞµĞ¼Ñƒ Ğ²Ñ‹ ÑÑ‡Ğ¸Ñ‚Ğ°ĞµÑ‚Ğµ, Ñ‡Ñ‚Ğ¾ Ğ²Ğ°ÑˆÑƒ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºÑƒ ÑÑ‚Ğ¾Ğ¸Ñ‚ Ğ¿ĞµÑ€ĞµÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ",
  I3 = () => "ĞĞ¿Ğ¸ÑˆÑ–Ñ‚ÑŒ, Ñ‡Ğ¾Ğ¼Ñƒ Ğ²Ğ¸ Ğ²Ğ²Ğ°Ğ¶Ğ°Ñ”Ñ‚Ğµ, Ñ‰Ğ¾ Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ğ½Ğ½Ñ ÑĞ»Ñ–Ğ´ Ğ¿ĞµÑ€ĞµĞ³Ğ»ÑĞ½ÑƒÑ‚Ğ¸",
  C3 = () => "HÃ£y cho chÃºng tÃ´i biáº¿t vÃ¬ sao báº¡n nghÄ© viá»‡c Ä‘Ã¬nh chá»‰ tÃ i khoáº£n nÃªn Ä‘Æ°á»£c xem xÃ©t láº¡i",
  A3 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? v3() : r === "pt" ? y3() : r === "ch" ? x3() : r === "de" ? b3() : r === "es" ? w3() : r === "fr" ? k3() : r === "it" ? T3() : r === "jp" ? P3() : r === "pl" ? S3() : r === "ru" ? M3() : r === "uk" ? I3() : C3()
  },
  z3 = () => "Appeal sent successfully",
  E3 = () => "Apelo enviado com sucesso",
  L3 = () => "ç”³è¯‰å·²æˆåŠŸå‘é€",
  D3 = () => "Einspruch erfolgreich gesendet",
  R3 = () => "ApelaciÃ³n enviada correctamente",
  j3 = () => "Recours envoyÃ© avec succÃ¨s",
  F3 = () => "Ricorso inviato con successo",
  B3 = () => "ç•°è­°ç”³ç«‹ã¦ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚",
  O3 = () => "OdwoÅ‚anie zostaÅ‚o pomyÅ›lnie wysÅ‚ane",
  q3 = () => "ĞĞ¿ĞµĞ»Ğ»ÑÑ†Ğ¸Ñ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ°",
  N3 = () => "ĞĞ¿ĞµĞ»ÑÑ†Ñ–Ñ ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾ Ğ½Ğ°Ğ´Ñ–ÑĞ»Ğ°Ğ½Ğ¾",
  V3 = () => "ÄÃ£ gá»­i khÃ¡ng cÃ¡o thÃ nh cÃ´ng",
  U3 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? z3() : r === "pt" ? E3() : r === "ch" ? L3() : r === "de" ? D3() : r === "es" ? R3() : r === "fr" ? j3() : r === "it" ? F3() : r === "jp" ? B3() : r === "pl" ? O3() : r === "ru" ? q3() : r === "uk" ? N3() : V3()
  },
  Z3 = () => "Are you absolutely sure?",
  G3 = () => "VocÃª tem certeza absoluta?",
  $3 = () => "ä½ ç¡®å®šå—ï¼Ÿ",
  W3 = () => "Bist du dir absolut sicher?",
  H3 = () => "Â¿EstÃ¡s absolutamente seguro?",
  X3 = () => "ÃŠtes-vous absolument sÃ»r ?",
  Y3 = () => "Sei assolutamente sicuro?",
  K3 = () => "æœ¬å½“ã«å®Ÿè¡Œã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
  J3 = () => "Czy na pewno chcesz to zrobiÄ‡?",
  Q3 = () => "Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹?",
  ek = () => "Ğ’Ğ¸ Ğ°Ğ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ğ¾ Ğ²Ğ¿ĞµĞ²Ğ½ĞµĞ½Ñ–?",
  tk = () => "Báº¡n cÃ³ thá»±c sá»± cháº¯c cháº¯n?",
  rk = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Z3() : r === "pt" ? G3() : r === "ch" ? $3() : r === "de" ? W3() : r === "es" ? H3() : r === "fr" ? X3() : r === "it" ? Y3() : r === "jp" ? K3() : r === "pl" ? J3() : r === "ru" ? Q3() : r === "uk" ? ek() : tk()
  },
  nk = () => "Ban from alliance",
  ik = () => "Banir da alianÃ§a",
  ak = () => "ä»è”ç›Ÿä¸­å°ç¦",
  ok = () => "Aus Allianz bannen",
  sk = () => "Banear de la alianza",
  lk = () => "Bannir de lâ€™alliance",
  ck = () => "Banna dall'alleanza",
  uk = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‹ã‚‰BAN",
  hk = () => "Zbanuj z sojuszu",
  dk = () => "Ğ—Ğ°Ğ±Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ² Ğ°Ğ»ÑŒÑĞ½ÑĞµ",
  pk = () => "Ğ—Ğ°Ğ±Ğ°Ğ½Ğ¸Ñ‚Ğ¸ Ğ² Ğ°Ğ»ÑŒÑĞ½ÑÑ–",
  fk = () => "Cáº¥m khá»i liÃªn minh",
  E0 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? nk() : r === "pt" ? ik() : r === "ch" ? ak() : r === "de" ? ok() : r === "es" ? sk() : r === "fr" ? lk() : r === "it" ? ck() : r === "jp" ? uk() : r === "pl" ? hk() : r === "ru" ? dk() : r === "uk" ? pk() : fk()
  },
  _k = d => `Reason: ${d.reason}`,
  mk = d => `Motivo: ${d.reason}`,
  gk = d => `åŸå› ï¼š${d.reason}`,
  vk = d => `Grund: ${d.reason}`,
  yk = d => `Motivo: ${d.reason}`,
  xk = d => `Raison : ${d.reason}`,
  bk = d => `Motivo: ${d.reason}`,
  wk = d => `ç†ç”±: ${d.reason}`,
  kk = d => `PowÃ³d: ${d.reason}`,
  Tk = d => `ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: ${d.reason}`,
  Pk = d => `ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: ${d.reason}`,
  Sk = d => `LÃ½ do: ${d.reason}`,
  kv = (d, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? _k(d) : r === "pt" ? mk(d) : r === "ch" ? gk(d) : r === "de" ? vk(d) : r === "es" ? yk(d) : r === "fr" ? xk(d) : r === "it" ? bk(d) : r === "jp" ? wk(d) : r === "pl" ? kk(d) : r === "ru" ? Tk(d) : r === "uk" ? Pk(d) : Sk(d)
  },
  Mk = () => "Bug report",
  Ik = () => "Reportar bug",
  Ck = () => "é”™è¯¯æŠ¥å‘Š",
  Ak = () => "Bug melden",
  zk = () => "Reporte de bug",
  Ek = () => "Signaler un bug",
  Lk = () => "Segnala bug",
  Dk = () => "ãƒã‚°å ±å‘Š",
  Rk = () => "ZgÅ‚oszenie bÅ‚Ä™du",
  jk = () => "Ğ¡Ğ¾Ğ¾Ğ±Ñ‰Ğ¸Ñ‚ÑŒ Ğ¾Ğ± Ğ¾ÑˆĞ¸Ğ±ĞºĞµ",
  Fk = () => "Ğ—Ğ²Ñ–Ñ‚ Ğ¿Ñ€Ğ¾ Ğ±Ğ°Ğ³",
  Bk = () => "BÃ¡o lá»—i",
  Ok = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Mk() : r === "pt" ? Ik() : r === "ch" ? Ck() : r === "de" ? Ak() : r === "es" ? zk() : r === "fr" ? Ek() : r === "it" ? Lk() : r === "jp" ? Dk() : r === "pl" ? Rk() : r === "ru" ? jk() : r === "uk" ? Fk() : Bk()
  },
  qk = () => "Change language",
  Nk = () => "Mudar idioma",
  Vk = () => "æ›´æ”¹è¯­è¨€",
  Uk = () => "Sprache Ã¤ndern",
  Zk = () => "Cambiar idioma",
  Gk = () => "Changer de langue",
  $k = () => "Cambia lingua",
  Wk = () => "è¨€èªã‚’å¤‰æ›´",
  Hk = () => "ZmieÅ„ jÄ™zyk",
  Xk = () => "Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹Ğº",
  Yk = () => "Ğ—Ğ¼Ñ–Ğ½Ğ¸Ñ‚Ğ¸ Ğ¼Ğ¾Ğ²Ñƒ",
  Kk = () => "Thay Ä‘á»•i ngÃ´n ngá»¯",
  Jk = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? qk() : r === "pt" ? Nk() : r === "ch" ? Vk() : r === "de" ? Uk() : r === "es" ? Zk() : r === "fr" ? Gk() : r === "it" ? $k() : r === "jp" ? Wk() : r === "pl" ? Hk() : r === "ru" ? Xk() : r === "uk" ? Yk() : Kk()
  },
  Qk = () => "Change picture:",
  eT = () => "Trocar imagem:",
  tT = () => "æ›´æ¢å¤´åƒï¼š",
  rT = () => "Bild Ã¤ndern:",
  nT = () => "Cambiar imagen:",
  iT = () => "Changer lâ€™image :",
  aT = () => "Cambia immagine:",
  oT = () => "ç”»åƒã‚’å¤‰æ›´:",
  sT = () => "ZmieÅ„ obraz:",
  lT = () => "Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ:",
  cT = () => "Ğ—Ğ¼Ñ–Ğ½Ğ¸Ñ‚Ğ¸ Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ:",
  uT = () => "Äá»•i áº£nh:",
  hT = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Qk() : r === "pt" ? eT() : r === "ch" ? tT() : r === "de" ? rT() : r === "es" ? nT() : r === "fr" ? iT() : r === "it" ? aT() : r === "jp" ? oT() : r === "pl" ? sT() : r === "ru" ? lT() : r === "uk" ? cT() : uT()
  },
  dT = () => "Claim",
  pT = () => "Resgatar",
  fT = () => "é¢†å–",
  _T = () => "Einsammeln",
  mT = () => "Reclamar",
  gT = () => "RÃ©cupÃ©rer",
  vT = () => "Riscatta",
  yT = () => "å—ã‘å–ã‚‹",
  xT = () => "Odbierz",
  bT = () => "ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ",
  wT = () => "ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ñ‚Ğ¸",
  kT = () => "Nháº­n",
  L0 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? dT() : r === "pt" ? pT() : r === "ch" ? fT() : r === "de" ? _T() : r === "es" ? mT() : r === "fr" ? gT() : r === "it" ? vT() : r === "jp" ? yT() : r === "pl" ? xT() : r === "ru" ? bT() : r === "uk" ? wT() : kT()
  },
  TT = () => "Claimed",
  PT = () => "Resgatado",
  ST = () => "å·²é¢†å–",
  MT = () => "Eingesammelt",
  IT = () => "Reclamado",
  CT = () => "RÃ©cupÃ©rÃ©",
  AT = () => "Riscattato",
  zT = () => "å—ã‘å–ã‚Šæ¸ˆã¿",
  ET = () => "Odebrano",
  LT = () => "ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾",
  DT = () => "ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ¾",
  RT = () => "ÄÃ£ nháº­n",
  jT = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? TT() : r === "pt" ? PT() : r === "ch" ? ST() : r === "de" ? MT() : r === "es" ? IT() : r === "fr" ? CT() : r === "it" ? AT() : r === "jp" ? zT() : r === "pl" ? ET() : r === "ru" ? LT() : r === "uk" ? DT() : RT()
  },
  FT = () => "Click",
  BT = () => "Clique",
  OT = () => "ç‚¹å‡»",
  qT = () => "Klicken",
  NT = () => "Haz clic",
  VT = () => "Cliquez",
  UT = () => "Clicca",
  ZT = () => "ã‚¯ãƒªãƒƒã‚¯",
  GT = () => "Kliknij",
  $T = () => "ĞšĞ»Ğ¸Ğº",
  WT = () => "ĞšĞ»Ğ°Ñ†Ğ½Ñ–Ñ‚ÑŒ",
  HT = () => "Nháº¥p",
  XT = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? FT() : r === "pt" ? BT() : r === "ch" ? OT() : r === "de" ? qT() : r === "es" ? NT() : r === "fr" ? VT() : r === "it" ? UT() : r === "jp" ? ZT() : r === "pl" ? GT() : r === "ru" ? $T() : r === "uk" ? WT() : HT()
  },
  YT = () => "Color Picker",
  KT = () => "Conta Gotas",
  JT = () => "å–è‰²å™¨",
  QT = () => "Farbpipette",
  eP = () => "Selector de color",
  tP = () => "Pipette",
  rP = () => "Contagocce",
  nP = () => "ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼",
  iP = () => "PrÃ³bnik kolorÃ³w",
  aP = () => "ĞŸĞ¸Ğ¿ĞµÑ‚ĞºĞ°",
  oP = () => "ĞŸÑ–Ğ¿ĞµÑ‚ĞºĞ°",
  sP = () => "Báº£ng chá»n mÃ u",
  lP = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? YT() : r === "pt" ? KT() : r === "ch" ? JT() : r === "de" ? QT() : r === "es" ? eP() : r === "fr" ? tP() : r === "it" ? rP() : r === "jp" ? nP() : r === "pl" ? iP() : r === "ru" ? aP() : r === "uk" ? oP() : sP()
  },
  cP = () => "Coordinates",
  uP = () => "Coordenadas",
  hP = () => "åæ ‡",
  dP = () => "Koordinaten",
  pP = () => "Coordenadas",
  fP = () => "CoordonnÃ©es",
  _P = () => "Coordinate",
  mP = () => "åº§æ¨™",
  gP = () => "WspÃ³Å‚rzÄ™dne",
  vP = () => "ĞšĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ñ‹",
  yP = () => "ĞšĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ğ¸",
  xP = () => "Tá»a Ä‘á»™",
  D0 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? cP() : r === "pt" ? uP() : r === "ch" ? hP() : r === "de" ? dP() : r === "es" ? pP() : r === "fr" ? fP() : r === "it" ? _P() : r === "jp" ? mP() : r === "pl" ? gP() : r === "ru" ? vP() : r === "uk" ? yP() : xP()
  },
  bP = () => "Copied",
  wP = () => "Copiado",
  kP = () => "å·²å¤åˆ¶",
  TP = () => "Kopiert",
  PP = () => "Copiado",
  SP = () => "CopiÃ©",
  MP = () => "Copiato",
  IP = () => "ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚",
  CP = () => "Skopiowano",
  AP = () => "Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾",
  zP = () => "Ğ¡ĞºĞ¾Ğ¿Ñ–Ğ¹Ğ¾Ğ²Ğ°Ğ½Ğ¾",
  EP = () => "ÄÃ£ sao chÃ©p",
  sm = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? bP() : r === "pt" ? wP() : r === "ch" ? kP() : r === "de" ? TP() : r === "es" ? PP() : r === "fr" ? SP() : r === "it" ? MP() : r === "jp" ? IP() : r === "pl" ? CP() : r === "ru" ? AP() : r === "uk" ? zP() : EP()
  },
  LP = d => `Could not install the app: ${d.error}`,
  DP = d => `NÃ£o pode instalar o app: ${d.error}`,
  RP = d => `æ— æ³•å®‰è£…åº”ç”¨ï¼š${d.error}`,
  jP = d => `App konnte nicht installiert werden: ${d.error}`,
  FP = d => `No se pudo instalar la app: ${d.error}`,
  BP = d => `Impossible dâ€™installer lâ€™application : ${d.error}`,
  OP = d => `Impossibile installare l'app: ${d.error}`,
  qP = d => `ã‚¢ãƒ—ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã§ãã¾ã›ã‚“ã§ã—ãŸ: ${d.error}`,
  NP = d => `Nie udaÅ‚o siÄ™ zainstalowaÄ‡ aplikacji: ${d.error}`,
  VP = d => `ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ: ${d.error}`,
  UP = d => `ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ Ğ²ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğ¸ Ğ·Ğ°ÑÑ‚Ğ¾ÑÑƒĞ½Ğ¾Ğº: ${d.error}`,
  ZP = d => `KhÃ´ng thá»ƒ cÃ i Ä‘áº·t á»©ng dá»¥ng: ${d.error}`,
  GP = (d, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? LP(d) : r === "pt" ? DP(d) : r === "ch" ? RP(d) : r === "de" ? jP(d) : r === "es" ? FP(d) : r === "fr" ? BP(d) : r === "it" ? OP(d) : r === "jp" ? qP(d) : r === "pl" ? NP(d) : r === "ru" ? VP(d) : r === "uk" ? UP(d) : ZP(d)
  },
  $P = () => "Could not logout. Try refreshing the page.",
  WP = () => "NÃ£o foi possÃ­vel sair da conta. Tente recarregar a pÃ¡gina.",
  HP = () => "æ— æ³•ç™»å‡ºï¼Œè¯·å°è¯•åˆ·æ–°é¡µé¢ã€‚",
  XP = () => "Abmelden nicht mÃ¶glich. Versuche, die Seite neu zu laden.",
  YP = () => "No se pudo cerrar sesiÃ³n. Intenta refrescar la pÃ¡gina.",
  KP = () => "Impossible de se dÃ©connecter. Essayez dâ€™actualiser la page.",
  JP = () => "Impossibile disconnettersi. Prova a ricaricare la pagina.",
  QP = () => "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ã¿ã¦ãã ã•ã„ã€‚",
  eS = () => "Nie udaÅ‚o siÄ™ wylogowaÄ‡. SprÃ³buj odÅ›wieÅ¼yÄ‡ stronÄ™.",
  tS = () => "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ²Ñ‹Ğ¹Ñ‚Ğ¸ Ğ¸Ğ· Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ.",
  rS = () => "ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ Ğ²Ğ¸Ğ¹Ñ‚Ğ¸ Ğ· Ğ°ĞºĞ°ÑƒĞ½Ñ‚Ğ°. Ğ¡Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¾Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğ¸ ÑÑ‚Ğ¾Ñ€Ñ–Ğ½ĞºÑƒ.",
  nS = () => "KhÃ´ng thá»ƒ Ä‘Äƒng xuáº¥t. HÃ£y thá»­ táº£i láº¡i trang.",
  iS = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? $P() : r === "pt" ? WP() : r === "ch" ? HP() : r === "de" ? XP() : r === "es" ? YP() : r === "fr" ? KP() : r === "it" ? JP() : r === "jp" ? QP() : r === "pl" ? eS() : r === "ru" ? tS() : r === "uk" ? rS() : nS()
  },
  aS = () => "Countries",
  oS = () => "PaÃ­ses",
  sS = () => "å›½å®¶",
  lS = () => "LÃ¤nder",
  cS = () => "PaÃ­ses",
  uS = () => "Pays",
  hS = () => "Paesi",
  dS = () => "å›½",
  pS = () => "Kraje",
  fS = () => "Ğ¡Ñ‚Ñ€Ğ°Ğ½Ñ‹",
  _S = () => "ĞšÑ€Ğ°Ñ—Ğ½Ğ¸",
  mS = () => "Quá»‘c gia",
  gS = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? aS() : r === "pt" ? oS() : r === "ch" ? sS() : r === "de" ? lS() : r === "es" ? cS() : r === "fr" ? uS() : r === "it" ? hS() : r === "jp" ? dS() : r === "pl" ? pS() : r === "ru" ? fS() : r === "uk" ? _S() : mS()
  },
  vS = () => "Country",
  yS = () => "PaÃ­s",
  xS = () => "å›½å®¶",
  bS = () => "Land",
  wS = () => "PaÃ­s",
  kS = () => "Pays",
  TS = () => "Paese",
  PS = () => "å›½",
  SS = () => "Kraj",
  MS = () => "Ğ¡Ñ‚Ñ€Ğ°Ğ½Ğ°",
  IS = () => "ĞšÑ€Ğ°Ñ—Ğ½Ğ°",
  CS = () => "Quá»‘c gia",
  lm = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? vS() : r === "pt" ? yS() : r === "ch" ? xS() : r === "de" ? bS() : r === "es" ? wS() : r === "fr" ? kS() : r === "it" ? TS() : r === "jp" ? PS() : r === "pl" ? SS() : r === "ru" ? MS() : r === "uk" ? IS() : CS()
  },
  AS = () => "Create",
  zS = () => "Criar",
  ES = () => "åˆ›å»º",
  LS = () => "Erstellen",
  DS = () => "Crear",
  RS = () => "CrÃ©er",
  jS = () => "Crea",
  FS = () => "ä½œæˆ",
  BS = () => "UtwÃ³rz",
  OS = () => "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ",
  qS = () => "Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ğ¸Ñ‚Ğ¸",
  NS = () => "Táº¡o",
  VS = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? AS() : r === "pt" ? zS() : r === "ch" ? ES() : r === "de" ? LS() : r === "es" ? DS() : r === "fr" ? RS() : r === "it" ? jS() : r === "jp" ? FS() : r === "pl" ? BS() : r === "ru" ? OS() : r === "uk" ? qS() : NS()
  },
  US = () => "Create alliance",
  ZS = () => "Criar alianÃ§a",
  GS = () => "åˆ›å»ºè”ç›Ÿ",
  $S = () => "Allianz erstellen",
  WS = () => "Crear alianza",
  HS = () => "CrÃ©er une alliance",
  XS = () => "Crea alleanza",
  YS = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‚’ä½œæˆ",
  KS = () => "UtwÃ³rz sojusz",
  JS = () => "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ°Ğ»ÑŒÑĞ½Ñ",
  QS = () => "Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ğ¸Ñ‚Ğ¸ Ğ°Ğ»ÑŒÑĞ½Ñ",
  e4 = () => "Táº¡o liÃªn minh",
  t4 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? US() : r === "pt" ? ZS() : r === "ch" ? GS() : r === "de" ? $S() : r === "es" ? WS() : r === "fr" ? HS() : r === "it" ? XS() : r === "jp" ? YS() : r === "pl" ? KS() : r === "ru" ? JS() : r === "uk" ? QS() : e4()
  },
  r4 = () => "Create an alliance",
  n4 = () => "Crie uma alianÃ§a",
  i4 = () => "åˆ›å»ºä¸€ä¸ªè”ç›Ÿ",
  a4 = () => "Erstelle eine Allianz",
  o4 = () => "Crear una alianza",
  s4 = () => "CrÃ©er une alliance",
  l4 = () => "Crea un'alleanza",
  c4 = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹",
  u4 = () => "UtwÃ³rz sojusz",
  h4 = () => "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ°Ğ»ÑŒÑĞ½Ñ",
  d4 = () => "Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ñ–Ñ‚ÑŒ Ğ°Ğ»ÑŒÑĞ½Ñ",
  p4 = () => "Táº¡o má»™t liÃªn minh",
  f4 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? r4() : r === "pt" ? n4() : r === "ch" ? i4() : r === "de" ? a4() : r === "es" ? o4() : r === "fr" ? s4() : r === "it" ? l4() : r === "jp" ? c4() : r === "pl" ? u4() : r === "ru" ? h4() : r === "uk" ? d4() : p4()
  },
  _4 = () => "Dark mode",
  m4 = () => "Modo escuro",
  g4 = () => "æ·±è‰²æ¨¡å¼",
  v4 = () => "Dunkler Modus",
  y4 = () => "Modo oscuro",
  x4 = () => "Mode sombre",
  b4 = () => "Tema scuro",
  w4 = () => "ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒ",
  k4 = () => "Tryb ciemny",
  T4 = () => "Ğ¢Ñ‘Ğ¼Ğ½Ğ°Ñ Ñ‚ĞµĞ¼Ğ°",
  P4 = () => "Ğ¢ĞµĞ¼Ğ½Ğ° Ñ‚ĞµĞ¼Ğ°",
  S4 = () => "Cháº¿ Ä‘á»™ tá»‘i",
  M4 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? _4() : r === "pt" ? m4() : r === "ch" ? g4() : r === "de" ? v4() : r === "es" ? y4() : r === "fr" ? x4() : r === "it" ? b4() : r === "jp" ? w4() : r === "pl" ? k4() : r === "ru" ? T4() : r === "uk" ? P4() : S4()
  },
  I4 = () => "Delete Account",
  C4 = () => "Deletar Conta",
  A4 = () => "åˆ é™¤è´¦å·",
  z4 = () => "Konto lÃ¶schen",
  E4 = () => "Eliminar cuenta",
  L4 = () => "Supprimer le compte",
  D4 = () => "Elimina account",
  R4 = () => "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’å‰Šé™¤",
  j4 = () => "UsuÅ„ konto",
  F4 = () => "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚",
  B4 = () => "Ğ’Ğ¸Ğ´Ğ°Ğ»Ğ¸Ñ‚Ğ¸ Ğ°ĞºĞ°ÑƒĞ½Ñ‚",
  O4 = () => "XÃ³a tÃ i khoáº£n",
  __ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? I4() : r === "pt" ? C4() : r === "ch" ? A4() : r === "de" ? z4() : r === "es" ? E4() : r === "fr" ? L4() : r === "it" ? D4() : r === "jp" ? R4() : r === "pl" ? j4() : r === "ru" ? F4() : r === "uk" ? B4() : O4()
  },
  q4 = () => "ğŸ™… Disclosing other's personal information is not allowed",
  N4 = () => "ğŸ™… Divulgar informaÃ§Ãµes pessoais dos outros nÃ£o Ã© permitido",
  V4 = () => "ğŸ™… ä¸å…è®¸æ³„éœ²ä»–äººä¸ªäººä¿¡æ¯",
  U4 = () => "ğŸ™… Das VerÃ¶ffentlichen persÃ¶nlicher Daten anderer ist nicht erlaubt",
  Z4 = () => "ğŸ™… No estÃ¡ permitido divulgar informaciÃ³n personal de otras personas",
  G4 = () => "ğŸ™… La divulgation dâ€™informations personnelles dâ€™autrui nâ€™est pas autorisÃ©e",
  $4 = () => "ğŸ™… Non Ã¨ consentito divulgare informazioni personali di altre persone",
  W4 = () => "ğŸ™… ä»–äººã®å€‹äººæƒ…å ±ã‚’å…¬é–‹ã™ã‚‹ã“ã¨ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚",
  H4 = () => "ğŸ™… UdostÄ™pnianie cudzych danych osobowych jest niedozwolone",
  X4 = () => "ğŸ™… ĞŸÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ»Ğ¸Ñ‡Ğ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ»ÑĞ´ĞµĞ¹ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½Ğ°",
  Y4 = () => "ğŸ™… ĞŸĞ¾ÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ Ğ¾ÑĞ¾Ğ±Ğ¸ÑÑ‚Ğ¾Ñ— Ñ–Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ— Ñ–Ğ½ÑˆĞ¸Ñ… Ğ»ÑĞ´ĞµĞ¹ Ğ·Ğ°Ğ±Ğ¾Ñ€Ğ¾Ğ½ĞµĞ½Ğ¾",
  K4 = () => "ğŸ™… KhÃ´ng Ä‘Æ°á»£c phÃ©p tiáº¿t lá»™ thÃ´ng tin cÃ¡ nhÃ¢n cá»§a ngÆ°á»i khÃ¡c",
  J4 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? q4() : r === "pt" ? N4() : r === "ch" ? V4() : r === "de" ? U4() : r === "es" ? Z4() : r === "fr" ? G4() : r === "it" ? $4() : r === "jp" ? W4() : r === "pl" ? H4() : r === "ru" ? X4() : r === "uk" ? Y4() : K4()
  },
  Q4 = () => "Successfully linked your Discord account.",
  eM = () => "A sua conta Discord foi conectada com sucesso.",
  tM = () => "å·²æˆåŠŸå…³è”ä½ çš„ Discord è´¦å·ã€‚",
  rM = () => "Dein Discord-Konto wurde erfolgreich verknÃ¼pft.",
  nM = () => "Tu cuenta de Discord se ha vinculado correctamente.",
  iM = () => "Votre compte Discord a Ã©tÃ© liÃ© avec succÃ¨s.",
  aM = () => "Il tuo account Discord Ã¨ stato collegato con successo.",
  oM = () => "Discordã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’æ­£å¸¸ã«é€£æºã—ã¾ã—ãŸã€‚",
  sM = () => "Twoje konto Discord zostaÅ‚o pomyÅ›lnie poÅ‚Ä…czone.",
  lM = () => "Ğ’Ğ°Ñˆ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚ Discord ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¿Ñ€Ğ¸Ğ²ÑĞ·Ğ°Ğ½.",
  cM = () => "Ğ’Ğ°Ñˆ Ğ°ĞºĞ°ÑƒĞ½Ñ‚ Discord ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾ Ğ¿Ñ€Ğ¸Ğ²Ê¼ÑĞ·Ğ°Ğ½Ğ¾.",
  uM = () => "ÄÃ£ liÃªn káº¿t tÃ i khoáº£n Discord cá»§a báº¡n thÃ nh cÃ´ng.",
  hM = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Q4() : r === "pt" ? eM() : r === "ch" ? tM() : r === "de" ? rM() : r === "es" ? nM() : r === "fr" ? iM() : r === "it" ? aM() : r === "jp" ? oM() : r === "pl" ? sM() : r === "ru" ? lM() : r === "uk" ? cM() : uM()
  },
  dM = () => "Discord Username",
  pM = () => "UsuÃ¡rio do Discord",
  fM = () => "Discord ç”¨æˆ·å",
  _M = () => "Discord-Benutzername",
  mM = () => "Usuario de Discord",
  gM = () => "Nom dâ€™utilisateur Discord",
  vM = () => "Utente Discord",
  yM = () => "Discordã®ãƒ¦ãƒ¼ã‚¶ãƒ¼å",
  xM = () => "Nazwa uÅ¼ytkownika Discord",
  bM = () => "Ğ˜Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Discord",
  wM = () => "Ğ†Ğ¼Ê¼Ñ Ğ² Discord",
  kM = () => "TÃªn ngÆ°á»i dÃ¹ng Discord",
  TM = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? dM() : r === "pt" ? pM() : r === "ch" ? fM() : r === "de" ? _M() : r === "es" ? mM() : r === "fr" ? gM() : r === "it" ? vM() : r === "jp" ? yM() : r === "pl" ? xM() : r === "ru" ? bM() : r === "uk" ? wM() : kM()
  },
  PM = () => "Display your countryâ€™s flag next to your username. Plus, when painting in regions where you own the corresponding flag, you recover 10% of the charges spent.",
  SM = () => "Exiba a bandeira do seu paÃ­s ao lado do seu nome de usuÃ¡rio. AlÃ©m disso, ao pintar em regiÃµes onde vocÃª possui a bandeira correspondente, vocÃª recupera 10% das tintas gastas.",
  MM = () => "åœ¨ç”¨æˆ·åæ—æ˜¾ç¤ºä½ çš„å›½å®¶å›½æ——ã€‚æ­¤å¤–ï¼Œå½“ä½ åœ¨æ‹¥æœ‰å¯¹åº”å›½æ——çš„åŒºåŸŸå†…ç»˜åˆ¶åƒç´ æ—¶ï¼Œå¯ä»¥è¿”è¿˜ 10% æ¶ˆè€—çš„å……èƒ½ã€‚",
  IM = () => "Zeige die Flagge deines Landes neben deinem Benutzernamen an. Wenn du in Regionen malst, in denen du die entsprechende Flagge besitzt, erhÃ¤ltst du 10 % der verbrauchten Pixel zurÃ¼ck.",
  CM = () => "Muestra la bandera de tu paÃ­s junto a tu nombre de usuario. AdemÃ¡s, al pintar en regiones donde posees la bandera correspondiente, recuperas el 10% de las cargas gastadas.",
  AM = () => "Affichez le drapeau de votre pays Ã  cÃ´tÃ© de votre nom dâ€™utilisateur. De plus, lorsque vous peignez dans des rÃ©gions correspondant Ã  votre drapeau, vous rÃ©cupÃ©rez 10 % des charges dÃ©pensÃ©es.",
  zM = () => "Mostra la bandiera del tuo paese accanto al tuo nome utente. Inoltre, quando dipingi in regioni in cui possiedi la bandiera corrispondente, recuperi il 10% delle cariche spese.",
  EM = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼åã®æ¨ªã«è‡ªåˆ†ã®å›½æ——ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚ã•ã‚‰ã«ã€ãã®å›½æ——ã«å¯¾å¿œã™ã‚‹åœ°åŸŸã§ãƒšã‚¤ãƒ³ãƒˆã™ã‚‹ã¨ã€æ¶ˆè²»ã—ãŸãƒãƒ£ãƒ¼ã‚¸ã®10%ãŒæˆ»ã£ã¦ãã¾ã™ã€‚",
  LM = () => "WyÅ›wietl flagÄ™ swojego kraju obok nazwy uÅ¼ytkownika. Dodatkowo, malujÄ…c w regionach, ktÃ³rych flagÄ™ posiadasz, odzyskujesz 10% zuÅ¼ytych Å‚adunkÃ³w.",
  DM = () => "ĞŸĞ¾ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ„Ğ»Ğ°Ğ³ ÑĞ²Ğ¾ĞµĞ¹ ÑÑ‚Ñ€Ğ°Ğ½Ñ‹ Ñ€ÑĞ´Ğ¾Ğ¼ Ñ Ğ¸Ğ¼ĞµĞ½ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ. ĞšÑ€Ğ¾Ğ¼Ğµ Ñ‚Ğ¾Ğ³Ğ¾, Ñ€Ğ¸ÑÑƒÑ Ğ² Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°Ñ…, Ğ³Ğ´Ğµ Ñƒ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¹ Ñ„Ğ»Ğ°Ğ³, Ğ²Ñ‹ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚Ğµ 10% Ğ¿Ğ¾Ñ‚Ñ€Ğ°Ñ‡ĞµĞ½Ğ½Ñ‹Ñ… Ğ·Ğ°Ñ€ÑĞ´Ğ¾Ğ².",
  RM = () => "ĞŸĞ¾ĞºĞ°Ğ·ÑƒĞ¹Ñ‚Ğµ Ğ¿Ñ€Ğ°Ğ¿Ğ¾Ñ€ ÑĞ²Ğ¾Ñ”Ñ— ĞºÑ€Ğ°Ñ—Ğ½Ğ¸ Ğ¿Ğ¾Ñ€ÑƒÑ‡ Ñ–Ğ· Ñ–Ğ¼â€™ÑĞ¼ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°. Ğ¢Ğ°ĞºĞ¾Ğ¶, ĞºĞ¾Ğ»Ğ¸ Ğ²Ğ¸ Ğ¼Ğ°Ğ»ÑÑ”Ñ‚Ğµ Ğ² Ñ€ĞµĞ³Ñ–Ğ¾Ğ½Ğ°Ñ…, Ñ‰Ğ¾ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°ÑÑ‚ÑŒ Ğ²Ğ°ÑˆĞ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ°Ğ¿Ğ¾Ñ€Ñƒ, Ğ²Ğ¸ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ”Ñ‚Ğµ 10% Ğ²Ğ¸Ñ‚Ñ€Ğ°Ñ‡ĞµĞ½Ğ¸Ñ… Ğ·Ğ°Ñ€ÑĞ´Ñ–Ğ².",
  jM = () => "Hiá»ƒn thá»‹ cá» quá»‘c gia bÃªn cáº¡nh tÃªn ngÆ°á»i dÃ¹ng cá»§a báº¡n. NgoÃ i ra, khi tÃ´ trong khu vá»±c tÆ°Æ¡ng á»©ng vá»›i lÃ¡ cá» báº¡n sá»Ÿ há»¯u, báº¡n sáº½ nháº­n láº¡i 10% lÆ°á»£t tÃ´ Ä‘Ã£ dÃ¹ng.",
  FM = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? PM() : r === "pt" ? SM() : r === "ch" ? MM() : r === "de" ? IM() : r === "es" ? CM() : r === "fr" ? AM() : r === "it" ? zM() : r === "jp" ? EM() : r === "pl" ? LM() : r === "ru" ? DM() : r === "uk" ? RM() : jM()
  },
  BM = () => "ğŸ˜ˆ Do not paint over other artworks using random colors or patterns just to mess things up",
  OM = () => "ğŸ˜ˆ NÃ£o desenhe por cima de outras artes usando cores ou padrÃµes aleatÃ³rios sÃ³ para bagunÃ§ar",
  qM = () => "ğŸ˜ˆ è¯·ä¸è¦éšæ„ç”¨éšæœºé¢œè‰²æˆ–å›¾æ¡ˆè¦†ç›–ä»–äººçš„ä½œå“æ¥æ£ä¹±",
  NM = () => "ğŸ˜ˆ Ãœbermale nicht andere Kunstwerke mit irgendwelchen Farben oder Mustern, nur um Chaos zu stiften",
  VM = () => "ğŸ˜ˆ No pintes sobre las obras de otros usando colores o patrones aleatorios sÃ³lo para arruinar",
  UM = () => "ğŸ˜ˆ Ne peignez pas par-dessus les Å“uvres des autres avec des couleurs ou motifs alÃ©atoires juste pour gÃ¢cher",
  ZM = () => "ğŸ˜ˆ Non disegnare sopra le opere altrui usando colori o pattern casuali solo per rovinare",
  GM = () => "ğŸ˜ˆ ã„ãŸãšã‚‰ç›®çš„ã§ã€ãƒ©ãƒ³ãƒ€ãƒ ãªè‰²ã‚„æ¨¡æ§˜ã§ä»–äººã®ä½œå“ã‚’å¡—ã‚Šã¤ã¶ã•ãªã„ã§ãã ã•ã„",
  $M = () => "ğŸ˜ˆ Nie maluj po cudzych pracach losowymi kolorami lub wzorami tylko po to, aby wszystko zepsuÄ‡",
  WM = () => "ğŸ˜ˆ ĞĞµ Ñ€Ğ¸ÑÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ñ‡ÑƒĞ¶Ğ¸Ñ… Ñ€Ğ°Ğ±Ğ¾Ñ‚ ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ğ¼Ğ¸ Ñ†Ğ²ĞµÑ‚Ğ°Ğ¼Ğ¸ Ğ¸Ğ»Ğ¸ ÑƒĞ·Ğ¾Ñ€Ğ°Ğ¼Ğ¸ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ñ€Ğ°Ğ´Ğ¸ Ñ‚Ğ¾Ğ³Ğ¾, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸ÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ‚ÑŒ Ğ¸Ñ…",
  HM = () => "ğŸ˜ˆ ĞĞµ Ğ¼Ğ°Ğ»ÑĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ñ‡ÑƒĞ¶Ğ¸Ñ… Ñ€Ğ¾Ğ±Ñ–Ñ‚ Ğ²Ğ¸Ğ¿Ğ°Ğ´ĞºĞ¾Ğ²Ğ¸Ğ¼Ğ¸ ĞºĞ¾Ğ»ÑŒĞ¾Ñ€Ğ°Ğ¼Ğ¸ Ñ‡Ğ¸ Ğ²Ñ–Ğ·ĞµÑ€ÑƒĞ½ĞºĞ°Ğ¼Ğ¸ Ğ»Ğ¸ÑˆĞµ Ğ·Ğ°Ñ€Ğ°Ğ´Ğ¸ Ğ¿ÑÑƒĞ²Ğ°Ğ½Ğ½Ñ",
  XM = () => "ğŸ˜ˆ Äá»«ng tÃ´ Ä‘Ã¨ lÃªn tÃ¡c pháº©m cá»§a ngÆ°á»i khÃ¡c báº±ng mÃ u ngáº«u nhiÃªn chá»‰ Ä‘á»ƒ phÃ¡",
  YM = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? BM() : r === "pt" ? OM() : r === "ch" ? qM() : r === "de" ? NM() : r === "es" ? VM() : r === "fr" ? UM() : r === "it" ? ZM() : r === "jp" ? GM() : r === "pl" ? $M() : r === "ru" ? WM() : r === "uk" ? HM() : XM()
  },
  KM = () => "Does not need to be equipped to provide the bonus",
  JM = () => "NÃ£o precisa estar equipada para obter o bÃ´nus",
  QM = () => "æ— éœ€è£…å¤‡å³å¯æä¾›åŠ æˆæ•ˆæœ",
  eI = () => "Muss nicht ausgerÃ¼stet sein, um den Bonus zu erhalten",
  tI = () => "No necesita estar equipada para otorgar el bono",
  rI = () => "Nâ€™a pas besoin dâ€™Ãªtre Ã©quipÃ© pour fournir le bonus",
  nI = () => "Non deve essere equipaggiato per fornire il bonus",
  iI = () => "ãƒœãƒ¼ãƒŠã‚¹ã‚’å¾—ã‚‹ãŸã‚ã«è£…å‚™ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚",
  aI = () => "Nie musi byÄ‡ zaÅ‚oÅ¼one, aby dawaÅ‚o bonus",
  oI = () => "ĞĞµ Ğ½ÑƒĞ¶Ğ½Ğ¾ ÑĞºĞ¸Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ±Ğ¾Ğ½ÑƒÑ",
  sI = () => "ĞĞµ Ğ¾Ğ±Ğ¾Ğ²Ê¼ÑĞ·ĞºĞ¾Ğ²Ğ¾ Ğ¾Ğ±Ğ»Ğ°Ğ´Ğ½ÑƒĞ²Ğ°Ñ‚Ğ¸, Ñ‰Ğ¾Ğ± Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ñ‚Ğ¸ Ğ±Ğ¾Ğ½ÑƒÑ",
  lI = () => "KhÃ´ng cáº§n trang bá»‹ Ä‘á»ƒ nháº­n hiá»‡u á»©ng",
  cI = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? KM() : r === "pt" ? JM() : r === "ch" ? QM() : r === "de" ? eI() : r === "es" ? tI() : r === "fr" ? rI() : r === "it" ? nI() : r === "jp" ? iI() : r === "pl" ? aI() : r === "ru" ? oI() : r === "uk" ? sI() : lI()
  },
  uI = () => "Download",
  hI = () => "Download",
  dI = () => "ä¸‹è½½",
  pI = () => "Download",
  fI = () => "Descargar",
  _I = () => "TÃ©lÃ©charger",
  mI = () => "Download",
  gI = () => "ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
  vI = () => "Pobierz",
  yI = () => "Ğ¡ĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ",
  xI = () => "Ğ—Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶Ğ¸Ñ‚Ğ¸",
  bI = () => "Táº£i xuá»‘ng",
  wI = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? uI() : r === "pt" ? hI() : r === "ch" ? dI() : r === "de" ? pI() : r === "es" ? fI() : r === "fr" ? _I() : r === "it" ? mI() : r === "jp" ? gI() : r === "pl" ? vI() : r === "ru" ? yI() : r === "uk" ? xI() : bI()
  },
  kI = () => "Edit profile",
  TI = () => "Editar perfil",
  PI = () => "ç¼–è¾‘ä¸ªäººèµ„æ–™",
  SI = () => "Profil bearbeiten",
  MI = () => "Editar perfil",
  II = () => "Modifier le profil",
  CI = () => "Modifica profilo",
  AI = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’ç·¨é›†",
  zI = () => "Edytuj profil",
  EI = () => "Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
  LI = () => "Ğ ĞµĞ´Ğ°Ğ³ÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»ÑŒ",
  DI = () => "Chá»‰nh sá»­a há»“ sÆ¡",
  RI = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? kI() : r === "pt" ? TI() : r === "ch" ? PI() : r === "de" ? SI() : r === "es" ? MI() : r === "fr" ? II() : r === "it" ? CI() : r === "jp" ? AI() : r === "pl" ? zI() : r === "ru" ? EI() : r === "uk" ? LI() : DI()
  },
  jI = () => "Equip",
  FI = () => "Equipar",
  BI = () => "è£…å¤‡",
  OI = () => "AusrÃ¼sten",
  qI = () => "Equipar",
  NI = () => "Ã‰quiper",
  VI = () => "Equipaggia",
  UI = () => "è£…å‚™ã™ã‚‹",
  ZI = () => "ZaÅ‚Ã³Å¼",
  GI = () => "Ğ­ĞºĞ¸Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
  $I = () => "ĞÑĞ½Ğ°ÑÑ‚Ğ¸Ñ‚Ğ¸",
  WI = () => "Trang bá»‹",
  HI = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? jI() : r === "pt" ? FI() : r === "ch" ? BI() : r === "de" ? OI() : r === "es" ? qI() : r === "fr" ? NI() : r === "it" ? VI() : r === "jp" ? UI() : r === "pl" ? ZI() : r === "ru" ? GI() : r === "uk" ? $I() : WI()
  },
  XI = () => "Equipped",
  YI = () => "Equipado",
  KI = () => "å·²è£…å¤‡",
  JI = () => "AusgerÃ¼stet",
  QI = () => "Equipado",
  e6 = () => "Ã‰quipÃ©",
  t6 = () => "Equipaggiato",
  r6 = () => "è£…å‚™ä¸­",
  n6 = () => "ZaÅ‚oÅ¼one",
  i6 = () => "Ğ­ĞºĞ¸Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾",
  a6 = () => "ĞÑĞ½Ğ°Ñ‰ĞµĞ½Ğ¾",
  o6 = () => "ÄÃ£ trang bá»‹",
  s6 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? XI() : r === "pt" ? YI() : r === "ch" ? KI() : r === "de" ? JI() : r === "es" ? QI() : r === "fr" ? e6() : r === "it" ? t6() : r === "jp" ? r6() : r === "pl" ? n6() : r === "ru" ? i6() : r === "uk" ? a6() : o6()
  },
  l6 = () => "Error giving admin to user",
  c6 = () => "Erro ao tornar usuÃ¡rio admin",
  u6 = () => "æˆäºˆç®¡ç†å‘˜æƒé™æ—¶å‡ºé”™",
  h6 = () => "Fehler beim Vergeben von Admin-Rechten",
  d6 = () => "Error al otorgar admin al usuario",
  p6 = () => "Erreur lors de lâ€™attribution du rÃ´le admin",
  f6 = () => "Errore nel rendere l'utente admin",
  _6 = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ç®¡ç†è€…æ¨©é™ã‚’ä»˜ä¸ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚",
  m6 = () => "BÅ‚Ä…d podczas nadawania uprawnieÅ„ admina",
  g6 = () => "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ğ´Ğ°Ñ‡Ğµ Ğ¿Ñ€Ğ°Ğ² Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ",
  v6 = () => "ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ğ¿Ñ–Ğ´ Ñ‡Ğ°Ñ Ğ½Ğ°Ğ´Ğ°Ğ½Ğ½Ñ Ğ¿Ñ€Ğ°Ğ² Ğ°Ğ´Ğ¼Ñ–Ğ½Ñ–ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°",
  y6 = () => "Lá»—i khi gÃ¡n quyá»n admin cho ngÆ°á»i dÃ¹ng",
  x6 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? l6() : r === "pt" ? c6() : r === "ch" ? u6() : r === "de" ? h6() : r === "es" ? d6() : r === "fr" ? p6() : r === "it" ? f6() : r === "jp" ? _6() : r === "pl" ? m6() : r === "ru" ? g6() : r === "uk" ? v6() : y6()
  },
  b6 = () => "Event",
  w6 = () => "Evento",
  k6 = () => "æ´»åŠ¨",
  T6 = () => "Event",
  P6 = () => "Evento",
  S6 = () => "Ã‰vÃ©nement",
  M6 = () => "Evento",
  I6 = () => "ã‚¤ãƒ™ãƒ³ãƒˆ",
  C6 = () => "Wydarzenie",
  A6 = () => "Ğ¡Ğ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ",
  z6 = () => "ĞŸĞ¾Ğ´Ñ–Ñ",
  E6 = () => "Sá»± kiá»‡n",
  L6 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? b6() : r === "pt" ? w6() : r === "ch" ? k6() : r === "de" ? T6() : r === "es" ? P6() : r === "fr" ? S6() : r === "it" ? M6() : r === "jp" ? I6() : r === "pl" ? C6() : r === "ru" ? A6() : r === "uk" ? z6() : E6()
  },
  D6 = () => "Favorite",
  R6 = () => "Favoritar",
  j6 = () => "æ”¶è—",
  F6 = () => "Favorit",
  B6 = () => "Favorito",
  O6 = () => "Favori",
  q6 = () => "Preferito",
  N6 = () => "ãŠæ°—ã«å…¥ã‚Š",
  V6 = () => "Ulubione",
  U6 = () => "Ğ˜Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ",
  Z6 = () => "Ğ£ Ğ²Ğ¸Ğ±Ñ€Ğ°Ğ½Ğµ",
  G6 = () => "YÃªu thÃ­ch",
  $6 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? D6() : r === "pt" ? R6() : r === "ch" ? j6() : r === "de" ? F6() : r === "es" ? B6() : r === "fr" ? O6() : r === "it" ? q6() : r === "jp" ? N6() : r === "pl" ? V6() : r === "ru" ? U6() : r === "uk" ? Z6() : G6()
  },
  W6 = d => `The flag of <b>${d.country}</b> does not have corresponding areas on the map and will only have cosmetic effects.`,
  H6 = d => `A bandeira <b>${d.country}</b> nÃ£o possui regiÃµes correspondente no mapa e sÃ³ terÃ¡ efeito cosmÃ©tico.`,
  X6 = d => `<b>${d.country}</b> çš„å›½æ——åœ¨åœ°å›¾ä¸Šæ²¡æœ‰å¯¹åº”çš„åŒºåŸŸï¼Œä»…å…·æœ‰è£…é¥°æ•ˆæœã€‚`,
  Y6 = d => `Die Flagge von <b>${d.country}</b> hat keine entsprechende Region auf der Karte und ist nur kosmetisch.`,
  K6 = d => `La bandera de <b>${d.country}</b> no tiene regiones correspondientes en el mapa y tendrÃ¡ sÃ³lo efecto cosmÃ©tico.`,
  J6 = d => `Le drapeau de <b>${d.country}</b> nâ€™a pas de rÃ©gion correspondante sur la carte et aura uniquement un effet cosmÃ©tique.`,
  Q6 = d => `La bandiera di <b>${d.country}</b> non ha una regione corrispondente sulla mappa e avrÃ  solo effetto cosmetico.`,
  eC = d => `<b>${d.country}</b>ã®å›½æ——ã«ã¯ãƒãƒƒãƒ—ä¸Šã®å¯¾å¿œã‚¨ãƒªã‚¢ãŒãªã„ãŸã‚ã€è¦‹ãŸç›®ã®ã¿ã®åŠ¹æœã«ãªã‚Šã¾ã™ã€‚`,
  tC = d => `Flaga <b>${d.country}</b> nie ma odpowiadajÄ…cych jej obszarÃ³w na mapie i ma jedynie efekt kosmetyczny.`,
  rC = d => `Ğ¤Ğ»Ğ°Ğ³ <b>${d.country}</b> Ğ½Ğµ Ğ¸Ğ¼ĞµĞµÑ‚ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ¹ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ğ¸ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ğµ Ğ¸ Ğ±ÑƒĞ´ĞµÑ‚ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑÑ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾ÑĞ¼ĞµÑ‚Ğ¸Ñ‡ĞµÑĞºÑƒÑ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ.`,
  nC = d => `ĞŸÑ€Ğ°Ğ¿Ğ¾Ñ€ <b>${d.country}</b> Ğ½Ğµ Ğ¼Ğ°Ñ” Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ½Ğ¸Ñ… Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ĞµĞ¹ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ñ– Ñ‚Ğ° Ğ¼Ğ°Ñ‚Ğ¸Ğ¼Ğµ Ğ»Ğ¸ÑˆĞµ Ğ²Ñ–Ğ·ÑƒĞ°Ğ»ÑŒĞ½Ğ¸Ğ¹ ĞµÑ„ĞµĞºÑ‚.`,
  iC = d => `Cá» cá»§a <b>${d.country}</b> khÃ´ng cÃ³ khu vá»±c tÆ°Æ¡ng á»©ng trÃªn báº£n Ä‘á»“ vÃ  chá»‰ cÃ³ tÃ¡c dá»¥ng trang trÃ­.`,
  aC = (d, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? W6(d) : r === "pt" ? H6(d) : r === "ch" ? X6(d) : r === "de" ? Y6(d) : r === "es" ? K6(d) : r === "fr" ? J6(d) : r === "it" ? Q6(d) : r === "jp" ? eC(d) : r === "pl" ? tC(d) : r === "ru" ? rC(d) : r === "uk" ? nC(d) : iC(d)
  },
  oC = () => "Flag without region on the map",
  sC = () => "Bandeira sem regiÃ£o no mapa",
  lC = () => "æ— åœ°å›¾åŒºåŸŸçš„å›½æ——",
  cC = () => "Flagge ohne Region auf der Karte",
  uC = () => "Bandera sin regiÃ³n en el mapa",
  hC = () => "Drapeau sans rÃ©gion sur la carte",
  dC = () => "Bandiera senza regione sulla mappa",
  pC = () => "ãƒãƒƒãƒ—ã«å¯¾å¿œã™ã‚‹åœ°åŸŸã®ãªã„æ——",
  fC = () => "Flaga bez regionu na mapie",
  _C = () => "Ğ¤Ğ»Ğ°Ğ³ Ğ±ĞµĞ· Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ° Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ğµ",
  mC = () => "ĞŸÑ€Ğ°Ğ¿Ğ¾Ñ€ Ğ±ĞµĞ· Ñ€ĞµĞ³Ñ–Ğ¾Ğ½Ñƒ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ñ–",
  gC = () => "Cá» khÃ´ng cÃ³ vÃ¹ng trÃªn báº£n Ä‘á»“",
  vC = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? oC() : r === "pt" ? sC() : r === "ch" ? lC() : r === "de" ? cC() : r === "es" ? uC() : r === "fr" ? hC() : r === "it" ? dC() : r === "jp" ? pC() : r === "pl" ? fC() : r === "ru" ? _C() : r === "uk" ? mC() : gC()
  },
  yC = () => "Follow the instructions to enable hardware acceleration",
  xC = () => "Siga a instruÃ§Ã£o para habilitar a aceleraÃ§Ã£o de hardware",
  bC = () => "è¯·æŒ‰ç…§è¯´æ˜å¯ç”¨ç¡¬ä»¶åŠ é€Ÿ",
  wC = () => "Folge den Anweisungen, um Hardwarebeschleunigung zu aktivieren",
  kC = () => "Sigue las instrucciones para habilitar la aceleraciÃ³n por hardware",
  TC = () => "Suivez les instructions pour activer lâ€™accÃ©lÃ©ration matÃ©rielle",
  PC = () => "Segui le istruzioni per abilitare l'accelerazione hardware",
  SC = () => "ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æœ‰åŠ¹ã«ã™ã‚‹æ‰‹é †ã«å¾“ã£ã¦ãã ã•ã„ã€‚",
  MC = () => "PostÄ™puj zgodnie z instrukcjami, aby wÅ‚Ä…czyÄ‡ akceleracjÄ™ sprzÄ™towÄ…",
  IC = () => "Ğ¡Ğ»ĞµĞ´ÑƒĞ¹Ñ‚Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸ÑĞ¼, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ°Ğ¿Ğ¿Ğ°Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğµ ÑƒÑĞºĞ¾Ñ€ĞµĞ½Ğ¸Ğµ",
  CC = () => "Ğ”Ğ¾Ñ‚Ñ€Ğ¸Ğ¼ÑƒĞ¹Ñ‚ĞµÑÑŒ Ñ–Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ñ–Ğ¹, Ñ‰Ğ¾Ğ± ÑƒĞ²Ñ–Ğ¼ĞºĞ½ÑƒÑ‚Ğ¸ Ğ°Ğ¿Ğ°Ñ€Ğ°Ñ‚Ğ½Ğµ Ğ¿Ñ€Ğ¸ÑĞºĞ¾Ñ€ĞµĞ½Ğ½Ñ",
  AC = () => "LÃ m theo hÆ°á»›ng dáº«n Ä‘á»ƒ báº­t tÄƒng tá»‘c pháº§n cá»©ng",
  zC = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? yC() : r === "pt" ? xC() : r === "ch" ? bC() : r === "de" ? wC() : r === "es" ? kC() : r === "fr" ? TC() : r === "it" ? PC() : r === "jp" ? SC() : r === "pl" ? MC() : r === "ru" ? IC() : r === "uk" ? CC() : AC()
  },
  EC = () => "For more details, see our",
  LC = () => "Para mais detalhes, veja nossa",
  DC = () => "æ›´å¤šè¯¦æƒ…è¯·å‚é˜…æˆ‘ä»¬çš„",
  RC = () => "FÃ¼r weitere Details siehe unsere",
  jC = () => "Para mÃ¡s detalles, consulta nuestra",
  FC = () => "Pour plus de dÃ©tails, consultez notre",
  BC = () => "Per maggiori dettagli, consulta la nostra",
  OC = () => "è©³ã—ãã¯ã€ã“ã¡ã‚‰ã‚’ã”è¦§ãã ã•ã„:",
  qC = () => "Po wiÄ™cej informacji zobacz naszÄ…",
  NC = () => "ĞŸĞ¾Ğ´Ñ€Ğ¾Ğ±Ğ½ĞµĞµ ÑĞ¼. Ğ² Ğ½Ğ°ÑˆĞ¸Ñ…",
  VC = () => "Ğ”Ğ»Ñ Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ´Ğ¾Ğ´Ğ°Ñ‚ĞºĞ¾Ğ²Ğ¾Ñ— Ñ–Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ— Ğ¿ĞµÑ€ĞµĞ³Ğ»ÑĞ½ÑŒÑ‚Ğµ Ğ½Ğ°ÑˆÑ–",
  UC = () => "Äá»ƒ biáº¿t thÃªm chi tiáº¿t, hÃ£y xem",
  ZC = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? EC() : r === "pt" ? LC() : r === "ch" ? DC() : r === "de" ? RC() : r === "es" ? jC() : r === "fr" ? FC() : r === "it" ? BC() : r === "jp" ? OC() : r === "pl" ? qC() : r === "ru" ? NC() : r === "uk" ? VC() : UC()
  },
  GC = () => "Get invited to an alliance",
  $C = () => "Seja convidado para uma alianÃ§a",
  WC = () => "é€šè¿‡é‚€è¯·åŠ å…¥è”ç›Ÿ",
  HC = () => "Lass dich in eine Allianz einladen",
  XC = () => "Recibe una invitaciÃ³n para una alianza",
  YC = () => "Recevoir une invitation dans une alliance",
  KC = () => "Fatti invitare in un'alleanza",
  JC = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã«æ‹›å¾…ã—ã¦ã‚‚ã‚‰ã†",
  QC = () => "ZostaÅ„ zaproszony do sojuszu",
  eA = () => "ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ Ğ² Ğ°Ğ»ÑŒÑĞ½Ñ",
  tA = () => "ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ¹Ñ‚Ğµ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑˆĞµĞ½Ğ½Ñ Ğ² Ğ°Ğ»ÑŒÑĞ½Ñ",
  rA = () => "Nháº­n lá»i má»i vÃ o má»™t liÃªn minh",
  nA = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? GC() : r === "pt" ? $C() : r === "ch" ? WC() : r === "de" ? HC() : r === "es" ? XC() : r === "fr" ? YC() : r === "it" ? KC() : r === "jp" ? JC() : r === "pl" ? QC() : r === "ru" ? eA() : r === "uk" ? tA() : rA()
  },
  iA = () => "Get more charges",
  aA = () => "Recarregue tinta para pintar",
  oA = () => "è·å¾—æ›´å¤šå……èƒ½",
  sA = () => "Mehr Pixel-Ladungen bekommen",
  lA = () => "Obtener mÃ¡s cargas",
  cA = () => "Obtenir plus de charges",
  uA = () => "Ricarica la vernice per dipingere",
  hA = () => "ãƒãƒ£ãƒ¼ã‚¸ã‚’è¿½åŠ ã§ç²å¾—",
  dA = () => "ZdobÄ…dÅº wiÄ™cej Å‚adunkÃ³w",
  pA = () => "ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ·Ğ°Ñ€ÑĞ´Ğ¾Ğ²",
  fA = () => "ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ñ‚Ğ¸ Ğ±Ñ–Ğ»ÑŒÑˆĞµ Ğ·Ğ°Ñ€ÑĞ´Ñ–Ğ²",
  _A = () => "Nháº­n thÃªm lÆ°á»£t tÃ´",
  mA = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? iA() : r === "pt" ? aA() : r === "ch" ? oA() : r === "de" ? sA() : r === "es" ? lA() : r === "fr" ? cA() : r === "it" ? uA() : r === "jp" ? hA() : r === "pl" ? dA() : r === "ru" ? pA() : r === "uk" ? fA() : _A()
  },
  gA = () => "Give admin",
  vA = () => "Tornar admin",
  yA = () => "æˆäºˆç®¡ç†å‘˜",
  xA = () => "Admin vergeben",
  bA = () => "Dar admin",
  wA = () => "Donner le rÃ´le admin",
  kA = () => "Rendi admin",
  TA = () => "ç®¡ç†è€…ã«ã™ã‚‹",
  PA = () => "Nadaj uprawnienia admina",
  SA = () => "Ğ¡Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ¼",
  MA = () => "ĞĞ°Ğ´Ğ°Ñ‚Ğ¸ Ğ°Ğ´Ğ¼Ñ–Ğ½-Ğ¿Ñ€Ğ°Ğ²Ğ°",
  IA = () => "GÃ¡n quyá»n admin",
  CA = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? gA() : r === "pt" ? vA() : r === "ch" ? yA() : r === "de" ? xA() : r === "es" ? bA() : r === "fr" ? wA() : r === "it" ? kA() : r === "jp" ? TA() : r === "pl" ? PA() : r === "ru" ? SA() : r === "uk" ? MA() : IA()
  },
  AA = () => "Giving admin to user",
  zA = () => "Tornar usuÃ¡rio um admin",
  EA = () => "æ­£åœ¨æˆäºˆç®¡ç†å‘˜æƒé™",
  LA = () => "Vergebe Admin-Rechte an Benutzer",
  DA = () => "Otorgando admin al usuario",
  RA = () => "Attribution du rÃ´le admin Ã  lâ€™utilisateur",
  jA = () => "Assegnazione permessi admin all'utente",
  FA = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ç®¡ç†è€…æ¨©é™ã‚’ä»˜ä¸ä¸­",
  BA = () => "Nadawanie uprawnieÅ„ admina uÅ¼ytkownikowi",
  OA = () => "Ğ’Ñ‹Ğ´Ğ°Ñ‡Ğ° Ğ¿Ñ€Ğ°Ğ² Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ",
  qA = () => "ĞĞ°Ğ´Ğ°Ğ½Ğ½Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñƒ Ğ¿Ñ€Ğ°Ğ² Ğ°Ğ´Ğ¼Ñ–Ğ½Ñ–ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°",
  NA = () => "Äang gÃ¡n quyá»n admin cho ngÆ°á»i dÃ¹ng",
  VA = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? AA() : r === "pt" ? zA() : r === "ch" ? EA() : r === "de" ? LA() : r === "es" ? DA() : r === "fr" ? RA() : r === "it" ? jA() : r === "jp" ? FA() : r === "pl" ? BA() : r === "ru" ? OA() : r === "uk" ? qA() : NA()
  },
  UA = () => "Headquarters",
  ZA = () => "Quartel General",
  GA = () => "æ€»éƒ¨",
  $A = () => "Hauptquartier",
  WA = () => "Cuartel general",
  HA = () => "Quartier gÃ©nÃ©ral",
  XA = () => "Quartier generale",
  YA = () => "æ‹ ç‚¹",
  KA = () => "Siedziba",
  JA = () => "Ğ¨Ñ‚Ğ°Ğ±-ĞºĞ²Ğ°Ñ€Ñ‚Ğ¸Ñ€Ğ°",
  QA = () => "Ğ¨Ñ‚Ğ°Ğ±-ĞºĞ²Ğ°Ñ€Ñ‚Ğ¸Ñ€Ğ°",
  ez = () => "Trá»¥ sá»Ÿ",
  tz = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? UA() : r === "pt" ? ZA() : r === "ch" ? GA() : r === "de" ? $A() : r === "es" ? WA() : r === "fr" ? HA() : r === "it" ? XA() : r === "jp" ? YA() : r === "pl" ? KA() : r === "ru" ? JA() : r === "uk" ? QA() : ez()
  },
  rz = () => "Hide pixel art",
  nz = () => "Esconder Pixel Art",
  iz = () => "éšè—åƒç´ ç”»",
  az = () => "Pixel-Art ausblenden",
  oz = () => "Ocultar pixel art",
  sz = () => "Masquer le pixel art",
  lz = () => "Nascondi Pixel Art",
  cz = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚¢ãƒ¼ãƒˆã‚’éè¡¨ç¤º",
  uz = () => "Ukryj pixel art",
  hz = () => "Ğ¡ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ-Ğ°Ñ€Ñ‚",
  dz = () => "ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ²Ğ°Ñ‚Ğ¸ Ğ¿Ñ–ĞºÑĞµĞ»ÑŒ-Ğ°Ñ€Ñ‚",
  pz = () => "áº¨n pixel art",
  fz = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? rz() : r === "pt" ? nz() : r === "ch" ? iz() : r === "de" ? az() : r === "es" ? oz() : r === "fr" ? sz() : r === "it" ? lz() : r === "jp" ? cz() : r === "pl" ? uz() : r === "ru" ? hz() : r === "uk" ? dz() : pz()
  },
  _z = () => "Hide UI",
  mz = () => "Esconder UI",
  gz = () => "éšè—ç•Œé¢",
  vz = () => "UI ausblenden",
  yz = () => "Ocultar UI",
  xz = () => "Masquer lâ€™interface",
  bz = () => "Nascondi UI",
  wz = () => "UIã‚’éš ã™",
  kz = () => "Ukryj interfejs",
  Tz = () => "Ğ¡ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ",
  Pz = () => "ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ²Ğ°Ñ‚Ğ¸ Ñ–Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ",
  Sz = () => "áº¨n giao diá»‡n",
  Mz = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? _z() : r === "pt" ? mz() : r === "ch" ? gz() : r === "de" ? vz() : r === "es" ? yz() : r === "fr" ? xz() : r === "it" ? bz() : r === "jp" ? wz() : r === "pl" ? kz() : r === "ru" ? Tz() : r === "uk" ? Pz() : Sz()
  },
  Iz = () => "Hold",
  Cz = () => "Segure",
  Az = () => "æŒ‰ä½",
  zz = () => "Halten",
  Ez = () => "Mantener",
  Lz = () => "Maintenir",
  Dz = () => "Tieni premuto",
  Rz = () => "é•·æŠ¼ã—",
  jz = () => "Przytrzymaj",
  Fz = () => "Ğ£Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°Ñ‚ÑŒ",
  Bz = () => "Ğ£Ñ‚Ñ€Ğ¸Ğ¼ÑƒĞ¹Ñ‚Ğµ",
  Oz = () => "Giá»¯",
  qz = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Iz() : r === "pt" ? Cz() : r === "ch" ? Az() : r === "de" ? zz() : r === "es" ? Ez() : r === "fr" ? Lz() : r === "it" ? Dz() : r === "jp" ? Rz() : r === "pl" ? jz() : r === "ru" ? Fz() : r === "uk" ? Bz() : Oz()
  },
  Nz = () => "How to paint faster",
  Vz = () => "Como pintar mais rÃ¡pido",
  Uz = () => "å¦‚ä½•æ›´å¿«åœ°ç»˜åˆ¶",
  Zz = () => "Wie man schneller malt",
  Gz = () => "CÃ³mo pintar mÃ¡s rÃ¡pido",
  $z = () => "Comment peindre plus vite",
  Wz = () => "Come dipingere piÃ¹ velocemente",
  Hz = () => "æ—©ãå¡—ã‚‹ã«ã¯",
  Xz = () => "Jak malowaÄ‡ szybciej",
  Yz = () => "ĞšĞ°Ğº Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ",
  Kz = () => "Ğ¯Ğº Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ ÑˆĞ²Ğ¸Ğ´ÑˆĞµ",
  Jz = () => "CÃ¡ch tÃ´ nhanh hÆ¡n",
  Qz = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Nz() : r === "pt" ? Vz() : r === "ch" ? Uz() : r === "de" ? Zz() : r === "es" ? Gz() : r === "fr" ? $z() : r === "it" ? Wz() : r === "jp" ? Hz() : r === "pl" ? Xz() : r === "ru" ? Yz() : r === "uk" ? Kz() : Jz()
  },
  e8 = () => "Image",
  t8 = () => "Imagem",
  r8 = () => "å›¾ç‰‡",
  n8 = () => "Bild",
  i8 = () => "Imagen",
  a8 = () => "Image",
  o8 = () => "Immagine",
  s8 = () => "ç”»åƒ",
  l8 = () => "Obraz",
  c8 = () => "Ğ˜Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ",
  u8 = () => "Ğ—Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ",
  h8 = () => "HÃ¬nh áº£nh",
  d8 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? e8() : r === "pt" ? t8() : r === "ch" ? r8() : r === "de" ? n8() : r === "es" ? i8() : r === "fr" ? a8() : r === "it" ? o8() : r === "jp" ? s8() : r === "pl" ? l8() : r === "ru" ? c8() : r === "uk" ? u8() : h8()
  },
  p8 = () => "Image copied to clipboard",
  f8 = () => "Imagem copiada para a Ã¡rea de transferÃªncia",
  _8 = () => "å›¾ç‰‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿",
  m8 = () => "Bild in die Zwischenablage kopiert",
  g8 = () => "Imagen copiada al portapapeles",
  v8 = () => "Image copiÃ©e dans le presse-papiers",
  y8 = () => "Immagine copiata negli appunti",
  x8 = () => "ç”»åƒã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚",
  b8 = () => "Obraz skopiowany do schowka",
  w8 = () => "Ğ˜Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ ÑĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ² Ğ±ÑƒÑ„ĞµÑ€ Ğ¾Ğ±Ğ¼ĞµĞ½Ğ°",
  k8 = () => "Ğ—Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ ÑĞºĞ¾Ğ¿Ñ–Ğ¹Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ´Ğ¾ Ğ±ÑƒÑ„ĞµÑ€Ğ° Ğ¾Ğ±Ğ¼Ñ–Ğ½Ñƒ",
  T8 = () => "ÄÃ£ sao chÃ©p hÃ¬nh áº£nh vÃ o clipboard",
  P8 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? p8() : r === "pt" ? f8() : r === "ch" ? _8() : r === "de" ? m8() : r === "es" ? g8() : r === "fr" ? v8() : r === "it" ? y8() : r === "jp" ? x8() : r === "pl" ? b8() : r === "ru" ? w8() : r === "uk" ? k8() : T8()
  },
  S8 = () => "Important",
  M8 = () => "Importante",
  I8 = () => "é‡è¦",
  C8 = () => "Wichtig",
  A8 = () => "Importante",
  z8 = () => "Important",
  E8 = () => "Importante",
  L8 = () => "é‡è¦",
  D8 = () => "WaÅ¼ne",
  R8 = () => "Ğ’Ğ°Ğ¶Ğ½Ğ¾",
  j8 = () => "Ğ’Ğ°Ğ¶Ğ»Ğ¸Ğ²Ğ¾",
  F8 = () => "Quan trá»ng",
  B8 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? S8() : r === "pt" ? M8() : r === "ch" ? I8() : r === "de" ? C8() : r === "es" ? A8() : r === "fr" ? z8() : r === "it" ? E8() : r === "jp" ? L8() : r === "pl" ? D8() : r === "ru" ? R8() : r === "uk" ? j8() : F8()
  },
  O8 = () => "Increase your maximum paint charges capacity",
  q8 = () => "Aumente sua capacidade mÃ¡xima de tinta",
  N8 = () => "æå‡ä½ çš„æœ€å¤§ç»˜åˆ¶å……èƒ½ä¸Šé™",
  V8 = () => "ErhÃ¶he deine maximale Anzahl an Pixel-Ladungen",
  U8 = () => "Aumenta tu capacidad mÃ¡xima de cargas de pintura",
  Z8 = () => "Augmentez votre capacitÃ© maximale de charges de peinture",
  G8 = () => "Aumenta la tua capacitÃ  massima di vernice",
  $8 = () => "ãƒšã‚¤ãƒ³ãƒˆã®æœ€å¤§ãƒãƒ£ãƒ¼ã‚¸æ•°ã‚’å¢—ã‚„ã™",
  W8 = () => "ZwiÄ™ksz maksymalnÄ… pojemnoÅ›Ä‡ Å‚adunkÃ³w malowania",
  H8 = () => "Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡ÑŒÑ‚Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ·Ğ°Ñ€ÑĞ´Ğ¾Ğ²",
  X8 = () => "Ğ—Ğ±Ñ–Ğ»ÑŒÑˆÑ‚Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñƒ ĞºÑ–Ğ»ÑŒĞºÑ–ÑÑ‚ÑŒ Ğ·Ğ°Ñ€ÑĞ´Ñ–Ğ² Ñ„Ğ°Ñ€Ğ±Ğ¸",
  Y8 = () => "TÄƒng sá»‘ lÆ°á»£t tÃ´ tá»‘i Ä‘a",
  K8 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? O8() : r === "pt" ? q8() : r === "ch" ? N8() : r === "de" ? V8() : r === "es" ? U8() : r === "fr" ? Z8() : r === "it" ? G8() : r === "jp" ? $8() : r === "pl" ? W8() : r === "ru" ? H8() : r === "uk" ? X8() : Y8()
  },
  J8 = () => "Info",
  Q8 = () => "InformaÃ§Ãµes",
  eE = () => "ä¿¡æ¯",
  tE = () => "Info",
  rE = () => "Info",
  nE = () => "Infos",
  iE = () => "Informazioni",
  aE = () => "æƒ…å ±",
  oE = () => "Informacje",
  sE = () => "Ğ˜Ğ½Ñ„Ğ¾",
  lE = () => "Ğ†Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ",
  cE = () => "ThÃ´ng tin",
  uE = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? J8() : r === "pt" ? Q8() : r === "ch" ? eE() : r === "de" ? tE() : r === "es" ? rE() : r === "fr" ? nE() : r === "it" ? iE() : r === "jp" ? aE() : r === "pl" ? oE() : r === "ru" ? sE() : r === "uk" ? lE() : cE()
  },
  hE = () => "Install App",
  dE = () => "Instalar App",
  pE = () => "å®‰è£…åº”ç”¨",
  fE = () => "App installieren",
  _E = () => "Instalar app",
  mE = () => "Installer lâ€™application",
  gE = () => "Installa app",
  vE = () => "ã‚¢ãƒ—ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«",
  yE = () => "Zainstaluj aplikacjÄ™",
  xE = () => "Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ",
  bE = () => "Ğ’ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğ¸ Ğ·Ğ°ÑÑ‚Ğ¾ÑÑƒĞ½Ğ¾Ğº",
  wE = () => "CÃ i Ä‘áº·t á»©ng dá»¥ng",
  kE = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? hE() : r === "pt" ? dE() : r === "ch" ? pE() : r === "de" ? fE() : r === "es" ? _E() : r === "fr" ? mE() : r === "it" ? gE() : r === "jp" ? vE() : r === "pl" ? yE() : r === "ru" ? xE() : r === "uk" ? bE() : wE()
  },
  TE = () => "Invite",
  PE = () => "Convite",
  SE = () => "é‚€è¯·",
  ME = () => "Einladen",
  IE = () => "Invitar",
  CE = () => "Invitation",
  AE = () => "Invito",
  zE = () => "æ‹›å¾…",
  EE = () => "ZaproÅ›",
  LE = () => "ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑĞ¸Ñ‚ÑŒ",
  DE = () => "Ğ—Ğ°Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚Ğ¸",
  RE = () => "Má»i",
  jE = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? TE() : r === "pt" ? PE() : r === "ch" ? SE() : r === "de" ? ME() : r === "es" ? IE() : r === "fr" ? CE() : r === "it" ? AE() : r === "jp" ? zE() : r === "pl" ? EE() : r === "ru" ? LE() : r === "uk" ? DE() : RE()
  },
  FE = () => "Invite link",
  BE = () => "Link de convite",
  OE = () => "é‚€è¯·é“¾æ¥",
  qE = () => "Einladungslink",
  NE = () => "Enlace de invitaciÃ³n",
  VE = () => "Lien dâ€™invitation",
  UE = () => "Link di invito",
  ZE = () => "æ‹›å¾…ãƒªãƒ³ã‚¯",
  GE = () => "Link zaproszenia",
  $E = () => "Ğ¡ÑÑ‹Ğ»ĞºĞ°-Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ",
  WE = () => "ĞŸĞ¾ÑĞ¸Ğ»Ğ°Ğ½Ğ½Ñ-Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑˆĞµĞ½Ğ½Ñ",
  HE = () => "LiÃªn káº¿t má»i",
  XE = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? FE() : r === "pt" ? BE() : r === "ch" ? OE() : r === "de" ? qE() : r === "es" ? NE() : r === "fr" ? VE() : r === "it" ? UE() : r === "jp" ? ZE() : r === "pl" ? GE() : r === "ru" ? $E() : r === "uk" ? WE() : HE()
  },
  YE = () => "is enabled on",
  KE = () => "estÃ¡ habilitado em",
  JE = () => "å·²åœ¨æ­¤å¯ç”¨ï¼š",
  QE = () => "aktiviert ist auf",
  eL = () => "estÃ¡ habilitado en",
  tL = () => "est activÃ© sur",
  rL = () => "Ã¨ abilitato su",
  nL = () => "ã¯æ¬¡ã§æœ‰åŠ¹ã§ã™:",
  iL = () => "jest wÅ‚Ä…czone na",
  aL = () => "Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾ Ğ½Ğ°",
  oL = () => "ÑƒĞ²Ñ–Ğ¼ĞºĞ½ĞµĞ½Ğ¾ Ğ½Ğ°",
  sL = () => "Ä‘Æ°á»£c báº­t trÃªn",
  lL = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? YE() : r === "pt" ? KE() : r === "ch" ? JE() : r === "de" ? QE() : r === "es" ? eL() : r === "fr" ? tL() : r === "it" ? rL() : r === "jp" ? nL() : r === "pl" ? iL() : r === "ru" ? aL() : r === "uk" ? oL() : sL()
  },
  cL = () => "Items",
  uL = () => "Itens",
  hL = () => "ç‰©å“",
  dL = () => "Items",
  pL = () => "Ãtems",
  fL = () => "Objets",
  _L = () => "Oggetti",
  mL = () => "ã‚¢ã‚¤ãƒ†ãƒ ",
  gL = () => "Przedmioty",
  vL = () => "ĞŸÑ€ĞµĞ´Ğ¼ĞµÑ‚Ñ‹",
  yL = () => "ĞŸÑ€ĞµĞ´Ğ¼ĞµÑ‚Ğ¸",
  xL = () => "Váº­t pháº©m",
  bL = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? cL() : r === "pt" ? uL() : r === "ch" ? hL() : r === "de" ? dL() : r === "es" ? pL() : r === "fr" ? fL() : r === "it" ? _L() : r === "jp" ? mL() : r === "pl" ? gL() : r === "ru" ? vL() : r === "uk" ? yL() : xL()
  },
  wL = () => "Leave alliance",
  kL = () => "Sair da alianÃ§a",
  TL = () => "ç¦»å¼€è”ç›Ÿ",
  PL = () => "Allianz verlassen",
  SL = () => "Salir de la alianza",
  ML = () => "Quitter lâ€™alliance",
  IL = () => "Esci dall'alleanza",
  CL = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‚’æŠœã‘ã‚‹",
  AL = () => "OpuÅ›Ä‡ sojusz",
  zL = () => "Ğ’Ñ‹Ğ¹Ñ‚Ğ¸ Ğ¸Ğ· Ğ°Ğ»ÑŒÑĞ½ÑĞ°",
  EL = () => "Ğ’Ğ¸Ğ¹Ñ‚Ğ¸ Ğ· Ğ°Ğ»ÑŒÑĞ½ÑÑƒ",
  LL = () => "Rá»i liÃªn minh",
  DL = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? wL() : r === "pt" ? kL() : r === "ch" ? TL() : r === "de" ? PL() : r === "es" ? SL() : r === "fr" ? ML() : r === "it" ? IL() : r === "jp" ? CL() : r === "pl" ? AL() : r === "ru" ? zL() : r === "uk" ? EL() : LL()
  },
  RL = () => "Light mode",
  jL = () => "Modo claro",
  FL = () => "æµ…è‰²æ¨¡å¼",
  BL = () => "Heller Modus",
  OL = () => "Modo claro",
  qL = () => "Mode clair",
  NL = () => "Tema chiaro",
  VL = () => "ãƒ©ã‚¤ãƒˆãƒ†ãƒ¼ãƒ",
  UL = () => "Tryb jasny",
  ZL = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ°Ñ Ñ‚ĞµĞ¼Ğ°",
  GL = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ° Ñ‚ĞµĞ¼Ğ°",
  $L = () => "Cháº¿ Ä‘á»™ sÃ¡ng",
  WL = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? RL() : r === "pt" ? jL() : r === "ch" ? FL() : r === "de" ? BL() : r === "es" ? OL() : r === "fr" ? qL() : r === "it" ? NL() : r === "jp" ? VL() : r === "pl" ? UL() : r === "ru" ? ZL() : r === "uk" ? GL() : $L()
  },
  HL = () => "Limit reached",
  XL = () => "Limite atingido",
  YL = () => "å·²è¾¾åˆ°ä¸Šé™",
  KL = () => "Limit erreicht",
  JL = () => "LÃ­mite alcanzado",
  QL = () => "Limite atteinte",
  eD = () => "Limite raggiunto",
  tD = () => "ä¸Šé™ã«é”ã—ã¾ã—ãŸã€‚",
  rD = () => "OsiÄ…gniÄ™to limit",
  nD = () => "Ğ”Ğ¾ÑÑ‚Ğ¸Ğ³Ğ½ÑƒÑ‚ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚",
  iD = () => "Ğ”Ğ¾ÑÑĞ³Ğ½ÑƒÑ‚Ğ¾ Ğ»Ñ–Ğ¼Ñ–Ñ‚",
  aD = () => "ÄÃ£ Ä‘áº¡t giá»›i háº¡n",
  oD = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? HL() : r === "pt" ? XL() : r === "ch" ? YL() : r === "de" ? KL() : r === "es" ? JL() : r === "fr" ? QL() : r === "it" ? eD() : r === "jp" ? tD() : r === "pl" ? rD() : r === "ru" ? nD() : r === "uk" ? iD() : aD()
  },
  sD = () => "Link your Discord",
  lD = () => "Conectar Discord",
  cD = () => "å…³è”ä½ çš„ Discord",
  uD = () => "Discord verknÃ¼pfen",
  hD = () => "Vincular Discord",
  dD = () => "Lier votre Discord",
  pD = () => "Collega Discord",
  fD = () => "Discordã‚’é€£æºã™ã‚‹",
  _D = () => "PoÅ‚Ä…cz Discord",
  mD = () => "ĞŸÑ€Ğ¸Ğ²ÑĞ·Ğ°Ñ‚ÑŒ Discord",
  gD = () => "ĞŸÑ€Ğ¸Ğ²Ê¼ÑĞ·Ğ°Ñ‚Ğ¸ Discord",
  vD = () => "LiÃªn káº¿t Discord",
  yD = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? sD() : r === "pt" ? lD() : r === "ch" ? cD() : r === "de" ? uD() : r === "es" ? hD() : r === "fr" ? dD() : r === "it" ? pD() : r === "jp" ? fD() : r === "pl" ? _D() : r === "ru" ? mD() : r === "uk" ? gD() : vD()
  },
  xD = () => "Location favorited",
  bD = () => "LocalizaÃ§Ã£o favoritada",
  wD = () => "ä½ç½®å·²æ”¶è—",
  kD = () => "Ort favorisiert",
  TD = () => "UbicaciÃ³n agregada a favoritos",
  PD = () => "Emplacement ajoutÃ© aux favoris",
  SD = () => "LocalitÃ  aggiunta ai preferiti",
  MD = () => "å ´æ‰€ã‚’ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ã—ã¾ã—ãŸã€‚",
  ID = () => "Lokalizacja dodana do ulubionych",
  CD = () => "Ğ›Ğ¾ĞºĞ°Ñ†Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ",
  AD = () => "Ğ›Ğ¾ĞºĞ°Ñ†Ñ–Ñ Ğ´Ğ¾Ğ´Ğ°Ğ½Ğ¾ Ğ´Ğ¾ Ğ²Ğ¸Ğ±Ñ€Ğ°Ğ½Ğ¸Ñ…",
  zD = () => "ÄÃ£ thÃªm vá»‹ trÃ­ vÃ o yÃªu thÃ­ch",
  ED = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? xD() : r === "pt" ? bD() : r === "ch" ? wD() : r === "de" ? kD() : r === "es" ? TD() : r === "fr" ? PD() : r === "it" ? SD() : r === "jp" ? MD() : r === "pl" ? ID() : r === "ru" ? CD() : r === "uk" ? AD() : zD()
  },
  LD = () => "Location unfavorited",
  DD = () => "LocalizaÃ§Ã£o desfavoritada",
  RD = () => "ä½ç½®å·²å–æ¶ˆæ”¶è—",
  jD = () => "Ort aus Favoriten entfernt",
  FD = () => "UbicaciÃ³n eliminada de favoritos",
  BD = () => "Emplacement retirÃ© des favoris",
  OD = () => "LocalitÃ  rimossa dai preferiti",
  qD = () => "å ´æ‰€ã®ãŠæ°—ã«å…¥ã‚Šã‚’è§£é™¤ã—ã¾ã—ãŸã€‚",
  ND = () => "Lokalizacja usuniÄ™ta z ulubionych",
  VD = () => "Ğ›Ğ¾ĞºĞ°Ñ†Ğ¸Ñ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ° Ğ¸Ğ· Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾",
  UD = () => "Ğ›Ğ¾ĞºĞ°Ñ†Ñ–Ñ Ğ²Ğ¸Ğ»ÑƒÑ‡ĞµĞ½Ğ¾ Ğ· Ğ²Ğ¸Ğ±Ñ€Ğ°Ğ½Ğ¸Ñ…",
  ZD = () => "ÄÃ£ bá» yÃªu thÃ­ch vá»‹ trÃ­",
  GD = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? LD() : r === "pt" ? DD() : r === "ch" ? RD() : r === "de" ? jD() : r === "es" ? FD() : r === "fr" ? BD() : r === "it" ? OD() : r === "jp" ? qD() : r === "pl" ? ND() : r === "ru" ? VD() : r === "uk" ? UD() : ZD()
  },
  $D = () => "Lock",
  WD = () => "Travar",
  HD = () => "é”å®š",
  XD = () => "Sperren",
  YD = () => "Bloquear",
  KD = () => "Verrouiller",
  JD = () => "Blocca",
  QD = () => "ãƒ­ãƒƒã‚¯",
  eR = () => "Zablokuj",
  tR = () => "Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
  rR = () => "Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ñ‚Ğ¸",
  nR = () => "KhÃ³a",
  iR = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? $D() : r === "pt" ? WD() : r === "ch" ? HD() : r === "de" ? XD() : r === "es" ? YD() : r === "fr" ? KD() : r === "it" ? JD() : r === "jp" ? QD() : r === "pl" ? eR() : r === "ru" ? tR() : r === "uk" ? rR() : nR()
  },
  aR = () => "Log in",
  oR = () => "Entrar",
  sR = () => "ç™»å½•",
  lR = () => "Einloggen",
  cR = () => "Iniciar sesiÃ³n",
  uR = () => "Se connecter",
  hR = () => "Accedi",
  dR = () => "ãƒ­ã‚°ã‚¤ãƒ³",
  pR = () => "Zaloguj siÄ™",
  fR = () => "Ğ’Ğ¾Ğ¹Ñ‚Ğ¸",
  _R = () => "Ğ£Ğ²Ñ–Ğ¹Ñ‚Ğ¸",
  mR = () => "ÄÄƒng nháº­p",
  gR = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? aR() : r === "pt" ? oR() : r === "ch" ? sR() : r === "de" ? lR() : r === "es" ? cR() : r === "fr" ? uR() : r === "it" ? hR() : r === "jp" ? dR() : r === "pl" ? pR() : r === "ru" ? fR() : r === "uk" ? _R() : mR()
  },
  vR = () => "Logged out",
  yR = () => "Logout feito",
  xR = () => "å·²ç™»å‡º",
  bR = () => "Ausgeloggt",
  wR = () => "SesiÃ³n cerrada",
  kR = () => "DÃ©connectÃ©",
  TR = () => "Logout effettuato",
  PR = () => "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚",
  SR = () => "Wylogowano",
  MR = () => "Ğ’Ñ‹ Ğ²Ñ‹ÑˆĞ»Ğ¸ Ğ¸Ğ· Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°",
  IR = () => "Ğ’Ğ¸Ñ…Ñ–Ğ´ Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ¾",
  CR = () => "ÄÃ£ Ä‘Äƒng xuáº¥t",
  AR = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? vR() : r === "pt" ? yR() : r === "ch" ? xR() : r === "de" ? bR() : r === "es" ? wR() : r === "fr" ? kR() : r === "it" ? TR() : r === "jp" ? PR() : r === "pl" ? SR() : r === "ru" ? MR() : r === "uk" ? IR() : CR()
  },
  zR = () => "This action will log your account out from all devices.",
  ER = () => "Essa aÃ§Ã£o ira desconectar sua conta de todos os dispositivos.",
  LR = () => "æ­¤æ“ä½œå°†ä½¿ä½ çš„è´¦å·åœ¨æ‰€æœ‰è®¾å¤‡ä¸Šç™»å‡ºã€‚",
  DR = () => "Diese Aktion meldet dein Konto auf allen GerÃ¤ten ab.",
  RR = () => "Esta acciÃ³n cerrarÃ¡ tu sesiÃ³n en todos los dispositivos.",
  jR = () => "Cette action dÃ©connectera votre compte de tous les appareils.",
  FR = () => "Questa azione disconnetterÃ  il tuo account da tutti i dispositivi.",
  BR = () => "ã“ã®æ“ä½œã«ã‚ˆã‚Šã€ã™ã¹ã¦ã®ç«¯æœ«ã‹ã‚‰ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒãƒ­ã‚°ã‚¢ã‚¦ãƒˆã•ã‚Œã¾ã™ã€‚",
  OR = () => "Ta akcja wyloguje Twoje konto ze wszystkich urzÄ…dzeÅ„.",
  qR = () => "Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ Ğ²Ğ°Ñˆ ÑĞµĞ°Ğ½Ñ Ğ½Ğ° Ğ²ÑĞµÑ… ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ°Ñ….",
  NR = () => "Ğ¦Ñ Ğ´Ñ–Ñ Ğ²Ğ¸Ğ²ĞµĞ´Ğµ Ğ²Ğ°Ñˆ Ğ°ĞºĞ°ÑƒĞ½Ñ‚ Ğ· ÑƒÑÑ–Ñ… Ğ¿Ñ€Ğ¸ÑÑ‚Ñ€Ğ¾Ñ—Ğ².",
  VR = () => "HÃ nh Ä‘á»™ng nÃ y sáº½ Ä‘Äƒng xuáº¥t tÃ i khoáº£n cá»§a báº¡n khá»i táº¥t cáº£ thiáº¿t bá»‹.",
  UR = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? zR() : r === "pt" ? ER() : r === "ch" ? LR() : r === "de" ? DR() : r === "es" ? RR() : r === "fr" ? jR() : r === "it" ? FR() : r === "jp" ? BR() : r === "pl" ? OR() : r === "ru" ? qR() : r === "uk" ? NR() : VR()
  },
  ZR = () => "My map is lagging",
  GR = () => "Meu mapa estÃ¡ travando",
  $R = () => "æˆ‘çš„åœ°å›¾å¾ˆå¡",
  WR = () => "Meine Karte laggt",
  HR = () => "Mi mapa va con lag",
  XR = () => "Ma carte lag",
  YR = () => "La mia mappa Ã¨ lenta",
  KR = () => "ãƒãƒƒãƒ—ã®å‹•ä½œãŒé‡ã„ã§ã™ã€‚",
  JR = () => "Mapa siÄ™ zacina",
  QR = () => "ĞšĞ°Ñ€Ñ‚Ğ° Ñ‚Ğ¾Ñ€Ğ¼Ğ¾Ğ·Ğ¸Ñ‚",
  ej = () => "ĞšĞ°Ñ€Ñ‚Ğ° Ğ³Ğ°Ğ»ÑŒĞ¼ÑƒÑ”",
  tj = () => "Báº£n Ä‘á»“ cá»§a tÃ´i Ä‘ang bá»‹ lag",
  rj = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? ZR() : r === "pt" ? GR() : r === "ch" ? $R() : r === "de" ? WR() : r === "es" ? HR() : r === "fr" ? XR() : r === "it" ? YR() : r === "jp" ? KR() : r === "pl" ? JR() : r === "ru" ? QR() : r === "uk" ? ej() : tj()
  },
  nj = () => "Mark all as read",
  ij = () => "Marcar tudo como lido",
  aj = () => "å…¨éƒ¨æ ‡è®°ä¸ºå·²è¯»",
  oj = () => "Alle als gelesen markieren",
  sj = () => "Marcar todo como leÃ­do",
  lj = () => "Tout marquer comme lu",
  cj = () => "Segna tutto come letto",
  uj = () => "ã™ã¹ã¦æ—¢èª­ã«ã™ã‚‹",
  hj = () => "Oznacz wszystko jako przeczytane",
  dj = () => "ĞÑ‚Ğ¼ĞµÑ‚Ğ¸Ñ‚ÑŒ Ğ²ÑÑ‘ ĞºĞ°Ğº Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ğ¾Ğµ",
  pj = () => "ĞŸĞ¾Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚Ğ¸ Ğ²ÑĞµ ÑĞº Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğµ",
  fj = () => "ÄÃ¡nh dáº¥u táº¥t cáº£ lÃ  Ä‘Ã£ Ä‘á»c",
  _j = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? nj() : r === "pt" ? ij() : r === "ch" ? aj() : r === "de" ? oj() : r === "es" ? sj() : r === "fr" ? lj() : r === "it" ? cj() : r === "jp" ? uj() : r === "pl" ? hj() : r === "ru" ? dj() : r === "uk" ? pj() : fj()
  },
  mj = () => "+2 max. charge/niveau",
  gj = () => "+2 tinta mÃ¡xima/level",
  vj = () => "æ¯çº§ +2 æœ€å¤§å……èƒ½",
  yj = () => "+2 max. Ladung/Level",
  xj = () => "+2 carga mÃ¡xima/nivel",
  bj = () => "+2 charge max/niveau",
  wj = () => "+2 cariche massime/livello",
  kj = () => "ãƒ¬ãƒ™ãƒ«ã”ã¨ã«æœ€å¤§ãƒãƒ£ãƒ¼ã‚¸ +2",
  Tj = () => "+2 maks. Å‚adunkÃ³w na poziom",
  Pj = () => "+2 Ğ¼Ğ°ĞºÑ. Ğ·Ğ°Ñ€ÑĞ´Ğ°/ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ",
  Sj = () => "+2 Ğ¼Ğ°ĞºÑ. Ğ·Ğ°Ñ€ÑĞ´/Ñ€Ñ–Ğ²ĞµĞ½ÑŒ",
  Mj = () => "+2 lÆ°á»£t tÃ´ tá»‘i Ä‘a má»—i cáº¥p",
  Ij = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? mj() : r === "pt" ? gj() : r === "ch" ? vj() : r === "de" ? yj() : r === "es" ? xj() : r === "fr" ? bj() : r === "it" ? wj() : r === "jp" ? kj() : r === "pl" ? Tj() : r === "ru" ? Pj() : r === "uk" ? Sj() : Mj()
  },
  Cj = () => "Menu",
  Aj = () => "Menu",
  zj = () => "èœå•",
  Ej = () => "MenÃ¼",
  Lj = () => "MenÃº",
  Dj = () => "Menu",
  Rj = () => "Menu",
  jj = () => "ãƒ¡ãƒ‹ãƒ¥ãƒ¼",
  Fj = () => "Menu",
  Bj = () => "ĞœĞµĞ½Ñ",
  Oj = () => "ĞœĞµĞ½Ñ",
  qj = () => "Menu",
  Nj = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Cj() : r === "pt" ? Aj() : r === "ch" ? zj() : r === "de" ? Ej() : r === "es" ? Lj() : r === "fr" ? Dj() : r === "it" ? Rj() : r === "jp" ? jj() : r === "pl" ? Fj() : r === "ru" ? Bj() : r === "uk" ? Oj() : qj()
  },
  Vj = () => "Month",
  Uj = () => "MÃªs",
  Zj = () => "æœˆ",
  Gj = () => "Monat",
  $j = () => "Mes",
  Wj = () => "Mois",
  Hj = () => "Mese",
  Xj = () => "æœˆ",
  Yj = () => "MiesiÄ…c",
  Kj = () => "ĞœĞµÑÑÑ†",
  Jj = () => "ĞœÑ–ÑÑÑ†ÑŒ",
  Qj = () => "ThÃ¡ng",
  e7 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Vj() : r === "pt" ? Uj() : r === "ch" ? Zj() : r === "de" ? Gj() : r === "es" ? $j() : r === "fr" ? Wj() : r === "it" ? Hj() : r === "jp" ? Xj() : r === "pl" ? Yj() : r === "ru" ? Kj() : r === "uk" ? Jj() : Qj()
  },
  t7 = () => "More",
  r7 = () => "Mais",
  n7 = () => "æ›´å¤š",
  i7 = () => "Mehr",
  a7 = () => "MÃ¡s",
  o7 = () => "Plus",
  s7 = () => "Altro",
  l7 = () => "ã‚‚ã£ã¨è¦‹ã‚‹",
  c7 = () => "WiÄ™cej",
  u7 = () => "Ğ•Ñ‰Ñ‘",
  h7 = () => "Ğ‘Ñ–Ğ»ÑŒÑˆĞµ",
  d7 = () => "ThÃªm",
  p7 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? t7() : r === "pt" ? r7() : r === "ch" ? n7() : r === "de" ? i7() : r === "es" ? a7() : r === "fr" ? o7() : r === "it" ? s7() : r === "jp" ? l7() : r === "pl" ? c7() : r === "ru" ? u7() : r === "uk" ? h7() : d7()
  },
  f7 = () => "Mute",
  _7 = () => "Mutar",
  m7 = () => "é™éŸ³",
  g7 = () => "Stummschalten",
  v7 = () => "Silenciar",
  y7 = () => "Muet",
  x7 = () => "Muta",
  b7 = () => "ãƒŸãƒ¥ãƒ¼ãƒˆ",
  w7 = () => "Wycisz",
  k7 = () => "Ğ—Ğ°Ğ¼ÑŒÑÑ‚Ğ¸Ñ‚ÑŒ",
  T7 = () => "Ğ—Ğ°Ğ³Ğ»ÑƒÑˆĞ¸Ñ‚Ğ¸",
  P7 = () => "Táº¯t tiáº¿ng",
  S7 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? f7() : r === "pt" ? _7() : r === "ch" ? m7() : r === "de" ? g7() : r === "es" ? v7() : r === "fr" ? y7() : r === "it" ? x7() : r === "jp" ? b7() : r === "pl" ? w7() : r === "ru" ? k7() : r === "uk" ? T7() : P7()
  },
  M7 = () => "My location",
  I7 = () => "Minha localizaÃ§Ã£o",
  C7 = () => "æˆ‘çš„ä½ç½®",
  A7 = () => "Mein Standort",
  z7 = () => "Mi ubicaciÃ³n",
  E7 = () => "Ma position",
  L7 = () => "La mia posizione",
  D7 = () => "ç¾åœ¨åœ°",
  R7 = () => "Moja lokalizacja",
  j7 = () => "ĞœĞ¾Ñ‘ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ",
  F7 = () => "ĞœĞ¾Ñ” Ğ¼Ñ–ÑÑ†ĞµĞ·Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¶ĞµĞ½Ğ½Ñ",
  B7 = () => "Vá»‹ trÃ­ cá»§a tÃ´i",
  O7 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? M7() : r === "pt" ? I7() : r === "ch" ? C7() : r === "de" ? A7() : r === "es" ? z7() : r === "fr" ? E7() : r === "it" ? L7() : r === "jp" ? D7() : r === "pl" ? R7() : r === "ru" ? j7() : r === "uk" ? F7() : B7()
  },
  q7 = () => "Name",
  N7 = () => "Nome",
  V7 = () => "åç§°",
  U7 = () => "Name",
  Z7 = () => "Nombre",
  G7 = () => "Nom",
  $7 = () => "Nome",
  W7 = () => "åå‰",
  H7 = () => "Nazwa",
  X7 = () => "Ğ˜Ğ¼Ñ",
  Y7 = () => "Ğ†Ğ¼Ê¼Ñ",
  K7 = () => "TÃªn",
  m_ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? q7() : r === "pt" ? N7() : r === "ch" ? V7() : r === "de" ? U7() : r === "es" ? Z7() : r === "fr" ? G7() : r === "it" ? $7() : r === "jp" ? W7() : r === "pl" ? H7() : r === "ru" ? X7() : r === "uk" ? Y7() : K7()
  },
  J7 = () => "Your name is how other users will see you in Wplace. It can be changed every 60 days.",
  Q7 = () => "Seu nome Ã© como outros usuÃ¡rios o verÃ£o no Wplace. VocÃª pode alterÃ¡-lo a cada 60 dias.",
  eF = () => "ä½ çš„åç§°æ˜¯å…¶ä»–ç©å®¶åœ¨ Wplace ä¸­çœ‹åˆ°çš„åå­—ã€‚æ¯ 60 å¤©å¯ä»¥æ›´æ”¹ä¸€æ¬¡ã€‚",
  tF = () => "Dein Name ist das, was andere Nutzer in Wplace sehen. Er kann alle 60 Tage geÃ¤ndert werden.",
  rF = () => "Tu nombre es cÃ³mo te verÃ¡n otros usuarios en Wplace. Se puede cambiar cada 60 dÃ­as.",
  nF = () => "Votre nom est celui que les autres utilisateurs verront dans Wplace. Vous pouvez le changer tous les 60 jours.",
  iF = () => "Il tuo nome Ã¨ come gli altri utenti ti vedranno su Wplace. Puoi cambiarlo ogni 60 giorni.",
  aF = () => "ã‚ãªãŸã®åå‰ã¯ã€Wplaceå†…ã§ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è¡¨ç¤ºã•ã‚Œã‚‹åå‰ã§ã™ã€‚60æ—¥ã«ä¸€åº¦å¤‰æ›´ã§ãã¾ã™ã€‚",
  oF = () => "Twoje imiÄ™ to to, jak inni uÅ¼ytkownicy widzÄ… CiÄ™ w Wplace. MoÅ¼na je zmieniaÄ‡ co 60 dni.",
  sF = () => "Ğ’Ğ°ÑˆĞµ Ğ¸Ğ¼Ñ â€” Ñ‚Ğ¾, ĞºĞ°Ğº Ğ²Ğ°Ñ Ğ²Ğ¸Ğ´ÑÑ‚ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ Ğ² Wplace. Ğ•Ğ³Ğ¾ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ñ€Ğ°Ğ· Ğ² 60 Ğ´Ğ½ĞµĞ¹.",
  lF = () => "Ğ’Ğ°ÑˆĞµ Ñ–Ğ¼Ê¼Ñ â€” Ñ†Ğµ Ñ‚Ğµ, ÑĞº Ñ–Ğ½ÑˆÑ– ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñ– Ğ±Ğ°Ñ‡Ğ¸Ñ‚Ğ¸Ğ¼ÑƒÑ‚ÑŒ Ğ²Ğ°Ñ Ñƒ Wplace. Ğ™Ğ¾Ğ³Ğ¾ Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ·Ğ¼Ñ–Ğ½ÑĞ²Ğ°Ñ‚Ğ¸ Ñ€Ğ°Ğ· Ğ½Ğ° 60 Ğ´Ğ½Ñ–Ğ².",
  cF = () => "TÃªn lÃ  cÃ¡ch ngÆ°á»i chÆ¡i khÃ¡c nhÃ¬n tháº¥y báº¡n trong Wplace. Báº¡n cÃ³ thá»ƒ Ä‘á»•i tÃªn má»—i 60 ngÃ y.",
  uF = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? J7() : r === "pt" ? Q7() : r === "ch" ? eF() : r === "de" ? tF() : r === "es" ? rF() : r === "fr" ? nF() : r === "it" ? iF() : r === "jp" ? aF() : r === "pl" ? oF() : r === "ru" ? sF() : r === "uk" ? lF() : cF()
  },
  hF = () => "No action",
  dF = () => "Sem opÃ§Ã£o",
  pF = () => "æ— æ“ä½œ",
  fF = () => "Keine Aktion",
  _F = () => "Sin acciÃ³n",
  mF = () => "Aucune action",
  gF = () => "Nessuna azione",
  vF = () => "å¯¾å¿œãªã—",
  yF = () => "Brak akcji",
  xF = () => "ĞĞµÑ‚ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ",
  bF = () => "ĞĞµĞ¼Ğ°Ñ” Ğ´Ñ–Ñ—",
  wF = () => "KhÃ´ng cÃ³ hÃ nh Ä‘á»™ng",
  kF = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? hF() : r === "pt" ? dF() : r === "ch" ? pF() : r === "de" ? fF() : r === "es" ? _F() : r === "fr" ? mF() : r === "it" ? gF() : r === "jp" ? vF() : r === "pl" ? yF() : r === "ru" ? xF() : r === "uk" ? bF() : wF()
  },
  TF = () => "No banned users",
  PF = () => "Sem usuÃ¡rios banidos",
  SF = () => "æ²¡æœ‰è¢«å°ç¦çš„ç”¨æˆ·",
  MF = () => "Keine gebannten Benutzer",
  IF = () => "No hay usuarios baneados",
  CF = () => "Aucun utilisateur banni",
  AF = () => "Nessun utente bannato",
  zF = () => "BANã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã„ã¾ã›ã‚“ã€‚",
  EF = () => "Brak zbanowanych uÅ¼ytkownikÃ³w",
  LF = () => "ĞĞµÑ‚ Ğ·Ğ°Ğ±Ğ°Ğ½ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹",
  DF = () => "ĞĞµĞ¼Ğ°Ñ” Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²Ğ°Ğ½Ğ¸Ñ… ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñ–Ğ²",
  RF = () => "KhÃ´ng cÃ³ ngÆ°á»i dÃ¹ng bá»‹ cáº¥m",
  jF = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? TF() : r === "pt" ? PF() : r === "ch" ? SF() : r === "de" ? MF() : r === "es" ? IF() : r === "fr" ? CF() : r === "it" ? AF() : r === "jp" ? zF() : r === "pl" ? EF() : r === "ru" ? LF() : r === "uk" ? DF() : RF()
  },
  FF = () => "No country found.",
  BF = () => "PaÃ­s nÃ£o encontrado.",
  OF = () => "æœªæ‰¾åˆ°å›½å®¶ã€‚",
  qF = () => "Kein Land gefunden.",
  NF = () => "No se encontrÃ³ ningÃºn paÃ­s.",
  VF = () => "Aucun pays trouvÃ©.",
  UF = () => "Paese non trovato.",
  ZF = () => "å›½ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚",
  GF = () => "Nie znaleziono kraju.",
  $F = () => "Ğ¡Ñ‚Ñ€Ğ°Ğ½Ğ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°.",
  WF = () => "ĞšÑ€Ğ°Ñ—Ğ½Ñƒ Ğ½Ğµ Ğ·Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾.",
  HF = () => "KhÃ´ng tÃ¬m tháº¥y quá»‘c gia.",
  XF = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? FF() : r === "pt" ? BF() : r === "ch" ? OF() : r === "de" ? qF() : r === "es" ? NF() : r === "fr" ? VF() : r === "it" ? UF() : r === "jp" ? ZF() : r === "pl" ? GF() : r === "ru" ? $F() : r === "uk" ? WF() : HF()
  },
  YF = () => "No description",
  KF = () => "Sem descriÃ§Ã£o",
  JF = () => "æ— æè¿°",
  QF = () => "Keine Beschreibung",
  eB = () => "Sin descripciÃ³n",
  tB = () => "Aucune description",
  rB = () => "Nessuna descrizione",
  nB = () => "èª¬æ˜ãªã—",
  iB = () => "Brak opisu",
  aB = () => "Ğ‘ĞµĞ· Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ",
  oB = () => "Ğ‘ĞµĞ· Ğ¾Ğ¿Ğ¸ÑÑƒ",
  sB = () => "KhÃ´ng cÃ³ mÃ´ táº£",
  R0 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? YF() : r === "pt" ? KF() : r === "ch" ? JF() : r === "de" ? QF() : r === "es" ? eB() : r === "fr" ? tB() : r === "it" ? rB() : r === "jp" ? nB() : r === "pl" ? iB() : r === "ru" ? aB() : r === "uk" ? oB() : sB()
  },
  lB = () => "ğŸš« No inappropriate content (+18, hate speech, inappropriate links, highly suggestive material, ...)",
  cB = () => "ğŸš« ConteÃºdo inapropriado nÃ£o permitido (+18, discurso de Ã³dio, links inapropriados, conteÃºdo altamente sugestivo, ...)",
  uB = () => "ğŸš« ä¸å…è®¸å‡ºç°ä¸å½“å†…å®¹ï¼ˆ+18ã€ä»‡æ¨è¨€è®ºã€ä¸å½“é“¾æ¥ã€é«˜åº¦æš—ç¤ºæ€§å†…å®¹ç­‰ï¼‰",
  hB = () => "ğŸš« Kein unangemessener Inhalt (+18, Hassrede, unangemessene Links, stark anzÃ¼gliches Material, ...)",
  dB = () => "ğŸš« Sin contenido inapropiado (+18, discurso de odio, enlaces inapropiados, contenido altamente sugerente, ...)",
  pB = () => "ğŸš« Aucun contenu inappropriÃ© (+18, discours haineux, liens inappropriÃ©s, contenu trÃ¨s suggestif, ...)",
  fB = () => "ğŸš« Contenuto inappropriato non consentito (+18, discorsi d'odio, link inappropriati, contenuto altamente esplicito, ...)",
  _B = () => "ğŸš« ä¸é©åˆ‡ãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯ç¦æ­¢ã§ã™ï¼ˆ18ç¦ã€ãƒ˜ã‚¤ãƒˆã‚¹ãƒ”ãƒ¼ãƒã€ä¸é©åˆ‡ãªãƒªãƒ³ã‚¯ã€éåº¦ã«æ€§çš„ãªå†…å®¹ãªã©ï¼‰ã€‚",
  mB = () => "ğŸš« Brak treÅ›ci nieodpowiednich (+18, mowa nienawiÅ›ci, nieodpowiednie linki, mocno sugestywne materiaÅ‚y, ...)",
  gB = () => "ğŸš« ĞĞ¸ĞºĞ°ĞºĞ¾Ğ³Ğ¾ Ğ½ĞµĞ¿Ñ€Ğ¸ĞµĞ¼Ğ»ĞµĞ¼Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ½Ñ‚ĞµĞ½Ñ‚Ğ° (+18, Ñ€ĞµÑ‡ÑŒ Ğ½ĞµĞ½Ğ°Ğ²Ğ¸ÑÑ‚Ğ¸, Ğ½ĞµĞ¿Ñ€Ğ¸ĞµĞ¼Ğ»ĞµĞ¼Ñ‹Ğµ ÑÑÑ‹Ğ»ĞºĞ¸, ĞºÑ€Ğ°Ğ¹Ğ½Ğµ Ğ¾Ñ‚ĞºÑ€Ğ¾Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ½Ñ‚ĞµĞ½Ñ‚ Ğ¸ Ñ‚.Ğ¿.)",
  vB = () => "ğŸš« Ğ–Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ½ĞµĞ¿Ñ€Ğ¸Ğ¹Ğ½ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ½Ñ‚ĞµĞ½Ñ‚Ñƒ (+18, Ğ¼Ğ¾Ğ²Ğ° Ğ²Ğ¾Ñ€Ğ¾Ğ¶Ğ½ĞµÑ‡Ñ–, Ğ½ĞµĞ¿Ñ€Ğ¸Ğ¹Ğ½ÑÑ‚Ğ½Ñ– Ğ¿Ğ¾ÑĞ¸Ğ»Ğ°Ğ½Ğ½Ñ, Ğ´ÑƒĞ¶Ğµ Ğ²Ñ–Ğ´Ğ²ĞµÑ€Ñ‚Ğ¸Ğ¹ ĞºĞ¾Ğ½Ñ‚ĞµĞ½Ñ‚, ...)",
  yB = () => "ğŸš« KhÃ´ng cho phÃ©p ná»™i dung khÃ´ng phÃ¹ há»£p (+18, ngÃ´n tá»« thÃ¹ háº±n, liÃªn káº¿t khÃ´ng phÃ¹ há»£p, ná»™i dung khiÃªu gá»£i máº¡nh, ...)",
  xB = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? lB() : r === "pt" ? cB() : r === "ch" ? uB() : r === "de" ? hB() : r === "es" ? dB() : r === "fr" ? pB() : r === "it" ? fB() : r === "jp" ? _B() : r === "pl" ? mB() : r === "ru" ? gB() : r === "uk" ? vB() : yB()
  },
  bB = () => "No more charges",
  wB = () => "Acabou a tinta",
  kB = () => "æ²¡æœ‰å‰©ä½™å……èƒ½",
  TB = () => "Keine Ladungen mehr",
  PB = () => "No tienes mÃ¡s cargas",
  SB = () => "Plus de charges",
  MB = () => "Vernice esaurita",
  IB = () => "ãƒãƒ£ãƒ¼ã‚¸ãŒæ®‹ã£ã¦ã„ã¾ã›ã‚“ã€‚",
  CB = () => "Brak Å‚adunkÃ³w",
  AB = () => "Ğ—Ğ°Ñ€ÑĞ´Ñ‹ Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ğ»Ğ¸ÑÑŒ",
  zB = () => "Ğ—Ğ°Ñ€ÑĞ´ Ğ·Ğ°ĞºÑ–Ğ½Ñ‡Ğ¸Ğ²ÑÑ",
  EB = () => "KhÃ´ng cÃ²n lÆ°á»£t tÃ´",
  LB = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? bB() : r === "pt" ? wB() : r === "ch" ? kB() : r === "de" ? TB() : r === "es" ? PB() : r === "fr" ? SB() : r === "it" ? MB() : r === "jp" ? IB() : r === "pl" ? CB() : r === "ru" ? AB() : r === "uk" ? zB() : EB()
  },
  DB = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ Do not paint with more than one account",
  RB = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ NÃ£o desenhe com mais de uma conta",
  jB = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ è¯·å‹¿ä½¿ç”¨å¤šä¸ªè´¦å·è¿›è¡Œç»˜åˆ¶",
  FB = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ Verwende nicht mehr als ein Konto zum Malen",
  BB = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ No pintes con mÃ¡s de una cuenta",
  OB = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ Ne dessinez pas avec plus dâ€™un compte",
  qB = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ Non disegnare con piÃ¹ di un account",
  NB = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ è¤‡æ•°ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒšã‚¤ãƒ³ãƒˆã—ãªã„ã§ãã ã•ã„ã€‚",
  VB = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ Nie maluj, uÅ¼ywajÄ…c wiÄ™cej niÅ¼ jednego konta",
  UB = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ ĞĞµĞ»ÑŒĞ·Ñ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ñ Ğ±Ğ¾Ğ»ĞµĞµ Ñ‡ĞµĞ¼ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°",
  ZB = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ ĞĞµ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ¹Ñ‚Ğµ Ğ±Ñ–Ğ»ÑŒÑˆĞµ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ°ĞºĞ°ÑƒĞ½Ñ‚Ğ°",
  GB = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ KhÃ´ng tÃ´ báº±ng nhiá»u hÆ¡n má»™t tÃ i khoáº£n",
  $B = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? DB() : r === "pt" ? RB() : r === "ch" ? jB() : r === "de" ? FB() : r === "es" ? BB() : r === "fr" ? OB() : r === "it" ? qB() : r === "jp" ? NB() : r === "pl" ? VB() : r === "ru" ? UB() : r === "uk" ? ZB() : GB()
  },
  WB = () => "You are not allowed to use multiple accounts. Use your main account to paint.",
  HB = () => "NÃ£o Ã© permitido usar vÃ¡rias contas. Use sua conta principal para pintar.",
  XB = () => "ä½ ä¸èƒ½ä½¿ç”¨å¤šä¸ªè´¦å·ã€‚è¯·ä½¿ç”¨ä½ çš„ä¸»è´¦å·è¿›è¡Œç»˜åˆ¶ã€‚",
  YB = () => "Es ist nicht erlaubt, mehrere Konten zu verwenden. Nutze dein Hauptkonto zum Malen.",
  KB = () => "No estÃ¡ permitido usar varias cuentas. Usa tu cuenta principal para pintar.",
  JB = () => "Lâ€™utilisation de plusieurs comptes nâ€™est pas autorisÃ©e. Utilisez votre compte principal pour peindre.",
  QB = () => "Non Ã¨ consentito usare piÃ¹ account. Usa il tuo account principale per dipingere.",
  e9 = () => "è¤‡æ•°ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚ãƒ¡ã‚¤ãƒ³ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒšã‚¤ãƒ³ãƒˆã—ã¦ãã ã•ã„ã€‚",
  t9 = () => "Nie moÅ¼esz uÅ¼ywaÄ‡ wielu kont. UÅ¼yj swojego gÅ‚Ã³wnego konta do malowania.",
  r9 = () => "Ğ—Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ¾Ğ². Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚ Ğ´Ğ»Ñ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¸Ñ.",
  n9 = () => "Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ²Ğ°Ñ‚Ğ¸ ĞºÑ–Ğ»ÑŒĞºĞ° Ğ°ĞºĞ°ÑƒĞ½Ñ‚Ñ–Ğ² Ğ·Ğ°Ğ±Ğ¾Ñ€Ğ¾Ğ½ĞµĞ½Ğ¾. Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ¹Ñ‚Ğµ ÑĞ²Ñ–Ğ¹ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¸Ğ¹ Ğ°ĞºĞ°ÑƒĞ½Ñ‚ Ğ´Ğ»Ñ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ.",
  i9 = () => "Báº¡n khÃ´ng Ä‘Æ°á»£c phÃ©p sá»­ dá»¥ng nhiá»u tÃ i khoáº£n. HÃ£y dÃ¹ng tÃ i khoáº£n chÃ­nh cá»§a báº¡n Ä‘á»ƒ tÃ´.",
  a9 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? WB() : r === "pt" ? HB() : r === "ch" ? XB() : r === "de" ? YB() : r === "es" ? KB() : r === "fr" ? JB() : r === "it" ? QB() : r === "jp" ? e9() : r === "pl" ? t9() : r === "ru" ? r9() : r === "uk" ? n9() : i9()
  },
  o9 = () => "No notifications",
  s9 = () => "Nenhuma notificaÃ§Ã£o",
  l9 = () => "æ²¡æœ‰é€šçŸ¥",
  c9 = () => "Keine Benachrichtigungen",
  u9 = () => "No hay notificaciones",
  h9 = () => "Aucune notification",
  d9 = () => "Nessuna notifica",
  p9 = () => "é€šçŸ¥ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚",
  f9 = () => "Brak powiadomieÅ„",
  _9 = () => "ĞĞµÑ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹",
  m9 = () => "ĞĞµĞ¼Ğ°Ñ” ÑĞ¿Ğ¾Ğ²Ñ–Ñ‰ĞµĞ½ÑŒ",
  g9 = () => "KhÃ´ng cÃ³ thÃ´ng bÃ¡o",
  v9 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? o9() : r === "pt" ? s9() : r === "ch" ? l9() : r === "de" ? c9() : r === "es" ? u9() : r === "fr" ? h9() : r === "it" ? d9() : r === "jp" ? p9() : r === "pl" ? f9() : r === "ru" ? _9() : r === "uk" ? m9() : g9()
  },
  y9 = () => "No pixels painted",
  x9 = () => "Nenhum pixel pintado",
  b9 = () => "å°šæœªç»˜åˆ¶åƒç´ ",
  w9 = () => "Keine Pixel gemalt",
  k9 = () => "No se han pintado pÃ­xeles",
  T9 = () => "Aucun pixel peint",
  P9 = () => "Nessun pixel dipinto",
  S9 = () => "ã¾ã ãƒ”ã‚¯ã‚»ãƒ«ãŒå¡—ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã€‚",
  M9 = () => "Brak pomalowanych pikseli",
  I9 = () => "ĞĞµÑ‚ Ğ½Ğ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¸ĞºÑĞµĞ»ĞµĞ¹",
  C9 = () => "Ğ–Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ñ–ĞºÑĞµĞ»Ñ Ğ½Ğµ Ğ½Ğ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ğ¾",
  A9 = () => "ChÆ°a cÃ³ pixel nÃ o Ä‘Æ°á»£c tÃ´",
  cm = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? y9() : r === "pt" ? x9() : r === "ch" ? b9() : r === "de" ? w9() : r === "es" ? k9() : r === "fr" ? T9() : r === "it" ? P9() : r === "jp" ? S9() : r === "pl" ? M9() : r === "ru" ? I9() : r === "uk" ? C9() : A9()
  },
  z9 = () => "No place found",
  E9 = () => "Nenhum local encontrado",
  L9 = () => "æœªæ‰¾åˆ°åœ°ç‚¹",
  D9 = () => "Kein Ort gefunden",
  R9 = () => "No se encontrÃ³ ningÃºn lugar",
  j9 = () => "Aucun endroit trouvÃ©",
  F9 = () => "Nessun luogo trovato",
  B9 = () => "å ´æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚",
  O9 = () => "Nie znaleziono miejsca",
  q9 = () => "ĞœĞµÑÑ‚Ğ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹",
  N9 = () => "ĞœÑ–ÑÑ†Ğµ Ğ½Ğµ Ğ·Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾",
  V9 = () => "KhÃ´ng tÃ¬m tháº¥y Ä‘á»‹a Ä‘iá»ƒm nÃ o",
  U9 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? z9() : r === "pt" ? E9() : r === "ch" ? L9() : r === "de" ? D9() : r === "es" ? R9() : r === "fr" ? j9() : r === "it" ? F9() : r === "jp" ? B9() : r === "pl" ? O9() : r === "ru" ? q9() : r === "uk" ? N9() : V9()
  },
  Z9 = () => "No recent locations",
  G9 = () => "Nenhum local recente",
  $9 = () => "æš‚æ— æœ€è¿‘ä½ç½®",
  W9 = () => "Keine besuchten Orte",
  H9 = () => "No hay ubicaciones recientes",
  X9 = () => "Aucun emplacement rÃ©cent",
  Y9 = () => "Nessuna localitÃ  recente",
  K9 = () => "æœ€è¿‘ã®å ´æ‰€ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚",
  J9 = () => "Brak ostatnich lokalizacji",
  Q9 = () => "ĞĞµÑ‚ Ğ½ĞµĞ´Ğ°Ğ²Ğ½Ğ¸Ñ… Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¹",
  eO = () => "ĞĞµĞ¼Ğ°Ñ” Ğ½ĞµÑ‰Ğ¾Ğ´Ğ°Ğ²Ğ½Ñ–Ñ… Ğ»Ğ¾ĞºĞ°Ñ†Ñ–Ğ¹",
  tO = () => "KhÃ´ng cÃ³ vá»‹ trÃ­ gáº§n Ä‘Ã¢y",
  rO = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Z9() : r === "pt" ? G9() : r === "ch" ? $9() : r === "de" ? W9() : r === "es" ? H9() : r === "fr" ? X9() : r === "it" ? Y9() : r === "jp" ? K9() : r === "pl" ? J9() : r === "ru" ? Q9() : r === "uk" ? eO() : tO()
  },
  nO = () => "No corresponding region on the map (cosmetic effect only)",
  iO = () => "NÃ£o possui regiÃ£o no mapa (apenas efeito cosmÃ©tico)",
  aO = () => "åœ¨åœ°å›¾ä¸Šæ²¡æœ‰å¯¹åº”åŒºåŸŸï¼ˆä»…è£…é¥°æ•ˆæœï¼‰",
  oO = () => "Keine entsprechende Region auf der Karte (nur kosmetischer Effekt)",
  sO = () => "Sin regiÃ³n correspondiente en el mapa (solo efecto cosmÃ©tico)",
  lO = () => "Aucune rÃ©gion correspondante sur la carte (effet cosmÃ©tique seulement)",
  cO = () => "Non ha una regione sulla mappa (solo effetto cosmetico)",
  uO = () => "ãƒãƒƒãƒ—ä¸Šã«å¯¾å¿œã™ã‚‹åœ°åŸŸã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆè¦‹ãŸç›®ã®ã¿ã®åŠ¹æœï¼‰ã€‚",
  hO = () => "Brak odpowiadajÄ…cego regionu na mapie (tylko efekt kosmetyczny)",
  dO = () => "ĞĞµÑ‚ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ¹ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ğ¸ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ğµ (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾ÑĞ¼ĞµÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ ÑÑ„Ñ„ĞµĞºÑ‚)",
  pO = () => "ĞĞµĞ¼Ğ°Ñ” Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ½Ğ¾Ñ— Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ñ– Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ñ– (Ğ»Ğ¸ÑˆĞµ ĞºĞ¾ÑĞ¼ĞµÑ‚Ğ¸Ñ‡Ğ½Ğ¸Ğ¹ ĞµÑ„ĞµĞºÑ‚)",
  fO = () => "KhÃ´ng cÃ³ vÃ¹ng tÆ°Æ¡ng á»©ng trÃªn báº£n Ä‘á»“ (chá»‰ cÃ³ tÃ¡c dá»¥ng trang trÃ­)",
  _O = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? nO() : r === "pt" ? iO() : r === "ch" ? aO() : r === "de" ? oO() : r === "es" ? sO() : r === "fr" ? lO() : r === "it" ? cO() : r === "jp" ? uO() : r === "pl" ? hO() : r === "ru" ? dO() : r === "uk" ? pO() : fO()
  },
  mO = () => "ğŸ¤– Use of bots is not allowed",
  gO = () => "ğŸ¤– Usar bots nÃ£o Ã© permitido",
  vO = () => "ğŸ¤– ä¸å…è®¸ä½¿ç”¨æœºå™¨äººæˆ–è„šæœ¬",
  yO = () => "ğŸ¤– Das Verwenden von Bots ist verboten",
  xO = () => "ğŸ¤– No se permite el uso de bots",
  bO = () => "ğŸ¤– Lâ€™utilisation de bots nâ€™est pas autorisÃ©e",
  wO = () => "ğŸ¤– L'uso di bot non Ã¨ consentito",
  kO = () => "ğŸ¤– ãƒœãƒƒãƒˆã®ä½¿ç”¨ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚",
  TO = () => "ğŸ¤– UÅ¼ywanie botÃ³w jest zabronione",
  PO = () => "ğŸ¤– Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ±Ğ¾Ñ‚Ğ¾Ğ² Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½Ğ¾",
  SO = () => "ğŸ¤– Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ğ½Ğ½Ñ Ğ±Ğ¾Ñ‚Ñ–Ğ² Ğ·Ğ°Ğ±Ğ¾Ñ€Ğ¾Ğ½ĞµĞ½Ğ¾",
  MO = () => "ğŸ¤– KhÃ´ng Ä‘Æ°á»£c phÃ©p sá»­ dá»¥ng bot",
  IO = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? mO() : r === "pt" ? gO() : r === "ch" ? vO() : r === "de" ? yO() : r === "es" ? xO() : r === "fr" ? bO() : r === "it" ? wO() : r === "jp" ? kO() : r === "pl" ? TO() : r === "ru" ? PO() : r === "uk" ? SO() : MO()
  },
  CO = () => "Not enough Droplets",
  AO = () => "Droplets insuficientes",
  zO = () => "æ°´æ»´æ•°é‡ä¸è¶³",
  EO = () => "Nicht genug Droplets",
  LO = () => "No tienes suficientes gotas",
  DO = () => "Pas assez de droplets",
  RO = () => "Gocce insufficienti",
  jO = () => "ãƒ‰ãƒ­ãƒƒãƒ—ãƒ¬ãƒƒãƒˆãŒè¶³ã‚Šã¾ã›ã‚“ã€‚",
  FO = () => "Za maÅ‚o kropli",
  BO = () => "ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ droplets",
  OO = () => "ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ½ÑŒĞ¾ Ğ´Ñ€Ğ¾Ğ¿Ğ»ĞµÑ‚Ñ–Ğ²",
  qO = () => "KhÃ´ng Ä‘á»§ droplets",
  Op = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? CO() : r === "pt" ? AO() : r === "ch" ? zO() : r === "de" ? EO() : r === "es" ? LO() : r === "fr" ? DO() : r === "it" ? RO() : r === "jp" ? jO() : r === "pl" ? FO() : r === "ru" ? BO() : r === "uk" ? OO() : qO()
  },
  NO = () => "You are not in an alliance",
  VO = () => "VocÃª nÃ£o estÃ¡ em uma alianÃ§a",
  UO = () => "ä½ ä¸åœ¨ä»»ä½•è”ç›Ÿä¸­",
  ZO = () => "Du bist in keiner Allianz",
  GO = () => "No estÃ¡s en una alianza",
  $O = () => "Vous nâ€™Ãªtes pas dans une alliance",
  WO = () => "Non sei in un'alleanza",
  HO = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã«æ‰€å±ã—ã¦ã„ã¾ã›ã‚“ã€‚",
  XO = () => "Nie jesteÅ› w Å¼adnym sojuszu",
  YO = () => "Ğ’Ñ‹ Ğ½Ğµ ÑĞ¾ÑÑ‚Ğ¾Ğ¸Ñ‚Ğµ Ğ² Ğ°Ğ»ÑŒÑĞ½ÑĞµ",
  KO = () => "Ğ’Ğ¸ Ğ½Ğµ Ğ¿ĞµÑ€ĞµĞ±ÑƒĞ²Ğ°Ñ”Ñ‚Ğµ Ğ² Ğ°Ğ»ÑŒÑĞ½ÑÑ–",
  JO = () => "Báº¡n khÃ´ng á»Ÿ trong liÃªn minh nÃ o",
  QO = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? NO() : r === "pt" ? VO() : r === "ch" ? UO() : r === "de" ? ZO() : r === "es" ? GO() : r === "fr" ? $O() : r === "it" ? WO() : r === "jp" ? HO() : r === "pl" ? XO() : r === "ru" ? YO() : r === "uk" ? KO() : JO()
  },
  eq = () => "Not painted",
  tq = () => "NÃ£o pintado",
  rq = () => "æœªç»˜åˆ¶",
  nq = () => "Nicht gemalt",
  iq = () => "No pintado",
  aq = () => "Non peint",
  oq = () => "Non dipinto",
  sq = () => "æœªå¡—ã‚Š",
  lq = () => "Niezamalowane",
  cq = () => "ĞĞµ Ğ½Ğ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¾",
  uq = () => "ĞĞµ Ğ½Ğ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ğ¾",
  hq = () => "ChÆ°a tÃ´",
  dq = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? eq() : r === "pt" ? tq() : r === "ch" ? rq() : r === "de" ? nq() : r === "es" ? iq() : r === "fr" ? aq() : r === "it" ? oq() : r === "jp" ? sq() : r === "pl" ? lq() : r === "ru" ? cq() : r === "uk" ? uq() : hq()
  },
  pq = () => "Not set",
  fq = () => "NÃ£o configurado",
  _q = () => "æœªè®¾ç½®",
  mq = () => "Nicht gesetzt",
  gq = () => "No establecido",
  vq = () => "Non dÃ©fini",
  yq = () => "Non impostato",
  xq = () => "æœªè¨­å®š",
  bq = () => "Nie ustawiono",
  wq = () => "ĞĞµ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¾",
  kq = () => "ĞĞµ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¾",
  Tq = () => "ChÆ°a Ä‘áº·t",
  Pq = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? pq() : r === "pt" ? fq() : r === "ch" ? _q() : r === "de" ? mq() : r === "es" ? gq() : r === "fr" ? vq() : r === "it" ? yq() : r === "jp" ? xq() : r === "pl" ? bq() : r === "ru" ? wq() : r === "uk" ? kq() : Tq()
  },
  Sq = () => "Notifications",
  Mq = () => "NotificaÃ§Ãµes",
  Iq = () => "é€šçŸ¥",
  Cq = () => "Benachrichtigungen",
  Aq = () => "Notificaciones",
  zq = () => "Notifications",
  Eq = () => "Notifiche",
  Lq = () => "é€šçŸ¥",
  Dq = () => "Powiadomienia",
  Rq = () => "Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ",
  jq = () => "Ğ¡Ğ¿Ğ¾Ğ²Ñ–Ñ‰ĞµĞ½Ğ½Ñ",
  Fq = () => "ThÃ´ng bÃ¡o",
  j0 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Sq() : r === "pt" ? Mq() : r === "ch" ? Iq() : r === "de" ? Cq() : r === "es" ? Aq() : r === "fr" ? zq() : r === "it" ? Eq() : r === "jp" ? Lq() : r === "pl" ? Dq() : r === "ru" ? Rq() : r === "uk" ? jq() : Fq()
  },
  Bq = () => "Offline",
  Oq = () => "Desconectado",
  qq = () => "ç¦»çº¿",
  Nq = () => "Offline",
  Vq = () => "Desconectado",
  Uq = () => "Hors ligne",
  Zq = () => "Offline",
  Gq = () => "ã‚ªãƒ•ãƒ©ã‚¤ãƒ³",
  $q = () => "Offline",
  Wq = () => "ĞÑ„Ñ„Ğ»Ğ°Ğ¹Ğ½",
  Hq = () => "ĞÑ„Ğ»Ğ°Ğ¹Ğ½",
  Xq = () => "Ngoáº¡i tuyáº¿n",
  Yq = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Bq() : r === "pt" ? Oq() : r === "ch" ? qq() : r === "de" ? Nq() : r === "es" ? Vq() : r === "fr" ? Uq() : r === "it" ? Zq() : r === "jp" ? Gq() : r === "pl" ? $q() : r === "ru" ? Wq() : r === "uk" ? Hq() : Xq()
  },
  Kq = () => "on the top right corner of the screen. This will lock the screen but it'll also enable painting by moving your finger over the map.",
  Jq = () => "no canto superior direito da tela. Isso bloquearÃ¡ a tela, mas tambÃ©m permitirÃ¡ pintar movendo o dedo sobre o mapa.",
  Qq = () => "åœ¨å±å¹•å³ä¸Šè§’ã€‚æ­¤æ“ä½œä¼šé”å®šå±å¹•ï¼Œä½†åŒæ—¶å¯ä»¥é€šè¿‡ç§»åŠ¨æ‰‹æŒ‡åœ¨åœ°å›¾ä¸Šè¿›è¡Œç»˜åˆ¶ã€‚",
  eN = () => "in der oberen rechten Ecke des Bildschirms. Dadurch wird der Bildschirm gesperrt, aber du kannst durch Bewegen deines Fingers Ã¼ber die Karte malen.",
  tN = () => "en la esquina superior derecha de la pantalla. Esto bloquearÃ¡ la pantalla pero tambiÃ©n permitirÃ¡ pintar moviendo el dedo sobre el mapa.",
  rN = () => "dans le coin supÃ©rieur droit de lâ€™Ã©cran. Cela verrouille lâ€™Ã©cran mais permet de peindre en dÃ©plaÃ§ant votre doigt sur la carte.",
  nN = () => "nell'angolo in alto a destra dello schermo. Questo bloccherÃ  lo schermo, ma ti permetterÃ  di dipingere muovendo il dito sulla mappa.",
  iN = () => "ç”»é¢å³ä¸Šã®ãƒœã‚¿ãƒ³ã§ã™ã€‚ç”»é¢ã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã™ãŒã€æŒ‡ã‚’ãƒãƒƒãƒ—ä¸Šã§å‹•ã‹ã™ã“ã¨ã§ãƒšã‚¤ãƒ³ãƒˆã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚",
  aN = () => "w prawym gÃ³rnym rogu ekranu. To zablokuje ekran, ale umoÅ¼liwi malowanie poprzez przesuwanie palcem po mapie.",
  oN = () => "Ğ² Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğ¼ Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ¼ ÑƒĞ³Ğ»Ñƒ ÑĞºÑ€Ğ°Ğ½Ğ°. Ğ­ĞºÑ€Ğ°Ğ½ Ğ±ÑƒĞ´ĞµÑ‚ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½, Ğ½Ğ¾ Ğ¿Ñ€Ğ¸ ÑÑ‚Ğ¾Ğ¼ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ, Ğ¿Ñ€Ğ¾Ğ²Ğ¾Ğ´Ñ Ğ¿Ğ°Ğ»ÑŒÑ†ĞµĞ¼ Ğ¿Ğ¾ ĞºĞ°Ñ€Ñ‚Ğµ.",
  sN = () => "Ñƒ Ğ²ĞµÑ€Ñ…Ğ½ÑŒĞ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğ¼Ñƒ ĞºÑƒÑ‚Ñ– ĞµĞºÑ€Ğ°Ğ½Ğ°. Ğ¦Ğµ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºÑƒÑ” ĞµĞºÑ€Ğ°Ğ½, Ğ°Ğ»Ğµ Ğ´Ğ¾Ğ·Ğ²Ğ¾Ğ»Ğ¸Ñ‚ÑŒ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸, Ğ¿Ñ€Ğ¾Ğ²Ğ¾Ğ´ÑÑ‡Ğ¸ Ğ¿Ğ°Ğ»ÑŒÑ†ĞµĞ¼ Ğ¿Ğ¾ ĞºĞ°Ñ€Ñ‚Ñ–.",
  lN = () => "á»Ÿ gÃ³c trÃªn bÃªn pháº£i mÃ n hÃ¬nh. Äiá»u nÃ y sáº½ khÃ³a mÃ n hÃ¬nh nhÆ°ng cho phÃ©p báº¡n tÃ´ báº±ng cÃ¡ch rÃª ngÃ³n tay trÃªn báº£n Ä‘á»“.",
  cN = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Kq() : r === "pt" ? Jq() : r === "ch" ? Qq() : r === "de" ? eN() : r === "es" ? tN() : r === "fr" ? rN() : r === "it" ? nN() : r === "jp" ? iN() : r === "pl" ? aN() : r === "ru" ? oN() : r === "uk" ? sN() : lN()
  },
  uN = () => "OpenMapTiles Data from",
  hN = () => "OpenMapTiles com dados do",
  dN = () => "åœ°å›¾æ•°æ®æ¥è‡ª OpenMapTiles",
  pN = () => "OpenMapTiles Daten von",
  fN = () => "Datos de OpenMapTiles de",
  _N = () => "DonnÃ©es OpenMapTiles de",
  mN = () => "OpenMapTiles con dati da",
  gN = () => "OpenMapTiles ãƒ‡ãƒ¼ã‚¿æä¾›:",
  vN = () => "Dane OpenMapTiles z",
  yN = () => "Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ OpenMapTiles Ğ¾Ñ‚",
  xN = () => "Ğ”Ğ°Ğ½Ñ– OpenMapTiles Ğ²Ñ–Ğ´",
  bN = () => "Dá»¯ liá»‡u OpenMapTiles tá»«",
  wN = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? uN() : r === "pt" ? hN() : r === "ch" ? dN() : r === "de" ? pN() : r === "es" ? fN() : r === "fr" ? _N() : r === "it" ? mN() : r === "jp" ? gN() : r === "pl" ? vN() : r === "ru" ? yN() : r === "uk" ? xN() : bN()
  },
  kN = () => "or hold",
  TN = () => "ou segure",
  PN = () => "æˆ–æŒ‰ä½",
  SN = () => "oder",
  MN = () => "o mantÃ©n pulsado",
  IN = () => "ou maintenez",
  CN = () => "o tieni premuto",
  AN = () => "ã¾ãŸã¯é•·æŠ¼ã—",
  zN = () => "lub przytrzymaj",
  EN = () => "Ğ¸Ğ»Ğ¸ ÑƒĞ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ",
  LN = () => "Ğ°Ğ±Ğ¾ ÑƒÑ‚Ñ€Ğ¸Ğ¼ÑƒĞ¹Ñ‚Ğµ",
  DN = () => "hoáº·c giá»¯",
  RN = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? kN() : r === "pt" ? TN() : r === "ch" ? PN() : r === "de" ? SN() : r === "es" ? MN() : r === "fr" ? IN() : r === "it" ? CN() : r === "jp" ? AN() : r === "pl" ? zN() : r === "ru" ? EN() : r === "uk" ? LN() : DN()
  },
  jN = () => "Overview",
  FN = () => "VisÃ£o Geral",
  BN = () => "æ¦‚è§ˆ",
  ON = () => "Ãœbersicht",
  qN = () => "Resumen",
  NN = () => "Vue dâ€™ensemble",
  VN = () => "Panoramica",
  UN = () => "æ¦‚è¦",
  ZN = () => "PrzeglÄ…d",
  GN = () => "ĞĞ±Ğ·Ğ¾Ñ€",
  $N = () => "ĞĞ³Ğ»ÑĞ´",
  WN = () => "Tá»•ng quan",
  HN = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? jN() : r === "pt" ? FN() : r === "ch" ? BN() : r === "de" ? ON() : r === "es" ? qN() : r === "fr" ? NN() : r === "it" ? VN() : r === "jp" ? UN() : r === "pl" ? ZN() : r === "ru" ? GN() : r === "uk" ? $N() : WN()
  },
  XN = () => "Paint",
  YN = () => "Pintar",
  KN = () => "ç»˜ç”»",
  JN = () => "Malen",
  QN = () => "Pintar",
  eV = () => "Peindre",
  tV = () => "Dipingi",
  rV = () => "ãƒšã‚¤ãƒ³ãƒˆ",
  nV = () => "Maluj",
  iV = () => "Ğ Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ",
  aV = () => "ĞœĞ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸",
  oV = () => "TÃ´",
  F0 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? XN() : r === "pt" ? YN() : r === "ch" ? KN() : r === "de" ? JN() : r === "es" ? QN() : r === "fr" ? eV() : r === "it" ? tV() : r === "jp" ? rV() : r === "pl" ? nV() : r === "ru" ? iV() : r === "uk" ? aV() : oV()
  },
  sV = () => "Paint pixel",
  lV = () => "Pintar pixel",
  cV = () => "ç»˜åˆ¶åƒç´ ",
  uV = () => "Pixel malen",
  hV = () => "Pintar pÃ­xel",
  dV = () => "Peindre un pixel",
  pV = () => "Dipingere pixel",
  fV = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚’å¡—ã‚‹",
  _V = () => "Pomaluj piksel",
  mV = () => "ĞĞ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ",
  gV = () => "ĞĞ°Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ğ¿Ñ–ĞºÑĞµĞ»ÑŒ",
  vV = () => "TÃ´ pixel",
  yV = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? sV() : r === "pt" ? lV() : r === "ch" ? cV() : r === "de" ? uV() : r === "es" ? hV() : r === "fr" ? dV() : r === "it" ? pV() : r === "jp" ? fV() : r === "pl" ? _V() : r === "ru" ? mV() : r === "uk" ? gV() : vV()
  },
  xV = () => "Painted",
  bV = () => "Pintados",
  wV = () => "å·²ç»˜åˆ¶",
  kV = () => "gemalt",
  TV = () => "Pintado",
  PV = () => "Peints",
  SV = () => "Dipinti",
  MV = () => "å¡—ã‚‰ã‚ŒãŸ",
  IV = () => "Pomalowane",
  CV = () => "ĞĞ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¾",
  AV = () => "ĞĞ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ğ¾",
  zV = () => "ÄÃ£ tÃ´",
  Ac = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? xV() : r === "pt" ? bV() : r === "ch" ? wV() : r === "de" ? kV() : r === "es" ? TV() : r === "fr" ? PV() : r === "it" ? SV() : r === "jp" ? MV() : r === "pl" ? IV() : r === "ru" ? CV() : r === "uk" ? AV() : zV()
  },
  EV = () => "Painted by",
  LV = () => "Pintado por",
  DV = () => "ç»˜åˆ¶è€…",
  RV = () => "Gemalt von",
  jV = () => "Pintado por",
  FV = () => "Peint par",
  BV = () => "Dipinto da",
  OV = () => "å¡—ã£ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼",
  qV = () => "Pomalowane przez",
  NV = () => "ĞĞ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¾",
  VV = () => "ĞĞ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ğ¾",
  UV = () => "ÄÆ°á»£c tÃ´ bá»Ÿi",
  ZV = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? EV() : r === "pt" ? LV() : r === "ch" ? DV() : r === "de" ? RV() : r === "es" ? jV() : r === "fr" ? FV() : r === "it" ? BV() : r === "jp" ? OV() : r === "pl" ? qV() : r === "ru" ? NV() : r === "uk" ? VV() : UV()
  },
  GV = () => "âœ… Painting over other artworks to complement them or create a new drawing is allowed",
  $V = () => "âœ… Desenhar sobre outras artes para complementar ou criar novas artes Ã© permitido",
  WV = () => "âœ… åœ¨ä¸ç ´åä½œå“çš„å‰æä¸‹ï¼Œå¯¹ä»–äººä½œå“è¿›è¡Œè¡¥å……æˆ–åˆ›ä½œæ–°å›¾æ˜¯å…è®¸çš„",
  HV = () => "âœ… Ãœber andere Kunstwerke zu malen, um sie zu ergÃ¤nzen oder ein neues Bild zu erstellen, ist erlaubt",
  XV = () => "âœ… Pintar sobre las obras de otros para complementarlas o crear un nuevo dibujo estÃ¡ permitido",
  YV = () => "âœ… Peindre par-dessus dâ€™autres Å“uvres pour les complÃ©ter ou crÃ©er un nouveau dessin est autorisÃ©",
  KV = () => "âœ… Disegnare sopra le opere altrui per completarle o creare nuove opere Ã¨ consentito",
  JV = () => "âœ… ä»–äººã®ä½œå“ã‚’è£œå®Œã—ãŸã‚Šã€æ–°ã—ã„çµµã‚’ä½œã‚‹ç›®çš„ã§ä¸Šã‹ã‚‰æãè¶³ã™ã“ã¨ã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã™ã€‚",
  QV = () => "âœ… Malowanie po cudzych pracach, aby je uzupeÅ‚niÄ‡ lub stworzyÄ‡ nowy rysunek, jest dozwolone",
  eU = () => "âœ… Ğ Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ñ‡ÑƒĞ¶Ğ¸Ñ… Ñ€Ğ°Ğ±Ğ¾Ñ‚, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ Ğ¸Ñ… Ğ¸Ğ»Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ€Ğ¸ÑÑƒĞ½Ğ¾Ğº, Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¾",
  tU = () => "âœ… ĞœĞ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ñ‡ÑƒĞ¶Ğ¸Ñ… Ñ€Ğ¾Ğ±Ñ–Ñ‚, Ñ‰Ğ¾Ğ± Ğ´Ğ¾Ğ¿Ğ¾Ğ²Ğ½Ğ¸Ñ‚Ğ¸ Ñ—Ñ… Ğ°Ğ±Ğ¾ ÑÑ‚Ğ²Ğ¾Ñ€Ğ¸Ñ‚Ğ¸ Ğ½Ğ¾Ğ²Ğ¸Ğ¹ Ğ¼Ğ°Ğ»ÑĞ½Ğ¾Ğº, Ğ´Ğ¾Ğ·Ğ²Ğ¾Ğ»ĞµĞ½Ğ¾",
  rU = () => "âœ… TÃ´ Ä‘Ã¨ lÃªn tÃ¡c pháº©m cá»§a ngÆ°á»i khÃ¡c Ä‘á»ƒ bá»• sung hoáº·c táº¡o tranh má»›i lÃ  Ä‘Æ°á»£c phÃ©p",
  nU = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? GV() : r === "pt" ? $V() : r === "ch" ? WV() : r === "de" ? HV() : r === "es" ? XV() : r === "fr" ? YV() : r === "it" ? KV() : r === "jp" ? JV() : r === "pl" ? QV() : r === "ru" ? eU() : r === "uk" ? tU() : rU()
  },
  iU = () => "Phone verification required",
  aU = () => "VerificaÃ§Ã£o de telefone necessÃ¡ria",
  oU = () => "éœ€è¦è¿›è¡Œç”µè¯éªŒè¯",
  sU = () => "Telefon-Verifizierung erforderlich",
  lU = () => "Se requiere verificaciÃ³n de telÃ©fono",
  cU = () => "VÃ©rification du tÃ©lÃ©phone requise",
  uU = () => "Verifica del telefono richiesta",
  hU = () => "é›»è©±ç•ªå·ã®ç¢ºèªãŒå¿…è¦ã§ã™ã€‚",
  dU = () => "Wymagana weryfikacja telefonu",
  pU = () => "Ğ¢Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°",
  fU = () => "ĞŸĞ¾Ñ‚Ñ€Ñ–Ğ±Ğ½Ğµ Ğ¿Ñ–Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¶ĞµĞ½Ğ½Ñ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ñƒ",
  _U = () => "YÃªu cáº§u xÃ¡c minh sá»‘ Ä‘iá»‡n thoáº¡i",
  Tv = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? iU() : r === "pt" ? aU() : r === "ch" ? oU() : r === "de" ? sU() : r === "es" ? lU() : r === "fr" ? cU() : r === "it" ? uU() : r === "jp" ? hU() : r === "pl" ? dU() : r === "ru" ? pU() : r === "uk" ? fU() : _U()
  },
  mU = () => "Pick a color from the map",
  gU = () => "Escolha uma cor do mapa",
  vU = () => "ä»åœ°å›¾ä¸­æ‹¾å–é¢œè‰²",
  yU = () => "Farbe von der Karte auswÃ¤hlen",
  xU = () => "Elige un color del mapa",
  bU = () => "Choisissez une couleur sur la carte",
  wU = () => "Scegli un colore dalla mappa",
  kU = () => "ãƒãƒƒãƒ—ã‹ã‚‰è‰²ã‚’æ‹¾ã†",
  TU = () => "Wybierz kolor z mapy",
  PU = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ†Ğ²ĞµÑ‚ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ğµ",
  SU = () => "ĞĞ±ĞµÑ€Ñ–Ñ‚ÑŒ ĞºĞ¾Ğ»Ñ–Ñ€ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ñ–",
  MU = () => "Chá»n má»™t mÃ u tá»« báº£n Ä‘á»“",
  IU = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? mU() : r === "pt" ? gU() : r === "ch" ? vU() : r === "de" ? yU() : r === "es" ? xU() : r === "fr" ? bU() : r === "it" ? wU() : r === "jp" ? kU() : r === "pl" ? TU() : r === "ru" ? PU() : r === "uk" ? SU() : MU()
  },
  CU = () => "Pixels",
  AU = () => "Pixels",
  zU = () => "åƒç´ ",
  EU = () => "Pixel",
  LU = () => "PÃ­xeles",
  DU = () => "Pixels",
  RU = () => "Pixel",
  jU = () => "ãƒ”ã‚¯ã‚»ãƒ«",
  FU = () => "Piksele",
  BU = () => "ĞŸĞ¸ĞºÑĞµĞ»Ğ¸",
  OU = () => "ĞŸÑ–ĞºÑĞµĞ»Ñ–",
  qU = () => "Pixel",
  xl = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? CU() : r === "pt" ? AU() : r === "ch" ? zU() : r === "de" ? EU() : r === "es" ? LU() : r === "fr" ? DU() : r === "it" ? RU() : r === "jp" ? jU() : r === "pl" ? FU() : r === "ru" ? BU() : r === "uk" ? OU() : qU()
  },
  NU = () => "Pixels painted inside the country",
  VU = () => "Pixels pintados dentro do paÃ­s",
  UU = () => "åœ¨è¯¥å›½å®¶å†…ç»˜åˆ¶çš„åƒç´ æ•°",
  ZU = () => "Pixel, die innerhalb des Landes gemalt wurden",
  GU = () => "PÃ­xeles pintados dentro del paÃ­s",
  $U = () => "Pixels peints dans le pays",
  WU = () => "Pixel dipinti all'interno del paese",
  HU = () => "ãã®å›½ã®é ˜åŸŸå†…ã§å¡—ã‚‰ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«æ•°",
  XU = () => "Piksele pomalowane wewnÄ…trz kraju",
  YU = () => "ĞŸĞ¸ĞºÑĞµĞ»Ğ¸, Ğ½Ğ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ ÑÑ‚Ñ€Ğ°Ğ½Ñ‹",
  KU = () => "ĞŸÑ–ĞºÑĞµĞ»Ñ–, Ğ½Ğ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ñ– Ğ²ÑĞµÑ€ĞµĞ´Ğ¸Ğ½Ñ– ĞºÑ€Ğ°Ñ—Ğ½Ğ¸",
  JU = () => "Pixel Ä‘Ã£ tÃ´ trong quá»‘c gia",
  QU = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? NU() : r === "pt" ? VU() : r === "ch" ? UU() : r === "de" ? ZU() : r === "es" ? GU() : r === "fr" ? $U() : r === "it" ? WU() : r === "jp" ? HU() : r === "pl" ? XU() : r === "ru" ? YU() : r === "uk" ? KU() : JU()
  },
  eZ = () => "Pixels painted inside the region",
  tZ = () => "Pixels pintados dentro da regiÃ£o",
  rZ = () => "åœ¨è¯¥åŒºåŸŸå†…ç»˜åˆ¶çš„åƒç´ æ•°",
  nZ = () => "Pixel, die innerhalb der Region gemalt wurden",
  iZ = () => "PÃ­xeles pintados dentro de la regiÃ³n",
  aZ = () => "Pixels peints dans la rÃ©gion",
  oZ = () => "Pixel dipinti all'interno della regione",
  sZ = () => "ãã®åœ°åŸŸå†…ã§å¡—ã‚‰ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«æ•°",
  lZ = () => "Piksele pomalowane wewnÄ…trz regionu",
  cZ = () => "ĞŸĞ¸ĞºÑĞµĞ»Ğ¸, Ğ½Ğ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°",
  uZ = () => "ĞŸÑ–ĞºÑĞµĞ»Ñ–, Ğ½Ğ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ñ– Ğ² Ğ¼ĞµĞ¶Ğ°Ñ… Ñ€ĞµĞ³Ñ–Ğ¾Ğ½Ñƒ",
  hZ = () => "Pixel Ä‘Ã£ tÃ´ trong vÃ¹ng",
  dZ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? eZ() : r === "pt" ? tZ() : r === "ch" ? rZ() : r === "de" ? nZ() : r === "es" ? iZ() : r === "fr" ? aZ() : r === "it" ? oZ() : r === "jp" ? sZ() : r === "pl" ? lZ() : r === "ru" ? cZ() : r === "uk" ? uZ() : hZ()
  },
  pZ = () => "Players",
  fZ = () => "Jogadores",
  _Z = () => "ç©å®¶",
  mZ = () => "Spieler",
  gZ = () => "Jugadores",
  vZ = () => "Joueurs",
  yZ = () => "Giocatori",
  xZ = () => "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼",
  bZ = () => "Gracze",
  wZ = () => "Ğ˜Ğ³Ñ€Ğ¾ĞºĞ¸",
  kZ = () => "Ğ“Ñ€Ğ°Ğ²Ñ†Ñ–",
  TZ = () => "NgÆ°á»i chÆ¡i",
  B0 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? pZ() : r === "pt" ? fZ() : r === "ch" ? _Z() : r === "de" ? mZ() : r === "es" ? gZ() : r === "fr" ? vZ() : r === "it" ? yZ() : r === "jp" ? xZ() : r === "pl" ? bZ() : r === "ru" ? wZ() : r === "uk" ? kZ() : TZ()
  },
  PZ = () => "âœ… Griefing political party flags or portraits of politicians is allowed",
  SZ = () => "âœ… Desenhar sobre bandeiras de partidos e retratos de polÃ­ticos Ã© permitido",
  MZ = () => "âœ… ç ´åæ”¿å…šæ——å¸œæˆ–æ”¿æ²»äººç‰©è‚–åƒæ˜¯å…è®¸çš„",
  IZ = () => "âœ… Das Griefen von Parteiflaggen oder PolitikerportrÃ¤ts ist erlaubt",
  CZ = () => "âœ… Griefear banderas de partidos polÃ­ticos o retratos de polÃ­ticos estÃ¡ permitido",
  AZ = () => "âœ… Peindre par-dessus les drapeaux de partis politiques ou les portraits de politiciens est autorisÃ©",
  zZ = () => "âœ… Ãˆ consentito disegnare sopra bandiere di partito e ritratti di politici",
  EZ = () => "âœ… æ”¿å…šã®æ——ã‚„æ”¿æ²»å®¶ã®è‚–åƒç”»ã‚’ã‚°ãƒªãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã™ã‚‹ã“ã¨ã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã™ã€‚",
  LZ = () => "âœ… Niszczenie flag partii politycznych lub portretÃ³w politykÃ³w jest dozwolone",
  DZ = () => "âœ… Ğ“Ñ€Ğ¸Ñ„ĞµÑ€ÑÑ‚Ğ²Ğ¾ Ğ¿Ğ¾ Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ñ Ğº Ñ„Ğ»Ğ°Ğ³Ğ°Ğ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¸Ğ»Ğ¸ Ğ¿Ğ¾Ñ€Ñ‚Ñ€ĞµÑ‚Ğ°Ğ¼ Ğ¿Ğ¾Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¾Ğ² Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¾",
  RZ = () => "âœ… ĞœĞ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ğ¿Ñ€Ğ°Ğ¿Ğ¾Ñ€Ñ–Ğ² Ğ¿Ğ°Ñ€Ñ‚Ñ–Ğ¹ Ğ°Ğ±Ğ¾ Ğ¿Ğ¾Ñ€Ñ‚Ñ€ĞµÑ‚Ñ–Ğ² Ğ¿Ğ¾Ğ»Ñ–Ñ‚Ğ¸ĞºÑ–Ğ² Ğ´Ğ¾Ğ·Ğ²Ğ¾Ğ»ĞµĞ½Ğ¾",
  jZ = () => "âœ… TÃ´ Ä‘Ã¨ lÃªn cá» Ä‘áº£ng phÃ¡i chÃ­nh trá»‹ hoáº·c chÃ¢n dung chÃ­nh trá»‹ gia lÃ  Ä‘Æ°á»£c phÃ©p",
  FZ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? PZ() : r === "pt" ? SZ() : r === "ch" ? MZ() : r === "de" ? IZ() : r === "es" ? CZ() : r === "fr" ? AZ() : r === "it" ? zZ() : r === "jp" ? EZ() : r === "pl" ? LZ() : r === "ru" ? DZ() : r === "uk" ? RZ() : jZ()
  },
  BZ = () => "Map powered by:",
  OZ = () => "Mapa fornecido por:",
  qZ = () => "åœ°å›¾æ”¯æŒï¼š",
  NZ = () => "Karte bereitgestellt von:",
  VZ = () => "Mapa proporcionado por:",
  UZ = () => "Carte fournie par :",
  ZZ = () => "Mappa fornita da:",
  GZ = () => "åœ°å›³æä¾›:",
  $Z = () => "Mapa dostarczana przez:",
  WZ = () => "ĞšĞ°Ñ€Ñ‚Ğ° Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ:",
  HZ = () => "ĞšĞ°Ñ€Ñ‚Ğ° Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ñ–:",
  XZ = () => "Báº£n Ä‘á»“ Ä‘Æ°á»£c cung cáº¥p bá»Ÿi:",
  YZ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? BZ() : r === "pt" ? OZ() : r === "ch" ? qZ() : r === "de" ? NZ() : r === "es" ? VZ() : r === "fr" ? UZ() : r === "it" ? ZZ() : r === "jp" ? GZ() : r === "pl" ? $Z() : r === "ru" ? WZ() : r === "uk" ? HZ() : XZ()
  },
  KZ = () => "Privacy",
  JZ = () => "Privacidade",
  QZ = () => "éšç§",
  eG = () => "Datenschutz",
  tG = () => "Privacidad",
  rG = () => "ConfidentialitÃ©",
  nG = () => "Privacy",
  iG = () => "ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼",
  aG = () => "PrywatnoÅ›Ä‡",
  oG = () => "ĞšĞ¾Ğ½Ñ„Ğ¸Ğ´ĞµĞ½Ñ†Ğ¸Ğ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ",
  sG = () => "ĞšĞ¾Ğ½Ñ„Ñ–Ğ´ĞµĞ½Ñ†Ñ–Ğ¹Ğ½Ñ–ÑÑ‚ÑŒ",
  lG = () => "Quyá»n riÃªng tÆ°",
  cG = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? KZ() : r === "pt" ? JZ() : r === "ch" ? QZ() : r === "de" ? eG() : r === "es" ? tG() : r === "fr" ? rG() : r === "it" ? nG() : r === "jp" ? iG() : r === "pl" ? aG() : r === "ru" ? oG() : r === "uk" ? sG() : lG()
  },
  uG = () => "Profile",
  hG = () => "Perfil",
  dG = () => "ä¸ªäººèµ„æ–™",
  pG = () => "Profil",
  fG = () => "Perfil",
  _G = () => "Profil",
  mG = () => "Profilo",
  gG = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«",
  vG = () => "Profil",
  yG = () => "ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
  xG = () => "ĞŸÑ€Ğ¾Ñ„Ñ–Ğ»ÑŒ",
  bG = () => "Há»“ sÆ¡",
  wG = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? uG() : r === "pt" ? hG() : r === "ch" ? dG() : r === "de" ? pG() : r === "es" ? fG() : r === "fr" ? _G() : r === "it" ? mG() : r === "jp" ? gG() : r === "pl" ? vG() : r === "ru" ? yG() : r === "uk" ? xG() : bG()
  },
  kG = () => "Profile updated",
  TG = () => "Perfil atualizado",
  PG = () => "ä¸ªäººèµ„æ–™å·²æ›´æ–°",
  SG = () => "Profil aktualisiert",
  MG = () => "Perfil actualizado",
  IG = () => "Profil mis Ã  jour",
  CG = () => "Profilo aggiornato",
  AG = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚",
  zG = () => "Profil zaktualizowany",
  EG = () => "ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½",
  LG = () => "ĞŸÑ€Ğ¾Ñ„Ñ–Ğ»ÑŒ Ğ¾Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾",
  DG = () => "ÄÃ£ cáº­p nháº­t há»“ sÆ¡",
  RG = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? kG() : r === "pt" ? TG() : r === "ch" ? PG() : r === "de" ? SG() : r === "es" ? MG() : r === "fr" ? IG() : r === "it" ? CG() : r === "jp" ? AG() : r === "pl" ? zG() : r === "ru" ? EG() : r === "uk" ? LG() : DG()
  },
  jG = () => "Random place",
  FG = () => "Local aleatÃ³rio",
  BG = () => "éšæœºåœ°ç‚¹",
  OG = () => "ZufÃ¤lliger Ort",
  qG = () => "Lugar aleatorio",
  NG = () => "Lieu alÃ©atoire",
  VG = () => "Luogo casuale",
  UG = () => "ãƒ©ãƒ³ãƒ€ãƒ ãªå ´æ‰€",
  ZG = () => "Losowe miejsce",
  GG = () => "Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ğ¾Ğµ Ğ¼ĞµÑÑ‚Ğ¾",
  $G = () => "Ğ’Ğ¸Ğ¿Ğ°Ğ´ĞºĞ¾Ğ²Ğµ Ğ¼Ñ–ÑÑ†Ğµ",
  WG = () => "Vá»‹ trÃ­ ngáº«u nhiÃªn",
  HG = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? jG() : r === "pt" ? FG() : r === "ch" ? BG() : r === "de" ? OG() : r === "es" ? qG() : r === "fr" ? NG() : r === "it" ? VG() : r === "jp" ? UG() : r === "pl" ? ZG() : r === "ru" ? GG() : r === "uk" ? $G() : WG()
  },
  XG = () => "Recent",
  YG = () => "Recente",
  KG = () => "æœ€è¿‘",
  JG = () => "Aktuell",
  QG = () => "Reciente",
  e$ = () => "RÃ©cent",
  t$ = () => "Recente",
  r$ = () => "æœ€è¿‘",
  n$ = () => "Ostatnie",
  i$ = () => "ĞĞµĞ´Ğ°Ğ²Ğ½Ğ¸Ğµ",
  a$ = () => "ĞĞµÑ‰Ğ¾Ğ´Ğ°Ğ²Ğ½Ñ–",
  o$ = () => "Gáº§n Ä‘Ã¢y",
  s$ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? XG() : r === "pt" ? YG() : r === "ch" ? KG() : r === "de" ? JG() : r === "es" ? QG() : r === "fr" ? e$() : r === "it" ? t$() : r === "jp" ? r$() : r === "pl" ? n$() : r === "ru" ? i$() : r === "uk" ? a$() : o$()
  },
  l$ = () => "Recharge paint charges",
  c$ = () => "Recarga de tinta",
  u$ = () => "ä¸ºç»˜åˆ¶å……èƒ½å……ç”µ",
  h$ = () => "Pixel-Ladungen aufladen",
  d$ = () => "Recargar cargas de pintura",
  p$ = () => "Recharger les charges de peinture",
  f$ = () => "Ricarica della vernice",
  _$ = () => "ãƒšã‚¤ãƒ³ãƒˆãƒãƒ£ãƒ¼ã‚¸ã‚’å›å¾©",
  m$ = () => "DoÅ‚aduj Å‚adunki malowania",
  g$ = () => "Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ñ€ÑĞ´Ñ‹",
  v$ = () => "ĞŸĞ¾Ğ¿Ğ¾Ğ²Ğ½Ğ¸Ñ‚Ğ¸ Ğ·Ğ°Ñ€ÑĞ´Ğ¸ Ñ„Ğ°Ñ€Ğ±Ğ¸",
  y$ = () => "Náº¡p láº¡i lÆ°á»£t tÃ´",
  x$ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? l$() : r === "pt" ? c$() : r === "ch" ? u$() : r === "de" ? h$() : r === "es" ? d$() : r === "fr" ? p$() : r === "it" ? f$() : r === "jp" ? _$() : r === "pl" ? m$() : r === "ru" ? g$() : r === "uk" ? v$() : y$()
  },
  b$ = () => "Redo",
  w$ = () => "Refazer",
  k$ = () => "é‡åš",
  T$ = () => "Wiederholen",
  P$ = () => "Rehacer",
  S$ = () => "RÃ©tablir",
  M$ = () => "Rifai",
  I$ = () => "ã‚„ã‚Šç›´ã™",
  C$ = () => "PonÃ³w",
  A$ = () => "ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‚ÑŒ",
  z$ = () => "ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‚Ğ¸",
  E$ = () => "LÃ m láº¡i",
  L$ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? b$() : r === "pt" ? w$() : r === "ch" ? k$() : r === "de" ? T$() : r === "es" ? P$() : r === "fr" ? S$() : r === "it" ? M$() : r === "jp" ? I$() : r === "pl" ? C$() : r === "ru" ? A$() : r === "uk" ? z$() : E$()
  },
  D$ = () => "Refund",
  R$ = () => "Reembolso",
  j$ = () => "é€€æ¬¾",
  F$ = () => "RÃ¼ckerstattung",
  B$ = () => "Reembolso",
  O$ = () => "Remboursement",
  q$ = () => "Rimborso",
  N$ = () => "è¿”é‡‘",
  V$ = () => "Zwrot",
  U$ = () => "Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ ÑÑ€ĞµĞ´ÑÑ‚Ğ²",
  Z$ = () => "ĞŸĞ¾Ğ²ĞµÑ€Ğ½ĞµĞ½Ğ½Ñ ĞºĞ¾ÑˆÑ‚Ñ–Ğ²",
  G$ = () => "HoÃ n tiá»n",
  O0 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? D$() : r === "pt" ? R$() : r === "ch" ? j$() : r === "de" ? F$() : r === "es" ? B$() : r === "fr" ? O$() : r === "it" ? q$() : r === "jp" ? N$() : r === "pl" ? V$() : r === "ru" ? U$() : r === "uk" ? Z$() : G$()
  },
  $$ = () => "Region",
  W$ = () => "RegiÃ£o",
  H$ = () => "åŒºåŸŸ",
  X$ = () => "Region",
  Y$ = () => "RegiÃ³n",
  K$ = () => "RÃ©gion",
  J$ = () => "Regione",
  Q$ = () => "åœ°åŸŸ",
  eW = () => "Region",
  tW = () => "Ğ ĞµĞ³Ğ¸Ğ¾Ğ½",
  rW = () => "Ğ ĞµĞ³Ñ–Ğ¾Ğ½",
  nW = () => "VÃ¹ng",
  iW = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? $$() : r === "pt" ? W$() : r === "ch" ? H$() : r === "de" ? X$() : r === "es" ? Y$() : r === "fr" ? K$() : r === "it" ? J$() : r === "jp" ? Q$() : r === "pl" ? eW() : r === "ru" ? tW() : r === "uk" ? rW() : nW()
  },
  aW = () => "Regions",
  oW = () => "RegiÃµes",
  sW = () => "åŒºåŸŸ",
  lW = () => "Regionen",
  cW = () => "Regiones",
  uW = () => "RÃ©gions",
  hW = () => "Regioni",
  dW = () => "åœ°åŸŸ",
  pW = () => "Regiony",
  fW = () => "Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹",
  _W = () => "Ğ ĞµĞ³Ñ–Ğ¾Ğ½Ğ¸",
  mW = () => "CÃ¡c vÃ¹ng",
  gW = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? aW() : r === "pt" ? oW() : r === "ch" ? sW() : r === "de" ? lW() : r === "es" ? cW() : r === "fr" ? uW() : r === "it" ? hW() : r === "jp" ? dW() : r === "pl" ? pW() : r === "ru" ? fW() : r === "uk" ? _W() : mW()
  },
  vW = () => "Report feedback",
  yW = () => "Feedback de denÃºncia",
  xW = () => "ä¸¾æŠ¥åé¦ˆ",
  bW = () => "Meldungs-Feedback",
  wW = () => "Feedback del reporte",
  kW = () => "Retour de signalement",
  TW = () => "Feedback segnalazione",
  PW = () => "é€šå ±ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯",
  SW = () => "Informacja zwrotna o zgÅ‚oszeniu",
  MW = () => "ĞĞ±Ñ€Ğ°Ñ‚Ğ½Ğ°Ñ ÑĞ²ÑĞ·ÑŒ Ğ¿Ğ¾ Ğ¶Ğ°Ğ»Ğ¾Ğ±Ğµ",
  IW = () => "Ğ’Ñ–Ğ´Ğ³ÑƒĞº Ñ‰Ğ¾Ğ´Ğ¾ ÑĞºĞ°Ñ€Ğ³Ğ¸",
  CW = () => "Pháº£n há»“i bÃ¡o cÃ¡o",
  Pv = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? vW() : r === "pt" ? yW() : r === "ch" ? xW() : r === "de" ? bW() : r === "es" ? wW() : r === "fr" ? kW() : r === "it" ? TW() : r === "jp" ? PW() : r === "pl" ? SW() : r === "ru" ? MW() : r === "uk" ? IW() : CW()
  },
  AW = () => "Your report has been reviewed, and a penalty has been applied to the reported player.",
  zW = () => "Um jogador denunciado recentemente por vocÃª foi punido.",
  EW = () => "ä½ çš„ä¸¾æŠ¥å·²è¢«å®¡æ ¸ï¼Œå¯¹è¢«ä¸¾æŠ¥ç©å®¶å·²æ–½åŠ æƒ©ç½šã€‚",
  LW = () => "Deine Meldung wurde Ã¼berprÃ¼ft und der gemeldete Spieler wurde bestraft.",
  DW = () => "Un jugador reportado recientemente por ti ha sido sancionado.",
  RW = () => "Votre signalement a Ã©tÃ© analysÃ© et une sanction a Ã©tÃ© appliquÃ©e au joueur signalÃ©.",
  jW = () => "Un giocatore che hai segnalato di recente Ã¨ stato punito.",
  FW = () => "ã‚ãªãŸã®é€šå ±ãŒç¢ºèªã•ã‚Œã€å¯¾è±¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‡¦ç½°ãŒé©ç”¨ã•ã‚Œã¾ã—ãŸã€‚",
  BW = () => "Twoje zgÅ‚oszenie zostaÅ‚o przeanalizowane i na ukaranego gracza naÅ‚oÅ¼ono karÄ™.",
  OW = () => "Ğ’Ğ°ÑˆĞ° Ğ½ĞµĞ´Ğ°Ğ²Ğ½ÑÑ Ğ¶Ğ°Ğ»Ğ¾Ğ±Ğ° Ğ±Ñ‹Ğ»Ğ° Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€ĞµĞ½Ğ°, Ğ¸ Ğº ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ½Ğ¾Ğ¼Ñƒ Ğ¸Ğ³Ñ€Ğ¾ĞºÑƒ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¾ Ğ½Ğ°ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ.",
  qW = () => "ĞšĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°, Ğ½Ğ° ÑĞºĞ¾Ğ³Ğ¾ Ğ²Ğ¸ Ğ½ĞµÑ‰Ğ¾Ğ´Ğ°Ğ²Ğ½Ğ¾ Ğ¿Ğ¾ÑĞºĞ°Ñ€Ğ¶Ğ¸Ğ»Ğ¸ÑÑ, Ğ±ÑƒĞ»Ğ¾ Ğ¿Ğ¾ĞºĞ°Ñ€Ğ°Ğ½Ğ¾.",
  NW = () => "BÃ¡o cÃ¡o gáº§n Ä‘Ã¢y cá»§a báº¡n Ä‘Ã£ Ä‘Æ°á»£c xá»­ lÃ½ vÃ  ngÆ°á»i chÆ¡i bá»‹ bÃ¡o cÃ¡o Ä‘Ã£ bá»‹ pháº¡t.",
  Sv = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? AW() : r === "pt" ? zW() : r === "ch" ? EW() : r === "de" ? LW() : r === "es" ? DW() : r === "fr" ? RW() : r === "it" ? jW() : r === "jp" ? FW() : r === "pl" ? BW() : r === "ru" ? OW() : r === "uk" ? qW() : NW()
  },
  VW = () => "Thank you for helping keep the community fair and safe.",
  UW = () => "Obrigado por ajudar a manter a comunidade justa e segura!",
  ZW = () => "æ„Ÿè°¢ä½ å¸®åŠ©ç»´æŠ¤ç¤¾åŒºçš„å…¬å¹³ä¸å®‰å…¨ã€‚",
  GW = () => "Danke, dass du hilfst, die Community fair und sicher zu halten.",
  $W = () => "Gracias por ayudar a mantener la comunidad justa y segura.",
  WW = () => "Merci dâ€™aider Ã  garder la communautÃ© juste et sÃ»re.",
  HW = () => "Grazie per aiutare a mantenere la comunitÃ  giusta e sicura!",
  XW = () => "ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã‚’å…¬æ­£ã§å®‰å…¨ã«ä¿ã¤ãŸã‚ã«ã”å”åŠ›ã„ãŸã ãã€ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚",
  YW = () => "DziÄ™kujemy za pomoc w utrzymaniu uczciwej i bezpiecznej spoÅ‚ecznoÅ›ci.",
  KW = () => "Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°ĞµÑ‚Ğµ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµÑÑ‚Ğ²Ğ¾ Ñ‡ĞµÑÑ‚Ğ½ĞµĞµ Ğ¸ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½ĞµĞµ.",
  JW = () => "Ğ”ÑĞºÑƒÑ”Ğ¼Ğ¾, Ñ‰Ğ¾ Ğ´Ğ¾Ğ¿Ğ¾Ğ¼Ğ°Ğ³Ğ°Ñ”Ñ‚Ğµ Ğ¿Ñ–Ğ´Ñ‚Ñ€Ğ¸Ğ¼ÑƒĞ²Ğ°Ñ‚Ğ¸ Ñ‡ĞµÑĞ½Ñ–ÑÑ‚ÑŒ Ñ‚Ğ° Ğ±ĞµĞ·Ğ¿ĞµĞºÑƒ ÑĞ¿Ñ–Ğ»ÑŒĞ½Ğ¾Ñ‚Ğ¸.",
  QW = () => "Cáº£m Æ¡n báº¡n Ä‘Ã£ giÃºp giá»¯ cá»™ng Ä‘á»“ng cÃ´ng báº±ng vÃ  an toÃ n.",
  eH = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? VW() : r === "pt" ? UW() : r === "ch" ? ZW() : r === "de" ? GW() : r === "es" ? $W() : r === "fr" ? WW() : r === "it" ? HW() : r === "jp" ? XW() : r === "pl" ? YW() : r === "ru" ? KW() : r === "uk" ? JW() : QW()
  },
  tH = () => "This action may take some time to be completed.",
  rH = () => "Essa aÃ§Ã£o pode levar algum tempo para ser realizada.",
  nH = () => "è¯¥æ“ä½œå¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´æ‰èƒ½å®Œæˆã€‚",
  iH = () => "Diese Aktion kann etwas Zeit in Anspruch nehmen.",
  aH = () => "Esta acciÃ³n puede tardar un poco en completarse.",
  oH = () => "Cette action peut prendre un certain temps Ã  Ãªtre complÃ©tÃ©e.",
  sH = () => "Questa azione potrebbe richiedere del tempo per essere completata.",
  lH = () => "ã“ã®æ“ä½œã®å®Œäº†ã«ã¯æ™‚é–“ãŒã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚",
  cH = () => "Ta akcja moÅ¼e chwilÄ™ potrwaÄ‡.",
  uH = () => "Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ·Ğ°Ğ½ÑÑ‚ÑŒ Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ.",
  hH = () => "Ğ¦Ñ Ğ´Ñ–Ñ Ğ¼Ğ¾Ğ¶Ğµ Ğ·Ğ°Ğ¹Ğ½ÑÑ‚Ğ¸ Ğ´ĞµÑĞºĞ¸Ğ¹ Ñ‡Ğ°Ñ.",
  dH = () => "HÃ nh Ä‘á»™ng nÃ y cÃ³ thá»ƒ máº¥t má»™t lÃºc Ä‘á»ƒ hoÃ n thÃ nh.",
  pH = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? tH() : r === "pt" ? rH() : r === "ch" ? nH() : r === "de" ? iH() : r === "es" ? aH() : r === "fr" ? oH() : r === "it" ? sH() : r === "jp" ? lH() : r === "pl" ? cH() : r === "ru" ? uH() : r === "uk" ? hH() : dH()
  },
  fH = () => "Rules",
  _H = () => "Regras",
  mH = () => "è§„åˆ™",
  gH = () => "Regeln",
  vH = () => "Reglas",
  yH = () => "RÃ¨gles",
  xH = () => "Regole",
  bH = () => "ãƒ«ãƒ¼ãƒ«",
  wH = () => "Zasady",
  kH = () => "ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°",
  TH = () => "ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°",
  PH = () => "Luáº­t",
  SH = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? fH() : r === "pt" ? _H() : r === "ch" ? mH() : r === "de" ? gH() : r === "es" ? vH() : r === "fr" ? yH() : r === "it" ? xH() : r === "jp" ? bH() : r === "pl" ? wH() : r === "ru" ? kH() : r === "uk" ? TH() : PH()
  },
  MH = () => "Select a color",
  IH = () => "Selecione uma color",
  CH = () => "é€‰æ‹©ä¸€ç§é¢œè‰²",
  AH = () => "Farbe auswÃ¤hlen",
  zH = () => "Selecciona un color",
  EH = () => "SÃ©lectionnez une couleur",
  LH = () => "Seleziona un colore",
  DH = () => "è‰²ã‚’é¸æŠ",
  RH = () => "Wybierz kolor",
  jH = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ†Ğ²ĞµÑ‚",
  FH = () => "Ğ’Ğ¸Ğ±ĞµÑ€Ñ–Ñ‚ÑŒ ĞºĞ¾Ğ»Ñ–Ñ€",
  BH = () => "Chá»n má»™t mÃ u",
  OH = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? MH() : r === "pt" ? IH() : r === "ch" ? CH() : r === "de" ? AH() : r === "es" ? zH() : r === "fr" ? EH() : r === "it" ? LH() : r === "jp" ? DH() : r === "pl" ? RH() : r === "ru" ? jH() : r === "uk" ? FH() : BH()
  },
  qH = () => "Select a pixel to erase",
  NH = () => "Selecione um pixel para apagar",
  VH = () => "é€‰æ‹©è¦æ“¦é™¤çš„åƒç´ ",
  UH = () => "Pixel zum LÃ¶schen auswÃ¤hlen",
  ZH = () => "Selecciona un pÃ­xel para borrar",
  GH = () => "SÃ©lectionnez un pixel Ã  effacer",
  $H = () => "Seleziona un pixel da cancellare",
  WH = () => "æ¶ˆã—ãŸã„ãƒ”ã‚¯ã‚»ãƒ«ã‚’é¸æŠ",
  HH = () => "Wybierz piksel do usuniÄ™cia",
  XH = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ Ğ´Ğ»Ñ ÑÑ‚Ğ¸Ñ€Ğ°Ğ½Ğ¸Ñ",
  YH = () => "Ğ’Ğ¸Ğ±ĞµÑ€Ñ–Ñ‚ÑŒ Ğ¿Ñ–ĞºÑĞµĞ»ÑŒ Ğ´Ğ»Ñ ÑÑ‚Ğ¸Ñ€Ğ°Ğ½Ğ½Ñ",
  KH = () => "Chá»n pixel Ä‘á»ƒ xÃ³a",
  JH = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? qH() : r === "pt" ? NH() : r === "ch" ? VH() : r === "de" ? UH() : r === "es" ? ZH() : r === "fr" ? GH() : r === "it" ? $H() : r === "jp" ? WH() : r === "pl" ? HH() : r === "ru" ? XH() : r === "uk" ? YH() : KH()
  },
  QH = () => "Select the area's first corner",
  eX = () => "Selecione o primeiro canto da Ã¡rea",
  tX = () => "é€‰æ‹©åŒºåŸŸçš„ç¬¬ä¸€ä¸ªè§’",
  rX = () => "Erste Ecke des Bereichs auswÃ¤hlen",
  nX = () => "Selecciona la primera esquina del Ã¡rea",
  iX = () => "SÃ©lectionnez le premier coin de la zone",
  aX = () => "Seleziona il primo angolo dell'area",
  oX = () => "é ˜åŸŸã®æœ€åˆã®è§’ã‚’é¸æŠ",
  sX = () => "Wybierz pierwszy naroÅ¼nik obszaru",
  lX = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ ÑƒĞ³Ğ¾Ğ» Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ğ¸",
  cX = () => "Ğ’Ğ¸Ğ±ĞµÑ€Ñ–Ñ‚ÑŒ Ğ¿ĞµÑ€ÑˆĞ¸Ğ¹ ĞºÑƒÑ‚ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ñ–",
  uX = () => "Chá»n gÃ³c Ä‘áº§u tiÃªn cá»§a vÃ¹ng",
  hX = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? QH() : r === "pt" ? eX() : r === "ch" ? tX() : r === "de" ? rX() : r === "es" ? nX() : r === "fr" ? iX() : r === "it" ? aX() : r === "jp" ? oX() : r === "pl" ? sX() : r === "ru" ? lX() : r === "uk" ? cX() : uX()
  },
  dX = () => "Select the area's opposite corner",
  pX = () => "Selecione o canto oposto da Ã¡rea",
  fX = () => "é€‰æ‹©åŒºåŸŸçš„å¯¹è§’",
  _X = () => "GegenÃ¼berliegende Ecke des Bereichs auswÃ¤hlen",
  mX = () => "Selecciona la esquina opuesta del Ã¡rea",
  gX = () => "SÃ©lectionnez le coin opposÃ© de la zone",
  vX = () => "Seleziona l'angolo opposto dell'area",
  yX = () => "é ˜åŸŸã®åå¯¾å´ã®è§’ã‚’é¸æŠ",
  xX = () => "Wybierz przeciwlegÅ‚y naroÅ¼nik obszaru",
  bX = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½Ñ‹Ğ¹ ÑƒĞ³Ğ¾Ğ» Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ğ¸",
  wX = () => "Ğ’Ğ¸Ğ±ĞµÑ€Ñ–Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ»ĞµĞ¶Ğ½Ğ¸Ğ¹ ĞºÑƒÑ‚ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ñ–",
  kX = () => "Chá»n gÃ³c Ä‘á»‘i diá»‡n cá»§a vÃ¹ng",
  TX = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? dX() : r === "pt" ? pX() : r === "ch" ? fX() : r === "de" ? _X() : r === "es" ? mX() : r === "fr" ? gX() : r === "it" ? vX() : r === "jp" ? yX() : r === "pl" ? xX() : r === "ru" ? bX() : r === "uk" ? wX() : kX()
  },
  PX = () => "Select the headquarters location",
  SX = () => "Selecione a localizaÃ§Ã£o do quartel general",
  MX = () => "é€‰æ‹©æ€»éƒ¨ä½ç½®",
  IX = () => "Standort des Hauptquartiers auswÃ¤hlen",
  CX = () => "Selecciona la ubicaciÃ³n del cuartel general",
  AX = () => "SÃ©lectionnez lâ€™emplacement du quartier gÃ©nÃ©ral",
  zX = () => "Seleziona la posizione del quartier generale",
  EX = () => "æ‹ ç‚¹ã®å ´æ‰€ã‚’é¸æŠ",
  LX = () => "Wybierz lokalizacjÄ™ siedziby",
  DX = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑˆÑ‚Ğ°Ğ±-ĞºĞ²Ğ°Ñ€Ñ‚Ğ¸Ñ€Ñ‹",
  RX = () => "Ğ’Ğ¸Ğ±ĞµÑ€Ñ–Ñ‚ÑŒ Ñ€Ğ¾Ğ·Ñ‚Ğ°ÑˆÑƒĞ²Ğ°Ğ½Ğ½Ñ ÑˆÑ‚Ğ°Ğ±-ĞºĞ²Ğ°Ñ€Ñ‚Ğ¸Ñ€Ğ¸",
  jX = () => "Chá»n vá»‹ trÃ­ trá»¥ sá»Ÿ",
  FX = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? PX() : r === "pt" ? SX() : r === "ch" ? MX() : r === "de" ? IX() : r === "es" ? CX() : r === "fr" ? AX() : r === "it" ? zX() : r === "jp" ? EX() : r === "pl" ? LX() : r === "ru" ? DX() : r === "uk" ? RX() : jX()
  },
  BX = () => "Send the link below to everybody you want to invite to the alliance",
  OX = () => "Envie o link abaixo para quem vocÃª deseja convidar para a alianÃ§a",
  qX = () => "å°†ä¸‹é¢çš„é“¾æ¥å‘é€ç»™ä½ æƒ³é‚€è¯·åŠ å…¥è”ç›Ÿçš„æ‰€æœ‰äºº",
  NX = () => "Sende den untenstehenden Link an alle, die du in die Allianz einladen mÃ¶chtest",
  VX = () => "EnvÃ­a el siguiente enlace a las personas que quieras invitar a la alianza",
  UX = () => "Envoyez le lien ci-dessous Ã  toutes les personnes que vous souhaitez inviter dans lâ€™alliance",
  ZX = () => "Invia il link qui sotto a chi vuoi invitare nell'alleanza",
  GX = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã«æ‹›å¾…ã—ãŸã„ç›¸æ‰‹ã«ã€ä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã‚’é€ã£ã¦ãã ã•ã„ã€‚",
  $X = () => "WyÅ›lij poniÅ¼szy link wszystkim, ktÃ³rych chcesz zaprosiÄ‡ do sojuszu",
  WX = () => "ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ÑÑÑ‹Ğ»ĞºÑƒ Ğ½Ğ¸Ğ¶Ğµ Ğ²ÑĞµĞ¼, ĞºĞ¾Ğ³Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑĞ¸Ñ‚ÑŒ Ğ² Ğ°Ğ»ÑŒÑĞ½Ñ",
  HX = () => "ĞĞ°Ğ´Ñ–ÑˆĞ»Ñ–Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ¸Ğ»Ğ°Ğ½Ğ½Ñ Ğ½Ğ¸Ğ¶Ñ‡Ğµ Ğ²ÑÑ–Ğ¼, ĞºĞ¾Ğ³Ğ¾ Ñ…Ğ¾Ñ‡ĞµÑ‚Ğµ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚Ğ¸ Ğ² Ğ°Ğ»ÑŒÑĞ½Ñ",
  XX = () => "Gá»­i liÃªn káº¿t dÆ°á»›i Ä‘Ã¢y cho nhá»¯ng ngÆ°á»i báº¡n muá»‘n má»i vÃ o liÃªn minh",
  YX = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? BX() : r === "pt" ? OX() : r === "ch" ? qX() : r === "de" ? NX() : r === "es" ? VX() : r === "fr" ? UX() : r === "it" ? ZX() : r === "jp" ? GX() : r === "pl" ? $X() : r === "ru" ? WX() : r === "uk" ? HX() : XX()
  },
  KX = () => "Your browser doesn't seem to be compatible to load the map. Please try another browser",
  JX = () => "Seu navegador nÃ£o parece ser compatÃ­vel para o mapa. Por favor, tente outro navegador",
  QX = () => "æ‚¨çš„æµè§ˆå™¨ä¼¼ä¹ä¸å…¼å®¹åŠ è½½åœ°å›¾ã€‚è¯·å°è¯•ä½¿ç”¨å…¶ä»–æµè§ˆå™¨",
  eY = () => "Ihr Browser scheint nicht kompatibel zu sein, um die Karte zu laden. Bitte versuchen Sie es mit einem anderen Browser",
  tY = () => "Tu navegador no parece ser compatible para cargar el mapa. Por favor, prueba con otro navegador.",
  rY = () => "Votre navigateur ne semble pas compatible pour charger la carte. Veuillez essayer un autre navigateur",
  nY = () => "Il tuo browser non sembra essere compatibile per caricare la mappa. Prova un altro browser",
  iY = () => "ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯åœ°å›³ã®èª­ã¿è¾¼ã¿ã«å¯¾å¿œã—ã¦ã„ãªã„ã‚ˆã†ã§ã™ã€‚åˆ¥ã®ãƒ–ãƒ©ã‚¦ã‚¶ã‚’ãŠè©¦ã—ãã ã•ã„ã€‚",
  aY = () => "Twoja przeglÄ…darka wydaje siÄ™ byÄ‡ niekompatybilna z Å‚adowaniem mapy. SprÃ³buj innej przeglÄ…darki.",
  oY = () => "Ğ’Ğ°Ñˆ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€, Ğ¿Ğ¾Ñ…Ğ¾Ğ¶Ğµ, Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºÑƒ ĞºĞ°Ñ€Ñ‚Ñ‹. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€.",
  sY = () => "Ğ’Ğ°Ñˆ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€, ÑÑ…Ğ¾Ğ¶Ğµ, Ğ½ĞµÑÑƒĞ¼Ñ–ÑĞ½Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ ĞºĞ°Ñ€Ñ‚Ğ¸. Ğ‘ÑƒĞ´ÑŒ Ğ»Ğ°ÑĞºĞ°, ÑĞ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ñ–Ğ½ÑˆĞ¸Ğ¹ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€",
  lY = () => "TrÃ¬nh duyá»‡t cá»§a báº¡n cÃ³ váº» khÃ´ng tÆ°Æ¡ng thÃ­ch Ä‘á»ƒ táº£i báº£n Ä‘á»“. Vui lÃ²ng thá»­ trÃ¬nh duyá»‡t khÃ¡c",
  cY = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? KX() : r === "pt" ? JX() : r === "ch" ? QX() : r === "de" ? eY() : r === "es" ? tY() : r === "fr" ? rY() : r === "it" ? nY() : r === "jp" ? iY() : r === "pl" ? aY() : r === "ru" ? oY() : r === "uk" ? sY() : lY()
  },
  uY = () => "Share",
  hY = () => "Compartilhar",
  dY = () => "åˆ†äº«",
  pY = () => "Teilen",
  fY = () => "Compartir",
  _Y = () => "Partager",
  mY = () => "Condividi",
  gY = () => "å…±æœ‰",
  vY = () => "UdostÄ™pnij",
  yY = () => "ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ",
  xY = () => "ĞŸĞ¾Ğ´Ñ–Ğ»Ğ¸Ñ‚Ğ¸ÑÑ",
  bY = () => "Chia sáº»",
  wY = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? uY() : r === "pt" ? hY() : r === "ch" ? dY() : r === "de" ? pY() : r === "es" ? fY() : r === "fr" ? _Y() : r === "it" ? mY() : r === "jp" ? gY() : r === "pl" ? vY() : r === "ru" ? yY() : r === "uk" ? xY() : bY()
  },
  kY = () => "Share place",
  TY = () => "Compartilhar local",
  PY = () => "åˆ†äº«åœ°ç‚¹",
  SY = () => "Ort teilen",
  MY = () => "Compartir lugar",
  IY = () => "Partager le lieu",
  CY = () => "Condividi luogo",
  AY = () => "å ´æ‰€ã‚’å…±æœ‰",
  zY = () => "UdostÄ™pnij miejsce",
  EY = () => "ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ Ğ¼ĞµÑÑ‚Ğ¾Ğ¼",
  LY = () => "ĞŸĞ¾Ğ´Ñ–Ğ»Ğ¸Ñ‚Ğ¸ÑÑ Ğ¼Ñ–ÑÑ†ĞµĞ¼",
  DY = () => "Chia sáº» vá»‹ trÃ­",
  RY = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? kY() : r === "pt" ? TY() : r === "ch" ? PY() : r === "de" ? SY() : r === "es" ? MY() : r === "fr" ? IY() : r === "it" ? CY() : r === "jp" ? AY() : r === "pl" ? zY() : r === "ru" ? EY() : r === "uk" ? LY() : DY()
  },
  jY = () => "Show last painted pixel on alliance",
  FY = () => "Mostrar Ãºltimo pixel pintado na alianÃ§a",
  BY = () => "åœ¨è”ç›Ÿä¸­æ˜¾ç¤ºæœ€åç»˜åˆ¶çš„åƒç´ ",
  OY = () => "Zuletzt gemalten Pixel in der Allianz anzeigen",
  qY = () => "Mostrar el Ãºltimo pÃ­xel pintado en la alianza",
  NY = () => "Afficher le dernier pixel peint dans lâ€™alliance",
  VY = () => "Mostra l'ultimo pixel dipinto nell'alleanza",
  UY = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã®æœ€å¾Œã«å¡—ã‚‰ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«ã‚’è¡¨ç¤º",
  ZY = () => "PokaÅ¼ ostatni pomalowany piksel w sojuszu",
  GY = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ, Ğ½Ğ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ°Ğ»ÑŒÑĞ½ÑĞ¾Ğ¼",
  $Y = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ Ğ¾ÑÑ‚Ğ°Ğ½Ğ½Ñ–Ğ¹ Ğ½Ğ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹ Ğ¿Ñ–ĞºÑĞµĞ»ÑŒ Ğ² Ğ°Ğ»ÑŒÑĞ½ÑÑ–",
  WY = () => "Hiá»ƒn thá»‹ pixel cuá»‘i cÃ¹ng Ä‘Æ°á»£c tÃ´ cá»§a liÃªn minh",
  HY = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? jY() : r === "pt" ? FY() : r === "ch" ? BY() : r === "de" ? OY() : r === "es" ? qY() : r === "fr" ? NY() : r === "it" ? VY() : r === "jp" ? UY() : r === "pl" ? ZY() : r === "ru" ? GY() : r === "uk" ? $Y() : WY()
  },
  XY = () => "Show Pixel Art",
  YY = () => "Mostrar Pixel Art",
  KY = () => "æ˜¾ç¤ºåƒç´ è‰ºæœ¯",
  JY = () => "Pixel-Art anzeigen",
  QY = () => "Mostrar Pixel Art",
  eK = () => "Afficher le pixel art",
  tK = () => "Mostra Pixel Art",
  rK = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚¢ãƒ¼ãƒˆã‚’è¡¨ç¤º",
  nK = () => "PokaÅ¼ Pixel Art",
  iK = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ-Ğ°Ñ€Ñ‚",
  aK = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ Pixel Art",
  oK = () => "Hiá»ƒn thá»‹ pixel art",
  sK = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? XY() : r === "pt" ? YY() : r === "ch" ? KY() : r === "de" ? JY() : r === "es" ? QY() : r === "fr" ? eK() : r === "it" ? tK() : r === "jp" ? rK() : r === "pl" ? nK() : r === "ru" ? iK() : r === "uk" ? aK() : oK()
  },
  lK = () => "Show profile",
  cK = () => "Exibir perfil",
  uK = () => "æŸ¥çœ‹ä¸ªäººèµ„æ–™",
  hK = () => "Profil anzeigen",
  dK = () => "Mostrar perfil",
  pK = () => "Afficher le profil",
  fK = () => "Mostra profilo",
  _K = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’è¦‹ã‚‹",
  mK = () => "PokaÅ¼ profil",
  gK = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
  vK = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»ÑŒ",
  yK = () => "Hiá»ƒn thá»‹ há»“ sÆ¡",
  xK = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? lK() : r === "pt" ? cK() : r === "ch" ? uK() : r === "de" ? hK() : r === "es" ? dK() : r === "fr" ? pK() : r === "it" ? fK() : r === "jp" ? _K() : r === "pl" ? mK() : r === "ru" ? gK() : r === "uk" ? vK() : yK()
  },
  bK = () => "SPACE",
  wK = () => "EspaÃ§o",
  kK = () => "ç©ºæ ¼é”®",
  TK = () => "Leertaste",
  PK = () => "Espacio",
  SK = () => "Espace",
  MK = () => "Spazio",
  IK = () => "ã‚¹ãƒšãƒ¼ã‚¹",
  CK = () => "SPACJA",
  AK = () => "ĞŸÑ€Ğ¾Ğ±ĞµĞ»",
  zK = () => "ĞŸÑ€Ğ¾Ğ±Ñ–Ğ»",
  EK = () => "PhÃ­m cÃ¡ch",
  LK = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? bK() : r === "pt" ? wK() : r === "ch" ? kK() : r === "de" ? TK() : r === "es" ? PK() : r === "fr" ? SK() : r === "it" ? MK() : r === "jp" ? IK() : r === "pl" ? CK() : r === "ru" ? AK() : r === "uk" ? zK() : EK()
  },
  DK = () => "Store",
  RK = () => "Loja",
  jK = () => "å•†åº—",
  FK = () => "Shop",
  BK = () => "Tienda",
  OK = () => "Boutique",
  qK = () => "Negozio",
  NK = () => "ã‚¹ãƒˆã‚¢",
  VK = () => "Sklep",
  UK = () => "ĞœĞ°Ğ³Ğ°Ğ·Ğ¸Ğ½",
  ZK = () => "ĞœĞ°Ğ³Ğ°Ğ·Ğ¸Ğ½",
  GK = () => "Cá»­a hÃ ng",
  q0 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? DK() : r === "pt" ? RK() : r === "ch" ? jK() : r === "de" ? FK() : r === "es" ? BK() : r === "fr" ? OK() : r === "it" ? qK() : r === "jp" ? NK() : r === "pl" ? VK() : r === "ru" ? UK() : r === "uk" ? ZK() : GK()
  },
  $K = () => "Submit",
  WK = () => "Enviar",
  HK = () => "æäº¤",
  XK = () => "Senden",
  YK = () => "Enviar",
  KK = () => "Envoyer",
  JK = () => "Invia",
  QK = () => "é€ä¿¡",
  eJ = () => "WyÅ›lij",
  tJ = () => "ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ",
  rJ = () => "ĞĞ°Ğ´Ñ–ÑĞ»Ğ°Ñ‚Ğ¸",
  nJ = () => "Gá»­i",
  iJ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? $K() : r === "pt" ? WK() : r === "ch" ? HK() : r === "de" ? XK() : r === "es" ? YK() : r === "fr" ? KK() : r === "it" ? JK() : r === "jp" ? QK() : r === "pl" ? eJ() : r === "ru" ? tJ() : r === "uk" ? rJ() : nJ()
  },
  aJ = () => "Suggestions",
  oJ = () => "SugestÃµes",
  sJ = () => "å»ºè®®",
  lJ = () => "VorschlÃ¤ge",
  cJ = () => "Sugerencias",
  uJ = () => "Suggestions",
  hJ = () => "Suggerimenti",
  dJ = () => "ææ¡ˆ",
  pJ = () => "Sugestie",
  fJ = () => "ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ",
  _J = () => "ĞŸÑ€Ğ¾Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ñ–Ñ—",
  mJ = () => "Gá»£i Ã½",
  gJ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? aJ() : r === "pt" ? oJ() : r === "ch" ? sJ() : r === "de" ? lJ() : r === "es" ? cJ() : r === "fr" ? uJ() : r === "it" ? hJ() : r === "jp" ? dJ() : r === "pl" ? pJ() : r === "ru" ? fJ() : r === "uk" ? _J() : mJ()
  },
  vJ = () => "Service Workers are not supported/enabled in your browser. Some features might not work properly.",
  yJ = () => "Service Workers nÃ£o sÃ£o suportados ou estÃ£o desativados em seu navegador. Alguns recursos podem nÃ£o funcionar corretamente.",
  xJ = () => "ä½ çš„æµè§ˆå™¨ä¸æ”¯æŒ/æœªå¯ç”¨ Service Workerã€‚ä¸€äº›åŠŸèƒ½å¯èƒ½æ— æ³•æ­£å¸¸å·¥ä½œã€‚",
  bJ = () => "Service Worker werden in deinem Browser nicht unterstÃ¼tzt/aktiviert. Einige Funktionen kÃ¶nnten nicht richtig funktionieren.",
  wJ = () => "Service Workers no estÃ¡n soportados o estÃ¡n desactivados en tu navegador. Algunas funciones pueden no funcionar correctamente.",
  kJ = () => "Les Service Workers ne sont pas pris en charge/activÃ©s dans votre navigateur. Certaines fonctionnalitÃ©s peuvent ne pas fonctionner correctement.",
  TJ = () => "I Service Worker non sono supportati o sono disabilitati nel tuo browser. Alcune funzionalitÃ  potrebbero non funzionare correttamente.",
  PJ = () => "ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯Service WorkerãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã‹ç„¡åŠ¹ã«ãªã£ã¦ã„ã¾ã™ã€‚ä¸€éƒ¨ã®æ©Ÿèƒ½ãŒæ­£ã—ãå‹•ä½œã—ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚",
  SJ = () => "Service Workers nie sÄ… obsÅ‚ugiwane lub sÄ… wyÅ‚Ä…czone w Twojej przeglÄ…darce. NiektÃ³re funkcje mogÄ… nie dziaÅ‚aÄ‡ poprawnie.",
  MJ = () => "Service Workers Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ÑÑ‚ÑÑ Ğ¸Ğ»Ğ¸ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ñ‹ Ğ² Ğ²Ğ°ÑˆĞµĞ¼ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ğµ. ĞĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾.",
  IJ = () => "Service Workers Ğ½Ğµ Ğ¿Ñ–Ğ´Ñ‚Ñ€Ğ¸Ğ¼ÑƒÑÑ‚ÑŒÑÑ Ğ°Ğ±Ğ¾ Ğ²Ğ¸Ğ¼ĞºĞ½ĞµĞ½Ñ– Ñƒ Ğ²Ğ°ÑˆĞ¾Ğ¼Ñƒ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ñ–. Ğ”ĞµÑĞºÑ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ— Ğ¼Ğ¾Ğ¶ÑƒÑ‚ÑŒ Ğ¿Ñ€Ğ°Ñ†ÑĞ²Ğ°Ñ‚Ğ¸ Ğ½ĞµĞºĞ¾Ñ€ĞµĞºÑ‚Ğ½Ğ¾.",
  CJ = () => "TrÃ¬nh duyá»‡t cá»§a báº¡n khÃ´ng há»— trá»£/báº­t Service Workers. Má»™t sá»‘ tÃ­nh nÄƒng cÃ³ thá»ƒ khÃ´ng hoáº¡t Ä‘á»™ng Ä‘Ãºng.",
  AJ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? vJ() : r === "pt" ? yJ() : r === "ch" ? xJ() : r === "de" ? bJ() : r === "es" ? wJ() : r === "fr" ? kJ() : r === "it" ? TJ() : r === "jp" ? PJ() : r === "pl" ? SJ() : r === "ru" ? MJ() : r === "uk" ? IJ() : CJ()
  },
  zJ = () => "Terms",
  EJ = () => "Termos",
  LJ = () => "æ¡æ¬¾",
  DJ = () => "Bedingungen",
  RJ = () => "TÃ©rminos",
  jJ = () => "Conditions",
  FJ = () => "Termini",
  BJ = () => "åˆ©ç”¨è¦ç´„",
  OJ = () => "Warunki",
  qJ = () => "Ğ£ÑĞ»Ğ¾Ğ²Ğ¸Ñ",
  NJ = () => "Ğ£Ğ¼Ğ¾Ğ²Ğ¸",
  VJ = () => "Äiá»u khoáº£n",
  UJ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? zJ() : r === "pt" ? EJ() : r === "ch" ? LJ() : r === "de" ? DJ() : r === "es" ? RJ() : r === "fr" ? jJ() : r === "it" ? FJ() : r === "jp" ? BJ() : r === "pl" ? OJ() : r === "ru" ? qJ() : r === "uk" ? NJ() : VJ()
  },
  ZJ = () => "This action is irreversible, do you want to proceed?",
  GJ = () => "Esta aÃ§Ã£o Ã© irreversÃ­vel, vocÃª deseja prosseguir?",
  $J = () => "æ­¤æ“ä½œä¸å¯é€†ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ",
  WJ = () => "Diese Aktion ist irreversibel. MÃ¶chtest du fortfahren?",
  HJ = () => "Esta acciÃ³n es irreversible, Â¿quieres continuar?",
  XJ = () => "Cette action est irrÃ©versible, souhaitez-vous continuer ?",
  YJ = () => "Questa azione Ã¨ irreversibile, vuoi procedere?",
  KJ = () => "ã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚å®Ÿè¡Œã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
  JJ = () => "Ta akcja jest nieodwracalna. Czy chcesz kontynuowaÄ‡?",
  QJ = () => "Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ¾Ğ±Ñ€Ğ°Ñ‚Ğ¸Ğ¼Ğ¾. ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ?",
  eQ = () => "Ğ¦Ñ Ğ´Ñ–Ñ Ğ½ĞµĞ¼Ğ¾Ğ¶Ğ»Ğ¸Ğ²Ğ¾ ÑĞºĞ°ÑÑƒĞ²Ğ°Ñ‚Ğ¸. ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ²Ğ¶Ğ¸Ñ‚Ğ¸?",
  tQ = () => "HÃ nh Ä‘á»™ng nÃ y khÃ´ng thá»ƒ hoÃ n tÃ¡c, báº¡n cÃ³ muá»‘n tiáº¿p tá»¥c?",
  rQ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? ZJ() : r === "pt" ? GJ() : r === "ch" ? $J() : r === "de" ? WJ() : r === "es" ? HJ() : r === "fr" ? XJ() : r === "it" ? YJ() : r === "jp" ? KJ() : r === "pl" ? JJ() : r === "ru" ? QJ() : r === "uk" ? eQ() : tQ()
  },
  nQ = () => "this month",
  iQ = () => "neste mÃªs",
  aQ = () => "æœ¬æœˆ",
  oQ = () => "diesen Monat",
  sQ = () => "este mes",
  lQ = () => "ce mois-ci",
  cQ = () => "questo mese",
  uQ = () => "ä»Šæœˆ",
  hQ = () => "w tym miesiÄ…cu",
  dQ = () => "Ğ² ÑÑ‚Ğ¾Ğ¼ Ğ¼ĞµÑÑÑ†Ğµ",
  pQ = () => "Ñ†ÑŒĞ¾Ğ³Ğ¾ Ğ¼Ñ–ÑÑÑ†Ñ",
  fQ = () => "thÃ¡ng nÃ y",
  um = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? nQ() : r === "pt" ? iQ() : r === "ch" ? aQ() : r === "de" ? oQ() : r === "es" ? sQ() : r === "fr" ? lQ() : r === "it" ? cQ() : r === "jp" ? uQ() : r === "pl" ? hQ() : r === "ru" ? dQ() : r === "uk" ? pQ() : fQ()
  },
  _Q = () => "this week",
  mQ = () => "nesta semana",
  gQ = () => "æœ¬å‘¨",
  vQ = () => "diese Woche",
  yQ = () => "esta semana",
  xQ = () => "cette semaine",
  bQ = () => "questa settimana",
  wQ = () => "ä»Šé€±",
  kQ = () => "w tym tygodniu",
  TQ = () => "Ğ½Ğ° ÑÑ‚Ğ¾Ğ¹ Ğ½ĞµĞ´ĞµĞ»Ğµ",
  PQ = () => "Ñ†ÑŒĞ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¶Ğ½Ñ",
  SQ = () => "tuáº§n nÃ y",
  hm = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? _Q() : r === "pt" ? mQ() : r === "ch" ? gQ() : r === "de" ? vQ() : r === "es" ? yQ() : r === "fr" ? xQ() : r === "it" ? bQ() : r === "jp" ? wQ() : r === "pl" ? kQ() : r === "ru" ? TQ() : r === "uk" ? PQ() : SQ()
  },
  MQ = () => "This will permanently delete your account and all associated data. This action cannot be undone.",
  IQ = () => "Isso excluirÃ¡ permanentemente sua conta e todos os dados associados. Esta aÃ§Ã£o nÃ£o pode ser desfeita.",
  CQ = () => "è¿™å°†æ°¸ä¹…åˆ é™¤ä½ çš„è´¦å·åŠæ‰€æœ‰ç›¸å…³æ•°æ®ï¼Œæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚",
  AQ = () => "Dies wird dein Konto und alle dazugehÃ¶rigen Daten dauerhaft lÃ¶schen. Diese Aktion kann nicht rÃ¼ckgÃ¤ngig gemacht werden.",
  zQ = () => "Esto eliminarÃ¡ permanentemente tu cuenta y todos los datos asociados. Esta acciÃ³n no se puede deshacer.",
  EQ = () => "Cela supprimera dÃ©finitivement votre compte et toutes les donnÃ©es associÃ©es. Cette action est irrÃ©versible.",
  LQ = () => "Questa azione eliminerÃ  definitivamente il tuo account e tutti i dati associati. Non potrÃ  essere annullata.",
  DQ = () => "ã“ã®æ“ä½œã«ã‚ˆã‚Šã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¨é–¢é€£ã™ã‚‹ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ãŒå®Œå…¨ã«å‰Šé™¤ã•ã‚Œã¾ã™ã€‚å…ƒã«æˆ»ã™ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚",
  RQ = () => "To trwale usunie Twoje konto i wszystkie powiÄ…zane dane. Tej akcji nie moÅ¼na cofnÄ…Ä‡.",
  jQ = () => "Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½Ğ°Ğ²ÑĞµĞ³Ğ´Ğ° ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ Ğ²Ğ°Ñˆ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚ Ğ¸ Ğ²ÑĞµ ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ. Ğ•Ğ³Ğ¾ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ.",
  FQ = () => "Ğ¦Ğµ Ğ½Ğ°Ğ·Ğ°Ğ²Ğ¶Ğ´Ğ¸ Ğ²Ğ¸Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ²Ğ°Ñˆ Ğ°ĞºĞ°ÑƒĞ½Ñ‚ Ñ– Ğ²ÑÑ– Ğ¿Ğ¾Ğ²Ê¼ÑĞ·Ğ°Ğ½Ñ– Ğ´Ğ°Ğ½Ñ–. Ğ¦Ñ Ğ´Ñ–Ñ Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ±ÑƒĞ´Ğµ ÑĞºĞ°ÑÑƒĞ²Ğ°Ñ‚Ğ¸.",
  BQ = () => "Viá»‡c nÃ y sáº½ xÃ³a vÄ©nh viá»…n tÃ i khoáº£n vÃ  táº¥t cáº£ dá»¯ liá»‡u liÃªn quan. HÃ nh Ä‘á»™ng nÃ y khÃ´ng thá»ƒ hoÃ n tÃ¡c.",
  OQ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? MQ() : r === "pt" ? IQ() : r === "ch" ? CQ() : r === "de" ? AQ() : r === "es" ? zQ() : r === "fr" ? EQ() : r === "it" ? LQ() : r === "jp" ? DQ() : r === "pl" ? RQ() : r === "ru" ? jQ() : r === "uk" ? FQ() : BQ()
  },
  qQ = () => "Tickets",
  NQ = () => "Tickets",
  VQ = () => "å·¥å•",
  UQ = () => "Tickets",
  ZQ = () => "Tickets",
  GQ = () => "Tickets",
  $Q = () => "Ticket",
  WQ = () => "ãƒã‚±ãƒƒãƒˆ",
  HQ = () => "Tickety",
  XQ = () => "Ğ¢Ğ¸ĞºĞµÑ‚Ñ‹",
  YQ = () => "Ğ¢Ñ–ĞºĞµÑ‚Ğ¸",
  KQ = () => "Phiáº¿u há»— trá»£",
  JQ = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? qQ() : r === "pt" ? NQ() : r === "ch" ? VQ() : r === "de" ? UQ() : r === "es" ? ZQ() : r === "fr" ? GQ() : r === "it" ? $Q() : r === "jp" ? WQ() : r === "pl" ? HQ() : r === "ru" ? XQ() : r === "uk" ? YQ() : KQ()
  },
  QQ = () => "Timeout appeal",
  eee = () => "RevisÃ£o de suspensÃ£o",
  tee = () => "ç¦è¨€ç”³è¯‰",
  ree = () => "Timeout-Einspruch",
  nee = () => "ApelaciÃ³n de suspensiÃ³n",
  iee = () => "Recours de suspension",
  aee = () => "Ricorso contro la sospensione",
  oee = () => "ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®ç•°è­°ç”³ç«‹ã¦",
  see = () => "OdwoÅ‚anie od zawieszenia",
  lee = () => "ĞĞ¿ĞµĞ»Ğ»ÑÑ†Ğ¸Ñ Ğ½Ğ° Ñ‚Ğ°Ğ¹Ğ¼-Ğ°ÑƒÑ‚",
  cee = () => "ĞĞ¿ĞµĞ»ÑÑ†Ñ–Ñ Ğ½Ğ° Ñ‚Ğ°Ğ¹Ğ¼-Ğ°ÑƒÑ‚",
  uee = () => "KhÃ¡ng cÃ¡o táº¡m khÃ³a",
  hee = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? QQ() : r === "pt" ? eee() : r === "ch" ? tee() : r === "de" ? ree() : r === "es" ? nee() : r === "fr" ? iee() : r === "it" ? aee() : r === "jp" ? oee() : r === "pl" ? see() : r === "ru" ? lee() : r === "uk" ? cee() : uee()
  },
  dee = () => "Appeal",
  pee = () => "Apelar",
  fee = () => "ç”³è¯‰",
  _ee = () => "Einspruch",
  mee = () => "Apelar",
  gee = () => "Recours",
  vee = () => "Fare ricorso",
  yee = () => "ç•°è­°ç”³ç«‹ã¦",
  xee = () => "OdwoÅ‚aj siÄ™",
  bee = () => "ĞĞ¿ĞµĞ»Ğ»ÑÑ†Ğ¸Ñ",
  wee = () => "ĞŸĞ¾Ğ´Ğ°Ñ‚Ğ¸ Ğ°Ğ¿ĞµĞ»ÑÑ†Ñ–Ñ",
  kee = () => "KhÃ¡ng cÃ¡o",
  Tee = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? dee() : r === "pt" ? pee() : r === "ch" ? fee() : r === "de" ? _ee() : r === "es" ? mee() : r === "fr" ? gee() : r === "it" ? vee() : r === "jp" ? yee() : r === "pl" ? xee() : r === "ru" ? bee() : r === "uk" ? wee() : kee()
  },
  Pee = () => "to paint.",
  See = () => "para pintar",
  Mee = () => "è¿›è¡Œç»˜åˆ¶ï¼Œ",
  Iee = () => "gedrÃ¼ckt halten, um zu malen",
  Cee = () => "para pintar.",
  Aee = () => "pour peindre.",
  zee = () => "per dipingere",
  Eee = () => "å¡—ã‚‹ã«ã¯",
  Lee = () => "aby malowaÄ‡.",
  Dee = () => "Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ.",
  Ree = () => "Ñ‰Ğ¾Ğ± Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸.",
  jee = () => "Ä‘á»ƒ tÃ´.",
  Fee = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Pee() : r === "pt" ? See() : r === "ch" ? Mee() : r === "de" ? Iee() : r === "es" ? Cee() : r === "fr" ? Aee() : r === "it" ? zee() : r === "jp" ? Eee() : r === "pl" ? Lee() : r === "ru" ? Dee() : r === "uk" ? Ree() : jee()
  },
  Bee = () => "You can paint more than 1 pixel",
  Oee = () => "VocÃª pode pintar mais de 1 pixel",
  qee = () => "ä½ å¯ä»¥ä¸€æ¬¡ç»˜åˆ¶å¤šä¸ªåƒç´ ",
  Nee = () => "Du kannst mehr als 1 Pixel malen",
  Vee = () => "Puedes pintar mÃ¡s de 1 pÃ­xel",
  Uee = () => "Vous pouvez peindre plus dâ€™un pixel",
  Zee = () => "Puoi dipingere piÃ¹ di 1 pixel",
  Gee = () => "1ã¤ä»¥ä¸Šã®ãƒ”ã‚¯ã‚»ãƒ«ã‚’ã¾ã¨ã‚ã¦å¡—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚",
  $ee = () => "MoÅ¼esz pomalowaÄ‡ wiÄ™cej niÅ¼ 1 piksel",
  Wee = () => "Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ğ±Ğ¾Ğ»ĞµĞµ Ñ‡ĞµĞ¼ 1 Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ",
  Hee = () => "Ğ’Ğ¸ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ğ±Ñ–Ğ»ÑŒÑˆĞµ, Ğ½Ñ–Ğ¶ 1 Ğ¿Ñ–ĞºÑĞµĞ»ÑŒ",
  Xee = () => "Báº¡n cÃ³ thá»ƒ tÃ´ nhiá»u hÆ¡n 1 pixel",
  Yee = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Bee() : r === "pt" ? Oee() : r === "ch" ? qee() : r === "de" ? Nee() : r === "es" ? Vee() : r === "fr" ? Uee() : r === "it" ? Zee() : r === "jp" ? Gee() : r === "pl" ? $ee() : r === "ru" ? Wee() : r === "uk" ? Hee() : Xee()
  },
  Kee = () => "Today",
  Jee = () => "Hoje",
  Qee = () => "ä»Šå¤©",
  ete = () => "Heute",
  tte = () => "Hoy",
  rte = () => "Aujourdâ€™hui",
  nte = () => "Oggi",
  ite = () => "ä»Šæ—¥",
  ate = () => "DziÅ›",
  ote = () => "Ğ¡ĞµĞ³Ğ¾Ğ´Ğ½Ñ",
  ste = () => "Ğ¡ÑŒĞ¾Ğ³Ğ¾Ğ´Ğ½Ñ–",
  lte = () => "HÃ´m nay",
  qp = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Kee() : r === "pt" ? Jee() : r === "ch" ? Qee() : r === "de" ? ete() : r === "es" ? tte() : r === "fr" ? rte() : r === "it" ? nte() : r === "jp" ? ite() : r === "pl" ? ate() : r === "ru" ? ote() : r === "uk" ? ste() : lte()
  },
  cte = () => "Toggle art opacity",
  ute = () => "Alterar opacidade",
  hte = () => "åˆ‡æ¢ä½œå“ä¸é€æ˜åº¦",
  dte = () => "Art-Transparenz umschalten",
  pte = () => "Alternar opacidad del arte",
  fte = () => "Basculer lâ€™opacitÃ© de lâ€™art",
  _te = () => "Modifica opacitÃ ",
  mte = () => "ã‚¢ãƒ¼ãƒˆã®ä¸é€æ˜åº¦ã‚’åˆ‡ã‚Šæ›¿ãˆ",
  gte = () => "PrzeÅ‚Ä…cz przezroczystoÅ›Ä‡ grafik",
  vte = () => "ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ½ĞµĞ¿Ñ€Ğ¾Ğ·Ñ€Ğ°Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ Ğ°Ñ€Ñ‚Ğ°",
  yte = () => "ĞŸĞµÑ€ĞµĞ¼ĞºĞ½ÑƒÑ‚Ğ¸ Ğ¿Ñ€Ğ¾Ğ·Ğ¾Ñ€Ñ–ÑÑ‚ÑŒ Ğ°Ñ€Ñ‚Ñƒ",
  xte = () => "Chuyá»ƒn Ä‘á»™ trong suá»‘t cá»§a art",
  N0 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? cte() : r === "pt" ? ute() : r === "ch" ? hte() : r === "de" ? dte() : r === "es" ? pte() : r === "fr" ? fte() : r === "it" ? _te() : r === "jp" ? mte() : r === "pl" ? gte() : r === "ru" ? vte() : r === "uk" ? yte() : xte()
  },
  bte = () => "Twitch account migrated successfully.",
  wte = () => "Conta da Twitch migrada com sucesso.",
  kte = () => "Twitch è´¦å·è¿ç§»æˆåŠŸã€‚",
  Tte = () => "Twitch-Konto erfolgreich migriert.",
  Pte = () => "Cuenta de Twitch migrada correctamente.",
  Ste = () => "Compte Twitch migrÃ© avec succÃ¨s.",
  Mte = () => "Account Twitch migrato con successo.",
  Ite = () => "Twitchã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ç§»è¡ŒãŒå®Œäº†ã—ã¾ã—ãŸã€‚",
  Cte = () => "Konto Twitch zostaÅ‚o pomyÅ›lnie przeniesione.",
  Ate = () => "ĞĞºĞºĞ°ÑƒĞ½Ñ‚ Twitch ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¼Ğ¸Ğ³Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½.",
  zte = () => "ĞĞºĞ°ÑƒĞ½Ñ‚ Twitch ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾ Ğ¿ĞµÑ€ĞµĞ½ĞµÑĞµĞ½Ğ¾.",
  Ete = () => "ÄÃ£ di chuyá»ƒn tÃ i khoáº£n Twitch thÃ nh cÃ´ng.",
  Lte = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? bte() : r === "pt" ? wte() : r === "ch" ? kte() : r === "de" ? Tte() : r === "es" ? Pte() : r === "fr" ? Ste() : r === "it" ? Mte() : r === "jp" ? Ite() : r === "pl" ? Cte() : r === "ru" ? Ate() : r === "uk" ? zte() : Ete()
  },
  Dte = () => "Please confirm by entering your username:",
  Rte = () => "Por favor, confirme digitando seu nome de usuÃ¡rio:",
  jte = () => "è¯·é€šè¿‡è¾“å…¥ç”¨æˆ·åè¿›è¡Œç¡®è®¤ï¼š",
  Fte = () => "Bitte bestÃ¤tige, indem du deinen Benutzernamen eingibst:",
  Bte = () => "Confirma escribiendo tu nombre de usuario:",
  Ote = () => "Veuillez confirmer en entrant votre nom dâ€™utilisateur :",
  qte = () => "Conferma digitando il tuo nome utente:",
  Nte = () => "ç¢ºèªã®ãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:",
  Vte = () => "PotwierdÅº, wpisujÄ…c swojÄ… nazwÄ™ uÅ¼ytkownika:",
  Ute = () => "Ğ”Ğ»Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°ÑˆĞµ Ğ¸Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ:",
  Zte = () => "ĞŸÑ–Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ñ–Ñ‚ÑŒ, Ğ±ÑƒĞ´ÑŒ Ğ»Ğ°ÑĞºĞ°, Ğ²Ğ²Ñ–Ğ²ÑˆĞ¸ Ğ²Ğ°ÑˆĞµ Ñ–Ğ¼Ê¼Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°:",
  Gte = () => "HÃ£y xÃ¡c nháº­n báº±ng cÃ¡ch nháº­p tÃªn ngÆ°á»i dÃ¹ng cá»§a báº¡n:",
  $te = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Dte() : r === "pt" ? Rte() : r === "ch" ? jte() : r === "de" ? Fte() : r === "es" ? Bte() : r === "fr" ? Ote() : r === "it" ? qte() : r === "jp" ? Nte() : r === "pl" ? Vte() : r === "ru" ? Ute() : r === "uk" ? Zte() : Gte()
  },
  Wte = () => "Type your username",
  Hte = () => "Digite seu nome de usuÃ¡rio",
  Xte = () => "è¾“å…¥ä½ çš„ç”¨æˆ·å",
  Yte = () => "Benutzernamen eingeben",
  Kte = () => "Escribe tu nombre de usuario",
  Jte = () => "Tapez votre nom dâ€™utilisateur",
  Qte = () => "Digita il tuo nome utente",
  ere = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å…¥åŠ›",
  tre = () => "Wpisz swojÄ… nazwÄ™ uÅ¼ytkownika",
  rre = () => "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¸Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ",
  nre = () => "Ğ’Ğ²ĞµĞ´Ñ–Ñ‚ÑŒ ÑĞ²Ğ¾Ñ” Ñ–Ğ¼Ê¼Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°",
  ire = () => "Nháº­p tÃªn ngÆ°á»i dÃ¹ng",
  are = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Wte() : r === "pt" ? Hte() : r === "ch" ? Xte() : r === "de" ? Yte() : r === "es" ? Kte() : r === "fr" ? Jte() : r === "it" ? Qte() : r === "jp" ? ere() : r === "pl" ? tre() : r === "ru" ? rre() : r === "uk" ? nre() : ire()
  },
  ore = () => "Understood",
  sre = () => "Entendido",
  lre = () => "æˆ‘å·²äº†è§£",
  cre = () => "Verstanden",
  ure = () => "Entendido",
  hre = () => "Compris",
  dre = () => "Capito",
  pre = () => "ç†è§£ã—ã¾ã—ãŸ",
  fre = () => "ZrozumiaÅ‚em",
  _re = () => "ĞŸĞ¾Ğ½ÑÑ‚Ğ½Ğ¾",
  mre = () => "Ğ—Ñ€Ğ¾Ğ·ÑƒĞ¼Ñ–Ğ»Ğ¾",
  gre = () => "ÄÃ£ hiá»ƒu",
  vre = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? ore() : r === "pt" ? sre() : r === "ch" ? lre() : r === "de" ? cre() : r === "es" ? ure() : r === "fr" ? hre() : r === "it" ? dre() : r === "jp" ? pre() : r === "pl" ? fre() : r === "ru" ? _re() : r === "uk" ? mre() : gre()
  },
  yre = () => "Undo",
  xre = () => "Desfazer",
  bre = () => "æ’¤æ¶ˆ",
  wre = () => "RÃ¼ckgÃ¤ngig machen",
  kre = () => "Deshacer",
  Tre = () => "Annuler",
  Pre = () => "Annulla",
  Sre = () => "å…ƒã«æˆ»ã™",
  Mre = () => "Cofnij",
  Ire = () => "ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ",
  Cre = () => "Ğ¡ĞºĞ°ÑÑƒĞ²Ğ°Ñ‚Ğ¸",
  Are = () => "HoÃ n tÃ¡c",
  zre = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? yre() : r === "pt" ? xre() : r === "ch" ? bre() : r === "de" ? wre() : r === "es" ? kre() : r === "fr" ? Tre() : r === "it" ? Pre() : r === "jp" ? Sre() : r === "pl" ? Mre() : r === "ru" ? Ire() : r === "uk" ? Cre() : Are()
  },
  Ere = d => `Unlink Discord (${d.username})`,
  Lre = d => `Desconectar Discord (${d.username})`,
  Dre = d => `å–æ¶ˆå…³è” Discordï¼ˆ${d.username}ï¼‰`,
  Rre = d => `Discord trennen (${d.username})`,
  jre = d => `Desvincular Discord (${d.username})`,
  Fre = d => `Dissocier Discord (${d.username})`,
  Bre = d => `Scollega Discord (${d.username})`,
  Ore = d => `Discordã¨ã®é€£æºã‚’è§£é™¤ (${d.username})`,
  qre = d => `OdÅ‚Ä…cz Discord (${d.username})`,
  Nre = d => `ĞÑ‚Ğ²ÑĞ·Ğ°Ñ‚ÑŒ Discord (${d.username})`,
  Vre = d => `Ğ’Ñ–Ğ´Ê¼Ñ”Ğ´Ğ½Ğ°Ñ‚Ğ¸ Discord (${d.username})`,
  Ure = d => `Há»§y liÃªn káº¿t Discord (${d.username})`,
  Zre = (d, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Ere(d) : r === "pt" ? Lre(d) : r === "ch" ? Dre(d) : r === "de" ? Rre(d) : r === "es" ? jre(d) : r === "fr" ? Fre(d) : r === "it" ? Bre(d) : r === "jp" ? Ore(d) : r === "pl" ? qre(d) : r === "ru" ? Nre(d) : r === "uk" ? Vre(d) : Ure(d)
  },
  Gre = () => "Discord unlinked",
  $re = () => "Discord desconectado",
  Wre = () => "Discord å·²å–æ¶ˆå…³è”",
  Hre = () => "Discord-Konto getrennt",
  Xre = () => "Discord desvinculado",
  Yre = () => "Discord dissociÃ©",
  Kre = () => "Discord scollegato",
  Jre = () => "Discordã¨ã®é€£æºã‚’è§£é™¤ã—ã¾ã—ãŸã€‚",
  Qre = () => "Discord odÅ‚Ä…czony",
  ene = () => "Discord Ğ¾Ñ‚Ğ²ÑĞ·Ğ°Ğ½",
  tne = () => "Discord Ğ²Ñ–Ğ´Ê¼Ñ”Ğ´Ğ½Ğ°Ğ½Ğ¾",
  rne = () => "ÄÃ£ há»§y liÃªn káº¿t Discord",
  nne = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Gre() : r === "pt" ? $re() : r === "ch" ? Wre() : r === "de" ? Hre() : r === "es" ? Xre() : r === "fr" ? Yre() : r === "it" ? Kre() : r === "jp" ? Jre() : r === "pl" ? Qre() : r === "ru" ? ene() : r === "uk" ? tne() : rne()
  },
  ine = () => "Unmute",
  ane = () => "Desmutar",
  one = () => "å–æ¶ˆé™éŸ³",
  sne = () => "Stummschaltung aufheben",
  lne = () => "Quitar silencio",
  cne = () => "RÃ©activer le son",
  une = () => "Riattiva audio",
  hne = () => "ãƒŸãƒ¥ãƒ¼ãƒˆè§£é™¤",
  dne = () => "WyÅ‚Ä…cz wyciszenie",
  pne = () => "Ğ¡Ğ½ÑÑ‚ÑŒ Ğ¼ÑŒÑÑ‚",
  fne = () => "Ğ£Ğ²Ñ–Ğ¼ĞºĞ½ÑƒÑ‚Ğ¸ Ğ·Ğ²ÑƒĞº",
  _ne = () => "Báº­t tiáº¿ng",
  mne = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? ine() : r === "pt" ? ane() : r === "ch" ? one() : r === "de" ? sne() : r === "es" ? lne() : r === "fr" ? cne() : r === "it" ? une() : r === "jp" ? hne() : r === "pl" ? dne() : r === "ru" ? pne() : r === "uk" ? fne() : _ne()
  },
  gne = () => "Update",
  vne = () => "Atualizar",
  yne = () => "æ›´æ–°",
  xne = () => "Aktualisieren",
  bne = () => "Actualizar",
  wne = () => "Mettre Ã  jour",
  kne = () => "Aggiorna",
  Tne = () => "æ›´æ–°",
  Pne = () => "Aktualizuj",
  Sne = () => "ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ",
  Mne = () => "ĞĞ½Ğ¾Ğ²Ğ¸Ñ‚Ğ¸",
  Ine = () => "Cáº­p nháº­t",
  Cne = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? gne() : r === "pt" ? vne() : r === "ch" ? yne() : r === "de" ? xne() : r === "es" ? bne() : r === "fr" ? wne() : r === "it" ? kne() : r === "jp" ? Tne() : r === "pl" ? Pne() : r === "ru" ? Sne() : r === "uk" ? Mne() : Ine()
  },
  Ane = () => "Use hardware acceleration when available",
  zne = () => "Usar aceleraÃ§Ã£o grÃ¡fica quando disponÃ­vel",
  Ene = () => "åœ¨å¯ç”¨æ—¶ä½¿ç”¨ç¡¬ä»¶åŠ é€Ÿ",
  Lne = () => "Hardwarebeschleunigung verwenden, wenn verfÃ¼gbar",
  Dne = () => "Usar aceleraciÃ³n por hardware cuando estÃ© disponible",
  Rne = () => "Utiliser lâ€™accÃ©lÃ©ration matÃ©rielle lorsquâ€™elle est disponible",
  jne = () => "Usa l'accelerazione grafica quando disponibile",
  Fne = () => "åˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹",
  Bne = () => "UÅ¼ywaj akceleracji sprzÄ™towej, gdy jest dostÄ™pna",
  One = () => "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ°Ğ¿Ğ¿Ğ°Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğµ ÑƒÑĞºĞ¾Ñ€ĞµĞ½Ğ¸Ğµ, ĞµÑĞ»Ğ¸ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾",
  qne = () => "Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ°Ğ¿Ğ°Ñ€Ğ°Ñ‚Ğ½Ğµ Ğ¿Ñ€Ğ¸ÑĞºĞ¾Ñ€ĞµĞ½Ğ½Ñ, ÑĞºÑ‰Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾",
  Nne = () => "DÃ¹ng tÄƒng tá»‘c pháº§n cá»©ng khi cÃ³ thá»ƒ",
  Vne = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Ane() : r === "pt" ? zne() : r === "ch" ? Ene() : r === "de" ? Lne() : r === "es" ? Dne() : r === "fr" ? Rne() : r === "it" ? jne() : r === "jp" ? Fne() : r === "pl" ? Bne() : r === "ru" ? One() : r === "uk" ? qne() : Nne()
  },
  Une = () => "Username copied to clipboard",
  Zne = () => "UsuÃ¡rio copiado",
  Gne = () => "ç”¨æˆ·åå·²å¤åˆ¶åˆ°å‰ªè´´æ¿",
  $ne = () => "Benutzername in die Zwischenablage kopiert",
  Wne = () => "Nombre de usuario copiado al portapapeles",
  Hne = () => "Nom dâ€™utilisateur copiÃ©",
  Xne = () => "Nome utente copiato",
  Yne = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚",
  Kne = () => "Nazwa uÅ¼ytkownika skopiowana do schowka",
  Jne = () => "Ğ˜Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ ÑĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ² Ğ±ÑƒÑ„ĞµÑ€ Ğ¾Ğ±Ğ¼ĞµĞ½Ğ°",
  Qne = () => "Ğ†Ğ¼Ê¼Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ° ÑĞºĞ¾Ğ¿Ñ–Ğ¹Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ² Ğ±ÑƒÑ„ĞµÑ€ Ğ¾Ğ±Ğ¼Ñ–Ğ½Ñƒ",
  eie = () => "ÄÃ£ sao chÃ©p tÃªn ngÆ°á»i dÃ¹ng vÃ o clipboard",
  tie = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Une() : r === "pt" ? Zne() : r === "ch" ? Gne() : r === "de" ? $ne() : r === "es" ? Wne() : r === "fr" ? Hne() : r === "it" ? Xne() : r === "jp" ? Yne() : r === "pl" ? Kne() : r === "ru" ? Jne() : r === "uk" ? Qne() : eie()
  },
  rie = () => "Verify if",
  nie = () => "Verifique se",
  iie = () => "è¯·æ£€æŸ¥æ˜¯å¦",
  aie = () => "ÃœberprÃ¼fe, ob",
  oie = () => "Verifica si",
  sie = () => "VÃ©rifiez si",
  lie = () => "Verifica se",
  cie = () => "æ¬¡ã‚’ç¢ºèª:",
  uie = () => "SprawdÅº, czy",
  hie = () => "Ğ£Ğ´Ğ¾ÑÑ‚Ğ¾Ğ²ĞµÑ€ÑŒÑ‚ĞµÑÑŒ Ğ² Ñ‚Ğ¾Ğ¼, Ñ‡Ñ‚Ğ¾",
  die = () => "ĞŸĞµÑ€ĞµĞºĞ¾Ğ½Ğ°Ğ¹Ñ‚ĞµÑÑ, Ñ‰Ğ¾",
  pie = () => "Kiá»ƒm tra xem",
  fie = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? rie() : r === "pt" ? nie() : r === "ch" ? iie() : r === "de" ? aie() : r === "es" ? oie() : r === "fr" ? sie() : r === "it" ? lie() : r === "jp" ? cie() : r === "pl" ? uie() : r === "ru" ? hie() : r === "uk" ? die() : pie()
  },
  _ie = () => "Violations of these rules may lead to suspension of your account or removal of drawings.",
  mie = () => "A violaÃ§Ã£o destas regras pode levar Ã  suspensÃ£o da conta ou Ã  remoÃ§Ã£o de desenhos.",
  gie = () => "è¿åè¿™äº›è§„åˆ™å¯èƒ½å¯¼è‡´ä½ çš„è´¦å·è¢«æš‚åœæˆ–ä½œå“è¢«ç§»é™¤ã€‚",
  vie = () => "VerstÃ¶ÃŸe gegen diese Regeln kÃ¶nnen zur Sperrung deines Kontos oder zur Entfernung von Zeichnungen fÃ¼hren.",
  yie = () => "Las violaciones de estas reglas pueden resultar en la suspensiÃ³n de tu cuenta o la eliminaciÃ³n de dibujos.",
  xie = () => "La violation de ces rÃ¨gles peut entraÃ®ner la suspension de votre compte ou la suppression de dessins.",
  bie = () => "La violazione di queste regole puÃ² portare alla sospensione dell'account o alla rimozione dei disegni.",
  wie = () => "ã“ã‚Œã‚‰ã®ãƒ«ãƒ¼ãƒ«ã«é•åã—ãŸå ´åˆã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®åœæ­¢ã‚„ä½œå“ã®å‰Šé™¤ãªã©ã®æªç½®ãŒå–ã‚‰ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚",
  kie = () => "Åamanie tych zasad moÅ¼e skutkowaÄ‡ zawieszeniem konta lub usuniÄ™ciem rysunkÃ³w.",
  Tie = () => "ĞĞ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ¸Ñ… Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ» Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€Ğ¸Ğ²ĞµÑÑ‚Ğ¸ Ğº Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞµ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ° Ğ¸Ğ»Ğ¸ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ñ€Ğ¸ÑÑƒĞ½ĞºĞ¾Ğ².",
  Pie = () => "ĞŸĞ¾Ñ€ÑƒÑˆĞµĞ½Ğ½Ñ Ñ†Ğ¸Ñ… Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ» Ğ¼Ğ¾Ğ¶Ğµ Ğ¿Ñ€Ğ¸Ğ·Ğ²ĞµÑÑ‚Ğ¸ Ğ´Ğ¾ Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ°ĞºĞ°ÑƒĞ½Ñ‚Ğ° Ğ°Ğ±Ğ¾ Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ñ Ğ¼Ğ°Ğ»ÑĞ½ĞºÑ–Ğ².",
  Sie = () => "Vi pháº¡m cÃ¡c luáº­t nÃ y cÃ³ thá»ƒ dáº«n Ä‘áº¿n viá»‡c Ä‘Ã¬nh chá»‰ tÃ i khoáº£n hoáº·c xÃ³a tranh.",
  Mie = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? _ie() : r === "pt" ? mie() : r === "ch" ? gie() : r === "de" ? vie() : r === "es" ? yie() : r === "fr" ? xie() : r === "it" ? bie() : r === "jp" ? wie() : r === "pl" ? kie() : r === "ru" ? Tie() : r === "uk" ? Pie() : Sie()
  },
  Iie = () => "Week",
  Cie = () => "Semana",
  Aie = () => "å‘¨",
  zie = () => "Woche",
  Eie = () => "Semana",
  Lie = () => "Semaine",
  Die = () => "Settimana",
  Rie = () => "é€±",
  jie = () => "TydzieÅ„",
  Fie = () => "ĞĞµĞ´ĞµĞ»Ñ",
  Bie = () => "Ğ¢Ğ¸Ğ¶Ğ´ĞµĞ½ÑŒ",
  Oie = () => "Tuáº§n",
  qie = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Iie() : r === "pt" ? Cie() : r === "ch" ? Aie() : r === "de" ? zie() : r === "es" ? Eie() : r === "fr" ? Lie() : r === "it" ? Die() : r === "jp" ? Rie() : r === "pl" ? jie() : r === "ru" ? Fie() : r === "uk" ? Bie() : Oie()
  },
  Nie = () => "Welcome to",
  Vie = () => "Bem vindo ao",
  Uie = () => "æ¬¢è¿æ¥åˆ°",
  Zie = () => "Willkommen bei",
  Gie = () => "Bienvenido a",
  $ie = () => "Bienvenue sur",
  Wie = () => "Benvenuto su",
  Hie = () => "ã‚ˆã†ã“ã",
  Xie = () => "Witamy w",
  Yie = () => "Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²",
  Kie = () => "Ğ›Ğ°ÑĞºĞ°Ğ²Ğ¾ Ğ¿Ñ€Ğ¾ÑĞ¸Ğ¼Ğ¾ Ğ´Ğ¾",
  Jie = () => "ChÃ o má»«ng Ä‘áº¿n vá»›i",
  Qie = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Nie() : r === "pt" ? Vie() : r === "ch" ? Uie() : r === "de" ? Zie() : r === "es" ? Gie() : r === "fr" ? $ie() : r === "it" ? Wie() : r === "jp" ? Hie() : r === "pl" ? Xie() : r === "ru" ? Yie() : r === "uk" ? Kie() : Jie()
  },
  eae = () => "When painting, click on the button",
  tae = () => "Quando pintar clique no botÃ£o",
  rae = () => "åœ¨ç»˜åˆ¶æ—¶ï¼Œç‚¹å‡»æŒ‰é’®",
  nae = () => "Wenn du malst, klicke auf den Button",
  iae = () => "Cuando estÃ©s pintando, haz clic en el botÃ³n",
  aae = () => "En peignant, cliquez sur le bouton",
  oae = () => "Quando dipingi, clicca sul pulsante",
  sae = () => "ãƒšã‚¤ãƒ³ãƒˆä¸­ã«ã€æ¬¡ã®ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚",
  lae = () => "Podczas malowania kliknij przycisk",
  cae = () => "Ğ’Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ",
  uae = () => "ĞŸÑ–Ğ´ Ñ‡Ğ°Ñ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ Ğ½Ğ°Ñ‚Ğ¸ÑĞ½Ñ–Ñ‚ÑŒ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ",
  hae = () => "Khi tÃ´, hÃ£y nháº¥p vÃ o nÃºt",
  dae = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? eae() : r === "pt" ? tae() : r === "ch" ? rae() : r === "de" ? nae() : r === "es" ? iae() : r === "fr" ? aae() : r === "it" ? oae() : r === "jp" ? sae() : r === "pl" ? lae() : r === "ru" ? cae() : r === "uk" ? uae() : hae()
  },
  pae = () => "You don't have charges to paint. Wait to recharge.",
  fae = () => "VocÃª nÃ£o possui tinta para pintar. Aguarde para carrega-las.",
  _ae = () => "ä½ æ²¡æœ‰å¯ç”¨å……èƒ½ï¼Œè«‹ç­‰å¾…å……èƒ½æ¢å¤ã€‚",
  mae = () => "Du hast keine Ladungen zum Malen. Warte, bis sie sich aufladen.",
  gae = () => "No tienes cargas para pintar. Espera a que se recarguen.",
  vae = () => "Vous nâ€™avez pas de charges pour peindre. Attendez quâ€™elles se rechargent.",
  yae = () => "Non hai vernice per dipingere. Attendi la ricarica.",
  xae = () => "ãƒšã‚¤ãƒ³ãƒˆç”¨ã®ãƒãƒ£ãƒ¼ã‚¸ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å›å¾©ã™ã‚‹ã¾ã§ãŠå¾…ã¡ãã ã•ã„ã€‚",
  bae = () => "Nie masz Å‚adunkÃ³w do malowania. Poczekaj na doÅ‚adowanie.",
  wae = () => "Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ·Ğ°Ñ€ÑĞ´Ğ¾Ğ² Ğ´Ğ»Ñ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¸Ñ. ĞŸĞ¾Ğ´Ğ¾Ğ¶Ğ´Ğ¸Ñ‚Ğµ, Ğ¿Ğ¾ĞºĞ° Ğ¾Ğ½Ğ¸ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²ÑÑ‚ÑÑ.",
  kae = () => "Ğ£ Ğ²Ğ°Ñ Ğ½ĞµĞ¼Ğ°Ñ” Ğ·Ğ°Ñ€ÑĞ´Ñ–Ğ² Ğ´Ğ»Ñ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ. Ğ—Ğ°Ñ‡ĞµĞºĞ°Ğ¹Ñ‚Ğµ, Ğ¿Ğ¾ĞºĞ¸ Ğ²Ğ¾Ğ½Ğ¸ Ğ²Ñ–Ğ´Ğ½Ğ¾Ğ²Ğ»ÑÑ‚ÑŒÑÑ.",
  Tae = () => "Báº¡n khÃ´ng cÃ²n lÆ°á»£t tÃ´ Ä‘á»ƒ váº½. HÃ£y chá» náº¡p láº¡i.",
  Pae = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? pae() : r === "pt" ? fae() : r === "ch" ? _ae() : r === "de" ? mae() : r === "es" ? gae() : r === "fr" ? vae() : r === "it" ? yae() : r === "jp" ? xae() : r === "pl" ? bae() : r === "ru" ? wae() : r === "uk" ? kae() : Tae()
  },
  Sae = () => "You need to zoom in to select a pixel",
  Mae = () => "DÃª zoom para selecionar um pixel",
  Iae = () => "ä½ éœ€è¦æ”¾å¤§æ‰èƒ½é€‰æ‹©åƒç´ ",
  Cae = () => "Du musst hineinzoomen, um einen Pixel zu wÃ¤hlen",
  Aae = () => "Acerca el zoom para seleccionar un pÃ­xel",
  zae = () => "Zoomez pour sÃ©lectionner un pixel",
  Eae = () => "Devi fare zoom per selezionare un pixel",
  Lae = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚’é¸æŠã™ã‚‹ã«ã¯ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚",
  Dae = () => "Musisz przybliÅ¼yÄ‡, aby wybraÄ‡ piksel",
  Rae = () => "ĞŸÑ€Ğ¸Ğ±Ğ»Ğ¸Ğ·ÑŒÑ‚Ğµ ĞºĞ°Ñ€Ñ‚Ñƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ",
  jae = () => "Ğ—Ğ±Ñ–Ğ»ÑŒÑˆÑ–Ñ‚ÑŒ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±, Ñ‰Ğ¾Ğ± Ğ²Ğ¸Ğ±Ñ€Ğ°Ñ‚Ğ¸ Ğ¿Ñ–ĞºÑĞµĞ»ÑŒ",
  Fae = () => "Báº¡n cáº§n phÃ³ng to Ä‘á»ƒ chá»n pixel",
  Bae = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Sae() : r === "pt" ? Mae() : r === "ch" ? Iae() : r === "de" ? Cae() : r === "es" ? Aae() : r === "fr" ? zae() : r === "it" ? Eae() : r === "jp" ? Lae() : r === "pl" ? Dae() : r === "ru" ? Rae() : r === "uk" ? jae() : Fae()
  },
  Oae = () => "Your account has been banned for violating the rules",
  qae = () => "A sua conta foi banida por quebrar as regras",
  Nae = () => "ä½ çš„è´¦å·å› è¿åè§„åˆ™å·²è¢«å°ç¦",
  Vae = () => "Dein Konto wurde wegen RegelverstÃ¶ÃŸen gebannt",
  Uae = () => "Tu cuenta ha sido baneada por infringir las reglas",
  Zae = () => "Votre compte a Ã©tÃ© banni pour avoir enfreint les rÃ¨gles",
  Gae = () => "Il tuo account Ã¨ stato bannato per aver infranto le regole",
  $ae = () => "ãƒ«ãƒ¼ãƒ«é•åã«ã‚ˆã‚Šã€ã‚ãªãŸã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯BANã•ã‚Œã¾ã—ãŸã€‚",
  Wae = () => "Twoje konto zostaÅ‚o zbanowane za Å‚amanie zasad",
  Hae = () => "Ğ’Ğ°Ñˆ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚ Ğ±Ñ‹Ğ» Ğ·Ğ°Ğ±Ğ°Ğ½ĞµĞ½ Ğ·Ğ° Ğ½Ğ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»",
  Xae = () => "Ğ’Ğ°Ñˆ Ğ°ĞºĞ°ÑƒĞ½Ñ‚ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²Ğ°Ğ½Ğ¾ Ğ·Ğ° Ğ¿Ğ¾Ñ€ÑƒÑˆĞµĞ½Ğ½Ñ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»",
  Yae = () => "TÃ i khoáº£n cá»§a báº¡n Ä‘Ã£ bá»‹ khÃ³a vÃ¬ vi pháº¡m luáº­t",
  Kae = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Oae() : r === "pt" ? qae() : r === "ch" ? Nae() : r === "de" ? Vae() : r === "es" ? Uae() : r === "fr" ? Zae() : r === "it" ? Gae() : r === "jp" ? $ae() : r === "pl" ? Wae() : r === "ru" ? Hae() : r === "uk" ? Xae() : Yae()
  },
  Jae = () => "Zoom in",
  Qae = () => "Aumentar zoom",
  eoe = () => "æ”¾å¤§",
  toe = () => "Hineinzoomen",
  roe = () => "Acercar",
  noe = () => "Zoom avant",
  ioe = () => "Zoom avanti",
  aoe = () => "ã‚ºãƒ¼ãƒ ã‚¤ãƒ³",
  ooe = () => "PrzybliÅ¼",
  soe = () => "ĞŸÑ€Ğ¸Ğ±Ğ»Ğ¸Ğ·Ğ¸Ñ‚ÑŒ",
  loe = () => "Ğ—Ğ±Ñ–Ğ»ÑŒÑˆĞ¸Ñ‚Ğ¸",
  coe = () => "PhÃ³ng to",
  Mv = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Jae() : r === "pt" ? Qae() : r === "ch" ? eoe() : r === "de" ? toe() : r === "es" ? roe() : r === "fr" ? noe() : r === "it" ? ioe() : r === "jp" ? aoe() : r === "pl" ? ooe() : r === "ru" ? soe() : r === "uk" ? loe() : coe()
  },
  uoe = () => "Zoom in to see the pixels",
  hoe = () => "Amplie para ver os pixels",
  doe = () => "æ”¾å¤§ä»¥æŸ¥çœ‹åƒç´ ",
  poe = () => "Hineinzoomen, um die Pixel zu sehen",
  foe = () => "Acerca el zoom para ver los pÃ­xeles",
  _oe = () => "Zoomez pour voir les pixels",
  moe = () => "Ingrandisci per vedere i pixel",
  goe = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚’è¦‹ã‚‹ã«ã¯ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚",
  voe = () => "PrzybliÅ¼, aby zobaczyÄ‡ piksele",
  yoe = () => "ĞŸÑ€Ğ¸Ğ±Ğ»Ğ¸Ğ·ÑŒÑ‚Ğµ ĞºĞ°Ñ€Ñ‚Ñƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ÑƒĞ²Ğ¸Ğ´ĞµÑ‚ÑŒ Ğ¿Ğ¸ĞºÑĞµĞ»Ğ¸",
  xoe = () => "Ğ—Ğ±Ñ–Ğ»ÑŒÑˆÑ–Ñ‚ÑŒ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±, Ñ‰Ğ¾Ğ± Ğ¿Ğ¾Ğ±Ğ°Ñ‡Ğ¸Ñ‚Ğ¸ Ğ¿Ñ–ĞºÑĞµĞ»Ñ–",
  boe = () => "PhÃ³ng to Ä‘á»ƒ tháº¥y cÃ¡c pixel",
  woe = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? uoe() : r === "pt" ? hoe() : r === "ch" ? doe() : r === "de" ? poe() : r === "es" ? foe() : r === "fr" ? _oe() : r === "it" ? moe() : r === "jp" ? goe() : r === "pl" ? voe() : r === "ru" ? yoe() : r === "uk" ? xoe() : boe()
  },
  koe = () => "Zoom out",
  Toe = () => "Diminuir zoom",
  Poe = () => "ç¼©å°",
  Soe = () => "Herauszoomen",
  Moe = () => "Alejar",
  Ioe = () => "Zoom arriÃ¨re",
  Coe = () => "Zoom indietro",
  Aoe = () => "ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ",
  zoe = () => "Oddal",
  Eoe = () => "ĞÑ‚Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ",
  Loe = () => "Ğ—Ğ¼ĞµĞ½ÑˆĞ¸Ñ‚Ğ¸",
  Doe = () => "Thu nhá»",
  Iv = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? koe() : r === "pt" ? Toe() : r === "ch" ? Poe() : r === "de" ? Soe() : r === "es" ? Moe() : r === "fr" ? Ioe() : r === "it" ? Coe() : r === "jp" ? Aoe() : r === "pl" ? zoe() : r === "ru" ? Eoe() : r === "uk" ? Loe() : Doe()
  },
  Roe = () => "Save with map",
  joe = () => "Salvar com mapa",
  Foe = () => "è¿åŒåœ°å›¾ä¸€èµ·ä¿å­˜",
  Boe = () => "Mit Karte speichern",
  Ooe = () => "Guardar con mapa",
  qoe = () => "Enregistrer avec la carte",
  Noe = () => "Salva con mappa",
  Voe = () => "ãƒãƒƒãƒ—ä»˜ãã§ä¿å­˜",
  Uoe = () => "Zapisz z mapÄ…",
  Zoe = () => "Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ğ¹",
  Goe = () => "Ğ—Ğ±ĞµÑ€ĞµĞ³Ñ‚Ğ¸ Ğ· ĞºĞ°Ñ€Ñ‚Ğ¾Ñ",
  $oe = () => "LÆ°u kÃ¨m báº£n Ä‘á»“",
  Woe = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Roe() : r === "pt" ? joe() : r === "ch" ? Foe() : r === "de" ? Boe() : r === "es" ? Ooe() : r === "fr" ? qoe() : r === "it" ? Noe() : r === "jp" ? Voe() : r === "pl" ? Uoe() : r === "ru" ? Zoe() : r === "uk" ? Goe() : $oe()
  },
  Hoe = () => "Show less",
  Xoe = () => "Mostrar menos",
  Yoe = () => "æ”¶èµ·",
  Koe = () => "Weniger anzeigen",
  Joe = () => "Mostrar menos",
  Qoe = () => "Afficher moins",
  ese = () => "Mostra meno",
  tse = () => "å°‘ãªãè¡¨ç¤º",
  rse = () => "PokaÅ¼ mniej",
  nse = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¼ĞµĞ½ÑŒÑˆĞµ",
  ise = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ Ğ¼ĞµĞ½ÑˆĞµ",
  ase = () => "áº¨n bá»›t",
  ose = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Hoe() : r === "pt" ? Xoe() : r === "ch" ? Yoe() : r === "de" ? Koe() : r === "es" ? Joe() : r === "fr" ? Qoe() : r === "it" ? ese() : r === "jp" ? tse() : r === "pl" ? rse() : r === "ru" ? nse() : r === "uk" ? ise() : ase()
  },
  sse = () => "Show more",
  lse = () => "Mostrar mais",
  cse = () => "æ˜¾ç¤ºæ›´å¤š",
  use = () => "Mehr anzeigen",
  hse = () => "Mostrar mÃ¡s",
  dse = () => "Afficher plus",
  pse = () => "Mostra altro",
  fse = () => "ã‚‚ã£ã¨è¦‹ã‚‹",
  _se = () => "PokaÅ¼ wiÄ™cej",
  mse = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ",
  gse = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ Ğ±Ñ–Ğ»ÑŒÑˆĞµ",
  vse = () => "Hiá»ƒn thá»‹ thÃªm",
  yse = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? sse() : r === "pt" ? lse() : r === "ch" ? cse() : r === "de" ? use() : r === "es" ? hse() : r === "fr" ? dse() : r === "it" ? pse() : r === "jp" ? fse() : r === "pl" ? _se() : r === "ru" ? mse() : r === "uk" ? gse() : vse()
  },
  xse = () => "Flags",
  bse = () => "Bandeiras",
  wse = () => "æ——å¸œ",
  kse = () => "Flaggen",
  Tse = () => "Banderas",
  Pse = () => "Drapeaux",
  Sse = () => "Bandiere",
  Mse = () => "æ——",
  Ise = () => "Flagi",
  Cse = () => "Ğ¤Ğ»Ğ°Ğ³Ğ¸",
  Ase = () => "ĞŸÑ€Ğ°Ğ¿Ğ¾Ñ€Ğ¸",
  zse = () => "Cá»",
  Ese = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? xse() : r === "pt" ? bse() : r === "ch" ? wse() : r === "de" ? kse() : r === "es" ? Tse() : r === "fr" ? Pse() : r === "it" ? Sse() : r === "jp" ? Mse() : r === "pl" ? Ise() : r === "ru" ? Cse() : r === "uk" ? Ase() : zse()
  },
  Lse = () => "Free",
  Dse = () => "GrÃ¡tis",
  Rse = () => "å…è´¹",
  jse = () => "Kostenlos",
  Fse = () => "Gratis",
  Bse = () => "Gratuit",
  Ose = () => "Gratuito",
  qse = () => "ç„¡æ–™",
  Nse = () => "Darmowy",
  Vse = () => "Ğ‘ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ğ¾",
  Use = () => "Ğ‘ĞµĞ·ĞºĞ¾ÑˆÑ‚Ğ¾Ğ²Ğ½Ğ¾",
  Zse = () => "Miá»…n phÃ­",
  Gse = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Lse() : r === "pt" ? Dse() : r === "ch" ? Rse() : r === "de" ? jse() : r === "es" ? Fse() : r === "fr" ? Bse() : r === "it" ? Ose() : r === "jp" ? qse() : r === "pl" ? Nse() : r === "ru" ? Vse() : r === "uk" ? Use() : Zse()
  },
  $se = () => "SPECIAL EVENT",
  Wse = () => "EVENTO ESPECIAL",
  Hse = () => "ç‰¹åˆ«æ´»åŠ¨",
  Xse = () => "Sonderveranstaltung",
  Yse = () => "EVENTO ESPECIAL",
  Kse = () => "Ã‰VÃ‰NEMENT SPÃ‰CIAL",
  Jse = () => "EVENTO SPECIALE",
  Qse = () => "ç‰¹åˆ¥ã‚¤ãƒ™ãƒ³ãƒˆ",
  ele = () => "WYDARZENIE SPECJALNE",
  tle = () => "Ğ¡ĞŸĞ•Ğ¦Ğ˜ĞĞ›Ğ¬ĞĞĞ• Ğ¡ĞĞ‘Ğ«Ğ¢Ğ˜Ğ•",
  rle = () => "Ğ¡Ğ¿ĞµÑ†Ñ–Ğ°Ğ»ÑŒĞ½Ğ° Ğ¿Ğ¾Ğ´Ñ–Ñ",
  nle = () => "Sá»° KIá»†N Äáº¶C BIá»†T",
  ile = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? $se() : r === "pt" ? Wse() : r === "ch" ? Hse() : r === "de" ? Xse() : r === "es" ? Yse() : r === "fr" ? Kse() : r === "it" ? Jse() : r === "jp" ? Qse() : r === "pl" ? ele() : r === "ru" ? tle() : r === "uk" ? rle() : nle()
  },
  ale = () => "Change frame",
  ole = () => "Alterar moldura",
  sle = () => "æ›´æ”¹æ¡†æ¶",
  lle = () => "Rahmen Ã¤ndern",
  cle = () => "Cambiar marco",
  ule = () => "Changer de cadre",
  hle = () => "Cambia cornice",
  dle = () => "ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å¤‰æ›´",
  ple = () => "ZmieÅ„ ramkÄ™",
  fle = () => "Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ĞºĞ°Ğ´Ñ€",
  _le = () => "Ğ—Ğ¼Ñ–Ğ½Ğ¸Ñ‚Ğ¸ ĞºĞ°Ğ´Ñ€",
  mle = () => "Äá»•i khung",
  gle = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? ale() : r === "pt" ? ole() : r === "ch" ? sle() : r === "de" ? lle() : r === "es" ? cle() : r === "fr" ? ule() : r === "it" ? hle() : r === "jp" ? dle() : r === "pl" ? ple() : r === "ru" ? fle() : r === "uk" ? _le() : mle()
  },
  vle = () => "Christmas Event",
  yle = () => "Evento de Natal",
  xle = () => "åœ£è¯æ´»åŠ¨",
  ble = () => "Weihnachtsveranstaltung",
  wle = () => "Evento de Navidad",
  kle = () => "Ã‰vÃ©nement de NoÃ«l",
  Tle = () => "Evento di Natale",
  Ple = () => "ã‚¯ãƒªã‚¹ãƒã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ",
  Sle = () => "Wydarzenie Å›wiÄ…teczne",
  Mle = () => "Ğ Ğ¾Ğ¶Ğ´ĞµÑÑ‚Ğ²ĞµĞ½ÑĞºĞ¾Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ",
  Ile = () => "Ğ Ñ–Ğ·Ğ´Ğ²ÑĞ½Ğ¸Ğ¹ Ğ·Ğ°Ñ…Ñ–Ğ´",
  Cle = () => "Sá»± kiá»‡n GiÃ¡ng Sinh",
  V0 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? vle() : r === "pt" ? yle() : r === "ch" ? xle() : r === "de" ? ble() : r === "es" ? wle() : r === "fr" ? kle() : r === "it" ? Tle() : r === "jp" ? Ple() : r === "pl" ? Sle() : r === "ru" ? Mle() : r === "uk" ? Ile() : Cle()
  },
  Ale = () => "Friday, Dec 19",
  zle = () => "Sexta, 19 de Dez",
  Ele = () => "12æœˆ19æ—¥ æ˜ŸæœŸäº”",
  Lle = () => "Freitag, 19. Dez.",
  Dle = () => "Viernes, 19 dic.",
  Rle = () => "Vendredi 19 dÃ©c.",
  jle = () => "VenerdÃ¬, 19 Dic",
  Fle = () => "12æœˆ19æ—¥(é‡‘)",
  Ble = () => "PiÄ…tek, 19 grudnia",
  Ole = () => "ĞŸÑÑ‚Ğ½Ğ¸Ñ†Ğ°, 19 Ğ´ĞµĞºĞ°Ğ±Ñ€Ñ",
  qle = () => "ĞŸ'ÑÑ‚Ğ½Ğ¸Ñ†Ñ, 19 Ğ“Ñ€ÑƒĞ´Ğ½Ñ",
  Nle = () => "Thá»© SÃ¡u, ngÃ y 19 thÃ¡ng 12",
  Vle = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Ale() : r === "pt" ? zle() : r === "ch" ? Ele() : r === "de" ? Lle() : r === "es" ? Dle() : r === "fr" ? Rle() : r === "it" ? jle() : r === "jp" ? Fle() : r === "pl" ? Ble() : r === "ru" ? Ole() : r === "uk" ? qle() : Nle()
  },
  Ule = () => "Friday, Jan 02",
  Zle = () => "Sexta, 02 de Jan",
  Gle = () => "æ˜ŸæœŸäº”, 1æœˆ2æ—¥",
  $le = () => "Freitag, 02. Januar",
  Wle = () => "Viernes, 02 ene",
  Hle = () => "Vendredi 02 Janv.",
  Xle = () => "VenerdÃ¬, 02 Gen",
  Yle = () => "é‡‘æ›œæ—¥ã€1æœˆ2æ—¥",
  Kle = () => "PiÄ…tek, 02 sty",
  Jle = () => "ĞŸÑÑ‚Ğ½Ğ¸Ñ†Ğ°, 02 Ğ¯Ğ½Ğ²Ğ°Ñ€Ñ",
  Qle = () => "ĞŸ'ÑÑ‚Ğ½Ğ¸Ñ†Ñ, 02 ÑÑ–Ñ‡Ğ½Ñ",
  ece = () => "Thá»© SÃ¡u, 02 Thg 1",
  tce = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Ule() : r === "pt" ? Zle() : r === "ch" ? Gle() : r === "de" ? $le() : r === "es" ? Wle() : r === "fr" ? Hle() : r === "it" ? Xle() : r === "jp" ? Yle() : r === "pl" ? Kle() : r === "ru" ? Jle() : r === "uk" ? Qle() : ece()
  },
  rce = () => "Three new Pixel Villages have appeared in the North Pole! Claim daily presents on the villages, and earn more by painting. Open the presents for an exclusive Christmas item, paint charges, droplets, and more!",
  nce = () => "TrÃªs novas Vilas surgiram no Polo Norte! Resgate presentes diÃ¡rios nas vilas e ganhe mais pintando. Abra obter presentes para obter um item de Natal exclusivo, cargas de tinta, gotas e muito mais!",
  ice = () => "ä¸‰ä¸ªæ–°çš„åƒç´ æ‘åº„å·²åœ¨åŒ—æå‡ºç°ï¼åœ¨æ‘åº„é‡Œé¢†å–æ¯æ—¥ç¤¼ç‰©ï¼Œå¹¶é€šè¿‡ç»˜ç”»èµšå–æ›´å¤šã€‚æ‰“å¼€ç¤¼ç‰©å³å¯è·å¾—ä¸€ä»¶ä¸“å±åœ£è¯ç‰©å“ã€æ¶‚è‰²èƒ½é‡ã€æ°´æ»´ä»¥åŠæ›´å¤šå¥½ç¤¼ï¼",
  ace = () => "Drei neue Pixel-DÃ¶rfer sind am Nordpol aufgetaucht! Holt euch tÃ¤gliche Geschenke in den DÃ¶rfern und verdient mehr durch Malen. Ã–ffnet die Geschenke fÃ¼r einen exklusiven Weihnachtsgegenstand, Farbladungen, TrÃ¶pfchen und mehr!",
  oce = () => "Â¡Han aparecido tres nuevas Aldeas Pixel en el Polo Norte! Reclama regalos diarios en las aldeas y gana mÃ¡s pintando. Â¡Abre los regalos para obtener un objeto navideÃ±o exclusivo, cargas de pintura, gotitas y mucho mÃ¡s!",
  sce = () => "Trois nouveaux Villages Pixel sont apparus au PÃ´le Nord ! RÃ©cupÃ©rez des cadeaux quotidiens dans les villages et gagnez-en davantage en peignant. Ouvrez les cadeaux pour obtenir un objet de NoÃ«l exclusif, des charges de peinture, des gouttelettes, et plus encore !",
  lce = () => "Tre nuovi Villaggi Pixel sono apparsi al Polo Nord! Richiedi regali giornalieri nei villaggi e guadagna di piÃ¹ dipingendo. Apri i regali per un oggetto natalizio esclusivo, ricariche di vernice, goccioline e altro ancora!",
  cce = () => "åŒ—æ¥µã«3ã¤ã®æ–°ã—ã„ãƒ”ã‚¯ã‚»ãƒ«æ‘ãŒç™»å ´ã—ã¾ã—ãŸï¼æ‘ã§æ¯æ—¥ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆã‚’å—ã‘å–ã‚Šã€ãƒšã‚¤ãƒ³ãƒˆã™ã‚‹ã“ã¨ã§ã•ã‚‰ã«å¤šãã®å ±é…¬ã‚’ç²å¾—ã§ãã¾ã™ã€‚ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆã‚’é–‹ã‘ã‚‹ã¨ã€é™å®šã®ã‚¯ãƒªã‚¹ãƒã‚¹ã‚¢ã‚¤ãƒ†ãƒ ã€ãƒšã‚¤ãƒ³ãƒˆãƒãƒ£ãƒ¼ã‚¸ã€ãƒ‰ãƒ­ãƒƒãƒ—ãƒ¬ãƒƒãƒˆãªã©ãŒæ‰‹ã«å…¥ã‚Šã¾ã™ï¼",
  uce = () => "Trzy nowe Wioski Pikseli pojawiÅ‚y siÄ™ na Biegunie PÃ³Å‚nocnym! Odbieraj codzienne prezenty w wioskach i zarabiaj wiÄ™cej, malujÄ…c. OtwÃ³rz prezenty, aby otrzymaÄ‡ ekskluzywny przedmiot Å›wiÄ…teczny, Å‚adunki farby, kropelki i wiele wiÄ™cej!",
  hce = () => "Ğ¢Ñ€Ğ¸ Ğ½Ğ¾Ğ²Ñ‹Ñ… ĞŸĞ¸ĞºÑĞµĞ»ÑŒĞ½Ñ‹Ñ… Ğ´ĞµÑ€ĞµĞ²Ğ½Ğ¸ Ğ¿Ğ¾ÑĞ²Ğ¸Ğ»Ğ¸ÑÑŒ Ğ½Ğ° Ğ¡ĞµĞ²ĞµÑ€Ğ½Ğ¾Ğ¼ Ğ¿Ğ¾Ğ»ÑÑĞµ! Ğ—Ğ°Ğ±Ğ¸Ñ€Ğ°Ğ¹Ñ‚Ğµ ĞµĞ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ´Ğ°Ñ€ĞºĞ¸ Ğ² Ğ´ĞµÑ€ĞµĞ²Ğ½ÑÑ… Ğ¸ Ğ·Ğ°Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ, Ñ€Ğ¸ÑÑƒÑ. ĞÑ‚ĞºÑ€Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ´Ğ°Ñ€ĞºĞ¸, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑĞºÑĞºĞ»ÑĞ·Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ñ€Ğ¾Ğ¶Ğ´ĞµÑÑ‚Ğ²ĞµĞ½ÑĞºĞ¸Ğ¹ Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚, Ğ·Ğ°Ñ€ÑĞ´Ñ‹ ĞºÑ€Ğ°ÑĞºĞ¸, ĞºĞ°Ğ¿Ğ»Ğ¸ Ğ¸ Ğ¼Ğ½Ğ¾Ğ³Ğ¾Ğµ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ!",
  dce = () => "Ğ¢Ñ€Ğ¸ Ğ½Ğ¾Ğ²Ñ– ĞŸÑ–ĞºÑĞµĞ»ÑŒĞ½Ñ– Ğ¡ĞµĞ»Ğ° Ğ·'ÑĞ²Ğ¸Ğ»Ğ¸ÑÑ Ğ½Ğ° ĞŸÑ–Ğ²Ğ½Ñ–Ñ‡Ğ½Ğ¾Ğ¼Ñƒ Ğ¿Ğ¾Ğ»ÑÑÑ–! Ğ—Ğ°Ğ±Ğ¸Ñ€Ğ°Ğ¹Ñ‚Ğµ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ñ– Ğ¿Ğ¾Ğ´Ğ°Ñ€ÑƒĞ½ĞºĞ¸ Ğ² ÑĞµĞ»Ğ°Ñ… Ñ– Ğ·Ğ°Ñ€Ğ¾Ğ±Ğ»ÑĞ¹Ñ‚Ğµ Ğ±Ñ–Ğ»ÑŒÑˆĞµ, Ñ€Ğ¾Ğ·Ñ„Ğ°Ñ€Ğ±Ğ¾Ğ²ÑƒÑÑ‡Ğ¸. Ğ’Ñ–Ğ´ĞºÑ€Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ´Ğ°Ñ€ÑƒĞ½ĞºĞ¸, Ñ‰Ğ¾Ğ± Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ñ‚Ğ¸ ĞµĞºÑĞºĞ»ÑĞ·Ğ¸Ğ²Ğ½Ğ¸Ğ¹ Ñ€Ñ–Ğ·Ğ´Ğ²ÑĞ½Ğ¸Ğ¹ Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚, Ğ·Ğ°Ñ€ÑĞ´Ğ¸ Ñ„Ğ°Ñ€Ğ±Ğ¸, ĞºÑ€Ğ°Ğ¿Ğ»Ñ– Ñ‚Ğ° Ğ±Ğ°Ğ³Ğ°Ñ‚Ğ¾ Ñ–Ğ½ÑˆĞ¾Ğ³Ğ¾!",
  pce = () => "Ba LÃ ng Pixel má»›i Ä‘Ã£ xuáº¥t hiá»‡n á»Ÿ Báº¯c Cá»±c! Nháº­n quÃ  hÃ ng ngÃ y táº¡i cÃ¡c lÃ ng, vÃ  kiáº¿m thÃªm báº±ng cÃ¡ch tÃ´ mÃ u. Má»Ÿ quÃ  Ä‘á»ƒ nháº­n má»™t váº­t pháº©m GiÃ¡ng Sinh Ä‘á»™c quyá»n, lÆ°á»£t tÃ´ mÃ u, giá»t, vÃ  nhiá»u hÆ¡n ná»¯a!",
  fce = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? rce() : r === "pt" ? nce() : r === "ch" ? ice() : r === "de" ? ace() : r === "es" ? oce() : r === "fr" ? sce() : r === "it" ? lce() : r === "jp" ? cce() : r === "pl" ? uce() : r === "ru" ? hce() : r === "uk" ? dce() : pce()
  },
  _ce = () => "Paint pixels",
  mce = () => "Pintar pixels",
  gce = () => "ç»˜åˆ¶åƒç´ ",
  vce = () => "Pixel malen",
  yce = () => "Pintar pÃ­xeles",
  xce = () => "Peindre des pixels",
  bce = () => "Dipingi pixel",
  wce = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚’ãƒšã‚¤ãƒ³ãƒˆã™ã‚‹",
  kce = () => "Maluj piksele",
  Tce = () => "Ğ Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¸ĞºÑĞµĞ»Ğ¸",
  Pce = () => "ĞœĞ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ğ¿Ñ–ĞºÑĞµĞ»Ñ–",
  Sce = () => "TÃ´ mÃ u Ä‘iá»ƒm áº£nh",
  Mce = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? _ce() : r === "pt" ? mce() : r === "ch" ? gce() : r === "de" ? vce() : r === "es" ? yce() : r === "fr" ? xce() : r === "it" ? bce() : r === "jp" ? wce() : r === "pl" ? kce() : r === "ru" ? Tce() : r === "uk" ? Pce() : Sce()
  },
  Ice = () => "Pixels painted today:",
  Cce = () => "Pixels pintados hoje:",
  Ace = () => "ä»Šæ—¥ç»˜åˆ¶åƒç´ ï¼š",
  zce = () => "Heute gemalte Pixel:",
  Ece = () => "PÃ­xeles pintados hoy:",
  Lce = () => "Pixels peints aujourd'hui :",
  Dce = () => "Pixel dipinti oggi:",
  Rce = () => "ä»Šæ—¥æã„ãŸãƒ”ã‚¯ã‚»ãƒ«æ•°ï¼š",
  jce = () => "Piksele namalowane dzisiaj:",
  Fce = () => "ĞĞ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¾ Ğ¿Ğ¸ĞºÑĞµĞ»ĞµĞ¹ ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ:",
  Bce = () => "ĞŸÑ–ĞºÑĞµĞ»Ñ–Ğ² Ğ½Ğ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ğ¾ ÑÑŒĞ¾Ğ³Ğ¾Ğ´Ğ½Ñ–:",
  Oce = () => "Sá»‘ pixel Ä‘Ã£ váº½ hÃ´m nay:",
  qce = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Ice() : r === "pt" ? Cce() : r === "ch" ? Ace() : r === "de" ? zce() : r === "es" ? Ece() : r === "fr" ? Lce() : r === "it" ? Dce() : r === "jp" ? Rce() : r === "pl" ? jce() : r === "ru" ? Fce() : r === "uk" ? Bce() : Oce()
  },
  Nce = () => "Presents earned today:",
  Vce = () => "Presentes ganhos hoje:",
  Uce = () => "ä»Šå¤©è·å¾—çš„ç¤¼ç‰©ï¼š",
  Zce = () => "Heute verdiente Geschenke:",
  Gce = () => "Regalos ganados hoy:",
  $ce = () => "Cadeaux gagnÃ©s aujourd'hui :",
  Wce = () => "Regali guadagnati oggi:",
  Hce = () => "æœ¬æ—¥ç²å¾—ã—ãŸãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆ:",
  Xce = () => "Prezenty zdobyte dzisiaj:",
  Yce = () => "ĞŸĞ¾Ğ´Ğ°Ñ€ĞºĞ¾Ğ² Ğ·Ğ°Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ¾ ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ:",
  Kce = () => "ĞŸĞ¾Ğ´Ğ°Ñ€ÑƒĞ½ĞºÑ–Ğ² Ğ·Ğ°Ñ€Ğ¾Ğ±Ğ»ĞµĞ½Ğ¾ ÑÑŒĞ¾Ğ³Ğ¾Ğ´Ğ½Ñ–:",
  Jce = () => "QuÃ  Ä‘Ã£ nháº­n hÃ´m nay:",
  Qce = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Nce() : r === "pt" ? Vce() : r === "ch" ? Uce() : r === "de" ? Zce() : r === "es" ? Gce() : r === "fr" ? $ce() : r === "it" ? Wce() : r === "jp" ? Hce() : r === "pl" ? Xce() : r === "ru" ? Yce() : r === "uk" ? Kce() : Jce()
  },
  eue = () => "Paint more pixels to earn the next present",
  tue = () => "Pinte mais pixels para ganhar o prÃ³ximo presente",
  rue = () => "ç”»æ›´å¤šåƒç´ ä»¥è·å¾—ä¸‹ä¸€ä¸ªç¤¼ç‰©",
  nue = () => "Male mehr Pixel, um das nÃ¤chste Geschenk zu verdienen",
  iue = () => "Pinta mÃ¡s pÃ­xeles para ganar el siguiente regalo",
  aue = () => "Peignez plus de pixels pour gagner le prochain cadeau",
  oue = () => "Colora piÃ¹ pixel per guadagnare il prossimo regalo",
  sue = () => "ã‚‚ã£ã¨ãƒ”ã‚¯ã‚»ãƒ«ã‚’å¡—ã£ã¦ã€æ¬¡ã®ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆã‚’æ‰‹ã«å…¥ã‚Œã¾ã—ã‚‡ã†",
  lue = () => "Maluj wiÄ™cej pikseli, aby zdobyÄ‡ nastÄ™pny prezent",
  cue = () => "ĞĞ°Ñ€Ğ¸ÑÑƒĞ¹Ñ‚Ğµ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ¿Ğ¸ĞºÑĞµĞ»ĞµĞ¹, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ·Ğ°Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ Ğ¿Ğ¾Ğ´Ğ°Ñ€Ğ¾Ğº",
  uue = () => "ĞœĞ°Ğ»ÑĞ¹Ñ‚Ğµ Ğ±Ñ–Ğ»ÑŒÑˆĞµ Ğ¿Ñ–ĞºÑĞµĞ»Ñ–Ğ², Ñ‰Ğ¾Ğ± Ğ·Ğ°Ñ€Ğ¾Ğ±Ğ¸Ñ‚Ğ¸ Ğ½Ğ°ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ğ¹ Ğ¿Ğ¾Ğ´Ğ°Ñ€ÑƒĞ½Ğ¾Ğº",
  hue = () => "TÃ´ thÃªm pixel Ä‘á»ƒ kiáº¿m mÃ³n quÃ  tiáº¿p theo",
  due = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? eue() : r === "pt" ? tue() : r === "ch" ? rue() : r === "de" ? nue() : r === "es" ? iue() : r === "fr" ? aue() : r === "it" ? oue() : r === "jp" ? sue() : r === "pl" ? lue() : r === "ru" ? cue() : r === "uk" ? uue() : hue()
  },
  pue = () => "Visit the Villages",
  fue = () => "Visite as Aldeias",
  _ue = () => "å‚è§‚æ‘åº„",
  mue = () => "Besuchen Sie die DÃ¶rfer",
  gue = () => "Visita los pueblos",
  vue = () => "Visitez les villages",
  yue = () => "Visita i villaggi",
  xue = () => "æ‘ã€…ã‚’è¨ªã‚Œã‚‹",
  bue = () => "OdwiedÅº wioski",
  wue = () => "ĞŸĞ¾ÑĞµÑ‚Ğ¸Ñ‚Ğµ Ğ´ĞµÑ€ĞµĞ²Ğ½Ğ¸",
  kue = () => "Ğ’Ñ–Ğ´Ğ²Ñ–Ğ´Ğ°Ğ¹Ñ‚Ğµ ÑĞµĞ»Ğ°",
  Tue = () => "GhÃ© thÄƒm cÃ¡c lÃ ng",
  Pue = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? pue() : r === "pt" ? fue() : r === "ch" ? _ue() : r === "de" ? mue() : r === "es" ? gue() : r === "fr" ? vue() : r === "it" ? yue() : r === "jp" ? xue() : r === "pl" ? bue() : r === "ru" ? wue() : r === "uk" ? kue() : Tue()
  },
  Sue = () => "Start",
  Mue = () => "InÃ­cio",
  Iue = () => "å¼€å§‹",
  Cue = () => "Start",
  Aue = () => "Inicio",
  zue = () => "DÃ©marrer",
  Eue = () => "Inizia",
  Lue = () => "é–‹å§‹",
  Due = () => "Start",
  Rue = () => "ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ",
  jue = () => "ĞŸĞ¾Ñ‡Ğ°Ñ‚Ğ¸",
  Fue = () => "Báº¯t Ä‘áº§u",
  Bue = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Sue() : r === "pt" ? Mue() : r === "ch" ? Iue() : r === "de" ? Cue() : r === "es" ? Aue() : r === "fr" ? zue() : r === "it" ? Eue() : r === "jp" ? Lue() : r === "pl" ? Due() : r === "ru" ? Rue() : r === "uk" ? jue() : Fue()
  },
  Oue = () => "Frame equipped!",
  que = () => "Estrutura equipada!",
  Nue = () => "æ¡†æ¶å·²è£…å¤‡ï¼",
  Vue = () => "Rahmen ausgerÃ¼stet!",
  Uue = () => "Â¡Marco equipado!",
  Zue = () => "Cadre Ã©quipÃ© !",
  Gue = () => "Telaio equipaggiato!",
  $ue = () => "ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è£…å‚™ã—ã¾ã—ãŸï¼",
  Wue = () => "Rama wyposaÅ¼ona!",
  Hue = () => "Ğ Ğ°Ğ¼Ğ° ÑĞ½Ğ°Ñ€ÑĞ¶ĞµĞ½Ğ°!",
  Xue = () => "Ğ Ğ°Ğ¼Ñƒ Ğ¾ÑĞ½Ğ°Ñ‰ĞµĞ½Ğ¾!",
  Yue = () => "ÄÃ£ trang bá»‹ khung!",
  Kue = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Oue() : r === "pt" ? que() : r === "ch" ? Nue() : r === "de" ? Vue() : r === "es" ? Uue() : r === "fr" ? Zue() : r === "it" ? Gue() : r === "jp" ? $ue() : r === "pl" ? Wue() : r === "ru" ? Hue() : r === "uk" ? Xue() : Yue()
  },
  Jue = () => "Error equipping frame. Try again later.",
  Que = () => "Erro ao equipar moldura. Tente novamente mais tarde.",
  ehe = () => "è£…å¤‡è¾¹æ¡†å¤±è´¥ã€‚è¯·ç¨åå†è¯•ã€‚",
  the = () => "Fehler beim AusrÃ¼sten des Rahmens. Versuchen Sie es spÃ¤ter erneut.",
  rhe = () => "Error al equipar el marco. IntÃ©ntalo de nuevo mÃ¡s tarde.",
  nhe = () => "Erreur lors de l'Ã©quipement du cadre. Veuillez rÃ©essayer plus tard.",
  ihe = () => "Errore durante l'equipaggiamento della cornice. Riprova piÃ¹ tardi.",
  ahe = () => "ãƒ•ãƒ¬ãƒ¼ãƒ ã®è£…å‚™ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚å¾Œã§ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚",
  ohe = () => "BÅ‚Ä…d podczas wyposaÅ¼ania ramki. SprÃ³buj ponownie pÃ³Åºniej.",
  she = () => "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞµ Ñ€Ğ°Ğ¼ĞºĞ¸. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ.",
  lhe = () => "ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ğ¿Ñ–Ğ´ Ñ‡Ğ°Ñ ĞµĞºÑ–Ğ¿Ñ–Ñ€ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ€Ğ°Ğ¼ĞºĞ¸. Ğ¡Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ñ–Ğ·Ğ½Ñ–ÑˆĞµ.",
  che = () => "Lá»—i khi trang bá»‹ khung. Vui lÃ²ng thá»­ láº¡i sau.",
  uhe = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Jue() : r === "pt" ? Que() : r === "ch" ? ehe() : r === "de" ? the() : r === "es" ? rhe() : r === "fr" ? nhe() : r === "it" ? ihe() : r === "jp" ? ahe() : r === "pl" ? ohe() : r === "ru" ? she() : r === "uk" ? lhe() : che()
  },
  hhe = () => "Frame Inventory",
  dhe = () => "InventÃ¡rio de Quadros",
  phe = () => "æ¡†æ¶åº“å­˜",
  fhe = () => "Rahmenbestand",
  _he = () => "Inventario de marcos",
  mhe = () => "Inventaire de cadres",
  ghe = () => "Inventario telai",
  vhe = () => "ãƒ•ãƒ¬ãƒ¼ãƒ åœ¨åº«",
  yhe = () => "Inwentarz ram",
  xhe = () => "Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ Ñ€Ğ°Ğ¼Ğ¾Ğº",
  bhe = () => "Ğ†Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ Ñ€Ğ°Ğ¼",
  whe = () => "Tá»“n kho khung",
  khe = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? hhe() : r === "pt" ? dhe() : r === "ch" ? phe() : r === "de" ? fhe() : r === "es" ? _he() : r === "fr" ? mhe() : r === "it" ? ghe() : r === "jp" ? vhe() : r === "pl" ? yhe() : r === "ru" ? xhe() : r === "uk" ? bhe() : whe()
  },
  The = () => "Choose a frame for your profile picture",
  Phe = () => "Escolha uma moldura para sua foto de perfil",
  She = () => "é€‰æ‹©ä¸€ä¸ªè¾¹æ¡†ä½œä¸ºæ‚¨çš„ä¸ªäººèµ„æ–™å›¾ç‰‡",
  Mhe = () => "WÃ¤hle einen Rahmen fÃ¼r dein Profilbild",
  Ihe = () => "Elige un marco para tu foto de perfil",
  Che = () => "Choisissez un cadre pour votre photo de profil",
  Ahe = () => "Scegli una cornice per la tua immagine del profilo",
  zhe = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«å†™çœŸã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é¸æŠ",
  Ehe = () => "Wybierz ramkÄ™ do swojego zdjÄ™cia profilowego",
  Lhe = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ€Ğ°Ğ¼ĞºÑƒ Ğ´Ğ»Ñ ÑĞ²Ğ¾ĞµĞ¹ Ñ„Ğ¾Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ",
  Dhe = () => "ĞĞ±ĞµÑ€Ñ–Ñ‚ÑŒ Ñ€Ğ°Ğ¼ĞºÑƒ Ğ´Ğ»Ñ ÑĞ²Ğ¾Ğ³Ğ¾ Ñ„Ğ¾Ñ‚Ğ¾ Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»Ñ",
  Rhe = () => "Chá»n má»™t khung cho áº£nh Ä‘áº¡i diá»‡n cá»§a báº¡n",
  jhe = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? The() : r === "pt" ? Phe() : r === "ch" ? She() : r === "de" ? Mhe() : r === "es" ? Ihe() : r === "fr" ? Che() : r === "it" ? Ahe() : r === "jp" ? zhe() : r === "pl" ? Ehe() : r === "ru" ? Lhe() : r === "uk" ? Dhe() : Rhe()
  },
  Fhe = () => "Your frames",
  Bhe = () => "Suas molduras",
  Ohe = () => "æ‚¨çš„å¸§",
  qhe = () => "Ihre Rahmen",
  Nhe = () => "Tus marcos",
  Vhe = () => "Vos montures",
  Uhe = () => "Le tue cornici",
  Zhe = () => "ã‚ãªãŸã®ãƒ•ãƒ¬ãƒ¼ãƒ ",
  Ghe = () => "Twoje ramki",
  $he = () => "Ğ’Ğ°ÑˆĞ¸ ĞºĞ°Ğ´Ñ€Ñ‹",
  Whe = () => "Ğ’Ğ°ÑˆÑ– Ğ¾Ğ¿Ñ€Ğ°Ğ²Ğ¸",
  Hhe = () => "Khung cá»§a báº¡n",
  Xhe = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Fhe() : r === "pt" ? Bhe() : r === "ch" ? Ohe() : r === "de" ? qhe() : r === "es" ? Nhe() : r === "fr" ? Vhe() : r === "it" ? Uhe() : r === "jp" ? Zhe() : r === "pl" ? Ghe() : r === "ru" ? $he() : r === "uk" ? Whe() : Hhe()
  },
  Yhe = () => "No frame in your profile",
  Khe = () => "Sem moldura no seu perfil",
  Jhe = () => "æ‚¨çš„ä¸ªäººèµ„æ–™ä¸­æ²¡æœ‰ç›¸æ¡†",
  Qhe = () => "Kein Rahmen in deinem Profil",
  ede = () => "Sin marco en tu perfil",
  tde = () => "Aucun cadre dans votre profil",
  rde = () => "Nessuna cornice nel tuo profilo",
  nde = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã«ãƒ•ãƒ¬ãƒ¼ãƒ ãŒã‚ã‚Šã¾ã›ã‚“",
  ide = () => "Brak ramki w Twoim profilu",
  ade = () => "ĞĞµÑ‚ Ñ€Ğ°Ğ¼ĞºĞ¸ Ğ² Ğ²Ğ°ÑˆĞµĞ¼ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğµ",
  ode = () => "Ğ£ Ğ²Ğ°ÑˆĞ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»Ñ– Ğ½ĞµĞ¼Ğ°Ñ” Ñ€Ğ°Ğ¼ĞºĞ¸",
  sde = () => "KhÃ´ng cÃ³ khung hÃ¬nh trong há»“ sÆ¡ cá»§a báº¡n",
  lde = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Yhe() : r === "pt" ? Khe() : r === "ch" ? Jhe() : r === "de" ? Qhe() : r === "es" ? ede() : r === "fr" ? tde() : r === "it" ? rde() : r === "jp" ? nde() : r === "pl" ? ide() : r === "ru" ? ade() : r === "uk" ? ode() : sde()
  },
  cde = () => "Selected",
  ude = () => "Selecionado",
  hde = () => "å·²é€‰ä¸­",
  dde = () => "AusgewÃ¤hlt",
  pde = () => "Seleccionado",
  fde = () => "SÃ©lectionnÃ©",
  _de = () => "Selezionato",
  mde = () => "é¸æŠæ¸ˆã¿",
  gde = () => "Wybrano",
  vde = () => "Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ¾",
  yde = () => "Ğ’Ğ¸Ğ±Ñ€Ğ°Ğ½Ğ¾",
  xde = () => "ÄÃ£ chá»n",
  Cv = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? cde() : r === "pt" ? ude() : r === "ch" ? hde() : r === "de" ? dde() : r === "es" ? pde() : r === "fr" ? fde() : r === "it" ? _de() : r === "jp" ? mde() : r === "pl" ? gde() : r === "ru" ? vde() : r === "uk" ? yde() : xde()
  },
  bde = () => "Frames store",
  wde = () => "Ã“tica",
  kde = () => "å¸§å­˜å‚¨",
  Tde = () => "Rahmenspeicher",
  Pde = () => "Tienda de marcos",
  Sde = () => "Magasin de cadres",
  Mde = () => "Corniceria",
  Ide = () => "ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¹ãƒˆã‚¢",
  Cde = () => "Sklep z ramkami",
  Ade = () => "ĞœĞ°Ğ³Ğ°Ğ·Ğ¸Ğ½ Ñ€Ğ°Ğ¼Ğ¾Ğº",
  zde = () => "ĞœĞ°Ğ³Ğ°Ğ·Ğ¸Ğ½ Ñ€Ğ°Ğ¼Ğ¾Ğº",
  Ede = () => "Cá»­a hÃ ng khung",
  Lde = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? bde() : r === "pt" ? wde() : r === "ch" ? kde() : r === "de" ? Tde() : r === "es" ? Pde() : r === "fr" ? Sde() : r === "it" ? Mde() : r === "jp" ? Ide() : r === "pl" ? Cde() : r === "ru" ? Ade() : r === "uk" ? zde() : Ede()
  },
  Dde = () => "We don't have frames to buy yet, wait for future updates ;)",
  Rde = () => "Ainda nÃ£o temos quadros para comprar, aguarde por futuras atualizaÃ§Ãµes ;)",
  jde = () => "æˆ‘ä»¬è¿˜æ²¡æœ‰ç›¸æ¡†å¯ä¾›è´­ä¹°ï¼Œæ•¬è¯·æœŸå¾…æœªæ¥çš„æ›´æ–° :)",
  Fde = () => "Wir haben noch keine Rahmen zum Kauf, bleibt dran fÃ¼r zukÃ¼nftige Updates ;)",
  Bde = () => "AÃºn no tenemos marcos para comprar, espera futuras actualizaciones ;)",
  Ode = () => "Nous n'avons pas encore de cadres Ã  acheter, attendez les futures mises Ã  jour ;)",
  qde = () => "Non abbiamo ancora cornici da acquistare, attendete futuri aggiornamenti ;)",
  Nde = () => "ã¾ã è³¼å…¥ã§ãã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä»Šå¾Œã®ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã‚’ãŠå¾…ã¡ãã ã•ã„ã­ ;)",
  Vde = () => "Nie mamy jeszcze ramek do kupienia, poczekaj na przyszÅ‚e aktualizacje ;)",
  Ude = () => "Ğ£ Ğ½Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ñ€Ğ°Ğ¼ Ğ´Ğ»Ñ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¸, Ğ¶Ğ´Ğ¸Ñ‚Ğµ Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ñ… Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¹ ;)",
  Zde = () => "Ğ£ Ğ½Ğ°Ñ Ñ‰Ğµ Ğ½ĞµĞ¼Ğ°Ñ” Ñ€Ğ°Ğ¼ Ğ´Ğ»Ñ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¸, Ñ‡ĞµĞºĞ°Ğ¹Ñ‚Ğµ Ğ¼Ğ°Ğ¹Ğ±ÑƒÑ‚Ğ½Ñ–Ñ… Ğ¾Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ÑŒ ;)",
  Gde = () => "ChÃºng tÃ´i chÆ°a cÃ³ khung áº£nh Ä‘á»ƒ bÃ¡n Ä‘Ã¢u, hÃ£y chá» cÃ¡c báº£n cáº­p nháº­t sáº¯p tá»›i nhÃ© ;)",
  $de = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Dde() : r === "pt" ? Rde() : r === "ch" ? jde() : r === "de" ? Fde() : r === "es" ? Bde() : r === "fr" ? Ode() : r === "it" ? qde() : r === "jp" ? Nde() : r === "pl" ? Vde() : r === "ru" ? Ude() : r === "uk" ? Zde() : Gde()
  },
  Wde = () => "Buy",
  Hde = () => "Comprar",
  Xde = () => "è´­ä¹°",
  Yde = () => "Kaufen",
  Kde = () => "Comprar",
  Jde = () => "Acheter",
  Qde = () => "Acquista",
  epe = () => "è³¼å…¥",
  tpe = () => "Kup",
  rpe = () => "ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ",
  npe = () => "ĞšÑƒĞ¿Ğ¸",
  ipe = () => "Mua",
  ape = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Wde() : r === "pt" ? Hde() : r === "ch" ? Xde() : r === "de" ? Yde() : r === "es" ? Kde() : r === "fr" ? Jde() : r === "it" ? Qde() : r === "jp" ? epe() : r === "pl" ? tpe() : r === "ru" ? rpe() : r === "uk" ? npe() : ipe()
  },
  ope = () => "None",
  spe = () => "Nenhum",
  lpe = () => "æ— ",
  cpe = () => "Keine",
  upe = () => "Ninguno",
  hpe = () => "Aucun",
  dpe = () => "Nessuno",
  ppe = () => "ãªã—",
  fpe = () => "Brak",
  _pe = () => "ĞĞµÑ‚",
  mpe = () => "Ğ–Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾",
  gpe = () => "KhÃ´ng cÃ³",
  vpe = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? ope() : r === "pt" ? spe() : r === "ch" ? lpe() : r === "de" ? cpe() : r === "es" ? upe() : r === "fr" ? hpe() : r === "it" ? dpe() : r === "jp" ? ppe() : r === "pl" ? fpe() : r === "ru" ? _pe() : r === "uk" ? mpe() : gpe()
  },
  ype = () => "No frame",
  xpe = () => "Sem moldura",
  bpe = () => "æ— è¾¹æ¡†",
  wpe = () => "Kein Rahmen",
  kpe = () => "Sin marco",
  Tpe = () => "Aucun cadre",
  Ppe = () => "Nessuna cornice",
  Spe = () => "ãƒ•ãƒ¬ãƒ¼ãƒ ãªã—",
  Mpe = () => "Brak ramki",
  Ipe = () => "Ğ‘ĞµĞ· Ñ€Ğ°Ğ¼ĞºĞ¸",
  Cpe = () => "Ğ‘ĞµĞ· Ñ€Ğ°Ğ¼ĞºĞ¸",
  Ape = () => "KhÃ´ng khung",
  zpe = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? ype() : r === "pt" ? xpe() : r === "ch" ? bpe() : r === "de" ? wpe() : r === "es" ? kpe() : r === "fr" ? Tpe() : r === "it" ? Ppe() : r === "jp" ? Spe() : r === "pl" ? Mpe() : r === "ru" ? Ipe() : r === "uk" ? Cpe() : Ape()
  },
  Epe = () => "Exclusive Frame",
  Lpe = () => "Moldura Exclusiva",
  Dpe = () => "ä¸“å±è¾¹æ¡†",
  Rpe = () => "Exklusiver Rahmen",
  jpe = () => "Marco Exclusivo",
  Fpe = () => "Cadre exclusif",
  Bpe = () => "Cornice Esclusiva",
  Ope = () => "é™å®šãƒ•ãƒ¬ãƒ¼ãƒ ",
  qpe = () => "Ekskluzywna Ramka",
  Npe = () => "Ğ­ĞºÑĞºĞ»ÑĞ·Ğ¸Ğ²Ğ½Ğ°Ñ Ñ€Ğ°Ğ¼ĞºĞ°",
  Vpe = () => "Ğ•ĞºÑĞºĞ»ÑĞ·Ğ¸Ğ²Ğ½Ğ° Ñ€Ğ°Ğ¼ĞºĞ°",
  Upe = () => "Khung Ä‘á»™c quyá»n",
  Zpe = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Epe() : r === "pt" ? Lpe() : r === "ch" ? Dpe() : r === "de" ? Rpe() : r === "es" ? jpe() : r === "fr" ? Fpe() : r === "it" ? Bpe() : r === "jp" ? Ope() : r === "pl" ? qpe() : r === "ru" ? Npe() : r === "uk" ? Vpe() : Upe()
  },
  Gpe = () => "'2025 Christmas profile frame",
  $pe = () => "Moldura de perfil de Natal de 2025",
  Wpe = () => "2025å¹´åœ£è¯èŠ‚å¤´åƒæ¡†",
  Hpe = () => "2025 Weihnachts-Profilrahmen",
  Xpe = () => "Marco de perfil navideÃ±o 2025",
  Ype = () => "Cadre de profil de NoÃ«l 2025",
  Kpe = () => "Cornice per profilo di Natale 2025",
  Jpe = () => "2025å¹´ ã‚¯ãƒªã‚¹ãƒã‚¹ ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ãƒ•ãƒ¬ãƒ¼ãƒ ",
  Qpe = () => "2025 Å›wiÄ…teczna ramka profilowa",
  efe = () => "Ğ Ğ¾Ğ¶Ğ´ĞµÑÑ‚Ğ²ĞµĞ½ÑĞºĞ°Ñ Ñ€Ğ°Ğ¼ĞºĞ° Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ 2025 Ğ³Ğ¾Ğ´Ğ°",
  tfe = () => "Ğ Ñ–Ğ·Ğ´Ğ²ÑĞ½Ğ° Ñ€Ğ°Ğ¼ĞºĞ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»Ñ 2025",
  rfe = () => "Khung áº£nh Ä‘áº¡i diá»‡n GiÃ¡ng sinh 2025",
  nfe = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Gpe() : r === "pt" ? $pe() : r === "ch" ? Wpe() : r === "de" ? Hpe() : r === "es" ? Xpe() : r === "fr" ? Ype() : r === "it" ? Kpe() : r === "jp" ? Jpe() : r === "pl" ? Qpe() : r === "ru" ? efe() : r === "uk" ? tfe() : rfe()
  },
  ife = () => "Charcoal",
  afe = () => "CarvÃ£o",
  ofe = () => "æœ¨ç‚­",
  sfe = () => "Holzkohle",
  lfe = () => "CarbÃ³n",
  cfe = () => "Charbon de bois",
  ufe = () => "Carbone",
  hfe = () => "æœ¨ç‚­",
  dfe = () => "WÄ™giel drzewny",
  pfe = () => "Ğ£Ğ³Ğ¾Ğ»ÑŒ",
  ffe = () => "Ğ’ÑƒĞ³Ñ–Ğ»Ğ»Ñ",
  _fe = () => "Than cá»§i",
  mfe = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? ife() : r === "pt" ? afe() : r === "ch" ? ofe() : r === "de" ? sfe() : r === "es" ? lfe() : r === "fr" ? cfe() : r === "it" ? ufe() : r === "jp" ? hfe() : r === "pl" ? dfe() : r === "ru" ? pfe() : r === "uk" ? ffe() : _fe()
  },
  gfe = () => "Nothing :(",
  vfe = () => "Nada :(",
  yfe = () => "ä»€ä¹ˆä¹Ÿæ²¡æœ‰ :(",
  xfe = () => "Nichts :(",
  bfe = () => "Nada :(",
  wfe = () => "Rien :(",
  kfe = () => "Niente :(",
  Tfe = () => "ä½•ã‚‚ãªã„ :(",
  Pfe = () => "Nic :(",
  Sfe = () => "ĞĞ¸Ñ‡ĞµĞ³Ğ¾ :(",
  Mfe = () => "ĞÑ–Ñ‡Ğ¾Ğ³Ğ¾ :(",
  Ife = () => "KhÃ´ng cÃ³ gÃ¬ :(",
  Cfe = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? gfe() : r === "pt" ? vfe() : r === "ch" ? yfe() : r === "de" ? xfe() : r === "es" ? bfe() : r === "fr" ? wfe() : r === "it" ? kfe() : r === "jp" ? Tfe() : r === "pl" ? Pfe() : r === "ru" ? Sfe() : r === "uk" ? Mfe() : Ife()
  },
  Afe = () => "Two presents",
  zfe = () => "Dois presentes",
  Efe = () => "ä¸¤ä»½ç¤¼ç‰©",
  Lfe = () => "Zwei Geschenke",
  Dfe = () => "Dos regalos",
  Rfe = () => "Deux cadeaux",
  jfe = () => "Due regali",
  Ffe = () => "ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆ2ã¤",
  Bfe = () => "Dwa prezenty",
  Ofe = () => "Ğ”Ğ²Ğ° Ğ¿Ğ¾Ğ´Ğ°Ñ€ĞºĞ°",
  qfe = () => "Ğ”Ğ²Ğ° Ğ¿Ğ¾Ğ´Ğ°Ñ€ÑƒĞ½ĞºĞ¸",
  Nfe = () => "Hai mÃ³n quÃ ",
  Vfe = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Afe() : r === "pt" ? zfe() : r === "ch" ? Efe() : r === "de" ? Lfe() : r === "es" ? Dfe() : r === "fr" ? Rfe() : r === "it" ? jfe() : r === "jp" ? Ffe() : r === "pl" ? Bfe() : r === "ru" ? Ofe() : r === "uk" ? qfe() : Nfe()
  },
  Ufe = () => "Two presents go again!",
  Zfe = () => "Dois presentes vÃ£o novamente!",
  Gfe = () => "ä¸¤ä»½ç¤¼ç‰©åˆæ¥äº†ï¼",
  $fe = () => "Zwei Geschenke gehen wieder!",
  Wfe = () => "Â¡Dos regalos van de nuevo!",
  Hfe = () => "Deux cadeaux repartent !",
  Xfe = () => "Due regali ripartono!",
  Yfe = () => "2ã¤ã®ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆãŒã‚‚ã†ä¸€åº¦ï¼",
  Kfe = () => "Dwa prezenty raz jeszcze!",
  Jfe = () => "Ğ”Ğ²Ğ° Ğ¿Ğ¾Ğ´Ğ°Ñ€ĞºĞ° ÑĞ½Ğ¾Ğ²Ğ° Ğ¸Ğ´ÑƒÑ‚!",
  Qfe = () => "Ğ”Ğ²Ğ° Ğ¿Ğ¾Ğ´Ğ°Ñ€ÑƒĞ½ĞºĞ¸ Ğ·Ğ½Ğ¾Ğ²Ñƒ!",
  e_e = () => "Hai mÃ³n quÃ  láº¡i tiáº¿p tá»¥c!",
  t_e = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Ufe() : r === "pt" ? Zfe() : r === "ch" ? Gfe() : r === "de" ? $fe() : r === "es" ? Wfe() : r === "fr" ? Hfe() : r === "it" ? Xfe() : r === "jp" ? Yfe() : r === "pl" ? Kfe() : r === "ru" ? Jfe() : r === "uk" ? Qfe() : e_e()
  },
  r_e = () => "Ink",
  n_e = () => "Tinta",
  i_e = () => "å¢¨æ°´",
  a_e = () => "Tinte",
  o_e = () => "Tinta",
  s_e = () => "Encre",
  l_e = () => "Inchiostro",
  c_e = () => "ã‚¤ãƒ³ã‚¯",
  u_e = () => "Atrament",
  h_e = () => "Ğ§ĞµÑ€Ğ½Ğ¸Ğ»Ğ°",
  d_e = () => "Ğ§Ğ¾Ñ€Ğ½Ğ¸Ğ»Ğ¾",
  p_e = () => "Má»±c",
  f_e = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? r_e() : r === "pt" ? n_e() : r === "ch" ? i_e() : r === "de" ? a_e() : r === "es" ? o_e() : r === "fr" ? s_e() : r === "it" ? l_e() : r === "jp" ? c_e() : r === "pl" ? u_e() : r === "ru" ? h_e() : r === "uk" ? d_e() : p_e()
  },
  __e = () => "Recharge",
  m_e = () => "Recarga",
  g_e = () => "å……å€¼",
  v_e = () => "Aufladen",
  y_e = () => "Recargar",
  x_e = () => "Recharger",
  b_e = () => "Ricarica",
  w_e = () => "ãƒãƒ£ãƒ¼ã‚¸",
  k_e = () => "DoÅ‚aduj",
  T_e = () => "ĞŸĞ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ",
  P_e = () => "ĞŸĞ¾Ğ¿Ğ¾Ğ²Ğ½Ğ¸Ñ‚Ğ¸",
  S_e = () => "Náº¡p tiá»n",
  M_e = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? __e() : r === "pt" ? m_e() : r === "ch" ? g_e() : r === "de" ? v_e() : r === "es" ? y_e() : r === "fr" ? x_e() : r === "it" ? b_e() : r === "jp" ? w_e() : r === "pl" ? k_e() : r === "ru" ? T_e() : r === "uk" ? P_e() : S_e()
  },
  I_e = () => "Choose a flag for your profile. Open the store to select it!",
  C_e = () => "Escolha uma bandeira para o seu perfil. Abra a loja para selecionÃ¡-la!",
  A_e = () => "ä¸ºæ‚¨çš„ä¸ªäººèµ„æ–™é€‰æ‹©ä¸€é¢æ——å¸œã€‚æ‰“å¼€å•†åº—é€‰æ‹©å®ƒï¼",
  z_e = () => "WÃ¤hle eine Flagge fÃ¼r dein Profil. Ã–ffne den Store, um sie auszuwÃ¤hlen!",
  E_e = () => "Elige una bandera para tu perfil. Â¡Abre la tienda para seleccionarla!",
  L_e = () => "Choisissez un drapeau pour votre profil. Ouvrez le magasin pour le sÃ©lectionner !",
  D_e = () => "Scegli una bandiera per il tuo profilo. Apri il negozio per selezionarla!",
  R_e = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç”¨ã®æ——ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚ã‚¹ãƒˆã‚¢ã‚’é–‹ã„ã¦é¸ã³ã¾ã—ã‚‡ã†ï¼",
  j_e = () => "Wybierz flagÄ™ dla swojego profilu. OtwÃ³rz sklep, aby jÄ… wybraÄ‡!",
  F_e = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ„Ğ»Ğ°Ğ³ Ğ´Ğ»Ñ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ. ĞÑ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ Ğ¼Ğ°Ğ³Ğ°Ğ·Ğ¸Ğ½, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ ĞµĞ³Ğ¾!",
  B_e = () => "Ğ’Ğ¸Ğ±ĞµÑ€Ñ–Ñ‚ÑŒ Ğ¿Ñ€Ğ°Ğ¿Ğ¾Ñ€ Ğ´Ğ»Ñ ÑĞ²Ğ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»Ñ. Ğ’Ñ–Ğ´ĞºÑ€Ğ¸Ğ¹Ñ‚Ğµ Ğ¼Ğ°Ğ³Ğ°Ğ·Ğ¸Ğ½, Ñ‰Ğ¾Ğ± Ğ²Ğ¸Ğ±Ñ€Ğ°Ñ‚Ğ¸ Ğ¹Ğ¾Ğ³Ğ¾!",
  O_e = () => "Chá»n má»™t lÃ¡ cá» cho há»“ sÆ¡ cá»§a báº¡n. Má»Ÿ cá»­a hÃ ng Ä‘á»ƒ chá»n nÃ³!",
  q_e = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? I_e() : r === "pt" ? C_e() : r === "ch" ? A_e() : r === "de" ? z_e() : r === "es" ? E_e() : r === "fr" ? L_e() : r === "it" ? D_e() : r === "jp" ? R_e() : r === "pl" ? j_e() : r === "ru" ? F_e() : r === "uk" ? B_e() : O_e()
  },
  N_e = () => "Reward claimed successfully! ğŸ„",
  V_e = () => "Recompensa resgatada com sucesso! ğŸ„",
  U_e = () => "å¥–åŠ±é¢†å–æˆåŠŸï¼ ğŸ„",
  Z_e = () => "Belohnung erfolgreich eingelÃ¶st! ğŸ„",
  G_e = () => "Â¡Recompensa reclamada con Ã©xito! ğŸ„",
  $_e = () => "RÃ©compense rÃ©clamÃ©e avec succÃ¨s ! ğŸ„",
  W_e = () => "Premio riscattato con successo! ğŸ„",
  H_e = () => "å ±é…¬ãŒæ­£å¸¸ã«ç²å¾—ã•ã‚Œã¾ã—ãŸï¼ ğŸ„",
  X_e = () => "Nagroda odebrana pomyÅ›lnie! ğŸ„",
  Y_e = () => "ĞĞ°Ğ³Ñ€Ğ°Ğ´Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ°! ğŸ„",
  K_e = () => "ĞĞ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ° ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾ Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ°! ğŸ„",
  J_e = () => "ÄÃ£ nháº­n thÆ°á»Ÿng thÃ nh cÃ´ng! ğŸ„",
  Q_e = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? N_e() : r === "pt" ? V_e() : r === "ch" ? U_e() : r === "de" ? Z_e() : r === "es" ? G_e() : r === "fr" ? $_e() : r === "it" ? W_e() : r === "jp" ? H_e() : r === "pl" ? X_e() : r === "ru" ? Y_e() : r === "uk" ? K_e() : J_e()
  },
  eme = () => "Open special presents and earn exclusive Christmas items!",
  tme = () => "Abra presentes especiais e ganhe itens exclusivos de Natal!",
  rme = () => "æ‰“å¼€ç‰¹åˆ«ç¤¼ç‰©ï¼Œèµ¢å–ä¸“å±åœ£è¯ç‰©å“ï¼",
  nme = () => "Ã–ffne besondere Geschenke und verdiene exklusive Weihnachtsartikel!",
  ime = () => "Â¡Abre regalos especiales y gana artÃ­culos exclusivos de Navidad!",
  ame = () => `Ouvrez des cadeaux spÃ©ciaux et gagnez des objets de NoÃ«l exclusifs
!`,
  ome = () => "Apri i regali speciali e ottieni oggetti natalizi esclusivi!",
  sme = () => "ç‰¹åˆ¥ãªãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆã‚’é–‹ã‘ã¦ã€é™å®šã®ã‚¯ãƒªã‚¹ãƒã‚¹ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç²å¾—ã—ã‚ˆã†ï¼",
  lme = () => "Otwieraj specjalne prezenty i zdobywaj ekskluzywne przedmioty Å›wiÄ…teczne!",
  cme = () => "ĞÑ‚ĞºÑ€Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ¾ÑĞ¾Ğ±Ñ‹Ğµ Ğ¿Ğ¾Ğ´Ğ°Ñ€ĞºĞ¸ Ğ¸ Ğ·Ğ°Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ ÑĞºÑĞºĞ»ÑĞ·Ğ¸Ğ²Ğ½Ñ‹Ğµ Ñ€Ğ¾Ğ¶Ğ´ĞµÑÑ‚Ğ²ĞµĞ½ÑĞºĞ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚Ñ‹!",
  ume = () => "Ğ’Ñ–Ğ´ĞºÑ€Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ ÑĞ¿ĞµÑ†Ñ–Ğ°Ğ»ÑŒĞ½Ñ– Ğ¿Ğ¾Ğ´Ğ°Ñ€ÑƒĞ½ĞºĞ¸ Ñ‚Ğ° Ğ·Ğ°Ñ€Ğ¾Ğ±Ğ»ÑĞ¹Ñ‚Ğµ ĞµĞºÑĞºĞ»ÑĞ·Ğ¸Ğ²Ğ½Ñ– Ñ€Ñ–Ğ·Ğ´Ğ²ÑĞ½Ñ– Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚Ğ¸!",
  hme = () => "Má»Ÿ nhá»¯ng mÃ³n quÃ  Ä‘áº·c biá»‡t vÃ  nháº­n cÃ¡c váº­t pháº©m GiÃ¡ng sinh Ä‘á»™c quyá»n!",
  dme = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? eme() : r === "pt" ? tme() : r === "ch" ? rme() : r === "de" ? nme() : r === "es" ? ime() : r === "fr" ? ame() : r === "it" ? ome() : r === "jp" ? sme() : r === "pl" ? lme() : r === "ru" ? cme() : r === "uk" ? ume() : hme()
  },
  pme = () => "You won:",
  fme = () => "VocÃª venceu:",
  _me = () => "æ‚¨èµ¢äº†:",
  mme = () => "Du hast gewonnen:",
  gme = () => "Ganaste:",
  vme = () => "Vous avez gagnÃ© :",
  yme = () => "Hai vinto:",
  xme = () => "ã‚ãªãŸãŒå‹ã¡ã¾ã—ãŸ:",
  bme = () => "WygraÅ‚eÅ›:",
  wme = () => "Ğ’Ñ‹ Ğ²Ñ‹Ğ¸Ğ³Ñ€Ğ°Ğ»Ğ¸:",
  kme = () => "Ğ’Ğ¸ Ğ²Ğ¸Ğ³Ñ€Ğ°Ğ»Ğ¸:",
  Tme = () => "Báº¡n Ä‘Ã£ tháº¯ng:",
  Pme = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? pme() : r === "pt" ? fme() : r === "ch" ? _me() : r === "de" ? mme() : r === "es" ? gme() : r === "fr" ? vme() : r === "it" ? yme() : r === "jp" ? xme() : r === "pl" ? bme() : r === "ru" ? wme() : r === "uk" ? kme() : Tme()
  },
  Sme = () => "No presents",
  Mme = () => "Sem presentes",
  Ime = () => "æ²¡æœ‰ç¤¼ç‰©",
  Cme = () => "Keine Geschenke",
  Ame = () => "Sin regalos",
  zme = () => "Pas de cadeaux",
  Eme = () => "Nessun regalo",
  Lme = () => "ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆãªã—",
  Dme = () => "Brak prezentÃ³w",
  Rme = () => "ĞŸĞ¾Ğ´Ğ°Ñ€ĞºĞ¾Ğ² Ğ½ĞµÑ‚",
  jme = () => "Ğ‘ĞµĞ· Ğ¿Ğ¾Ğ´Ğ°Ñ€ÑƒĞ½ĞºÑ–Ğ²",
  Fme = () => "KhÃ´ng cÃ³ quÃ ",
  Av = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Sme() : r === "pt" ? Mme() : r === "ch" ? Ime() : r === "de" ? Cme() : r === "es" ? Ame() : r === "fr" ? zme() : r === "it" ? Eme() : r === "jp" ? Lme() : r === "pl" ? Dme() : r === "ru" ? Rme() : r === "uk" ? jme() : Fme()
  },
  Bme = () => "Opening...",
  Ome = () => "Abrindo...",
  qme = () => "æ­£åœ¨æ‰“å¼€...",
  Nme = () => "Ã–ffnet...",
  Vme = () => "Abriendo...",
  Ume = () => "Ouverture...",
  Zme = () => "Apertura...",
  Gme = () => "é–‹ã„ã¦ã„ã¾ã™...",
  $me = () => "Otwieranie...",
  Wme = () => "ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ...",
  Hme = () => "Ğ’Ñ–Ğ´ĞºÑ€Ğ¸Ñ‚Ñ‚Ñ...",
  Xme = () => "Äang má»Ÿ...",
  Yme = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Bme() : r === "pt" ? Ome() : r === "ch" ? qme() : r === "de" ? Nme() : r === "es" ? Vme() : r === "fr" ? Ume() : r === "it" ? Zme() : r === "jp" ? Gme() : r === "pl" ? $me() : r === "ru" ? Wme() : r === "uk" ? Hme() : Xme()
  },
  Kme = d => `You still have ${d.count} presents to open!`,
  Jme = d => `VocÃª ainda tem ${d.count} presentes para abrir!`,
  Qme = d => `ä½ è¿˜æœ‰ ${d.count} ä»½ç¤¼ç‰©è¦æ‰“å¼€ï¼`,
  ege = d => `Du hast noch ${d.count} Geschenke zu Ã¶ffnen!`,
  tge = d => `Â¡AÃºn te quedan ${d.count} regalos por abrir!`,
  rge = d => `Il vous reste ${d.count} cadeaux Ã  ouvrir !`,
  nge = d => `Hai ancora ${d.count} regali da aprire!`,
  ige = d => `ã¾ã ${d.count}å€‹ã®ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆã‚’é–‹ã‘ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼`,
  age = d => `Nadal masz ${d.count} prezentÃ³w do otwarcia!`,
  oge = d => `Ğ£ Ğ²Ğ°Ñ Ğ¾ÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ ${d.count} Ğ¿Ğ¾Ğ´Ğ°Ñ€ĞºĞ¾Ğ²!`,
  sge = d => `Ğ’Ğ°Ğ¼ Ğ·Ğ°Ğ»Ğ¸ÑˆĞ¸Ğ»Ğ¾ÑÑ Ğ²Ñ–Ğ´ĞºÑ€Ğ¸Ñ‚Ğ¸ ${d.count} Ğ¿Ğ¾Ğ´Ğ°Ñ€ÑƒĞ½ĞºÑ–Ğ²!`,
  lge = d => `Báº¡n váº«n cÃ²n ${d.count} mÃ³n quÃ  Ä‘á»ƒ má»Ÿ!`,
  cge = (d, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Kme(d) : r === "pt" ? Jme(d) : r === "ch" ? Qme(d) : r === "de" ? ege(d) : r === "es" ? tge(d) : r === "fr" ? rge(d) : r === "it" ? nge(d) : r === "jp" ? ige(d) : r === "pl" ? age(d) : r === "ru" ? oge(d) : r === "uk" ? sge(d) : lge(d)
  },
  uge = () => "Open Present",
  hge = () => "Abrir Presente",
  dge = () => "æ‰“å¼€ç¤¼ç‰©",
  pge = () => "Geschenk Ã¶ffnen",
  fge = () => "Abrir regalo",
  _ge = () => "Ouvrir le cadeau",
  mge = () => "Apri Regalo",
  gge = () => "ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆã‚’é–‹ã‘ã‚‹",
  vge = () => "OtwÃ³rz prezent",
  yge = () => "ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ğ°Ñ€Ğ¾Ğº",
  xge = () => "Ğ’Ñ–Ğ´ĞºÑ€Ğ¸Ñ‚Ğ¸ Ğ¿Ğ¾Ğ´Ğ°Ñ€ÑƒĞ½Ğ¾Ğº",
  bge = () => "Má»Ÿ QuÃ ",
  U0 = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? uge() : r === "pt" ? hge() : r === "ch" ? dge() : r === "de" ? pge() : r === "es" ? fge() : r === "fr" ? _ge() : r === "it" ? mge() : r === "jp" ? gge() : r === "pl" ? vge() : r === "ru" ? yge() : r === "uk" ? xge() : bge()
  },
  wge = () => "Hide snowflakes",
  kge = () => "Ocultar flocos de neve",
  Tge = () => "éšè—é›ªèŠ±",
  Pge = () => "Schneeflocken ausblenden",
  Sge = () => "Ocultar copos de nieve",
  Mge = () => "Masquer les flocons de neige",
  Ige = () => "Nascondi fiocchi di neve",
  Cge = () => "é›ªã®çµæ™¶ã‚’éè¡¨ç¤ºã«ã™ã‚‹",
  Age = () => "Ukryj pÅ‚atki Å›niegu",
  zge = () => "Ğ¡ĞºÑ€Ñ‹Ñ‚ÑŒ ÑĞ½ĞµĞ¶Ğ¸Ğ½ĞºĞ¸",
  Ege = () => "ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ²Ğ°Ñ‚Ğ¸ ÑĞ½Ñ–Ğ¶Ğ¸Ğ½ĞºĞ¸",
  Lge = () => "áº¨n bÃ´ng tuyáº¿t",
  Dge = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? wge() : r === "pt" ? kge() : r === "ch" ? Tge() : r === "de" ? Pge() : r === "es" ? Sge() : r === "fr" ? Mge() : r === "it" ? Ige() : r === "jp" ? Cge() : r === "pl" ? Age() : r === "ru" ? zge() : r === "uk" ? Ege() : Lge()
  },
  Rge = () => "Show snowflakes",
  jge = () => "Mostrar flocos de neve",
  Fge = () => "æ˜¾ç¤ºé›ªèŠ±",
  Bge = () => "Schneeflocken anzeigen",
  Oge = () => "Mostrar copos de nieve",
  qge = () => "Afficher les flocons de neige",
  Nge = () => "Mostra fiocchi di neve",
  Vge = () => "é›ªã®çµæ™¶ã‚’è¡¨ç¤º",
  Uge = () => "PokaÅ¼ pÅ‚atki Å›niegu",
  Zge = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑĞ½ĞµĞ¶Ğ¸Ğ½ĞºĞ¸",
  Gge = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ ÑĞ½Ñ–Ğ¶Ğ¸Ğ½ĞºĞ¸",
  $ge = () => "Hiá»ƒn thá»‹ bÃ´ng tuyáº¿t",
  Wge = (d = {}, s = {}) => {
    const r = s.locale ?? Se();
    return r === "en" ? Rge() : r === "pt" ? jge() : r === "ch" ? Fge() : r === "de" ? Bge() : r === "es" ? Oge() : r === "fr" ? qge() : r === "it" ? Nge() : r === "jp" ? Vge() : r === "pl" ? Uge() : r === "ru" ? Zge() : r === "uk" ? Gge() : $ge()
  },
  us = 2 * Math.PI * 6378137 / 2;
class ja {
  constructor(s = 256) {
    vn(this, "initialResolution");
    this.tileSize = s, this.initialResolution = 2 * us / this.tileSize
  }
  latLonToMeters(s, r) {
    const x = r / 180 * us,
      A = Math.log(Math.tan((90 + s) * Math.PI / 360)) / (Math.PI / 180) * us / 180;
    return [x, A]
  }
  metersToLatLon(s, r) {
    const x = s / us * 180;
    let A = r / us * 180;
    return A = 180 / Math.PI * (2 * Math.atan(Math.exp(A * Math.PI / 180)) - Math.PI / 2), [A, x]
  }
  pixelsToMeters(s, r, x) {
    const A = this.resolution(x),
      E = s * A - us,
      k = us - r * A;
    return [E, k]
  }
  pixelsToLatLon(s, r, x) {
    const [A, E] = this.pixelsToMeters(s, r, x);
    return this.metersToLatLon(A, E)
  }
  latLonToPixels(s, r, x) {
    const [A, E] = this.latLonToMeters(s, r);
    return this.metersToPixels(A, E, x)
  }
  latLonToPixelsFloor(s, r, x) {
    const [A, E] = this.latLonToPixels(s, r, x);
    return [Math.floor(A), Math.floor(E)]
  }
  metersToPixels(s, r, x) {
    const A = this.resolution(x),
      E = (s + us) / A,
      k = (us - r) / A;
    return [E, k]
  }
  latLonToTile(s, r, x) {
    const [A, E] = this.latLonToMeters(s, r);
    return this.metersToTile(A, E, x)
  }
  metersToTile(s, r, x) {
    const [A, E] = this.metersToPixels(s, r, x);
    return this.pixelsToTile(A, E)
  }
  pixelsToTile(s, r) {
    const x = Math.ceil(s / this.tileSize) - 1,
      A = Math.ceil(r / this.tileSize) - 1;
    return [x, A]
  }
  pixelsToTileLocal(s, r) {
    return {
      tile: this.pixelsToTile(s, r),
      pixel: [Math.floor(s) % this.tileSize, Math.floor(r) % this.tileSize]
    }
  }
  tileBounds(s, r, x) {
    const [A, E] = this.pixelsToMeters(s * this.tileSize, r * this.tileSize, x), [k, l] = this.pixelsToMeters((s + 1) * this.tileSize, (r + 1) * this.tileSize, x);
    return {
      min: [A, E],
      max: [k, l]
    }
  }
  tileBoundsLatLon(s, r, x) {
    const A = this.tileBounds(s, r, x);
    return {
      min: this.metersToLatLon(A.min[0], A.min[1]),
      max: this.metersToLatLon(A.max[0], A.max[1])
    }
  }
  resolution(s) {
    return this.initialResolution / 2 ** s
  }
  latLonToTileAndPixel(s, r, x) {
    const [A, E] = this.latLonToMeters(s, r), [k, l] = this.metersToTile(A, E, x), [j, W] = this.metersToPixels(A, E, x);
    return {
      tile: [k, l],
      pixel: [Math.floor(j) % this.tileSize, Math.floor(W) % this.tileSize]
    }
  }
  pixelBounds(s, r, x) {
    return {
      min: this.pixelsToMeters(s, r, x),
      max: this.pixelsToMeters(s + 1, r + 1, x)
    }
  }
  pixelToBoundsLatLon(s, r, x) {
    const A = this.pixelBounds(s, r, x),
      E = .001885,
      k = (A.max[0] - A.min[0]) * E,
      l = (A.max[1] - A.min[1]) * E;
    return A.min[0] -= k, A.max[0] -= k, A.min[1] -= l, A.max[1] -= l, {
      min: this.metersToLatLon(A.min[0], A.min[1]),
      max: this.metersToLatLon(A.max[0], A.max[1])
    }
  }
  latLonToTileBoundsLatLon(s, r, x) {
    const [A, E] = this.latLonToMeters(s, r), [k, l] = this.metersToTile(A, E, x);
    return this.tileBoundsLatLon(k, l, x)
  }
  latLonToPixelBoundsLatLon(s, r, x) {
    const [A, E] = this.latLonToMeters(s, r), [k, l] = this.metersToPixels(A, E, x);
    return this.pixelToBoundsLatLon(Math.floor(k), Math.floor(l), x)
  }
  latLonToRegionAndPixel(s, r, x, A = Ia.regionSize) {
    const [E, k] = this.latLonToPixelsFloor(s, r, x), l = this.tileSize * A;
    return {
      region: [Math.floor(E / l), Math.floor(k / l)],
      pixel: [E % l, k % l]
    }
  }
}

function dm(d, s = !0) {
  const {
    min: r,
    max: x
  } = d;
  return s ? [
    [r[1], x[0]],
    [x[1], x[0]],
    [x[1], r[0]],
    [r[1], r[0]]
  ] : [
    [r[0], x[1]],
    [x[0], x[1]],
    [x[0], r[1]],
    [r[0], r[1]]
  ]
}

function pm(d) {
  return [(d.min[0] + d.max[0]) / 2, (d.min[1] + d.max[1]) / 2]
}
const Hge = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==",
  zv = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";

function Xge(d) {
  return Math.floor(Math.random() * d)
}
const g_ = 14.5;
async function Yge() {
  const d = Jge();
  if (d) return d;
  try {
    if ((await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted") {
      const r = await new Promise((x, A) => navigator.geolocation.getCurrentPosition(E => x(E), E => A(E)));
      return {
        lat: r.coords.latitude,
        lng: r.coords.longitude,
        zoom: g_
      }
    }
  } catch (s) {
    console.error(s)
  }
  return {
    ...Kge().pos,
    zoom: g_
  }
}

function Kge() {
  const d = Object.entries(Z0),
    s = Xge(d.length),
    [r, x] = d[s];
  return {
    city: r,
    pos: x
  }
}
const Z0 = {
    tokyo: {
      lat: 35.677545560719665,
      lng: 139.76394445809638
    },
    paris: {
      lat: 48.8537151734952,
      lng: 2.3484026030630787
    },
    newYork: {
      lat: 40.71283173786517,
      lng: -74.00599771376795
    },
    saoPaulo: {
      lat: -23.550584064565356,
      lng: -46.63339720713918
    },
    sydney: {
      lat: -33.86943325619071,
      lng: 151.2083447239608
    }
  },
  G0 = "location";

function Fo(d, s) {
  localStorage.setItem(G0, JSON.stringify({
    ...d,
    zoom: s
  }))
}

function Jge() {
  const d = localStorage.getItem(G0);
  if (!d) return;
  const s = JSON.parse(d);
  return s.zoom ?? (s.zoom = g_), s
}

function Qge(d) {
  return d.lat >= -90 && d.lat <= 90 && d.lng >= -180 && d.lng <= 180
}
var lh, ch;
class eve {
  constructor() {
    yn(this, lh, We(-1));
    yn(this, ch, We([]))
  }
  get idx() {
    return g(tr(this, lh))
  }
  set idx(s) {
    G(tr(this, lh), s, !0)
  }
  get entries() {
    return g(tr(this, ch))
  }
  set entries(s) {
    G(tr(this, ch), s)
  }
  hasNext() {
    return this.idx < this.entries.length - 1
  }
  goToNext(s) {
    const r = this.idx + 1,
      x = this.entries[r];
    x && (this.idx = r, s.flyTo({
      center: x.pos,
      zoom: x.zoom
    }))
  }
  hasPrev() {
    return this.idx > 0
  }
  goToPrev(s) {
    const r = this.idx - 1,
      x = this.entries[r];
    x && (this.idx = r, s.flyTo({
      center: x.pos,
      zoom: x.zoom
    }))
  }
  isEmpty() {
    return this.entries.length === 0
  }
  push(s) {
    this.idx = this.idx + 1, this.entries = [...this.entries.slice(0, this.idx), s]
  }
}
lh = new WeakMap, ch = new WeakMap;
const tve = new eve;

function rve(d) {
  return d && d.__esModule && Object.prototype.hasOwnProperty.call(d, "default") ? d.default : d
}
var dp = {
  exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.11.0/LICENSE.txt
 */
var nve = dp.exports,
  Ev;

function ive() {
  return Ev || (Ev = 1, (function(d, s) {
    (function(r, x) {
      d.exports = x()
    })(nve, (function() {
      var r = {},
        x = {};

      function A(k, l, j) {
        if (x[k] = j, k === "index") {
          var W = "var sharedModule = {}; (" + x.shared + ")(sharedModule); (" + x.worker + ")(sharedModule);",
            $ = {};
          return x.shared($), x.index(r, $), typeof window < "u" && r.setWorkerUrl(window.URL.createObjectURL(new Blob([W], {
            type: "text/javascript"
          }))), r
        }
      }
      A("shared", ["exports"], (function(k) {
        function l(i, t, n, o) {
          return new(n || (n = Promise))((function(u, _) {
            function m(M) {
              try {
                b(o.next(M))
              } catch (I) {
                _(I)
              }
            }

            function y(M) {
              try {
                b(o.throw(M))
              } catch (I) {
                _(I)
              }
            }

            function b(M) {
              var I;
              M.done ? u(M.value) : (I = M.value, I instanceof n ? I : new n((function(D) {
                D(I)
              }))).then(m, y)
            }
            b((o = o.apply(i, t || [])).next())
          }))
        }

        function j(i, t) {
          this.x = i, this.y = t
        }

        function W(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
        }
        var $, J;
        typeof SuppressedError == "function" && SuppressedError, j.prototype = {
          clone() {
            return new j(this.x, this.y)
          },
          add(i) {
            return this.clone()._add(i)
          },
          sub(i) {
            return this.clone()._sub(i)
          },
          multByPoint(i) {
            return this.clone()._multByPoint(i)
          },
          divByPoint(i) {
            return this.clone()._divByPoint(i)
          },
          mult(i) {
            return this.clone()._mult(i)
          },
          div(i) {
            return this.clone()._div(i)
          },
          rotate(i) {
            return this.clone()._rotate(i)
          },
          rotateAround(i, t) {
            return this.clone()._rotateAround(i, t)
          },
          matMult(i) {
            return this.clone()._matMult(i)
          },
          unit() {
            return this.clone()._unit()
          },
          perp() {
            return this.clone()._perp()
          },
          round() {
            return this.clone()._round()
          },
          mag() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
          },
          equals(i) {
            return this.x === i.x && this.y === i.y
          },
          dist(i) {
            return Math.sqrt(this.distSqr(i))
          },
          distSqr(i) {
            const t = i.x - this.x,
              n = i.y - this.y;
            return t * t + n * n
          },
          angle() {
            return Math.atan2(this.y, this.x)
          },
          angleTo(i) {
            return Math.atan2(this.y - i.y, this.x - i.x)
          },
          angleWith(i) {
            return this.angleWithSep(i.x, i.y)
          },
          angleWithSep(i, t) {
            return Math.atan2(this.x * t - this.y * i, this.x * i + this.y * t)
          },
          _matMult(i) {
            const t = i[2] * this.x + i[3] * this.y;
            return this.x = i[0] * this.x + i[1] * this.y, this.y = t, this
          },
          _add(i) {
            return this.x += i.x, this.y += i.y, this
          },
          _sub(i) {
            return this.x -= i.x, this.y -= i.y, this
          },
          _mult(i) {
            return this.x *= i, this.y *= i, this
          },
          _div(i) {
            return this.x /= i, this.y /= i, this
          },
          _multByPoint(i) {
            return this.x *= i.x, this.y *= i.y, this
          },
          _divByPoint(i) {
            return this.x /= i.x, this.y /= i.y, this
          },
          _unit() {
            return this._div(this.mag()), this
          },
          _perp() {
            const i = this.y;
            return this.y = this.x, this.x = -i, this
          },
          _rotate(i) {
            const t = Math.cos(i),
              n = Math.sin(i),
              o = n * this.x + t * this.y;
            return this.x = t * this.x - n * this.y, this.y = o, this
          },
          _rotateAround(i, t) {
            const n = Math.cos(i),
              o = Math.sin(i),
              u = t.y + o * (this.x - t.x) + n * (this.y - t.y);
            return this.x = t.x + n * (this.x - t.x) - o * (this.y - t.y), this.y = u, this
          },
          _round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
          },
          constructor: j
        }, j.convert = function(i) {
          if (i instanceof j) return i;
          if (Array.isArray(i)) return new j(+i[0], +i[1]);
          if (i.x !== void 0 && i.y !== void 0) return new j(+i.x, +i.y);
          throw new Error("Expected [x, y] or {x, y} point format")
        };
        var ce = (function() {
            if (J) return $;

            function i(t, n, o, u) {
              this.cx = 3 * t, this.bx = 3 * (o - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (u - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = o, this.p2y = u
            }
            return J = 1, $ = i, i.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, n) {
                if (n === void 0 && (n = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var o = t, u = 0; u < 8; u++) {
                  var _ = this.sampleCurveX(o) - t;
                  if (Math.abs(_) < n) return o;
                  var m = this.sampleCurveDerivativeX(o);
                  if (Math.abs(m) < 1e-6) break;
                  o -= _ / m
                }
                var y = 0,
                  b = 1;
                for (o = t, u = 0; u < 20 && (_ = this.sampleCurveX(o), !(Math.abs(_ - t) < n)); u++) t > _ ? y = o : b = o, o = .5 * (b - y) + y;
                return o
              },
              solve: function(t, n) {
                return this.sampleCurveY(this.solveCurveX(t, n))
              }
            }, $
          })(),
          ge = W(ce);
        let fe, Z;

        function de() {
          return fe == null && (fe = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), fe
        }

        function Fe() {
          if (Z == null && (Z = !1, de())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", {
              willReadFrequently: !0
            });
            if (t) {
              for (let o = 0; o < 25; o++) {
                const u = 4 * o;
                t.fillStyle = `rgb(${u},${u+1},${u+2})`, t.fillRect(o % 5, Math.floor(o / 5), 1, 1)
              }
              const n = t.getImageData(0, 0, 5, 5).data;
              for (let o = 0; o < 100; o++)
                if (o % 4 != 3 && n[o] !== o) {
                  Z = !0;
                  break
                }
            }
          }
          return Z || !1
        }
        var Re = 1e-6,
          Pe = typeof Float32Array < "u" ? Float32Array : Array;

        function Ge() {
          var i = new Pe(9);
          return Pe != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[5] = 0, i[6] = 0, i[7] = 0), i[0] = 1, i[4] = 1, i[8] = 1, i
        }

        function et(i) {
          return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
        }

        function Ve() {
          var i = new Pe(3);
          return Pe != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i
        }

        function ve(i) {
          var t = i[0],
            n = i[1],
            o = i[2];
          return Math.sqrt(t * t + n * n + o * o)
        }

        function Me(i, t, n) {
          var o = new Pe(3);
          return o[0] = i, o[1] = t, o[2] = n, o
        }

        function Ye(i, t, n) {
          return i[0] = t[0] + n[0], i[1] = t[1] + n[1], i[2] = t[2] + n[2], i
        }

        function Ce(i, t, n) {
          return i[0] = t[0] * n, i[1] = t[1] * n, i[2] = t[2] * n, i
        }

        function Oe(i, t, n) {
          var o = t[0],
            u = t[1],
            _ = t[2],
            m = n[0],
            y = n[1],
            b = n[2];
          return i[0] = u * b - _ * y, i[1] = _ * m - o * b, i[2] = o * y - u * m, i
        }
        var ut, Ue = ve;

        function Ke(i, t, n) {
          var o = t[0],
            u = t[1],
            _ = t[2],
            m = t[3];
          return i[0] = n[0] * o + n[4] * u + n[8] * _ + n[12] * m, i[1] = n[1] * o + n[5] * u + n[9] * _ + n[13] * m, i[2] = n[2] * o + n[6] * u + n[10] * _ + n[14] * m, i[3] = n[3] * o + n[7] * u + n[11] * _ + n[15] * m, i
        }

        function St() {
          var i = new Pe(4);
          return Pe != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i[3] = 1, i
        }

        function Ft(i, t, n, o) {
          var u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx",
            _ = Math.PI / 360;
          t *= _, o *= _, n *= _;
          var m = Math.sin(t),
            y = Math.cos(t),
            b = Math.sin(n),
            M = Math.cos(n),
            I = Math.sin(o),
            D = Math.cos(o);
          switch (u) {
            case "xyz":
              i[0] = m * M * D + y * b * I, i[1] = y * b * D - m * M * I, i[2] = y * M * I + m * b * D, i[3] = y * M * D - m * b * I;
              break;
            case "xzy":
              i[0] = m * M * D - y * b * I, i[1] = y * b * D - m * M * I, i[2] = y * M * I + m * b * D, i[3] = y * M * D + m * b * I;
              break;
            case "yxz":
              i[0] = m * M * D + y * b * I, i[1] = y * b * D - m * M * I, i[2] = y * M * I - m * b * D, i[3] = y * M * D + m * b * I;
              break;
            case "yzx":
              i[0] = m * M * D + y * b * I, i[1] = y * b * D + m * M * I, i[2] = y * M * I - m * b * D, i[3] = y * M * D - m * b * I;
              break;
            case "zxy":
              i[0] = m * M * D - y * b * I, i[1] = y * b * D + m * M * I, i[2] = y * M * I + m * b * D, i[3] = y * M * D - m * b * I;
              break;
            case "zyx":
              i[0] = m * M * D - y * b * I, i[1] = y * b * D + m * M * I, i[2] = y * M * I - m * b * D, i[3] = y * M * D + m * b * I;
              break;
            default:
              throw new Error("Unknown angle order " + u)
          }
          return i
        }

        function Jt() {
          var i = new Pe(2);
          return Pe != Float32Array && (i[0] = 0, i[1] = 0), i
        }

        function Mt(i, t) {
          var n = new Pe(2);
          return n[0] = i, n[1] = t, n
        }
        Ve(), ut = new Pe(4), Pe != Float32Array && (ut[0] = 0, ut[1] = 0, ut[2] = 0, ut[3] = 0), Ve(), Me(1, 0, 0), Me(0, 1, 0), St(), St(), Ge(), Jt();
        const ct = 8192;

        function wt(i, t, n) {
          return t * (ct / (i.tileSize * Math.pow(2, n - i.tileID.overscaledZ)))
        }

        function ft(i, t) {
          return (i % t + t) % t
        }

        function $t(i, t, n) {
          return i * (1 - n) + t * n
        }

        function Et(i) {
          if (i <= 0) return 0;
          if (i >= 1) return 1;
          const t = i * i,
            n = t * i;
          return 4 * (i < .5 ? n : 3 * (i - t) + n - .75)
        }

        function Qt(i, t, n, o) {
          const u = new ge(i, t, n, o);
          return _ => u.solve(_)
        }
        const vr = Qt(.25, .1, .25, 1);

        function Kt(i, t, n) {
          return Math.min(n, Math.max(t, i))
        }

        function Bt(i, t, n) {
          const o = n - t,
            u = ((i - t) % o + o) % o + t;
          return u === t ? n : u
        }

        function it(i, ...t) {
          for (const n of t)
            for (const o in n) i[o] = n[o];
          return i
        }
        let He = 1;

        function Ot(i, t, n) {
          const o = {};
          for (const u in i) o[u] = t.call(this, i[u], u, i);
          return o
        }

        function Gt(i, t, n) {
          const o = {};
          for (const u in i) t.call(this, i[u], u, i) && (o[u] = i[u]);
          return o
        }

        function kt(i) {
          return Array.isArray(i) ? i.map(kt) : typeof i == "object" && i ? Ot(i, kt) : i
        }
        const nr = {};

        function It(i) {
          nr[i] || (typeof console < "u" && console.warn(i), nr[i] = !0)
        }

        function mt(i, t, n) {
          return (n.y - i.y) * (t.x - i.x) > (t.y - i.y) * (n.x - i.x)
        }

        function yt(i) {
          return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope
        }
        let bt = null;

        function Lt(i) {
          if (bt == null) {
            const t = i.navigator ? i.navigator.userAgent : null;
            bt = !!i.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
          }
          return bt
        }

        function st(i) {
          return typeof ImageBitmap < "u" && i instanceof ImageBitmap
        }
        const lr = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";

        function gr(i, t, n, o, u) {
          return l(this, void 0, void 0, (function*() {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const _ = new VideoFrame(i, {
              timestamp: 0
            });
            try {
              const m = _ == null ? void 0 : _.format;
              if (!m || !m.startsWith("BGR") && !m.startsWith("RGB")) throw new Error(`Unrecognized format ${m}`);
              const y = m.startsWith("BGR"),
                b = new Uint8ClampedArray(o * u * 4);
              if (yield _.copyTo(b, (function(M, I, D, B, V) {
                  const H = 4 * Math.max(-I, 0),
                    K = (Math.max(0, D) - D) * B * 4 + H,
                    re = 4 * B,
                    pe = Math.max(0, I),
                    Ne = Math.max(0, D);
                  return {
                    rect: {
                      x: pe,
                      y: Ne,
                      width: Math.min(M.width, I + B) - pe,
                      height: Math.min(M.height, D + V) - Ne
                    },
                    layout: [{
                      offset: K,
                      stride: re
                    }]
                  }
                })(i, t, n, o, u)), y)
                for (let M = 0; M < b.length; M += 4) {
                  const I = b[M];
                  b[M] = b[M + 2], b[M + 2] = I
                }
              return b
            } finally {
              _.close()
            }
          }))
        }
        let dr, pr;

        function Ht(i, t, n, o) {
          return i.addEventListener(t, n, o), {
            unsubscribe: () => {
              i.removeEventListener(t, n, o)
            }
          }
        }

        function Sr(i) {
          return i * Math.PI / 180
        }

        function Rr(i) {
          return i / Math.PI * 180
        }
        const Vt = {
            touchstart: !0,
            touchmove: !0,
            touchmoveWindow: !0,
            touchend: !0,
            touchcancel: !0
          },
          Tr = {
            dblclick: !0,
            click: !0,
            mouseover: !0,
            mouseout: !0,
            mousedown: !0,
            mousemove: !0,
            mousemoveWindow: !0,
            mouseup: !0,
            mouseupWindow: !0,
            contextmenu: !0,
            wheel: !0
          },
          Xt = "AbortError";

        function ue() {
          return new Error(Xt)
        }
        const N = {
          MAX_PARALLEL_IMAGE_REQUESTS: 16,
          MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
          MAX_TILE_CACHE_ZOOM_LEVELS: 5,
          REGISTERED_PROTOCOLS: {},
          WORKER_URL: ""
        };

        function q(i) {
          return N.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))]
        }
        const X = "global-dispatcher";
        class te extends Error {
          constructor(t, n, o, u) {
            super(`AJAXError: ${n} (${t}): ${o}`), this.status = t, this.statusText = n, this.url = o, this.body = u
          }
        }
        const le = () => yt(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href,
          xe = function(i, t) {
            if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
              const o = q(i.url);
              if (o) return o(i, t);
              if (yt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: i,
                targetMapId: X
              }, t)
            }
            if (!(/^file:/.test(n = i.url) || /^file:/.test(le()) && !/^\w+:/.test(n))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(o, u) {
                return l(this, void 0, void 0, (function*() {
                  const _ = new Request(o.url, {
                    method: o.method || "GET",
                    body: o.body,
                    credentials: o.credentials,
                    headers: o.headers,
                    cache: o.cache,
                    referrer: le(),
                    signal: u.signal
                  });
                  let m, y;
                  o.type !== "json" || _.headers.has("Accept") || _.headers.set("Accept", "application/json");
                  try {
                    m = yield fetch(_)
                  } catch (M) {
                    throw new te(0, M.message, o.url, new Blob)
                  }
                  if (!m.ok) {
                    const M = yield m.blob();
                    throw new te(m.status, m.statusText, o.url, M)
                  }
                  y = o.type === "arrayBuffer" || o.type === "image" ? m.arrayBuffer() : o.type === "json" ? m.json() : m.text();
                  const b = yield y;
                  if (u.signal.aborted) throw ue();
                  return {
                    data: b,
                    cacheControl: m.headers.get("Cache-Control"),
                    expires: m.headers.get("Expires")
                  }
                }))
              })(i, t);
              if (yt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: i,
                mustQueue: !0,
                targetMapId: X
              }, t)
            }
            var n;
            return (function(o, u) {
              return new Promise(((_, m) => {
                var y;
                const b = new XMLHttpRequest;
                b.open(o.method || "GET", o.url, !0), o.type !== "arrayBuffer" && o.type !== "image" || (b.responseType = "arraybuffer");
                for (const M in o.headers) b.setRequestHeader(M, o.headers[M]);
                o.type === "json" && (b.responseType = "text", !((y = o.headers) === null || y === void 0) && y.Accept || b.setRequestHeader("Accept", "application/json")), b.withCredentials = o.credentials === "include", b.onerror = () => {
                  m(new Error(b.statusText))
                }, b.onload = () => {
                  if (!u.signal.aborted)
                    if ((b.status >= 200 && b.status < 300 || b.status === 0) && b.response !== null) {
                      let M = b.response;
                      if (o.type === "json") try {
                        M = JSON.parse(b.response)
                      } catch (I) {
                        return void m(I)
                      }
                      _({
                        data: M,
                        cacheControl: b.getResponseHeader("Cache-Control"),
                        expires: b.getResponseHeader("Expires")
                      })
                    } else {
                      const M = new Blob([b.response], {
                        type: b.getResponseHeader("Content-Type")
                      });
                      m(new te(b.status, b.statusText, o.url, M))
                    }
                }, u.signal.addEventListener("abort", (() => {
                  b.abort(), m(ue())
                })), b.send(o.body)
              }))
            })(i, t)
          };

        function je(i) {
          if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
          const t = new URL(i),
            n = window.location;
          return t.protocol === n.protocol && t.host === n.host
        }

        function Ie(i, t, n) {
          n[i] && n[i].indexOf(t) !== -1 || (n[i] = n[i] || [], n[i].push(t))
        }

        function qe(i, t, n) {
          if (n && n[i]) {
            const o = n[i].indexOf(t);
            o !== -1 && n[i].splice(o, 1)
          }
        }
        class rt {
          constructor(t, n = {}) {
            it(this, n), this.type = t
          }
        }
        class Xe extends rt {
          constructor(t, n = {}) {
            super("error", it({
              error: t
            }, n))
          }
        }
        class he {
          on(t, n) {
            return this._listeners = this._listeners || {}, Ie(t, n, this._listeners), {
              unsubscribe: () => {
                this.off(t, n)
              }
            }
          }
          off(t, n) {
            return qe(t, n, this._listeners), qe(t, n, this._oneTimeListeners), this
          }
          once(t, n) {
            return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, Ie(t, n, this._oneTimeListeners), this) : new Promise((o => this.once(t, o)))
          }
          fire(t, n) {
            typeof t == "string" && (t = new rt(t, n || {}));
            const o = t.type;
            if (this.listens(o)) {
              t.target = this;
              const u = this._listeners && this._listeners[o] ? this._listeners[o].slice() : [];
              for (const y of u) y.call(this, t);
              const _ = this._oneTimeListeners && this._oneTimeListeners[o] ? this._oneTimeListeners[o].slice() : [];
              for (const y of _) qe(o, y, this._oneTimeListeners), y.call(this, t);
              const m = this._eventedParent;
              m && (it(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), m.fire(t))
            } else t instanceof Xe && console.error(t.error);
            return this
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
          }
          setEventedParent(t, n) {
            return this._eventedParent = t, this._eventedParentData = n, this
          }
        }
        var Q = {
          $version: 8,
          $root: {
            version: {
              required: !0,
              type: "enum",
              values: [8]
            },
            name: {
              type: "string"
            },
            metadata: {
              type: "*"
            },
            center: {
              type: "array",
              value: "number"
            },
            centerAltitude: {
              type: "number"
            },
            zoom: {
              type: "number"
            },
            bearing: {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees"
            },
            pitch: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            roll: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            state: {
              type: "state",
              default: {}
            },
            light: {
              type: "light"
            },
            sky: {
              type: "sky"
            },
            projection: {
              type: "projection"
            },
            terrain: {
              type: "terrain"
            },
            sources: {
              required: !0,
              type: "sources"
            },
            sprite: {
              type: "sprite"
            },
            glyphs: {
              type: "string"
            },
            "font-faces": {
              type: "array",
              value: "fontFaces"
            },
            transition: {
              type: "transition"
            },
            layers: {
              required: !0,
              type: "array",
              value: "layer"
            }
          },
          sources: {
            "*": {
              type: "source"
            }
          },
          source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
          source_vector: {
            type: {
              required: !0,
              type: "enum",
              values: {
                vector: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            attribution: {
              type: "string"
            },
            promoteId: {
              type: "promoteId"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            encoding: {
              type: "enum",
              values: {
                mvt: {},
                mlt: {}
              },
              default: "mvt"
            },
            "*": {
              type: "*"
            }
          },
          source_raster: {
            type: {
              required: !0,
              type: "enum",
              values: {
                raster: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            attribution: {
              type: "string"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster_dem: {
            type: {
              required: !0,
              type: "enum",
              values: {
                "raster-dem": {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            attribution: {
              type: "string"
            },
            encoding: {
              type: "enum",
              values: {
                terrarium: {},
                mapbox: {},
                custom: {}
              },
              default: "mapbox"
            },
            redFactor: {
              type: "number",
              default: 1
            },
            blueFactor: {
              type: "number",
              default: 1
            },
            greenFactor: {
              type: "number",
              default: 1
            },
            baseShift: {
              type: "number",
              default: 0
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_geojson: {
            type: {
              required: !0,
              type: "enum",
              values: {
                geojson: {}
              }
            },
            data: {
              required: !0,
              type: "*"
            },
            maxzoom: {
              type: "number",
              default: 18
            },
            attribution: {
              type: "string"
            },
            buffer: {
              type: "number",
              default: 128,
              maximum: 512,
              minimum: 0
            },
            filter: {
              type: "*"
            },
            tolerance: {
              type: "number",
              default: .375
            },
            cluster: {
              type: "boolean",
              default: !1
            },
            clusterRadius: {
              type: "number",
              default: 50,
              minimum: 0
            },
            clusterMaxZoom: {
              type: "number"
            },
            clusterMinPoints: {
              type: "number"
            },
            clusterProperties: {
              type: "*"
            },
            lineMetrics: {
              type: "boolean",
              default: !1
            },
            generateId: {
              type: "boolean",
              default: !1
            },
            promoteId: {
              type: "promoteId"
            }
          },
          source_video: {
            type: {
              required: !0,
              type: "enum",
              values: {
                video: {}
              }
            },
            urls: {
              required: !0,
              type: "array",
              value: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          source_image: {
            type: {
              required: !0,
              type: "enum",
              values: {
                image: {}
              }
            },
            url: {
              required: !0,
              type: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          layer: {
            id: {
              type: "string",
              required: !0
            },
            type: {
              type: "enum",
              values: {
                fill: {},
                line: {},
                symbol: {},
                circle: {},
                heatmap: {},
                "fill-extrusion": {},
                raster: {},
                hillshade: {},
                "color-relief": {},
                background: {}
              },
              required: !0
            },
            metadata: {
              type: "*"
            },
            source: {
              type: "string"
            },
            "source-layer": {
              type: "string"
            },
            minzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            maxzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            filter: {
              type: "filter"
            },
            layout: {
              type: "layout"
            },
            paint: {
              type: "paint"
            }
          },
          layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
          layout_background: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_fill: {
            "fill-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_circle: {
            "circle-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_heatmap: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_fill-extrusion": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_line: {
            "line-cap": {
              type: "enum",
              values: {
                butt: {},
                round: {},
                square: {}
              },
              default: "butt",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-join": {
              type: "enum",
              values: {
                bevel: {},
                round: {},
                miter: {}
              },
              default: "miter",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "line-miter-limit": {
              type: "number",
              default: 2,
              requires: [{
                "line-join": "miter"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-round-limit": {
              type: "number",
              default: 1.05,
              requires: [{
                "line-join": "round"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_symbol: {
            "symbol-placement": {
              type: "enum",
              values: {
                point: {},
                line: {},
                "line-center": {}
              },
              default: "point",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-spacing": {
              type: "number",
              default: 250,
              minimum: 1,
              units: "pixels",
              requires: [{
                "symbol-placement": "line"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-avoid-edges": {
              type: "boolean",
              default: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "symbol-z-order": {
              type: "enum",
              values: {
                auto: {},
                "viewport-y": {},
                source: {}
              },
              default: "auto",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "!": "icon-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-optional": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-size": {
              type: "number",
              default: 1,
              minimum: 0,
              units: "factor of the original icon size",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-text-fit": {
              type: "enum",
              values: {
                none: {},
                width: {},
                height: {},
                both: {}
              },
              default: "none",
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-text-fit-padding": {
              type: "array",
              value: "number",
              length: 4,
              default: [0, 0, 0, 0],
              units: "pixels",
              requires: ["icon-image", "text-field", {
                "icon-text-fit": ["both", "width", "height"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-image": {
              type: "resolvedImage",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-padding": {
              type: "padding",
              default: [2],
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-keep-upright": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "icon-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-offset": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                "viewport-glyph": {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-field": {
              type: "formatted",
              default: "",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-font": {
              type: "array",
              value: "string",
              default: ["Open Sans Regular", "Arial Unicode MS Regular"],
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-size": {
              type: "number",
              default: 16,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-width": {
              type: "number",
              default: 10,
              minimum: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-line-height": {
              type: "number",
              default: 1.2,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-letter-spacing": {
              type: "number",
              default: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-justify": {
              type: "enum",
              values: {
                auto: {},
                left: {},
                center: {},
                right: {}
              },
              default: "center",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-radial-offset": {
              type: "number",
              units: "ems",
              default: 0,
              requires: ["text-field"],
              "property-type": "data-driven",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              }
            },
            "text-variable-anchor": {
              type: "array",
              value: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-variable-anchor-offset": {
              type: "variableAnchorOffsetCollection",
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["text-field", {
                "!": "text-variable-anchor"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-angle": {
              type: "number",
              default: 45,
              units: "degrees",
              requires: ["text-field", {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-writing-mode": {
              type: "array",
              value: "enum",
              values: {
                horizontal: {},
                vertical: {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-padding": {
              type: "number",
              default: 2,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-keep-upright": {
              type: "boolean",
              default: !0,
              requires: ["text-field", {
                "text-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-transform": {
              type: "enum",
              values: {
                none: {},
                uppercase: {},
                lowercase: {}
              },
              default: "none",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-offset": {
              type: "array",
              value: "number",
              units: "ems",
              length: 2,
              default: [0, 0],
              requires: ["text-field", {
                "!": "text-radial-offset"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["text-field", {
                "!": "text-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-optional": {
              type: "boolean",
              default: !1,
              requires: ["text-field", "icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_raster: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_hillshade: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_color-relief": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          filter: {
            type: "array",
            value: "*"
          },
          filter_operator: {
            type: "enum",
            values: {
              "==": {},
              "!=": {},
              ">": {},
              ">=": {},
              "<": {},
              "<=": {},
              in: {},
              "!in": {},
              all: {},
              any: {},
              none: {},
              has: {},
              "!has": {}
            }
          },
          geometry_type: {
            type: "enum",
            values: {
              Point: {},
              LineString: {},
              Polygon: {}
            }
          },
          function: {
            expression: {
              type: "expression"
            },
            stops: {
              type: "array",
              value: "function_stop"
            },
            base: {
              type: "number",
              default: 1,
              minimum: 0
            },
            property: {
              type: "string",
              default: "$zoom"
            },
            type: {
              type: "enum",
              values: {
                identity: {},
                exponential: {},
                interval: {},
                categorical: {}
              },
              default: "exponential"
            },
            colorSpace: {
              type: "enum",
              values: {
                rgb: {},
                lab: {},
                hcl: {}
              },
              default: "rgb"
            },
            default: {
              type: "*",
              required: !1
            }
          },
          function_stop: {
            type: "array",
            minimum: 0,
            maximum: 24,
            value: ["number", "color"],
            length: 2
          },
          expression: {
            type: "array",
            value: "*",
            minimum: 1
          },
          light: {
            anchor: {
              type: "enum",
              default: "viewport",
              values: {
                map: {},
                viewport: {}
              },
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              }
            },
            position: {
              type: "array",
              default: [1.15, 210, 30],
              length: 3,
              value: "number",
              "property-type": "data-constant",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            },
            color: {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            intensity: {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          sky: {
            "sky-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#88C6FC",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-ground-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-fog-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "sky-horizon-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "atmosphere-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          terrain: {
            source: {
              type: "string",
              required: !0
            },
            exaggeration: {
              type: "number",
              minimum: 0,
              default: 1
            }
          },
          projection: {
            type: {
              type: "projectionDefinition",
              default: "mercator",
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            }
          },
          paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
          paint_fill: {
            "fill-antialias": {
              type: "boolean",
              default: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-outline-color": {
              type: "color",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }, {
                "fill-antialias": !0
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            }
          },
          "paint_fill-extrusion": {
            "fill-extrusion-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-extrusion-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-extrusion-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "fill-extrusion-height": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-base": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              requires: ["fill-extrusion-height"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-vertical-gradient": {
              type: "boolean",
              default: !0,
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_line: {
            "line-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["line-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-width": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-gap-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-offset": {
              type: "number",
              default: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-dasharray": {
              type: "array",
              value: "number",
              minimum: 0,
              transition: !0,
              units: "line widths",
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-gradient": {
              type: "color",
              transition: !1,
              requires: [{
                "!": "line-dasharray"
              }, {
                "!": "line-pattern"
              }, {
                source: "geojson",
                has: {
                  lineMetrics: !0
                }
              }],
              expression: {
                interpolated: !0,
                parameters: ["line-progress"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_circle: {
            "circle-radius": {
              type: "number",
              default: 5,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-blur": {
              type: "number",
              default: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["circle-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-scale": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-stroke-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            }
          },
          paint_heatmap: {
            "heatmap-radius": {
              type: "number",
              default: 30,
              minimum: 1,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-weight": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-intensity": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "heatmap-color": {
              type: "color",
              default: ["interpolate", ["linear"],
                ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"
              ],
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["heatmap-density"]
              },
              "property-type": "color-ramp"
            },
            "heatmap-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_symbol: {
            "icon-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["icon-image", "icon-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              overridable: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["text-field", "text-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_raster: {
            "raster-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-hue-rotate": {
              type: "number",
              default: 0,
              period: 360,
              transition: !0,
              units: "degrees",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-min": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-max": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-saturation": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-contrast": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-resampling": {
              type: "enum",
              values: {
                linear: {},
                nearest: {}
              },
              default: "linear",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-fade-duration": {
              type: "number",
              default: 300,
              minimum: 0,
              transition: !1,
              units: "milliseconds",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_hillshade: {
            "hillshade-illumination-direction": {
              type: "numberArray",
              default: 335,
              minimum: 0,
              maximum: 359,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-altitude": {
              type: "numberArray",
              default: 45,
              minimum: 0,
              maximum: 90,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-exaggeration": {
              type: "number",
              default: .5,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-shadow-color": {
              type: "colorArray",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-highlight-color": {
              type: "colorArray",
              default: "#FFFFFF",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-accent-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-method": {
              type: "enum",
              values: {
                standard: {},
                basic: {},
                combined: {},
                igor: {},
                multidirectional: {}
              },
              default: "standard",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          "paint_color-relief": {
            "color-relief-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "color-relief-color": {
              type: "color",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["elevation"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_background: {
            "background-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "background-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "background-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "background-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          transition: {
            duration: {
              type: "number",
              default: 300,
              minimum: 0,
              units: "milliseconds"
            },
            delay: {
              type: "number",
              default: 0,
              minimum: 0,
              units: "milliseconds"
            }
          },
          "property-type": {
            "data-driven": {
              type: "property-type"
            },
            "cross-faded": {
              type: "property-type"
            },
            "cross-faded-data-driven": {
              type: "property-type"
            },
            "color-ramp": {
              type: "property-type"
            },
            "data-constant": {
              type: "property-type"
            },
            constant: {
              type: "property-type"
            }
          },
          promoteId: {
            "*": {
              type: "string"
            }
          }
        };
        const Ze = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];

        function vt(i, t) {
          const n = {};
          for (const o in i) o !== "ref" && (n[o] = i[o]);
          return Ze.forEach((o => {
            o in t && (n[o] = t[o])
          })), n
        }

        function Qe(i, t) {
          if (Array.isArray(i)) {
            if (!Array.isArray(t) || i.length !== t.length) return !1;
            for (let n = 0; n < i.length; n++)
              if (!Qe(i[n], t[n])) return !1;
            return !0
          }
          if (typeof i == "object" && i !== null && t !== null) {
            if (typeof t != "object" || Object.keys(i).length !== Object.keys(t).length) return !1;
            for (const n in i)
              if (!Qe(i[n], t[n])) return !1;
            return !0
          }
          return i === t
        }

        function oe(i, t) {
          i.push(t)
        }

        function De(i, t, n) {
          oe(n, {
            command: "addSource",
            args: [i, t[i]]
          })
        }

        function Je(i, t, n) {
          oe(t, {
            command: "removeSource",
            args: [i]
          }), n[i] = !0
        }

        function Tt(i, t, n, o) {
          Je(i, n, o), De(i, t, n)
        }

        function Dt(i, t, n) {
          let o;
          for (o in i[n])
            if (Object.prototype.hasOwnProperty.call(i[n], o) && o !== "data" && !Qe(i[n][o], t[n][o])) return !1;
          for (o in t[n])
            if (Object.prototype.hasOwnProperty.call(t[n], o) && o !== "data" && !Qe(i[n][o], t[n][o])) return !1;
          return !0
        }

        function _t(i, t, n, o, u, _) {
          i = i || {}, t = t || {};
          for (const m in i) Object.prototype.hasOwnProperty.call(i, m) && (Qe(i[m], t[m]) || n.push({
            command: _,
            args: [o, m, t[m], u]
          }));
          for (const m in t) Object.prototype.hasOwnProperty.call(t, m) && !Object.prototype.hasOwnProperty.call(i, m) && (Qe(i[m], t[m]) || n.push({
            command: _,
            args: [o, m, t[m], u]
          }))
        }

        function zt(i) {
          return i.id
        }

        function Yt(i, t) {
          return i[t.id] = t, i
        }
        class $e {
          constructor(t, n, o, u) {
            this.message = (t ? `${t}: ` : "") + o, u && (this.identifier = u), n != null && n.__line__ && (this.line = n.__line__)
          }
        }

        function Ct(i, ...t) {
          for (const n of t)
            for (const o in n) i[o] = n[o];
          return i
        }
        class ir extends Error {
          constructor(t, n) {
            super(n), this.message = n, this.key = t
          }
        }
        class Fr {
          constructor(t, n = []) {
            this.parent = t, this.bindings = {};
            for (const [o, u] of n) this.bindings[o] = u
          }
          concat(t) {
            return new Fr(this, t)
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`)
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t)
          }
        }
        const br = {
            kind: "null"
          },
          nt = {
            kind: "number"
          },
          cr = {
            kind: "string"
          },
          ar = {
            kind: "boolean"
          },
          Ar = {
            kind: "color"
          },
          qr = {
            kind: "projectionDefinition"
          },
          Gr = {
            kind: "object"
          },
          Mr = {
            kind: "value"
          },
          Sn = {
            kind: "collator"
          },
          Vr = {
            kind: "formatted"
          },
          Le = {
            kind: "padding"
          },
          tt = {
            kind: "colorArray"
          },
          qt = {
            kind: "numberArray"
          },
          Ut = {
            kind: "resolvedImage"
          },
          fr = {
            kind: "variableAnchorOffsetCollection"
          };

        function Wt(i, t) {
          return {
            kind: "array",
            itemType: i,
            N: t
          }
        }

        function yr(i) {
          if (i.kind === "array") {
            const t = yr(i.itemType);
            return typeof i.N == "number" ? `array<${t}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${t}>`
          }
          return i.kind
        }
        const tn = [br, nt, cr, ar, Ar, qr, Vr, Gr, Wt(Mr), Le, qt, tt, Ut, fr];

        function Kr(i, t) {
          if (t.kind === "error") return null;
          if (i.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !Kr(i.itemType, t.itemType)) && (typeof i.N != "number" || i.N === t.N)) return null
          } else {
            if (i.kind === t.kind) return null;
            if (i.kind === "value") {
              for (const n of tn)
                if (!Kr(n, t)) return null
            }
          }
          return `Expected ${yr(i)} but found ${yr(t)} instead.`
        }

        function Br(i, t) {
          return t.some((n => n.kind === i.kind))
        }

        function Cr(i, t) {
          return t.some((n => n === "null" ? i === null : n === "array" ? Array.isArray(i) : n === "object" ? i && !Array.isArray(i) && typeof i == "object" : n === typeof i))
        }

        function Yr(i, t) {
          return i.kind === "array" && t.kind === "array" ? i.itemType.kind === t.itemType.kind && typeof i.N == "number" : i.kind === t.kind
        }
        const Ln = .96422,
          In = .82521,
          Wr = 4 / 29,
          jr = 6 / 29,
          wn = 3 * jr * jr,
          En = jr * jr * jr,
          Mn = Math.PI / 180,
          qn = 180 / Math.PI;

        function Gn(i) {
          return (i %= 360) < 0 && (i += 360), i
        }

        function Jn([i, t, n, o]) {
          let u, _;
          const m = ri((.2225045 * (i = Zn(i)) + .7168786 * (t = Zn(t)) + .0606169 * (n = Zn(n))) / 1);
          i === t && t === n ? u = _ = m : (u = ri((.4360747 * i + .3850649 * t + .1430804 * n) / Ln), _ = ri((.0139322 * i + .0971045 * t + .7141733 * n) / In));
          const y = 116 * m - 16;
          return [y < 0 ? 0 : y, 500 * (u - m), 200 * (m - _), o]
        }

        function Zn(i) {
          return i <= .04045 ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4)
        }

        function ri(i) {
          return i > En ? Math.pow(i, 1 / 3) : i / wn + Wr
        }

        function la([i, t, n, o]) {
          let u = (i + 16) / 116,
            _ = isNaN(t) ? u : u + t / 500,
            m = isNaN(n) ? u : u - n / 200;
          return u = 1 * Oa(u), _ = Ln * Oa(_), m = In * Oa(m), [Hi(3.1338561 * _ - 1.6168667 * u - .4906146 * m), Hi(-.9787684 * _ + 1.9161415 * u + .033454 * m), Hi(.0719453 * _ - .2289914 * u + 1.4052427 * m), o]
        }

        function Hi(i) {
          return (i = i <= .00304 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - .055) < 0 ? 0 : i > 1 ? 1 : i
        }

        function Oa(i) {
          return i > jr ? i * i * i : wn * (i - Wr)
        }
        const qa = Object.hasOwn || function(i, t) {
          return Object.prototype.hasOwnProperty.call(i, t)
        };

        function Aa(i, t) {
          return qa(i, t) ? i[t] : void 0
        }

        function za(i) {
          return parseInt(i.padEnd(2, i), 16) / 255
        }

        function Ea(i, t) {
          return eo(t ? i / 100 : i, 0, 1)
        }

        function eo(i, t, n) {
          return Math.min(Math.max(t, i), n)
        }

        function dt(i) {
          return !i.some(Number.isNaN)
        }
        const At = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        };

        function Zt(i, t, n) {
          return i + n * (t - i)
        }

        function gn(i, t, n) {
          return i.map(((o, u) => Zt(o, t[u], n)))
        }
        class Nr {
          constructor(t, n, o, u = 1, _ = !0) {
            this.r = t, this.g = n, this.b = o, this.a = u, _ || (this.r *= u, this.g *= u, this.b *= u, u || this.overwriteGetter("rgb", [t, n, o, u]))
          }
          static parse(t) {
            if (t instanceof Nr) return t;
            if (typeof t != "string") return;
            const n = (function(o) {
              if ((o = o.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const u = Aa(At, o);
              if (u) {
                const [m, y, b] = u;
                return [m / 255, y / 255, b / 255, 1]
              }
              if (o.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(o)) {
                const m = o.length < 6 ? 1 : 2;
                let y = 1;
                return [za(o.slice(y, y += m)), za(o.slice(y, y += m)), za(o.slice(y, y += m)), za(o.slice(y, y + m) || "ff")]
              }
              if (o.startsWith("rgb")) {
                const m = o.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (m) {
                  const [y, b, M, I, D, B, V, H, K, re, pe, Ne] = m, be = [I || " ", V || " ", re].join("");
                  if (be === "  " || be === "  /" || be === ",," || be === ",,,") {
                    const Ae = [M, B, K].join(""),
                      ot = Ae === "%%%" ? 100 : Ae === "" ? 255 : 0;
                    if (ot) {
                      const gt = [eo(+b / ot, 0, 1), eo(+D / ot, 0, 1), eo(+H / ot, 0, 1), pe ? Ea(+pe, Ne) : 1];
                      if (dt(gt)) return gt
                    }
                  }
                  return
                }
              }
              const _ = o.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (_) {
                const [m, y, b, M, I, D, B, V, H] = _, K = [b || " ", I || " ", B].join("");
                if (K === "  " || K === "  /" || K === ",," || K === ",,,") {
                  const re = [+y, eo(+M, 0, 100), eo(+D, 0, 100), V ? Ea(+V, H) : 1];
                  if (dt(re)) return (function([pe, Ne, be, Ae]) {
                    function ot(gt) {
                      const er = (gt + pe / 30) % 12,
                        Pr = Ne * Math.min(be, 1 - be);
                      return be - Pr * Math.max(-1, Math.min(er - 3, 9 - er, 1))
                    }
                    return pe = Gn(pe), Ne /= 100, be /= 100, [ot(0), ot(8), ot(4), Ae]
                  })(re)
                }
              }
            })(t);
            return n ? new Nr(...n, !1) : void 0
          }
          get rgb() {
            const {
              r: t,
              g: n,
              b: o,
              a: u
            } = this, _ = u || 1 / 0;
            return this.overwriteGetter("rgb", [t / _, n / _, o / _, u])
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [n, o, u, _] = Jn(t), m = Math.sqrt(o * o + u * u);
              return [Math.round(1e4 * m) ? Gn(Math.atan2(u, o) * qn) : NaN, m, n, _]
            })(this.rgb))
          }
          get lab() {
            return this.overwriteGetter("lab", Jn(this.rgb))
          }
          overwriteGetter(t, n) {
            return Object.defineProperty(this, t, {
              value: n
            }), n
          }
          toString() {
            const [t, n, o, u] = this.rgb;
            return `rgba(${[t,n,o].map((_=>Math.round(255*_))).join(",")},${u})`
          }
          static interpolate(t, n, o, u = "rgb") {
            switch (u) {
              case "rgb": {
                const [_, m, y, b] = gn(t.rgb, n.rgb, o);
                return new Nr(_, m, y, b, !1)
              }
              case "hcl": {
                const [_, m, y, b] = t.hcl, [M, I, D, B] = n.hcl;
                let V, H;
                if (isNaN(_) || isNaN(M)) isNaN(_) ? isNaN(M) ? V = NaN : (V = M, y !== 1 && y !== 0 || (H = I)) : (V = _, D !== 1 && D !== 0 || (H = m));
                else {
                  let be = M - _;
                  M > _ && be > 180 ? be -= 360 : M < _ && _ - M > 180 && (be += 360), V = _ + o * be
                }
                const [K, re, pe, Ne] = (function([be, Ae, ot, gt]) {
                  return be = isNaN(be) ? 0 : be * Mn, la([ot, Math.cos(be) * Ae, Math.sin(be) * Ae, gt])
                })([V, H ?? Zt(m, I, o), Zt(y, D, o), Zt(b, B, o)]);
                return new Nr(K, re, pe, Ne, !1)
              }
              case "lab": {
                const [_, m, y, b] = la(gn(t.lab, n.lab, o));
                return new Nr(_, m, y, b, !1)
              }
            }
          }
        }
        Nr.black = new Nr(0, 0, 0, 1), Nr.white = new Nr(1, 1, 1, 1), Nr.transparent = new Nr(0, 0, 0, 0), Nr.red = new Nr(1, 0, 0, 1);
        class un {
          constructor(t, n, o) {
            this.sensitivity = t ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = o, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
              sensitivity: this.sensitivity,
              usage: "search"
            })
          }
          compare(t, n) {
            return this.collator.compare(t, n)
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
          }
        }
        const Fn = ["bottom", "center", "top"];
        class Rn {
          constructor(t, n, o, u, _, m) {
            this.text = t, this.image = n, this.scale = o, this.fontStack = u, this.textColor = _, this.verticalAlign = m
          }
        }
        class Xn {
          constructor(t) {
            this.sections = t
          }
          static fromString(t) {
            return new Xn([new Rn(t, null, null, null, null, null)])
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t => t.text.length !== 0 || t.image && t.image.name.length !== 0))
          }
          static factory(t) {
            return t instanceof Xn ? t : Xn.fromString(t)
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t => t.text)).join("")
          }
        }
        class zr {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof zr) return t;
            if (typeof t == "number") return new zr([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const n of t)
                if (typeof n != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]]
              }
              return new zr(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, n, o) {
            return new zr(gn(t.values, n.values, o))
          }
        }
        class mr {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof mr) return t;
            if (typeof t == "number") return new mr([t]);
            if (Array.isArray(t)) {
              for (const n of t)
                if (typeof n != "number") return;
              return new mr(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, n, o) {
            return new mr(gn(t.values, n.values, o))
          }
        }
        class nn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof nn) return t;
            if (typeof t == "string") {
              const o = Nr.parse(t);
              return o ? new nn([o]) : void 0
            }
            if (!Array.isArray(t)) return;
            const n = [];
            for (const o of t) {
              if (typeof o != "string") return;
              const u = Nr.parse(o);
              if (!u) return;
              n.push(u)
            }
            return new nn(n)
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, n, o, u = "rgb") {
            const _ = [];
            if (t.values.length != n.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${n.values.length}), cannot interpolate.`);
            for (let m = 0; m < t.values.length; m++) _.push(Nr.interpolate(t.values[m], n.values[m], o, u));
            return new nn(_)
          }
        }
        class sn extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError"
          }
          toJSON() {
            return this.message
          }
        }
        const Kn = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class kn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof kn) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let n = 0; n < t.length; n += 2) {
                const o = t[n],
                  u = t[n + 1];
                if (typeof o != "string" || !Kn.has(o) || !Array.isArray(u) || u.length !== 2 || typeof u[0] != "number" || typeof u[1] != "number") return
              }
              return new kn(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, n, o) {
            const u = t.values,
              _ = n.values;
            if (u.length !== _.length) throw new sn(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${n.toString()}`);
            const m = [];
            for (let y = 0; y < u.length; y += 2) {
              if (u[y] !== _[y]) throw new sn(`Cannot interpolate values containing mismatched anchors. from[${y}]: ${u[y]}, to[${y}]: ${_[y]}`);
              m.push(u[y]);
              const [b, M] = u[y + 1], [I, D] = _[y + 1];
              m.push([Zt(b, I, o), Zt(M, D, o)])
            }
            return new kn(m)
          }
        }
        class Cn {
          constructor(t) {
            this.name = t.name, this.available = t.available
          }
          toString() {
            return this.name
          }
          static fromString(t) {
            return t ? new Cn({
              name: t,
              available: !1
            }) : null
          }
        }
        class $n {
          constructor(t, n, o) {
            this.from = t, this.to = n, this.transition = o
          }
          static interpolate(t, n, o) {
            return new $n(t, n, o)
          }
          static parse(t) {
            return t instanceof $n ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new $n(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new $n(t.from, t.to, t.transition) : typeof t == "string" ? new $n(t, t, 1) : void 0
          }
        }

        function bi(i, t, n, o) {
          return typeof i == "number" && i >= 0 && i <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? o === void 0 || typeof o == "number" && o >= 0 && o <= 1 ? null : `Invalid rgba value [${[i,t,n,o].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof o=="number"?[i,t,n,o]:[i,t,n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }

        function Nn(i) {
          if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof $n || i instanceof Nr || i instanceof un || i instanceof Xn || i instanceof zr || i instanceof mr || i instanceof nn || i instanceof kn || i instanceof Cn) return !0;
          if (Array.isArray(i)) {
            for (const t of i)
              if (!Nn(t)) return !1;
            return !0
          }
          if (typeof i == "object") {
            for (const t in i)
              if (!Nn(i[t])) return !1;
            return !0
          }
          return !1
        }

        function fn(i) {
          if (i === null) return br;
          if (typeof i == "string") return cr;
          if (typeof i == "boolean") return ar;
          if (typeof i == "number") return nt;
          if (i instanceof Nr) return Ar;
          if (i instanceof $n) return qr;
          if (i instanceof un) return Sn;
          if (i instanceof Xn) return Vr;
          if (i instanceof zr) return Le;
          if (i instanceof mr) return qt;
          if (i instanceof nn) return tt;
          if (i instanceof kn) return fr;
          if (i instanceof Cn) return Ut;
          if (Array.isArray(i)) {
            const t = i.length;
            let n;
            for (const o of i) {
              const u = fn(o);
              if (n) {
                if (n === u) continue;
                n = Mr;
                break
              }
              n = u
            }
            return Wt(n || Mr, t)
          }
          return Gr
        }

        function _n(i) {
          const t = typeof i;
          return i === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(i) : i instanceof Nr || i instanceof $n || i instanceof Xn || i instanceof zr || i instanceof mr || i instanceof nn || i instanceof kn || i instanceof Cn ? i.toString() : JSON.stringify(i)
        }
        class Vn {
          constructor(t, n) {
            this.type = t, this.value = n
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (!Nn(t[1])) return n.error("invalid value");
            const o = t[1];
            let u = fn(o);
            const _ = n.expectedType;
            return u.kind !== "array" || u.N !== 0 || !_ || _.kind !== "array" || typeof _.N == "number" && _.N !== 0 || (u = _), new Vn(u, o)
          }
          evaluate() {
            return this.value
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        const ci = {
          string: cr,
          number: nt,
          boolean: ar,
          object: Gr
        };
        class an {
          constructor(t, n) {
            this.type = t, this.args = n
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let o, u = 1;
            const _ = t[0];
            if (_ === "array") {
              let y, b;
              if (t.length > 2) {
                const M = t[1];
                if (typeof M != "string" || !(M in ci) || M === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
                y = ci[M], u++
              } else y = Mr;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
                b = t[2], u++
              }
              o = Wt(y, b)
            } else {
              if (!ci[_]) throw new Error(`Types doesn't contain name = ${_}`);
              o = ci[_]
            }
            const m = [];
            for (; u < t.length; u++) {
              const y = n.parse(t[u], u, Mr);
              if (!y) return null;
              m.push(y)
            }
            return new an(o, m)
          }
          evaluate(t) {
            for (let n = 0; n < this.args.length; n++) {
              const o = this.args[n].evaluate(t);
              if (!Kr(this.type, fn(o))) return o;
              if (n === this.args.length - 1) throw new sn(`Expected value to be of type ${yr(this.type)}, but found ${yr(fn(o))} instead.`)
            }
            throw new Error
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const Si = {
          "to-boolean": ar,
          "to-color": Ar,
          "to-number": nt,
          "to-string": cr
        };
        class ln {
          constructor(t, n) {
            this.type = t, this.args = n
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const o = t[0];
            if (!Si[o]) throw new Error(`Can't parse ${o} as it is not part of the known types`);
            if ((o === "to-boolean" || o === "to-string") && t.length !== 2) return n.error("Expected one argument.");
            const u = Si[o],
              _ = [];
            for (let m = 1; m < t.length; m++) {
              const y = n.parse(t[m], m, Mr);
              if (!y) return null;
              _.push(y)
            }
            return new ln(u, _)
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let n, o;
                for (const u of this.args) {
                  if (n = u.evaluate(t), o = null, n instanceof Nr) return n;
                  if (typeof n == "string") {
                    const _ = t.parseColor(n);
                    if (_) return _
                  } else if (Array.isArray(n) && (o = n.length < 3 || n.length > 4 ? `Invalid rgba value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : bi(n[0], n[1], n[2], n[3]), !o)) return new Nr(n[0] / 255, n[1] / 255, n[2] / 255, n[3])
                }
                throw new sn(o || `Could not parse color from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "padding": {
                let n;
                for (const o of this.args) {
                  n = o.evaluate(t);
                  const u = zr.parse(n);
                  if (u) return u
                }
                throw new sn(`Could not parse padding from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "numberArray": {
                let n;
                for (const o of this.args) {
                  n = o.evaluate(t);
                  const u = mr.parse(n);
                  if (u) return u
                }
                throw new sn(`Could not parse numberArray from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "colorArray": {
                let n;
                for (const o of this.args) {
                  n = o.evaluate(t);
                  const u = nn.parse(n);
                  if (u) return u
                }
                throw new sn(`Could not parse colorArray from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "variableAnchorOffsetCollection": {
                let n;
                for (const o of this.args) {
                  n = o.evaluate(t);
                  const u = kn.parse(n);
                  if (u) return u
                }
                throw new sn(`Could not parse variableAnchorOffsetCollection from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "number": {
                let n = null;
                for (const o of this.args) {
                  if (n = o.evaluate(t), n === null) return 0;
                  const u = Number(n);
                  if (!isNaN(u)) return u
                }
                throw new sn(`Could not convert ${JSON.stringify(n)} to number.`)
              }
              case "formatted":
                return Xn.fromString(_n(this.args[0].evaluate(t)));
              case "resolvedImage":
                return Cn.fromString(_n(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return _n(this.args[0].evaluate(t))
            }
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const dn = ["Unknown", "Point", "LineString", "Polygon"];
        class Na {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = new Map, this.availableImages = null, this.canonical = null
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? dn[this.feature.type] : this.feature.type : null
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null
          }
          canonicalID() {
            return this.canonical
          }
          properties() {
            return this.feature && this.feature.properties || {}
          }
          parseColor(t) {
            let n = this._parseColorCache.get(t);
            return n || (n = Nr.parse(t), this._parseColorCache.set(t, n)), n
          }
        }
        class An {
          constructor(t, n, o = [], u, _ = new Fr, m = []) {
            this.registry = t, this.path = o, this.key = o.map((y => `[${y}]`)).join(""), this.scope = _, this.errors = m, this.expectedType = u, this._isConstant = n
          }
          parse(t, n, o, u, _ = {}) {
            return n ? this.concat(n, o, u)._parse(t, _) : this._parse(t, _)
          }
          _parse(t, n) {
            function o(u, _, m) {
              return m === "assert" ? new an(_, [u]) : m === "coerce" ? new ln(_, [u]) : u
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const u = t[0];
              if (typeof u != "string") return this.error(`Expression name must be a string, but found ${typeof u} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const _ = this.registry[u];
              if (_) {
                let m = _.parse(t, this);
                if (!m) return null;
                if (this.expectedType) {
                  const y = this.expectedType,
                    b = m.type;
                  if (y.kind !== "string" && y.kind !== "number" && y.kind !== "boolean" && y.kind !== "object" && y.kind !== "array" || b.kind !== "value") {
                    if (y.kind === "projectionDefinition" && ["string", "array"].includes(b.kind) || ["color", "formatted", "resolvedImage"].includes(y.kind) && ["value", "string"].includes(b.kind) || ["padding", "numberArray"].includes(y.kind) && ["value", "number", "array"].includes(b.kind) || y.kind === "colorArray" && ["value", "string", "array"].includes(b.kind) || y.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(b.kind)) m = o(m, y, n.typeAnnotation || "coerce");
                    else if (this.checkSubtype(y, b)) return null
                  } else m = o(m, y, n.typeAnnotation || "assert")
                }
                if (!(m instanceof Vn) && m.type.kind !== "resolvedImage" && this._isConstant(m)) {
                  const y = new Na;
                  try {
                    m = new Vn(m.type, m.evaluate(y))
                  } catch (b) {
                    return this.error(b.message), null
                  }
                }
                return m
              }
              return this.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0)
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
          }
          concat(t, n, o) {
            const u = typeof t == "number" ? this.path.concat(t) : this.path,
              _ = o ? this.scope.concat(o) : this.scope;
            return new An(this.registry, this._isConstant, u, n || null, _, this.errors)
          }
          error(t, ...n) {
            const o = `${this.key}${n.map((u=>`[${u}]`)).join("")}`;
            this.errors.push(new ir(o, t))
          }
          checkSubtype(t, n) {
            const o = Kr(t, n);
            return o && this.error(o), o
          }
        }
        class Bi {
          constructor(t, n) {
            this.type = n.type, this.bindings = [].concat(t), this.result = n
          }
          evaluate(t) {
            return this.result.evaluate(t)
          }
          eachChild(t) {
            for (const n of this.bindings) t(n[1]);
            t(this.result)
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);
            const o = [];
            for (let _ = 1; _ < t.length - 1; _ += 2) {
              const m = t[_];
              if (typeof m != "string") return n.error(`Expected string, but found ${typeof m} instead.`, _);
              if (/[^a-zA-Z0-9_]/.test(m)) return n.error("Variable names must contain only alphanumeric characters or '_'.", _);
              const y = n.parse(t[_ + 1], _ + 1);
              if (!y) return null;
              o.push([m, y])
            }
            const u = n.parse(t[t.length - 1], t.length - 1, n.expectedType, o);
            return u ? new Bi(o, u) : null
          }
          outputDefined() {
            return this.result.outputDefined()
          }
        }
        class Di {
          constructor(t, n) {
            this.type = n.type, this.name = t, this.boundExpression = n
          }
          static parse(t, n) {
            if (t.length !== 2 || typeof t[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
            const o = t[1];
            return n.scope.has(o) ? new Di(o, n.scope.get(o)) : n.error(`Unknown variable "${o}". Make sure "${o}" has been bound in an enclosing "let" expression before using it.`, 1)
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t)
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        class La {
          constructor(t, n, o) {
            this.type = t, this.index = n, this.input = o
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const o = n.parse(t[1], 1, nt),
              u = n.parse(t[2], 2, Wt(n.expectedType || Mr));
            return o && u ? new La(u.type.itemType, o, u) : null
          }
          evaluate(t) {
            const n = this.index.evaluate(t),
              o = this.input.evaluate(t);
            if (n < 0) throw new sn(`Array index out of bounds: ${n} < 0.`);
            if (n >= o.length) throw new sn(`Array index out of bounds: ${n} > ${o.length-1}.`);
            if (n !== Math.floor(n)) throw new sn(`Array index must be an integer, but found ${n} instead.`);
            return o[n]
          }
          eachChild(t) {
            t(this.index), t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class Da {
          constructor(t, n) {
            this.type = ar, this.needle = t, this.haystack = n
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const o = n.parse(t[1], 1, Mr),
              u = n.parse(t[2], 2, Mr);
            return o && u ? Br(o.type, [ar, cr, nt, br, Mr]) ? new Da(o, u) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${yr(o.type)} instead`) : null
          }
          evaluate(t) {
            const n = this.needle.evaluate(t),
              o = this.haystack.evaluate(t);
            if (!o) return !1;
            if (!Cr(n, ["boolean", "string", "number", "null"])) throw new sn(`Expected first argument to be of type boolean, string, number or null, but found ${yr(fn(n))} instead.`);
            if (!Cr(o, ["string", "array"])) throw new sn(`Expected second argument to be of type array or string, but found ${yr(fn(o))} instead.`);
            return o.indexOf(n) >= 0
          }
          eachChild(t) {
            t(this.needle), t(this.haystack)
          }
          outputDefined() {
            return !0
          }
        }
        class ga {
          constructor(t, n, o) {
            this.type = nt, this.needle = t, this.haystack = n, this.fromIndex = o
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 2 or 3 arguments, but found ${t.length-1} instead.`);
            const o = n.parse(t[1], 1, Mr),
              u = n.parse(t[2], 2, Mr);
            if (!o || !u) return null;
            if (!Br(o.type, [ar, cr, nt, br, Mr])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${yr(o.type)} instead`);
            if (t.length === 4) {
              const _ = n.parse(t[3], 3, nt);
              return _ ? new ga(o, u, _) : null
            }
            return new ga(o, u)
          }
          evaluate(t) {
            const n = this.needle.evaluate(t),
              o = this.haystack.evaluate(t);
            if (!Cr(n, ["boolean", "string", "number", "null"])) throw new sn(`Expected first argument to be of type boolean, string, number or null, but found ${yr(fn(n))} instead.`);
            let u;
            if (this.fromIndex && (u = this.fromIndex.evaluate(t)), Cr(o, ["string"])) {
              const _ = o.indexOf(n, u);
              return _ === -1 ? -1 : [...o.slice(0, _)].length
            }
            if (Cr(o, ["array"])) return o.indexOf(n, u);
            throw new sn(`Expected second argument to be of type array or string, but found ${yr(fn(o))} instead.`)
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex)
          }
          outputDefined() {
            return !1
          }
        }
        class va {
          constructor(t, n, o, u, _, m) {
            this.inputType = t, this.type = n, this.input = o, this.cases = u, this.outputs = _, this.otherwise = m
          }
          static parse(t, n) {
            if (t.length < 5) return n.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 1) return n.error("Expected an even number of arguments.");
            let o, u;
            n.expectedType && n.expectedType.kind !== "value" && (u = n.expectedType);
            const _ = {},
              m = [];
            for (let M = 2; M < t.length - 1; M += 2) {
              let I = t[M];
              const D = t[M + 1];
              Array.isArray(I) || (I = [I]);
              const B = n.concat(M);
              if (I.length === 0) return B.error("Expected at least one branch label.");
              for (const H of I) {
                if (typeof H != "number" && typeof H != "string") return B.error("Branch labels must be numbers or strings.");
                if (typeof H == "number" && Math.abs(H) > Number.MAX_SAFE_INTEGER) return B.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof H == "number" && Math.floor(H) !== H) return B.error("Numeric branch labels must be integer values.");
                if (o) {
                  if (B.checkSubtype(o, fn(H))) return null
                } else o = fn(H);
                if (_[String(H)] !== void 0) return B.error("Branch labels must be unique.");
                _[String(H)] = m.length
              }
              const V = n.parse(D, M, u);
              if (!V) return null;
              u = u || V.type, m.push(V)
            }
            const y = n.parse(t[1], 1, Mr);
            if (!y) return null;
            const b = n.parse(t[t.length - 1], t.length - 1, u);
            return b ? y.type.kind !== "value" && n.concat(1).checkSubtype(o, y.type) ? null : new va(o, u, y, _, m, b) : null
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            return (fn(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(t)
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class to {
          constructor(t, n, o) {
            this.type = t, this.branches = n, this.otherwise = o
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 0) return n.error("Expected an odd number of arguments.");
            let o;
            n.expectedType && n.expectedType.kind !== "value" && (o = n.expectedType);
            const u = [];
            for (let m = 1; m < t.length - 1; m += 2) {
              const y = n.parse(t[m], m, ar);
              if (!y) return null;
              const b = n.parse(t[m + 1], m + 1, o);
              if (!b) return null;
              u.push([y, b]), o = o || b.type
            }
            const _ = n.parse(t[t.length - 1], t.length - 1, o);
            if (!_) return null;
            if (!o) throw new Error("Can't infer output type");
            return new to(o, u, _)
          }
          evaluate(t) {
            for (const [n, o] of this.branches)
              if (n.evaluate(t)) return o.evaluate(t);
            return this.otherwise.evaluate(t)
          }
          eachChild(t) {
            for (const [n, o] of this.branches) t(n), t(o);
            t(this.otherwise)
          }
          outputDefined() {
            return this.branches.every((([t, n]) => n.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class so {
          constructor(t, n, o, u) {
            this.type = t, this.input = n, this.beginIndex = o, this.endIndex = u
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 2 or 3 arguments, but found ${t.length-1} instead.`);
            const o = n.parse(t[1], 1, Mr),
              u = n.parse(t[2], 2, nt);
            if (!o || !u) return null;
            if (!Br(o.type, [Wt(Mr), cr, Mr])) return n.error(`Expected first argument to be of type array or string, but found ${yr(o.type)} instead`);
            if (t.length === 4) {
              const _ = n.parse(t[3], 3, nt);
              return _ ? new so(o.type, o, u, _) : null
            }
            return new so(o.type, o, u)
          }
          evaluate(t) {
            const n = this.input.evaluate(t),
              o = this.beginIndex.evaluate(t);
            let u;
            if (this.endIndex && (u = this.endIndex.evaluate(t)), Cr(n, ["string"])) return [...n].slice(o, u).join("");
            if (Cr(n, ["array"])) return n.slice(o, u);
            throw new sn(`Expected first argument to be of type array or string, but found ${yr(fn(n))} instead.`)
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex)
          }
          outputDefined() {
            return !1
          }
        }

        function ii(i, t) {
          const n = i.length - 1;
          let o, u, _ = 0,
            m = n,
            y = 0;
          for (; _ <= m;)
            if (y = Math.floor((_ + m) / 2), o = i[y], u = i[y + 1], o <= t) {
              if (y === n || t < u) return y;
              _ = y + 1
            } else {
              if (!(o > t)) throw new sn("Input is not a number.");
              m = y - 1
            } return 0
        }
        class ui {
          constructor(t, n, o) {
            this.type = t, this.input = n, this.labels = [], this.outputs = [];
            for (const [u, _] of o) this.labels.push(u), this.outputs.push(_)
          }
          static parse(t, n) {
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            const o = n.parse(t[1], 1, nt);
            if (!o) return null;
            const u = [];
            let _ = null;
            n.expectedType && n.expectedType.kind !== "value" && (_ = n.expectedType);
            for (let m = 1; m < t.length; m += 2) {
              const y = m === 1 ? -1 / 0 : t[m],
                b = t[m + 1],
                M = m,
                I = m + 1;
              if (typeof y != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', M);
              if (u.length && u[u.length - 1][0] >= y) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', M);
              const D = n.parse(b, I, _);
              if (!D) return null;
              _ = _ || D.type, u.push([y, D])
            }
            return new ui(_, o, u)
          }
          evaluate(t) {
            const n = this.labels,
              o = this.outputs;
            if (n.length === 1) return o[0].evaluate(t);
            const u = this.input.evaluate(t);
            if (u <= n[0]) return o[0].evaluate(t);
            const _ = n.length;
            return u >= n[_ - 1] ? o[_ - 1].evaluate(t) : o[ii(n, u)].evaluate(t)
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function Xi(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
        }
        var ai, ca, lo = (function() {
            if (ca) return ai;

            function i(t, n, o, u) {
              this.cx = 3 * t, this.bx = 3 * (o - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (u - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = o, this.p2y = u
            }
            return ca = 1, ai = i, i.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, n) {
                if (n === void 0 && (n = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var o = t, u = 0; u < 8; u++) {
                  var _ = this.sampleCurveX(o) - t;
                  if (Math.abs(_) < n) return o;
                  var m = this.sampleCurveDerivativeX(o);
                  if (Math.abs(m) < 1e-6) break;
                  o -= _ / m
                }
                var y = 0,
                  b = 1;
                for (o = t, u = 0; u < 20 && (_ = this.sampleCurveX(o), !(Math.abs(_ - t) < n)); u++) t > _ ? y = o : b = o, o = .5 * (b - y) + y;
                return o
              },
              solve: function(t, n) {
                return this.sampleCurveY(this.solveCurveX(t, n))
              }
            }, ai
          })(),
          co = Xi(lo);
        class On {
          constructor(t, n, o, u, _) {
            this.type = t, this.operator = n, this.interpolation = o, this.input = u, this.labels = [], this.outputs = [];
            for (const [m, y] of _) this.labels.push(m), this.outputs.push(y)
          }
          static interpolationFactor(t, n, o, u) {
            let _ = 0;
            if (t.name === "exponential") _ = xs(n, t.base, o, u);
            else if (t.name === "linear") _ = xs(n, 1, o, u);
            else if (t.name === "cubic-bezier") {
              const m = t.controlPoints;
              _ = new co(m[0], m[1], m[2], m[3]).solve(xs(n, 1, o, u))
            }
            return _
          }
          static parse(t, n) {
            let [o, u, _, ...m] = t;
            if (!Array.isArray(u) || u.length === 0) return n.error("Expected an interpolation type expression.", 1);
            if (u[0] === "linear") u = {
              name: "linear"
            };
            else if (u[0] === "exponential") {
              const M = u[1];
              if (typeof M != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
              u = {
                name: "exponential",
                base: M
              }
            } else {
              if (u[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(u[0])}`, 1, 0);
              {
                const M = u.slice(1);
                if (M.length !== 4 || M.some((I => typeof I != "number" || I < 0 || I > 1))) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                u = {
                  name: "cubic-bezier",
                  controlPoints: M
                }
              }
            }
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            if (_ = n.parse(_, 2, nt), !_) return null;
            const y = [];
            let b = null;
            o !== "interpolate-hcl" && o !== "interpolate-lab" || n.expectedType == tt ? n.expectedType && n.expectedType.kind !== "value" && (b = n.expectedType) : b = Ar;
            for (let M = 0; M < m.length; M += 2) {
              const I = m[M],
                D = m[M + 1],
                B = M + 3,
                V = M + 4;
              if (typeof I != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', B);
              if (y.length && y[y.length - 1][0] >= I) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', B);
              const H = n.parse(D, V, b);
              if (!H) return null;
              b = b || H.type, y.push([I, H])
            }
            return Yr(b, nt) || Yr(b, qr) || Yr(b, Ar) || Yr(b, Le) || Yr(b, qt) || Yr(b, tt) || Yr(b, fr) || Yr(b, Wt(nt)) ? new On(b, o, u, _, y) : n.error(`Type ${yr(b)} is not interpolatable.`)
          }
          evaluate(t) {
            const n = this.labels,
              o = this.outputs;
            if (n.length === 1) return o[0].evaluate(t);
            const u = this.input.evaluate(t);
            if (u <= n[0]) return o[0].evaluate(t);
            const _ = n.length;
            if (u >= n[_ - 1]) return o[_ - 1].evaluate(t);
            const m = ii(n, u),
              y = On.interpolationFactor(this.interpolation, u, n[m], n[m + 1]),
              b = o[m].evaluate(t),
              M = o[m + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Zt(b, M, y);
                  case "color":
                    return Nr.interpolate(b, M, y);
                  case "padding":
                    return zr.interpolate(b, M, y);
                  case "colorArray":
                    return nn.interpolate(b, M, y);
                  case "numberArray":
                    return mr.interpolate(b, M, y);
                  case "variableAnchorOffsetCollection":
                    return kn.interpolate(b, M, y);
                  case "array":
                    return gn(b, M, y);
                  case "projectionDefinition":
                    return $n.interpolate(b, M, y)
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return Nr.interpolate(b, M, y, "hcl");
                  case "colorArray":
                    return nn.interpolate(b, M, y, "hcl")
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return Nr.interpolate(b, M, y, "lab");
                  case "colorArray":
                    return nn.interpolate(b, M, y, "lab")
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function xs(i, t, n, o) {
          const u = o - n,
            _ = i - n;
          return u === 0 ? 0 : t === 1 ? _ / u : (Math.pow(t, _) - 1) / (Math.pow(t, u) - 1)
        }
        const Yi = {
          color: Nr.interpolate,
          number: Zt,
          padding: zr.interpolate,
          numberArray: mr.interpolate,
          colorArray: nn.interpolate,
          variableAnchorOffsetCollection: kn.interpolate,
          array: gn
        };
        class uo {
          constructor(t, n) {
            this.type = t, this.args = n
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let o = null;
            const u = n.expectedType;
            u && u.kind !== "value" && (o = u);
            const _ = [];
            for (const y of t.slice(1)) {
              const b = n.parse(y, 1 + _.length, o, void 0, {
                typeAnnotation: "omit"
              });
              if (!b) return null;
              o = o || b.type, _.push(b)
            }
            if (!o) throw new Error("No output type");
            const m = u && _.some((y => Kr(u, y.type)));
            return new uo(m ? Mr : o, _)
          }
          evaluate(t) {
            let n, o = null,
              u = 0;
            for (const _ of this.args)
              if (u++, o = _.evaluate(t), o && o instanceof Cn && !o.available && (n || (n = o.name), o = null, u === this.args.length && (o = n)), o !== null) break;
            return o
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }

        function Ml(i, t) {
          return i === "==" || i === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
        }

        function Uo(i, t, n, o) {
          return o.compare(t, n) === 0
        }

        function ho(i, t, n) {
          const o = i !== "==" && i !== "!=";
          return class $0 {
            constructor(_, m, y) {
              this.type = ar, this.lhs = _, this.rhs = m, this.collator = y, this.hasUntypedArgument = _.type.kind === "value" || m.type.kind === "value"
            }
            static parse(_, m) {
              if (_.length !== 3 && _.length !== 4) return m.error("Expected two or three arguments.");
              const y = _[0];
              let b = m.parse(_[1], 1, Mr);
              if (!b) return null;
              if (!Ml(y, b.type)) return m.concat(1).error(`"${y}" comparisons are not supported for type '${yr(b.type)}'.`);
              let M = m.parse(_[2], 2, Mr);
              if (!M) return null;
              if (!Ml(y, M.type)) return m.concat(2).error(`"${y}" comparisons are not supported for type '${yr(M.type)}'.`);
              if (b.type.kind !== M.type.kind && b.type.kind !== "value" && M.type.kind !== "value") return m.error(`Cannot compare types '${yr(b.type)}' and '${yr(M.type)}'.`);
              o && (b.type.kind === "value" && M.type.kind !== "value" ? b = new an(M.type, [b]) : b.type.kind !== "value" && M.type.kind === "value" && (M = new an(b.type, [M])));
              let I = null;
              if (_.length === 4) {
                if (b.type.kind !== "string" && M.type.kind !== "string" && b.type.kind !== "value" && M.type.kind !== "value") return m.error("Cannot use collator to compare non-string types.");
                if (I = m.parse(_[3], 3, Sn), !I) return null
              }
              return new $0(b, M, I)
            }
            evaluate(_) {
              const m = this.lhs.evaluate(_),
                y = this.rhs.evaluate(_);
              if (o && this.hasUntypedArgument) {
                const b = fn(m),
                  M = fn(y);
                if (b.kind !== M.kind || b.kind !== "string" && b.kind !== "number") throw new sn(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${b.kind}, ${M.kind}) instead.`)
              }
              if (this.collator && !o && this.hasUntypedArgument) {
                const b = fn(m),
                  M = fn(y);
                if (b.kind !== "string" || M.kind !== "string") return t(_, m, y)
              }
              return this.collator ? n(_, m, y, this.collator.evaluate(_)) : t(_, m, y)
            }
            eachChild(_) {
              _(this.lhs), _(this.rhs), this.collator && _(this.collator)
            }
            outputDefined() {
              return !0
            }
          }
        }
        const Uc = ho("==", (function(i, t, n) {
            return t === n
          }), Uo),
          Up = ho("!=", (function(i, t, n) {
            return t !== n
          }), (function(i, t, n, o) {
            return !Uo(0, t, n, o)
          })),
          Vh = ho("<", (function(i, t, n) {
            return t < n
          }), (function(i, t, n, o) {
            return o.compare(t, n) < 0
          })),
          Il = ho(">", (function(i, t, n) {
            return t > n
          }), (function(i, t, n, o) {
            return o.compare(t, n) > 0
          })),
          Cl = ho("<=", (function(i, t, n) {
            return t <= n
          }), (function(i, t, n, o) {
            return o.compare(t, n) <= 0
          })),
          Va = ho(">=", (function(i, t, n) {
            return t >= n
          }), (function(i, t, n, o) {
            return o.compare(t, n) >= 0
          }));
        class Zs {
          constructor(t, n, o) {
            this.type = Sn, this.locale = o, this.caseSensitive = t, this.diacriticSensitive = n
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected one argument.");
            const o = t[1];
            if (typeof o != "object" || Array.isArray(o)) return n.error("Collator options argument must be an object.");
            const u = n.parse(o["case-sensitive"] !== void 0 && o["case-sensitive"], 1, ar);
            if (!u) return null;
            const _ = n.parse(o["diacritic-sensitive"] !== void 0 && o["diacritic-sensitive"], 1, ar);
            if (!_) return null;
            let m = null;
            return o.locale && (m = n.parse(o.locale, 1, cr), !m) ? null : new Zs(u, _, m)
          }
          evaluate(t) {
            return new un(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null)
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale)
          }
          outputDefined() {
            return !1
          }
        }
        class bs {
          constructor(t, n, o, u, _) {
            this.type = cr, this.number = t, this.locale = n, this.currency = o, this.minFractionDigits = u, this.maxFractionDigits = _
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error("Expected two arguments.");
            const o = n.parse(t[1], 1, nt);
            if (!o) return null;
            const u = t[2];
            if (typeof u != "object" || Array.isArray(u)) return n.error("NumberFormat options argument must be an object.");
            let _ = null;
            if (u.locale && (_ = n.parse(u.locale, 1, cr), !_)) return null;
            let m = null;
            if (u.currency && (m = n.parse(u.currency, 1, cr), !m)) return null;
            let y = null;
            if (u["min-fraction-digits"] && (y = n.parse(u["min-fraction-digits"], 1, nt), !y)) return null;
            let b = null;
            return u["max-fraction-digits"] && (b = n.parse(u["max-fraction-digits"], 1, nt), !b) ? null : new bs(o, _, m, y, b)
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
              style: this.currency ? "currency" : "decimal",
              currency: this.currency ? this.currency.evaluate(t) : void 0,
              minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
              maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
            }).format(this.number.evaluate(t))
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits)
          }
          outputDefined() {
            return !1
          }
        }
        class Al {
          constructor(t) {
            this.type = Vr, this.sections = t
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const o = t[1];
            if (!Array.isArray(o) && typeof o == "object") return n.error("First argument must be an image or text section.");
            const u = [];
            let _ = !1;
            for (let m = 1; m <= t.length - 1; ++m) {
              const y = t[m];
              if (_ && typeof y == "object" && !Array.isArray(y)) {
                _ = !1;
                let b = null;
                if (y["font-scale"] && (b = n.parse(y["font-scale"], 1, nt), !b)) return null;
                let M = null;
                if (y["text-font"] && (M = n.parse(y["text-font"], 1, Wt(cr)), !M)) return null;
                let I = null;
                if (y["text-color"] && (I = n.parse(y["text-color"], 1, Ar), !I)) return null;
                let D = null;
                if (y["vertical-align"]) {
                  if (typeof y["vertical-align"] == "string" && !Fn.includes(y["vertical-align"])) return n.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${y["vertical-align"]}' instead.`);
                  if (D = n.parse(y["vertical-align"], 1, cr), !D) return null
                }
                const B = u[u.length - 1];
                B.scale = b, B.font = M, B.textColor = I, B.verticalAlign = D
              } else {
                const b = n.parse(t[m], 1, Mr);
                if (!b) return null;
                const M = b.type.kind;
                if (M !== "string" && M !== "value" && M !== "null" && M !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                _ = !0, u.push({
                  content: b,
                  scale: null,
                  font: null,
                  textColor: null,
                  verticalAlign: null
                })
              }
            }
            return new Al(u)
          }
          evaluate(t) {
            return new Xn(this.sections.map((n => {
              const o = n.content.evaluate(t);
              return fn(o) === Ut ? new Rn("", o, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null) : new Rn(_n(o), null, n.scale ? n.scale.evaluate(t) : null, n.font ? n.font.evaluate(t).join(",") : null, n.textColor ? n.textColor.evaluate(t) : null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null)
            })))
          }
          eachChild(t) {
            for (const n of this.sections) t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor), n.verticalAlign && t(n.verticalAlign)
          }
          outputDefined() {
            return !1
          }
        }
        class Gs {
          constructor(t) {
            this.type = Ut, this.input = t
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected two arguments.");
            const o = n.parse(t[1], 1, cr);
            return o ? new Gs(o) : n.error("No image name provided.")
          }
          evaluate(t) {
            const n = this.input.evaluate(t),
              o = Cn.fromString(n);
            return o && t.availableImages && (o.available = t.availableImages.indexOf(n) > -1), o
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class Zc {
          constructor(t) {
            this.type = nt, this.input = t
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const o = n.parse(t[1], 1);
            return o ? o.type.kind !== "array" && o.type.kind !== "string" && o.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${yr(o.type)} instead.`) : new Zc(o) : null
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            if (typeof n == "string") return [...n].length;
            if (Array.isArray(n)) return n.length;
            throw new sn(`Expected value to be of type string or array, but found ${yr(fn(n))} instead.`)
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        const ro = 8192;

        function Zp(i, t) {
          const n = (180 + i[0]) / 360,
            o = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360,
            u = Math.pow(2, t.z);
          return [Math.round(n * u * ro), Math.round(o * u * ro)]
        }

        function Gc(i, t) {
          const n = Math.pow(2, t.z);
          return [(u = (i[0] / ro + t.x) / n, 360 * u - 180), (o = (i[1] / ro + t.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * o) * Math.PI / 180)) - 90)];
          var o, u
        }

        function Ao(i, t) {
          i[0] = Math.min(i[0], t[0]), i[1] = Math.min(i[1], t[1]), i[2] = Math.max(i[2], t[0]), i[3] = Math.max(i[3], t[1])
        }

        function $s(i, t) {
          return !(i[0] <= t[0] || i[2] >= t[2] || i[1] <= t[1] || i[3] >= t[3])
        }

        function Uh(i, t, n) {
          const o = i[0] - t[0],
            u = i[1] - t[1],
            _ = i[0] - n[0],
            m = i[1] - n[1];
          return o * m - _ * u == 0 && o * _ <= 0 && u * m <= 0
        }

        function Ws(i, t, n, o) {
          return (u = [o[0] - n[0], o[1] - n[1]])[0] * (_ = [t[0] - i[0], t[1] - i[1]])[1] - u[1] * _[0] != 0 && !(!Gh(i, t, n, o) || !Gh(n, o, i, t));
          var u, _
        }

        function Gp(i, t, n) {
          for (const o of n)
            for (let u = 0; u < o.length - 1; ++u)
              if (Ws(i, t, o[u], o[u + 1])) return !0;
          return !1
        }

        function Zo(i, t, n = !1) {
          let o = !1;
          for (const y of t)
            for (let b = 0; b < y.length - 1; b++) {
              if (Uh(i, y[b], y[b + 1])) return n;
              (_ = y[b])[1] > (u = i)[1] != (m = y[b + 1])[1] > u[1] && u[0] < (m[0] - _[0]) * (u[1] - _[1]) / (m[1] - _[1]) + _[0] && (o = !o)
            }
          var u, _, m;
          return o
        }

        function $p(i, t) {
          for (const n of t)
            if (Zo(i, n)) return !0;
          return !1
        }

        function Zh(i, t) {
          for (const n of i)
            if (!Zo(n, t)) return !1;
          for (let n = 0; n < i.length - 1; ++n)
            if (Gp(i[n], i[n + 1], t)) return !1;
          return !0
        }

        function Wp(i, t) {
          for (const n of t)
            if (Zh(i, n)) return !0;
          return !1
        }

        function Gh(i, t, n, o) {
          const u = o[0] - n[0],
            _ = o[1] - n[1],
            m = (i[0] - n[0]) * _ - u * (i[1] - n[1]),
            y = (t[0] - n[0]) * _ - u * (t[1] - n[1]);
          return m > 0 && y < 0 || m < 0 && y > 0
        }

        function $c(i, t, n) {
          const o = [];
          for (let u = 0; u < i.length; u++) {
            const _ = [];
            for (let m = 0; m < i[u].length; m++) {
              const y = Zp(i[u][m], n);
              Ao(t, y), _.push(y)
            }
            o.push(_)
          }
          return o
        }

        function Wc(i, t, n) {
          const o = [];
          for (let u = 0; u < i.length; u++) {
            const _ = $c(i[u], t, n);
            o.push(_)
          }
          return o
        }

        function Hc(i, t, n, o) {
          if (i[0] < n[0] || i[0] > n[2]) {
            const u = .5 * o;
            let _ = i[0] - n[0] > u ? -o : n[0] - i[0] > u ? o : 0;
            _ === 0 && (_ = i[0] - n[2] > u ? -o : n[2] - i[0] > u ? o : 0), i[0] += _
          }
          Ao(t, i)
        }

        function Xc(i, t, n, o) {
          const u = Math.pow(2, o.z) * ro,
            _ = [o.x * ro, o.y * ro],
            m = [];
          for (const y of i)
            for (const b of y) {
              const M = [b.x + _[0], b.y + _[1]];
              Hc(M, t, n, u), m.push(M)
            }
          return m
        }

        function $h(i, t, n, o) {
          const u = Math.pow(2, o.z) * ro,
            _ = [o.x * ro, o.y * ro],
            m = [];
          for (const b of i) {
            const M = [];
            for (const I of b) {
              const D = [I.x + _[0], I.y + _[1]];
              Ao(t, D), M.push(D)
            }
            m.push(M)
          }
          if (t[2] - t[0] <= u / 2) {
            (y = t)[0] = y[1] = 1 / 0, y[2] = y[3] = -1 / 0;
            for (const b of m)
              for (const M of b) Hc(M, t, n, u)
          }
          var y;
          return m
        }
        class Go {
          constructor(t, n) {
            this.type = ar, this.geojson = t, this.geometries = n
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Nn(t[1])) {
              const o = t[1];
              if (o.type === "FeatureCollection") {
                const u = [];
                for (const _ of o.features) {
                  const {
                    type: m,
                    coordinates: y
                  } = _.geometry;
                  m === "Polygon" && u.push(y), m === "MultiPolygon" && u.push(...y)
                }
                if (u.length) return new Go(o, {
                  type: "MultiPolygon",
                  coordinates: u
                })
              } else if (o.type === "Feature") {
                const u = o.geometry.type;
                if (u === "Polygon" || u === "MultiPolygon") return new Go(o, o.geometry)
              } else if (o.type === "Polygon" || o.type === "MultiPolygon") return new Go(o, o)
            }
            return n.error("'within' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, o) {
                const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  m = n.canonicalID();
                if (o.type === "Polygon") {
                  const y = $c(o.coordinates, _, m),
                    b = Xc(n.geometry(), u, _, m);
                  if (!$s(u, _)) return !1;
                  for (const M of b)
                    if (!Zo(M, y)) return !1
                }
                if (o.type === "MultiPolygon") {
                  const y = Wc(o.coordinates, _, m),
                    b = Xc(n.geometry(), u, _, m);
                  if (!$s(u, _)) return !1;
                  for (const M of b)
                    if (!$p(M, y)) return !1
                }
                return !0
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, o) {
                const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  m = n.canonicalID();
                if (o.type === "Polygon") {
                  const y = $c(o.coordinates, _, m),
                    b = $h(n.geometry(), u, _, m);
                  if (!$s(u, _)) return !1;
                  for (const M of b)
                    if (!Zh(M, y)) return !1
                }
                if (o.type === "MultiPolygon") {
                  const y = Wc(o.coordinates, _, m),
                    b = $h(n.geometry(), u, _, m);
                  if (!$s(u, _)) return !1;
                  for (const M of b)
                    if (!Wp(M, y)) return !1
                }
                return !0
              })(t, this.geometries)
            }
            return !1
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        let Wh = class {
          constructor(i = [], t = (n, o) => n < o ? -1 : n > o ? 1 : 0) {
            if (this.data = i, this.length = this.data.length, this.compare = t, this.length > 0)
              for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n)
          }
          push(i) {
            this.data.push(i), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const i = this.data[0],
              t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), i
          }
          peek() {
            return this.data[0]
          }
          _up(i) {
            const {
              data: t,
              compare: n
            } = this, o = t[i];
            for (; i > 0;) {
              const u = i - 1 >> 1,
                _ = t[u];
              if (n(o, _) >= 0) break;
              t[i] = _, i = u
            }
            t[i] = o
          }
          _down(i) {
            const {
              data: t,
              compare: n
            } = this, o = this.length >> 1, u = t[i];
            for (; i < o;) {
              let _ = 1 + (i << 1);
              const m = _ + 1;
              if (m < this.length && n(t[m], t[_]) < 0 && (_ = m), n(t[_], u) >= 0) break;
              t[i] = t[_], i = _
            }
            t[i] = u
          }
        };

        function Hh(i, t, n = 0, o = i.length - 1, u = Hp) {
          for (; o > n;) {
            if (o - n > 600) {
              const b = o - n + 1,
                M = t - n + 1,
                I = Math.log(b),
                D = .5 * Math.exp(2 * I / 3),
                B = .5 * Math.sqrt(I * D * (b - D) / b) * (M - b / 2 < 0 ? -1 : 1);
              Hh(i, t, Math.max(n, Math.floor(t - M * D / b + B)), Math.min(o, Math.floor(t + (b - M) * D / b + B)), u)
            }
            const _ = i[t];
            let m = n,
              y = o;
            for (zo(i, n, t), u(i[o], _) > 0 && zo(i, n, o); m < y;) {
              for (zo(i, m, y), m++, y--; u(i[m], _) < 0;) m++;
              for (; u(i[y], _) > 0;) y--
            }
            u(i[n], _) === 0 ? zo(i, n, y) : (y++, zo(i, y, o)), y <= t && (n = y + 1), t <= y && (o = y - 1)
          }
        }

        function zo(i, t, n) {
          const o = i[t];
          i[t] = i[n], i[n] = o
        }

        function Hp(i, t) {
          return i < t ? -1 : i > t ? 1 : 0
        }

        function zl(i, t) {
          if (i.length <= 1) return [i];
          const n = [];
          let o, u;
          for (const _ of i) {
            const m = Yp(_);
            m !== 0 && (_.area = Math.abs(m), u === void 0 && (u = m < 0), u === m < 0 ? (o && n.push(o), o = [_]) : o.push(_))
          }
          if (o && n.push(o), t > 1)
            for (let _ = 0; _ < n.length; _++) n[_].length <= t || (Hh(n[_], t, 1, n[_].length - 1, Xp), n[_] = n[_].slice(0, t));
          return n
        }

        function Xp(i, t) {
          return t.area - i.area
        }

        function Yp(i) {
          let t = 0;
          for (let n, o, u = 0, _ = i.length, m = _ - 1; u < _; m = u++) n = i[u], o = i[m], t += (o.x - n.x) * (n.y + o.y);
          return t
        }
        const El = 1 / 298.257223563,
          Yc = El * (2 - El),
          Xh = Math.PI / 180;
        class Kc {
          constructor(t) {
            const n = 6378.137 * Xh * 1e3,
              o = Math.cos(t * Xh),
              u = 1 / (1 - Yc * (1 - o * o)),
              _ = Math.sqrt(u);
            this.kx = n * _ * o, this.ky = n * _ * u * (1 - Yc)
          }
          distance(t, n) {
            const o = this.wrap(t[0] - n[0]) * this.kx,
              u = (t[1] - n[1]) * this.ky;
            return Math.sqrt(o * o + u * u)
          }
          pointOnLine(t, n) {
            let o, u, _, m, y = 1 / 0;
            for (let b = 0; b < t.length - 1; b++) {
              let M = t[b][0],
                I = t[b][1],
                D = this.wrap(t[b + 1][0] - M) * this.kx,
                B = (t[b + 1][1] - I) * this.ky,
                V = 0;
              D === 0 && B === 0 || (V = (this.wrap(n[0] - M) * this.kx * D + (n[1] - I) * this.ky * B) / (D * D + B * B), V > 1 ? (M = t[b + 1][0], I = t[b + 1][1]) : V > 0 && (M += D / this.kx * V, I += B / this.ky * V)), D = this.wrap(n[0] - M) * this.kx, B = (n[1] - I) * this.ky;
              const H = D * D + B * B;
              H < y && (y = H, o = M, u = I, _ = b, m = V)
            }
            return {
              point: [o, u],
              index: _,
              t: Math.max(0, Math.min(1, m))
            }
          }
          wrap(t) {
            for (; t < -180;) t += 360;
            for (; t > 180;) t -= 360;
            return t
          }
        }

        function Jc(i, t) {
          return t[0] - i[0]
        }

        function Hs(i) {
          return i[1] - i[0] + 1
        }

        function po(i, t) {
          return i[1] >= i[0] && i[1] < t
        }

        function Qc(i, t) {
          if (i[0] > i[1]) return [null, null];
          const n = Hs(i);
          if (t) {
            if (n === 2) return [i, null];
            const u = Math.floor(n / 2);
            return [
              [i[0], i[0] + u],
              [i[0] + u, i[1]]
            ]
          }
          if (n === 1) return [i, null];
          const o = Math.floor(n / 2) - 1;
          return [
            [i[0], i[0] + o],
            [i[0] + o + 1, i[1]]
          ]
        }

        function eu(i, t) {
          if (!po(t, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let o = t[0]; o <= t[1]; ++o) Ao(n, i[o]);
          return n
        }

        function Ll(i) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const n of i)
            for (const o of n) Ao(t, o);
          return t
        }

        function Yh(i) {
          return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0
        }

        function tu(i, t, n) {
          if (!Yh(i) || !Yh(t)) return NaN;
          let o = 0,
            u = 0;
          return i[2] < t[0] && (o = t[0] - i[2]), i[0] > t[2] && (o = i[0] - t[2]), i[1] > t[3] && (u = i[1] - t[3]), i[3] < t[1] && (u = t[1] - i[3]), n.distance([0, 0], [o, u])
        }

        function $o(i, t, n) {
          const o = n.pointOnLine(t, i);
          return n.distance(i, o.point)
        }

        function ru(i, t, n, o, u) {
          const _ = Math.min($o(i, [n, o], u), $o(t, [n, o], u)),
            m = Math.min($o(n, [i, t], u), $o(o, [i, t], u));
          return Math.min(_, m)
        }

        function Wn(i, t, n, o, u) {
          if (!po(t, i.length) || !po(o, n.length)) return 1 / 0;
          let _ = 1 / 0;
          for (let m = t[0]; m < t[1]; ++m) {
            const y = i[m],
              b = i[m + 1];
            for (let M = o[0]; M < o[1]; ++M) {
              const I = n[M],
                D = n[M + 1];
              if (Ws(y, b, I, D)) return 0;
              _ = Math.min(_, ru(y, b, I, D, u))
            }
          }
          return _
        }

        function Kp(i, t, n, o, u) {
          if (!po(t, i.length) || !po(o, n.length)) return NaN;
          let _ = 1 / 0;
          for (let m = t[0]; m <= t[1]; ++m)
            for (let y = o[0]; y <= o[1]; ++y)
              if (_ = Math.min(_, u.distance(i[m], n[y])), _ === 0) return _;
          return _
        }

        function Jp(i, t, n) {
          if (Zo(i, t, !0)) return 0;
          let o = 1 / 0;
          for (const u of t) {
            const _ = u[0],
              m = u[u.length - 1];
            if (_ !== m && (o = Math.min(o, $o(i, [m, _], n)), o === 0)) return o;
            const y = n.pointOnLine(u, i);
            if (o = Math.min(o, n.distance(i, y.point)), o === 0) return o
          }
          return o
        }

        function Qp(i, t, n, o) {
          if (!po(t, i.length)) return NaN;
          for (let _ = t[0]; _ <= t[1]; ++_)
            if (Zo(i[_], n, !0)) return 0;
          let u = 1 / 0;
          for (let _ = t[0]; _ < t[1]; ++_) {
            const m = i[_],
              y = i[_ + 1];
            for (const b of n)
              for (let M = 0, I = b.length, D = I - 1; M < I; D = M++) {
                const B = b[D],
                  V = b[M];
                if (Ws(m, y, B, V)) return 0;
                u = Math.min(u, ru(m, y, B, V, o))
              }
          }
          return u
        }

        function Kh(i, t) {
          for (const n of i)
            for (const o of n)
              if (Zo(o, t, !0)) return !0;
          return !1
        }

        function ef(i, t, n, o = 1 / 0) {
          const u = Ll(i),
            _ = Ll(t);
          if (o !== 1 / 0 && tu(u, _, n) >= o) return o;
          if ($s(u, _)) {
            if (Kh(i, t)) return 0
          } else if (Kh(t, i)) return 0;
          let m = 1 / 0;
          for (const y of i)
            for (let b = 0, M = y.length, I = M - 1; b < M; I = b++) {
              const D = y[I],
                B = y[b];
              for (const V of t)
                for (let H = 0, K = V.length, re = K - 1; H < K; re = H++) {
                  const pe = V[re],
                    Ne = V[H];
                  if (Ws(D, B, pe, Ne)) return 0;
                  m = Math.min(m, ru(D, B, pe, Ne, n))
                }
            }
          return m
        }

        function Jh(i, t, n, o, u, _) {
          if (!_) return;
          const m = tu(eu(o, _), u, n);
          m < t && i.push([m, _, [0, 0]])
        }

        function Dl(i, t, n, o, u, _, m) {
          if (!_ || !m) return;
          const y = tu(eu(o, _), eu(u, m), n);
          y < t && i.push([y, _, m])
        }

        function Rl(i, t, n, o, u = 1 / 0) {
          let _ = Math.min(o.distance(i[0], n[0][0]), u);
          if (_ === 0) return _;
          const m = new Wh([
              [0, [0, i.length - 1],
                [0, 0]
              ]
            ], Jc),
            y = Ll(n);
          for (; m.length > 0;) {
            const b = m.pop();
            if (b[0] >= _) continue;
            const M = b[1],
              I = t ? 50 : 100;
            if (Hs(M) <= I) {
              if (!po(M, i.length)) return NaN;
              if (t) {
                const D = Qp(i, M, n, o);
                if (isNaN(D) || D === 0) return D;
                _ = Math.min(_, D)
              } else
                for (let D = M[0]; D <= M[1]; ++D) {
                  const B = Jp(i[D], n, o);
                  if (_ = Math.min(_, B), _ === 0) return 0
                }
            } else {
              const D = Qc(M, t);
              Jh(m, _, o, i, y, D[0]), Jh(m, _, o, i, y, D[1])
            }
          }
          return _
        }

        function jl(i, t, n, o, u, _ = 1 / 0) {
          let m = Math.min(_, u.distance(i[0], n[0]));
          if (m === 0) return m;
          const y = new Wh([
            [0, [0, i.length - 1],
              [0, n.length - 1]
            ]
          ], Jc);
          for (; y.length > 0;) {
            const b = y.pop();
            if (b[0] >= m) continue;
            const M = b[1],
              I = b[2],
              D = t ? 50 : 100,
              B = o ? 50 : 100;
            if (Hs(M) <= D && Hs(I) <= B) {
              if (!po(M, i.length) && po(I, n.length)) return NaN;
              let V;
              if (t && o) V = Wn(i, M, n, I, u), m = Math.min(m, V);
              else if (t && !o) {
                const H = i.slice(M[0], M[1] + 1);
                for (let K = I[0]; K <= I[1]; ++K)
                  if (V = $o(n[K], H, u), m = Math.min(m, V), m === 0) return m
              } else if (!t && o) {
                const H = n.slice(I[0], I[1] + 1);
                for (let K = M[0]; K <= M[1]; ++K)
                  if (V = $o(i[K], H, u), m = Math.min(m, V), m === 0) return m
              } else V = Kp(i, M, n, I, u), m = Math.min(m, V)
            } else {
              const V = Qc(M, t),
                H = Qc(I, o);
              Dl(y, m, u, i, n, V[0], H[0]), Dl(y, m, u, i, n, V[0], H[1]), Dl(y, m, u, i, n, V[1], H[0]), Dl(y, m, u, i, n, V[1], H[1])
            }
          }
          return m
        }

        function nu(i) {
          return i.type === "MultiPolygon" ? i.coordinates.map((t => ({
            type: "Polygon",
            coordinates: t
          }))) : i.type === "MultiLineString" ? i.coordinates.map((t => ({
            type: "LineString",
            coordinates: t
          }))) : i.type === "MultiPoint" ? i.coordinates.map((t => ({
            type: "Point",
            coordinates: t
          }))) : [i]
        }
        class Wo {
          constructor(t, n) {
            this.type = nt, this.geojson = t, this.geometries = n
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Nn(t[1])) {
              const o = t[1];
              if (o.type === "FeatureCollection") return new Wo(o, o.features.map((u => nu(u.geometry))).flat());
              if (o.type === "Feature") return new Wo(o, nu(o.geometry));
              if ("type" in o && "coordinates" in o) return new Wo(o, nu(o))
            }
            return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, o) {
                const u = n.geometry(),
                  _ = u.flat().map((b => Gc([b.x, b.y], n.canonical)));
                if (u.length === 0) return NaN;
                const m = new Kc(_[0][1]);
                let y = 1 / 0;
                for (const b of o) {
                  switch (b.type) {
                    case "Point":
                      y = Math.min(y, jl(_, !1, [b.coordinates], !1, m, y));
                      break;
                    case "LineString":
                      y = Math.min(y, jl(_, !1, b.coordinates, !0, m, y));
                      break;
                    case "Polygon":
                      y = Math.min(y, Rl(_, !1, b.coordinates, m, y))
                  }
                  if (y === 0) return y
                }
                return y
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, o) {
                const u = n.geometry(),
                  _ = u.flat().map((b => Gc([b.x, b.y], n.canonical)));
                if (u.length === 0) return NaN;
                const m = new Kc(_[0][1]);
                let y = 1 / 0;
                for (const b of o) {
                  switch (b.type) {
                    case "Point":
                      y = Math.min(y, jl(_, !0, [b.coordinates], !1, m, y));
                      break;
                    case "LineString":
                      y = Math.min(y, jl(_, !0, b.coordinates, !0, m, y));
                      break;
                    case "Polygon":
                      y = Math.min(y, Rl(_, !0, b.coordinates, m, y))
                  }
                  if (y === 0) return y
                }
                return y
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(n, o) {
                const u = n.geometry();
                if (u.length === 0 || u[0].length === 0) return NaN;
                const _ = zl(u, 0).map((b => b.map((M => M.map((I => Gc([I.x, I.y], n.canonical))))))),
                  m = new Kc(_[0][0][0][1]);
                let y = 1 / 0;
                for (const b of o)
                  for (const M of _) {
                    switch (b.type) {
                      case "Point":
                        y = Math.min(y, Rl([b.coordinates], !1, M, m, y));
                        break;
                      case "LineString":
                        y = Math.min(y, Rl(b.coordinates, !0, M, m, y));
                        break;
                      case "Polygon":
                        y = Math.min(y, ef(M, b.coordinates, m, y))
                    }
                    if (y === 0) return y
                  }
                return y
              })(t, this.geometries)
            }
            return NaN
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        class Xs {
          constructor(t) {
            this.type = Mr, this.key = t
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const o = t[1];
            return o == null ? n.error("Global state property must be defined.") : typeof o != "string" ? n.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Xs(o)
          }
          evaluate(t) {
            var n;
            const o = (n = t.globals) === null || n === void 0 ? void 0 : n.globalState;
            return o && Object.keys(o).length !== 0 ? Aa(o, this.key) : null
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        const ws = {
          "==": Uc,
          "!=": Up,
          ">": Il,
          "<": Vh,
          ">=": Va,
          "<=": Cl,
          array: an,
          at: La,
          boolean: an,
          case: to,
          coalesce: uo,
          collator: Zs,
          format: Al,
          image: Gs,
          in: Da,
          "index-of": ga,
          interpolate: On,
          "interpolate-hcl": On,
          "interpolate-lab": On,
          length: Zc,
          let: Bi,
          literal: Vn,
          match: va,
          number: an,
          "number-format": bs,
          object: an,
          slice: so,
          step: ui,
          string: an,
          "to-boolean": ln,
          "to-color": ln,
          "to-number": ln,
          "to-string": ln,
          var: Di,
          within: Go,
          distance: Wo,
          "global-state": Xs
        };
        class Ra {
          constructor(t, n, o, u) {
            this.name = t, this.type = n, this._evaluate = o, this.args = u
          }
          evaluate(t) {
            return this._evaluate(t, this.args)
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return !1
          }
          static parse(t, n) {
            const o = t[0],
              u = Ra.definitions[o];
            if (!u) return n.error(`Unknown expression "${o}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const _ = Array.isArray(u) ? u[0] : u.type,
              m = Array.isArray(u) ? [
                [u[1], u[2]]
              ] : u.overloads,
              y = m.filter((([M]) => !Array.isArray(M) || M.length === t.length - 1));
            let b = null;
            for (const [M, I] of y) {
              b = new An(n.registry, Fl, n.path, null, n.scope);
              const D = [];
              let B = !1;
              for (let V = 1; V < t.length; V++) {
                const H = t[V],
                  K = Array.isArray(M) ? M[V - 1] : M.type,
                  re = b.parse(H, 1 + D.length, K);
                if (!re) {
                  B = !0;
                  break
                }
                D.push(re)
              }
              if (!B)
                if (Array.isArray(M) && M.length !== D.length) b.error(`Expected ${M.length} arguments, but found ${D.length} instead.`);
                else {
                  for (let V = 0; V < D.length; V++) {
                    const H = Array.isArray(M) ? M[V] : M.type,
                      K = D[V];
                    b.concat(V + 1).checkSubtype(H, K.type)
                  }
                  if (b.errors.length === 0) return new Ra(o, _, I, D)
                }
            }
            if (y.length === 1) n.errors.push(...b.errors);
            else {
              const M = (y.length ? y : m).map((([D]) => {
                  return B = D, Array.isArray(B) ? `(${B.map(yr).join(", ")})` : `(${yr(B.type)}...)`;
                  var B
                })).join(" | "),
                I = [];
              for (let D = 1; D < t.length; D++) {
                const B = n.parse(t[D], 1 + I.length);
                if (!B) return null;
                I.push(yr(B.type))
              }
              n.error(`Expected arguments of type ${M}, but found (${I.join(", ")}) instead.`)
            }
            return null
          }
          static register(t, n) {
            Ra.definitions = n;
            for (const o in n) t[o] = Ra
          }
        }

        function Qh(i, [t, n, o, u]) {
          t = t.evaluate(i), n = n.evaluate(i), o = o.evaluate(i);
          const _ = u ? u.evaluate(i) : 1,
            m = bi(t, n, o, _);
          if (m) throw new sn(m);
          return new Nr(t / 255, n / 255, o / 255, _, !1)
        }

        function ed(i, t) {
          return i in t
        }

        function iu(i, t) {
          const n = t[i];
          return n === void 0 ? null : n
        }

        function Ho(i) {
          return {
            type: i
          }
        }

        function Fl(i) {
          if (i instanceof Di) return Fl(i.boundExpression);
          if (i instanceof Ra && i.name === "error" || i instanceof Zs || i instanceof Go || i instanceof Wo || i instanceof Xs) return !1;
          const t = i instanceof ln || i instanceof an;
          let n = !0;
          return i.eachChild((o => {
            n = t ? n && Fl(o) : n && o instanceof Vn
          })), !!n && Bl(i) && Ol(i, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
        }

        function Bl(i) {
          if (i instanceof Ra && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof Go || i instanceof Wo) return !1;
          let t = !0;
          return i.eachChild((n => {
            t && !Bl(n) && (t = !1)
          })), t
        }

        function Ys(i) {
          if (i instanceof Ra && i.name === "feature-state") return !1;
          let t = !0;
          return i.eachChild((n => {
            t && !Ys(n) && (t = !1)
          })), t
        }

        function Ol(i, t) {
          if (i instanceof Ra && t.indexOf(i.name) >= 0) return !1;
          let n = !0;
          return i.eachChild((o => {
            n && !Ol(o, t) && (n = !1)
          })), n
        }

        function td(i) {
          return {
            result: "success",
            value: i
          }
        }

        function ks(i) {
          return {
            result: "error",
            value: i
          }
        }

        function Ts(i) {
          return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven"
        }

        function rd(i) {
          return !!i.expression && i.expression.parameters.indexOf("zoom") > -1
        }

        function au(i) {
          return !!i.expression && i.expression.interpolated
        }

        function jn(i) {
          return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i
        }

        function ql(i) {
          return typeof i == "object" && i !== null && !Array.isArray(i) && fn(i) === Gr
        }

        function tf(i) {
          return i
        }

        function nd(i, t) {
          const n = i.stops && typeof i.stops[0][0] == "object",
            o = n || !(n || i.property !== void 0),
            u = i.type || (au(t) ? "exponential" : "interval"),
            _ = (function(I) {
              switch (I.type) {
                case "color":
                  return Nr.parse;
                case "padding":
                  return zr.parse;
                case "numberArray":
                  return mr.parse;
                case "colorArray":
                  return nn.parse;
                default:
                  return null
              }
            })(t);
          if (_ && ((i = Ct({}, i)).stops && (i.stops = i.stops.map((I => [I[0], _(I[1])]))), i.default = _(i.default ? i.default : t.default)), i.colorSpace && (m = i.colorSpace) !== "rgb" && m !== "hcl" && m !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
          var m;
          const y = (function(I) {
            switch (I) {
              case "exponential":
                return id;
              case "interval":
                return nf;
              case "categorical":
                return rf;
              case "identity":
                return ad;
              default:
                throw new Error(`Unknown function type "${I}"`)
            }
          })(u);
          let b, M;
          if (u === "categorical") {
            b = Object.create(null);
            for (const I of i.stops) b[I[0]] = I[1];
            M = typeof i.stops[0][0]
          }
          if (n) {
            const I = {},
              D = [];
            for (let H = 0; H < i.stops.length; H++) {
              const K = i.stops[H],
                re = K[0].zoom;
              I[re] === void 0 && (I[re] = {
                zoom: re,
                type: i.type,
                property: i.property,
                default: i.default,
                stops: []
              }, D.push(re)), I[re].stops.push([K[0].value, K[1]])
            }
            const B = [];
            for (const H of D) B.push([I[H].zoom, nd(I[H], t)]);
            const V = {
              name: "linear"
            };
            return {
              kind: "composite",
              interpolationType: V,
              interpolationFactor: On.interpolationFactor.bind(void 0, V),
              zoomStops: B.map((H => H[0])),
              evaluate: ({
                zoom: H
              }, K) => id({
                stops: B,
                base: i.base
              }, t, H).evaluate(H, K)
            }
          }
          if (o) {
            const I = u === "exponential" ? {
              name: "exponential",
              base: i.base !== void 0 ? i.base : 1
            } : null;
            return {
              kind: "camera",
              interpolationType: I,
              interpolationFactor: On.interpolationFactor.bind(void 0, I),
              zoomStops: i.stops.map((D => D[0])),
              evaluate: ({
                zoom: D
              }) => y(i, t, D, b, M)
            }
          }
          return {
            kind: "source",
            evaluate(I, D) {
              const B = D && D.properties ? D.properties[i.property] : void 0;
              return B === void 0 ? Xo(i.default, t.default) : y(i, t, B, b, M)
            }
          }
        }

        function Xo(i, t, n) {
          return i !== void 0 ? i : t !== void 0 ? t : n !== void 0 ? n : void 0
        }

        function rf(i, t, n, o, u) {
          return Xo(typeof n === u ? o[n] : void 0, i.default, t.default)
        }

        function nf(i, t, n) {
          if (jn(n) !== "number") return Xo(i.default, t.default);
          const o = i.stops.length;
          if (o === 1 || n <= i.stops[0][0]) return i.stops[0][1];
          if (n >= i.stops[o - 1][0]) return i.stops[o - 1][1];
          const u = ii(i.stops.map((_ => _[0])), n);
          return i.stops[u][1]
        }

        function id(i, t, n) {
          const o = i.base !== void 0 ? i.base : 1;
          if (jn(n) !== "number") return Xo(i.default, t.default);
          const u = i.stops.length;
          if (u === 1 || n <= i.stops[0][0]) return i.stops[0][1];
          if (n >= i.stops[u - 1][0]) return i.stops[u - 1][1];
          const _ = ii(i.stops.map((I => I[0])), n),
            m = (function(I, D, B, V) {
              const H = V - B,
                K = I - B;
              return H === 0 ? 0 : D === 1 ? K / H : (Math.pow(D, K) - 1) / (Math.pow(D, H) - 1)
            })(n, o, i.stops[_][0], i.stops[_ + 1][0]),
            y = i.stops[_][1],
            b = i.stops[_ + 1][1],
            M = Yi[t.type] || tf;
          return typeof y.evaluate == "function" ? {
            evaluate(...I) {
              const D = y.evaluate.apply(void 0, I),
                B = b.evaluate.apply(void 0, I);
              if (D !== void 0 && B !== void 0) return M(D, B, m, i.colorSpace)
            }
          } : M(y, b, m, i.colorSpace)
        }

        function ad(i, t, n) {
          switch (t.type) {
            case "color":
              n = Nr.parse(n);
              break;
            case "formatted":
              n = Xn.fromString(n.toString());
              break;
            case "resolvedImage":
              n = Cn.fromString(n.toString());
              break;
            case "padding":
              n = zr.parse(n);
              break;
            case "colorArray":
              n = nn.parse(n);
              break;
            case "numberArray":
              n = mr.parse(n);
              break;
            default:
              jn(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0)
          }
          return Xo(n, i.default, t.default)
        }
        Ra.register(ws, {
          error: [{
              kind: "error"
            },
            [cr], (i, [t]) => {
              throw new sn(t.evaluate(i))
            }
          ],
          typeof: [cr, [Mr], (i, [t]) => yr(fn(t.evaluate(i)))],
          "to-rgba": [Wt(nt, 4), [Ar], (i, [t]) => {
            const [n, o, u, _] = t.evaluate(i).rgb;
            return [255 * n, 255 * o, 255 * u, _]
          }],
          rgb: [Ar, [nt, nt, nt], Qh],
          rgba: [Ar, [nt, nt, nt, nt], Qh],
          has: {
            type: ar,
            overloads: [
              [
                [cr], (i, [t]) => ed(t.evaluate(i), i.properties())
              ],
              [
                [cr, Gr], (i, [t, n]) => ed(t.evaluate(i), n.evaluate(i))
              ]
            ]
          },
          get: {
            type: Mr,
            overloads: [
              [
                [cr], (i, [t]) => iu(t.evaluate(i), i.properties())
              ],
              [
                [cr, Gr], (i, [t, n]) => iu(t.evaluate(i), n.evaluate(i))
              ]
            ]
          },
          "feature-state": [Mr, [cr], (i, [t]) => iu(t.evaluate(i), i.featureState || {})],
          properties: [Gr, [], i => i.properties()],
          "geometry-type": [cr, [], i => i.geometryType()],
          id: [Mr, [], i => i.id()],
          zoom: [nt, [], i => i.globals.zoom],
          "heatmap-density": [nt, [], i => i.globals.heatmapDensity || 0],
          elevation: [nt, [], i => i.globals.elevation || 0],
          "line-progress": [nt, [], i => i.globals.lineProgress || 0],
          accumulated: [Mr, [], i => i.globals.accumulated === void 0 ? null : i.globals.accumulated],
          "+": [nt, Ho(nt), (i, t) => {
            let n = 0;
            for (const o of t) n += o.evaluate(i);
            return n
          }],
          "*": [nt, Ho(nt), (i, t) => {
            let n = 1;
            for (const o of t) n *= o.evaluate(i);
            return n
          }],
          "-": {
            type: nt,
            overloads: [
              [
                [nt, nt], (i, [t, n]) => t.evaluate(i) - n.evaluate(i)
              ],
              [
                [nt], (i, [t]) => -t.evaluate(i)
              ]
            ]
          },
          "/": [nt, [nt, nt], (i, [t, n]) => t.evaluate(i) / n.evaluate(i)],
          "%": [nt, [nt, nt], (i, [t, n]) => t.evaluate(i) % n.evaluate(i)],
          ln2: [nt, [], () => Math.LN2],
          pi: [nt, [], () => Math.PI],
          e: [nt, [], () => Math.E],
          "^": [nt, [nt, nt], (i, [t, n]) => Math.pow(t.evaluate(i), n.evaluate(i))],
          sqrt: [nt, [nt], (i, [t]) => Math.sqrt(t.evaluate(i))],
          log10: [nt, [nt], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN10],
          ln: [nt, [nt], (i, [t]) => Math.log(t.evaluate(i))],
          log2: [nt, [nt], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN2],
          sin: [nt, [nt], (i, [t]) => Math.sin(t.evaluate(i))],
          cos: [nt, [nt], (i, [t]) => Math.cos(t.evaluate(i))],
          tan: [nt, [nt], (i, [t]) => Math.tan(t.evaluate(i))],
          asin: [nt, [nt], (i, [t]) => Math.asin(t.evaluate(i))],
          acos: [nt, [nt], (i, [t]) => Math.acos(t.evaluate(i))],
          atan: [nt, [nt], (i, [t]) => Math.atan(t.evaluate(i))],
          min: [nt, Ho(nt), (i, t) => Math.min(...t.map((n => n.evaluate(i))))],
          max: [nt, Ho(nt), (i, t) => Math.max(...t.map((n => n.evaluate(i))))],
          abs: [nt, [nt], (i, [t]) => Math.abs(t.evaluate(i))],
          round: [nt, [nt], (i, [t]) => {
            const n = t.evaluate(i);
            return n < 0 ? -Math.round(-n) : Math.round(n)
          }],
          floor: [nt, [nt], (i, [t]) => Math.floor(t.evaluate(i))],
          ceil: [nt, [nt], (i, [t]) => Math.ceil(t.evaluate(i))],
          "filter-==": [ar, [cr, Mr], (i, [t, n]) => i.properties()[t.value] === n.value],
          "filter-id-==": [ar, [Mr], (i, [t]) => i.id() === t.value],
          "filter-type-==": [ar, [cr], (i, [t]) => i.geometryType() === t.value],
          "filter-<": [ar, [cr, Mr], (i, [t, n]) => {
            const o = i.properties()[t.value],
              u = n.value;
            return typeof o == typeof u && o < u
          }],
          "filter-id-<": [ar, [Mr], (i, [t]) => {
            const n = i.id(),
              o = t.value;
            return typeof n == typeof o && n < o
          }],
          "filter->": [ar, [cr, Mr], (i, [t, n]) => {
            const o = i.properties()[t.value],
              u = n.value;
            return typeof o == typeof u && o > u
          }],
          "filter-id->": [ar, [Mr], (i, [t]) => {
            const n = i.id(),
              o = t.value;
            return typeof n == typeof o && n > o
          }],
          "filter-<=": [ar, [cr, Mr], (i, [t, n]) => {
            const o = i.properties()[t.value],
              u = n.value;
            return typeof o == typeof u && o <= u
          }],
          "filter-id-<=": [ar, [Mr], (i, [t]) => {
            const n = i.id(),
              o = t.value;
            return typeof n == typeof o && n <= o
          }],
          "filter->=": [ar, [cr, Mr], (i, [t, n]) => {
            const o = i.properties()[t.value],
              u = n.value;
            return typeof o == typeof u && o >= u
          }],
          "filter-id->=": [ar, [Mr], (i, [t]) => {
            const n = i.id(),
              o = t.value;
            return typeof n == typeof o && n >= o
          }],
          "filter-has": [ar, [Mr], (i, [t]) => t.value in i.properties()],
          "filter-has-id": [ar, [], i => i.id() !== null && i.id() !== void 0],
          "filter-type-in": [ar, [Wt(cr)], (i, [t]) => t.value.indexOf(i.geometryType()) >= 0],
          "filter-id-in": [ar, [Wt(Mr)], (i, [t]) => t.value.indexOf(i.id()) >= 0],
          "filter-in-small": [ar, [cr, Wt(Mr)], (i, [t, n]) => n.value.indexOf(i.properties()[t.value]) >= 0],
          "filter-in-large": [ar, [cr, Wt(Mr)], (i, [t, n]) => (function(o, u, _, m) {
            for (; _ <= m;) {
              const y = _ + m >> 1;
              if (u[y] === o) return !0;
              u[y] > o ? m = y - 1 : _ = y + 1
            }
            return !1
          })(i.properties()[t.value], n.value, 0, n.value.length - 1)],
          all: {
            type: ar,
            overloads: [
              [
                [ar, ar], (i, [t, n]) => t.evaluate(i) && n.evaluate(i)
              ],
              [Ho(ar), (i, t) => {
                for (const n of t)
                  if (!n.evaluate(i)) return !1;
                return !0
              }]
            ]
          },
          any: {
            type: ar,
            overloads: [
              [
                [ar, ar], (i, [t, n]) => t.evaluate(i) || n.evaluate(i)
              ],
              [Ho(ar), (i, t) => {
                for (const n of t)
                  if (n.evaluate(i)) return !0;
                return !1
              }]
            ]
          },
          "!": [ar, [ar], (i, [t]) => !t.evaluate(i)],
          "is-supported-script": [ar, [cr], (i, [t]) => {
            const n = i.globals && i.globals.isSupportedScript;
            return !n || n(t.evaluate(i))
          }],
          upcase: [cr, [cr], (i, [t]) => t.evaluate(i).toUpperCase()],
          downcase: [cr, [cr], (i, [t]) => t.evaluate(i).toLowerCase()],
          concat: [cr, Ho(Mr), (i, t) => t.map((n => _n(n.evaluate(i)))).join("")],
          "resolved-locale": [cr, [Sn], (i, [t]) => t.evaluate(i).resolvedLocale()]
        });
        class ou {
          constructor(t, n, o) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new Na, this._defaultValue = n ? (function(u) {
              if (u.type === "color" && ql(u.default)) return new Nr(0, 0, 0, 0);
              switch (u.type) {
                case "color":
                  return Nr.parse(u.default) || null;
                case "padding":
                  return zr.parse(u.default) || null;
                case "numberArray":
                  return mr.parse(u.default) || null;
                case "colorArray":
                  return nn.parse(u.default) || null;
                case "variableAnchorOffsetCollection":
                  return kn.parse(u.default) || null;
                case "projectionDefinition":
                  return $n.parse(u.default) || null;
                default:
                  return u.default === void 0 ? null : u.default
              }
            })(n) : null, this._enumValues = n && n.type === "enum" ? n.values : null, this._globalState = o
          }
          evaluateWithoutErrorHandling(t, n, o, u, _, m) {
            return this._globalState && (t = Ko(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = o, this._evaluator.canonical = u, this._evaluator.availableImages = _ || null, this._evaluator.formattedSection = m, this.expression.evaluate(this._evaluator)
          }
          evaluate(t, n, o, u, _, m) {
            this._globalState && (t = Ko(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = o || null, this._evaluator.canonical = u, this._evaluator.availableImages = _ || null, this._evaluator.formattedSection = m || null;
            try {
              const y = this.expression.evaluate(this._evaluator);
              if (y == null || typeof y == "number" && y != y) return this._defaultValue;
              if (this._enumValues && !(y in this._enumValues)) throw new sn(`Expected value to be one of ${Object.keys(this._enumValues).map((b=>JSON.stringify(b))).join(", ")}, but found ${JSON.stringify(y)} instead.`);
              return y
            } catch (y) {
              return this._warningHistory[y.message] || (this._warningHistory[y.message] = !0, typeof console < "u" && console.warn(y.message)), this._defaultValue
            }
          }
        }

        function Nl(i) {
          return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in ws
        }

        function Yo(i, t, n) {
          const o = new An(ws, Fl, [], t ? (function(_) {
              const m = {
                color: Ar,
                string: cr,
                number: nt,
                enum: cr,
                boolean: ar,
                formatted: Vr,
                padding: Le,
                numberArray: qt,
                colorArray: tt,
                projectionDefinition: qr,
                resolvedImage: Ut,
                variableAnchorOffsetCollection: fr
              };
              return _.type === "array" ? Wt(m[_.value] || Mr, _.length) : m[_.type]
            })(t) : void 0),
            u = o.parse(i, void 0, void 0, void 0, t && t.type === "string" ? {
              typeAnnotation: "coerce"
            } : void 0);
          return u ? td(new ou(u, t, n)) : ks(o.errors)
        }
        class Ks {
          constructor(t, n, o) {
            this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !Ys(n.expression), this.globalStateRefs = Zl(n.expression), this._globalState = o
          }
          evaluateWithoutErrorHandling(t, n, o, u, _, m) {
            return this._globalState && (t = Ko(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, n, o, u, _, m)
          }
          evaluate(t, n, o, u, _, m) {
            return this._globalState && (t = Ko(t, this._globalState)), this._styleExpression.evaluate(t, n, o, u, _, m)
          }
        }
        class su {
          constructor(t, n, o, u, _) {
            this.kind = t, this.zoomStops = o, this._styleExpression = n, this.isStateDependent = t !== "camera" && !Ys(n.expression), this.globalStateRefs = Zl(n.expression), this.interpolationType = u, this._globalState = _
          }
          evaluateWithoutErrorHandling(t, n, o, u, _, m) {
            return this._globalState && (t = Ko(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, n, o, u, _, m)
          }
          evaluate(t, n, o, u, _, m) {
            return this._globalState && (t = Ko(t, this._globalState)), this._styleExpression.evaluate(t, n, o, u, _, m)
          }
          interpolationFactor(t, n, o) {
            return this.interpolationType ? On.interpolationFactor(this.interpolationType, t, n, o) : 0
          }
        }

        function od(i, t, n) {
          const o = Yo(i, t, n);
          if (o.result === "error") return o;
          const u = o.value.expression,
            _ = Bl(u);
          if (!_ && !Ts(t)) return ks([new ir("", "data expressions not supported")]);
          const m = Ol(u, ["zoom"]);
          if (!m && !rd(t)) return ks([new ir("", "zoom expressions not supported")]);
          const y = Ul(u);
          return y || m ? y instanceof ir ? ks([y]) : y instanceof On && !au(t) ? ks([new ir("", '"interpolate" expressions cannot be used with this property')]) : td(y ? new su(_ ? "camera" : "composite", o.value, y.labels, y instanceof On ? y.interpolation : void 0, n) : new Ks(_ ? "constant" : "source", o.value, n)) : ks([new ir("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
        }
        class Vl {
          constructor(t, n) {
            this._parameters = t, this._specification = n, Ct(this, nd(this._parameters, this._specification))
          }
          static deserialize(t) {
            return new Vl(t._parameters, t._specification)
          }
          static serialize(t) {
            return {
              _parameters: t._parameters,
              _specification: t._specification
            }
          }
        }

        function Ul(i) {
          let t = null;
          if (i instanceof Bi) t = Ul(i.result);
          else if (i instanceof uo) {
            for (const n of i.args)
              if (t = Ul(n), t) break
          } else(i instanceof ui || i instanceof On) && i.input instanceof Ra && i.input.name === "zoom" && (t = i);
          return t instanceof ir || i.eachChild((n => {
            const o = Ul(n);
            o instanceof ir ? t = o : !t && o ? t = new ir("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && o && t !== o && (t = new ir("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
          })), t
        }

        function Zl(i, t = new Set) {
          return i instanceof Xs && t.add(i.key), i.eachChild((n => {
            Zl(n, t)
          })), t
        }

        function Ko(i, t) {
          const {
            zoom: n,
            heatmapDensity: o,
            elevation: u,
            lineProgress: _,
            isSupportedScript: m,
            accumulated: y
          } = i ?? {};
          return {
            zoom: n,
            heatmapDensity: o,
            elevation: u,
            lineProgress: _,
            isSupportedScript: m,
            accumulated: y,
            globalState: t
          }
        }

        function Gl(i) {
          if (i === !0 || i === !1) return !0;
          if (!Array.isArray(i) || i.length === 0) return !1;
          switch (i[0]) {
            case "has":
              return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
            case "in":
              return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
            case "any":
            case "all":
              for (const t of i.slice(1))
                if (!Gl(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0
          }
        }
        const af = {
          type: "boolean",
          default: !1,
          transition: !1,
          "property-type": "data-driven",
          expression: {
            interpolated: !1,
            parameters: ["zoom", "feature"]
          }
        };

        function Js(i, t) {
          if (i == null) return {
            filter: () => !0,
            needGeometry: !1,
            getGlobalStateRefs: () => new Set
          };
          Gl(i) || (i = Qs(i));
          const n = Yo(i, af, t);
          if (n.result === "error") throw new Error(n.value.map((o => `${o.key}: ${o.message}`)).join(", "));
          return {
            filter: (o, u, _) => n.value.evaluate(o, u, {}, _),
            needGeometry: lu(i),
            getGlobalStateRefs: () => Zl(n.value.expression)
          }
        }

        function sd(i, t) {
          return i < t ? -1 : i > t ? 1 : 0
        }

        function lu(i) {
          if (!Array.isArray(i)) return !1;
          if (i[0] === "within" || i[0] === "distance") return !0;
          for (let t = 1; t < i.length; t++)
            if (lu(i[t])) return !0;
          return !1
        }

        function Qs(i) {
          if (!i) return !0;
          const t = i[0];
          return i.length <= 1 ? t !== "any" : t === "==" ? cu(i[1], i[2], "==") : t === "!=" ? $l(cu(i[1], i[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? cu(i[1], i[2], t) : t === "any" ? (n = i.slice(1), ["any"].concat(n.map(Qs))) : t === "all" ? ["all"].concat(i.slice(1).map(Qs)) : t === "none" ? ["all"].concat(i.slice(1).map(Qs).map($l)) : t === "in" ? ld(i[1], i.slice(2)) : t === "!in" ? $l(ld(i[1], i.slice(2))) : t === "has" ? cd(i[1]) : t !== "!has" || $l(cd(i[1]));
          var n
        }

        function cu(i, t, n) {
          switch (i) {
            case "$type":
              return [`filter-type-${n}`, t];
            case "$id":
              return [`filter-id-${n}`, t];
            default:
              return [`filter-${n}`, i, t]
          }
        }

        function ld(i, t) {
          if (t.length === 0) return !1;
          switch (i) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some((n => typeof n != typeof t[0])) ? ["filter-in-large", i, ["literal", t.sort(sd)]] : ["filter-in-small", i, ["literal", t]]
          }
        }

        function cd(i) {
          switch (i) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", i]
          }
        }

        function $l(i) {
          return ["!", i]
        }

        function Wl(i) {
          const t = typeof i;
          if (t === "number" || t === "boolean" || t === "string" || i == null) return JSON.stringify(i);
          if (Array.isArray(i)) {
            let u = "[";
            for (const _ of i) u += `${Wl(_)},`;
            return `${u}]`
          }
          const n = Object.keys(i).sort();
          let o = "{";
          for (let u = 0; u < n.length; u++) o += `${JSON.stringify(n[u])}:${Wl(i[n[u]])},`;
          return `${o}}`
        }

        function ud(i) {
          let t = "";
          for (const n of Ze) t += `/${Wl(i[n])}`;
          return t
        }

        function Hl(i) {
          const t = i.value;
          return t ? [new $e(i.key, t, "constants have been deprecated as of v8")] : []
        }

        function pi(i) {
          return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i
        }

        function fo(i) {
          if (Array.isArray(i)) return i.map(fo);
          if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
            const t = {};
            for (const n in i) t[n] = fo(i[n]);
            return t
          }
          return pi(i)
        }

        function ya(i) {
          const t = i.key,
            n = i.value,
            o = i.valueSpec || {},
            u = i.objectElementValidators || {},
            _ = i.style,
            m = i.styleSpec,
            y = i.validateSpec;
          let b = [];
          const M = jn(n);
          if (M !== "object") return [new $e(t, n, `object expected, ${M} found`)];
          for (const I in n) {
            const D = I.split(".")[0],
              B = Aa(o, D) || o["*"];
            let V;
            if (Aa(u, D)) V = u[D];
            else if (Aa(o, D)) V = y;
            else if (u["*"]) V = u["*"];
            else {
              if (!o["*"]) {
                b.push(new $e(t, n[I], `unknown property "${I}"`));
                continue
              }
              V = y
            }
            b = b.concat(V({
              key: (t && `${t}.`) + I,
              value: n[I],
              valueSpec: B,
              style: _,
              styleSpec: m,
              object: n,
              objectKey: I,
              validateSpec: y
            }, n))
          }
          for (const I in o) u[I] || o[I].required && o[I].default === void 0 && n[I] === void 0 && b.push(new $e(t, n, `missing required property "${I}"`));
          return b
        }

        function Ps(i) {
          const t = i.value,
            n = i.valueSpec,
            o = i.style,
            u = i.styleSpec,
            _ = i.key,
            m = i.arrayElementValidator || i.validateSpec;
          if (jn(t) !== "array") return [new $e(_, t, `array expected, ${jn(t)} found`)];
          if (n.length && t.length !== n.length) return [new $e(_, t, `array length ${n.length} expected, length ${t.length} found`)];
          if (n["min-length"] && t.length < n["min-length"]) return [new $e(_, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
          let y = {
            type: n.value,
            values: n.values
          };
          u.$version < 7 && (y.function = n.function), jn(n.value) === "object" && (y = n.value);
          let b = [];
          for (let M = 0; M < t.length; M++) b = b.concat(m({
            array: t,
            arrayIndex: M,
            value: t[M],
            valueSpec: y,
            validateSpec: i.validateSpec,
            style: o,
            styleSpec: u,
            key: `${_}[${M}]`
          }));
          return b
        }

        function Xl(i) {
          const t = i.key,
            n = i.value,
            o = i.valueSpec;
          let u = jn(n);
          return u === "number" && n != n && (u = "NaN"), u !== "number" ? [new $e(t, n, `number expected, ${u} found`)] : "minimum" in o && n < o.minimum ? [new $e(t, n, `${n} is less than the minimum value ${o.minimum}`)] : "maximum" in o && n > o.maximum ? [new $e(t, n, `${n} is greater than the maximum value ${o.maximum}`)] : []
        }

        function hd(i) {
          const t = i.valueSpec,
            n = pi(i.value.type);
          let o, u, _, m = {};
          const y = n !== "categorical" && i.value.property === void 0,
            b = !y,
            M = jn(i.value.stops) === "array" && jn(i.value.stops[0]) === "array" && jn(i.value.stops[0][0]) === "object",
            I = ya({
              key: i.key,
              value: i.value,
              valueSpec: i.styleSpec.function,
              validateSpec: i.validateSpec,
              style: i.style,
              styleSpec: i.styleSpec,
              objectElementValidators: {
                stops: function(V) {
                  if (n === "identity") return [new $e(V.key, V.value, 'identity function may not have a "stops" property')];
                  let H = [];
                  const K = V.value;
                  return H = H.concat(Ps({
                    key: V.key,
                    value: K,
                    valueSpec: V.valueSpec,
                    validateSpec: V.validateSpec,
                    style: V.style,
                    styleSpec: V.styleSpec,
                    arrayElementValidator: D
                  })), jn(K) === "array" && K.length === 0 && H.push(new $e(V.key, K, "array must have at least one stop")), H
                },
                default: function(V) {
                  return V.validateSpec({
                    key: V.key,
                    value: V.value,
                    valueSpec: t,
                    validateSpec: V.validateSpec,
                    style: V.style,
                    styleSpec: V.styleSpec
                  })
                }
              }
            });
          return n === "identity" && y && I.push(new $e(i.key, i.value, 'missing required property "property"')), n === "identity" || i.value.stops || I.push(new $e(i.key, i.value, 'missing required property "stops"')), n === "exponential" && i.valueSpec.expression && !au(i.valueSpec) && I.push(new $e(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (b && !Ts(i.valueSpec) ? I.push(new $e(i.key, i.value, "property functions not supported")) : y && !rd(i.valueSpec) && I.push(new $e(i.key, i.value, "zoom functions not supported"))), n !== "categorical" && !M || i.value.property !== void 0 || I.push(new $e(i.key, i.value, '"property" property is required')), I;

          function D(V) {
            let H = [];
            const K = V.value,
              re = V.key;
            if (jn(K) !== "array") return [new $e(re, K, `array expected, ${jn(K)} found`)];
            if (K.length !== 2) return [new $e(re, K, `array length 2 expected, length ${K.length} found`)];
            if (M) {
              if (jn(K[0]) !== "object") return [new $e(re, K, `object expected, ${jn(K[0])} found`)];
              if (K[0].zoom === void 0) return [new $e(re, K, "object stop key must have zoom")];
              if (K[0].value === void 0) return [new $e(re, K, "object stop key must have value")];
              if (_ && _ > pi(K[0].zoom)) return [new $e(re, K[0].zoom, "stop zoom values must appear in ascending order")];
              pi(K[0].zoom) !== _ && (_ = pi(K[0].zoom), u = void 0, m = {}), H = H.concat(ya({
                key: `${re}[0]`,
                value: K[0],
                valueSpec: {
                  zoom: {}
                },
                validateSpec: V.validateSpec,
                style: V.style,
                styleSpec: V.styleSpec,
                objectElementValidators: {
                  zoom: Xl,
                  value: B
                }
              }))
            } else H = H.concat(B({
              key: `${re}[0]`,
              value: K[0],
              validateSpec: V.validateSpec,
              style: V.style,
              styleSpec: V.styleSpec
            }, K));
            return Nl(fo(K[1])) ? H.concat([new $e(`${re}[1]`, K[1], "expressions are not allowed in function stops.")]) : H.concat(V.validateSpec({
              key: `${re}[1]`,
              value: K[1],
              valueSpec: t,
              validateSpec: V.validateSpec,
              style: V.style,
              styleSpec: V.styleSpec
            }))
          }

          function B(V, H) {
            const K = jn(V.value),
              re = pi(V.value),
              pe = V.value !== null ? V.value : H;
            if (o) {
              if (K !== o) return [new $e(V.key, pe, `${K} stop domain type must match previous stop domain type ${o}`)]
            } else o = K;
            if (K !== "number" && K !== "string" && K !== "boolean") return [new $e(V.key, pe, "stop domain value must be a number, string, or boolean")];
            if (K !== "number" && n !== "categorical") {
              let Ne = `number expected, ${K} found`;
              return Ts(t) && n === void 0 && (Ne += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new $e(V.key, pe, Ne)]
            }
            return n !== "categorical" || K !== "number" || isFinite(re) && Math.floor(re) === re ? n !== "categorical" && K === "number" && u !== void 0 && re < u ? [new $e(V.key, pe, "stop domain values must appear in ascending order")] : (u = re, n === "categorical" && re in m ? [new $e(V.key, pe, "stop domain values must be unique")] : (m[re] = !0, [])) : [new $e(V.key, pe, `integer expected, found ${re}`)]
          }
        }

        function Ss(i) {
          const t = (i.expressionContext === "property" ? od : Yo)(fo(i.value), i.valueSpec);
          if (t.result === "error") return t.value.map((o => new $e(`${i.key}${o.key}`, i.value, o.message)));
          const n = t.value.expression || t.value._styleExpression.expression;
          if (i.expressionContext === "property" && i.propertyKey === "text-font" && !n.outputDefined()) return [new $e(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (i.expressionContext === "property" && i.propertyType === "layout" && !Ys(n)) return [new $e(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (i.expressionContext === "filter" && !Ys(n)) return [new $e(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
          if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
            if (!Ol(n, ["zoom", "feature-state"])) return [new $e(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (i.expressionContext === "cluster-initial" && !Bl(n)) return [new $e(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
          }
          return []
        }

        function uu(i) {
          const t = i.key,
            n = i.value,
            o = jn(n);
          return o !== "string" ? [new $e(t, n, `color expected, ${o} found`)] : Nr.parse(String(n)) ? [] : [new $e(t, n, `color expected, "${n}" found`)]
        }

        function el(i) {
          const t = i.key,
            n = i.value,
            o = i.valueSpec,
            u = [];
          return Array.isArray(o.values) ? o.values.indexOf(pi(n)) === -1 && u.push(new $e(t, n, `expected one of [${o.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(o.values).indexOf(pi(n)) === -1 && u.push(new $e(t, n, `expected one of [${Object.keys(o.values).join(", ")}], ${JSON.stringify(n)} found`)), u
        }

        function hu(i) {
          return Gl(fo(i.value)) ? Ss(Ct({}, i, {
            expressionContext: "filter",
            valueSpec: {
              value: "boolean"
            }
          })) : du(i)
        }

        function du(i) {
          const t = i.value,
            n = i.key;
          if (jn(t) !== "array") return [new $e(n, t, `array expected, ${jn(t)} found`)];
          const o = i.styleSpec;
          let u, _ = [];
          if (t.length < 1) return [new $e(n, t, "filter array must have at least 1 element")];
          switch (_ = _.concat(el({
              key: `${n}[0]`,
              value: t[0],
              valueSpec: o.filter_operator,
              style: i.style,
              styleSpec: i.styleSpec
            })), pi(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && pi(t[1]) === "$type" && _.push(new $e(n, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && _.push(new $e(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (u = jn(t[1]), u !== "string" && _.push(new $e(`${n}[1]`, t[1], `string expected, ${u} found`)));
              for (let m = 2; m < t.length; m++) u = jn(t[m]), pi(t[1]) === "$type" ? _ = _.concat(el({
                key: `${n}[${m}]`,
                value: t[m],
                valueSpec: o.geometry_type,
                style: i.style,
                styleSpec: i.styleSpec
              })) : u !== "string" && u !== "number" && u !== "boolean" && _.push(new $e(`${n}[${m}]`, t[m], `string, number, or boolean expected, ${u} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let m = 1; m < t.length; m++) _ = _.concat(du({
                key: `${n}[${m}]`,
                value: t[m],
                style: i.style,
                styleSpec: i.styleSpec
              }));
              break;
            case "has":
            case "!has":
              u = jn(t[1]), t.length !== 2 ? _.push(new $e(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : u !== "string" && _.push(new $e(`${n}[1]`, t[1], `string expected, ${u} found`))
          }
          return _
        }

        function pu(i, t) {
          const n = i.key,
            o = i.validateSpec,
            u = i.style,
            _ = i.styleSpec,
            m = i.value,
            y = i.objectKey,
            b = _[`${t}_${i.layerType}`];
          if (!b) return [];
          const M = y.match(/^(.*)-transition$/);
          if (t === "paint" && M && b[M[1]] && b[M[1]].transition) return o({
            key: n,
            value: m,
            valueSpec: _.transition,
            style: u,
            styleSpec: _
          });
          const I = i.valueSpec || b[y];
          if (!I) return [new $e(n, m, `unknown property "${y}"`)];
          let D;
          if (jn(m) === "string" && Ts(I) && !I.tokens && (D = /^{([^}]+)}$/.exec(m))) return [new $e(n, m, `"${y}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(D[1])} }\`.`)];
          const B = [];
          return i.layerType === "symbol" && y === "text-font" && ql(fo(m)) && pi(m.type) === "identity" && B.push(new $e(n, m, '"text-font" does not support identity functions')), B.concat(o({
            key: i.key,
            value: m,
            valueSpec: I,
            style: u,
            styleSpec: _,
            expressionContext: "property",
            propertyType: t,
            propertyKey: y
          }))
        }

        function tl(i) {
          return pu(i, "paint")
        }

        function dd(i) {
          return pu(i, "layout")
        }

        function fu(i) {
          let t = [];
          const n = i.value,
            o = i.key,
            u = i.style,
            _ = i.styleSpec;
          if (jn(n) !== "object") return [new $e(o, n, `object expected, ${jn(n)} found`)];
          n.type || n.ref || t.push(new $e(o, n, 'either "type" or "ref" is required'));
          let m = pi(n.type);
          const y = pi(n.ref);
          if (n.id) {
            const b = pi(n.id);
            for (let M = 0; M < i.arrayIndex; M++) {
              const I = u.layers[M];
              pi(I.id) === b && t.push(new $e(o, n.id, `duplicate layer id "${n.id}", previously used at line ${I.id.__line__}`))
            }
          }
          if ("ref" in n) {
            let b;
            ["type", "source", "source-layer", "filter", "layout"].forEach((M => {
              M in n && t.push(new $e(o, n[M], `"${M}" is prohibited for ref layers`))
            })), u.layers.forEach((M => {
              pi(M.id) === y && (b = M)
            })), b ? b.ref ? t.push(new $e(o, n.ref, "ref cannot reference another ref layer")) : m = pi(b.type) : t.push(new $e(o, n.ref, `ref layer "${y}" not found`))
          } else if (m !== "background")
            if (n.source) {
              const b = u.sources && u.sources[n.source],
                M = b && pi(b.type);
              b ? M === "vector" && m === "raster" ? t.push(new $e(o, n.source, `layer "${n.id}" requires a raster source`)) : M !== "raster-dem" && m === "hillshade" || M !== "raster-dem" && m === "color-relief" ? t.push(new $e(o, n.source, `layer "${n.id}" requires a raster-dem source`)) : M === "raster" && m !== "raster" ? t.push(new $e(o, n.source, `layer "${n.id}" requires a vector source`)) : M !== "vector" || n["source-layer"] ? M === "raster-dem" && m !== "hillshade" && m !== "color-relief" ? t.push(new $e(o, n.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : m !== "line" || !n.paint || !n.paint["line-gradient"] || M === "geojson" && b.lineMetrics || t.push(new $e(o, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new $e(o, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new $e(o, n.source, `source "${n.source}" not found`))
            } else t.push(new $e(o, n, 'missing required property "source"'));
          return t = t.concat(ya({
            key: o,
            value: n,
            valueSpec: _.layer,
            style: i.style,
            styleSpec: i.styleSpec,
            validateSpec: i.validateSpec,
            objectElementValidators: {
              "*": () => [],
              type: () => i.validateSpec({
                key: `${o}.type`,
                value: n.type,
                valueSpec: _.layer.type,
                style: i.style,
                styleSpec: i.styleSpec,
                validateSpec: i.validateSpec,
                object: n,
                objectKey: "type"
              }),
              filter: hu,
              layout: b => ya({
                layer: n,
                key: b.key,
                value: b.value,
                style: b.style,
                styleSpec: b.styleSpec,
                validateSpec: b.validateSpec,
                objectElementValidators: {
                  "*": M => dd(Ct({
                    layerType: m
                  }, M))
                }
              }),
              paint: b => ya({
                layer: n,
                key: b.key,
                value: b.value,
                style: b.style,
                styleSpec: b.styleSpec,
                validateSpec: b.validateSpec,
                objectElementValidators: {
                  "*": M => tl(Ct({
                    layerType: m
                  }, M))
                }
              })
            }
          })), t
        }

        function Eo(i) {
          const t = i.value,
            n = i.key,
            o = jn(t);
          return o !== "string" ? [new $e(n, t, `string expected, ${o} found`)] : []
        }
        const pd = {
          promoteId: function({
            key: i,
            value: t
          }) {
            if (jn(t) === "string") return Eo({
              key: i,
              value: t
            });
            {
              const n = [];
              for (const o in t) n.push(...Eo({
                key: `${i}.${o}`,
                value: t[o]
              }));
              return n
            }
          }
        };

        function _u(i) {
          const t = i.value,
            n = i.key,
            o = i.styleSpec,
            u = i.style,
            _ = i.validateSpec;
          if (!t.type) return [new $e(n, t, '"type" is required')];
          const m = pi(t.type);
          let y;
          switch (m) {
            case "vector":
            case "raster":
              return y = ya({
                key: n,
                value: t,
                valueSpec: o[`source_${m.replace("-","_")}`],
                style: i.style,
                styleSpec: o,
                objectElementValidators: pd,
                validateSpec: _
              }), y;
            case "raster-dem":
              return y = (function(b) {
                var M;
                const I = (M = b.sourceName) !== null && M !== void 0 ? M : "",
                  D = b.value,
                  B = b.styleSpec,
                  V = B.source_raster_dem,
                  H = b.style;
                let K = [];
                const re = jn(D);
                if (D === void 0) return K;
                if (re !== "object") return K.push(new $e("source_raster_dem", D, `object expected, ${re} found`)), K;
                const pe = pi(D.encoding) === "custom",
                  Ne = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                  be = b.value.encoding ? `"${b.value.encoding}"` : "Default";
                for (const Ae in D) !pe && Ne.includes(Ae) ? K.push(new $e(Ae, D[Ae], `In "${I}": "${Ae}" is only valid when "encoding" is set to "custom". ${be} encoding found`)) : V[Ae] ? K = K.concat(b.validateSpec({
                  key: Ae,
                  value: D[Ae],
                  valueSpec: V[Ae],
                  validateSpec: b.validateSpec,
                  style: H,
                  styleSpec: B
                })) : K.push(new $e(Ae, D[Ae], `unknown property "${Ae}"`));
                return K
              })({
                sourceName: n,
                value: t,
                style: i.style,
                styleSpec: o,
                validateSpec: _
              }), y;
            case "geojson":
              if (y = ya({
                  key: n,
                  value: t,
                  valueSpec: o.source_geojson,
                  style: u,
                  styleSpec: o,
                  validateSpec: _,
                  objectElementValidators: pd
                }), t.cluster)
                for (const b in t.clusterProperties) {
                  const [M, I] = t.clusterProperties[b], D = typeof M == "string" ? [M, ["accumulated"],
                    ["get", b]
                  ] : M;
                  y.push(...Ss({
                    key: `${n}.${b}.map`,
                    value: I,
                    expressionContext: "cluster-map"
                  })), y.push(...Ss({
                    key: `${n}.${b}.reduce`,
                    value: D,
                    expressionContext: "cluster-reduce"
                  }))
                }
              return y;
            case "video":
              return ya({
                key: n,
                value: t,
                valueSpec: o.source_video,
                style: u,
                validateSpec: _,
                styleSpec: o
              });
            case "image":
              return ya({
                key: n,
                value: t,
                valueSpec: o.source_image,
                style: u,
                validateSpec: _,
                styleSpec: o
              });
            case "canvas":
              return [new $e(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return el({
                key: `${n}.type`,
                value: t.type,
                valueSpec: {
                  values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                }
              })
          }
        }

        function mu(i) {
          const t = i.value,
            n = i.styleSpec,
            o = n.light,
            u = i.style;
          let _ = [];
          const m = jn(t);
          if (t === void 0) return _;
          if (m !== "object") return _ = _.concat([new $e("light", t, `object expected, ${m} found`)]), _;
          for (const y in t) {
            const b = y.match(/^(.*)-transition$/);
            _ = _.concat(b && o[b[1]] && o[b[1]].transition ? i.validateSpec({
              key: y,
              value: t[y],
              valueSpec: n.transition,
              validateSpec: i.validateSpec,
              style: u,
              styleSpec: n
            }) : o[y] ? i.validateSpec({
              key: y,
              value: t[y],
              valueSpec: o[y],
              validateSpec: i.validateSpec,
              style: u,
              styleSpec: n
            }) : [new $e(y, t[y], `unknown property "${y}"`)])
          }
          return _
        }

        function Ms(i) {
          const t = i.value,
            n = i.styleSpec,
            o = n.sky,
            u = i.style,
            _ = jn(t);
          if (t === void 0) return [];
          if (_ !== "object") return [new $e("sky", t, `object expected, ${_} found`)];
          let m = [];
          for (const y in t) m = m.concat(o[y] ? i.validateSpec({
            key: y,
            value: t[y],
            valueSpec: o[y],
            style: u,
            styleSpec: n
          }) : [new $e(y, t[y], `unknown property "${y}"`)]);
          return m
        }

        function fd(i) {
          const t = i.value,
            n = i.styleSpec,
            o = n.terrain,
            u = i.style;
          let _ = [];
          const m = jn(t);
          if (t === void 0) return _;
          if (m !== "object") return _ = _.concat([new $e("terrain", t, `object expected, ${m} found`)]), _;
          for (const y in t) _ = _.concat(o[y] ? i.validateSpec({
            key: y,
            value: t[y],
            valueSpec: o[y],
            validateSpec: i.validateSpec,
            style: u,
            styleSpec: n
          }) : [new $e(y, t[y], `unknown property "${y}"`)]);
          return _
        }

        function _d(i) {
          let t = [];
          const n = i.value,
            o = i.key;
          if (Array.isArray(n)) {
            const u = [],
              _ = [];
            for (const m in n) n[m].id && u.includes(n[m].id) && t.push(new $e(o, n, `all the sprites' ids must be unique, but ${n[m].id} is duplicated`)), u.push(n[m].id), n[m].url && _.includes(n[m].url) && t.push(new $e(o, n, `all the sprites' URLs must be unique, but ${n[m].url} is duplicated`)), _.push(n[m].url), t = t.concat(ya({
              key: `${o}[${m}]`,
              value: n[m],
              valueSpec: {
                id: {
                  type: "string",
                  required: !0
                },
                url: {
                  type: "string",
                  required: !0
                }
              },
              validateSpec: i.validateSpec
            }));
            return t
          }
          return Eo({
            key: o,
            value: n
          })
        }

        function md(i) {
          return t = i.value, t && t.constructor === Object ? [] : [new $e(i.key, i.value, `object expected, ${jn(i.value)} found`)];
          var t
        }
        const gd = {
          "*": () => [],
          array: Ps,
          boolean: function(i) {
            const t = i.value,
              n = i.key,
              o = jn(t);
            return o !== "boolean" ? [new $e(n, t, `boolean expected, ${o} found`)] : []
          },
          number: Xl,
          color: uu,
          constants: Hl,
          enum: el,
          filter: hu,
          function: hd,
          layer: fu,
          object: ya,
          source: _u,
          light: mu,
          sky: Ms,
          terrain: fd,
          projection: function(i) {
            const t = i.value,
              n = i.styleSpec,
              o = n.projection,
              u = i.style,
              _ = jn(t);
            if (t === void 0) return [];
            if (_ !== "object") return [new $e("projection", t, `object expected, ${_} found`)];
            let m = [];
            for (const y in t) m = m.concat(o[y] ? i.validateSpec({
              key: y,
              value: t[y],
              valueSpec: o[y],
              style: u,
              styleSpec: n
            }) : [new $e(y, t[y], `unknown property "${y}"`)]);
            return m
          },
          projectionDefinition: function(i) {
            const t = i.key;
            let n = i.value;
            n = n instanceof String ? n.valueOf() : n;
            const o = jn(n);
            return o !== "array" || (function(u) {
              return Array.isArray(u) && u.length === 3 && typeof u[0] == "string" && typeof u[1] == "string" && typeof u[2] == "number"
            })(n) || (function(u) {
              return !!["interpolate", "step", "literal"].includes(u[0])
            })(n) ? ["array", "string"].includes(o) ? [] : [new $e(t, n, `projection expected, invalid type "${o}" found`)] : [new $e(t, n, `projection expected, invalid array ${JSON.stringify(n)} found`)]
          },
          string: Eo,
          formatted: function(i) {
            return Eo(i).length === 0 ? [] : Ss(i)
          },
          resolvedImage: function(i) {
            return Eo(i).length === 0 ? [] : Ss(i)
          },
          padding: function(i) {
            const t = i.key,
              n = i.value;
            if (jn(n) === "array") {
              if (n.length < 1 || n.length > 4) return [new $e(t, n, `padding requires 1 to 4 values; ${n.length} values found`)];
              const o = {
                type: "number"
              };
              let u = [];
              for (let _ = 0; _ < n.length; _++) u = u.concat(i.validateSpec({
                key: `${t}[${_}]`,
                value: n[_],
                validateSpec: i.validateSpec,
                valueSpec: o
              }));
              return u
            }
            return Xl({
              key: t,
              value: n,
              valueSpec: {}
            })
          },
          numberArray: function(i) {
            const t = i.key,
              n = i.value;
            if (jn(n) === "array") {
              const o = {
                type: "number"
              };
              if (n.length < 1) return [new $e(t, n, "array length at least 1 expected, length 0 found")];
              let u = [];
              for (let _ = 0; _ < n.length; _++) u = u.concat(i.validateSpec({
                key: `${t}[${_}]`,
                value: n[_],
                validateSpec: i.validateSpec,
                valueSpec: o
              }));
              return u
            }
            return Xl({
              key: t,
              value: n,
              valueSpec: {}
            })
          },
          colorArray: function(i) {
            const t = i.key,
              n = i.value;
            if (jn(n) === "array") {
              if (n.length < 1) return [new $e(t, n, "array length at least 1 expected, length 0 found")];
              let o = [];
              for (let u = 0; u < n.length; u++) o = o.concat(uu({
                key: `${t}[${u}]`,
                value: n[u]
              }));
              return o
            }
            return uu({
              key: t,
              value: n
            })
          },
          variableAnchorOffsetCollection: function(i) {
            const t = i.key,
              n = i.value,
              o = jn(n),
              u = i.styleSpec;
            if (o !== "array" || n.length < 1 || n.length % 2 != 0) return [new $e(t, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let _ = [];
            for (let m = 0; m < n.length; m += 2) _ = _.concat(el({
              key: `${t}[${m}]`,
              value: n[m],
              valueSpec: u.layout_symbol["text-anchor"]
            })), _ = _.concat(Ps({
              key: `${t}[${m+1}]`,
              value: n[m + 1],
              valueSpec: {
                length: 2,
                value: "number"
              },
              validateSpec: i.validateSpec,
              style: i.style,
              styleSpec: u
            }));
            return _
          },
          sprite: _d,
          state: md
        };

        function Yl(i) {
          const t = i.value,
            n = i.valueSpec,
            o = i.styleSpec;
          return i.validateSpec = Yl, n.expression && ql(pi(t)) ? hd(i) : n.expression && Nl(fo(t)) ? Ss(i) : n.type && gd[n.type] ? gd[n.type](i) : ya(Ct({}, i, {
            valueSpec: n.type ? o[n.type] : n
          }))
        }

        function vd(i) {
          const t = i.value,
            n = i.key,
            o = Eo(i);
          return o.length || (t.indexOf("{fontstack}") === -1 && o.push(new $e(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && o.push(new $e(n, t, '"glyphs" url must include a "{range}" token'))), o
        }

        function ra(i, t = Q) {
          let n = [];
          return n = n.concat(Yl({
            key: "",
            value: i,
            valueSpec: t.$root,
            styleSpec: t,
            style: i,
            validateSpec: Yl,
            objectElementValidators: {
              glyphs: vd,
              "*": () => []
            }
          })), i.constants && (n = n.concat(Hl({
            key: "constants",
            value: i.constants
          }))), xa(n)
        }

        function ua(i) {
          return function(t) {
            return i(Object.assign({}, t, {
              validateSpec: Yl
            }))
          }
        }

        function xa(i) {
          return [].concat(i).sort(((t, n) => t.line - n.line))
        }

        function ha(i) {
          return function(...t) {
            return xa(i.apply(this, t))
          }
        }
        ra.source = ha(ua(_u)), ra.sprite = ha(ua(_d)), ra.glyphs = ha(ua(vd)), ra.light = ha(ua(mu)), ra.sky = ha(ua(Ms)), ra.terrain = ha(ua(fd)), ra.state = ha(ua(md)), ra.layer = ha(ua(fu)), ra.filter = ha(ua(hu)), ra.paintProperty = ha(ua(tl)), ra.layoutProperty = ha(ua(dd));
        const yd = Q,
          Is = ra,
          of = Is.light,
          rl = Is.sky,
          xd = Is.paintProperty,
          gu = Is.layoutProperty;

        function bd(i, t) {
          let n = !1;
          if (t && t.length)
            for (const o of t) i.fire(new Xe(new Error(o.message))), n = !0;
          return n
        }
        class Jo {
          constructor(t, n, o) {
            const u = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const m = new Int32Array(this.arrayBuffer);
              t = m[0], this.d = (n = m[1]) + 2 * (o = m[2]);
              for (let b = 0; b < this.d * this.d; b++) {
                const M = m[3 + b],
                  I = m[3 + b + 1];
                u.push(M === I ? null : m.subarray(M, I))
              }
              const y = m[3 + u.length + 1];
              this.keys = m.subarray(m[3 + u.length], y), this.bboxes = m.subarray(y), this.insert = this._insertReadonly
            } else {
              this.d = n + 2 * o;
              for (let m = 0; m < this.d * this.d; m++) u.push([]);
              this.keys = [], this.bboxes = []
            }
            this.n = n, this.extent = t, this.padding = o, this.scale = n / t, this.uid = 0;
            const _ = o / n * t;
            this.min = -_, this.max = t + _
          }
          insert(t, n, o, u, _) {
            this._forEachCell(n, o, u, _, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(n), this.bboxes.push(o), this.bboxes.push(u), this.bboxes.push(_)
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
          }
          _insertCell(t, n, o, u, _, m) {
            this.cells[_].push(m)
          }
          query(t, n, o, u, _) {
            const m = this.min,
              y = this.max;
            if (t <= m && n <= m && y <= o && y <= u && !_) return Array.prototype.slice.call(this.keys);
            {
              const b = [];
              return this._forEachCell(t, n, o, u, this._queryCell, b, {}, _), b
            }
          }
          _queryCell(t, n, o, u, _, m, y, b) {
            const M = this.cells[_];
            if (M !== null) {
              const I = this.keys,
                D = this.bboxes;
              for (let B = 0; B < M.length; B++) {
                const V = M[B];
                if (y[V] === void 0) {
                  const H = 4 * V;
                  (b ? b(D[H + 0], D[H + 1], D[H + 2], D[H + 3]) : t <= D[H + 2] && n <= D[H + 3] && o >= D[H + 0] && u >= D[H + 1]) ? (y[V] = !0, m.push(I[V])) : y[V] = !1
                }
              }
            }
          }
          _forEachCell(t, n, o, u, _, m, y, b) {
            const M = this._convertToCellCoord(t),
              I = this._convertToCellCoord(n),
              D = this._convertToCellCoord(o),
              B = this._convertToCellCoord(u);
            for (let V = M; V <= D; V++)
              for (let H = I; H <= B; H++) {
                const K = this.d * H + V;
                if ((!b || b(this._convertFromCellCoord(V), this._convertFromCellCoord(H), this._convertFromCellCoord(V + 1), this._convertFromCellCoord(H + 1))) && _.call(this, t, n, o, u, K, m, y, b)) return
              }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells,
              n = 3 + this.cells.length + 1 + 1;
            let o = 0;
            for (let m = 0; m < this.cells.length; m++) o += this.cells[m].length;
            const u = new Int32Array(n + o + this.keys.length + this.bboxes.length);
            u[0] = this.extent, u[1] = this.n, u[2] = this.padding;
            let _ = n;
            for (let m = 0; m < t.length; m++) {
              const y = t[m];
              u[3 + m] = _, u.set(y, _), _ += y.length
            }
            return u[3 + t.length] = _, u.set(this.keys, _), _ += this.keys.length, u[3 + t.length + 1] = _, u.set(this.bboxes, _), _ += this.bboxes.length, u.buffer
          }
          static serialize(t, n) {
            const o = t.toArrayBuffer();
            return n && n.push(o), {
              buffer: o
            }
          }
          static deserialize(t) {
            return new Jo(t.buffer)
          }
        }
        const _o = {};

        function Er(i, t, n = {}) {
          if (_o[i]) throw new Error(`${i} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", {
            value: i,
            writeable: !1
          }), _o[i] = {
            klass: t,
            omit: n.omit || [],
            shallow: n.shallow || []
          }
        }
        Er("Object", Object), Er("Set", Set), Er("TransferableGridIndex", Jo), Er("Color", Nr), Er("Error", Error), Er("AJAXError", te), Er("ResolvedImage", Cn), Er("StylePropertyFunction", Vl), Er("StyleExpression", ou, {
          omit: ["_evaluator"]
        }), Er("ZoomDependentExpression", su), Er("ZoomConstantExpression", Ks), Er("CompoundExpression", Ra, {
          omit: ["_evaluate"]
        });
        for (const i in ws) ws[i]._classRegistryKey || Er(`Expression_${i}`, ws[i]);

        function wd(i) {
          return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer")
        }

        function vu(i) {
          return i.$name || i.constructor._classRegistryKey
        }

        function kd(i) {
          return !(function(t) {
            if (t === null || typeof t != "object") return !1;
            const n = vu(t);
            return !(!n || n === "Object")
          })(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || wd(i) || st(i) || ArrayBuffer.isView(i) || i instanceof ImageData)
        }

        function mo(i, t) {
          if (kd(i)) return (wd(i) || st(i)) && t && t.push(i), ArrayBuffer.isView(i) && t && t.push(i.buffer), i instanceof ImageData && t && t.push(i.data.buffer), i;
          if (Array.isArray(i)) {
            const _ = [];
            for (const m of i) _.push(mo(m, t));
            return _
          }
          if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
          const n = vu(i);
          if (!n) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
          if (!_o[n]) throw new Error(`${n} is not registered.`);
          const {
            klass: o
          } = _o[n], u = o.serialize ? o.serialize(i, t) : {};
          if (o.serialize) {
            if (t && u === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property")
          } else {
            for (const _ in i) {
              if (!i.hasOwnProperty(_) || _o[n].omit.indexOf(_) >= 0) continue;
              const m = i[_];
              u[_] = _o[n].shallow.indexOf(_) >= 0 ? m : mo(m, t)
            }
            i instanceof Error && (u.message = i.message)
          }
          if (u.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return n !== "Object" && (u.$name = n), u
        }

        function nl(i) {
          if (kd(i)) return i;
          if (Array.isArray(i)) return i.map(nl);
          if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
          const t = vu(i) || "Object";
          if (!_o[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const {
            klass: n
          } = _o[t];
          if (!n) throw new Error(`can't deserialize unregistered class ${t}`);
          if (n.deserialize) return n.deserialize(i);
          const o = Object.create(n.prototype);
          for (const u of Object.keys(i)) {
            if (u === "$name") continue;
            const _ = i[u];
            o[u] = _o[t].shallow.indexOf(u) >= 0 ? _ : nl(_)
          }
          return o
        }
        class yu {
          constructor() {
            this.first = !0
          }
          update(t, n) {
            const o = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = o, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = o, !0) : (this.lastFloorZoom > o ? (this.lastIntegerZoom = o + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < o && (this.lastIntegerZoom = o, this.lastIntegerZoomTime = n), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = o, !0))
          }
        }
        const Dn = {
          "Latin-1 Supplement": i => i >= 128 && i <= 255,
          "Hangul Jamo": i => i >= 4352 && i <= 4607,
          Khmer: i => i >= 6016 && i <= 6143,
          "General Punctuation": i => i >= 8192 && i <= 8303,
          "Letterlike Symbols": i => i >= 8448 && i <= 8527,
          "Number Forms": i => i >= 8528 && i <= 8591,
          "Miscellaneous Technical": i => i >= 8960 && i <= 9215,
          "Control Pictures": i => i >= 9216 && i <= 9279,
          "Optical Character Recognition": i => i >= 9280 && i <= 9311,
          "Enclosed Alphanumerics": i => i >= 9312 && i <= 9471,
          "Geometric Shapes": i => i >= 9632 && i <= 9727,
          "Miscellaneous Symbols": i => i >= 9728 && i <= 9983,
          "Miscellaneous Symbols and Arrows": i => i >= 11008 && i <= 11263,
          "Ideographic Description Characters": i => i >= 12272 && i <= 12287,
          "CJK Symbols and Punctuation": i => i >= 12288 && i <= 12351,
          Hiragana: i => i >= 12352 && i <= 12447,
          Katakana: i => i >= 12448 && i <= 12543,
          Kanbun: i => i >= 12688 && i <= 12703,
          "CJK Strokes": i => i >= 12736 && i <= 12783,
          "Enclosed CJK Letters and Months": i => i >= 12800 && i <= 13055,
          "CJK Compatibility": i => i >= 13056 && i <= 13311,
          "Yijing Hexagram Symbols": i => i >= 19904 && i <= 19967,
          "CJK Unified Ideographs": i => i >= 19968 && i <= 40959,
          "Hangul Syllables": i => i >= 44032 && i <= 55215,
          "Private Use Area": i => i >= 57344 && i <= 63743,
          "Vertical Forms": i => i >= 65040 && i <= 65055,
          "CJK Compatibility Forms": i => i >= 65072 && i <= 65103,
          "Small Form Variants": i => i >= 65104 && i <= 65135,
          "Halfwidth and Fullwidth Forms": i => i >= 65280 && i <= 65519
        };

        function xu(i) {
          for (const t of i)
            if (Kl(t.charCodeAt(0))) return !0;
          return !1
        }

        function bu(i) {
          for (const t of i)
            if (!Pd(t.charCodeAt(0))) return !1;
          return !0
        }

        function Cs(i) {
          const t = i.map((n => {
            try {
              return new RegExp(`\\p{sc=${n}}`, "u").source
            } catch {
              return null
            }
          })).filter((n => n));
          return new RegExp(t.join("|"), "u")
        }
        const Td = Cs(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);

        function Pd(i) {
          return !Td.test(String.fromCodePoint(i))
        }
        const wu = Cs(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);

        function Kl(i) {
          return !(i !== 746 && i !== 747 && (i < 4352 || !(Dn["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || Dn["CJK Compatibility"](i) || Dn["CJK Strokes"](i) || !(!Dn["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || Dn["Enclosed CJK Letters and Months"](i) || Dn["Ideographic Description Characters"](i) || Dn.Kanbun(i) || Dn.Katakana(i) && i !== 12540 || !(!Dn["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!Dn["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || Dn["Vertical Forms"](i) || Dn["Yijing Hexagram Symbols"](i) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(i)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(i)) || wu.test(String.fromCodePoint(i)))))
        }

        function Jl(i) {
          return !(Kl(i) || (function(t) {
            return !!(Dn["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || Dn["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || Dn["Letterlike Symbols"](t) || Dn["Number Forms"](t) || Dn["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Dn["Control Pictures"](t) && t !== 9251 || Dn["Optical Character Recognition"](t) || Dn["Enclosed Alphanumerics"](t) || Dn["Geometric Shapes"](t) || Dn["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Dn["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Dn["CJK Symbols and Punctuation"](t) || Dn.Katakana(t) || Dn["Private Use Area"](t) || Dn["CJK Compatibility Forms"](t) || Dn["Small Form Variants"](t) || Dn["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
          })(i))
        }
        const Sd = Cs(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);

        function Md(i) {
          return Sd.test(String.fromCodePoint(i))
        }

        function Id(i, t) {
          return !(!t && Md(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || Dn.Khmer(i))
        }

        function sf(i) {
          for (const t of i)
            if (Md(t.charCodeAt(0))) return !0;
          return !1
        }
        const go = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {}
          }
          setState(i) {
            this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL
          }
          getState() {
            return {
              pluginStatus: this.pluginStatus,
              pluginURL: this.pluginURL
            }
          }
          setMethods(i) {
            if (go.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText, this.loadScriptResolve()
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus
          }
          syncState(i, t) {
            return l(this, void 0, void 0, (function*() {
              if (this.isParsed()) return this.getState();
              if (i.pluginStatus !== "loading") return this.setState(i), i;
              const n = i.pluginURL,
                o = new Promise((_ => {
                  this.loadScriptResolve = _
                }));
              t(n);
              const u = new Promise((_ => setTimeout((() => _()), this.TIMEOUT)));
              if (yield Promise.race([o, u]), this.isParsed()) {
                const _ = {
                  pluginStatus: "loaded",
                  pluginURL: n
                };
                return this.setState(_), _
              }
              throw this.setState({
                pluginStatus: "error",
                pluginURL: ""
              }), new Error(`RTL Text Plugin failed to import scripts from ${n}`)
            }))
          }
        };
        class Qn {
          constructor(t, n) {
            this.isSupportedScript = Cd, this.zoom = t, n ? (this.now = n.now || 0, this.fadeDuration = n.fadeDuration || 0, this.zoomHistory = n.zoomHistory || new yu, this.transition = n.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new yu, this.transition = {})
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
          }
          getCrossfadeParameters() {
            const t = this.zoom,
              n = t - Math.floor(t),
              o = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? {
              fromScale: 2,
              toScale: 1,
              t: n + (1 - n) * o
            } : {
              fromScale: .5,
              toScale: 1,
              t: 1 - (1 - o) * n
            }
          }
        }

        function Cd(i) {
          return (function(t, n) {
            for (const o of t)
              if (!Id(o.charCodeAt(0), n)) return !1;
            return !0
          })(i, go.getRTLTextPluginStatus() === "loaded")
        }
        class il {
          constructor(t, n, o) {
            this.property = t, this.value = n, this.expression = (function(u, _, m) {
              if (ql(u)) return new Vl(u, _);
              if (Nl(u)) {
                const y = od(u, _, m);
                if (y.result === "error") throw new Error(y.value.map((b => `${b.key}: ${b.message}`)).join(", "));
                return y.value
              } {
                let y = u;
                return _.type === "color" && typeof u == "string" ? y = Nr.parse(u) : _.type !== "padding" || typeof u != "number" && !Array.isArray(u) ? _.type !== "numberArray" || typeof u != "number" && !Array.isArray(u) ? _.type !== "colorArray" || typeof u != "string" && !Array.isArray(u) ? _.type === "variableAnchorOffsetCollection" && Array.isArray(u) ? y = kn.parse(u) : _.type === "projectionDefinition" && typeof u == "string" && (y = $n.parse(u)) : y = nn.parse(u) : y = mr.parse(u) : y = zr.parse(u), {
                  globalStateRefs: new Set,
                  _globalState: null,
                  kind: "constant",
                  evaluate: () => y
                }
              }
            })(n === void 0 ? t.specification.default : n, t.specification, o)
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite"
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || new Set
          }
          possiblyEvaluate(t, n, o) {
            return this.property.possiblyEvaluate(this, t, n, o)
          }
        }
        class ku {
          constructor(t, n) {
            this.property = t, this.value = new il(t, void 0, n)
          }
          transitioned(t, n) {
            return new Tu(this.property, this.value, n, it({}, t.transition, this.transition), t.now)
          }
          untransitioned() {
            return new Tu(this.property, this.value, null, {}, 0)
          }
        }
        class Ad {
          constructor(t, n) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues), this._globalState = n
          }
          getValue(t) {
            return kt(this._values[t].value.value)
          }
          setValue(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new ku(this._values[t].property, this._globalState)), this._values[t].value = new il(this._values[t].property, n === null ? void 0 : kt(n), this._globalState)
          }
          getTransition(t) {
            return kt(this._values[t].transition)
          }
          setTransition(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new ku(this._values[t].property, this._globalState)), this._values[t].transition = kt(n) || void 0
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const o = this.getValue(n);
              o !== void 0 && (t[n] = o);
              const u = this.getTransition(n);
              u !== void 0 && (t[`${n}-transition`] = u)
            }
            return t
          }
          transitioned(t, n) {
            const o = new Pu(this._properties);
            for (const u of Object.keys(this._values)) o._values[u] = this._values[u].transitioned(t, n._values[u]);
            return o
          }
          untransitioned() {
            const t = new Pu(this._properties);
            for (const n of Object.keys(this._values)) t._values[n] = this._values[n].untransitioned();
            return t
          }
        }
        class Tu {
          constructor(t, n, o, u, _) {
            this.property = t, this.value = n, this.begin = _ + u.delay || 0, this.end = this.begin + u.duration || 0, t.specification.transition && (u.delay || u.duration) && (this.prior = o)
          }
          possiblyEvaluate(t, n, o) {
            const u = t.now || 0,
              _ = this.value.possiblyEvaluate(t, n, o),
              m = this.prior;
            if (m) {
              if (u > this.end) return this.prior = null, _;
              if (this.value.isDataDriven()) return this.prior = null, _;
              if (u < this.begin) return m.possiblyEvaluate(t, n, o);
              {
                const y = (u - this.begin) / (this.end - this.begin);
                return this.property.interpolate(m.possiblyEvaluate(t, n, o), _, Et(y))
              }
            }
            return _
          }
        }
        class Pu {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues)
          }
          possiblyEvaluate(t, n, o) {
            const u = new Qo(this._properties);
            for (const _ of Object.keys(this._values)) u._values[_] = this._values[_].possiblyEvaluate(t, n, o);
            return u
          }
          hasTransition() {
            for (const t of Object.keys(this._values))
              if (this._values[t].prior) return !0;
            return !1
          }
        }
        class zd {
          constructor(t, n) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._globalState = n
          }
          hasValue(t) {
            return this._values[t].value !== void 0
          }
          getValue(t) {
            return kt(this._values[t].value)
          }
          setValue(t, n) {
            this._values[t] = new il(this._values[t].property, n === null ? void 0 : kt(n), this._globalState)
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const o = this.getValue(n);
              o !== void 0 && (t[n] = o)
            }
            return t
          }
          possiblyEvaluate(t, n, o) {
            const u = new Qo(this._properties);
            for (const _ of Object.keys(this._values)) u._values[_] = this._values[_].possiblyEvaluate(t, n, o);
            return u
          }
        }
        class Ua {
          constructor(t, n, o) {
            this.property = t, this.value = n, this.parameters = o
          }
          isConstant() {
            return this.value.kind === "constant"
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t
          }
          evaluate(t, n, o, u) {
            return this.property.evaluate(this.value, this.parameters, t, n, o, u)
          }
        }
        class Qo {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues)
          }
          get(t) {
            return this._values[t]
          }
        }
        class Xr {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, n) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(n)
          }
          interpolate(t, n, o) {
            const u = Yi[this.specification.type];
            return u ? u(t, n, o) : t
          }
        }
        class hn {
          constructor(t, n) {
            this.specification = t, this.overrides = n
          }
          possiblyEvaluate(t, n, o, u) {
            return new Ua(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? {
              kind: "constant",
              value: t.expression.evaluate(n, null, {}, o, u)
            } : t.expression, n)
          }
          interpolate(t, n, o) {
            if (t.value.kind !== "constant" || n.value.kind !== "constant") return t;
            if (t.value.value === void 0 || n.value.value === void 0) return new Ua(this, {
              kind: "constant",
              value: void 0
            }, t.parameters);
            const u = Yi[this.specification.type];
            if (u) {
              const _ = u(t.value.value, n.value.value, o);
              return new Ua(this, {
                kind: "constant",
                value: _
              }, t.parameters)
            }
            return t
          }
          evaluate(t, n, o, u, _, m) {
            return t.kind === "constant" ? t.value : t.evaluate(n, o, u, _, m)
          }
        }
        class al extends hn {
          possiblyEvaluate(t, n, o, u) {
            if (t.value === void 0) return new Ua(this, {
              kind: "constant",
              value: void 0
            }, n);
            if (t.expression.kind === "constant") {
              const _ = t.expression.evaluate(n, null, {}, o, u),
                m = t.property.specification.type === "resolvedImage" && typeof _ != "string" ? _.name : _,
                y = this._calculate(m, m, m, n);
              return new Ua(this, {
                kind: "constant",
                value: y
              }, n)
            }
            if (t.expression.kind === "camera") {
              const _ = this._calculate(t.expression.evaluate({
                zoom: n.zoom - 1
              }), t.expression.evaluate({
                zoom: n.zoom
              }), t.expression.evaluate({
                zoom: n.zoom + 1
              }), n);
              return new Ua(this, {
                kind: "constant",
                value: _
              }, n)
            }
            return new Ua(this, t.expression, n)
          }
          evaluate(t, n, o, u, _, m) {
            if (t.kind === "source") {
              const y = t.evaluate(n, o, u, _, m);
              return this._calculate(y, y, y, n)
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({
              zoom: Math.floor(n.zoom) - 1
            }, o, u), t.evaluate({
              zoom: Math.floor(n.zoom)
            }, o, u), t.evaluate({
              zoom: Math.floor(n.zoom) + 1
            }, o, u), n) : t.value
          }
          _calculate(t, n, o, u) {
            return u.zoom > u.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: n
            } : {
              from: o,
              to: n
            }
          }
          interpolate(t) {
            return t
          }
        }
        class Ed {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, n, o, u) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const _ = t.expression.evaluate(n, null, {}, o, u);
                return this._calculate(_, _, _, n)
              }
              return this._calculate(t.expression.evaluate(new Qn(Math.floor(n.zoom - 1), n)), t.expression.evaluate(new Qn(Math.floor(n.zoom), n)), t.expression.evaluate(new Qn(Math.floor(n.zoom + 1), n)), n)
            }
          }
          _calculate(t, n, o, u) {
            return u.zoom > u.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: n
            } : {
              from: o,
              to: n
            }
          }
          interpolate(t) {
            return t
          }
        }
        class ol {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, n, o, u) {
            return !!t.expression.evaluate(n, null, {}, o, u)
          }
          interpolate() {
            return !1
          }
        }
        class na {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const n in t) {
              const o = t[n];
              o.specification.overridable && this.overridableProperties.push(n);
              const u = this.defaultPropertyValues[n] = new il(o, void 0, void 0),
                _ = this.defaultTransitionablePropertyValues[n] = new ku(o, void 0);
              this.defaultTransitioningPropertyValues[n] = _.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = u.possiblyEvaluate({})
            }
          }
        }
        Er("DataDrivenProperty", hn), Er("DataConstantProperty", Xr), Er("CrossFadedDataDrivenProperty", al), Er("CrossFadedProperty", Ed), Er("ColorRampProperty", ol);
        const Su = "-transition";
        class Za extends he {
          constructor(t, n, o) {
            if (super(), this.id = t.id, this.type = t.type, this._globalState = o, this._featureFilter = {
                filter: () => !0,
                needGeometry: !1,
                getGlobalStateRefs: () => new Set
              }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = Js(t.filter, o)), n.layout && (this._unevaluatedLayout = new zd(n.layout, o)), n.paint)) {
              this._transitionablePaint = new Ad(n.paint, o);
              for (const u in t.paint) this.setPaintProperty(u, t.paint[u], {
                validate: !1
              });
              for (const u in t.layout) this.setLayoutProperty(u, t.layout[u], {
                validate: !1
              });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Qo(n.paint)
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = Js(t, this._globalState)
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = new Set;
            if (this._unevaluatedLayout)
              for (const n in this._unevaluatedLayout._values) {
                const o = this._unevaluatedLayout._values[n];
                for (const u of o.getGlobalStateRefs()) t.add(u)
              }
            for (const n of this._featureFilter.getGlobalStateRefs()) t.add(n);
            return t
          }
          getPaintAffectingGlobalStateRefs() {
            var t;
            const n = new globalThis.Map;
            if (this._transitionablePaint)
              for (const o in this._transitionablePaint._values) {
                const u = this._transitionablePaint._values[o].value;
                for (const _ of u.getGlobalStateRefs()) {
                  const m = (t = n.get(_)) !== null && t !== void 0 ? t : [];
                  m.push({
                    name: o,
                    value: u.value
                  }), n.set(_, m)
                }
              }
            return n
          }
          setLayoutProperty(t, n, o = {}) {
            n != null && this._validate(gu, `layers.${this.id}.layout.${t}`, t, n, o) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, n) : this.visibility = n)
          }
          getPaintProperty(t) {
            return t.endsWith(Su) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
          }
          setPaintProperty(t, n, o = {}) {
            if (n != null && this._validate(xd, `layers.${this.id}.paint.${t}`, t, n, o)) return !1;
            if (t.endsWith(Su)) return this._transitionablePaint.setTransition(t.slice(0, -11), n || void 0), !1;
            {
              const u = this._transitionablePaint._values[t],
                _ = u.property.specification["property-type"] === "cross-faded-data-driven",
                m = u.value.isDataDriven(),
                y = u.value;
              this._transitionablePaint.setValue(t, n), this._handleSpecialPaintPropertyUpdate(t);
              const b = this._transitionablePaint._values[t].value;
              return b.isDataDriven() || m || _ || this._handleOverridablePaintPropertyUpdate(t, y, b)
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {}
          _handleOverridablePaintPropertyUpdate(t, n, o) {
            return !1
          }
          isHidden(t, n = !1) {
            return !!(this.minzoom && t < (n ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition()
          }
          recalculate(t, n) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, n)
          }
          serialize() {
            const t = {
              id: this.id,
              type: this.type,
              source: this.source,
              "source-layer": this.sourceLayer,
              metadata: this.metadata,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              filter: this.filter,
              layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
              paint: this._transitionablePaint && this._transitionablePaint.serialize()
            };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Gt(t, ((n, o) => !(n === void 0 || o === "layout" && !Object.keys(n).length || o === "paint" && !Object.keys(n).length)))
          }
          _validate(t, n, o, u, _ = {}) {
            return (!_ || _.validate !== !1) && bd(this, t.call(Is, {
              key: n,
              layerType: this.type,
              objectKey: o,
              value: u,
              styleSpec: Q,
              style: {
                glyphs: !0,
                sprite: !0
              }
            }))
          }
          is3D() {
            return !1
          }
          isTileClipped() {
            return !1
          }
          hasOffscreenPass() {
            return !1
          }
          resize() {}
          isStateDependent() {
            for (const t in this.paint._values) {
              const n = this.paint.get(t);
              if (n instanceof Ua && Ts(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return !0
            }
            return !1
          }
        }
        let Ld;
        var lf = {
          get paint() {
            return Ld = Ld || new na({
              "raster-opacity": new Xr(Q.paint_raster["raster-opacity"]),
              "raster-hue-rotate": new Xr(Q.paint_raster["raster-hue-rotate"]),
              "raster-brightness-min": new Xr(Q.paint_raster["raster-brightness-min"]),
              "raster-brightness-max": new Xr(Q.paint_raster["raster-brightness-max"]),
              "raster-saturation": new Xr(Q.paint_raster["raster-saturation"]),
              "raster-contrast": new Xr(Q.paint_raster["raster-contrast"]),
              "raster-resampling": new Xr(Q.paint_raster["raster-resampling"]),
              "raster-fade-duration": new Xr(Q.paint_raster["raster-fade-duration"])
            })
          }
        };
        class cf extends Za {
          constructor(t, n) {
            super(t, lf, n)
          }
        }
        const uf = {
          Int8: Int8Array,
          Uint8: Uint8Array,
          Int16: Int16Array,
          Uint16: Uint16Array,
          Int32: Int32Array,
          Uint32: Uint32Array,
          Float32: Float32Array
        };
        class no {
          constructor(t, n) {
            this._structArray = t, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
          }
        }
        class fi {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0)
          }
          static serialize(t, n) {
            return t._trim(), n && (t.isTransferred = !0, n.push(t.arrayBuffer)), {
              length: t.length,
              arrayBuffer: t.arrayBuffer
            }
          }
          static deserialize(t) {
            const n = Object.create(this.prototype);
            return n.arrayBuffer = t.arrayBuffer, n.length = t.length, n.capacity = t.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
          }
          clear() {
            this.length = 0
          }
          resize(t) {
            this.reserve(t), this.length = t
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const n = this.uint8;
              this._refreshViews(), n && this.uint8.set(n)
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
          }
        }

        function wi(i, t = 1) {
          let n = 0,
            o = 0;
          return {
            members: i.map((u => {
              const _ = uf[u.type].BYTES_PER_ELEMENT,
                m = n = Dd(n, Math.max(t, _)),
                y = u.components || 1;
              return o = Math.max(o, _), n += _ * y, {
                name: u.name,
                type: u.type,
                components: y,
                offset: m
              }
            })),
            size: Dd(n, Math.max(o, t)),
            alignment: t
          }
        }

        function Dd(i, t) {
          return Math.ceil(i / t) * t
        }
        class As extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, t, n)
          }
          emplace(t, n, o) {
            const u = 2 * t;
            return this.int16[u + 0] = n, this.int16[u + 1] = o, t
          }
        }
        As.prototype.bytesPerElement = 4, Er("StructArrayLayout2i4", As);
        class Ql extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n, o)
          }
          emplace(t, n, o, u) {
            const _ = 3 * t;
            return this.int16[_ + 0] = n, this.int16[_ + 1] = o, this.int16[_ + 2] = u, t
          }
        }
        Ql.prototype.bytesPerElement = 6, Er("StructArrayLayout3i6", Ql);
        class Mu extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, n, o, u)
          }
          emplace(t, n, o, u, _) {
            const m = 4 * t;
            return this.int16[m + 0] = n, this.int16[m + 1] = o, this.int16[m + 2] = u, this.int16[m + 3] = _, t
          }
        }
        Mu.prototype.bytesPerElement = 8, Er("StructArrayLayout4i8", Mu);
        class vo extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, n, o, u, _, m)
          }
          emplace(t, n, o, u, _, m, y) {
            const b = 6 * t;
            return this.int16[b + 0] = n, this.int16[b + 1] = o, this.int16[b + 2] = u, this.int16[b + 3] = _, this.int16[b + 4] = m, this.int16[b + 5] = y, t
          }
        }
        vo.prototype.bytesPerElement = 12, Er("StructArrayLayout2i4i12", vo);
        class ec extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, n, o, u, _, m)
          }
          emplace(t, n, o, u, _, m, y) {
            const b = 4 * t,
              M = 8 * t;
            return this.int16[b + 0] = n, this.int16[b + 1] = o, this.uint8[M + 4] = u, this.uint8[M + 5] = _, this.uint8[M + 6] = m, this.uint8[M + 7] = y, t
          }
        }
        ec.prototype.bytesPerElement = 8, Er("StructArrayLayout2i4ub8", ec);
        class es extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, n) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, t, n)
          }
          emplace(t, n, o) {
            const u = 2 * t;
            return this.float32[u + 0] = n, this.float32[u + 1] = o, t
          }
        }
        es.prototype.bytesPerElement = 8, Er("StructArrayLayout2f8", es);
        class tc extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m, y, b, M, I) {
            const D = this.length;
            return this.resize(D + 1), this.emplace(D, t, n, o, u, _, m, y, b, M, I)
          }
          emplace(t, n, o, u, _, m, y, b, M, I, D) {
            const B = 10 * t;
            return this.uint16[B + 0] = n, this.uint16[B + 1] = o, this.uint16[B + 2] = u, this.uint16[B + 3] = _, this.uint16[B + 4] = m, this.uint16[B + 5] = y, this.uint16[B + 6] = b, this.uint16[B + 7] = M, this.uint16[B + 8] = I, this.uint16[B + 9] = D, t
          }
        }
        tc.prototype.bytesPerElement = 20, Er("StructArrayLayout10ui20", tc);
        class sl extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m, y, b) {
            const M = this.length;
            return this.resize(M + 1), this.emplace(M, t, n, o, u, _, m, y, b)
          }
          emplace(t, n, o, u, _, m, y, b, M) {
            const I = 8 * t;
            return this.uint16[I + 0] = n, this.uint16[I + 1] = o, this.uint16[I + 2] = u, this.uint16[I + 3] = _, this.uint16[I + 4] = m, this.uint16[I + 5] = y, this.uint16[I + 6] = b, this.uint16[I + 7] = M, t
          }
        }
        sl.prototype.bytesPerElement = 16, Er("StructArrayLayout8ui16", sl);
        class Iu extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m, y, b, M, I, D, B) {
            const V = this.length;
            return this.resize(V + 1), this.emplace(V, t, n, o, u, _, m, y, b, M, I, D, B)
          }
          emplace(t, n, o, u, _, m, y, b, M, I, D, B, V) {
            const H = 12 * t;
            return this.int16[H + 0] = n, this.int16[H + 1] = o, this.int16[H + 2] = u, this.int16[H + 3] = _, this.uint16[H + 4] = m, this.uint16[H + 5] = y, this.uint16[H + 6] = b, this.uint16[H + 7] = M, this.int16[H + 8] = I, this.int16[H + 9] = D, this.int16[H + 10] = B, this.int16[H + 11] = V, t
          }
        }
        Iu.prototype.bytesPerElement = 24, Er("StructArrayLayout4i4ui4i24", Iu);
        class zs extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n, o)
          }
          emplace(t, n, o, u) {
            const _ = 3 * t;
            return this.float32[_ + 0] = n, this.float32[_ + 1] = o, this.float32[_ + 2] = u, t
          }
        }
        zs.prototype.bytesPerElement = 12, Er("StructArrayLayout3f12", zs);
        class ts extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t)
          }
          emplace(t, n) {
            return this.uint32[1 * t + 0] = n, t
          }
        }
        ts.prototype.bytesPerElement = 4, Er("StructArrayLayout1ul4", ts);
        class Cu extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m, y, b, M) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, t, n, o, u, _, m, y, b, M)
          }
          emplace(t, n, o, u, _, m, y, b, M, I) {
            const D = 10 * t,
              B = 5 * t;
            return this.int16[D + 0] = n, this.int16[D + 1] = o, this.int16[D + 2] = u, this.int16[D + 3] = _, this.int16[D + 4] = m, this.int16[D + 5] = y, this.uint32[B + 3] = b, this.uint16[D + 8] = M, this.uint16[D + 9] = I, t
          }
        }
        Cu.prototype.bytesPerElement = 20, Er("StructArrayLayout6i1ul2ui20", Cu);
        class rc extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, n, o, u, _, m)
          }
          emplace(t, n, o, u, _, m, y) {
            const b = 6 * t;
            return this.int16[b + 0] = n, this.int16[b + 1] = o, this.int16[b + 2] = u, this.int16[b + 3] = _, this.int16[b + 4] = m, this.int16[b + 5] = y, t
          }
        }
        rc.prototype.bytesPerElement = 12, Er("StructArrayLayout2i2i2i12", rc);
        class rs extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, t, n, o, u, _)
          }
          emplace(t, n, o, u, _, m) {
            const y = 4 * t,
              b = 8 * t;
            return this.float32[y + 0] = n, this.float32[y + 1] = o, this.float32[y + 2] = u, this.int16[b + 6] = _, this.int16[b + 7] = m, t
          }
        }
        rs.prototype.bytesPerElement = 16, Er("StructArrayLayout2f1f2i16", rs);
        class Au extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, n, o, u, _, m)
          }
          emplace(t, n, o, u, _, m, y) {
            const b = 16 * t,
              M = 4 * t,
              I = 8 * t;
            return this.uint8[b + 0] = n, this.uint8[b + 1] = o, this.float32[M + 1] = u, this.float32[M + 2] = _, this.int16[I + 6] = m, this.int16[I + 7] = y, t
          }
        }
        Au.prototype.bytesPerElement = 16, Er("StructArrayLayout2ub2f2i16", Au);
        class nc extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n, o)
          }
          emplace(t, n, o, u) {
            const _ = 3 * t;
            return this.uint16[_ + 0] = n, this.uint16[_ + 1] = o, this.uint16[_ + 2] = u, t
          }
        }
        nc.prototype.bytesPerElement = 6, Er("StructArrayLayout3ui6", nc);
        class ic extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m, y, b, M, I, D, B, V, H, K, re, pe) {
            const Ne = this.length;
            return this.resize(Ne + 1), this.emplace(Ne, t, n, o, u, _, m, y, b, M, I, D, B, V, H, K, re, pe)
          }
          emplace(t, n, o, u, _, m, y, b, M, I, D, B, V, H, K, re, pe, Ne) {
            const be = 24 * t,
              Ae = 12 * t,
              ot = 48 * t;
            return this.int16[be + 0] = n, this.int16[be + 1] = o, this.uint16[be + 2] = u, this.uint16[be + 3] = _, this.uint32[Ae + 2] = m, this.uint32[Ae + 3] = y, this.uint32[Ae + 4] = b, this.uint16[be + 10] = M, this.uint16[be + 11] = I, this.uint16[be + 12] = D, this.float32[Ae + 7] = B, this.float32[Ae + 8] = V, this.uint8[ot + 36] = H, this.uint8[ot + 37] = K, this.uint8[ot + 38] = re, this.uint32[Ae + 10] = pe, this.int16[be + 22] = Ne, t
          }
        }
        ic.prototype.bytesPerElement = 48, Er("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", ic);
        class zu extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m, y, b, M, I, D, B, V, H, K, re, pe, Ne, be, Ae, ot, gt, er, Pr, _r, wr, Jr, xr) {
            const kr = this.length;
            return this.resize(kr + 1), this.emplace(kr, t, n, o, u, _, m, y, b, M, I, D, B, V, H, K, re, pe, Ne, be, Ae, ot, gt, er, Pr, _r, wr, Jr, xr)
          }
          emplace(t, n, o, u, _, m, y, b, M, I, D, B, V, H, K, re, pe, Ne, be, Ae, ot, gt, er, Pr, _r, wr, Jr, xr, kr) {
            const jt = 32 * t,
              mn = 16 * t;
            return this.int16[jt + 0] = n, this.int16[jt + 1] = o, this.int16[jt + 2] = u, this.int16[jt + 3] = _, this.int16[jt + 4] = m, this.int16[jt + 5] = y, this.int16[jt + 6] = b, this.int16[jt + 7] = M, this.uint16[jt + 8] = I, this.uint16[jt + 9] = D, this.uint16[jt + 10] = B, this.uint16[jt + 11] = V, this.uint16[jt + 12] = H, this.uint16[jt + 13] = K, this.uint16[jt + 14] = re, this.uint16[jt + 15] = pe, this.uint16[jt + 16] = Ne, this.uint16[jt + 17] = be, this.uint16[jt + 18] = Ae, this.uint16[jt + 19] = ot, this.uint16[jt + 20] = gt, this.uint16[jt + 21] = er, this.uint16[jt + 22] = Pr, this.uint32[mn + 12] = _r, this.float32[mn + 13] = wr, this.float32[mn + 14] = Jr, this.uint16[jt + 30] = xr, this.uint16[jt + 31] = kr, t
          }
        }
        zu.prototype.bytesPerElement = 64, Er("StructArrayLayout8i15ui1ul2f2ui64", zu);
        class p extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t)
          }
          emplace(t, n) {
            return this.float32[1 * t + 0] = n, t
          }
        }
        p.prototype.bytesPerElement = 4, Er("StructArrayLayout1f4", p);
        class e extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n, o)
          }
          emplace(t, n, o, u) {
            const _ = 3 * t;
            return this.uint16[6 * t + 0] = n, this.float32[_ + 1] = o, this.float32[_ + 2] = u, t
          }
        }
        e.prototype.bytesPerElement = 12, Er("StructArrayLayout1ui2f12", e);
        class a extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n, o)
          }
          emplace(t, n, o, u) {
            const _ = 4 * t;
            return this.uint32[2 * t + 0] = n, this.uint16[_ + 2] = o, this.uint16[_ + 3] = u, t
          }
        }
        a.prototype.bytesPerElement = 8, Er("StructArrayLayout1ul2ui8", a);
        class c extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, t, n)
          }
          emplace(t, n, o) {
            const u = 2 * t;
            return this.uint16[u + 0] = n, this.uint16[u + 1] = o, t
          }
        }
        c.prototype.bytesPerElement = 4, Er("StructArrayLayout2ui4", c);
        class h extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t)
          }
          emplace(t, n) {
            return this.uint16[1 * t + 0] = n, t
          }
        }
        h.prototype.bytesPerElement = 2, Er("StructArrayLayout1ui2", h);
        class f extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, n, o, u)
          }
          emplace(t, n, o, u, _) {
            const m = 4 * t;
            return this.float32[m + 0] = n, this.float32[m + 1] = o, this.float32[m + 2] = u, this.float32[m + 3] = _, t
          }
        }
        f.prototype.bytesPerElement = 16, Er("StructArrayLayout4f16", f);
        class v extends no {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get anchorPoint() {
            return new j(this.anchorPointX, this.anchorPointY)
          }
        }
        v.prototype.size = 20;
        class w extends Cu {
          get(t) {
            return new v(this, t)
          }
        }
        Er("CollisionBoxArray", w);
        class T extends no {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3]
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2]
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4]
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7]
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8]
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36]
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37]
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38]
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22]
          }
        }
        T.prototype.size = 48;
        class C extends ic {
          get(t) {
            return new T(this, t)
          }
        }
        Er("PlacedSymbolArray", C);
        class z extends no {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6]
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7]
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13]
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14]
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15]
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16]
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17]
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18]
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19]
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20]
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21]
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22]
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13]
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14]
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30]
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31]
          }
        }
        z.prototype.size = 64;
        class F extends zu {
          get(t) {
            return new z(this, t)
          }
        }
        Er("SymbolInstanceArray", F);
        class R extends p {
          getoffsetX(t) {
            return this.float32[1 * t + 0]
          }
        }
        Er("GlyphOffsetArray", R);
        class U extends Ql {
          getx(t) {
            return this.int16[3 * t + 0]
          }
          gety(t) {
            return this.int16[3 * t + 1]
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2]
          }
        }
        Er("SymbolLineVertexArray", U);
        class Y extends no {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0]
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1]
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2]
          }
        }
        Y.prototype.size = 12;
        class ne extends e {
          get(t) {
            return new Y(this, t)
          }
        }
        Er("TextAnchorOffsetArray", ne);
        class ie extends no {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3]
          }
        }
        ie.prototype.size = 8;
        class ae extends a {
          get(t) {
            return new ie(this, t)
          }
        }
        Er("FeatureIndexArray", ae);
        class me extends As {}
        class ke extends As {}
        class _e extends As {}
        class Te extends vo {}
        class Ee extends ec {}
        class ye extends es {}
        class Be extends tc {}
        class ht extends sl {}
        class at extends Iu {}
        class lt extends zs {}
        class pt extends ts {}
        class ur extends rc {}
        class hr extends Au {}
        class Nt extends nc {}
        class Ur extends c {}
        const Tn = wi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: Hn
          } = Tn;
        class zn {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t
          }
          prepareSegment(t, n, o, u) {
            const _ = this.segments[this.segments.length - 1];
            return t > zn.MAX_VERTEX_ARRAY_LENGTH && It(`Max vertices per segment is ${zn.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${zn.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !_ || _.vertexLength + t > zn.MAX_VERTEX_ARRAY_LENGTH || _.sortKey !== u ? this.createNewSegment(n, o, u) : _
          }
          createNewSegment(t, n, o) {
            const u = {
              vertexOffset: t.length,
              primitiveOffset: n.length,
              vertexLength: 0,
              primitiveLength: 0,
              vaos: {}
            };
            return o !== void 0 && (u.sortKey = o), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(u), u
          }
          getOrCreateLatestSegment(t, n, o) {
            return this.prepareSegment(0, t, n, o)
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0
          }
          get() {
            return this.segments
          }
          destroy() {
            for (const t of this.segments)
              for (const n in t.vaos) t.vaos[n].destroy()
          }
          static simpleSegment(t, n, o, u) {
            return new zn([{
              vertexOffset: t,
              primitiveOffset: n,
              vertexLength: o,
              primitiveLength: u,
              vaos: {},
              sortKey: 0
            }])
          }
        }

        function ei(i, t) {
          return 256 * (i = Kt(Math.floor(i), 0, 255)) + Kt(Math.floor(t), 0, 255)
        }
        zn.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Er("SegmentVector", zn);
        const _i = wi([{
            name: "a_pattern_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pattern_to",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_from",
            components: 1,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_to",
            components: 1,
            type: "Uint16"
          }]),
          ni = wi([{
            name: "a_dasharray_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_dasharray_to",
            components: 4,
            type: "Uint16"
          }]);
        var Ai, hi, Oi, di = {
            exports: {}
          },
          Mi = {
            exports: {}
          },
          da = {
            exports: {}
          },
          ns = (function() {
            if (Oi) return di.exports;
            Oi = 1;
            var i = (Ai || (Ai = 1, Mi.exports = function(n, o) {
                var u, _, m, y, b, M, I, D;
                for (_ = n.length - (u = 3 & n.length), m = o, b = 3432918353, M = 461845907, D = 0; D < _;) I = 255 & n.charCodeAt(D) | (255 & n.charCodeAt(++D)) << 8 | (255 & n.charCodeAt(++D)) << 16 | (255 & n.charCodeAt(++D)) << 24, ++D, m = 27492 + (65535 & (y = 5 * (65535 & (m = (m ^= I = (65535 & (I = (I = (65535 & I) * b + (((I >>> 16) * b & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * M + (((I >>> 16) * M & 65535) << 16) & 4294967295) << 13 | m >>> 19)) + ((5 * (m >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (y >>> 16) & 65535) << 16);
                switch (I = 0, u) {
                  case 3:
                    I ^= (255 & n.charCodeAt(D + 2)) << 16;
                  case 2:
                    I ^= (255 & n.charCodeAt(D + 1)) << 8;
                  case 1:
                    m ^= I = (65535 & (I = (I = (65535 & (I ^= 255 & n.charCodeAt(D))) * b + (((I >>> 16) * b & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * M + (((I >>> 16) * M & 65535) << 16) & 4294967295
                }
                return m ^= n.length, m = 2246822507 * (65535 & (m ^= m >>> 16)) + ((2246822507 * (m >>> 16) & 65535) << 16) & 4294967295, m = 3266489909 * (65535 & (m ^= m >>> 13)) + ((3266489909 * (m >>> 16) & 65535) << 16) & 4294967295, (m ^= m >>> 16) >>> 0
              }), Mi.exports),
              t = (hi || (hi = 1, da.exports = function(n, o) {
                for (var u, _ = n.length, m = o ^ _, y = 0; _ >= 4;) u = 1540483477 * (65535 & (u = 255 & n.charCodeAt(y) | (255 & n.charCodeAt(++y)) << 8 | (255 & n.charCodeAt(++y)) << 16 | (255 & n.charCodeAt(++y)) << 24)) + ((1540483477 * (u >>> 16) & 65535) << 16), m = 1540483477 * (65535 & m) + ((1540483477 * (m >>> 16) & 65535) << 16) ^ (u = 1540483477 * (65535 & (u ^= u >>> 24)) + ((1540483477 * (u >>> 16) & 65535) << 16)), _ -= 4, ++y;
                switch (_) {
                  case 3:
                    m ^= (255 & n.charCodeAt(y + 2)) << 16;
                  case 2:
                    m ^= (255 & n.charCodeAt(y + 1)) << 8;
                  case 1:
                    m = 1540483477 * (65535 & (m ^= 255 & n.charCodeAt(y))) + ((1540483477 * (m >>> 16) & 65535) << 16)
                }
                return m = 1540483477 * (65535 & (m ^= m >>> 13)) + ((1540483477 * (m >>> 16) & 65535) << 16), (m ^= m >>> 15) >>> 0
              }), da.exports);
            return di.exports = i, di.exports.murmur3 = i, di.exports.murmur2 = t, di.exports
          })(),
          yo = W(ns);
        class io {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1
          }
          add(t, n, o, u) {
            this.ids.push(is(t)), this.positions.push(n, o, u)
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const n = is(t);
            let o = 0,
              u = this.ids.length - 1;
            for (; o < u;) {
              const m = o + u >> 1;
              this.ids[m] >= n ? u = m : o = m + 1
            }
            const _ = [];
            for (; this.ids[o] === n;) _.push({
              index: this.positions[3 * o],
              start: this.positions[3 * o + 1],
              end: this.positions[3 * o + 2]
            }), o++;
            return _
          }
          static serialize(t, n) {
            const o = new Float64Array(t.ids),
              u = new Uint32Array(t.positions);
            return Es(o, u, 0, o.length - 1), n && n.push(o.buffer, u.buffer), {
              ids: o,
              positions: u
            }
          }
          static deserialize(t) {
            const n = new io;
            return n.ids = t.ids, n.positions = t.positions, n.indexed = !0, n
          }
        }

        function is(i) {
          const t = +i;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : yo(String(i))
        }

        function Es(i, t, n, o) {
          for (; n < o;) {
            const u = i[n + o >> 1];
            let _ = n - 1,
              m = o + 1;
            for (;;) {
              do _++; while (i[_] < u);
              do m--; while (i[m] > u);
              if (_ >= m) break;
              as(i, _, m), as(t, 3 * _, 3 * m), as(t, 3 * _ + 1, 3 * m + 1), as(t, 3 * _ + 2, 3 * m + 2)
            }
            m - n < o - m ? (Es(i, t, n, m), n = m + 1) : (Es(i, t, m + 1, o), o = m)
          }
        }

        function as(i, t, n) {
          const o = i[t];
          i[t] = i[n], i[n] = o
        }
        Er("FeaturePositionMap", io);
        class ba {
          constructor(t, n) {
            this.gl = t.gl, this.location = n
          }
        }
        class pa extends ba {
          constructor(t, n) {
            super(t, n), this.current = 0
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t))
          }
        }
        class xo extends ba {
          constructor(t, n) {
            super(t, n), this.current = [0, 0, 0, 0]
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
          }
        }
        class Lo extends ba {
          constructor(t, n) {
            super(t, n), this.current = Nr.transparent
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
          }
        }
        const ll = new Float32Array(16);

        function Ii(i) {
          return [ei(255 * i.r, 255 * i.g), ei(255 * i.b, 255 * i.a)]
        }
        class ki {
          constructor(t, n, o) {
            this.value = t, this.uniformNames = n.map((u => `u_${u}`)), this.type = o
          }
          setUniform(t, n, o) {
            t.set(o.constantOr(this.value))
          }
          getBinding(t, n, o) {
            return this.type === "color" ? new Lo(t, n) : new pa(t, n)
          }
        }
        class qi {
          constructor(t, n) {
            this.uniformNames = n.map((o => `u_${o}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1
          }
          setConstantPatternPositions(t, n) {
            this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = t.tlbr
          }
          setConstantDashPositions(t, n) {
            this.dashTo = [0, t.y, t.height, t.width], this.dashFrom = [0, n.y, n.height, n.width]
          }
          setUniform(t, n, o, u) {
            let _ = null;
            u === "u_pattern_to" ? _ = this.patternTo : u === "u_pattern_from" ? _ = this.patternFrom : u === "u_dasharray_to" ? _ = this.dashTo : u === "u_dasharray_from" ? _ = this.dashFrom : u === "u_pixel_ratio_to" ? _ = this.pixelRatioTo : u === "u_pixel_ratio_from" && (_ = this.pixelRatioFrom), _ !== null && t.set(_)
          }
          getBinding(t, n, o) {
            return o.substr(0, 9) === "u_pattern" || o.substr(0, 12) === "u_dasharray_" ? new xo(t, n) : new pa(t, n)
          }
        }
        class oi {
          constructor(t, n, o, u) {
            this.expression = t, this.type = o, this.maxValue = 0, this.paintVertexAttributes = n.map((_ => ({
              name: `a_${_}`,
              type: "Float32",
              components: o === "color" ? 2 : 1,
              offset: 0
            }))), this.paintVertexArray = new u
          }
          populatePaintArray(t, n, o) {
            const u = this.paintVertexArray.length,
              _ = this.expression.evaluate(new Qn(0, o), n, {}, o.canonical, [], o.formattedSection);
            this.paintVertexArray.resize(t), this._setPaintValue(u, t, _)
          }
          updatePaintArray(t, n, o, u, _) {
            const m = this.expression.evaluate(new Qn(0, _), o, u);
            this._setPaintValue(t, n, m)
          }
          _setPaintValue(t, n, o) {
            if (this.type === "color") {
              const u = Ii(o);
              for (let _ = t; _ < n; _++) this.paintVertexArray.emplace(_, u[0], u[1])
            } else {
              for (let u = t; u < n; u++) this.paintVertexArray.emplace(u, o);
              this.maxValue = Math.max(this.maxValue, Math.abs(o))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
        }
        class Ga {
          constructor(t, n, o, u, _, m) {
            this.expression = t, this.uniformNames = n.map((y => `u_${y}_t`)), this.type = o, this.useIntegerZoom = u, this.zoom = _, this.maxValue = 0, this.paintVertexAttributes = n.map((y => ({
              name: `a_${y}`,
              type: "Float32",
              components: o === "color" ? 4 : 2,
              offset: 0
            }))), this.paintVertexArray = new m
          }
          populatePaintArray(t, n, o) {
            const u = this.expression.evaluate(new Qn(this.zoom, o), n, {}, o.canonical, [], o.formattedSection),
              _ = this.expression.evaluate(new Qn(this.zoom + 1, o), n, {}, o.canonical, [], o.formattedSection),
              m = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(m, t, u, _)
          }
          updatePaintArray(t, n, o, u, _) {
            const m = this.expression.evaluate(new Qn(this.zoom, _), o, u),
              y = this.expression.evaluate(new Qn(this.zoom + 1, _), o, u);
            this._setPaintValue(t, n, m, y)
          }
          _setPaintValue(t, n, o, u) {
            if (this.type === "color") {
              const _ = Ii(o),
                m = Ii(u);
              for (let y = t; y < n; y++) this.paintVertexArray.emplace(y, _[0], _[1], m[0], m[1])
            } else {
              for (let _ = t; _ < n; _++) this.paintVertexArray.emplace(_, o, u);
              this.maxValue = Math.max(this.maxValue, Math.abs(o), Math.abs(u))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
          setUniform(t, n) {
            const o = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom,
              u = Kt(this.expression.interpolationFactor(o, this.zoom, this.zoom + 1), 0, 1);
            t.set(u)
          }
          getBinding(t, n, o) {
            return new pa(t, n)
          }
        }
        class Do {
          constructor(t, n, o, u, _, m) {
            this.expression = t, this.type = n, this.useIntegerZoom = o, this.zoom = u, this.layerId = m, this.zoomInPaintVertexArray = new _, this.zoomOutPaintVertexArray = new _
          }
          populatePaintArray(t, n, o) {
            const u = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(u, t, this.getPositionIds(n), o)
          }
          updatePaintArray(t, n, o, u, _) {
            this._setPaintValues(t, n, this.getPositionIds(o), _)
          }
          _setPaintValues(t, n, o, u) {
            const _ = this.getPositions(u);
            if (!_ || !o) return;
            const m = _[o.min],
              y = _[o.mid],
              b = _[o.max];
            if (m && y && b)
              for (let M = t; M < n; M++) this.emplace(this.zoomInPaintVertexArray, M, y, m), this.emplace(this.zoomOutPaintVertexArray, M, y, b)
          }
          upload(t) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const n = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, n, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, n, this.expression.isStateDependent)
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
          }
        }
        class Rd extends Do {
          getPositions(t) {
            return t.imagePositions
          }
          getPositionIds(t) {
            return t.patterns && t.patterns[this.layerId]
          }
          getVertexAttributes() {
            return _i.members
          }
          emplace(t, n, o, u) {
            t.emplace(n, o.tlbr[0], o.tlbr[1], o.tlbr[2], o.tlbr[3], u.tlbr[0], u.tlbr[1], u.tlbr[2], u.tlbr[3], o.pixelRatio, u.pixelRatio)
          }
        }
        class jd extends Do {
          getPositions(t) {
            return t.dashPositions
          }
          getPositionIds(t) {
            return t.dashes && t.dashes[this.layerId]
          }
          getVertexAttributes() {
            return ni.members
          }
          emplace(t, n, o, u) {
            t.emplace(n, 0, o.y, o.height, o.width, 0, u.y, u.height, u.width)
          }
        }
        class Fd {
          constructor(t, n, o) {
            this.binders = {}, this._buffers = [];
            const u = [];
            for (const _ in t.paint._values) {
              if (!o(_)) continue;
              const m = t.paint.get(_);
              if (!(m instanceof Ua && Ts(m.property.specification))) continue;
              const y = ss(_, t.type),
                b = m.value,
                M = m.property.specification.type,
                I = m.property.useIntegerZoom,
                D = m.property.specification["property-type"],
                B = D === "cross-faded" || D === "cross-faded-data-driven";
              if (b.kind === "constant") this.binders[_] = B ? new qi(b.value, y) : new ki(b.value, y, M), u.push(`/u_${_}`);
              else if (b.kind === "source" || B) {
                const V = Eu(_, M, "source");
                this.binders[_] = B ? _ === "line-dasharray" ? new jd(b, M, I, n, V, t.id) : new Rd(b, M, I, n, V, t.id) : new oi(b, y, M, V), u.push(`/a_${_}`)
              } else {
                const V = Eu(_, M, "composite");
                this.binders[_] = new Ga(b, y, M, I, n, V), u.push(`/z_${_}`)
              }
            }
            this.cacheKey = u.sort().join("")
          }
          getMaxValue(t) {
            const n = this.binders[t];
            return n instanceof oi || n instanceof Ga ? n.maxValue : 0
          }
          populatePaintArrays(t, n, o) {
            for (const u in this.binders) {
              const _ = this.binders[u];
              (_ instanceof oi || _ instanceof Ga || _ instanceof Do) && _.populatePaintArray(t, n, o)
            }
          }
          setConstantPatternPositions(t, n) {
            for (const o in this.binders) {
              const u = this.binders[o];
              u instanceof qi && u.setConstantPatternPositions(t, n)
            }
          }
          setConstantDashPositions(t, n) {
            for (const o in this.binders) {
              const u = this.binders[o];
              u instanceof qi && u.setConstantDashPositions(t, n)
            }
          }
          updatePaintArrays(t, n, o, u, _) {
            let m = !1;
            for (const y in t) {
              const b = n.getPositions(y);
              for (const M of b) {
                const I = o.feature(M.index);
                for (const D in this.binders) {
                  const B = this.binders[D];
                  if ((B instanceof oi || B instanceof Ga || B instanceof Do) && B.expression.isStateDependent === !0) {
                    const V = u.paint.get(D);
                    B.expression = V.value, B.updatePaintArray(M.start, M.end, I, t[y], _), m = !0
                  }
                }
              }
            }
            return m
          }
          defines() {
            const t = [];
            for (const n in this.binders) {
              const o = this.binders[n];
              (o instanceof ki || o instanceof qi) && t.push(...o.uniformNames.map((u => `#define HAS_UNIFORM_${u}`)))
            }
            return t
          }
          getBinderAttributes() {
            const t = [];
            for (const n in this.binders) {
              const o = this.binders[n];
              if (o instanceof oi || o instanceof Ga)
                for (let u = 0; u < o.paintVertexAttributes.length; u++) t.push(o.paintVertexAttributes[u].name);
              else if (o instanceof Do) {
                const u = o.getVertexAttributes();
                for (const _ of u) t.push(_.name)
              }
            }
            return t
          }
          getBinderUniforms() {
            const t = [];
            for (const n in this.binders) {
              const o = this.binders[n];
              if (o instanceof ki || o instanceof qi || o instanceof Ga)
                for (const u of o.uniformNames) t.push(u)
            }
            return t
          }
          getPaintVertexBuffers() {
            return this._buffers
          }
          getUniforms(t, n) {
            const o = [];
            for (const u in this.binders) {
              const _ = this.binders[u];
              if (_ instanceof ki || _ instanceof qi || _ instanceof Ga) {
                for (const m of _.uniformNames)
                  if (n[m]) {
                    const y = _.getBinding(t, n[m], m);
                    o.push({
                      name: m,
                      property: u,
                      binding: y
                    })
                  }
              }
            }
            return o
          }
          setUniforms(t, n, o, u) {
            for (const {
                name: _,
                property: m,
                binding: y
              }
              of n) this.binders[m].setUniform(y, u, o.get(m), _)
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const n in this.binders) {
              const o = this.binders[n];
              if (t && o instanceof Do) {
                const u = t.fromScale === 2 ? o.zoomInPaintVertexBuffer : o.zoomOutPaintVertexBuffer;
                u && this._buffers.push(u)
              } else(o instanceof oi || o instanceof Ga) && o.paintVertexBuffer && this._buffers.push(o.paintVertexBuffer)
            }
          }
          upload(t) {
            for (const n in this.binders) {
              const o = this.binders[n];
              (o instanceof oi || o instanceof Ga || o instanceof Do) && o.upload(t)
            }
            this.updatePaintBuffers()
          }
          destroy() {
            for (const t in this.binders) {
              const n = this.binders[t];
              (n instanceof oi || n instanceof Ga || n instanceof Do) && n.destroy()
            }
          }
        }
        class os {
          constructor(t, n, o = () => !0) {
            this.programConfigurations = {};
            for (const u of t) this.programConfigurations[u.id] = new Fd(u, n, o);
            this.needsUpload = !1, this._featureMap = new io, this._bufferOffset = 0
          }
          populatePaintArrays(t, n, o, u) {
            for (const _ in this.programConfigurations) this.programConfigurations[_].populatePaintArrays(t, n, u);
            n.id !== void 0 && this._featureMap.add(n.id, o, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0
          }
          updatePaintArrays(t, n, o, u) {
            for (const _ of o) this.needsUpload = this.programConfigurations[_.id].updatePaintArrays(t, this._featureMap, n, _, u) || this.needsUpload
          }
          get(t) {
            return this.programConfigurations[t]
          }
          upload(t) {
            if (this.needsUpload) {
              for (const n in this.programConfigurations) this.programConfigurations[n].upload(t);
              this.needsUpload = !1
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy()
          }
        }

        function ss(i, t) {
          return {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-dasharray": ["dasharray_to", "dasharray_from"],
            "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
          } [i] || [i.replace(`${t}-`, "").replace(/-/g, "_")]
        }

        function Eu(i, t, n) {
          const o = {
              color: {
                source: es,
                composite: f
              },
              number: {
                source: p,
                composite: es
              }
            },
            u = (function(_) {
              return {
                "line-pattern": {
                  source: Be,
                  composite: Be
                },
                "fill-pattern": {
                  source: Be,
                  composite: Be
                },
                "fill-extrusion-pattern": {
                  source: Be,
                  composite: Be
                },
                "line-dasharray": {
                  source: ht,
                  composite: ht
                }
              } [_]
            })(i);
          return u && u[n] || o[t][n]
        }
        Er("ConstantBinder", ki), Er("CrossFadedConstantBinder", qi), Er("SourceExpressionBinder", oi), Er("CrossFadedPatternBinder", Rd), Er("CrossFadedDasharrayBinder", jd), Er("CompositeExpressionBinder", Ga), Er("ProgramConfiguration", Fd, {
          omit: ["_buffers"]
        }), Er("ProgramConfigurationSet", os);
        const ac = Math.pow(2, 14) - 1,
          Lu = -ac - 1;

        function bo(i) {
          const t = ct / i.extent,
            n = i.loadGeometry();
          for (let o = 0; o < n.length; o++) {
            const u = n[o];
            for (let _ = 0; _ < u.length; _++) {
              const m = u[_],
                y = Math.round(m.x * t),
                b = Math.round(m.y * t);
              m.x = Kt(y, Lu, ac), m.y = Kt(b, Lu, ac), (y < m.x || y > m.x + 1 || b < m.y || b > m.y + 1) && It("Geometry exceeds allowed extent, reduce your vector tile buffer size")
            }
          }
          return n
        }

        function Ro(i, t) {
          return {
            type: i.type,
            id: i.id,
            properties: i.properties,
            geometry: t ? bo(i) : []
          }
        }
        const oc = -32768;

        function Ny(i, t, n, o, u) {
          i.emplaceBack(oc + 8 * t + o, oc + 8 * n + u)
        }
        class hf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n => n.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new ke, this.indexArray = new Nt, this.segments = new zn, this.programConfigurations = new os(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((n => n.isStateDependent())).map((n => n.id))
          }
          populate(t, n, o) {
            const u = this.layers[0],
              _ = [];
            let m = null,
              y = !1,
              b = u.type === "heatmap";
            if (u.type === "circle") {
              const I = u;
              m = I.layout.get("circle-sort-key"), y = !m.isConstant(), b = b || I.paint.get("circle-pitch-alignment") === "map"
            }
            const M = b ? n.subdivisionGranularity.circle : 1;
            for (const {
                feature: I,
                id: D,
                index: B,
                sourceLayerIndex: V
              }
              of t) {
              const H = this.layers[0]._featureFilter.needGeometry,
                K = Ro(I, H);
              if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), K, o)) continue;
              const re = y ? m.evaluate(K, {}, o) : void 0,
                pe = {
                  id: D,
                  properties: I.properties,
                  type: I.type,
                  sourceLayerIndex: V,
                  index: B,
                  geometry: H ? K.geometry : bo(I),
                  patterns: {},
                  sortKey: re
                };
              _.push(pe)
            }
            y && _.sort(((I, D) => I.sortKey - D.sortKey));
            for (const I of _) {
              const {
                geometry: D,
                index: B,
                sourceLayerIndex: V
              } = I, H = t[B].feature;
              this.addFeature(I, D, B, o, M), n.featureIndex.insert(H, D, B, V, this.index)
            }
          }
          update(t, n, o) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, {
              imagePositions: o
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Hn), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          addFeature(t, n, o, u, _ = 1) {
            let m;
            switch (_) {
              case 1:
                m = [0, 7];
                break;
              case 3:
                m = [0, 2, 5, 7];
                break;
              case 5:
                m = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                m = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${_}; valid values are 1, 3, 5, 7.`)
            }
            const y = m.length;
            for (const b of n)
              for (const M of b) {
                const I = M.x,
                  D = M.y;
                if (I < 0 || I >= ct || D < 0 || D >= ct) continue;
                const B = this.segments.prepareSegment(y * y, this.layoutVertexArray, this.indexArray, t.sortKey),
                  V = B.vertexLength;
                for (let H = 0; H < y; H++)
                  for (let K = 0; K < y; K++) Ny(this.layoutVertexArray, I, D, m[K], m[H]);
                for (let H = 0; H < y - 1; H++)
                  for (let K = 0; K < y - 1; K++) {
                    const re = V + H * y + K,
                      pe = V + (H + 1) * y + K;
                    this.indexArray.emplaceBack(re, pe + 1, re + 1), this.indexArray.emplaceBack(re, pe, pe + 1)
                  }
                B.vertexLength += y * y, B.primitiveLength += (y - 1) * (y - 1) * 2
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {
              imagePositions: {},
              canonical: u
            })
          }
        }

        function Lm(i, t) {
          for (let n = 0; n < i.length; n++)
            if (sc(t, i[n])) return !0;
          for (let n = 0; n < t.length; n++)
            if (sc(i, t[n])) return !0;
          return !!df(i, t)
        }

        function Bd(i, t, n) {
          return !!sc(i, t) || !!pf(t, i, n)
        }

        function Dm(i, t) {
          if (i.length === 1) return jm(t, i[0]);
          for (let n = 0; n < t.length; n++) {
            const o = t[n];
            for (let u = 0; u < o.length; u++)
              if (sc(i, o[u])) return !0
          }
          for (let n = 0; n < i.length; n++)
            if (jm(t, i[n])) return !0;
          for (let n = 0; n < t.length; n++)
            if (df(i, t[n])) return !0;
          return !1
        }

        function Vy(i, t, n) {
          if (i.length > 1) {
            if (df(i, t)) return !0;
            for (let o = 0; o < t.length; o++)
              if (pf(t[o], i, n)) return !0
          }
          for (let o = 0; o < i.length; o++)
            if (pf(i[o], t, n)) return !0;
          return !1
        }

        function df(i, t) {
          if (i.length === 0 || t.length === 0) return !1;
          for (let n = 0; n < i.length - 1; n++) {
            const o = i[n],
              u = i[n + 1];
            for (let _ = 0; _ < t.length - 1; _++)
              if (Uy(o, u, t[_], t[_ + 1])) return !0
          }
          return !1
        }

        function Uy(i, t, n, o) {
          return mt(i, n, o) !== mt(t, n, o) && mt(i, t, n) !== mt(i, t, o)
        }

        function pf(i, t, n) {
          const o = n * n;
          if (t.length === 1) return i.distSqr(t[0]) < o;
          for (let u = 1; u < t.length; u++)
            if (Rm(i, t[u - 1], t[u]) < o) return !0;
          return !1
        }

        function Rm(i, t, n) {
          const o = t.distSqr(n);
          if (o === 0) return i.distSqr(t);
          const u = ((i.x - t.x) * (n.x - t.x) + (i.y - t.y) * (n.y - t.y)) / o;
          return i.distSqr(u < 0 ? t : u > 1 ? n : n.sub(t)._mult(u)._add(t))
        }

        function jm(i, t) {
          let n, o, u, _ = !1;
          for (let m = 0; m < i.length; m++) {
            n = i[m];
            for (let y = 0, b = n.length - 1; y < n.length; b = y++) o = n[y], u = n[b], o.y > t.y != u.y > t.y && t.x < (u.x - o.x) * (t.y - o.y) / (u.y - o.y) + o.x && (_ = !_)
          }
          return _
        }

        function sc(i, t) {
          let n = !1;
          for (let o = 0, u = i.length - 1; o < i.length; u = o++) {
            const _ = i[o],
              m = i[u];
            _.y > t.y != m.y > t.y && t.x < (m.x - _.x) * (t.y - _.y) / (m.y - _.y) + _.x && (n = !n)
          }
          return n
        }

        function Zy(i, t, n) {
          const o = n[0],
            u = n[2];
          if (i.x < o.x && t.x < o.x || i.x > u.x && t.x > u.x || i.y < o.y && t.y < o.y || i.y > u.y && t.y > u.y) return !1;
          const _ = mt(i, t, n[0]);
          return _ !== mt(i, t, n[1]) || _ !== mt(i, t, n[2]) || _ !== mt(i, t, n[3])
        }

        function lc(i, t, n) {
          const o = t.paint.get(i).value;
          return o.kind === "constant" ? o.value : n.programConfigurations.get(t.id).getMaxValue(i)
        }

        function Od(i) {
          return Math.sqrt(i[0] * i[0] + i[1] * i[1])
        }

        function qd(i, t, n, o, u) {
          if (!t[0] && !t[1]) return i;
          const _ = j.convert(t)._mult(u);
          n === "viewport" && _._rotate(-o);
          const m = [];
          for (let y = 0; y < i.length; y++) m.push(i[y].sub(_));
          return m
        }

        function Gy({
          queryGeometry: i,
          size: t
        }, n) {
          return Bd(i, n, t)
        }

        function $y({
          queryGeometry: i,
          size: t,
          transform: n,
          unwrappedTileID: o,
          getElevation: u
        }, _) {
          return Bd(i, _, t * (n.projectTileCoordinates(_.x, _.y, o, u).signedDistanceFromCamera / n.cameraToCenterDistance))
        }

        function Wy({
          queryGeometry: i,
          size: t,
          transform: n,
          unwrappedTileID: o,
          getElevation: u
        }, _) {
          const m = n.projectTileCoordinates(_.x, _.y, o, u).signedDistanceFromCamera,
            y = t * (n.cameraToCenterDistance / m);
          return Bd(i, ff(_, n, o, u), y)
        }

        function Hy({
          queryGeometry: i,
          size: t,
          transform: n,
          unwrappedTileID: o,
          getElevation: u
        }, _) {
          return Bd(i, ff(_, n, o, u), t)
        }

        function Fm({
          queryGeometry: i,
          size: t,
          transform: n,
          unwrappedTileID: o,
          getElevation: u,
          pitchAlignment: _ = "map",
          pitchScale: m = "map"
        }, y) {
          const b = _ === "map" ? m === "map" ? Gy : $y : m === "map" ? Wy : Hy,
            M = {
              queryGeometry: i,
              size: t,
              transform: n,
              unwrappedTileID: o,
              getElevation: u
            };
          for (const I of y)
            for (const D of I)
              if (b(M, D)) return !0;
          return !1
        }

        function ff(i, t, n, o) {
          const u = t.projectTileCoordinates(i.x, i.y, n, o).point;
          return new j((.5 * u.x + .5) * t.width, (.5 * -u.y + .5) * t.height)
        }
        let Bm, Om;
        Er("CircleBucket", hf, {
          omit: ["layers"]
        });
        var Xy = {
          get paint() {
            return Om = Om || new na({
              "circle-radius": new hn(Q.paint_circle["circle-radius"]),
              "circle-color": new hn(Q.paint_circle["circle-color"]),
              "circle-blur": new hn(Q.paint_circle["circle-blur"]),
              "circle-opacity": new hn(Q.paint_circle["circle-opacity"]),
              "circle-translate": new Xr(Q.paint_circle["circle-translate"]),
              "circle-translate-anchor": new Xr(Q.paint_circle["circle-translate-anchor"]),
              "circle-pitch-scale": new Xr(Q.paint_circle["circle-pitch-scale"]),
              "circle-pitch-alignment": new Xr(Q.paint_circle["circle-pitch-alignment"]),
              "circle-stroke-width": new hn(Q.paint_circle["circle-stroke-width"]),
              "circle-stroke-color": new hn(Q.paint_circle["circle-stroke-color"]),
              "circle-stroke-opacity": new hn(Q.paint_circle["circle-stroke-opacity"])
            })
          },
          get layout() {
            return Bm = Bm || new na({
              "circle-sort-key": new hn(Q.layout_circle["circle-sort-key"])
            })
          }
        };
        class Yy extends Za {
          constructor(t, n) {
            super(t, Xy, n)
          }
          createBucket(t) {
            return new hf(t)
          }
          queryRadius(t) {
            const n = t;
            return lc("circle-radius", this, n) + lc("circle-stroke-width", this, n) + Od(this.paint.get("circle-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: n,
            featureState: o,
            geometry: u,
            transform: _,
            pixelsToTileUnits: m,
            unwrappedTileID: y,
            getElevation: b
          }) {
            const M = qd(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -_.bearingInRadians, m),
              I = this.paint.get("circle-radius").evaluate(n, o) + this.paint.get("circle-stroke-width").evaluate(n, o),
              D = this.paint.get("circle-pitch-scale"),
              B = this.paint.get("circle-pitch-alignment");
            let V, H;
            return B === "map" ? (V = M, H = I * m) : (V = (function(K, re, pe, Ne) {
              return K.map((be => ff(be, re, pe, Ne)))
            })(M, _, y, b), H = I), Fm({
              queryGeometry: V,
              size: H,
              transform: _,
              unwrappedTileID: y,
              getElevation: b,
              pitchAlignment: B,
              pitchScale: D
            }, u)
          }
        }
        class qm extends hf {}
        let Nm;
        Er("HeatmapBucket", qm, {
          omit: ["layers"]
        });
        var Ky = {
          get paint() {
            return Nm = Nm || new na({
              "heatmap-radius": new hn(Q.paint_heatmap["heatmap-radius"]),
              "heatmap-weight": new hn(Q.paint_heatmap["heatmap-weight"]),
              "heatmap-intensity": new Xr(Q.paint_heatmap["heatmap-intensity"]),
              "heatmap-color": new ol(Q.paint_heatmap["heatmap-color"]),
              "heatmap-opacity": new Xr(Q.paint_heatmap["heatmap-opacity"])
            })
          }
        };

        function _f(i, {
          width: t,
          height: n
        }, o, u) {
          if (u) {
            if (u instanceof Uint8ClampedArray) u = new Uint8Array(u.buffer);
            else if (u.length !== t * n * o) throw new RangeError(`mismatched image size. expected: ${u.length} but got: ${t*n*o}`)
          } else u = new Uint8Array(t * n * o);
          return i.width = t, i.height = n, i.data = u, i
        }

        function Vm(i, {
          width: t,
          height: n
        }, o) {
          if (t === i.width && n === i.height) return;
          const u = _f({}, {
            width: t,
            height: n
          }, o);
          mf(i, u, {
            x: 0,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            width: Math.min(i.width, t),
            height: Math.min(i.height, n)
          }, o), i.width = t, i.height = n, i.data = u.data
        }

        function mf(i, t, n, o, u, _) {
          if (u.width === 0 || u.height === 0) return t;
          if (u.width > i.width || u.height > i.height || n.x > i.width - u.width || n.y > i.height - u.height) throw new RangeError("out of range source coordinates for image copy");
          if (u.width > t.width || u.height > t.height || o.x > t.width - u.width || o.y > t.height - u.height) throw new RangeError("out of range destination coordinates for image copy");
          const m = i.data,
            y = t.data;
          if (m === y) throw new Error("srcData equals dstData, so image is already copied");
          for (let b = 0; b < u.height; b++) {
            const M = ((n.y + b) * i.width + n.x) * _,
              I = ((o.y + b) * t.width + o.x) * _;
            for (let D = 0; D < u.width * _; D++) y[I + D] = m[M + D]
          }
          return t
        }
        class Du {
          constructor(t, n) {
            _f(this, t, 1, n)
          }
          resize(t) {
            Vm(this, t, 1)
          }
          clone() {
            return new Du({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, n, o, u, _) {
            mf(t, n, o, u, _, 1)
          }
        }
        class Ta {
          constructor(t, n) {
            _f(this, t, 4, n)
          }
          resize(t) {
            Vm(this, t, 4)
          }
          replace(t, n) {
            n ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
          }
          clone() {
            return new Ta({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, n, o, u, _) {
            mf(t, n, o, u, _, 4)
          }
          setPixel(t, n, o) {
            const u = 4 * (t * this.width + n);
            this.data[u + 0] = Math.round(255 * o.r / o.a), this.data[u + 1] = Math.round(255 * o.g / o.a), this.data[u + 2] = Math.round(255 * o.b / o.a), this.data[u + 3] = Math.round(255 * o.a)
          }
        }

        function Um(i) {
          const t = {},
            n = i.resolution || 256,
            o = i.clips ? i.clips.length : 1,
            u = i.image || new Ta({
              width: n,
              height: o
            });
          if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
          const _ = (m, y, b) => {
            t[i.evaluationKey] = b;
            const M = i.expression.evaluate(t);
            u.setPixel(m / 4 / n, y / 4, M)
          };
          if (i.clips)
            for (let m = 0, y = 0; m < o; ++m, y += 4 * n)
              for (let b = 0, M = 0; b < n; b++, M += 4) {
                const I = b / (n - 1),
                  {
                    start: D,
                    end: B
                  } = i.clips[m];
                _(y, M, D * (1 - I) + B * I)
              } else
                for (let m = 0, y = 0; m < n; m++, y += 4) _(0, y, m / (n - 1));
          return u
        }
        Er("AlphaImage", Du), Er("RGBAImage", Ta);
        const gf = "big-fb";
        class Jy extends Za {
          createBucket(t) {
            return new qm(t)
          }
          constructor(t, n) {
            super(t, Ky, n), this.heatmapFbos = new Map, this._updateColorRamp()
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp()
          }
          _updateColorRamp() {
            this.colorRamp = Um({
              expression: this._transitionablePaint._values["heatmap-color"].value.expression,
              evaluationKey: "heatmapDensity",
              image: this.colorRamp
            }), this.colorRampTexture = null
          }
          resize() {
            this.heatmapFbos.has(gf) && this.heatmapFbos.delete(gf)
          }
          queryRadius(t) {
            return lc("heatmap-radius", this, t)
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: n,
            featureState: o,
            geometry: u,
            transform: _,
            pixelsToTileUnits: m,
            unwrappedTileID: y,
            getElevation: b
          }) {
            return Fm({
              queryGeometry: t,
              size: this.paint.get("heatmap-radius").evaluate(n, o) * m,
              transform: _,
              unwrappedTileID: y,
              getElevation: b
            }, u)
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
          }
        }
        let Zm;
        var Qy = {
          get paint() {
            return Zm = Zm || new na({
              "hillshade-illumination-direction": new Xr(Q.paint_hillshade["hillshade-illumination-direction"]),
              "hillshade-illumination-altitude": new Xr(Q.paint_hillshade["hillshade-illumination-altitude"]),
              "hillshade-illumination-anchor": new Xr(Q.paint_hillshade["hillshade-illumination-anchor"]),
              "hillshade-exaggeration": new Xr(Q.paint_hillshade["hillshade-exaggeration"]),
              "hillshade-shadow-color": new Xr(Q.paint_hillshade["hillshade-shadow-color"]),
              "hillshade-highlight-color": new Xr(Q.paint_hillshade["hillshade-highlight-color"]),
              "hillshade-accent-color": new Xr(Q.paint_hillshade["hillshade-accent-color"]),
              "hillshade-method": new Xr(Q.paint_hillshade["hillshade-method"])
            })
          }
        };
        class ex extends Za {
          constructor(t, n) {
            super(t, Qy, n), this.recalculate({
              zoom: 0,
              zoomHistory: {}
            }, void 0)
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values,
              n = this.paint.get("hillshade-illumination-altitude").values,
              o = this.paint.get("hillshade-highlight-color").values,
              u = this.paint.get("hillshade-shadow-color").values;
            const _ = Math.max(t.length, n.length, o.length, u.length);
            t = t.concat(Array(_ - t.length).fill(t.at(-1))), n = n.concat(Array(_ - n.length).fill(n.at(-1))), o = o.concat(Array(_ - o.length).fill(o.at(-1))), u = u.concat(Array(_ - u.length).fill(u.at(-1)));
            const m = n.map(Sr);
            return {
              directionRadians: t.map(Sr),
              altitudeRadians: m,
              shadowColor: u,
              highlightColor: o
            }
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
          }
        }
        let Gm;
        var tx = {
          get paint() {
            return Gm = Gm || new na({
              "color-relief-opacity": new Xr(Q["paint_color-relief"]["color-relief-opacity"]),
              "color-relief-color": new ol(Q["paint_color-relief"]["color-relief-color"])
            })
          }
        };
        class vf {
          constructor(t, n, o, u) {
            this.context = t, this.format = o, this.texture = t.gl.createTexture(), this.update(n, u)
          }
          update(t, n, o) {
            const {
              width: u,
              height: _
            } = t, m = !(this.size && this.size[0] === u && this.size[1] === _ || o), {
              context: y
            } = this, {
              gl: b
            } = y;
            if (this.useMipmap = !!(n && n.useMipmap), b.bindTexture(b.TEXTURE_2D, this.texture), y.pixelStoreUnpackFlipY.set(!1), y.pixelStoreUnpack.set(1), y.pixelStoreUnpackPremultiplyAlpha.set(this.format === b.RGBA && (!n || n.premultiply !== !1)), m) this.size = [u, _], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || st(t) ? b.texImage2D(b.TEXTURE_2D, 0, this.format, this.format, b.UNSIGNED_BYTE, t) : b.texImage2D(b.TEXTURE_2D, 0, this.format, u, _, 0, this.format, b.UNSIGNED_BYTE, t.data);
            else {
              const {
                x: M,
                y: I
              } = o || {
                x: 0,
                y: 0
              };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || st(t) ? b.texSubImage2D(b.TEXTURE_2D, 0, M, I, b.RGBA, b.UNSIGNED_BYTE, t) : b.texSubImage2D(b.TEXTURE_2D, 0, M, I, u, _, b.RGBA, b.UNSIGNED_BYTE, t.data)
            }
            this.useMipmap && this.isSizePowerOfTwo() && b.generateMipmap(b.TEXTURE_2D), y.pixelStoreUnpackFlipY.setDefault(), y.pixelStoreUnpack.setDefault(), y.pixelStoreUnpackPremultiplyAlpha.setDefault()
          }
          bind(t, n, o) {
            const {
              context: u
            } = this, {
              gl: _
            } = u;
            _.bindTexture(_.TEXTURE_2D, this.texture), o !== _.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (o = _.LINEAR), t !== this.filter && (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_MAG_FILTER, t), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MIN_FILTER, o || t), this.filter = t), n !== this.wrap && (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, n), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, n), this.wrap = n)
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
          }
          destroy() {
            const {
              gl: t
            } = this.context;
            t.deleteTexture(this.texture), this.texture = null
          }
        }
        class $m {
          constructor(t, n, o, u = 1, _ = 1, m = 1, y = 0) {
            if (this.uid = t, n.height !== n.width) throw new RangeError("DEM tiles must be square");
            if (o && !["mapbox", "terrarium", "custom"].includes(o)) return void It(`"${o}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = n.height;
            const b = this.dim = n.height - 2;
            switch (this.data = new Uint32Array(n.data.buffer), o) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = u, this.greenFactor = _, this.blueFactor = m, this.baseShift = y;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4
            }
            for (let M = 0; M < b; M++) this.data[this._idx(-1, M)] = this.data[this._idx(0, M)], this.data[this._idx(b, M)] = this.data[this._idx(b - 1, M)], this.data[this._idx(M, -1)] = this.data[this._idx(M, 0)], this.data[this._idx(M, b)] = this.data[this._idx(M, b - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(b, -1)] = this.data[this._idx(b - 1, 0)], this.data[this._idx(-1, b)] = this.data[this._idx(0, b - 1)], this.data[this._idx(b, b)] = this.data[this._idx(b - 1, b - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let M = 0; M < b; M++)
              for (let I = 0; I < b; I++) {
                const D = this.get(M, I);
                D > this.max && (this.max = D), D < this.min && (this.min = D)
              }
          }
          get(t, n) {
            const o = new Uint8Array(this.data.buffer),
              u = 4 * this._idx(t, n);
            return this.unpack(o[u], o[u + 1], o[u + 2])
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
          }
          _idx(t, n) {
            if (t < -1 || t >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (n + 1) * this.stride + (t + 1)
          }
          unpack(t, n, o) {
            return t * this.redFactor + n * this.greenFactor + o * this.blueFactor - this.baseShift
          }
          pack(t) {
            return Wm(t, this.getUnpackVector())
          }
          getPixels() {
            return new Ta({
              width: this.stride,
              height: this.stride
            }, new Uint8Array(this.data.buffer))
          }
          backfillBorder(t, n, o) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let u = n * this.dim,
              _ = n * this.dim + this.dim,
              m = o * this.dim,
              y = o * this.dim + this.dim;
            switch (n) {
              case -1:
                u = _ - 1;
                break;
              case 1:
                _ = u + 1
            }
            switch (o) {
              case -1:
                m = y - 1;
                break;
              case 1:
                y = m + 1
            }
            const b = -n * this.dim,
              M = -o * this.dim;
            for (let I = m; I < y; I++)
              for (let D = u; D < _; D++) this.data[this._idx(D, I)] = t.data[this._idx(D + b, I + M)]
          }
        }

        function Wm(i, t) {
          const n = t[0],
            o = t[1],
            u = t[2],
            _ = t[3],
            m = Math.min(n, o, u),
            y = Math.round((i + _) / m);
          return {
            r: Math.floor(y * m / n) % 256,
            g: Math.floor(y * m / o) % 256,
            b: Math.floor(y * m / u) % 256
          }
        }
        Er("DEMData", $m);
        class rx extends Za {
          constructor(t, n) {
            super(t, tx, n)
          }
          _createColorRamp(t) {
            const n = {
                elevationStops: [],
                colorStops: []
              },
              o = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (o instanceof Ks && o._styleExpression.expression instanceof On) {
              this.colorRampExpression = o;
              const m = o._styleExpression.expression;
              n.elevationStops = m.labels, n.colorStops = [];
              for (const y of n.elevationStops) n.colorStops.push(m.evaluate({
                globals: {
                  elevation: y
                }
              }))
            }
            if (n.elevationStops.length < 1 && (n.elevationStops = [0], n.colorStops = [Nr.transparent]), n.elevationStops.length < 2 && (n.elevationStops.push(n.elevationStops[0] + 1), n.colorStops.push(n.colorStops[0])), n.elevationStops.length <= t) return n;
            const u = {
                elevationStops: [],
                colorStops: []
              },
              _ = (n.elevationStops.length - 1) / (t - 1);
            for (let m = 0; m < n.elevationStops.length - .5; m += _) u.elevationStops.push(n.elevationStops[Math.round(m)]), u.colorStops.push(n.colorStops[Math.round(m)]);
            return It(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t}, provided: ${n.elevationStops.length}`), u
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
          }
          getColorRampTextures(t, n, o) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const u = this._createColorRamp(n),
              _ = new Ta({
                width: u.colorStops.length,
                height: 1
              }),
              m = new Ta({
                width: u.colorStops.length,
                height: 1
              });
            for (let y = 0; y < u.elevationStops.length; y++) {
              const b = Wm(u.elevationStops[y], o);
              m.setPixel(0, y, new Nr(b.r / 255, b.g / 255, b.b / 255, 1)), _.setPixel(0, y, u.colorStops[y])
            }
            return this.colorRampTextures = {
              elevationTexture: new vf(t, m, t.gl.RGBA),
              colorTexture: new vf(t, _, t.gl.RGBA)
            }, this.colorRampTextures
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures
          }
        }
        const nx = wi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: ix
          } = nx;

        function Nd(i, t, n) {
          const o = n.patternDependencies;
          let u = !1;
          for (const _ of t) {
            const m = _.paint.get(`${i}-pattern`);
            m.isConstant() || (u = !0);
            const y = m.constantOr(null);
            y && (u = !0, o[y.to] = !0, o[y.from] = !0)
          }
          return u
        }

        function yf(i, t, n, o, u) {
          const {
            zoom: _
          } = o, m = u.patternDependencies;
          for (const y of t) {
            const b = y.paint.get(`${i}-pattern`).value;
            if (b.kind !== "constant") {
              let M = b.evaluate({
                  zoom: _ - 1
                }, n, {}, u.availableImages),
                I = b.evaluate({
                  zoom: _
                }, n, {}, u.availableImages),
                D = b.evaluate({
                  zoom: _ + 1
                }, n, {}, u.availableImages);
              M = M && M.name ? M.name : M, I = I && I.name ? I.name : I, D = D && D.name ? D.name : D, m[M] = !0, m[I] = !0, m[D] = !0, n.patterns[y.id] = {
                min: M,
                mid: I,
                max: D
              }
            }
          }
          return n
        }

        function Hm(i, t, n, o, u) {
          let _;
          if (u === (function(m, y, b, M) {
              let I = 0;
              for (let D = y, B = b - M; D < b; D += M) I += (m[B] - m[D]) * (m[D + 1] + m[B + 1]), B = D;
              return I
            })(i, t, n, o) > 0)
            for (let m = t; m < n; m += o) _ = Jm(m / o | 0, i[m], i[m + 1], _);
          else
            for (let m = n - o; m >= t; m -= o) _ = Jm(m / o | 0, i[m], i[m + 1], _);
          return _ && cc(_, _.next) && (Bu(_), _ = _.next), _
        }

        function cl(i, t) {
          if (!i) return i;
          t || (t = i);
          let n, o = i;
          do
            if (n = !1, o.steiner || !cc(o, o.next) && Ci(o.prev, o, o.next) !== 0) o = o.next;
            else {
              if (Bu(o), o = t = o.prev, o === o.next) break;
              n = !0
            } while (n || o !== t);
          return t
        }

        function Ru(i, t, n, o, u, _, m) {
          if (!i) return;
          !m && _ && (function(b, M, I, D) {
            let B = b;
            do B.z === 0 && (B.z = xf(B.x, B.y, M, I, D)), B.prevZ = B.prev, B.nextZ = B.next, B = B.next; while (B !== b);
            B.prevZ.nextZ = null, B.prevZ = null, (function(V) {
              let H, K = 1;
              do {
                let re, pe = V;
                V = null;
                let Ne = null;
                for (H = 0; pe;) {
                  H++;
                  let be = pe,
                    Ae = 0;
                  for (let gt = 0; gt < K && (Ae++, be = be.nextZ, be); gt++);
                  let ot = K;
                  for (; Ae > 0 || ot > 0 && be;) Ae !== 0 && (ot === 0 || !be || pe.z <= be.z) ? (re = pe, pe = pe.nextZ, Ae--) : (re = be, be = be.nextZ, ot--), Ne ? Ne.nextZ = re : V = re, re.prevZ = Ne, Ne = re;
                  pe = be
                }
                Ne.nextZ = null, K *= 2
              } while (H > 1)
            })(B)
          })(i, o, u, _);
          let y = i;
          for (; i.prev !== i.next;) {
            const b = i.prev,
              M = i.next;
            if (_ ? ox(i, o, u, _) : ax(i)) t.push(b.i, i.i, M.i), Bu(i), i = M.next, y = M.next;
            else if ((i = M) === y) {
              m ? m === 1 ? Ru(i = sx(cl(i), t), t, n, o, u, _, 2) : m === 2 && lx(i, t, n, o, u, _) : Ru(cl(i), t, n, o, u, _, 1);
              break
            }
          }
        }

        function ax(i) {
          const t = i.prev,
            n = i,
            o = i.next;
          if (Ci(t, n, o) >= 0) return !1;
          const u = t.x,
            _ = n.x,
            m = o.x,
            y = t.y,
            b = n.y,
            M = o.y,
            I = Math.min(u, _, m),
            D = Math.min(y, b, M),
            B = Math.max(u, _, m),
            V = Math.max(y, b, M);
          let H = o.next;
          for (; H !== t;) {
            if (H.x >= I && H.x <= B && H.y >= D && H.y <= V && ju(u, y, _, b, m, M, H.x, H.y) && Ci(H.prev, H, H.next) >= 0) return !1;
            H = H.next
          }
          return !0
        }

        function ox(i, t, n, o) {
          const u = i.prev,
            _ = i,
            m = i.next;
          if (Ci(u, _, m) >= 0) return !1;
          const y = u.x,
            b = _.x,
            M = m.x,
            I = u.y,
            D = _.y,
            B = m.y,
            V = Math.min(y, b, M),
            H = Math.min(I, D, B),
            K = Math.max(y, b, M),
            re = Math.max(I, D, B),
            pe = xf(V, H, t, n, o),
            Ne = xf(K, re, t, n, o);
          let be = i.prevZ,
            Ae = i.nextZ;
          for (; be && be.z >= pe && Ae && Ae.z <= Ne;) {
            if (be.x >= V && be.x <= K && be.y >= H && be.y <= re && be !== u && be !== m && ju(y, I, b, D, M, B, be.x, be.y) && Ci(be.prev, be, be.next) >= 0 || (be = be.prevZ, Ae.x >= V && Ae.x <= K && Ae.y >= H && Ae.y <= re && Ae !== u && Ae !== m && ju(y, I, b, D, M, B, Ae.x, Ae.y) && Ci(Ae.prev, Ae, Ae.next) >= 0)) return !1;
            Ae = Ae.nextZ
          }
          for (; be && be.z >= pe;) {
            if (be.x >= V && be.x <= K && be.y >= H && be.y <= re && be !== u && be !== m && ju(y, I, b, D, M, B, be.x, be.y) && Ci(be.prev, be, be.next) >= 0) return !1;
            be = be.prevZ
          }
          for (; Ae && Ae.z <= Ne;) {
            if (Ae.x >= V && Ae.x <= K && Ae.y >= H && Ae.y <= re && Ae !== u && Ae !== m && ju(y, I, b, D, M, B, Ae.x, Ae.y) && Ci(Ae.prev, Ae, Ae.next) >= 0) return !1;
            Ae = Ae.nextZ
          }
          return !0
        }

        function sx(i, t) {
          let n = i;
          do {
            const o = n.prev,
              u = n.next.next;
            !cc(o, u) && Ym(o, n, n.next, u) && Fu(o, u) && Fu(u, o) && (t.push(o.i, n.i, u.i), Bu(n), Bu(n.next), n = i = u), n = n.next
          } while (n !== i);
          return cl(n)
        }

        function lx(i, t, n, o, u, _) {
          let m = i;
          do {
            let y = m.next.next;
            for (; y !== m.prev;) {
              if (m.i !== y.i && px(m, y)) {
                let b = Km(m, y);
                return m = cl(m, m.next), b = cl(b, b.next), Ru(m, t, n, o, u, _, 0), void Ru(b, t, n, o, u, _, 0)
              }
              y = y.next
            }
            m = m.next
          } while (m !== i)
        }

        function cx(i, t) {
          let n = i.x - t.x;
          return n === 0 && (n = i.y - t.y, n === 0) && (n = (i.next.y - i.y) / (i.next.x - i.x) - (t.next.y - t.y) / (t.next.x - t.x)), n
        }

        function ux(i, t) {
          const n = (function(u, _) {
            let m = _;
            const y = u.x,
              b = u.y;
            let M, I = -1 / 0;
            if (cc(u, m)) return m;
            do {
              if (cc(u, m.next)) return m.next;
              if (b <= m.y && b >= m.next.y && m.next.y !== m.y) {
                const K = m.x + (b - m.y) * (m.next.x - m.x) / (m.next.y - m.y);
                if (K <= y && K > I && (I = K, M = m.x < m.next.x ? m : m.next, K === y)) return M
              }
              m = m.next
            } while (m !== _);
            if (!M) return null;
            const D = M,
              B = M.x,
              V = M.y;
            let H = 1 / 0;
            m = M;
            do {
              if (y >= m.x && m.x >= B && y !== m.x && Xm(b < V ? y : I, b, B, V, b < V ? I : y, b, m.x, m.y)) {
                const K = Math.abs(b - m.y) / (y - m.x);
                Fu(m, u) && (K < H || K === H && (m.x > M.x || m.x === M.x && hx(M, m))) && (M = m, H = K)
              }
              m = m.next
            } while (m !== D);
            return M
          })(i, t);
          if (!n) return t;
          const o = Km(n, i);
          return cl(o, o.next), cl(n, n.next)
        }

        function hx(i, t) {
          return Ci(i.prev, i, t.prev) < 0 && Ci(t.next, i, i.next) < 0
        }

        function xf(i, t, n, o, u) {
          return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - n) * u | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - o) * u | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }

        function dx(i) {
          let t = i,
            n = i;
          do(t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next; while (t !== i);
          return n
        }

        function Xm(i, t, n, o, u, _, m, y) {
          return (u - m) * (t - y) >= (i - m) * (_ - y) && (i - m) * (o - y) >= (n - m) * (t - y) && (n - m) * (_ - y) >= (u - m) * (o - y)
        }

        function ju(i, t, n, o, u, _, m, y) {
          return !(i === m && t === y) && Xm(i, t, n, o, u, _, m, y)
        }

        function px(i, t) {
          return i.next.i !== t.i && i.prev.i !== t.i && !(function(n, o) {
            let u = n;
            do {
              if (u.i !== n.i && u.next.i !== n.i && u.i !== o.i && u.next.i !== o.i && Ym(u, u.next, n, o)) return !0;
              u = u.next
            } while (u !== n);
            return !1
          })(i, t) && (Fu(i, t) && Fu(t, i) && (function(n, o) {
            let u = n,
              _ = !1;
            const m = (n.x + o.x) / 2,
              y = (n.y + o.y) / 2;
            do u.y > y != u.next.y > y && u.next.y !== u.y && m < (u.next.x - u.x) * (y - u.y) / (u.next.y - u.y) + u.x && (_ = !_), u = u.next; while (u !== n);
            return _
          })(i, t) && (Ci(i.prev, i, t.prev) || Ci(i, t.prev, t)) || cc(i, t) && Ci(i.prev, i, i.next) > 0 && Ci(t.prev, t, t.next) > 0)
        }

        function Ci(i, t, n) {
          return (t.y - i.y) * (n.x - t.x) - (t.x - i.x) * (n.y - t.y)
        }

        function cc(i, t) {
          return i.x === t.x && i.y === t.y
        }

        function Ym(i, t, n, o) {
          const u = Ud(Ci(i, t, n)),
            _ = Ud(Ci(i, t, o)),
            m = Ud(Ci(n, o, i)),
            y = Ud(Ci(n, o, t));
          return u !== _ && m !== y || !(u !== 0 || !Vd(i, n, t)) || !(_ !== 0 || !Vd(i, o, t)) || !(m !== 0 || !Vd(n, i, o)) || !(y !== 0 || !Vd(n, t, o))
        }

        function Vd(i, t, n) {
          return t.x <= Math.max(i.x, n.x) && t.x >= Math.min(i.x, n.x) && t.y <= Math.max(i.y, n.y) && t.y >= Math.min(i.y, n.y)
        }

        function Ud(i) {
          return i > 0 ? 1 : i < 0 ? -1 : 0
        }

        function Fu(i, t) {
          return Ci(i.prev, i, i.next) < 0 ? Ci(i, t, i.next) >= 0 && Ci(i, i.prev, t) >= 0 : Ci(i, t, i.prev) < 0 || Ci(i, i.next, t) < 0
        }

        function Km(i, t) {
          const n = bf(i.i, i.x, i.y),
            o = bf(t.i, t.x, t.y),
            u = i.next,
            _ = t.prev;
          return i.next = t, t.prev = i, n.next = u, u.prev = n, o.next = n, n.prev = o, _.next = o, o.prev = _, o
        }

        function Jm(i, t, n, o) {
          const u = bf(i, t, n);
          return o ? (u.next = o.next, u.prev = o, o.next.prev = u, o.next = u) : (u.prev = u, u.next = u), u
        }

        function Bu(i) {
          i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ)
        }

        function bf(i, t, n) {
          return {
            i,
            x: t,
            y: n,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
          }
        }
        class uc {
          constructor(t, n) {
            if (n > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = n
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1)
          }
        }
        class Zd {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle
          }
        }
        Zd.noSubdivision = new Zd({
          fill: new uc(0, 0),
          line: new uc(0, 0),
          tile: new uc(0, 0),
          stencil: new uc(0, 0),
          circle: 1
        }), Er("SubdivisionGranularityExpression", uc), Er("SubdivisionGranularitySetting", Zd);
        const hc = -32768,
          Ou = 32767;
        class fx {
          constructor(t, n) {
            this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = t, this._granularityCellSize = ct / t, this._canonical = n
          }
          _getKey(t, n) {
            return (t += 32768) << 16 | n + 32768
          }
          _vertexToIndex(t, n) {
            if (t < -32768 || n < -32768 || t > 32767 || n > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const o = 0 | Math.round(t),
              u = 0 | Math.round(n),
              _ = this._getKey(o, u);
            if (this._vertexDictionary.has(_)) return this._vertexDictionary.get(_);
            const m = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(_, m), this._vertexBuffer.push(o, u), m
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(u, _) {
              const m = [];
              for (let y = 0; y < _.length; y += 3) {
                const b = _[y],
                  M = _[y + 1],
                  I = _[y + 2],
                  D = u[2 * b],
                  B = u[2 * b + 1];
                (u[2 * M] - D) * (u[2 * I + 1] - B) - (u[2 * M + 1] - B) * (u[2 * I] - D) > 0 ? (m.push(b), m.push(I), m.push(M)) : (m.push(b), m.push(M), m.push(I))
              }
              return m
            })(this._vertexBuffer, t);
            const n = [],
              o = t.length;
            for (let u = 0; u < o; u += 3) {
              const _ = [t[u + 0], t[u + 1], t[u + 2]],
                m = [this._vertexBuffer[2 * t[u + 0] + 0], this._vertexBuffer[2 * t[u + 0] + 1], this._vertexBuffer[2 * t[u + 1] + 0], this._vertexBuffer[2 * t[u + 1] + 1], this._vertexBuffer[2 * t[u + 2] + 0], this._vertexBuffer[2 * t[u + 2] + 1]];
              let y = 1 / 0,
                b = 1 / 0,
                M = -1 / 0,
                I = -1 / 0;
              for (let K = 0; K < 3; K++) {
                const re = m[2 * K],
                  pe = m[2 * K + 1];
                y = Math.min(y, re), M = Math.max(M, re), b = Math.min(b, pe), I = Math.max(I, pe)
              }
              if (y === M || b === I) continue;
              const D = Math.floor(y / this._granularityCellSize),
                B = Math.ceil(M / this._granularityCellSize),
                V = Math.floor(b / this._granularityCellSize),
                H = Math.ceil(I / this._granularityCellSize);
              if (D !== B || V !== H)
                for (let K = V; K < H; K++) {
                  const re = this._scanlineGenerateVertexRingForCellRow(K, m, _);
                  _x(this._vertexBuffer, re, n)
                } else n.push(..._)
            }
            return n
          }
          _scanlineGenerateVertexRingForCellRow(t, n, o) {
            const u = t * this._granularityCellSize,
              _ = u + this._granularityCellSize,
              m = [];
            for (let y = 0; y < 3; y++) {
              const b = n[2 * y],
                M = n[2 * y + 1],
                I = n[2 * (y + 1) % 6],
                D = n[(2 * (y + 1) + 1) % 6],
                B = n[2 * (y + 2) % 6],
                V = n[(2 * (y + 2) + 1) % 6],
                H = I - b,
                K = D - M,
                re = H === 0,
                pe = K === 0,
                Ne = (u - M) / K,
                be = (_ - M) / K,
                Ae = Math.min(Ne, be),
                ot = Math.max(Ne, be);
              if (!pe && (Ae >= 1 || ot <= 0) || pe && (M < u || M > _)) {
                D >= u && D <= _ && m.push(o[(y + 1) % 3]);
                continue
              }!pe && Ae > 0 && m.push(this._vertexToIndex(b + H * Ae, M + K * Ae));
              const gt = b + H * Math.max(Ae, 0),
                er = b + H * Math.min(ot, 1);
              re || this._generateIntraEdgeVertices(m, b, M, I, D, gt, er), !pe && ot < 1 && m.push(this._vertexToIndex(b + H * ot, M + K * ot)), (pe || D >= u && D <= _) && m.push(o[(y + 1) % 3]), !pe && (D <= u || D >= _) && this._generateInterEdgeVertices(m, b, M, I, D, B, V, er, u, _)
            }
            return m
          }
          _generateIntraEdgeVertices(t, n, o, u, _, m, y) {
            const b = u - n,
              M = _ - o,
              I = M === 0,
              D = I ? Math.min(n, u) : Math.min(m, y),
              B = I ? Math.max(n, u) : Math.max(m, y),
              V = Math.floor(D / this._granularityCellSize) + 1,
              H = Math.ceil(B / this._granularityCellSize) - 1;
            if (I ? n < u : m < y)
              for (let K = V; K <= H; K++) {
                const re = K * this._granularityCellSize;
                t.push(this._vertexToIndex(re, o + M * (re - n) / b))
              } else
                for (let K = H; K >= V; K--) {
                  const re = K * this._granularityCellSize;
                  t.push(this._vertexToIndex(re, o + M * (re - n) / b))
                }
          }
          _generateInterEdgeVertices(t, n, o, u, _, m, y, b, M, I) {
            const D = _ - o,
              B = m - u,
              V = y - _,
              H = (M - _) / V,
              K = (I - _) / V,
              re = Math.min(H, K),
              pe = Math.max(H, K),
              Ne = u + B * re;
            let be = Math.floor(Math.min(Ne, b) / this._granularityCellSize) + 1,
              Ae = Math.ceil(Math.max(Ne, b) / this._granularityCellSize) - 1,
              ot = b < Ne;
            const gt = V === 0;
            if (gt && (y === M || y === I)) return;
            if (gt || re >= 1 || pe <= 0) {
              const Pr = o - y,
                _r = m + (n - m) * Math.min((M - y) / Pr, (I - y) / Pr);
              be = Math.floor(Math.min(_r, b) / this._granularityCellSize) + 1, Ae = Math.ceil(Math.max(_r, b) / this._granularityCellSize) - 1, ot = b < _r
            }
            const er = D > 0 ? I : M;
            if (ot)
              for (let Pr = be; Pr <= Ae; Pr++) t.push(this._vertexToIndex(Pr * this._granularityCellSize, er));
            else
              for (let Pr = Ae; Pr >= be; Pr--) t.push(this._vertexToIndex(Pr * this._granularityCellSize, er))
          }
          _generateOutline(t) {
            const n = [];
            for (const o of t) {
              const u = ul(o, this._granularity, !0),
                _ = this._pointArrayToIndices(u),
                m = [];
              for (let y = 1; y < _.length; y++) m.push(_[y - 1]), m.push(_[y]);
              n.push(m)
            }
            return n
          }
          _handlePoles(t) {
            let n = !1,
              o = !1;
            this._canonical && (this._canonical.y === 0 && (n = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (o = !0)), (n || o) && this._fillPoles(t, n, o)
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let n = 0; n < t.length; n += 2) {
              const o = t[n + 1];
              o === hc && (t[n + 1] = -32767), o === Ou && (t[n + 1] = 32766)
            }
          }
          _generatePoleQuad(t, n, o, u, _, m) {
            u > _ != (m === hc) ? (t.push(n), t.push(o), t.push(this._vertexToIndex(u, m)), t.push(o), t.push(this._vertexToIndex(_, m)), t.push(this._vertexToIndex(u, m))) : (t.push(o), t.push(n), t.push(this._vertexToIndex(u, m)), t.push(this._vertexToIndex(_, m)), t.push(o), t.push(this._vertexToIndex(u, m)))
          }
          _fillPoles(t, n, o) {
            const u = this._vertexBuffer,
              _ = ct,
              m = t.length;
            for (let y = 2; y < m; y += 3) {
              const b = t[y - 2],
                M = t[y - 1],
                I = t[y],
                D = u[2 * b],
                B = u[2 * b + 1],
                V = u[2 * M],
                H = u[2 * M + 1],
                K = u[2 * I],
                re = u[2 * I + 1];
              n && (B === 0 && H === 0 && this._generatePoleQuad(t, b, M, D, V, hc), H === 0 && re === 0 && this._generatePoleQuad(t, M, I, V, K, hc), re === 0 && B === 0 && this._generatePoleQuad(t, I, b, K, D, hc)), o && (B === _ && H === _ && this._generatePoleQuad(t, b, M, D, V, Ou), H === _ && re === _ && this._generatePoleQuad(t, M, I, V, K, Ou), re === _ && B === _ && this._generatePoleQuad(t, I, b, K, D, Ou))
            }
          }
          _initializeVertices(t) {
            for (let n = 0; n < t.length; n += 2) this._vertexToIndex(t[n], t[n + 1])
          }
          subdividePolygonInternal(t, n) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const {
              flattened: o,
              holeIndices: u
            } = (function(y) {
              const b = [],
                M = [];
              for (const I of y)
                if (I.length !== 0) {
                  I !== y[0] && b.push(M.length / 2);
                  for (let D = 0; D < I.length; D++) M.push(I[D].x), M.push(I[D].y)
                } return {
                flattened: M,
                holeIndices: b
              }
            })(t);
            let _;
            this._initializeVertices(o);
            try {
              const y = (function(M, I, D = 2) {
                  const B = I && I.length,
                    V = B ? I[0] * D : M.length;
                  let H = Hm(M, 0, V, D, !0);
                  const K = [];
                  if (!H || H.next === H.prev) return K;
                  let re, pe, Ne;
                  if (B && (H = (function(be, Ae, ot, gt) {
                      const er = [];
                      for (let Pr = 0, _r = Ae.length; Pr < _r; Pr++) {
                        const wr = Hm(be, Ae[Pr] * gt, Pr < _r - 1 ? Ae[Pr + 1] * gt : be.length, gt, !1);
                        wr === wr.next && (wr.steiner = !0), er.push(dx(wr))
                      }
                      er.sort(cx);
                      for (let Pr = 0; Pr < er.length; Pr++) ot = ux(er[Pr], ot);
                      return ot
                    })(M, I, H, D)), M.length > 80 * D) {
                    re = M[0], pe = M[1];
                    let be = re,
                      Ae = pe;
                    for (let ot = D; ot < V; ot += D) {
                      const gt = M[ot],
                        er = M[ot + 1];
                      gt < re && (re = gt), er < pe && (pe = er), gt > be && (be = gt), er > Ae && (Ae = er)
                    }
                    Ne = Math.max(be - re, Ae - pe), Ne = Ne !== 0 ? 32767 / Ne : 0
                  }
                  return Ru(H, K, D, re, pe, Ne, 0), K
                })(o, u),
                b = this._convertIndices(o, y);
              _ = this._subdivideTrianglesScanline(b)
            } catch (y) {
              console.error(y)
            }
            let m = [];
            return n && (m = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(_), {
              verticesFlattened: this._vertexBuffer,
              indicesTriangles: _,
              indicesLineList: m
            }
          }
          _convertIndices(t, n) {
            const o = [];
            for (let u = 0; u < n.length; u++) o.push(this._vertexToIndex(t[2 * n[u]], t[2 * n[u] + 1]));
            return o
          }
          _pointArrayToIndices(t) {
            const n = [];
            for (let o = 0; o < t.length; o++) {
              const u = t[o];
              n.push(this._vertexToIndex(u.x, u.y))
            }
            return n
          }
        }

        function Qm(i, t, n, o = !0) {
          return new fx(n, t).subdividePolygonInternal(i, o)
        }

        function ul(i, t, n = !1) {
          if (!i || i.length < 1) return [];
          if (i.length < 2) return [];
          const o = i[0],
            u = i[i.length - 1],
            _ = n && (o.x !== u.x || o.y !== u.y);
          if (t < 2) return _ ? [...i, i[0]] : [...i];
          const m = Math.floor(ct / t),
            y = [];
          y.push(new j(i[0].x, i[0].y));
          const b = i.length,
            M = _ ? b : b - 1;
          for (let I = 0; I < M; I++) {
            const D = i[I],
              B = I < b - 1 ? i[I + 1] : i[0],
              V = D.x,
              H = D.y,
              K = B.x,
              re = B.y,
              pe = V !== K,
              Ne = H !== re;
            if (!pe && !Ne) continue;
            const be = K - V,
              Ae = re - H,
              ot = Math.abs(be),
              gt = Math.abs(Ae);
            let er = V,
              Pr = H;
            for (;;) {
              const wr = be > 0 ? (Math.floor(er / m) + 1) * m : (Math.ceil(er / m) - 1) * m,
                Jr = Ae > 0 ? (Math.floor(Pr / m) + 1) * m : (Math.ceil(Pr / m) - 1) * m,
                xr = Math.abs(er - wr),
                kr = Math.abs(Pr - Jr),
                jt = Math.abs(er - K),
                mn = Math.abs(Pr - re),
                xn = pe ? xr / ot : Number.POSITIVE_INFINITY,
                cn = Ne ? kr / gt : Number.POSITIVE_INFINITY;
              if ((jt <= xr || !pe) && (mn <= kr || !Ne)) break;
              if (xn < cn && pe || !Ne) {
                er = wr, Pr += Ae * xn;
                const Hr = new j(er, Math.round(Pr));
                y[y.length - 1].x === Hr.x && y[y.length - 1].y === Hr.y || y.push(Hr)
              } else {
                er += be * cn, Pr = Jr;
                const Hr = new j(Math.round(er), Pr);
                y[y.length - 1].x === Hr.x && y[y.length - 1].y === Hr.y || y.push(Hr)
              }
            }
            const _r = new j(K, re);
            y[y.length - 1].x === _r.x && y[y.length - 1].y === _r.y || y.push(_r)
          }
          return y
        }

        function _x(i, t, n) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let o = 0,
            u = i[2 * t[0]];
          for (let b = 1; b < t.length; b++) {
            const M = i[2 * t[b]];
            M < u && (u = M, o = b)
          }
          const _ = t.length;
          let m = o,
            y = (m + 1) % _;
          for (;;) {
            const b = m - 1 >= 0 ? m - 1 : _ - 1,
              M = (y + 1) % _,
              I = i[2 * t[b]],
              D = i[2 * t[M]],
              B = i[2 * t[m]],
              V = i[2 * t[m] + 1],
              H = i[2 * t[y] + 1];
            let K = !1;
            if (I < D) K = !0;
            else if (I > D) K = !1;
            else {
              const re = H - V,
                pe = -(i[2 * t[y]] - B),
                Ne = V < H ? 1 : -1;
              ((I - B) * re + (i[2 * t[b] + 1] - V) * pe) * Ne > ((D - B) * re + (i[2 * t[M] + 1] - V) * pe) * Ne && (K = !0)
            }
            if (K) {
              const re = t[b],
                pe = t[m],
                Ne = t[y];
              re !== pe && re !== Ne && pe !== Ne && n.push(Ne, pe, re), m--, m < 0 && (m = _ - 1)
            } else {
              const re = t[M],
                pe = t[m],
                Ne = t[y];
              re !== pe && re !== Ne && pe !== Ne && n.push(Ne, pe, re), y++, y >= _ && (y = 0)
            }
            if (b === M) break
          }
        }

        function eg(i, t, n, o, u, _, m, y, b) {
          const M = u.length / 2,
            I = m && y && b;
          if (M < zn.MAX_VERTEX_ARRAY_LENGTH) {
            const D = t.prepareSegment(M, n, o),
              B = D.vertexLength;
            for (let K = 0; K < _.length; K += 3) o.emplaceBack(B + _[K], B + _[K + 1], B + _[K + 2]);
            let V, H;
            D.vertexLength += M, D.primitiveLength += _.length / 3, I && (H = m.prepareSegment(M, n, y), V = H.vertexLength, H.vertexLength += M);
            for (let K = 0; K < u.length; K += 2) i(u[K], u[K + 1]);
            if (I)
              for (let K = 0; K < b.length; K++) {
                const re = b[K];
                for (let pe = 1; pe < re.length; pe += 2) y.emplaceBack(V + re[pe - 1], V + re[pe]);
                H.primitiveLength += re.length / 2
              }
          } else(function(D, B, V, H, K, re) {
            const pe = [];
            for (let gt = 0; gt < H.length / 2; gt++) pe.push(-1);
            const Ne = {
              count: 0
            };
            let be = 0,
              Ae = D.getOrCreateLatestSegment(B, V),
              ot = Ae.vertexLength;
            for (let gt = 2; gt < K.length; gt += 3) {
              const er = K[gt - 2],
                Pr = K[gt - 1],
                _r = K[gt];
              let wr = pe[er] < be,
                Jr = pe[Pr] < be,
                xr = pe[_r] < be;
              Ae.vertexLength + ((wr ? 1 : 0) + (Jr ? 1 : 0) + (xr ? 1 : 0)) > zn.MAX_VERTEX_ARRAY_LENGTH && (Ae = D.createNewSegment(B, V), be = Ne.count, wr = !0, Jr = !0, xr = !0, ot = 0);
              const kr = qu(pe, H, re, Ne, er, wr, Ae),
                jt = qu(pe, H, re, Ne, Pr, Jr, Ae),
                mn = qu(pe, H, re, Ne, _r, xr, Ae);
              V.emplaceBack(ot + kr - be, ot + jt - be, ot + mn - be), Ae.primitiveLength++
            }
          })(t, n, o, u, _, i), I && (function(D, B, V, H, K, re) {
            const pe = [];
            for (let gt = 0; gt < H.length / 2; gt++) pe.push(-1);
            const Ne = {
              count: 0
            };
            let be = 0,
              Ae = D.getOrCreateLatestSegment(B, V),
              ot = Ae.vertexLength;
            for (let gt = 0; gt < K.length; gt++) {
              const er = K[gt];
              for (let Pr = 1; Pr < K[gt].length; Pr += 2) {
                const _r = er[Pr - 1],
                  wr = er[Pr];
                let Jr = pe[_r] < be,
                  xr = pe[wr] < be;
                Ae.vertexLength + ((Jr ? 1 : 0) + (xr ? 1 : 0)) > zn.MAX_VERTEX_ARRAY_LENGTH && (Ae = D.createNewSegment(B, V), be = Ne.count, Jr = !0, xr = !0, ot = 0);
                const kr = qu(pe, H, re, Ne, _r, Jr, Ae),
                  jt = qu(pe, H, re, Ne, wr, xr, Ae);
                V.emplaceBack(ot + kr - be, ot + jt - be), Ae.primitiveLength++
              }
            }
          })(m, n, y, u, b, i), t.forceNewSegmentOnNextPrepare(), m == null || m.forceNewSegmentOnNextPrepare()
        }

        function qu(i, t, n, o, u, _, m) {
          if (_) {
            const y = o.count;
            return n(t[2 * u], t[2 * u + 1]), i[u] = o.count, o.count++, m.vertexLength++, y
          }
          return i[u]
        }
        class wf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n => n.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new _e, this.indexArray = new Nt, this.indexArray2 = new Ur, this.programConfigurations = new os(t.layers, t.zoom), this.segments = new zn, this.segments2 = new zn, this.stateDependentLayerIds = this.layers.filter((n => n.isStateDependent())).map((n => n.id))
          }
          populate(t, n, o) {
            this.hasDependencies = Nd("fill", this.layers, n);
            const u = this.layers[0].layout.get("fill-sort-key"),
              _ = !u.isConstant(),
              m = [];
            for (const {
                feature: y,
                id: b,
                index: M,
                sourceLayerIndex: I
              }
              of t) {
              const D = this.layers[0]._featureFilter.needGeometry,
                B = Ro(y, D);
              if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), B, o)) continue;
              const V = _ ? u.evaluate(B, {}, o, n.availableImages) : void 0,
                H = {
                  id: b,
                  properties: y.properties,
                  type: y.type,
                  sourceLayerIndex: I,
                  index: M,
                  geometry: D ? B.geometry : bo(y),
                  patterns: {},
                  sortKey: V
                };
              m.push(H)
            }
            _ && m.sort(((y, b) => y.sortKey - b.sortKey));
            for (const y of m) {
              const {
                geometry: b,
                index: M,
                sourceLayerIndex: I
              } = y;
              if (this.hasDependencies) {
                const D = yf("fill", this.layers, y, {
                  zoom: this.zoom
                }, n);
                this.patternFeatures.push(D)
              } else this.addFeature(y, b, M, o, {}, n.subdivisionGranularity);
              n.featureIndex.insert(t[M].feature, b, M, I, this.index)
            }
          }
          update(t, n, o) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, {
              imagePositions: o
            })
          }
          addFeatures(t, n, o) {
            for (const u of this.patternFeatures) this.addFeature(u, u.geometry, u.index, n, o, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ix), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy())
          }
          addFeature(t, n, o, u, _, m) {
            for (const y of zl(n, 500)) {
              const b = Qm(y, u, m.fill.getGranularityForZoomLevel(u.z)),
                M = this.layoutVertexArray;
              eg(((I, D) => {
                M.emplaceBack(I, D)
              }), this.segments, this.layoutVertexArray, this.indexArray, b.verticesFlattened, b.indicesTriangles, this.segments2, this.indexArray2, b.indicesLineList)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {
              imagePositions: _,
              canonical: u
            })
          }
        }
        let tg, rg;
        Er("FillBucket", wf, {
          omit: ["layers", "patternFeatures"]
        });
        var mx = {
          get paint() {
            return rg = rg || new na({
              "fill-antialias": new Xr(Q.paint_fill["fill-antialias"]),
              "fill-opacity": new hn(Q.paint_fill["fill-opacity"]),
              "fill-color": new hn(Q.paint_fill["fill-color"]),
              "fill-outline-color": new hn(Q.paint_fill["fill-outline-color"]),
              "fill-translate": new Xr(Q.paint_fill["fill-translate"]),
              "fill-translate-anchor": new Xr(Q.paint_fill["fill-translate-anchor"]),
              "fill-pattern": new al(Q.paint_fill["fill-pattern"])
            })
          },
          get layout() {
            return tg = tg || new na({
              "fill-sort-key": new hn(Q.layout_fill["fill-sort-key"])
            })
          }
        };
        class gx extends Za {
          constructor(t, n) {
            super(t, mx, n)
          }
          recalculate(t, n) {
            super.recalculate(t, n);
            const o = this.paint._values["fill-outline-color"];
            o.value.kind === "constant" && o.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
          }
          createBucket(t) {
            return new wf(t)
          }
          queryRadius() {
            return Od(this.paint.get("fill-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            geometry: n,
            transform: o,
            pixelsToTileUnits: u
          }) {
            return Dm(qd(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -o.bearingInRadians, u), n)
          }
          isTileClipped() {
            return !0
          }
        }
        const vx = wi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_normal_ed",
            components: 4,
            type: "Int16"
          }], 4),
          yx = wi([{
            name: "a_centroid",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: xx
          } = vx;
        class dc {
          constructor(t, n, o, u, _) {
            this.properties = {}, this.extent = o, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = u, this._values = _, t.readFields(bx, this, n)
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos,
              o = [];
            let u, _ = 1,
              m = 0,
              y = 0,
              b = 0;
            for (; t.pos < n;) {
              if (m <= 0) {
                const M = t.readVarint();
                _ = 7 & M, m = M >> 3
              }
              if (m--, _ === 1 || _ === 2) y += t.readSVarint(), b += t.readSVarint(), _ === 1 && (u && o.push(u), u = []), u && u.push(new j(y, b));
              else {
                if (_ !== 7) throw new Error(`unknown command ${_}`);
                u && u.push(u[0].clone())
              }
            }
            return u && o.push(u), o
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos;
            let o = 1,
              u = 0,
              _ = 0,
              m = 0,
              y = 1 / 0,
              b = -1 / 0,
              M = 1 / 0,
              I = -1 / 0;
            for (; t.pos < n;) {
              if (u <= 0) {
                const D = t.readVarint();
                o = 7 & D, u = D >> 3
              }
              if (u--, o === 1 || o === 2) _ += t.readSVarint(), m += t.readSVarint(), _ < y && (y = _), _ > b && (b = _), m < M && (M = m), m > I && (I = m);
              else if (o !== 7) throw new Error(`unknown command ${o}`)
            }
            return [y, M, b, I]
          }
          toGeoJSON(t, n, o) {
            const u = this.extent * Math.pow(2, o),
              _ = this.extent * t,
              m = this.extent * n,
              y = this.loadGeometry();

            function b(B) {
              return [360 * (B.x + _) / u - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (B.y + m) / u) * Math.PI)) - 90]
            }

            function M(B) {
              return B.map(b)
            }
            let I;
            if (this.type === 1) {
              const B = [];
              for (const H of y) B.push(H[0]);
              const V = M(B);
              I = B.length === 1 ? {
                type: "Point",
                coordinates: V[0]
              } : {
                type: "MultiPoint",
                coordinates: V
              }
            } else if (this.type === 2) {
              const B = y.map(M);
              I = B.length === 1 ? {
                type: "LineString",
                coordinates: B[0]
              } : {
                type: "MultiLineString",
                coordinates: B
              }
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const B = (function(H) {
                    const K = H.length;
                    if (K <= 1) return [H];
                    const re = [];
                    let pe, Ne;
                    for (let be = 0; be < K; be++) {
                      const Ae = wx(H[be]);
                      Ae !== 0 && (Ne === void 0 && (Ne = Ae < 0), Ne === Ae < 0 ? (pe && re.push(pe), pe = [H[be]]) : pe && pe.push(H[be]))
                    }
                    return pe && re.push(pe), re
                  })(y),
                  V = [];
                for (const H of B) V.push(H.map(M));
                I = V.length === 1 ? {
                  type: "Polygon",
                  coordinates: V[0]
                } : {
                  type: "MultiPolygon",
                  coordinates: V
                }
              }
            }
            const D = {
              type: "Feature",
              geometry: I,
              properties: this.properties
            };
            return this.id != null && (D.id = this.id), D
          }
        }

        function bx(i, t, n) {
          i === 1 ? t.id = n.readVarint() : i === 2 ? (function(o, u) {
            const _ = o.readVarint() + o.pos;
            for (; o.pos < _;) {
              const m = u._keys[o.readVarint()],
                y = u._values[o.readVarint()];
              u.properties[m] = y
            }
          })(n, t) : i === 3 ? t.type = n.readVarint() : i === 4 && (t._geometry = n.pos)
        }

        function wx(i) {
          let t = 0;
          for (let n, o, u = 0, _ = i.length, m = _ - 1; u < _; m = u++) n = i[u], o = i[m], t += (o.x - n.x) * (n.y + o.y);
          return t
        }
        dc.types = ["Unknown", "Point", "LineString", "Polygon"];
        class ng {
          constructor(t, n) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(kx, this, n), this.length = this._features.length
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const n = this._pbf.readVarint() + this._pbf.pos;
            return new dc(this._pbf, n, this.extent, this._keys, this._values)
          }
        }

        function kx(i, t, n) {
          i === 15 ? t.version = n.readVarint() : i === 1 ? t.name = n.readString() : i === 5 ? t.extent = n.readVarint() : i === 2 ? t._features.push(n.pos) : i === 3 ? t._keys.push(n.readString()) : i === 4 && t._values.push((function(o) {
            let u = null;
            const _ = o.readVarint() + o.pos;
            for (; o.pos < _;) {
              const m = o.readVarint() >> 3;
              u = m === 1 ? o.readString() : m === 2 ? o.readFloat() : m === 3 ? o.readDouble() : m === 4 ? o.readVarint64() : m === 5 ? o.readVarint() : m === 6 ? o.readSVarint() : m === 7 ? o.readBoolean() : null
            }
            if (u == null) throw new Error("unknown feature value");
            return u
          })(n))
        }
        class ig {
          constructor(t, n) {
            this.layers = t.readFields(Tx, {}, n)
          }
        }

        function Tx(i, t, n) {
          if (i === 3) {
            const o = new ng(n, n.readVarint() + n.pos);
            o.length && (t[o.name] = o)
          }
        }
        const kf = Math.pow(2, 13);

        function Nu(i, t, n, o, u, _, m, y) {
          i.emplaceBack(t, n, 2 * Math.floor(o * kf) + m, u * kf * 2, _ * kf * 2, Math.round(y))
        }
        class Tf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n => n.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new Te, this.centroidVertexArray = new me, this.indexArray = new Nt, this.programConfigurations = new os(t.layers, t.zoom), this.segments = new zn, this.stateDependentLayerIds = this.layers.filter((n => n.isStateDependent())).map((n => n.id))
          }
          populate(t, n, o) {
            this.features = [], this.hasDependencies = Nd("fill-extrusion", this.layers, n);
            for (const {
                feature: u,
                id: _,
                index: m,
                sourceLayerIndex: y
              }
              of t) {
              const b = this.layers[0]._featureFilter.needGeometry,
                M = Ro(u, b);
              if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), M, o)) continue;
              const I = {
                id: _,
                sourceLayerIndex: y,
                index: m,
                geometry: b ? M.geometry : bo(u),
                properties: u.properties,
                type: u.type,
                patterns: {}
              };
              this.hasDependencies ? this.features.push(yf("fill-extrusion", this.layers, I, {
                zoom: this.zoom
              }, n)) : this.addFeature(I, I.geometry, m, o, {}, n.subdivisionGranularity), n.featureIndex.insert(u, I.geometry, m, y, this.index, !0)
            }
          }
          addFeatures(t, n, o) {
            for (const u of this.features) {
              const {
                geometry: _
              } = u;
              this.addFeature(u, _, u.index, n, o, t.subdivisionGranularity)
            }
          }
          update(t, n, o) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, {
              imagePositions: o
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, xx), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, yx.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy())
          }
          addFeature(t, n, o, u, _, m) {
            for (const y of zl(n, 500)) {
              const b = {
                  x: 0,
                  y: 0,
                  sampleCount: 0
                },
                M = this.layoutVertexArray.length;
              this.processPolygon(b, u, t, y, m);
              const I = this.layoutVertexArray.length - M,
                D = Math.floor(b.x / b.sampleCount),
                B = Math.floor(b.y / b.sampleCount);
              for (let V = 0; V < I; V++) this.centroidVertexArray.emplaceBack(D, B)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {
              imagePositions: _,
              canonical: u
            })
          }
          processPolygon(t, n, o, u, _) {
            if (u.length < 1 || ag(u[0])) return;
            for (const D of u) D.length !== 0 && Px(t, D);
            const m = {
                segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
              },
              y = _.fill.getGranularityForZoomLevel(n.z),
              b = dc.types[o.type] === "Polygon";
            for (const D of u) {
              if (D.length === 0 || ag(D)) continue;
              const B = ul(D, y, b);
              this._generateSideFaces(B, m)
            }
            if (!b) return;
            const M = Qm(u, n, y, !1),
              I = this.layoutVertexArray;
            eg(((D, B) => {
              Nu(I, D, B, 0, 0, 1, 1, 0)
            }), this.segments, this.layoutVertexArray, this.indexArray, M.verticesFlattened, M.indicesTriangles)
          }
          _generateSideFaces(t, n) {
            let o = 0;
            for (let u = 1; u < t.length; u++) {
              const _ = t[u],
                m = t[u - 1];
              if (Sx(_, m)) continue;
              n.segment.vertexLength + 4 > zn.MAX_VERTEX_ARRAY_LENGTH && (n.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const y = _.sub(m)._perp()._unit(),
                b = m.dist(_);
              o + b > 32768 && (o = 0), Nu(this.layoutVertexArray, _.x, _.y, y.x, y.y, 0, 0, o), Nu(this.layoutVertexArray, _.x, _.y, y.x, y.y, 0, 1, o), o += b, Nu(this.layoutVertexArray, m.x, m.y, y.x, y.y, 0, 0, o), Nu(this.layoutVertexArray, m.x, m.y, y.x, y.y, 0, 1, o);
              const M = n.segment.vertexLength;
              this.indexArray.emplaceBack(M, M + 2, M + 1), this.indexArray.emplaceBack(M + 1, M + 2, M + 3), n.segment.vertexLength += 4, n.segment.primitiveLength += 2
            }
          }
        }

        function Px(i, t) {
          for (let n = 0; n < t.length; n++) {
            const o = t[n];
            n === t.length - 1 && t[0].x === o.x && t[0].y === o.y || (i.x += o.x, i.y += o.y, i.sampleCount++)
          }
        }

        function Sx(i, t) {
          return i.x === t.x && (i.x < 0 || i.x > ct) || i.y === t.y && (i.y < 0 || i.y > ct)
        }

        function ag(i) {
          return i.every((t => t.x < 0)) || i.every((t => t.x > ct)) || i.every((t => t.y < 0)) || i.every((t => t.y > ct))
        }
        let og;
        Er("FillExtrusionBucket", Tf, {
          omit: ["layers", "features"]
        });
        var Mx = {
          get paint() {
            return og = og || new na({
              "fill-extrusion-opacity": new Xr(Q["paint_fill-extrusion"]["fill-extrusion-opacity"]),
              "fill-extrusion-color": new hn(Q["paint_fill-extrusion"]["fill-extrusion-color"]),
              "fill-extrusion-translate": new Xr(Q["paint_fill-extrusion"]["fill-extrusion-translate"]),
              "fill-extrusion-translate-anchor": new Xr(Q["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
              "fill-extrusion-pattern": new al(Q["paint_fill-extrusion"]["fill-extrusion-pattern"]),
              "fill-extrusion-height": new hn(Q["paint_fill-extrusion"]["fill-extrusion-height"]),
              "fill-extrusion-base": new hn(Q["paint_fill-extrusion"]["fill-extrusion-base"]),
              "fill-extrusion-vertical-gradient": new Xr(Q["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
            })
          }
        };
        class Ix extends Za {
          constructor(t, n) {
            super(t, Mx, n)
          }
          createBucket(t) {
            return new Tf(t)
          }
          queryRadius() {
            return Od(this.paint.get("fill-extrusion-translate"))
          }
          is3D() {
            return !0
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: n,
            featureState: o,
            geometry: u,
            transform: _,
            pixelsToTileUnits: m,
            pixelPosMatrix: y
          }) {
            const b = qd(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -_.bearingInRadians, m),
              M = this.paint.get("fill-extrusion-height").evaluate(n, o),
              I = this.paint.get("fill-extrusion-base").evaluate(n, o),
              D = (function(V, H) {
                const K = [];
                for (const re of V) {
                  const pe = [re.x, re.y, 0, 1];
                  Ke(pe, pe, H), K.push(new j(pe[0] / pe[3], pe[1] / pe[3]))
                }
                return K
              })(b, y),
              B = (function(V, H, K, re) {
                const pe = [],
                  Ne = [],
                  be = re[8] * H,
                  Ae = re[9] * H,
                  ot = re[10] * H,
                  gt = re[11] * H,
                  er = re[8] * K,
                  Pr = re[9] * K,
                  _r = re[10] * K,
                  wr = re[11] * K;
                for (const Jr of V) {
                  const xr = [],
                    kr = [];
                  for (const jt of Jr) {
                    const mn = jt.x,
                      xn = jt.y,
                      cn = re[0] * mn + re[4] * xn + re[12],
                      Hr = re[1] * mn + re[5] * xn + re[13],
                      Bn = re[2] * mn + re[6] * xn + re[14],
                      yi = re[3] * mn + re[7] * xn + re[15],
                      Ri = Bn + ot,
                      aa = yi + gt,
                      Wa = cn + er,
                      Pa = Hr + Pr,
                      Ki = Bn + _r,
                      mi = yi + wr,
                      Vi = new j((cn + be) / aa, (Hr + Ae) / aa);
                    Vi.z = Ri / aa, xr.push(Vi);
                    const Ji = new j(Wa / mi, Pa / mi);
                    Ji.z = Ki / mi, kr.push(Ji)
                  }
                  pe.push(xr), Ne.push(kr)
                }
                return [pe, Ne]
              })(u, I, M, y);
            return (function(V, H, K) {
              let re = 1 / 0;
              Dm(K, H) && (re = sg(K, H[0]));
              for (let pe = 0; pe < H.length; pe++) {
                const Ne = H[pe],
                  be = V[pe];
                for (let Ae = 0; Ae < Ne.length - 1; Ae++) {
                  const ot = Ne[Ae],
                    gt = [ot, Ne[Ae + 1], be[Ae + 1], be[Ae], ot];
                  Lm(K, gt) && (re = Math.min(re, sg(K, gt)))
                }
              }
              return re !== 1 / 0 && re
            })(B[0], B[1], D)
          }
        }

        function Vu(i, t) {
          return i.x * t.x + i.y * t.y
        }

        function sg(i, t) {
          if (i.length === 1) {
            let n = 0;
            const o = t[n++];
            let u;
            for (; !u || o.equals(u);)
              if (u = t[n++], !u) return 1 / 0;
            for (; n < t.length; n++) {
              const _ = t[n],
                m = i[0],
                y = u.sub(o),
                b = _.sub(o),
                M = m.sub(o),
                I = Vu(y, y),
                D = Vu(y, b),
                B = Vu(b, b),
                V = Vu(M, y),
                H = Vu(M, b),
                K = I * B - D * D,
                re = (B * V - D * H) / K,
                pe = (I * H - D * V) / K,
                Ne = o.z * (1 - re - pe) + u.z * re + _.z * pe;
              if (isFinite(Ne)) return Ne
            }
            return 1 / 0
          } {
            let n = 1 / 0;
            for (const o of t) n = Math.min(n, o.z);
            return n
          }
        }
        const Cx = wi([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
          }], 4),
          {
            members: Ax
          } = Cx,
          zx = wi([{
            name: "a_uv_x",
            components: 1,
            type: "Float32"
          }, {
            name: "a_split_index",
            components: 1,
            type: "Float32"
          }]),
          {
            members: Ex
          } = zx,
          Lx = Math.cos(Math.PI / 180 * 37.5),
          lg = Math.pow(2, 14) / .5;
        class Pf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n => n.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((n => {
              this.gradients[n.id] = {}
            })), this.layoutVertexArray = new Ee, this.layoutVertexArray2 = new ye, this.indexArray = new Nt, this.programConfigurations = new os(t.layers, t.zoom), this.segments = new zn, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((n => n.isStateDependent())).map((n => n.id))
          }
          populate(t, n, o) {
            this.hasDependencies = Nd("line", this.layers, n) || this.hasLineDasharray(this.layers);
            const u = this.layers[0].layout.get("line-sort-key"),
              _ = !u.isConstant(),
              m = [];
            for (const {
                feature: y,
                id: b,
                index: M,
                sourceLayerIndex: I
              }
              of t) {
              const D = this.layers[0]._featureFilter.needGeometry,
                B = Ro(y, D);
              if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), B, o)) continue;
              const V = _ ? u.evaluate(B, {}, o) : void 0,
                H = {
                  id: b,
                  properties: y.properties,
                  type: y.type,
                  sourceLayerIndex: I,
                  index: M,
                  geometry: D ? B.geometry : bo(y),
                  patterns: {},
                  dashes: {},
                  sortKey: V
                };
              m.push(H)
            }
            _ && m.sort(((y, b) => y.sortKey - b.sortKey));
            for (const y of m) {
              const {
                geometry: b,
                index: M,
                sourceLayerIndex: I
              } = y;
              this.hasDependencies ? (Nd("line", this.layers, n) ? yf("line", this.layers, y, {
                zoom: this.zoom
              }, n) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, y, this.zoom, n), this.patternFeatures.push(y)) : this.addFeature(y, b, M, o, {}, {}, n.subdivisionGranularity), n.featureIndex.insert(t[M].feature, b, M, I, this.index)
            }
          }
          update(t, n, o, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, {
              imagePositions: o,
              dashPositions: u
            })
          }
          addFeatures(t, n, o, u) {
            for (const _ of this.patternFeatures) this.addFeature(_, _.geometry, _.index, n, o, u, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Ex)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ax), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return {
              start: +t.properties.mapbox_clip_start,
              end: +t.properties.mapbox_clip_end
            }
          }
          addFeature(t, n, o, u, _, m, y) {
            const b = this.layers[0].layout,
              M = b.get("line-join").evaluate(t, {}),
              I = b.get("line-cap"),
              D = b.get("line-miter-limit"),
              B = b.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const V of n) this.addLine(V, t, M, I, D, B, u, y);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {
              imagePositions: _,
              dashPositions: m,
              canonical: u
            })
          }
          addLine(t, n, o, u, _, m, y, b) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = ul(t, y ? b.line.getGranularityForZoomLevel(y.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let be = 0; be < t.length - 1; be++) this.totalDistance += t[be].dist(t[be + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
            }
            const M = dc.types[n.type] === "Polygon";
            let I = t.length;
            for (; I >= 2 && t[I - 1].equals(t[I - 2]);) I--;
            let D = 0;
            for (; D < I - 1 && t[D].equals(t[D + 1]);) D++;
            if (I < (M ? 3 : 2)) return;
            o === "bevel" && (_ = 1.05);
            const B = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
              V = this.segments.prepareSegment(10 * I, this.layoutVertexArray, this.indexArray);
            let H, K, re, pe, Ne;
            this.e1 = this.e2 = -1, M && (H = t[I - 2], Ne = t[D].sub(H)._unit()._perp());
            for (let be = D; be < I; be++) {
              if (re = be === I - 1 ? M ? t[D + 1] : void 0 : t[be + 1], re && t[be].equals(re)) continue;
              Ne && (pe = Ne), H && (K = H), H = t[be], Ne = re ? re.sub(H)._unit()._perp() : pe, pe = pe || Ne;
              let Ae = pe.add(Ne);
              Ae.x === 0 && Ae.y === 0 || Ae._unit();
              const ot = pe.x * Ne.x + pe.y * Ne.y,
                gt = Ae.x * Ne.x + Ae.y * Ne.y,
                er = gt !== 0 ? 1 / gt : 1 / 0,
                Pr = 2 * Math.sqrt(2 - 2 * gt),
                _r = gt < Lx && K && re,
                wr = pe.x * Ne.y - pe.y * Ne.x > 0;
              if (_r && be > D) {
                const kr = H.dist(K);
                if (kr > 2 * B) {
                  const jt = H.sub(H.sub(K)._mult(B / kr)._round());
                  this.updateDistance(K, jt), this.addCurrentVertex(jt, pe, 0, 0, V), K = jt
                }
              }
              const Jr = K && re;
              let xr = Jr ? o : M ? "butt" : u;
              if (Jr && xr === "round" && (er < m ? xr = "miter" : er <= 2 && (xr = "fakeround")), xr === "miter" && er > _ && (xr = "bevel"), xr === "bevel" && (er > 2 && (xr = "flipbevel"), er < _ && (xr = "miter")), K && this.updateDistance(K, H), xr === "miter") Ae._mult(er), this.addCurrentVertex(H, Ae, 0, 0, V);
              else if (xr === "flipbevel") {
                if (er > 100) Ae = Ne.mult(-1);
                else {
                  const kr = er * pe.add(Ne).mag() / pe.sub(Ne).mag();
                  Ae._perp()._mult(kr * (wr ? -1 : 1))
                }
                this.addCurrentVertex(H, Ae, 0, 0, V), this.addCurrentVertex(H, Ae.mult(-1), 0, 0, V)
              } else if (xr === "bevel" || xr === "fakeround") {
                const kr = -Math.sqrt(er * er - 1),
                  jt = wr ? kr : 0,
                  mn = wr ? 0 : kr;
                if (K && this.addCurrentVertex(H, pe, jt, mn, V), xr === "fakeround") {
                  const xn = Math.round(180 * Pr / Math.PI / 20);
                  for (let cn = 1; cn < xn; cn++) {
                    let Hr = cn / xn;
                    if (Hr !== .5) {
                      const yi = Hr - .5;
                      Hr += Hr * yi * (Hr - 1) * ((1.0904 + ot * (ot * (3.55645 - 1.43519 * ot) - 3.2452)) * yi * yi + (.848013 + ot * (.215638 * ot - 1.06021)))
                    }
                    const Bn = Ne.sub(pe)._mult(Hr)._add(pe)._unit()._mult(wr ? -1 : 1);
                    this.addHalfVertex(H, Bn.x, Bn.y, !1, wr, 0, V)
                  }
                }
                re && this.addCurrentVertex(H, Ne, -jt, -mn, V)
              } else if (xr === "butt") this.addCurrentVertex(H, Ae, 0, 0, V);
              else if (xr === "square") {
                const kr = K ? 1 : -1;
                this.addCurrentVertex(H, Ae, kr, kr, V)
              } else xr === "round" && (K && (this.addCurrentVertex(H, pe, 0, 0, V), this.addCurrentVertex(H, pe, 1, 1, V, !0)), re && (this.addCurrentVertex(H, Ne, -1, -1, V, !0), this.addCurrentVertex(H, Ne, 0, 0, V)));
              if (_r && be < I - 1) {
                const kr = H.dist(re);
                if (kr > 2 * B) {
                  const jt = H.add(re.sub(H)._mult(B / kr)._round());
                  this.updateDistance(H, jt), this.addCurrentVertex(jt, Ne, 0, 0, V), H = jt
                }
              }
            }
          }
          addCurrentVertex(t, n, o, u, _, m = !1) {
            const y = n.y * u - n.x,
              b = -n.y - n.x * u;
            this.addHalfVertex(t, n.x + n.y * o, n.y - n.x * o, m, !1, o, _), this.addHalfVertex(t, y, b, m, !0, -u, _), this.distance > lg / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, n, o, u, _, m))
          }
          addHalfVertex({
            x: t,
            y: n
          }, o, u, _, m, y, b) {
            const M = .5 * (this.lineClips ? this.scaledDistance * (lg - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (_ ? 1 : 0), (n << 1) + (m ? 1 : 0), Math.round(63 * o) + 128, Math.round(63 * u) + 128, 1 + (y === 0 ? 0 : y < 0 ? -1 : 1) | (63 & M) << 2, M >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const I = b.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, I, this.e2), b.primitiveLength++), m ? this.e2 = I : this.e1 = I
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
          }
          updateDistance(t, n) {
            this.distance += t.dist(n), this.updateScaledDistance()
          }
          hasLineDasharray(t) {
            for (const n of t) {
              const o = n.paint.get("line-dasharray");
              if (o && !o.isConstant()) return !0
            }
            return !1
          }
          addLineDashDependencies(t, n, o, u) {
            for (const _ of t) {
              const m = _.paint.get("line-dasharray");
              if (!m || m.value.kind === "constant") continue;
              const y = _.layout.get("line-cap") === "round",
                b = {
                  dasharray: m.value.evaluate({
                    zoom: o - 1
                  }, n, {}),
                  round: y
                },
                M = {
                  dasharray: m.value.evaluate({
                    zoom: o
                  }, n, {}),
                  round: y
                },
                I = {
                  dasharray: m.value.evaluate({
                    zoom: o + 1
                  }, n, {}),
                  round: y
                },
                D = `${b.dasharray.join(",")},${b.round}`,
                B = `${M.dasharray.join(",")},${M.round}`,
                V = `${I.dasharray.join(",")},${I.round}`;
              u.dashDependencies[D] = b, u.dashDependencies[B] = M, u.dashDependencies[V] = I, n.dashes[_.id] = {
                min: D,
                mid: B,
                max: V
              }
            }
          }
        }
        let cg, ug;
        Er("LineBucket", Pf, {
          omit: ["layers", "patternFeatures"]
        });
        var hg = {
          get paint() {
            return ug = ug || new na({
              "line-opacity": new hn(Q.paint_line["line-opacity"]),
              "line-color": new hn(Q.paint_line["line-color"]),
              "line-translate": new Xr(Q.paint_line["line-translate"]),
              "line-translate-anchor": new Xr(Q.paint_line["line-translate-anchor"]),
              "line-width": new hn(Q.paint_line["line-width"]),
              "line-gap-width": new hn(Q.paint_line["line-gap-width"]),
              "line-offset": new hn(Q.paint_line["line-offset"]),
              "line-blur": new hn(Q.paint_line["line-blur"]),
              "line-dasharray": new al(Q.paint_line["line-dasharray"]),
              "line-pattern": new al(Q.paint_line["line-pattern"]),
              "line-gradient": new ol(Q.paint_line["line-gradient"])
            })
          },
          get layout() {
            return cg = cg || new na({
              "line-cap": new Xr(Q.layout_line["line-cap"]),
              "line-join": new hn(Q.layout_line["line-join"]),
              "line-miter-limit": new Xr(Q.layout_line["line-miter-limit"]),
              "line-round-limit": new Xr(Q.layout_line["line-round-limit"]),
              "line-sort-key": new hn(Q.layout_line["line-sort-key"])
            })
          }
        };
        class Dx extends hn {
          possiblyEvaluate(t, n) {
            return n = new Qn(Math.floor(n.zoom), {
              now: n.now,
              fadeDuration: n.fadeDuration,
              zoomHistory: n.zoomHistory,
              transition: n.transition
            }), super.possiblyEvaluate(t, n)
          }
          evaluate(t, n, o, u) {
            return n = it({}, n, {
              zoom: Math.floor(n.zoom)
            }), super.evaluate(t, n, o, u)
          }
        }
        let Gd;
        class Rx extends Za {
          constructor(t, n) {
            super(t, hg, n), this.gradientVersion = 0, Gd || (Gd = new Dx(hg.paint.properties["line-width"].specification), Gd.useIntegerZoom = !0)
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const n = this.gradientExpression();
              this.stepInterpolant = !!(function(o) {
                return o._styleExpression !== void 0
              })(n) && n._styleExpression.expression instanceof ui, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression
          }
          recalculate(t, n) {
            super.recalculate(t, n), this.paint._values["line-floorwidth"] = Gd.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
          }
          createBucket(t) {
            return new Pf(t)
          }
          queryRadius(t) {
            const n = t,
              o = dg(lc("line-width", this, n), lc("line-gap-width", this, n)),
              u = lc("line-offset", this, n);
            return o / 2 + Math.abs(u) + Od(this.paint.get("line-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: n,
            featureState: o,
            geometry: u,
            transform: _,
            pixelsToTileUnits: m
          }) {
            const y = qd(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -_.bearingInRadians, m),
              b = m / 2 * dg(this.paint.get("line-width").evaluate(n, o), this.paint.get("line-gap-width").evaluate(n, o)),
              M = this.paint.get("line-offset").evaluate(n, o);
            return M && (u = (function(I, D) {
              const B = [];
              for (let V = 0; V < I.length; V++) {
                const H = I[V],
                  K = [];
                for (let re = 0; re < H.length; re++) {
                  const pe = H[re - 1],
                    Ne = H[re],
                    be = H[re + 1],
                    Ae = re === 0 ? new j(0, 0) : Ne.sub(pe)._unit()._perp(),
                    ot = re === H.length - 1 ? new j(0, 0) : be.sub(Ne)._unit()._perp(),
                    gt = Ae._add(ot)._unit(),
                    er = gt.x * ot.x + gt.y * ot.y;
                  er !== 0 && gt._mult(1 / er), K.push(gt._mult(D)._add(Ne))
                }
                B.push(K)
              }
              return B
            })(u, M * m)), (function(I, D, B) {
              for (let V = 0; V < D.length; V++) {
                const H = D[V];
                if (I.length >= 3) {
                  for (let K = 0; K < H.length; K++)
                    if (sc(I, H[K])) return !0
                }
                if (Vy(I, H, B)) return !0
              }
              return !1
            })(y, u, b)
          }
          isTileClipped() {
            return !0
          }
        }

        function dg(i, t) {
          return t > 0 ? t + 2 * i : i
        }
        const jx = wi([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
          }], 4),
          Fx = wi([{
            name: "a_projected_pos",
            components: 3,
            type: "Float32"
          }], 4);
        wi([{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint32"
        }], 4);
        const Bx = wi([{
          name: "a_placed",
          components: 2,
          type: "Uint8"
        }, {
          name: "a_shift",
          components: 2,
          type: "Float32"
        }, {
          name: "a_box_real",
          components: 2,
          type: "Int16"
        }]);
        wi([{
          type: "Int16",
          name: "anchorPointX"
        }, {
          type: "Int16",
          name: "anchorPointY"
        }, {
          type: "Int16",
          name: "x1"
        }, {
          type: "Int16",
          name: "y1"
        }, {
          type: "Int16",
          name: "x2"
        }, {
          type: "Int16",
          name: "y2"
        }, {
          type: "Uint32",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "sourceLayerIndex"
        }, {
          type: "Uint16",
          name: "bucketIndex"
        }]);
        const pg = wi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
          }], 4),
          Ox = wi([{
            name: "a_pos",
            components: 2,
            type: "Float32"
          }, {
            name: "a_radius",
            components: 1,
            type: "Float32"
          }, {
            name: "a_flags",
            components: 2,
            type: "Int16"
          }], 4);

        function qx(i, t, n) {
          return i.sections.forEach((o => {
            o.text = (function(u, _, m) {
              const y = _.layout.get("text-transform").evaluate(m, {});
              return y === "uppercase" ? u = u.toLocaleUpperCase() : y === "lowercase" && (u = u.toLocaleLowerCase()), go.applyArabicShaping && (u = go.applyArabicShaping(u)), u
            })(o.text, t, n)
          })), i
        }
        wi([{
          name: "triangle",
          components: 3,
          type: "Uint16"
        }]), wi([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Uint16",
          name: "glyphStartIndex"
        }, {
          type: "Uint16",
          name: "numGlyphs"
        }, {
          type: "Uint32",
          name: "vertexStartIndex"
        }, {
          type: "Uint32",
          name: "lineStartIndex"
        }, {
          type: "Uint32",
          name: "lineLength"
        }, {
          type: "Uint16",
          name: "segment"
        }, {
          type: "Uint16",
          name: "lowerSize"
        }, {
          type: "Uint16",
          name: "upperSize"
        }, {
          type: "Float32",
          name: "lineOffsetX"
        }, {
          type: "Float32",
          name: "lineOffsetY"
        }, {
          type: "Uint8",
          name: "writingMode"
        }, {
          type: "Uint8",
          name: "placedOrientation"
        }, {
          type: "Uint8",
          name: "hidden"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Int16",
          name: "associatedIconIndex"
        }]), wi([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Int16",
          name: "rightJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "centerJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "leftJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "placedIconSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedIconSymbolIndex"
        }, {
          type: "Uint16",
          name: "key"
        }, {
          type: "Uint16",
          name: "textBoxStartIndex"
        }, {
          type: "Uint16",
          name: "textBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxEndIndex"
        }, {
          type: "Uint16",
          name: "iconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "iconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "numHorizontalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numVerticalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numIconVertices"
        }, {
          type: "Uint16",
          name: "numVerticalIconVertices"
        }, {
          type: "Uint16",
          name: "useRuntimeCollisionCircles"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Float32",
          name: "textBoxScale"
        }, {
          type: "Float32",
          name: "collisionCircleDiameter"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetStartIndex"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetEndIndex"
        }]), wi([{
          type: "Float32",
          name: "offsetX"
        }]), wi([{
          type: "Int16",
          name: "x"
        }, {
          type: "Int16",
          name: "y"
        }, {
          type: "Int16",
          name: "tileUnitDistanceFromAnchor"
        }]), wi([{
          type: "Uint16",
          name: "textAnchor"
        }, {
          type: "Float32",
          components: 2,
          name: "textOffset"
        }]);
        const Uu = {
          "!": "ï¸•",
          "#": "ï¼ƒ",
          $: "ï¼„",
          "%": "ï¼…",
          "&": "ï¼†",
          "(": "ï¸µ",
          ")": "ï¸¶",
          "*": "ï¼Š",
          "+": "ï¼‹",
          ",": "ï¸",
          "-": "ï¸²",
          ".": "ãƒ»",
          "/": "ï¼",
          ":": "ï¸“",
          ";": "ï¸”",
          "<": "ï¸¿",
          "=": "ï¼",
          ">": "ï¹€",
          "?": "ï¸–",
          "@": "ï¼ ",
          "[": "ï¹‡",
          "\\": "ï¼¼",
          "]": "ï¹ˆ",
          "^": "ï¼¾",
          _: "ï¸³",
          "`": "ï½€",
          "{": "ï¸·",
          "|": "â€•",
          "}": "ï¸¸",
          "~": "ï½",
          "Â¢": "ï¿ ",
          "Â£": "ï¿¡",
          "Â¥": "ï¿¥",
          "Â¦": "ï¿¤",
          "Â¬": "ï¿¢",
          "Â¯": "ï¿£",
          "â€“": "ï¸²",
          "â€”": "ï¸±",
          "â€˜": "ï¹ƒ",
          "â€™": "ï¹„",
          "â€œ": "ï¹",
          "â€": "ï¹‚",
          "â€¦": "ï¸™",
          "â€§": "ãƒ»",
          "â‚©": "ï¿¦",
          "ã€": "ï¸‘",
          "ã€‚": "ï¸’",
          "ã€ˆ": "ï¸¿",
          "ã€‰": "ï¹€",
          "ã€Š": "ï¸½",
          "ã€‹": "ï¸¾",
          "ã€Œ": "ï¹",
          "ã€": "ï¹‚",
          "ã€": "ï¹ƒ",
          "ã€": "ï¹„",
          "ã€": "ï¸»",
          "ã€‘": "ï¸¼",
          "ã€”": "ï¸¹",
          "ã€•": "ï¸º",
          "ã€–": "ï¸—",
          "ã€—": "ï¸˜",
          "ï¼": "ï¸•",
          "ï¼ˆ": "ï¸µ",
          "ï¼‰": "ï¸¶",
          "ï¼Œ": "ï¸",
          "ï¼": "ï¸²",
          "ï¼": "ãƒ»",
          "ï¼š": "ï¸“",
          "ï¼›": "ï¸”",
          "ï¼œ": "ï¸¿",
          "ï¼": "ï¹€",
          "ï¼Ÿ": "ï¸–",
          "ï¼»": "ï¹‡",
          "ï¼½": "ï¹ˆ",
          "ï¼¿": "ï¸³",
          "ï½›": "ï¸·",
          "ï½œ": "â€•",
          "ï½": "ï¸¸",
          "ï½Ÿ": "ï¸µ",
          "ï½ ": "ï¸¶",
          "ï½¡": "ï¸’",
          "ï½¢": "ï¹",
          "ï½£": "ï¹‚"
        };
        var Ni = 24;
        const Sf = 4294967296,
          fg = 1 / Sf,
          _g = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class Mf {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length
          }
          readFields(t, n, o = this.length) {
            for (; this.pos < o;) {
              const u = this.readVarint(),
                _ = u >> 3,
                m = this.pos;
              this.type = 7 & u, t(_, n, this), this.pos === m && this.skip(u)
            }
            return n
          }
          readMessage(t, n) {
            return this.readFields(t, n, this.readVarint() + this.pos)
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, t
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, t
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * Sf;
            return this.pos += 8, t
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * Sf;
            return this.pos += 8, t
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, t
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, t
          }
          readVarint(t) {
            const n = this.buf;
            let o, u;
            return u = n[this.pos++], o = 127 & u, u < 128 ? o : (u = n[this.pos++], o |= (127 & u) << 7, u < 128 ? o : (u = n[this.pos++], o |= (127 & u) << 14, u < 128 ? o : (u = n[this.pos++], o |= (127 & u) << 21, u < 128 ? o : (u = n[this.pos], o |= (15 & u) << 28, (function(_, m, y) {
              const b = y.buf;
              let M, I;
              if (I = b[y.pos++], M = (112 & I) >> 4, I < 128 || (I = b[y.pos++], M |= (127 & I) << 3, I < 128) || (I = b[y.pos++], M |= (127 & I) << 10, I < 128) || (I = b[y.pos++], M |= (127 & I) << 17, I < 128) || (I = b[y.pos++], M |= (127 & I) << 24, I < 128) || (I = b[y.pos++], M |= (1 & I) << 31, I < 128)) return pc(_, M, m);
              throw new Error("Expected varint not more than 10 bytes")
            })(o, t, this)))))
          }
          readVarint64() {
            return this.readVarint(!0)
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2
          }
          readBoolean() {
            return !!this.readVarint()
          }
          readString() {
            const t = this.readVarint() + this.pos,
              n = this.pos;
            return this.pos = t, t - n >= 12 && _g ? _g.decode(this.buf.subarray(n, t)) : (function(o, u, _) {
              let m = "",
                y = u;
              for (; y < _;) {
                const b = o[y];
                let M, I, D, B = null,
                  V = b > 239 ? 4 : b > 223 ? 3 : b > 191 ? 2 : 1;
                if (y + V > _) break;
                V === 1 ? b < 128 && (B = b) : V === 2 ? (M = o[y + 1], (192 & M) == 128 && (B = (31 & b) << 6 | 63 & M, B <= 127 && (B = null))) : V === 3 ? (M = o[y + 1], I = o[y + 2], (192 & M) == 128 && (192 & I) == 128 && (B = (15 & b) << 12 | (63 & M) << 6 | 63 & I, (B <= 2047 || B >= 55296 && B <= 57343) && (B = null))) : V === 4 && (M = o[y + 1], I = o[y + 2], D = o[y + 3], (192 & M) == 128 && (192 & I) == 128 && (192 & D) == 128 && (B = (15 & b) << 18 | (63 & M) << 12 | (63 & I) << 6 | 63 & D, (B <= 65535 || B >= 1114112) && (B = null))), B === null ? (B = 65533, V = 1) : B > 65535 && (B -= 65536, m += String.fromCharCode(B >>> 10 & 1023 | 55296), B = 56320 | 1023 & B), m += String.fromCharCode(B), y += V
              }
              return m
            })(this.buf, n, t)
          }
          readBytes() {
            const t = this.readVarint() + this.pos,
              n = this.buf.subarray(this.pos, t);
            return this.pos = t, n
          }
          readPackedVarint(t = [], n) {
            const o = this.readPackedEnd();
            for (; this.pos < o;) t.push(this.readVarint(n));
            return t
          }
          readPackedSVarint(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readSVarint());
            return t
          }
          readPackedBoolean(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readBoolean());
            return t
          }
          readPackedFloat(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readFloat());
            return t
          }
          readPackedDouble(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readDouble());
            return t
          }
          readPackedFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readFixed32());
            return t
          }
          readPackedSFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readSFixed32());
            return t
          }
          readPackedFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readFixed64());
            return t
          }
          readPackedSFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readSFixed64());
            return t
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1
          }
          skip(t) {
            const n = 7 & t;
            if (n === 0)
              for (; this.buf[this.pos++] > 127;);
            else if (n === 2) this.pos = this.readVarint() + this.pos;
            else if (n === 5) this.pos += 4;
            else {
              if (n !== 1) throw new Error(`Unimplemented type: ${n}`);
              this.pos += 8
            }
          }
          writeTag(t, n) {
            this.writeVarint(t << 3 | n)
          }
          realloc(t) {
            let n = this.length || 16;
            for (; n < this.pos + t;) n *= 2;
            if (n !== this.length) {
              const o = new Uint8Array(n);
              o.set(this.buf), this.buf = o, this.dataView = new DataView(o.buffer), this.length = n
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * fg), !0), this.pos += 8
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * fg), !0), this.pos += 8
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(n, o) {
              let u, _;
              if (n >= 0 ? (u = n % 4294967296 | 0, _ = n / 4294967296 | 0) : (u = ~(-n % 4294967296), _ = ~(-n / 4294967296), 4294967295 ^ u ? u = u + 1 | 0 : (u = 0, _ = _ + 1 | 0)), n >= 18446744073709552e3 || n < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              o.realloc(10), (function(m, y, b) {
                b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, b.buf[b.pos] = 127 & (m >>>= 7)
              })(u, 0, o), (function(m, y) {
                const b = (7 & m) << 4;
                y.buf[y.pos++] |= b | ((m >>>= 3) ? 128 : 0), m && (y.buf[y.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (y.buf[y.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (y.buf[y.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (y.buf[y.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (y.buf[y.pos++] = 127 & m)))))
              })(_, o)
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))))
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t)
          }
          writeBoolean(t) {
            this.writeVarint(+t)
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const n = this.pos;
            this.pos = (function(u, _, m) {
              for (let y, b, M = 0; M < _.length; M++) {
                if (y = _.charCodeAt(M), y > 55295 && y < 57344) {
                  if (!b) {
                    y > 56319 || M + 1 === _.length ? (u[m++] = 239, u[m++] = 191, u[m++] = 189) : b = y;
                    continue
                  }
                  if (y < 56320) {
                    u[m++] = 239, u[m++] = 191, u[m++] = 189, b = y;
                    continue
                  }
                  y = b - 55296 << 10 | y - 56320 | 65536, b = null
                } else b && (u[m++] = 239, u[m++] = 191, u[m++] = 189, b = null);
                y < 128 ? u[m++] = y : (y < 2048 ? u[m++] = y >> 6 | 192 : (y < 65536 ? u[m++] = y >> 12 | 224 : (u[m++] = y >> 18 | 240, u[m++] = y >> 12 & 63 | 128), u[m++] = y >> 6 & 63 | 128), u[m++] = 63 & y | 128)
              }
              return m
            })(this.buf, t, this.pos);
            const o = this.pos - n;
            o >= 128 && mg(n, o, this), this.pos = n - 1, this.writeVarint(o), this.pos += o
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8
          }
          writeBytes(t) {
            const n = t.length;
            this.writeVarint(n), this.realloc(n);
            for (let o = 0; o < n; o++) this.buf[this.pos++] = t[o]
          }
          writeRawMessage(t, n) {
            this.pos++;
            const o = this.pos;
            t(n, this);
            const u = this.pos - o;
            u >= 128 && mg(o, u, this), this.pos = o - 1, this.writeVarint(u), this.pos += u
          }
          writeMessage(t, n, o) {
            this.writeTag(t, 2), this.writeRawMessage(n, o)
          }
          writePackedVarint(t, n) {
            n.length && this.writeMessage(t, Nx, n)
          }
          writePackedSVarint(t, n) {
            n.length && this.writeMessage(t, Vx, n)
          }
          writePackedBoolean(t, n) {
            n.length && this.writeMessage(t, Gx, n)
          }
          writePackedFloat(t, n) {
            n.length && this.writeMessage(t, Ux, n)
          }
          writePackedDouble(t, n) {
            n.length && this.writeMessage(t, Zx, n)
          }
          writePackedFixed32(t, n) {
            n.length && this.writeMessage(t, $x, n)
          }
          writePackedSFixed32(t, n) {
            n.length && this.writeMessage(t, Wx, n)
          }
          writePackedFixed64(t, n) {
            n.length && this.writeMessage(t, Hx, n)
          }
          writePackedSFixed64(t, n) {
            n.length && this.writeMessage(t, Xx, n)
          }
          writeBytesField(t, n) {
            this.writeTag(t, 2), this.writeBytes(n)
          }
          writeFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeFixed32(n)
          }
          writeSFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeSFixed32(n)
          }
          writeFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeFixed64(n)
          }
          writeSFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeSFixed64(n)
          }
          writeVarintField(t, n) {
            this.writeTag(t, 0), this.writeVarint(n)
          }
          writeSVarintField(t, n) {
            this.writeTag(t, 0), this.writeSVarint(n)
          }
          writeStringField(t, n) {
            this.writeTag(t, 2), this.writeString(n)
          }
          writeFloatField(t, n) {
            this.writeTag(t, 5), this.writeFloat(n)
          }
          writeDoubleField(t, n) {
            this.writeTag(t, 1), this.writeDouble(n)
          }
          writeBooleanField(t, n) {
            this.writeVarintField(t, +n)
          }
        }

        function pc(i, t, n) {
          return n ? 4294967296 * t + (i >>> 0) : 4294967296 * (t >>> 0) + (i >>> 0)
        }

        function mg(i, t, n) {
          const o = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          n.realloc(o);
          for (let u = n.pos - 1; u >= i; u--) n.buf[u + o] = n.buf[u]
        }

        function Nx(i, t) {
          for (let n = 0; n < i.length; n++) t.writeVarint(i[n])
        }

        function Vx(i, t) {
          for (let n = 0; n < i.length; n++) t.writeSVarint(i[n])
        }

        function Ux(i, t) {
          for (let n = 0; n < i.length; n++) t.writeFloat(i[n])
        }

        function Zx(i, t) {
          for (let n = 0; n < i.length; n++) t.writeDouble(i[n])
        }

        function Gx(i, t) {
          for (let n = 0; n < i.length; n++) t.writeBoolean(i[n])
        }

        function $x(i, t) {
          for (let n = 0; n < i.length; n++) t.writeFixed32(i[n])
        }

        function Wx(i, t) {
          for (let n = 0; n < i.length; n++) t.writeSFixed32(i[n])
        }

        function Hx(i, t) {
          for (let n = 0; n < i.length; n++) t.writeFixed64(i[n])
        }

        function Xx(i, t) {
          for (let n = 0; n < i.length; n++) t.writeSFixed64(i[n])
        }

        function Yx(i, t, n) {
          i === 1 && n.readMessage(Kx, t)
        }

        function Kx(i, t, n) {
          if (i === 3) {
            const {
              id: o,
              bitmap: u,
              width: _,
              height: m,
              left: y,
              top: b,
              advance: M
            } = n.readMessage(Jx, {});
            t.push({
              id: o,
              bitmap: new Du({
                width: _ + 6,
                height: m + 6
              }, u),
              metrics: {
                width: _,
                height: m,
                left: y,
                top: b,
                advance: M
              }
            })
          }
        }

        function Jx(i, t, n) {
          i === 1 ? t.id = n.readVarint() : i === 2 ? t.bitmap = n.readBytes() : i === 3 ? t.width = n.readVarint() : i === 4 ? t.height = n.readVarint() : i === 5 ? t.left = n.readSVarint() : i === 6 ? t.top = n.readSVarint() : i === 7 && (t.advance = n.readVarint())
        }

        function gg(i) {
          let t = 0,
            n = 0;
          for (const m of i) t += m.w * m.h, n = Math.max(n, m.w);
          i.sort(((m, y) => y.h - m.h));
          const o = [{
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(t / .95)), n),
            h: 1 / 0
          }];
          let u = 0,
            _ = 0;
          for (const m of i)
            for (let y = o.length - 1; y >= 0; y--) {
              const b = o[y];
              if (!(m.w > b.w || m.h > b.h)) {
                if (m.x = b.x, m.y = b.y, _ = Math.max(_, m.y + m.h), u = Math.max(u, m.x + m.w), m.w === b.w && m.h === b.h) {
                  const M = o.pop();
                  M && y < o.length && (o[y] = M)
                } else m.h === b.h ? (b.x += m.w, b.w -= m.w) : m.w === b.w ? (b.y += m.h, b.h -= m.h) : (o.push({
                  x: b.x + m.w,
                  y: b.y,
                  w: b.w - m.w,
                  h: m.h
                }), b.y += m.h, b.h -= m.h);
                break
              }
            }
          return {
            w: u,
            h: _,
            fill: t / (u * _) || 0
          }
        }
        class If {
          constructor(t, {
            pixelRatio: n,
            version: o,
            stretchX: u,
            stretchY: _,
            content: m,
            textFitWidth: y,
            textFitHeight: b
          }) {
            this.paddedRect = t, this.pixelRatio = n, this.stretchX = u, this.stretchY = _, this.content = m, this.version = o, this.textFitWidth = y, this.textFitHeight = b
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1]
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
          }
          get tlbr() {
            return this.tl.concat(this.br)
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
          }
        }
        class vg {
          constructor(t, n) {
            const o = {},
              u = {};
            this.haveRenderCallbacks = [];
            const _ = [];
            this.addImages(t, o, _), this.addImages(n, u, _);
            const {
              w: m,
              h: y
            } = gg(_), b = new Ta({
              width: m || 1,
              height: y || 1
            });
            for (const M in t) {
              const I = t[M],
                D = o[M].paddedRect;
              Ta.copy(I.data, b, {
                x: 0,
                y: 0
              }, {
                x: D.x + 1,
                y: D.y + 1
              }, I.data)
            }
            for (const M in n) {
              const I = n[M],
                D = u[M].paddedRect,
                B = D.x + 1,
                V = D.y + 1,
                H = I.data.width,
                K = I.data.height;
              Ta.copy(I.data, b, {
                x: 0,
                y: 0
              }, {
                x: B,
                y: V
              }, I.data), Ta.copy(I.data, b, {
                x: 0,
                y: K - 1
              }, {
                x: B,
                y: V - 1
              }, {
                width: H,
                height: 1
              }), Ta.copy(I.data, b, {
                x: 0,
                y: 0
              }, {
                x: B,
                y: V + K
              }, {
                width: H,
                height: 1
              }), Ta.copy(I.data, b, {
                x: H - 1,
                y: 0
              }, {
                x: B - 1,
                y: V
              }, {
                width: 1,
                height: K
              }), Ta.copy(I.data, b, {
                x: 0,
                y: 0
              }, {
                x: B + H,
                y: V
              }, {
                width: 1,
                height: K
              })
            }
            this.image = b, this.iconPositions = o, this.patternPositions = u
          }
          addImages(t, n, o) {
            for (const u in t) {
              const _ = t[u],
                m = {
                  x: 0,
                  y: 0,
                  w: _.data.width + 2,
                  h: _.data.height + 2
                };
              o.push(m), n[u] = new If(m, _), _.hasRenderCallback && this.haveRenderCallbacks.push(u)
            }
          }
          patchUpdatedImages(t, n) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const o in t.updatedImages) this.patchUpdatedImage(this.iconPositions[o], t.getImage(o), n), this.patchUpdatedImage(this.patternPositions[o], t.getImage(o), n)
          }
          patchUpdatedImage(t, n, o) {
            if (!t || !n || t.version === n.version) return;
            t.version = n.version;
            const [u, _] = t.tl;
            o.update(n.data, void 0, {
              x: u,
              y: _
            })
          }
        }
        var Ls;
        Er("ImagePosition", If), Er("ImageAtlas", vg), k.as = void 0, (Ls = k.as || (k.as = {}))[Ls.none = 0] = "none", Ls[Ls.horizontal = 1] = "horizontal", Ls[Ls.vertical = 2] = "vertical", Ls[Ls.horizontalOnly = 3] = "horizontalOnly";
        class Zu {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom"
          }
          static forText(t, n, o) {
            const u = new Zu;
            return u.scale = t || 1, u.fontStack = n, u.verticalAlign = o || "bottom", u
          }
          static forImage(t, n) {
            const o = new Zu;
            return o.imageName = t, o.verticalAlign = n || "bottom", o
          }
        }
        class fc {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
          }
          static fromFeature(t, n) {
            const o = new fc;
            for (let u = 0; u < t.sections.length; u++) {
              const _ = t.sections[u];
              _.image ? o.addImageSection(_) : o.addTextSection(_, n)
            }
            return o
          }
          length() {
            return this.text.length
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]]
          }
          getSectionIndex(t) {
            return this.sectionIndex[t]
          }
          getCharCode(t) {
            return this.text.charCodeAt(t)
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let n = "";
              for (let o = 0; o < t.length; o++) {
                const u = t.charCodeAt(o + 1) || null,
                  _ = t.charCodeAt(o - 1) || null;
                n += u && Jl(u) && !Uu[t[o + 1]] || _ && Jl(_) && !Uu[t[o - 1]] || !Uu[t[o]] ? t[o] : Uu[t[o]]
              }
              return n
            })(this.text)
          }
          trim() {
            let t = 0;
            for (let o = 0; o < this.text.length && Wd[this.text.charCodeAt(o)]; o++) t++;
            let n = this.text.length;
            for (let o = this.text.length - 1; o >= 0 && o >= t && Wd[this.text.charCodeAt(o)]; o--) n--;
            this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n)
          }
          substring(t, n) {
            const o = new fc;
            return o.text = this.text.substring(t, n), o.sectionIndex = this.sectionIndex.slice(t, n), o.sections = this.sections, o
          }
          toString() {
            return this.text
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, n) => Math.max(t, this.sections[n].scale)), 0)
          }
          getMaxImageSize(t) {
            let n = 0,
              o = 0;
            for (let u = 0; u < this.length(); u++) {
              const _ = this.getSection(u);
              if (_.imageName) {
                const m = t[_.imageName];
                if (!m) continue;
                const y = m.displaySize;
                n = Math.max(n, y[0]), o = Math.max(o, y[1])
              }
            }
            return {
              maxImageWidth: n,
              maxImageHeight: o
            }
          }
          addTextSection(t, n) {
            this.text += t.text, this.sections.push(Zu.forText(t.scale, t.fontStack || n, t.verticalAlign));
            const o = this.sections.length - 1;
            for (let u = 0; u < t.text.length; ++u) this.sectionIndex.push(o)
          }
          addImageSection(t) {
            const n = t.image ? t.image.name : "";
            if (n.length === 0) return void It("Can't add FormattedSection with an empty image.");
            const o = this.getNextImageSectionCharCode();
            o ? (this.text += String.fromCharCode(o), this.sections.push(Zu.forImage(n, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : It("Reached maximum number of images 6401")
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
          }
        }

        function $d(i, t, n, o, u, _, m, y, b, M, I, D, B, V, H) {
          const K = fc.fromFeature(i, u);
          let re;
          D === k.as.vertical && K.verticalizePunctuation();
          const {
            processBidirectionalText: pe,
            processStyledBidirectionalText: Ne
          } = go;
          if (pe && K.sections.length === 1) {
            re = [];
            const ot = pe(K.toString(), Cf(K, M, _, t, o, V));
            for (const gt of ot) {
              const er = new fc;
              er.text = gt, er.sections = K.sections;
              for (let Pr = 0; Pr < gt.length; Pr++) er.sectionIndex.push(0);
              re.push(er)
            }
          } else if (Ne) {
            re = [];
            const ot = Ne(K.text, K.sectionIndex, Cf(K, M, _, t, o, V));
            for (const gt of ot) {
              const er = new fc;
              er.text = gt[0], er.sectionIndex = gt[1], er.sections = K.sections, re.push(er)
            }
          } else re = (function(ot, gt) {
            const er = [],
              Pr = ot.text;
            let _r = 0;
            for (const wr of gt) er.push(ot.substring(_r, wr)), _r = wr;
            return _r < Pr.length && er.push(ot.substring(_r, Pr.length)), er
          })(K, Cf(K, M, _, t, o, V));
          const be = [],
            Ae = {
              positionedLines: be,
              text: K.toString(),
              top: I[1],
              bottom: I[1],
              left: I[0],
              right: I[0],
              writingMode: D,
              iconsInText: !1,
              verticalizable: !1
            };
          return (function(ot, gt, er, Pr, _r, wr, Jr, xr, kr, jt, mn, xn) {
            let cn = 0,
              Hr = 0,
              Bn = 0,
              yi = 0;
            const Ri = xr === "right" ? 1 : xr === "left" ? 0 : .5,
              aa = Ni / xn;
            let Wa = 0;
            for (const mi of _r) {
              mi.trim();
              const Vi = mi.getMaxScale(),
                Ji = {
                  positionedGlyphs: [],
                  lineOffset: 0
                };
              ot.positionedLines[Wa] = Ji;
              const Qi = Ji.positionedGlyphs;
              let wa = 0;
              if (!mi.length()) {
                Hr += wr, ++Wa;
                continue
              }
              const Ha = rb(Pr, mi, aa);
              for (let Sa = 0; Sa < mi.length(); Sa++) {
                const ji = mi.getSection(Sa),
                  Zi = mi.getSectionIndex(Sa),
                  Gi = mi.getCharCode(Sa),
                  zi = nb(kr, mn, Gi);
                let si;
                if (ji.imageName) {
                  if (ot.iconsInText = !0, ji.scale = ji.scale * aa, si = ab(ji, zi, Vi, Ha, Pr), !si) continue;
                  wa = Math.max(wa, si.imageOffset)
                } else if (si = ib(ji, Gi, zi, Ha, gt, er), !si) continue;
                const {
                  rect: wo,
                  metrics: vc,
                  baselineOffset: ko
                } = si;
                Qi.push({
                  glyph: Gi,
                  imageName: ji.imageName,
                  x: cn,
                  y: Hr + ko + -17,
                  vertical: zi,
                  scale: ji.scale,
                  fontStack: ji.fontStack,
                  sectionIndex: Zi,
                  metrics: vc,
                  rect: wo
                }), zi ? (ot.verticalizable = !0, cn += (ji.imageName ? vc.advance : Ni) * ji.scale + jt) : cn += vc.advance * ji.scale + jt
              }
              Qi.length !== 0 && (Bn = Math.max(cn - jt, Bn), ob(Qi, 0, Qi.length - 1, Ri)), cn = 0, Ji.lineOffset = Math.max(wa, (Vi - 1) * Ni);
              const Ui = wr * Vi + wa;
              Hr += Ui, yi = Math.max(Ui, yi), ++Wa
            }
            const {
              horizontalAlign: Pa,
              verticalAlign: Ki
            } = Af(Jr);
            (function(mi, Vi, Ji, Qi, wa, Ha, Ui, Sa, ji) {
              const Zi = (Vi - Ji) * wa;
              let Gi = 0;
              Gi = Ha !== Ui ? -Sa * Qi - -17 : -Qi * ji * Ui + .5 * Ui;
              for (const zi of mi)
                for (const si of zi.positionedGlyphs) si.x += Zi, si.y += Gi
            })(ot.positionedLines, Ri, Pa, Ki, Bn, yi, wr, Hr, _r.length), ot.top += -Ki * Hr, ot.bottom = ot.top + Hr, ot.left += -Pa * Bn, ot.right = ot.left + Bn
          })(Ae, t, n, o, re, m, y, b, D, M, B, H), !(function(ot) {
            for (const gt of ot)
              if (gt.positionedGlyphs.length !== 0) return !1;
            return !0
          })(be) && Ae
        }
        const Wd = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
          },
          Qx = {
            10: !0,
            32: !0,
            38: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
          },
          eb = {
            40: !0
          };

        function yg(i, t, n, o, u, _) {
          if (t.imageName) {
            const m = o[t.imageName];
            return m ? m.displaySize[0] * t.scale * Ni / _ + u : 0
          } {
            const m = n[t.fontStack],
              y = m && m[i];
            return y ? y.metrics.advance * t.scale + u : 0
          }
        }

        function xg(i, t, n, o) {
          const u = Math.pow(i - t, 2);
          return o ? i < t ? u / 2 : 2 * u : u + Math.abs(n) * n
        }

        function tb(i, t, n) {
          let o = 0;
          return i === 10 && (o -= 1e4), n && (o += 150), i !== 40 && i !== 65288 || (o += 50), t !== 41 && t !== 65289 || (o += 50), o
        }

        function bg(i, t, n, o, u, _) {
          let m = null,
            y = xg(t, n, u, _);
          for (const b of o) {
            const M = xg(t - b.x, n, u, _) + b.badness;
            M <= y && (m = b, y = M)
          }
          return {
            index: i,
            x: t,
            priorBreak: m,
            badness: y
          }
        }

        function wg(i) {
          return i ? wg(i.priorBreak).concat(i.index) : []
        }

        function Cf(i, t, n, o, u, _) {
          if (!i) return [];
          const m = [],
            y = (function(D, B, V, H, K, re) {
              let pe = 0;
              for (let Ne = 0; Ne < D.length(); Ne++) {
                const be = D.getSection(Ne);
                pe += yg(D.getCharCode(Ne), be, H, K, B, re)
              }
              return pe / Math.max(1, Math.ceil(pe / V))
            })(i, t, n, o, u, _),
            b = i.text.indexOf("â€‹") >= 0;
          let M = 0;
          for (let D = 0; D < i.length(); D++) {
            const B = i.getSection(D),
              V = i.getCharCode(D);
            if (Wd[V] || (M += yg(V, B, o, u, t, _)), D < i.length() - 1) {
              const H = !((I = V) < 11904) && (!!Dn["CJK Compatibility Forms"](I) || !!Dn["CJK Compatibility"](I) || !!Dn["CJK Strokes"](I) || !!Dn["CJK Symbols and Punctuation"](I) || !!Dn["Enclosed CJK Letters and Months"](I) || !!Dn["Halfwidth and Fullwidth Forms"](I) || !!Dn["Ideographic Description Characters"](I) || !!Dn["Vertical Forms"](I) || wu.test(String.fromCodePoint(I)));
              (Qx[V] || H || B.imageName || D !== i.length() - 2 && eb[i.getCharCode(D + 1)]) && m.push(bg(D + 1, M, y, m, tb(V, i.getCharCode(D + 1), H && b), !1))
            }
          }
          var I;
          return wg(bg(i.length(), M, y, m, 0, !0))
        }

        function Af(i) {
          let t = .5,
            n = .5;
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0
          }
          switch (i) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              n = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              n = 0
          }
          return {
            horizontalAlign: t,
            verticalAlign: n
          }
        }

        function rb(i, t, n) {
          const o = t.getMaxScale() * Ni,
            {
              maxImageWidth: u,
              maxImageHeight: _
            } = t.getMaxImageSize(i),
            m = Math.max(o, _ * n);
          return {
            verticalLineContentWidth: Math.max(o, u * n),
            horizontalLineContentHeight: m
          }
        }

        function kg(i) {
          switch (i) {
            case "top":
              return 0;
            case "center":
              return .5;
            default:
              return 1
          }
        }

        function nb(i, t, n) {
          return !(i === k.as.horizontal || !t && !Kl(n) || t && (Wd[n] || (o = n, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(o)))));
          var o
        }

        function ib(i, t, n, o, u, _) {
          const m = _[i.fontStack],
            y = (function(M, I, D, B) {
              if (M && M.rect) return M;
              const V = I[D.fontStack],
                H = V && V[B];
              return H ? {
                rect: null,
                metrics: H.metrics
              } : null
            })(m && m[t], u, i, t);
          if (y === null) return null;
          let b;
          if (n) b = o.verticalLineContentWidth - i.scale * Ni;
          else {
            const M = kg(i.verticalAlign);
            b = (o.horizontalLineContentHeight - i.scale * Ni) * M
          }
          return {
            rect: y.rect,
            metrics: y.metrics,
            baselineOffset: b
          }
        }

        function ab(i, t, n, o, u) {
          const _ = u[i.imageName];
          if (!_) return null;
          const m = _.paddedRect,
            y = _.displaySize,
            b = {
              width: y[0],
              height: y[1],
              left: 1,
              top: -3,
              advance: t ? y[1] : y[0]
            };
          let M;
          if (t) M = o.verticalLineContentWidth - y[1] * i.scale;
          else {
            const I = kg(i.verticalAlign);
            M = (o.horizontalLineContentHeight - y[1] * i.scale) * I
          }
          return {
            rect: m,
            metrics: b,
            baselineOffset: M,
            imageOffset: (t ? y[0] : y[1]) * i.scale - Ni * n
          }
        }

        function ob(i, t, n, o) {
          if (o === 0) return;
          const u = i[n],
            _ = (i[n].x + u.metrics.advance * u.scale) * o;
          for (let m = t; m <= n; m++) i[m].x -= _
        }

        function sb(i, t, n) {
          const {
            horizontalAlign: o,
            verticalAlign: u
          } = Af(n), _ = t[0] - i.displaySize[0] * o, m = t[1] - i.displaySize[1] * u;
          return {
            image: i,
            top: m,
            bottom: m + i.displaySize[1],
            left: _,
            right: _ + i.displaySize[0]
          }
        }

        function Tg(i) {
          var t, n;
          let o = i.left,
            u = i.top,
            _ = i.right - o,
            m = i.bottom - u;
          const y = (t = i.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink",
            b = (n = i.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink",
            M = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
          if (b === "proportional") {
            if (y === "stretchOnly" && _ / m < M || y === "proportional") {
              const I = Math.ceil(m * M);
              o *= I / _, _ = I
            }
          } else if (y === "proportional" && b === "stretchOnly" && M !== 0 && _ / m > M) {
            const I = Math.ceil(_ / M);
            u *= I / m, m = I
          }
          return {
            x1: o,
            y1: u,
            x2: o + _,
            y2: u + m
          }
        }

        function Pg(i, t, n, o, u, _) {
          const m = i.image;
          let y;
          if (m.content) {
            const re = m.content,
              pe = m.pixelRatio || 1;
            y = [re[0] / pe, re[1] / pe, m.displaySize[0] - re[2] / pe, m.displaySize[1] - re[3] / pe]
          }
          const b = t.left * _,
            M = t.right * _;
          let I, D, B, V;
          n === "width" || n === "both" ? (V = u[0] + b - o[3], D = u[0] + M + o[1]) : (V = u[0] + (b + M - m.displaySize[0]) / 2, D = V + m.displaySize[0]);
          const H = t.top * _,
            K = t.bottom * _;
          return n === "height" || n === "both" ? (I = u[1] + H - o[0], B = u[1] + K + o[2]) : (I = u[1] + (H + K - m.displaySize[1]) / 2, B = I + m.displaySize[1]), {
            image: m,
            top: I,
            right: D,
            bottom: B,
            left: V,
            collisionPadding: y
          }
        }
        const ls = 128,
          Ds = 32640;

        function Sg(i, t) {
          const {
            expression: n
          } = t;
          if (n.kind === "constant") return {
            kind: "constant",
            layoutSize: n.evaluate(new Qn(i + 1))
          };
          if (n.kind === "source") return {
            kind: "source"
          };
          {
            const {
              zoomStops: o,
              interpolationType: u
            } = n;
            let _ = 0;
            for (; _ < o.length && o[_] <= i;) _++;
            _ = Math.max(0, _ - 1);
            let m = _;
            for (; m < o.length && o[m] < i + 1;) m++;
            m = Math.min(o.length - 1, m);
            const y = o[_],
              b = o[m];
            return n.kind === "composite" ? {
              kind: "composite",
              minZoom: y,
              maxZoom: b,
              interpolationType: u
            } : {
              kind: "camera",
              minZoom: y,
              maxZoom: b,
              minSize: n.evaluate(new Qn(y)),
              maxSize: n.evaluate(new Qn(b)),
              interpolationType: u
            }
          }
        }

        function zf(i, t, n) {
          let o = "never";
          const u = i.get(t);
          return u ? o = u : i.get(n) && (o = "always"), o
        }
        const lb = [{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint8",
          offset: 0
        }];

        function Hd(i, t, n, o, u, _, m, y, b, M, I, D, B) {
          const V = y ? Math.min(Ds, Math.round(y[0])) : 0,
            H = y ? Math.min(Ds, Math.round(y[1])) : 0;
          i.emplaceBack(t, n, Math.round(32 * o), Math.round(32 * u), _, m, (V << 1) + (b ? 1 : 0), H, 16 * M, 16 * I, 256 * D, 256 * B)
        }

        function Ef(i, t, n) {
          i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n)
        }

        function cb(i) {
          for (const t of i.sections)
            if (sf(t.text)) return !0;
          return !1
        }
        class Lf {
          constructor(t) {
            this.layoutVertexArray = new at, this.indexArray = new Nt, this.programConfigurations = t, this.segments = new zn, this.dynamicLayoutVertexArray = new lt, this.opacityVertexArray = new pt, this.hasVisibleVertices = !1, this.placedSymbolArray = new C
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
          }
          upload(t, n, o, u) {
            this.isEmpty() || (o && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, jx.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Fx.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, lb, !0), this.opacityVertexBuffer.itemSize = 1), (o || u) && this.programConfigurations.upload(t))
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy())
          }
        }
        Er("SymbolBuffers", Lf);
        class Df {
          constructor(t, n, o) {
            this.layoutVertexArray = new t, this.layoutAttributes = n, this.indexArray = new o, this.segments = new zn, this.collisionVertexArray = new hr
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Bx.members, !0)
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy())
          }
        }
        Er("CollisionBuffers", Df);
        class _c {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = Lt(globalThis) ? Math.min(t.overscaling, 128) : t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((m => m.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const n = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Sg(this.zoom, n["text-size"]), this.iconSizeData = Sg(this.zoom, n["icon-size"]);
            const o = this.layers[0].layout,
              u = o.get("symbol-sort-key"),
              _ = o.get("symbol-z-order");
            this.canOverlap = zf(o, "text-overlap", "text-allow-overlap") !== "never" || zf(o, "icon-overlap", "icon-allow-overlap") !== "never" || o.get("text-ignore-placement") || o.get("icon-ignore-placement"), this.sortFeaturesByKey = _ !== "viewport-y" && !u.isConstant(), this.sortFeaturesByY = (_ === "viewport-y" || _ === "auto" && !this.sortFeaturesByKey) && this.canOverlap, o.get("symbol-placement") === "point" && (this.writingModes = o.get("text-writing-mode").map((m => k.as[m]))), this.stateDependentLayerIds = this.layers.filter((m => m.isStateDependent())).map((m => m.id)), this.sourceID = t.sourceID
          }
          createArrays() {
            this.text = new Lf(new os(this.layers, this.zoom, (t => /^text/.test(t)))), this.icon = new Lf(new os(this.layers, this.zoom, (t => /^icon/.test(t)))), this.glyphOffsetArray = new R, this.lineVertexArray = new U, this.symbolInstances = new F, this.textAnchorOffsets = new ne
          }
          calculateGlyphDependencies(t, n, o, u, _) {
            for (let m = 0; m < t.length; m++)
              if (n[t.charCodeAt(m)] = !0, (o || u) && _) {
                const y = Uu[t.charAt(m)];
                y && (n[y.charCodeAt(0)] = !0)
              }
          }
          populate(t, n, o) {
            const u = this.layers[0],
              _ = u.layout,
              m = _.get("text-font"),
              y = _.get("text-field"),
              b = _.get("icon-image"),
              M = (y.value.kind !== "constant" || y.value.value instanceof Xn && !y.value.value.isEmpty() || y.value.value.toString().length > 0) && (m.value.kind !== "constant" || m.value.value.length > 0),
              I = b.value.kind !== "constant" || !!b.value.value || Object.keys(b.parameters).length > 0,
              D = _.get("symbol-sort-key");
            if (this.features = [], !M && !I) return;
            const B = n.iconDependencies,
              V = n.glyphDependencies,
              H = n.availableImages,
              K = new Qn(this.zoom);
            for (const {
                feature: re,
                id: pe,
                index: Ne,
                sourceLayerIndex: be
              }
              of t) {
              const Ae = u._featureFilter.needGeometry,
                ot = Ro(re, Ae);
              if (!u._featureFilter.filter(K, ot, o)) continue;
              let gt, er;
              if (Ae || (ot.geometry = bo(re)), M) {
                const _r = u.getValueAndResolveTokens("text-field", ot, o, H),
                  wr = Xn.factory(_r),
                  Jr = this.hasRTLText = this.hasRTLText || cb(wr);
                (!Jr || go.getRTLTextPluginStatus() === "unavailable" || Jr && go.isParsed()) && (gt = qx(wr, u, ot))
              }
              if (I) {
                const _r = u.getValueAndResolveTokens("icon-image", ot, o, H);
                er = _r instanceof Cn ? _r : Cn.fromString(_r)
              }
              if (!gt && !er) continue;
              const Pr = this.sortFeaturesByKey ? D.evaluate(ot, {}, o) : void 0;
              if (this.features.push({
                  id: pe,
                  text: gt,
                  icon: er,
                  index: Ne,
                  sourceLayerIndex: be,
                  geometry: ot.geometry,
                  properties: re.properties,
                  type: dc.types[re.type],
                  sortKey: Pr
                }), er && (B[er.name] = !0), gt) {
                const _r = m.evaluate(ot, {}, o).join(","),
                  wr = _.get("text-rotation-alignment") !== "viewport" && _.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(k.as.vertical) >= 0;
                for (const Jr of gt.sections)
                  if (Jr.image) B[Jr.image.name] = !0;
                  else {
                    const xr = xu(gt.toString()),
                      kr = Jr.fontStack || _r,
                      jt = V[kr] = V[kr] || {};
                    this.calculateGlyphDependencies(Jr.text, jt, wr, this.allowVerticalPlacement, xr)
                  }
              }
            }
            _.get("symbol-placement") === "line" && (this.features = (function(re) {
              const pe = {},
                Ne = {},
                be = [];
              let Ae = 0;

              function ot(_r) {
                be.push(re[_r]), Ae++
              }

              function gt(_r, wr, Jr) {
                const xr = Ne[_r];
                return delete Ne[_r], Ne[wr] = xr, be[xr].geometry[0].pop(), be[xr].geometry[0] = be[xr].geometry[0].concat(Jr[0]), xr
              }

              function er(_r, wr, Jr) {
                const xr = pe[wr];
                return delete pe[wr], pe[_r] = xr, be[xr].geometry[0].shift(), be[xr].geometry[0] = Jr[0].concat(be[xr].geometry[0]), xr
              }

              function Pr(_r, wr, Jr) {
                const xr = Jr ? wr[0][wr[0].length - 1] : wr[0][0];
                return `${_r}:${xr.x}:${xr.y}`
              }
              for (let _r = 0; _r < re.length; _r++) {
                const wr = re[_r],
                  Jr = wr.geometry,
                  xr = wr.text ? wr.text.toString() : null;
                if (!xr) {
                  ot(_r);
                  continue
                }
                const kr = Pr(xr, Jr),
                  jt = Pr(xr, Jr, !0);
                if (kr in Ne && jt in pe && Ne[kr] !== pe[jt]) {
                  const mn = er(kr, jt, Jr),
                    xn = gt(kr, jt, be[mn].geometry);
                  delete pe[kr], delete Ne[jt], Ne[Pr(xr, be[xn].geometry, !0)] = xn, be[mn].geometry = null
                } else kr in Ne ? gt(kr, jt, Jr) : jt in pe ? er(kr, jt, Jr) : (ot(_r), pe[kr] = Ae - 1, Ne[jt] = Ae - 1)
              }
              return be.filter((_r => _r.geometry))
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((re, pe) => re.sortKey - pe.sortKey))
          }
          update(t, n, o) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, n, this.layers, {
              imagePositions: o
            }), this.icon.programConfigurations.updatePaintArrays(t, n, this.layers, {
              imagePositions: o
            }))
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
          }
          addToLineVertexArray(t, n) {
            const o = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let u = t.dist(n[t.segment + 1]),
                _ = t.dist(n[t.segment]);
              const m = {};
              for (let y = t.segment + 1; y < n.length; y++) m[y] = {
                x: n[y].x,
                y: n[y].y,
                tileUnitDistanceFromAnchor: u
              }, y < n.length - 1 && (u += n[y + 1].dist(n[y]));
              for (let y = t.segment || 0; y >= 0; y--) m[y] = {
                x: n[y].x,
                y: n[y].y,
                tileUnitDistanceFromAnchor: _
              }, y > 0 && (_ += n[y - 1].dist(n[y]));
              for (let y = 0; y < n.length; y++) {
                const b = m[y];
                this.lineVertexArray.emplaceBack(b.x, b.y, b.tileUnitDistanceFromAnchor)
              }
            }
            return {
              lineStartIndex: o,
              lineLength: this.lineVertexArray.length - o
            }
          }
          addSymbols(t, n, o, u, _, m, y, b, M, I, D, B) {
            const V = t.indexArray,
              H = t.layoutVertexArray,
              K = t.segments.prepareSegment(4 * n.length, H, V, this.canOverlap ? m.sortKey : void 0),
              re = this.glyphOffsetArray.length,
              pe = K.vertexLength,
              Ne = this.allowVerticalPlacement && y === k.as.vertical ? Math.PI / 2 : 0,
              be = m.text && m.text.sections;
            for (let Ae = 0; Ae < n.length; Ae++) {
              const {
                tl: ot,
                tr: gt,
                bl: er,
                br: Pr,
                tex: _r,
                pixelOffsetTL: wr,
                pixelOffsetBR: Jr,
                minFontScaleX: xr,
                minFontScaleY: kr,
                glyphOffset: jt,
                isSDF: mn,
                sectionIndex: xn
              } = n[Ae], cn = K.vertexLength, Hr = jt[1];
              Hd(H, b.x, b.y, ot.x, Hr + ot.y, _r.x, _r.y, o, mn, wr.x, wr.y, xr, kr), Hd(H, b.x, b.y, gt.x, Hr + gt.y, _r.x + _r.w, _r.y, o, mn, Jr.x, wr.y, xr, kr), Hd(H, b.x, b.y, er.x, Hr + er.y, _r.x, _r.y + _r.h, o, mn, wr.x, Jr.y, xr, kr), Hd(H, b.x, b.y, Pr.x, Hr + Pr.y, _r.x + _r.w, _r.y + _r.h, o, mn, Jr.x, Jr.y, xr, kr), Ef(t.dynamicLayoutVertexArray, b, Ne), V.emplaceBack(cn, cn + 2, cn + 1), V.emplaceBack(cn + 1, cn + 2, cn + 3), K.vertexLength += 4, K.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(jt[0]), Ae !== n.length - 1 && xn === n[Ae + 1].sectionIndex || t.programConfigurations.populatePaintArrays(H.length, m, m.index, {
                imagePositions: {},
                canonical: B,
                formattedSection: be && be[xn]
              })
            }
            t.placedSymbolArray.emplaceBack(b.x, b.y, re, this.glyphOffsetArray.length - re, pe, M, I, b.segment, o ? o[0] : 0, o ? o[1] : 0, u[0], u[1], y, 0, !1, 0, D)
          }
          _addCollisionDebugVertex(t, n, o, u, _, m) {
            return n.emplaceBack(0, 0), t.emplaceBack(o.x, o.y, u, _, Math.round(m.x), Math.round(m.y))
          }
          addCollisionDebugVertices(t, n, o, u, _, m, y) {
            const b = _.segments.prepareSegment(4, _.layoutVertexArray, _.indexArray),
              M = b.vertexLength,
              I = _.layoutVertexArray,
              D = _.collisionVertexArray,
              B = y.anchorX,
              V = y.anchorY;
            this._addCollisionDebugVertex(I, D, m, B, V, new j(t, n)), this._addCollisionDebugVertex(I, D, m, B, V, new j(o, n)), this._addCollisionDebugVertex(I, D, m, B, V, new j(o, u)), this._addCollisionDebugVertex(I, D, m, B, V, new j(t, u)), b.vertexLength += 4;
            const H = _.indexArray;
            H.emplaceBack(M, M + 1), H.emplaceBack(M + 1, M + 2), H.emplaceBack(M + 2, M + 3), H.emplaceBack(M + 3, M), b.primitiveLength += 4
          }
          addDebugCollisionBoxes(t, n, o, u) {
            for (let _ = t; _ < n; _++) {
              const m = this.collisionBoxArray.get(_);
              this.addCollisionDebugVertices(m.x1, m.y1, m.x2, m.y2, u ? this.textCollisionBox : this.iconCollisionBox, m.anchorPoint, o)
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Df(ur, pg.members, Ur), this.iconCollisionBox = new Df(ur, pg.members, Ur);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const n = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, !1), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, !1)
            }
          }
          _deserializeCollisionBoxesForSymbol(t, n, o, u, _, m, y, b, M) {
            const I = {};
            for (let D = n; D < o; D++) {
              const B = t.get(D);
              I.textBox = {
                x1: B.x1,
                y1: B.y1,
                x2: B.x2,
                y2: B.y2,
                anchorPointX: B.anchorPointX,
                anchorPointY: B.anchorPointY
              }, I.textFeatureIndex = B.featureIndex;
              break
            }
            for (let D = u; D < _; D++) {
              const B = t.get(D);
              I.verticalTextBox = {
                x1: B.x1,
                y1: B.y1,
                x2: B.x2,
                y2: B.y2,
                anchorPointX: B.anchorPointX,
                anchorPointY: B.anchorPointY
              }, I.verticalTextFeatureIndex = B.featureIndex;
              break
            }
            for (let D = m; D < y; D++) {
              const B = t.get(D);
              I.iconBox = {
                x1: B.x1,
                y1: B.y1,
                x2: B.x2,
                y2: B.y2,
                anchorPointX: B.anchorPointX,
                anchorPointY: B.anchorPointY
              }, I.iconFeatureIndex = B.featureIndex;
              break
            }
            for (let D = b; D < M; D++) {
              const B = t.get(D);
              I.verticalIconBox = {
                x1: B.x1,
                y1: B.y1,
                x2: B.x2,
                y2: B.y2,
                anchorPointX: B.anchorPointX,
                anchorPointY: B.anchorPointY
              }, I.verticalIconFeatureIndex = B.featureIndex;
              break
            }
            return I
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let n = 0; n < this.symbolInstances.length; n++) {
              const o = this.symbolInstances.get(n);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, o.textBoxStartIndex, o.textBoxEndIndex, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o.iconBoxStartIndex, o.iconBoxEndIndex, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex))
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0
          }
          hasIconData() {
            return this.icon.segments.get().length > 0
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
          }
          addIndicesForPlacedSymbol(t, n) {
            const o = t.placedSymbolArray.get(n),
              u = o.vertexStartIndex + 4 * o.numGlyphs;
            for (let _ = o.vertexStartIndex; _ < u; _ += 4) t.indexArray.emplaceBack(_, _ + 2, _ + 1), t.indexArray.emplaceBack(_ + 1, _ + 2, _ + 3)
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const n = Math.sin(t),
              o = Math.cos(t),
              u = [],
              _ = [],
              m = [];
            for (let y = 0; y < this.symbolInstances.length; ++y) {
              m.push(y);
              const b = this.symbolInstances.get(y);
              u.push(0 | Math.round(n * b.anchorX + o * b.anchorY)), _.push(b.featureIndex)
            }
            return m.sort(((y, b) => u[y] - u[b] || _[b] - _[y])), m
          }
          addToSortKeyRanges(t, n) {
            const o = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            o && o.sortKey === n ? o.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
              sortKey: n,
              symbolInstanceStart: t,
              symbolInstanceEnd: t + 1
            })
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const n of this.symbolInstanceIndexes) {
                const o = this.symbolInstances.get(n);
                this.featureSortOrder.push(o.featureIndex), [o.rightJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.leftJustifiedTextSymbolIndex].forEach(((u, _, m) => {
                  u >= 0 && m.indexOf(u) === _ && this.addIndicesForPlacedSymbol(this.text, u)
                })), o.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, o.verticalPlacedTextSymbolIndex), o.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, o.placedIconSymbolIndex), o.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, o.verticalPlacedIconSymbolIndex)
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
            }
          }
        }
        let Mg, Ig;
        Er("SymbolBucket", _c, {
          omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }), _c.MAX_GLYPHS = 65535, _c.addDynamicAttributes = Ef;
        var Rf = {
          get paint() {
            return Ig = Ig || new na({
              "icon-opacity": new hn(Q.paint_symbol["icon-opacity"]),
              "icon-color": new hn(Q.paint_symbol["icon-color"]),
              "icon-halo-color": new hn(Q.paint_symbol["icon-halo-color"]),
              "icon-halo-width": new hn(Q.paint_symbol["icon-halo-width"]),
              "icon-halo-blur": new hn(Q.paint_symbol["icon-halo-blur"]),
              "icon-translate": new Xr(Q.paint_symbol["icon-translate"]),
              "icon-translate-anchor": new Xr(Q.paint_symbol["icon-translate-anchor"]),
              "text-opacity": new hn(Q.paint_symbol["text-opacity"]),
              "text-color": new hn(Q.paint_symbol["text-color"], {
                runtimeType: Ar,
                getOverride: i => i.textColor,
                hasOverride: i => !!i.textColor
              }),
              "text-halo-color": new hn(Q.paint_symbol["text-halo-color"]),
              "text-halo-width": new hn(Q.paint_symbol["text-halo-width"]),
              "text-halo-blur": new hn(Q.paint_symbol["text-halo-blur"]),
              "text-translate": new Xr(Q.paint_symbol["text-translate"]),
              "text-translate-anchor": new Xr(Q.paint_symbol["text-translate-anchor"])
            })
          },
          get layout() {
            return Mg = Mg || new na({
              "symbol-placement": new Xr(Q.layout_symbol["symbol-placement"]),
              "symbol-spacing": new Xr(Q.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new Xr(Q.layout_symbol["symbol-avoid-edges"]),
              "symbol-sort-key": new hn(Q.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new Xr(Q.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new Xr(Q.layout_symbol["icon-allow-overlap"]),
              "icon-overlap": new Xr(Q.layout_symbol["icon-overlap"]),
              "icon-ignore-placement": new Xr(Q.layout_symbol["icon-ignore-placement"]),
              "icon-optional": new Xr(Q.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new Xr(Q.layout_symbol["icon-rotation-alignment"]),
              "icon-size": new hn(Q.layout_symbol["icon-size"]),
              "icon-text-fit": new Xr(Q.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new Xr(Q.layout_symbol["icon-text-fit-padding"]),
              "icon-image": new hn(Q.layout_symbol["icon-image"]),
              "icon-rotate": new hn(Q.layout_symbol["icon-rotate"]),
              "icon-padding": new hn(Q.layout_symbol["icon-padding"]),
              "icon-keep-upright": new Xr(Q.layout_symbol["icon-keep-upright"]),
              "icon-offset": new hn(Q.layout_symbol["icon-offset"]),
              "icon-anchor": new hn(Q.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new Xr(Q.layout_symbol["icon-pitch-alignment"]),
              "text-pitch-alignment": new Xr(Q.layout_symbol["text-pitch-alignment"]),
              "text-rotation-alignment": new Xr(Q.layout_symbol["text-rotation-alignment"]),
              "text-field": new hn(Q.layout_symbol["text-field"]),
              "text-font": new hn(Q.layout_symbol["text-font"]),
              "text-size": new hn(Q.layout_symbol["text-size"]),
              "text-max-width": new hn(Q.layout_symbol["text-max-width"]),
              "text-line-height": new Xr(Q.layout_symbol["text-line-height"]),
              "text-letter-spacing": new hn(Q.layout_symbol["text-letter-spacing"]),
              "text-justify": new hn(Q.layout_symbol["text-justify"]),
              "text-radial-offset": new hn(Q.layout_symbol["text-radial-offset"]),
              "text-variable-anchor": new Xr(Q.layout_symbol["text-variable-anchor"]),
              "text-variable-anchor-offset": new hn(Q.layout_symbol["text-variable-anchor-offset"]),
              "text-anchor": new hn(Q.layout_symbol["text-anchor"]),
              "text-max-angle": new Xr(Q.layout_symbol["text-max-angle"]),
              "text-writing-mode": new Xr(Q.layout_symbol["text-writing-mode"]),
              "text-rotate": new hn(Q.layout_symbol["text-rotate"]),
              "text-padding": new Xr(Q.layout_symbol["text-padding"]),
              "text-keep-upright": new Xr(Q.layout_symbol["text-keep-upright"]),
              "text-transform": new hn(Q.layout_symbol["text-transform"]),
              "text-offset": new hn(Q.layout_symbol["text-offset"]),
              "text-allow-overlap": new Xr(Q.layout_symbol["text-allow-overlap"]),
              "text-overlap": new Xr(Q.layout_symbol["text-overlap"]),
              "text-ignore-placement": new Xr(Q.layout_symbol["text-ignore-placement"]),
              "text-optional": new Xr(Q.layout_symbol["text-optional"])
            })
          }
        };
        class Cg {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : br, this.defaultValue = t
          }
          evaluate(t) {
            if (t.formattedSection) {
              const n = this.defaultValue.property.overrides;
              if (n && n.hasOverride(t.formattedSection)) return n.getOverride(t.formattedSection)
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
          }
          outputDefined() {
            return !1
          }
          serialize() {
            return null
          }
        }
        Er("FormatSectionOverride", Cg, {
          omit: ["defaultValue"]
        });
        class Xd extends Za {
          constructor(t, n) {
            super(t, Rf, n)
          }
          recalculate(t, n) {
            if (super.recalculate(t, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const o = this.layout.get("text-writing-mode");
              if (o) {
                const u = [];
                for (const _ of o) u.indexOf(_) < 0 && u.push(_);
                this.layout._values["text-writing-mode"] = u
              } else this.layout._values["text-writing-mode"] = ["horizontal"]
            }
            this._setPaintOverrides()
          }
          getValueAndResolveTokens(t, n, o, u) {
            const _ = this.layout.get(t).evaluate(n, {}, o, u),
              m = this._unevaluatedLayout._values[t];
            return m.isDataDriven() || Nl(m.value) || !_ ? _ : (function(y, b) {
              return b.replace(/{([^{}]+)}/g, ((M, I) => y && I in y ? String(y[I]) : ""))
            })(n.properties, _)
          }
          createBucket(t) {
            return new _c(t)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex")
          }
          _setPaintOverrides() {
            for (const t of Rf.paint.overridableProperties) {
              if (!Xd.hasPaintOverride(this.layout, t)) continue;
              const n = this.paint.get(t),
                o = new Cg(n),
                u = new ou(o, n.property.specification);
              let _ = null;
              _ = n.value.kind === "constant" || n.value.kind === "source" ? new Ks("source", u) : new su("composite", u, n.value.zoomStops), this.paint._values[t] = new Ua(n.property, _, n.parameters)
            }
          }
          _handleOverridablePaintPropertyUpdate(t, n, o) {
            return !(!this.layout || n.isDataDriven() || o.isDataDriven()) && Xd.hasPaintOverride(this.layout, t)
          }
          static hasPaintOverride(t, n) {
            const o = t.get("text-field"),
              u = Rf.paint.properties[n];
            let _ = !1;
            const m = y => {
              for (const b of y)
                if (u.overrides && u.overrides.hasOverride(b)) return void(_ = !0)
            };
            if (o.value.kind === "constant" && o.value.value instanceof Xn) m(o.value.value.sections);
            else if (o.value.kind === "source" || o.value.kind === "composite") {
              const y = M => {
                  _ || (M instanceof Vn && fn(M.value) === Vr ? m(M.value.sections) : M instanceof Al ? m(M.sections) : M.eachChild(y))
                },
                b = o.value;
              b._styleExpression && y(b._styleExpression.expression)
            }
            return _
          }
        }
        let Ag;
        var ub = {
          get paint() {
            return Ag = Ag || new na({
              "background-color": new Xr(Q.paint_background["background-color"]),
              "background-pattern": new Ed(Q.paint_background["background-pattern"]),
              "background-opacity": new Xr(Q.paint_background["background-opacity"])
            })
          }
        };
        class hb extends Za {
          constructor(t, n) {
            super(t, ub, n)
          }
        }
        class db extends Za {
          constructor(t, n) {
            super(t, {}, n), this.onAdd = o => {
              this.implementation.onAdd && this.implementation.onAdd(o, o.painter.context.gl)
            }, this.onRemove = o => {
              this.implementation.onRemove && this.implementation.onRemove(o, o.painter.context.gl)
            }, this.implementation = t
          }
          is3D() {
            return this.implementation.renderingMode === "3d"
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0
          }
          recalculate() {}
          updateTransitions() {}
          hasTransition() {
            return !1
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized")
          }
        }
        class pb {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle()
            })
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle()
            }), 0))
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {}
          }
        }
        const fb = {
            once: !0
          },
          jf = 63710088e-1;
        class Rs {
          constructor(t, n) {
            if (isNaN(t) || isNaN(n)) throw new Error(`Invalid LngLat object: (${t}, ${n})`);
            if (this.lng = +t, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
          }
          wrap() {
            return new Rs(Bt(this.lng, -180, 180), this.lat)
          }
          toArray() {
            return [this.lng, this.lat]
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`
          }
          distanceTo(t) {
            const n = Math.PI / 180,
              o = this.lat * n,
              u = t.lat * n,
              _ = Math.sin(o) * Math.sin(u) + Math.cos(o) * Math.cos(u) * Math.cos((t.lng - this.lng) * n);
            return jf * Math.acos(Math.min(_, 1))
          }
          static convert(t) {
            if (t instanceof Rs) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new Rs(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new Rs(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
          }
        }
        const zg = 2 * Math.PI * jf;

        function Eg(i) {
          return zg * Math.cos(i * Math.PI / 180)
        }

        function Lg(i) {
          return (180 + i) / 360
        }

        function Dg(i) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360
        }

        function Rg(i, t) {
          return i / Eg(t)
        }

        function jg(i) {
          return 360 * i - 180
        }

        function Yd(i) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90
        }

        function Fg(i, t) {
          return i * Eg(Yd(t))
        }
        class Gu {
          constructor(t, n, o = 0) {
            this.x = +t, this.y = +n, this.z = +o
          }
          static fromLngLat(t, n = 0) {
            const o = Rs.convert(t);
            return new Gu(Lg(o.lng), Dg(o.lat), Rg(n, o.lat))
          }
          toLngLat() {
            return new Rs(jg(this.x), Yd(this.y))
          }
          toAltitude() {
            return Fg(this.z, this.y)
          }
          meterInMercatorCoordinateUnits() {
            return 1 / zg * (t = Yd(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t
          }
        }

        function Bg(i, t, n) {
          var o = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
          return [i * o - 2 * Math.PI * 6378137 / 2, t * o - 2 * Math.PI * 6378137 / 2]
        }
        class Ff {
          constructor(t, n, o) {
            if (!(function(u, _, m) {
                return !(u < 0 || u > 25 || m < 0 || m >= Math.pow(2, u) || _ < 0 || _ >= Math.pow(2, u))
              })(t, n, o)) throw new Error(`x=${n}, y=${o}, z=${t} outside of bounds. 0<=x<${Math.pow(2,t)}, 0<=y<${Math.pow(2,t)} 0<=z<=25 `);
            this.z = t, this.x = n, this.y = o, this.key = mc(0, t, t, n, o)
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y
          }
          url(t, n, o) {
            const u = (m = this.y, y = this.z, b = Bg(256 * (_ = this.x), 256 * (m = Math.pow(2, y) - m - 1), y), M = Bg(256 * (_ + 1), 256 * (m + 1), y), b[0] + "," + b[1] + "," + M[0] + "," + M[1]);
            var _, m, y, b, M;
            const I = (function(D, B, V) {
              let H, K = "";
              for (let re = D; re > 0; re--) H = 1 << re - 1, K += (B & H ? 1 : 0) + (V & H ? 2 : 0);
              return K
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(o === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, I).replace(/{bbox-epsg-3857}/g, u)
          }
          isChildOf(t) {
            const n = this.z - t.z;
            return n > 0 && t.x === this.x >> n && t.y === this.y >> n
          }
          getTilePoint(t) {
            const n = Math.pow(2, this.z);
            return new j((t.x * n - this.x) * ct, (t.y * n - this.y) * ct)
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`
          }
        }
        class Og {
          constructor(t, n) {
            this.wrap = t, this.canonical = n, this.key = mc(t, n.z, n.z, n.x, n.y)
          }
        }
        class $a {
          constructor(t, n, o, u, _) {
            if (this.terrainRttPosMatrix32f = null, t < o) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${o}`);
            this.overscaledZ = t, this.wrap = n, this.canonical = new Ff(o, +u, +_), this.key = mc(n, t, o, u, _)
          }
          clone() {
            return new $a(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const n = this.canonical.z - t;
            return t > this.canonical.z ? new $a(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new $a(t, this.wrap, t, this.canonical.x >> n, this.canonical.y >> n)
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z
          }
          calculateScaledKey(t, n) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const o = this.canonical.z - t;
            return t > this.canonical.z ? mc(this.wrap * +n, t, this.canonical.z, this.canonical.x, this.canonical.y) : mc(this.wrap * +n, t, t, this.canonical.x >> o, this.canonical.y >> o)
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap || this.overscaledZ - t.overscaledZ <= 0) return !1;
            if (t.overscaledZ === 0) return this.overscaledZ > 0;
            const n = this.canonical.z - t.canonical.z;
            return !(n < 0) && t.canonical.x === this.canonical.x >> n && t.canonical.y === this.canonical.y >> n
          }
          children(t) {
            if (this.overscaledZ >= t) return [new $a(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const n = this.canonical.z + 1,
              o = 2 * this.canonical.x,
              u = 2 * this.canonical.y;
            return [new $a(n, this.wrap, n, o, u), new $a(n, this.wrap, n, o + 1, u), new $a(n, this.wrap, n, o, u + 1), new $a(n, this.wrap, n, o + 1, u + 1)]
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
          }
          wrapped() {
            return new $a(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          unwrapTo(t) {
            return new $a(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z)
          }
          toUnwrapped() {
            return new Og(this.wrap, this.canonical)
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new Gu(t.x - this.wrap, t.y))
          }
        }

        function mc(i, t, n, o, u) {
          (i *= 2) < 0 && (i = -1 * i - 1);
          const _ = 1 << n;
          return (_ * _ * i + _ * u + o).toString(36) + n.toString(36) + t.toString(36)
        }

        function $u(i, t) {
          return t ? i.properties[t] : i.id
        }
        Er("CanonicalTileID", Ff), Er("OverscaledTileID", $a, {
          omit: ["terrainRttPosMatrix32f"]
        });
        class hl {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this
          }
          shrinkBy(t) {
            return this.expandBy(-t)
          }
          map(t) {
            const n = new hl;
            return n.extend(t(new j(this.minX, this.minY))), n.extend(t(new j(this.maxX, this.minY))), n.extend(t(new j(this.minX, this.maxY))), n.extend(t(new j(this.maxX, this.maxY))), n
          }
          static fromPoints(t) {
            const n = new hl;
            for (const o of t) n.extend(o);
            return n
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY
          }
          empty() {
            return this.minX > this.maxX
          }
          width() {
            return this.maxX - this.minX
          }
          height() {
            return this.maxY - this.minY
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY
          }
        }
        class qg {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let n = 0; n < t.length; n++) {
              const o = t[n];
              this._stringToNumber[o] = n, this._numberToString[n] = o
            }
          }
          encode(t) {
            return this._stringToNumber[t]
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t]
          }
        }
        class Ng {
          constructor(t, n, o, u, _) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = n, t._x = o, t._y = u, this.properties = t.properties, this.id = _
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry
          }
          set geometry(t) {
            this._geometry = t
          }
          toJSON() {
            const t = {
              geometry: this.geometry
            };
            for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (t[n] = this[n]);
            return t
          }
        }
        class Vg {
          constructor(t, n) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Jo(ct, 16, 0), this.grid3D = new Jo(ct, 16, 0), this.featureIndexArray = new ae, this.promoteId = n
          }
          insert(t, n, o, u, _, m) {
            const y = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(o, u, _);
            const b = m ? this.grid3D : this.grid;
            for (let M = 0; M < n.length; M++) {
              const I = n[M],
                D = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let B = 0; B < I.length; B++) {
                const V = I[B];
                D[0] = Math.min(D[0], V.x), D[1] = Math.min(D[1], V.y), D[2] = Math.max(D[2], V.x), D[3] = Math.max(D[3], V.y)
              }
              D[0] < ct && D[1] < ct && D[2] >= 0 && D[3] >= 0 && b.insert(y, D[0], D[1], D[2], D[3])
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new ig(new Mf(this.rawTileData)).layers, this.sourceLayerCoder = new qg(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers
          }
          query(t, n, o, u) {
            this.loadVTLayers();
            const _ = t.params,
              m = ct / t.tileSize / t.scale,
              y = Js(_.filter, _.globalState),
              b = t.queryGeometry,
              M = t.queryPadding * m,
              I = hl.fromPoints(b),
              D = this.grid.query(I.minX - M, I.minY - M, I.maxX + M, I.maxY + M),
              B = hl.fromPoints(t.cameraQueryGeometry).expandBy(M),
              V = this.grid3D.query(B.minX, B.minY, B.maxX, B.maxY, ((re, pe, Ne, be) => (function(Ae, ot, gt, er, Pr) {
                for (const wr of Ae)
                  if (ot <= wr.x && gt <= wr.y && er >= wr.x && Pr >= wr.y) return !0;
                const _r = [new j(ot, gt), new j(ot, Pr), new j(er, Pr), new j(er, gt)];
                if (Ae.length > 2) {
                  for (const wr of _r)
                    if (sc(Ae, wr)) return !0
                }
                for (let wr = 0; wr < Ae.length - 1; wr++)
                  if (Zy(Ae[wr], Ae[wr + 1], _r)) return !0;
                return !1
              })(t.cameraQueryGeometry, re - M, pe - M, Ne + M, be + M)));
            for (const re of V) D.push(re);
            D.sort(_b);
            const H = {};
            let K;
            for (let re = 0; re < D.length; re++) {
              const pe = D[re];
              if (pe === K) continue;
              K = pe;
              const Ne = this.featureIndexArray.get(pe);
              let be = null;
              this.loadMatchingFeature(H, Ne.bucketIndex, Ne.sourceLayerIndex, Ne.featureIndex, y, _.layers, _.availableImages, n, o, u, ((Ae, ot, gt) => (be || (be = bo(Ae)), ot.queryIntersectsFeature({
                queryGeometry: b,
                feature: Ae,
                featureState: gt,
                geometry: be,
                zoom: this.z,
                transform: t.transform,
                pixelsToTileUnits: m,
                pixelPosMatrix: t.pixelPosMatrix,
                unwrappedTileID: this.tileID.toUnwrapped(),
                getElevation: t.getElevation
              }))))
            }
            return H
          }
          loadMatchingFeature(t, n, o, u, _, m, y, b, M, I, D) {
            const B = this.bucketLayerIDs[n];
            if (m && !B.some((re => m.has(re)))) return;
            const V = this.sourceLayerCoder.decode(o),
              H = this.vtLayers[V].feature(u);
            if (_.needGeometry) {
              const re = Ro(H, !0);
              if (!_.filter(new Qn(this.tileID.overscaledZ), re, this.tileID.canonical)) return
            } else if (!_.filter(new Qn(this.tileID.overscaledZ), H)) return;
            const K = this.getId(H, V);
            for (let re = 0; re < B.length; re++) {
              const pe = B[re];
              if (m && !m.has(pe)) continue;
              const Ne = b[pe];
              if (!Ne) continue;
              let be = {};
              K && I && (be = I.getState(Ne.sourceLayer || "_geojsonTileLayer", K));
              const Ae = it({}, M[pe]);
              Ae.paint = Ug(Ae.paint, Ne.paint, H, be, y), Ae.layout = Ug(Ae.layout, Ne.layout, H, be, y);
              const ot = !D || D(H, Ne, be);
              if (!ot) continue;
              const gt = new Ng(H, this.z, this.x, this.y, K);
              gt.layer = Ae;
              let er = t[pe];
              er === void 0 && (er = t[pe] = []), er.push({
                featureIndex: u,
                feature: gt,
                intersectionZ: ot
              })
            }
          }
          lookupSymbolFeatures(t, n, o, u, _, m, y, b) {
            const M = {};
            this.loadVTLayers();
            const I = Js(_.filterSpec, _.globalState);
            for (const D of t) this.loadMatchingFeature(M, o, u, D, I, m, y, b, n);
            return M
          }
          hasLayer(t) {
            for (const n of this.bucketLayerIDs)
              for (const o of n)
                if (t === o) return !0;
            return !1
          }
          getId(t, n) {
            var o;
            let u = t.id;
            return this.promoteId && (u = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof u == "boolean" && (u = Number(u)), u === void 0 && (!((o = t.properties) === null || o === void 0) && o.cluster) && this.promoteId && (u = Number(t.properties.cluster_id))), u
          }
        }

        function Ug(i, t, n, o, u) {
          return Ot(i, ((_, m) => {
            const y = t instanceof Qo ? t.get(m) : null;
            return y && y.evaluate ? y.evaluate(n, o, u) : y
          }))
        }

        function _b(i, t) {
          return t - i
        }

        function Zg(i, t, n, o, u) {
          const _ = [];
          for (let m = 0; m < i.length; m++) {
            const y = i[m];
            let b;
            for (let M = 0; M < y.length - 1; M++) {
              let I = y[M],
                D = y[M + 1];
              I.x < t && D.x < t || (I.x < t ? I = new j(t, I.y + (t - I.x) / (D.x - I.x) * (D.y - I.y))._round() : D.x < t && (D = new j(t, I.y + (t - I.x) / (D.x - I.x) * (D.y - I.y))._round()), I.y < n && D.y < n || (I.y < n ? I = new j(I.x + (n - I.y) / (D.y - I.y) * (D.x - I.x), n)._round() : D.y < n && (D = new j(I.x + (n - I.y) / (D.y - I.y) * (D.x - I.x), n)._round()), I.x >= o && D.x >= o || (I.x >= o ? I = new j(o, I.y + (o - I.x) / (D.x - I.x) * (D.y - I.y))._round() : D.x >= o && (D = new j(o, I.y + (o - I.x) / (D.x - I.x) * (D.y - I.y))._round()), I.y >= u && D.y >= u || (I.y >= u ? I = new j(I.x + (u - I.y) / (D.y - I.y) * (D.x - I.x), u)._round() : D.y >= u && (D = new j(I.x + (u - I.y) / (D.y - I.y) * (D.x - I.x), u)._round()), b && I.equals(b[b.length - 1]) || (b = [I], _.push(b)), b.push(D)))))
            }
          }
          return _
        }
        Er("FeatureIndex", Vg, {
          omit: ["rawTileData", "sourceLayerCoder"]
        });
        class js extends j {
          constructor(t, n, o, u) {
            super(t, n), this.angle = o, u !== void 0 && (this.segment = u)
          }
          clone() {
            return new js(this.x, this.y, this.angle, this.segment)
          }
        }

        function Gg(i, t, n, o, u) {
          if (t.segment === void 0 || n === 0) return !0;
          let _ = t,
            m = t.segment + 1,
            y = 0;
          for (; y > -n / 2;) {
            if (m--, m < 0) return !1;
            y -= i[m].dist(_), _ = i[m]
          }
          y += i[m].dist(i[m + 1]), m++;
          const b = [];
          let M = 0;
          for (; y < n / 2;) {
            const I = i[m],
              D = i[m + 1];
            if (!D) return !1;
            let B = i[m - 1].angleTo(I) - I.angleTo(D);
            for (B = Math.abs((B + 3 * Math.PI) % (2 * Math.PI) - Math.PI), b.push({
                distance: y,
                angleDelta: B
              }), M += B; y - b[0].distance > o;) M -= b.shift().angleDelta;
            if (M > u) return !1;
            m++, y += I.dist(D)
          }
          return !0
        }

        function $g(i) {
          let t = 0;
          for (let n = 0; n < i.length - 1; n++) t += i[n].dist(i[n + 1]);
          return t
        }

        function Wg(i, t, n) {
          return i ? .6 * t * n : 0
        }

        function Hg(i, t) {
          return Math.max(i ? i.right - i.left : 0, t ? t.right - t.left : 0)
        }

        function mb(i, t, n, o, u, _) {
          const m = Wg(n, u, _),
            y = Hg(n, o) * _;
          let b = 0;
          const M = $g(i) / 2;
          for (let I = 0; I < i.length - 1; I++) {
            const D = i[I],
              B = i[I + 1],
              V = D.dist(B);
            if (b + V > M) {
              const H = (M - b) / V,
                K = Yi.number(D.x, B.x, H),
                re = Yi.number(D.y, B.y, H),
                pe = new js(K, re, B.angleTo(D), I);
              return pe._round(), !m || Gg(i, pe, y, m, t) ? pe : void 0
            }
            b += V
          }
        }

        function gb(i, t, n, o, u, _, m, y, b) {
          const M = Wg(o, _, m),
            I = Hg(o, u),
            D = I * m,
            B = i[0].x === 0 || i[0].x === b || i[0].y === 0 || i[0].y === b;
          return t - D < t / 4 && (t = D + t / 4), Xg(i, B ? t / 2 * y % t : (I / 2 + 2 * _) * m * y % t, t, M, n, D, B, !1, b)
        }

        function Xg(i, t, n, o, u, _, m, y, b) {
          const M = _ / 2,
            I = $g(i);
          let D = 0,
            B = t - n,
            V = [];
          for (let H = 0; H < i.length - 1; H++) {
            const K = i[H],
              re = i[H + 1],
              pe = K.dist(re),
              Ne = re.angleTo(K);
            for (; B + n < D + pe;) {
              B += n;
              const be = (B - D) / pe,
                Ae = Yi.number(K.x, re.x, be),
                ot = Yi.number(K.y, re.y, be);
              if (Ae >= 0 && Ae < b && ot >= 0 && ot < b && B - M >= 0 && B + M <= I) {
                const gt = new js(Ae, ot, Ne, H);
                gt._round(), o && !Gg(i, gt, _, o, u) || V.push(gt)
              }
            }
            D += pe
          }
          return y || V.length || m || (V = Xg(i, D / 2, n, o, u, _, m, !0, b)), V
        }

        function Yg(i, t, n, o) {
          const u = [],
            _ = i.image,
            m = _.pixelRatio,
            y = _.paddedRect.w - 2,
            b = _.paddedRect.h - 2;
          let M = {
            x1: i.left,
            y1: i.top,
            x2: i.right,
            y2: i.bottom
          };
          const I = _.stretchX || [
              [0, y]
            ],
            D = _.stretchY || [
              [0, b]
            ],
            B = (jt, mn) => jt + mn[1] - mn[0],
            V = I.reduce(B, 0),
            H = D.reduce(B, 0),
            K = y - V,
            re = b - H;
          let pe = 0,
            Ne = V,
            be = 0,
            Ae = H,
            ot = 0,
            gt = K,
            er = 0,
            Pr = re;
          if (_.content && o) {
            const jt = _.content,
              mn = jt[2] - jt[0],
              xn = jt[3] - jt[1];
            (_.textFitWidth || _.textFitHeight) && (M = Tg(i)), pe = Kd(I, 0, jt[0]), be = Kd(D, 0, jt[1]), Ne = Kd(I, jt[0], jt[2]), Ae = Kd(D, jt[1], jt[3]), ot = jt[0] - pe, er = jt[1] - be, gt = mn - Ne, Pr = xn - Ae
          }
          const _r = M.x1,
            wr = M.y1,
            Jr = M.x2 - _r,
            xr = M.y2 - wr,
            kr = (jt, mn, xn, cn) => {
              const Hr = Jd(jt.stretch - pe, Ne, Jr, _r),
                Bn = Qd(jt.fixed - ot, gt, jt.stretch, V),
                yi = Jd(mn.stretch - be, Ae, xr, wr),
                Ri = Qd(mn.fixed - er, Pr, mn.stretch, H),
                aa = Jd(xn.stretch - pe, Ne, Jr, _r),
                Wa = Qd(xn.fixed - ot, gt, xn.stretch, V),
                Pa = Jd(cn.stretch - be, Ae, xr, wr),
                Ki = Qd(cn.fixed - er, Pr, cn.stretch, H),
                mi = new j(Hr, yi),
                Vi = new j(aa, yi),
                Ji = new j(aa, Pa),
                Qi = new j(Hr, Pa),
                wa = new j(Bn / m, Ri / m),
                Ha = new j(Wa / m, Ki / m),
                Ui = t * Math.PI / 180;
              if (Ui) {
                const Zi = Math.sin(Ui),
                  Gi = Math.cos(Ui),
                  zi = [Gi, -Zi, Zi, Gi];
                mi._matMult(zi), Vi._matMult(zi), Qi._matMult(zi), Ji._matMult(zi)
              }
              const Sa = jt.stretch + jt.fixed,
                ji = mn.stretch + mn.fixed;
              return {
                tl: mi,
                tr: Vi,
                bl: Qi,
                br: Ji,
                tex: {
                  x: _.paddedRect.x + 1 + Sa,
                  y: _.paddedRect.y + 1 + ji,
                  w: xn.stretch + xn.fixed - Sa,
                  h: cn.stretch + cn.fixed - ji
                },
                writingMode: void 0,
                glyphOffset: [0, 0],
                sectionIndex: 0,
                pixelOffsetTL: wa,
                pixelOffsetBR: Ha,
                minFontScaleX: gt / m / Jr,
                minFontScaleY: Pr / m / xr,
                isSDF: n
              }
            };
          if (o && (_.stretchX || _.stretchY)) {
            const jt = Kg(I, K, V),
              mn = Kg(D, re, H);
            for (let xn = 0; xn < jt.length - 1; xn++) {
              const cn = jt[xn],
                Hr = jt[xn + 1];
              for (let Bn = 0; Bn < mn.length - 1; Bn++) u.push(kr(cn, mn[Bn], Hr, mn[Bn + 1]))
            }
          } else u.push(kr({
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: y + 1
          }, {
            fixed: 0,
            stretch: b + 1
          }));
          return u
        }

        function Kd(i, t, n) {
          let o = 0;
          for (const u of i) o += Math.max(t, Math.min(n, u[1])) - Math.max(t, Math.min(n, u[0]));
          return o
        }

        function Kg(i, t, n) {
          const o = [{
            fixed: -1,
            stretch: 0
          }];
          for (const [u, _] of i) {
            const m = o[o.length - 1];
            o.push({
              fixed: u - m.stretch,
              stretch: m.stretch
            }), o.push({
              fixed: u - m.stretch,
              stretch: m.stretch + (_ - u)
            })
          }
          return o.push({
            fixed: t + 1,
            stretch: n
          }), o
        }

        function Jd(i, t, n, o) {
          return i / t * n + o
        }

        function Qd(i, t, n, o) {
          return i - t * n / o
        }
        Er("Anchor", js);
        class ep {
          constructor(t, n, o, u, _, m, y, b, M, I) {
            var D;
            if (this.boxStartIndex = t.length, M) {
              let B = m.top,
                V = m.bottom;
              const H = m.collisionPadding;
              H && (B -= H[1], V += H[3]);
              let K = V - B;
              K > 0 && (K = Math.max(10, K), this.circleDiameter = K)
            } else {
              const B = !((D = m.image) === null || D === void 0) && D.content && (m.image.textFitWidth || m.image.textFitHeight) ? Tg(m) : {
                x1: m.left,
                y1: m.top,
                x2: m.right,
                y2: m.bottom
              };
              B.y1 = B.y1 * y - b[0], B.y2 = B.y2 * y + b[2], B.x1 = B.x1 * y - b[3], B.x2 = B.x2 * y + b[1];
              const V = m.collisionPadding;
              if (V && (B.x1 -= V[0] * y, B.y1 -= V[1] * y, B.x2 += V[2] * y, B.y2 += V[3] * y), I) {
                const H = new j(B.x1, B.y1),
                  K = new j(B.x2, B.y1),
                  re = new j(B.x1, B.y2),
                  pe = new j(B.x2, B.y2),
                  Ne = I * Math.PI / 180;
                H._rotate(Ne), K._rotate(Ne), re._rotate(Ne), pe._rotate(Ne), B.x1 = Math.min(H.x, K.x, re.x, pe.x), B.x2 = Math.max(H.x, K.x, re.x, pe.x), B.y1 = Math.min(H.y, K.y, re.y, pe.y), B.y2 = Math.max(H.y, K.y, re.y, pe.y)
              }
              t.emplaceBack(n.x, n.y, B.x1, B.y1, B.x2, B.y2, o, u, _)
            }
            this.boxEndIndex = t.length
          }
        }
        class vb {
          constructor(t = [], n = (o, u) => o < u ? -1 : o > u ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = n, this.length > 0)
              for (let o = (this.length >> 1) - 1; o >= 0; o--) this._down(o)
          }
          push(t) {
            this.data.push(t), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0],
              n = this.data.pop();
            return --this.length > 0 && (this.data[0] = n, this._down(0)), t
          }
          peek() {
            return this.data[0]
          }
          _up(t) {
            const {
              data: n,
              compare: o
            } = this, u = n[t];
            for (; t > 0;) {
              const _ = t - 1 >> 1,
                m = n[_];
              if (o(u, m) >= 0) break;
              n[t] = m, t = _
            }
            n[t] = u
          }
          _down(t) {
            const {
              data: n,
              compare: o
            } = this, u = this.length >> 1, _ = n[t];
            for (; t < u;) {
              let m = 1 + (t << 1);
              const y = m + 1;
              if (y < this.length && o(n[y], n[m]) < 0 && (m = y), o(n[m], _) >= 0) break;
              n[t] = n[m], t = m
            }
            n[t] = _
          }
        }

        function yb(i, t = 1, n = !1) {
          const o = hl.fromPoints(i[0]),
            u = Math.min(o.width(), o.height());
          let _ = u / 2;
          const m = new vb([], xb),
            {
              minX: y,
              minY: b,
              maxX: M,
              maxY: I
            } = o;
          if (u === 0) return new j(y, b);
          for (let V = y; V < M; V += u)
            for (let H = b; H < I; H += u) m.push(new gc(V + _, H + _, _, i));
          let D = (function(V) {
              let H = 0,
                K = 0,
                re = 0;
              const pe = V[0];
              for (let Ne = 0, be = pe.length, Ae = be - 1; Ne < be; Ae = Ne++) {
                const ot = pe[Ne],
                  gt = pe[Ae],
                  er = ot.x * gt.y - gt.x * ot.y;
                K += (ot.x + gt.x) * er, re += (ot.y + gt.y) * er, H += 3 * er
              }
              return new gc(K / H, re / H, 0, V)
            })(i),
            B = m.length;
          for (; m.length;) {
            const V = m.pop();
            (V.d > D.d || !D.d) && (D = V, n && console.log("found best %d after %d probes", Math.round(1e4 * V.d) / 1e4, B)), V.max - D.d <= t || (_ = V.h / 2, m.push(new gc(V.p.x - _, V.p.y - _, _, i)), m.push(new gc(V.p.x + _, V.p.y - _, _, i)), m.push(new gc(V.p.x - _, V.p.y + _, _, i)), m.push(new gc(V.p.x + _, V.p.y + _, _, i)), B += 4)
          }
          return n && (console.log(`num probes: ${B}`), console.log(`best distance: ${D.d}`)), D.p
        }

        function xb(i, t) {
          return t.max - i.max
        }

        function gc(i, t, n, o) {
          this.p = new j(i, t), this.h = n, this.d = (function(u, _) {
            let m = !1,
              y = 1 / 0;
            for (let b = 0; b < _.length; b++) {
              const M = _[b];
              for (let I = 0, D = M.length, B = D - 1; I < D; B = I++) {
                const V = M[I],
                  H = M[B];
                V.y > u.y != H.y > u.y && u.x < (H.x - V.x) * (u.y - V.y) / (H.y - V.y) + V.x && (m = !m), y = Math.min(y, Rm(u, V, H))
              }
            }
            return (m ? 1 : -1) * Math.sqrt(y)
          })(this.p, o), this.max = this.d + this.h * Math.SQRT2
        }
        var ia;
        k.aI = void 0, (ia = k.aI || (k.aI = {}))[ia.center = 1] = "center", ia[ia.left = 2] = "left", ia[ia.right = 3] = "right", ia[ia.top = 4] = "top", ia[ia.bottom = 5] = "bottom", ia[ia["top-left"] = 6] = "top-left", ia[ia["top-right"] = 7] = "top-right", ia[ia["bottom-left"] = 8] = "bottom-left", ia[ia["bottom-right"] = 9] = "bottom-right";
        const Bf = Number.POSITIVE_INFINITY;

        function Jg(i, t) {
          return t[1] !== Bf ? (function(n, o, u) {
            let _ = 0,
              m = 0;
            switch (o = Math.abs(o), u = Math.abs(u), n) {
              case "top-right":
              case "top-left":
              case "top":
                m = u - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                m = 7 - u
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
              case "right":
                _ = -o;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                _ = o
            }
            return [_, m]
          })(i, t[0], t[1]) : (function(n, o) {
            let u = 0,
              _ = 0;
            o < 0 && (o = 0);
            const m = o / Math.SQRT2;
            switch (n) {
              case "top-right":
              case "top-left":
                _ = m - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                _ = 7 - m;
                break;
              case "bottom":
                _ = 7 - o;
                break;
              case "top":
                _ = o - 7
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
                u = -m;
                break;
              case "top-left":
              case "bottom-left":
                u = m;
                break;
              case "left":
                u = o;
                break;
              case "right":
                u = -o
            }
            return [u, _]
          })(i, t[0])
        }

        function Qg(i, t, n) {
          var o;
          const u = i.layout,
            _ = (o = u.get("text-variable-anchor-offset")) === null || o === void 0 ? void 0 : o.evaluate(t, {}, n);
          if (_) {
            const y = _.values,
              b = [];
            for (let M = 0; M < y.length; M += 2) {
              const I = b[M] = y[M],
                D = y[M + 1].map((B => B * Ni));
              I.startsWith("top") ? D[1] -= 7 : I.startsWith("bottom") && (D[1] += 7), b[M + 1] = D
            }
            return new kn(b)
          }
          const m = u.get("text-variable-anchor");
          if (m) {
            let y;
            y = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [u.get("text-radial-offset").evaluate(t, {}, n) * Ni, Bf] : u.get("text-offset").evaluate(t, {}, n).map((M => M * Ni));
            const b = [];
            for (const M of m) b.push(M, Jg(M, y));
            return new kn(b)
          }
          return null
        }

        function Of(i) {
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left"
          }
          return "center"
        }

        function bb(i, t, n, o, u, _, m, y, b, M, I, D) {
          let B = _.textMaxSize.evaluate(t, {});
          B === void 0 && (B = m);
          const V = i.layers[0].layout,
            H = V.get("icon-offset").evaluate(t, {}, I),
            K = tv(n.horizontal),
            re = m / 24,
            pe = i.tilePixelRatio * re,
            Ne = i.tilePixelRatio * B / 24,
            be = i.tilePixelRatio * y,
            Ae = i.tilePixelRatio * V.get("symbol-spacing"),
            ot = V.get("text-padding") * i.tilePixelRatio,
            gt = (function(xn, cn, Hr, Bn = 1) {
              const yi = xn.get("icon-padding").evaluate(cn, {}, Hr),
                Ri = yi && yi.values;
              return [Ri[0] * Bn, Ri[1] * Bn, Ri[2] * Bn, Ri[3] * Bn]
            })(V, t, I, i.tilePixelRatio),
            er = V.get("text-max-angle") / 180 * Math.PI,
            Pr = V.get("text-rotation-alignment") !== "viewport" && V.get("symbol-placement") !== "point",
            _r = V.get("icon-rotation-alignment") === "map" && V.get("symbol-placement") !== "point",
            wr = V.get("symbol-placement"),
            Jr = Ae / 2,
            xr = V.get("icon-text-fit");
          let kr;
          o && xr !== "none" && (i.allowVerticalPlacement && n.vertical && (kr = Pg(o, n.vertical, xr, V.get("icon-text-fit-padding"), H, re)), K && (o = Pg(o, K, xr, V.get("icon-text-fit-padding"), H, re)));
          const jt = I ? D.line.getGranularityForZoomLevel(I.z) : 1,
            mn = (xn, cn) => {
              cn.x < 0 || cn.x >= ct || cn.y < 0 || cn.y >= ct || (function(Hr, Bn, yi, Ri, aa, Wa, Pa, Ki, mi, Vi, Ji, Qi, wa, Ha, Ui, Sa, ji, Zi, Gi, zi, si, wo, vc, ko, Tb) {
                const yc = Hr.addToLineVertexArray(Bn, yi);
                let dl, xc, bc, wc, av = 0,
                  ov = 0,
                  sv = 0,
                  lv = 0,
                  Wf = -1,
                  Hf = -1;
                const cs = {};
                let cv = yo("");
                if (Hr.allowVerticalPlacement && Ri.vertical) {
                  const fa = Ki.layout.get("text-rotate").evaluate(si, {}, ko) + 90;
                  bc = new ep(mi, Bn, Vi, Ji, Qi, Ri.vertical, wa, Ha, Ui, fa), Pa && (wc = new ep(mi, Bn, Vi, Ji, Qi, Pa, ji, Zi, Ui, fa))
                }
                if (aa) {
                  const fa = Ki.layout.get("icon-rotate").evaluate(si, {}),
                    Xa = Ki.layout.get("icon-text-fit") !== "none",
                    pl = Yg(aa, fa, vc, Xa),
                    Po = Pa ? Yg(Pa, fa, vc, Xa) : void 0;
                  xc = new ep(mi, Bn, Vi, Ji, Qi, aa, ji, Zi, !1, fa), av = 4 * pl.length;
                  const fl = Hr.iconSizeData;
                  let jo = null;
                  fl.kind === "source" ? (jo = [ls * Ki.layout.get("icon-size").evaluate(si, {})], jo[0] > Ds && It(`${Hr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : fl.kind === "composite" && (jo = [ls * wo.compositeIconSizes[0].evaluate(si, {}, ko), ls * wo.compositeIconSizes[1].evaluate(si, {}, ko)], (jo[0] > Ds || jo[1] > Ds) && It(`${Hr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Hr.addSymbols(Hr.icon, pl, jo, zi, Gi, si, k.as.none, Bn, yc.lineStartIndex, yc.lineLength, -1, ko), Wf = Hr.icon.placedSymbolArray.length - 1, Po && (ov = 4 * Po.length, Hr.addSymbols(Hr.icon, Po, jo, zi, Gi, si, k.as.vertical, Bn, yc.lineStartIndex, yc.lineLength, -1, ko), Hf = Hr.icon.placedSymbolArray.length - 1)
                }
                const uv = Object.keys(Ri.horizontal);
                for (const fa of uv) {
                  const Xa = Ri.horizontal[fa];
                  if (!dl) {
                    cv = yo(Xa.text);
                    const Po = Ki.layout.get("text-rotate").evaluate(si, {}, ko);
                    dl = new ep(mi, Bn, Vi, Ji, Qi, Xa, wa, Ha, Ui, Po)
                  }
                  const pl = Xa.positionedLines.length === 1;
                  if (sv += ev(Hr, Bn, Xa, Wa, Ki, Ui, si, Sa, yc, Ri.vertical ? k.as.horizontal : k.as.horizontalOnly, pl ? uv : [fa], cs, Wf, wo, ko), pl) break
                }
                Ri.vertical && (lv += ev(Hr, Bn, Ri.vertical, Wa, Ki, Ui, si, Sa, yc, k.as.vertical, ["vertical"], cs, Hf, wo, ko));
                const Pb = dl ? dl.boxStartIndex : Hr.collisionBoxArray.length,
                  Sb = dl ? dl.boxEndIndex : Hr.collisionBoxArray.length,
                  Mb = bc ? bc.boxStartIndex : Hr.collisionBoxArray.length,
                  Ib = bc ? bc.boxEndIndex : Hr.collisionBoxArray.length,
                  Cb = xc ? xc.boxStartIndex : Hr.collisionBoxArray.length,
                  Ab = xc ? xc.boxEndIndex : Hr.collisionBoxArray.length,
                  zb = wc ? wc.boxStartIndex : Hr.collisionBoxArray.length,
                  Eb = wc ? wc.boxEndIndex : Hr.collisionBoxArray.length;
                let To = -1;
                const rp = (fa, Xa) => fa && fa.circleDiameter ? Math.max(fa.circleDiameter, Xa) : Xa;
                To = rp(dl, To), To = rp(bc, To), To = rp(xc, To), To = rp(wc, To);
                const hv = To > -1 ? 1 : 0;
                hv && (To *= Tb / Ni), Hr.glyphOffsetArray.length >= _c.MAX_GLYPHS && It("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), si.sortKey !== void 0 && Hr.addToSortKeyRanges(Hr.symbolInstances.length, si.sortKey);
                const Lb = Qg(Ki, si, ko),
                  [Db, Rb] = (function(fa, Xa) {
                    const pl = fa.length,
                      Po = Xa == null ? void 0 : Xa.values;
                    if ((Po == null ? void 0 : Po.length) > 0)
                      for (let fl = 0; fl < Po.length; fl += 2) {
                        const jo = Po[fl + 1];
                        fa.emplaceBack(k.aI[Po[fl]], jo[0], jo[1])
                      }
                    return [pl, fa.length]
                  })(Hr.textAnchorOffsets, Lb);
                Hr.symbolInstances.emplaceBack(Bn.x, Bn.y, cs.right >= 0 ? cs.right : -1, cs.center >= 0 ? cs.center : -1, cs.left >= 0 ? cs.left : -1, cs.vertical || -1, Wf, Hf, cv, Pb, Sb, Mb, Ib, Cb, Ab, zb, Eb, Vi, sv, lv, av, ov, hv, 0, wa, To, Db, Rb)
              })(i, cn, xn, n, o, u, kr, i.layers[0], i.collisionBoxArray, t.index, t.sourceLayerIndex, i.index, pe, [ot, ot, ot, ot], Pr, b, be, gt, _r, H, t, _, M, I, m)
            };
          if (wr === "line")
            for (const xn of Zg(t.geometry, 0, 0, ct, ct)) {
              const cn = ul(xn, jt),
                Hr = gb(cn, Ae, er, n.vertical || K, o, 24, Ne, i.overscaling, ct);
              for (const Bn of Hr) K && wb(i, K.text, Jr, Bn) || mn(cn, Bn)
            } else if (wr === "line-center") {
              for (const xn of t.geometry)
                if (xn.length > 1) {
                  const cn = ul(xn, jt),
                    Hr = mb(cn, er, n.vertical || K, o, 24, Ne);
                  Hr && mn(cn, Hr)
                }
            } else if (t.type === "Polygon")
            for (const xn of zl(t.geometry, 0)) {
              const cn = yb(xn, 16);
              mn(ul(xn[0], jt, !0), new js(cn.x, cn.y, 0))
            } else if (t.type === "LineString")
              for (const xn of t.geometry) {
                const cn = ul(xn, jt);
                mn(cn, new js(cn[0].x, cn[0].y, 0))
              } else if (t.type === "Point")
                for (const xn of t.geometry)
                  for (const cn of xn) mn([cn], new js(cn.x, cn.y, 0))
        }

        function ev(i, t, n, o, u, _, m, y, b, M, I, D, B, V, H) {
          const K = (function(Ne, be, Ae, ot, gt, er, Pr, _r) {
              const wr = ot.layout.get("text-rotate").evaluate(er, {}) * Math.PI / 180,
                Jr = [];
              for (const xr of be.positionedLines)
                for (const kr of xr.positionedGlyphs) {
                  if (!kr.rect) continue;
                  const jt = kr.rect || {};
                  let mn = 4,
                    xn = !0,
                    cn = 1,
                    Hr = 0;
                  const Bn = (gt || _r) && kr.vertical,
                    yi = kr.metrics.advance * kr.scale / 2;
                  if (_r && be.verticalizable && (Hr = xr.lineOffset / 2 - (kr.imageName ? -(Ni - kr.metrics.width * kr.scale) / 2 : (kr.scale - 1) * Ni)), kr.imageName) {
                    const Zi = Pr[kr.imageName];
                    xn = Zi.sdf, cn = Zi.pixelRatio, mn = 1 / cn
                  }
                  const Ri = gt ? [kr.x + yi, kr.y] : [0, 0];
                  let aa = gt ? [0, 0] : [kr.x + yi + Ae[0], kr.y + Ae[1] - Hr],
                    Wa = [0, 0];
                  Bn && (Wa = aa, aa = [0, 0]);
                  const Pa = kr.metrics.isDoubleResolution ? 2 : 1,
                    Ki = (kr.metrics.left - mn) * kr.scale - yi + aa[0],
                    mi = (-kr.metrics.top - mn) * kr.scale + aa[1],
                    Vi = Ki + jt.w / Pa * kr.scale / cn,
                    Ji = mi + jt.h / Pa * kr.scale / cn,
                    Qi = new j(Ki, mi),
                    wa = new j(Vi, mi),
                    Ha = new j(Ki, Ji),
                    Ui = new j(Vi, Ji);
                  if (Bn) {
                    const Zi = new j(-yi, yi - -17),
                      Gi = -Math.PI / 2,
                      zi = 12 - yi,
                      si = new j(22 - zi, -(kr.imageName ? zi : 0)),
                      wo = new j(...Wa);
                    Qi._rotateAround(Gi, Zi)._add(si)._add(wo), wa._rotateAround(Gi, Zi)._add(si)._add(wo), Ha._rotateAround(Gi, Zi)._add(si)._add(wo), Ui._rotateAround(Gi, Zi)._add(si)._add(wo)
                  }
                  if (wr) {
                    const Zi = Math.sin(wr),
                      Gi = Math.cos(wr),
                      zi = [Gi, -Zi, Zi, Gi];
                    Qi._matMult(zi), wa._matMult(zi), Ha._matMult(zi), Ui._matMult(zi)
                  }
                  const Sa = new j(0, 0),
                    ji = new j(0, 0);
                  Jr.push({
                    tl: Qi,
                    tr: wa,
                    bl: Ha,
                    br: Ui,
                    tex: jt,
                    writingMode: be.writingMode,
                    glyphOffset: Ri,
                    sectionIndex: kr.sectionIndex,
                    isSDF: xn,
                    pixelOffsetTL: Sa,
                    pixelOffsetBR: ji,
                    minFontScaleX: 0,
                    minFontScaleY: 0
                  })
                }
              return Jr
            })(0, n, y, u, _, m, o, i.allowVerticalPlacement),
            re = i.textSizeData;
          let pe = null;
          re.kind === "source" ? (pe = [ls * u.layout.get("text-size").evaluate(m, {})], pe[0] > Ds && It(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : re.kind === "composite" && (pe = [ls * V.compositeTextSizes[0].evaluate(m, {}, H), ls * V.compositeTextSizes[1].evaluate(m, {}, H)], (pe[0] > Ds || pe[1] > Ds) && It(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), i.addSymbols(i.text, K, pe, y, _, m, M, t, b.lineStartIndex, b.lineLength, B, H);
          for (const Ne of I) D[Ne] = i.text.placedSymbolArray.length - 1;
          return 4 * K.length
        }

        function tv(i) {
          for (const t in i) return i[t];
          return null
        }

        function wb(i, t, n, o) {
          const u = i.compareText;
          if (t in u) {
            const _ = u[t];
            for (let m = _.length - 1; m >= 0; m--)
              if (o.dist(_[m]) < n) return !0
          } else u[t] = [];
          return u[t].push(o), !1
        }
        const rv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class qf {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [n, o] = new Uint8Array(t, 0, 2);
            if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const u = o >> 4;
            if (u !== 1) throw new Error(`Got v${u} data when expected v1.`);
            const _ = rv[15 & o];
            if (!_) throw new Error("Unrecognized array type.");
            const [m] = new Uint16Array(t, 2, 1), [y] = new Uint32Array(t, 4, 1);
            return new qf(y, m, _, t)
          }
          constructor(t, n = 64, o = Float64Array, u) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = o, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const _ = rv.indexOf(this.ArrayType),
              m = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
              y = t * this.IndexArrayType.BYTES_PER_ELEMENT,
              b = (8 - y % 8) % 8;
            if (_ < 0) throw new Error(`Unexpected typed array class: ${o}.`);
            u && u instanceof ArrayBuffer ? (this.data = u, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + y + b, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + m + y + b), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + y + b, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + _]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t)
          }
          add(t, n) {
            const o = this._pos >> 1;
            return this.ids[o] = o, this.coords[this._pos++] = t, this.coords[this._pos++] = n, o
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return Nf(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this
          }
          range(t, n, o, u) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: _,
              coords: m,
              nodeSize: y
            } = this, b = [0, _.length - 1, 0], M = [];
            for (; b.length;) {
              const I = b.pop() || 0,
                D = b.pop() || 0,
                B = b.pop() || 0;
              if (D - B <= y) {
                for (let re = B; re <= D; re++) {
                  const pe = m[2 * re],
                    Ne = m[2 * re + 1];
                  pe >= t && pe <= o && Ne >= n && Ne <= u && M.push(_[re])
                }
                continue
              }
              const V = B + D >> 1,
                H = m[2 * V],
                K = m[2 * V + 1];
              H >= t && H <= o && K >= n && K <= u && M.push(_[V]), (I === 0 ? t <= H : n <= K) && (b.push(B), b.push(V - 1), b.push(1 - I)), (I === 0 ? o >= H : u >= K) && (b.push(V + 1), b.push(D), b.push(1 - I))
            }
            return M
          }
          within(t, n, o) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: u,
              coords: _,
              nodeSize: m
            } = this, y = [0, u.length - 1, 0], b = [], M = o * o;
            for (; y.length;) {
              const I = y.pop() || 0,
                D = y.pop() || 0,
                B = y.pop() || 0;
              if (D - B <= m) {
                for (let re = B; re <= D; re++) iv(_[2 * re], _[2 * re + 1], t, n) <= M && b.push(u[re]);
                continue
              }
              const V = B + D >> 1,
                H = _[2 * V],
                K = _[2 * V + 1];
              iv(H, K, t, n) <= M && b.push(u[V]), (I === 0 ? t - o <= H : n - o <= K) && (y.push(B), y.push(V - 1), y.push(1 - I)), (I === 0 ? t + o >= H : n + o >= K) && (y.push(V + 1), y.push(D), y.push(1 - I))
            }
            return b
          }
        }

        function Nf(i, t, n, o, u, _) {
          if (u - o <= n) return;
          const m = o + u >> 1;
          nv(i, t, m, o, u, _), Nf(i, t, n, o, m - 1, 1 - _), Nf(i, t, n, m + 1, u, 1 - _)
        }

        function nv(i, t, n, o, u, _) {
          for (; u > o;) {
            if (u - o > 600) {
              const M = u - o + 1,
                I = n - o + 1,
                D = Math.log(M),
                B = .5 * Math.exp(2 * D / 3),
                V = .5 * Math.sqrt(D * B * (M - B) / M) * (I - M / 2 < 0 ? -1 : 1);
              nv(i, t, n, Math.max(o, Math.floor(n - I * B / M + V)), Math.min(u, Math.floor(n + (M - I) * B / M + V)), _)
            }
            const m = t[2 * n + _];
            let y = o,
              b = u;
            for (Wu(i, t, o, n), t[2 * u + _] > m && Wu(i, t, o, u); y < b;) {
              for (Wu(i, t, y, b), y++, b--; t[2 * y + _] < m;) y++;
              for (; t[2 * b + _] > m;) b--
            }
            t[2 * o + _] === m ? Wu(i, t, o, b) : (b++, Wu(i, t, b, u)), b <= n && (o = b + 1), n <= b && (u = b - 1)
          }
        }

        function Wu(i, t, n, o) {
          Vf(i, n, o), Vf(t, 2 * n, 2 * o), Vf(t, 2 * n + 1, 2 * o + 1)
        }

        function Vf(i, t, n) {
          const o = i[t];
          i[t] = i[n], i[n] = o
        }

        function iv(i, t, n, o) {
          const u = i - n,
            _ = t - o;
          return u * u + _ * _
        }
        var Uf;
        k.cA = void 0, (Uf = k.cA || (k.cA = {})).create = "create", Uf.load = "load", Uf.fullLoad = "fullLoad";
        let tp = null,
          Hu = [];
        const Zf = 1e3 / 60,
          Gf = "loadTime",
          $f = "fullLoadTime",
          kb = {
            mark(i) {
              performance.mark(i)
            },
            frame(i) {
              const t = i;
              tp != null && Hu.push(t - tp), tp = t
            },
            clearMetrics() {
              tp = null, Hu = [], performance.clearMeasures(Gf), performance.clearMeasures($f);
              for (const i in k.cA) performance.clearMarks(k.cA[i])
            },
            getPerformanceMetrics() {
              performance.measure(Gf, k.cA.create, k.cA.load), performance.measure($f, k.cA.create, k.cA.fullLoad);
              const i = performance.getEntriesByName(Gf)[0].duration,
                t = performance.getEntriesByName($f)[0].duration,
                n = Hu.length,
                o = 1 / (Hu.reduce(((_, m) => _ + m), 0) / n / 1e3),
                u = Hu.filter((_ => _ > Zf)).reduce(((_, m) => _ + (m - Zf) / Zf), 0);
              return {
                loadTime: i,
                fullLoadTime: t,
                fps: o,
                percentDroppedFrames: u / (n + u) * 100,
                totalFrames: n
              }
            }
          };
        k.$ = gr, k.A = Pe, k.B = Is, k.C = function([i, t, n]) {
          return t += 90, t *= Math.PI / 180, n *= Math.PI / 180, {
            x: i * Math.cos(t) * Math.sin(n),
            y: i * Math.sin(t) * Math.sin(n),
            z: i * Math.cos(n)
          }
        }, k.D = Xr, k.E = he, k.F = Yi, k.G = Qn, k.H = rl, k.I = If, k.J = Lt, k.K = class {
          constructor(i, t) {
            this.target = i, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new pb((() => this.process())), this.subscription = Ht(this.target, "message", (n => this.receive(n)), !1), this.globalScope = yt(self) ? i : window
          }
          registerMessageHandler(i, t) {
            this.messageHandlers[i] = t
          }
          sendAsync(i, t) {
            return new Promise(((n, o) => {
              const u = Math.round(1e18 * Math.random()).toString(36).substring(0, 10),
                _ = t ? Ht(t.signal, "abort", (() => {
                  _ == null || _.unsubscribe(), delete this.resolveRejects[u];
                  const b = {
                    id: u,
                    type: "<cancel>",
                    origin: location.origin,
                    targetMapId: i.targetMapId,
                    sourceMapId: this.mapId
                  };
                  this.target.postMessage(b)
                }), fb) : null;
              this.resolveRejects[u] = {
                resolve: b => {
                  _ == null || _.unsubscribe(), n(b)
                },
                reject: b => {
                  _ == null || _.unsubscribe(), o(b)
                }
              };
              const m = [],
                y = Object.assign(Object.assign({}, i), {
                  id: u,
                  sourceMapId: this.mapId,
                  origin: location.origin,
                  data: mo(i.data, m)
                });
              this.target.postMessage(y, {
                transfer: m
              })
            }))
          }
          receive(i) {
            const t = i.data,
              n = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[n];
                const o = this.abortControllers[n];
                return delete this.abortControllers[n], void(o && o.abort())
              }
              if (yt(self) || t.mustQueue) return this.tasks[n] = t, this.taskQueue.push(n), void this.invoker.trigger();
              this.processTask(n, t)
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const i = this.taskQueue.shift(),
              t = this.tasks[i];
            delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(i, t)
          }
          processTask(i, t) {
            return l(this, void 0, void 0, (function*() {
              if (t.type === "<response>") {
                const u = this.resolveRejects[i];
                return delete this.resolveRejects[i], u ? void(t.error ? u.reject(nl(t.error)) : u.resolve(nl(t.data))) : void 0
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const n = nl(t.data),
                o = new AbortController;
              this.abortControllers[i] = o;
              try {
                const u = yield this.messageHandlers[t.type](t.sourceMapId, n, o);
                this.completeTask(i, null, u)
              } catch (u) {
                this.completeTask(i, u)
              }
            }))
          }
          completeTask(i, t, n) {
            const o = [];
            delete this.abortControllers[i];
            const u = {
              id: i,
              type: "<response>",
              sourceMapId: this.mapId,
              origin: location.origin,
              error: t ? mo(t) : null,
              data: mo(n, o)
            };
            this.target.postMessage(u, {
              transfer: o
            })
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe()
          }
        }, k.L = X, k.M = function() {
          var i = new Pe(16);
          return Pe != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i
        }, k.N = function(i, t, n) {
          var o, u, _, m, y, b, M, I, D, B, V, H, K = n[0],
            re = n[1],
            pe = n[2];
          return t === i ? (i[12] = t[0] * K + t[4] * re + t[8] * pe + t[12], i[13] = t[1] * K + t[5] * re + t[9] * pe + t[13], i[14] = t[2] * K + t[6] * re + t[10] * pe + t[14], i[15] = t[3] * K + t[7] * re + t[11] * pe + t[15]) : (u = t[1], _ = t[2], m = t[3], y = t[4], b = t[5], M = t[6], I = t[7], D = t[8], B = t[9], V = t[10], H = t[11], i[0] = o = t[0], i[1] = u, i[2] = _, i[3] = m, i[4] = y, i[5] = b, i[6] = M, i[7] = I, i[8] = D, i[9] = B, i[10] = V, i[11] = H, i[12] = o * K + y * re + D * pe + t[12], i[13] = u * K + b * re + B * pe + t[13], i[14] = _ * K + M * re + V * pe + t[14], i[15] = m * K + I * re + H * pe + t[15]), i
        }, k.O = function(i, t, n) {
          var o = n[0],
            u = n[1],
            _ = n[2];
          return i[0] = t[0] * o, i[1] = t[1] * o, i[2] = t[2] * o, i[3] = t[3] * o, i[4] = t[4] * u, i[5] = t[5] * u, i[6] = t[6] * u, i[7] = t[7] * u, i[8] = t[8] * _, i[9] = t[9] * _, i[10] = t[10] * _, i[11] = t[11] * _, i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i
        }, k.P = j, k.Q = function(i, t, n) {
          var o = t[0],
            u = t[1],
            _ = t[2],
            m = t[3],
            y = t[4],
            b = t[5],
            M = t[6],
            I = t[7],
            D = t[8],
            B = t[9],
            V = t[10],
            H = t[11],
            K = t[12],
            re = t[13],
            pe = t[14],
            Ne = t[15],
            be = n[0],
            Ae = n[1],
            ot = n[2],
            gt = n[3];
          return i[0] = be * o + Ae * y + ot * D + gt * K, i[1] = be * u + Ae * b + ot * B + gt * re, i[2] = be * _ + Ae * M + ot * V + gt * pe, i[3] = be * m + Ae * I + ot * H + gt * Ne, i[4] = (be = n[4]) * o + (Ae = n[5]) * y + (ot = n[6]) * D + (gt = n[7]) * K, i[5] = be * u + Ae * b + ot * B + gt * re, i[6] = be * _ + Ae * M + ot * V + gt * pe, i[7] = be * m + Ae * I + ot * H + gt * Ne, i[8] = (be = n[8]) * o + (Ae = n[9]) * y + (ot = n[10]) * D + (gt = n[11]) * K, i[9] = be * u + Ae * b + ot * B + gt * re, i[10] = be * _ + Ae * M + ot * V + gt * pe, i[11] = be * m + Ae * I + ot * H + gt * Ne, i[12] = (be = n[12]) * o + (Ae = n[13]) * y + (ot = n[14]) * D + (gt = n[15]) * K, i[13] = be * u + Ae * b + ot * B + gt * re, i[14] = be * _ + Ae * M + ot * V + gt * pe, i[15] = be * m + Ae * I + ot * H + gt * Ne, i
        }, k.R = Ta, k.S = function(i, t) {
          const n = {};
          for (let o = 0; o < t.length; o++) {
            const u = t[o];
            u in i && (n[u] = i[u])
          }
          return n
        }, k.T = vf, k.U = Rs, k.V = Bt, k.W = Dg, k.X = Lg, k.Y = de, k.Z = Fe, k._ = l, k.a = N, k.a$ = function(i, t, n) {
          return i[0] = t[0] * n[0], i[1] = t[1] * n[1], i[2] = t[2] * n[2], i[3] = t[3] * n[3], i
        }, k.a0 = $a, k.a1 = jg, k.a2 = Yd, k.a3 = ct, k.a4 = function(i, t) {
          var n, o, u, _, m;
          if (!i) return t ?? {};
          if (!t) return i;
          let y = Object.assign({}, i);
          if (t.removeAll && (y = {
              removeAll: !0
            }), t.remove) {
            const b = new Set(t.remove);
            y.add && (y.add = y.add.filter((I => !b.has(I.id)))), y.update && (y.update = y.update.filter((I => !b.has(I.id))));
            const M = new Set(((n = i.add) !== null && n !== void 0 ? n : []).map((I => I.id)));
            t.remove = t.remove.filter((I => !M.has(I)))
          }
          if (t.remove) {
            const b = new Set(y.remove ? y.remove.concat(t.remove) : t.remove);
            y.remove = Array.from(b.values())
          }
          if (t.add) {
            const b = y.add ? y.add.concat(t.add) : t.add,
              M = new Map(b.map((I => [I.id, I])));
            y.add = Array.from(M.values())
          }
          if (t.update) {
            const b = new Map((o = y.update) === null || o === void 0 ? void 0 : o.map((M => [M.id, M])));
            for (const M of t.update) {
              const I = (u = b.get(M.id)) !== null && u !== void 0 ? u : {
                id: M.id
              };
              M.newGeometry && (I.newGeometry = M.newGeometry), M.addOrUpdateProperties && (I.addOrUpdateProperties = ((_ = I.addOrUpdateProperties) !== null && _ !== void 0 ? _ : []).concat(M.addOrUpdateProperties)), M.removeProperties && (I.removeProperties = ((m = I.removeProperties) !== null && m !== void 0 ? m : []).concat(M.removeProperties)), M.removeAllProperties && (I.removeAllProperties = !0), b.set(M.id, I)
            }
            y.update = Array.from(b.values())
          }
          return y.remove && y.add && (y.remove = y.remove.filter((b => y.add.findIndex((M => M.id === b)) === -1))), y
        }, k.a5 = Gu, k.a6 = hl, k.a7 = 25, k.a8 = Ff, k.a9 = i => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise((n => {
            t.onloadstart = () => {
              n(t)
            };
            for (const o of i) {
              const u = window.document.createElement("source");
              je(o) || (t.crossOrigin = "Anonymous"), u.src = o, t.appendChild(u)
            }
          }))
        }, k.aA = Ke, k.aB = function(i, t, n, o) {
          const u = t.y - i.y,
            _ = t.x - i.x,
            m = o.y - n.y,
            y = o.x - n.x,
            b = m * _ - y * u;
          if (b === 0) return null;
          const M = (y * (i.y - n.y) - m * (i.x - n.x)) / b;
          return new j(i.x + M * _, i.y + M * u)
        }, k.aC = Zg, k.aD = Lm, k.aE = function(i) {
          let t = 1 / 0,
            n = 1 / 0,
            o = -1 / 0,
            u = -1 / 0;
          for (const _ of i) t = Math.min(t, _.x), n = Math.min(n, _.y), o = Math.max(o, _.x), u = Math.max(u, _.y);
          return [t, n, o, u]
        }, k.aF = Ni, k.aG = wt, k.aH = function(i, t, n, o, u = !1) {
          if (!n[0] && !n[1]) return [0, 0];
          const _ = u ? o === "map" ? -i.bearingInRadians : 0 : o === "viewport" ? i.bearingInRadians : 0;
          if (_) {
            const m = Math.sin(_),
              y = Math.cos(_);
            n = [n[0] * y - n[1] * m, n[0] * m + n[1] * y]
          }
          return [u ? n[0] : wt(t, n[0], i.zoom), u ? n[1] : wt(t, n[1], i.zoom)]
        }, k.aJ = zf, k.aK = Of, k.aL = Af, k.aM = qf, k.aN = wi, k.aO = Zd, k.aP = me, k.aQ = zn, k.aR = Nt, k.aS = Rr, k.aT = Fg, k.aU = Ce, k.aV = Ye, k.aW = function(i) {
          var t = new Pe(3);
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t
        }, k.aX = function(i, t, n) {
          return i[0] = t[0] - n[0], i[1] = t[1] - n[1], i[2] = t[2] - n[2], i
        }, k.aY = function(i, t) {
          var n = t[0],
            o = t[1],
            u = t[2],
            _ = n * n + o * o + u * u;
          return _ > 0 && (_ = 1 / Math.sqrt(_)), i[0] = t[0] * _, i[1] = t[1] * _, i[2] = t[2] * _, i
        }, k.aZ = Oe, k.a_ = function(i, t) {
          return i[0] * t[0] + i[1] * t[1] + i[2] * t[2]
        }, k.aa = $e, k.ab = function() {
          return He++
        }, k.ac = w, k.ad = _c, k.ae = Js, k.af = Ro, k.ag = Ng, k.ah = function(i) {
          const t = {};
          if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((n, o, u, _) => {
              const m = u || _;
              return t[o] = !m || m.toLowerCase(), ""
            })), t["max-age"]) {
            const n = parseInt(t["max-age"], 10);
            isNaN(n) ? delete t["max-age"] : t["max-age"] = n
          }
          return t
        }, k.ai = Kt, k.aj = 85.051129, k.ak = Sr, k.al = function(i) {
          return Math.pow(2, i)
        }, k.am = et, k.an = Rg, k.ao = function(i) {
          return Math.log(i) / Math.LN2
        }, k.ap = function(i) {
          var t = i[0],
            n = i[1];
          return t * t + n * n
        }, k.aq = function(i) {
          if (!i.length) return new Set;
          const t = Math.max(...i.map((b => b.canonical.z)));
          let n = 1 / 0,
            o = -1 / 0,
            u = 1 / 0,
            _ = -1 / 0;
          const m = [];
          for (const b of i) {
            const {
              x: M,
              y: I,
              z: D
            } = b.canonical, B = Math.pow(2, t - D), V = M * B, H = I * B;
            m.push({
              id: b,
              x: V,
              y: H
            }), V < n && (n = V), V > o && (o = V), H < u && (u = H), H > _ && (_ = H)
          }
          const y = new Set;
          for (const b of m) b.x !== n && b.x !== o && b.y !== u && b.y !== _ || y.add(b.id);
          return y
        }, k.ar = function(i, t) {
          let n = 0,
            o = 0;
          if (i.kind === "constant") o = i.layoutSize;
          else if (i.kind !== "source") {
            const {
              interpolationType: u,
              minZoom: _,
              maxZoom: m
            } = i, y = u ? Kt(On.interpolationFactor(u, t, _, m), 0, 1) : 0;
            i.kind === "camera" ? o = Yi.number(i.minSize, i.maxSize, y) : n = y
          }
          return {
            uSizeT: n,
            uSize: o
          }
        }, k.at = function(i, {
          uSize: t,
          uSizeT: n
        }, {
          lowerSize: o,
          upperSize: u
        }) {
          return i.kind === "source" ? o / ls : i.kind === "composite" ? Yi.number(o / ls, u / ls, n) : t
        }, k.au = function(i, t) {
          var n = t[0],
            o = t[1],
            u = t[2],
            _ = t[3],
            m = t[4],
            y = t[5],
            b = t[6],
            M = t[7],
            I = t[8],
            D = t[9],
            B = t[10],
            V = t[11],
            H = t[12],
            K = t[13],
            re = t[14],
            pe = t[15],
            Ne = n * y - o * m,
            be = n * b - u * m,
            Ae = n * M - _ * m,
            ot = o * b - u * y,
            gt = o * M - _ * y,
            er = u * M - _ * b,
            Pr = I * K - D * H,
            _r = I * re - B * H,
            wr = I * pe - V * H,
            Jr = D * re - B * K,
            xr = D * pe - V * K,
            kr = B * pe - V * re,
            jt = Ne * kr - be * xr + Ae * Jr + ot * wr - gt * _r + er * Pr;
          return jt ? (i[0] = (y * kr - b * xr + M * Jr) * (jt = 1 / jt), i[1] = (u * xr - o * kr - _ * Jr) * jt, i[2] = (K * er - re * gt + pe * ot) * jt, i[3] = (B * gt - D * er - V * ot) * jt, i[4] = (b * wr - m * kr - M * _r) * jt, i[5] = (n * kr - u * wr + _ * _r) * jt, i[6] = (re * Ae - H * er - pe * be) * jt, i[7] = (I * er - B * Ae + V * be) * jt, i[8] = (m * xr - y * wr + M * Pr) * jt, i[9] = (o * wr - n * xr - _ * Pr) * jt, i[10] = (H * gt - K * Ae + pe * Ne) * jt, i[11] = (D * Ae - I * gt - V * Ne) * jt, i[12] = (y * _r - m * Jr - b * Pr) * jt, i[13] = (n * Jr - o * _r + u * Pr) * jt, i[14] = (K * be - H * ot - re * Ne) * jt, i[15] = (I * ot - D * be + B * Ne) * jt, i) : null
        }, k.av = Jt, k.aw = function(i) {
          var t = i[0],
            n = i[1];
          return Math.sqrt(t * t + n * n)
        }, k.ax = function(i) {
          return i[0] = 0, i[1] = 0, i
        }, k.ay = function(i, t, n) {
          return i[0] = t[0] * n, i[1] = t[1] * n, i
        }, k.az = Ef, k.b = st, k.b$ = function(i, t, n) {
          var o = t[0],
            u = t[1],
            _ = t[2];
          return i[0] = o * n[0] + u * n[3] + _ * n[6], i[1] = o * n[1] + u * n[4] + _ * n[7], i[2] = o * n[2] + u * n[5] + _ * n[8], i
        }, k.b0 = ve, k.b1 = function(i, t, n) {
          const o = t[0] * n[0] + t[1] * n[1] + t[2] * n[2];
          return o === 0 ? null : (-(i[0] * n[0] + i[1] * n[1] + i[2] * n[2]) - n[3]) / o
        }, k.b2 = Ue, k.b3 = function(i, t, n) {
          return i[0] = t[0] * n, i[1] = t[1] * n, i[2] = t[2] * n, i[3] = t[3] * n, i
        }, k.b4 = function(i, t) {
          return i[0] * t[0] + i[1] * t[1] + i[2] * t[2] + i[3]
        }, k.b5 = Og, k.b6 = mc, k.b7 = function(i, t, n, o, u) {
          var _ = 1 / Math.tan(t / 2);
          if (i[0] = _ / n, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = _, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, u != null && u !== 1 / 0) {
            var m = 1 / (o - u);
            i[10] = (u + o) * m, i[14] = 2 * u * o * m
          } else i[10] = -1, i[14] = -2 * o;
          return i
        }, k.b8 = function(i) {
          var t = new Pe(16);
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], t
        }, k.b9 = function(i, t, n) {
          var o = Math.sin(n),
            u = Math.cos(n),
            _ = t[0],
            m = t[1],
            y = t[2],
            b = t[3],
            M = t[4],
            I = t[5],
            D = t[6],
            B = t[7];
          return t !== i && (i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = _ * u + M * o, i[1] = m * u + I * o, i[2] = y * u + D * o, i[3] = b * u + B * o, i[4] = M * u - _ * o, i[5] = I * u - m * o, i[6] = D * u - y * o, i[7] = B * u - b * o, i
        }, k.bA = function(i, t, n, o) {
          var u = [],
            _ = [];
          return u[0] = t[0] - n[0], u[1] = t[1] - n[1], u[2] = t[2] - n[2], _[0] = u[0], _[1] = u[1] * Math.cos(o) - u[2] * Math.sin(o), _[2] = u[1] * Math.sin(o) + u[2] * Math.cos(o), i[0] = _[0] + n[0], i[1] = _[1] + n[1], i[2] = _[2] + n[2], i
        }, k.bB = function(i, t, n, o) {
          var u = [],
            _ = [];
          return u[0] = t[0] - n[0], u[1] = t[1] - n[1], u[2] = t[2] - n[2], _[0] = u[2] * Math.sin(o) + u[0] * Math.cos(o), _[1] = u[1], _[2] = u[2] * Math.cos(o) - u[0] * Math.sin(o), i[0] = _[0] + n[0], i[1] = _[1] + n[1], i[2] = _[2] + n[2], i
        }, k.bC = function(i, t, n) {
          var o = Math.sin(n),
            u = Math.cos(n),
            _ = t[0],
            m = t[1],
            y = t[2],
            b = t[3],
            M = t[8],
            I = t[9],
            D = t[10],
            B = t[11];
          return t !== i && (i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = _ * u - M * o, i[1] = m * u - I * o, i[2] = y * u - D * o, i[3] = b * u - B * o, i[8] = _ * o + M * u, i[9] = m * o + I * u, i[10] = y * o + D * u, i[11] = b * o + B * u, i
        }, k.bD = function(i, t) {
          const n = ft(i, 360),
            o = ft(t, 360),
            u = o - n,
            _ = o > n ? u - 360 : u + 360;
          return Math.abs(u) < Math.abs(_) ? u : _
        }, k.bE = function(i) {
          return i[0] = 0, i[1] = 0, i[2] = 0, i
        }, k.bF = function(i, t, n, o) {
          const u = Math.sqrt(i * i + t * t),
            _ = Math.sqrt(n * n + o * o);
          i /= u, t /= u, n /= _, o /= _;
          const m = Math.acos(i * n + t * o);
          return -t * n + i * o > 0 ? m : -m
        }, k.bG = function(i, t) {
          const n = ft(i, 2 * Math.PI),
            o = ft(t, 2 * Math.PI);
          return Math.min(Math.abs(n - o), Math.abs(n - o + 2 * Math.PI), Math.abs(n - o - 2 * Math.PI))
        }, k.bH = function() {
          const i = {},
            t = Q.$version;
          for (const n in Q.$root) {
            const o = Q.$root[n];
            if (o.required) {
              let u = null;
              u = n === "version" ? t : o.type === "array" ? [] : {}, u != null && (i[n] = u)
            }
          }
          return i
        }, k.bI = yu, k.bJ = le, k.bK = function i(t, n) {
          if (Array.isArray(t)) {
            if (!Array.isArray(n) || t.length !== n.length) return !1;
            for (let o = 0; o < t.length; o++)
              if (!i(t[o], n[o])) return !1;
            return !0
          }
          if (typeof t == "object" && t !== null && n !== null) {
            if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length) return !1;
            for (const o in t)
              if (!i(t[o], n[o])) return !1;
            return !0
          }
          return t === n
        }, k.bL = function(i) {
          i = i.slice();
          const t = Object.create(null);
          for (let n = 0; n < i.length; n++) t[i[n].id] = i[n];
          for (let n = 0; n < i.length; n++) "ref" in i[n] && (i[n] = vt(i[n], t[i[n].ref]));
          return i
        }, k.bM = function(i, t) {
          if (i.type === "custom") return new db(i, t);
          switch (i.type) {
            case "background":
              return new hb(i, t);
            case "circle":
              return new Yy(i, t);
            case "color-relief":
              return new rx(i, t);
            case "fill":
              return new gx(i, t);
            case "fill-extrusion":
              return new Ix(i, t);
            case "heatmap":
              return new Jy(i, t);
            case "hillshade":
              return new ex(i, t);
            case "line":
              return new Rx(i, t);
            case "raster":
              return new cf(i, t);
            case "symbol":
              return new Xd(i, t)
          }
        }, k.bN = i => i.type === "raster", k.bO = kt, k.bP = function(i, t) {
          if (!i) return [{
            command: "setStyle",
            args: [t]
          }];
          let n = [];
          try {
            if (!Qe(i.version, t.version)) return [{
              command: "setStyle",
              args: [t]
            }];
            Qe(i.center, t.center) || n.push({
              command: "setCenter",
              args: [t.center]
            }), Qe(i.state, t.state) || n.push({
              command: "setGlobalState",
              args: [t.state]
            }), Qe(i.centerAltitude, t.centerAltitude) || n.push({
              command: "setCenterAltitude",
              args: [t.centerAltitude]
            }), Qe(i.zoom, t.zoom) || n.push({
              command: "setZoom",
              args: [t.zoom]
            }), Qe(i.bearing, t.bearing) || n.push({
              command: "setBearing",
              args: [t.bearing]
            }), Qe(i.pitch, t.pitch) || n.push({
              command: "setPitch",
              args: [t.pitch]
            }), Qe(i.roll, t.roll) || n.push({
              command: "setRoll",
              args: [t.roll]
            }), Qe(i.sprite, t.sprite) || n.push({
              command: "setSprite",
              args: [t.sprite]
            }), Qe(i.glyphs, t.glyphs) || n.push({
              command: "setGlyphs",
              args: [t.glyphs]
            }), Qe(i.transition, t.transition) || n.push({
              command: "setTransition",
              args: [t.transition]
            }), Qe(i.light, t.light) || n.push({
              command: "setLight",
              args: [t.light]
            }), Qe(i.terrain, t.terrain) || n.push({
              command: "setTerrain",
              args: [t.terrain]
            }), Qe(i.sky, t.sky) || n.push({
              command: "setSky",
              args: [t.sky]
            }), Qe(i.projection, t.projection) || n.push({
              command: "setProjection",
              args: [t.projection]
            });
            const o = {},
              u = [];
            (function(m, y, b, M) {
              let I;
              for (I in y = y || {}, m = m || {}) Object.prototype.hasOwnProperty.call(m, I) && (Object.prototype.hasOwnProperty.call(y, I) || Je(I, b, M));
              for (I in y) Object.prototype.hasOwnProperty.call(y, I) && (Object.prototype.hasOwnProperty.call(m, I) ? Qe(m[I], y[I]) || (m[I].type === "geojson" && y[I].type === "geojson" && Dt(m, y, I) ? oe(b, {
                command: "setGeoJSONSourceData",
                args: [I, y[I].data]
              }) : Tt(I, y, b, M)) : De(I, y, b))
            })(i.sources, t.sources, u, o);
            const _ = [];
            i.layers && i.layers.forEach((m => {
              "source" in m && o[m.source] ? n.push({
                command: "removeLayer",
                args: [m.id]
              }) : _.push(m)
            })), n = n.concat(u), (function(m, y, b) {
              y = y || [];
              const M = (m = m || []).map(zt),
                I = y.map(zt),
                D = m.reduce(Yt, {}),
                B = y.reduce(Yt, {}),
                V = M.slice(),
                H = Object.create(null);
              let K, re, pe, Ne, be;
              for (let Ae = 0, ot = 0; Ae < M.length; Ae++) K = M[Ae], Object.prototype.hasOwnProperty.call(B, K) ? ot++ : (oe(b, {
                command: "removeLayer",
                args: [K]
              }), V.splice(V.indexOf(K, ot), 1));
              for (let Ae = 0, ot = 0; Ae < I.length; Ae++) K = I[I.length - 1 - Ae], V[V.length - 1 - Ae] !== K && (Object.prototype.hasOwnProperty.call(D, K) ? (oe(b, {
                command: "removeLayer",
                args: [K]
              }), V.splice(V.lastIndexOf(K, V.length - ot), 1)) : ot++, Ne = V[V.length - Ae], oe(b, {
                command: "addLayer",
                args: [B[K], Ne]
              }), V.splice(V.length - Ae, 0, K), H[K] = !0);
              for (let Ae = 0; Ae < I.length; Ae++)
                if (K = I[Ae], re = D[K], pe = B[K], !H[K] && !Qe(re, pe))
                  if (Qe(re.source, pe.source) && Qe(re["source-layer"], pe["source-layer"]) && Qe(re.type, pe.type)) {
                    for (be in _t(re.layout, pe.layout, b, K, null, "setLayoutProperty"), _t(re.paint, pe.paint, b, K, null, "setPaintProperty"), Qe(re.filter, pe.filter) || oe(b, {
                        command: "setFilter",
                        args: [K, pe.filter]
                      }), Qe(re.minzoom, pe.minzoom) && Qe(re.maxzoom, pe.maxzoom) || oe(b, {
                        command: "setLayerZoomRange",
                        args: [K, pe.minzoom, pe.maxzoom]
                      }), re) Object.prototype.hasOwnProperty.call(re, be) && be !== "layout" && be !== "paint" && be !== "filter" && be !== "metadata" && be !== "minzoom" && be !== "maxzoom" && (be.indexOf("paint.") === 0 ? _t(re[be], pe[be], b, K, be.slice(6), "setPaintProperty") : Qe(re[be], pe[be]) || oe(b, {
                      command: "setLayerProperty",
                      args: [K, be, pe[be]]
                    }));
                    for (be in pe) Object.prototype.hasOwnProperty.call(pe, be) && !Object.prototype.hasOwnProperty.call(re, be) && be !== "layout" && be !== "paint" && be !== "filter" && be !== "metadata" && be !== "minzoom" && be !== "maxzoom" && (be.indexOf("paint.") === 0 ? _t(re[be], pe[be], b, K, be.slice(6), "setPaintProperty") : Qe(re[be], pe[be]) || oe(b, {
                      command: "setLayerProperty",
                      args: [K, be, pe[be]]
                    }))
                  } else oe(b, {
                    command: "removeLayer",
                    args: [K]
                  }), Ne = V[V.lastIndexOf(K) + 1], oe(b, {
                    command: "addLayer",
                    args: [pe, Ne]
                  })
            })(_, t.layers, n)
          } catch (o) {
            console.warn("Unable to compute style diff:", o), n = [{
              command: "setStyle",
              args: [t]
            }]
          }
          return n
        }, k.bQ = function(i) {
          const t = [],
            n = i.id;
          return n === void 0 && t.push({
            message: `layers.${n}: missing required property "id"`
          }), i.render === void 0 && t.push({
            message: `layers.${n}: missing required method "render"`
          }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && t.push({
            message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"`
          }), t
        }, k.bR = Ot, k.bS = Gt, k.bT = class extends ba {
          constructor(i, t) {
            super(i, t), this.current = 0
          }
          set(i) {
            this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i))
          }
        }, k.bU = Lo, k.bV = class extends ba {
          constructor(i, t) {
            super(i, t), this.current = ll
          }
          set(i) {
            if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
            for (let t = 1; t < 16; t++)
              if (i[t] !== this.current[t]) {
                this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
                break
              }
          }
        }, k.bW = xo, k.bX = class extends ba {
          constructor(i, t) {
            super(i, t), this.current = [0, 0, 0]
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]))
          }
        }, k.bY = class extends ba {
          constructor(i, t) {
            super(i, t), this.current = [0, 0]
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]))
          }
        }, k.bZ = Ge, k.b_ = function(i, t) {
          var n = Math.sin(t),
            o = Math.cos(t);
          return i[0] = o, i[1] = n, i[2] = 0, i[3] = -n, i[4] = o, i[5] = 0, i[6] = 0, i[7] = 0, i[8] = 1, i
        }, k.ba = function(i, t, n) {
          var o = Math.sin(n),
            u = Math.cos(n),
            _ = t[4],
            m = t[5],
            y = t[6],
            b = t[7],
            M = t[8],
            I = t[9],
            D = t[10],
            B = t[11];
          return t !== i && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[4] = _ * u + M * o, i[5] = m * u + I * o, i[6] = y * u + D * o, i[7] = b * u + B * o, i[8] = M * u - _ * o, i[9] = I * u - m * o, i[10] = D * u - y * o, i[11] = B * u - b * o, i
        }, k.bb = function() {
          const i = new Float32Array(16);
          return et(i), i
        }, k.bc = function() {
          const i = new Float64Array(16);
          return et(i), i
        }, k.bd = function() {
          return new Float64Array(16)
        }, k.be = function(i, t, n) {
          const o = new Float64Array(4);
          return Ft(o, i, t - 90, n), o
        }, k.bf = function(i, t, n, o) {
          var u, _, m, y, b, M = t[0],
            I = t[1],
            D = t[2],
            B = t[3],
            V = n[0],
            H = n[1],
            K = n[2],
            re = n[3];
          return (_ = M * V + I * H + D * K + B * re) < 0 && (_ = -_, V = -V, H = -H, K = -K, re = -re), 1 - _ > Re ? (u = Math.acos(_), m = Math.sin(u), y = Math.sin((1 - o) * u) / m, b = Math.sin(o * u) / m) : (y = 1 - o, b = o), i[0] = y * M + b * V, i[1] = y * I + b * H, i[2] = y * D + b * K, i[3] = y * B + b * re, i
        }, k.bg = function(i) {
          const t = new Float64Array(9);
          var n, o, u, _, m, y, b, M, I, D, B, V, H, K, re, pe, Ne, be;
          D = (u = (o = i)[0]) * (b = u + u), B = (_ = o[1]) * b, H = (m = o[2]) * b, K = m * (M = _ + _), pe = (y = o[3]) * b, Ne = y * M, be = y * (I = m + m), (n = t)[0] = 1 - (V = _ * M) - (re = m * I), n[3] = B - be, n[6] = H + Ne, n[1] = B + be, n[4] = 1 - D - re, n[7] = K - pe, n[2] = H - Ne, n[5] = K + pe, n[8] = 1 - D - V;
          const Ae = Rr(-Math.asin(Kt(t[2], -1, 1)));
          let ot, gt;
          return Math.hypot(t[5], t[8]) < .001 ? (ot = 0, gt = -Rr(Math.atan2(t[3], t[4]))) : (ot = Rr(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), gt = Rr(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), {
            roll: ot,
            pitch: Ae + 90,
            bearing: gt
          }
        }, k.bh = function(i, t) {
          return i.roll == t.roll && i.pitch == t.pitch && i.bearing == t.bearing
        }, k.bi = Nr, k.bj = pa, k.bk = hc, k.bl = Ou, k.bm = uc, k.bn = $t, k.bo = Et, k.bp = $n, k.bq = function(i, t, n, o, u) {
          return $t(o, u, Kt((i - t) / (n - t), 0, 1))
        }, k.br = ft, k.bs = function() {
          return new Float64Array(3)
        }, k.bt = function(i, t, n, o) {
          return i[0] = t[0] + n[0] * o, i[1] = t[1] + n[1] * o, i[2] = t[2] + n[2] * o, i
        }, k.bu = Ft, k.bv = function(i, t, n) {
          var o = n[0],
            u = n[1],
            _ = n[2],
            m = n[3],
            y = t[0],
            b = t[1],
            M = t[2],
            I = u * M - _ * b,
            D = _ * y - o * M,
            B = o * b - u * y;
          return i[0] = y + m * (I += I) + u * (B += B) - _ * (D += D), i[1] = b + m * D + _ * I - o * B, i[2] = M + m * B + o * D - u * I, i
        }, k.bw = function(i, t, n) {
          const o = (u = [i[0], i[1], i[2], t[0], t[1], t[2], n[0], n[1], n[2]])[0] * ((I = u[8]) * (m = u[4]) - (y = u[5]) * (M = u[7])) + u[1] * (-I * (_ = u[3]) + y * (b = u[6])) + u[2] * (M * _ - m * b);
          var u, _, m, y, b, M, I;
          if (o === 0) return null;
          const D = Oe([], [t[0], t[1], t[2]], [n[0], n[1], n[2]]),
            B = Oe([], [n[0], n[1], n[2]], [i[0], i[1], i[2]]),
            V = Oe([], [i[0], i[1], i[2]], [t[0], t[1], t[2]]),
            H = Ce([], D, -i[3]);
          return Ye(H, H, Ce([], B, -t[3])), Ye(H, H, Ce([], V, -n[3])), Ce(H, H, 1 / o), H
        }, k.bx = jf, k.by = function() {
          return new Float64Array(4)
        }, k.bz = function(i, t, n, o) {
          var u = [],
            _ = [];
          return u[0] = t[0] - n[0], u[1] = t[1] - n[1], u[2] = t[2] - n[2], _[0] = u[0] * Math.cos(o) - u[1] * Math.sin(o), _[1] = u[0] * Math.sin(o) + u[1] * Math.cos(o), _[2] = u[2], i[0] = _[0] + n[0], i[1] = _[1] + n[1], i[2] = _[2] + n[2], i
        }, k.c = ue, k.c0 = function(i, t, n, o, u, _, m) {
          var y = 1 / (t - n),
            b = 1 / (o - u),
            M = 1 / (_ - m);
          return i[0] = -2 * y, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * b, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * M, i[11] = 0, i[12] = (t + n) * y, i[13] = (u + o) * b, i[14] = (m + _) * M, i[15] = 1, i
        }, k.c1 = class extends ba {
          constructor(i, t) {
            super(i, t), this.current = new Array
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const t = new Float32Array(4 * i.length);
              for (let n = 0; n < i.length; n++) t[4 * n] = i[n].r, t[4 * n + 1] = i[n].g, t[4 * n + 2] = i[n].b, t[4 * n + 3] = i[n].a;
              this.gl.uniform4fv(this.location, t)
            }
          }
        }, k.c2 = class extends ba {
          constructor(i, t) {
            super(i, t), this.current = new Array
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const t = new Float32Array(i);
              this.gl.uniform1fv(this.location, t)
            }
          }
        }, k.c3 = class extends rs {}, k.c4 = Ox, k.c5 = class extends nc {}, k.c6 = gf, k.c7 = function(i) {
          return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2))
        }, k.c8 = Um, k.c9 = function(i, t, n) {
          var o = t[0],
            u = t[1],
            _ = t[2],
            m = n[3] * o + n[7] * u + n[11] * _ + n[15];
          return i[0] = (n[0] * o + n[4] * u + n[8] * _ + n[12]) / (m = m || 1), i[1] = (n[1] * o + n[5] * u + n[9] * _ + n[13]) / m, i[2] = (n[2] * o + n[6] * u + n[10] * _ + n[14]) / m, i
        }, k.cB = function(i) {
          return i.message === Xt
        }, k.cC = te, k.cD = function(i, t) {
          N.REGISTERED_PROTOCOLS[i] = t
        }, k.cE = function(i) {
          delete N.REGISTERED_PROTOCOLS[i]
        }, k.cF = function(i, t) {
          const n = {};
          for (let u = 0; u < i.length; u++) {
            const _ = t && t[i[u].id] || ud(i[u]);
            t && (t[i[u].id] = _);
            let m = n[_];
            m || (m = n[_] = []), m.push(i[u])
          }
          const o = [];
          for (const u in n) o.push(n[u]);
          return o
        }, k.cG = Er, k.cH = qg, k.cI = Vg, k.cJ = vg, k.cK = function(i) {
          i.bucket.createArrays(), i.bucket.tilePixelRatio = ct / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
          const t = i.bucket.layers[0],
            n = t.layout,
            o = t._unevaluatedLayout._values,
            u = {
              layoutIconSize: o["icon-size"].possiblyEvaluate(new Qn(i.bucket.zoom + 1), i.canonical),
              layoutTextSize: o["text-size"].possiblyEvaluate(new Qn(i.bucket.zoom + 1), i.canonical),
              textMaxSize: o["text-size"].possiblyEvaluate(new Qn(18))
            };
          if (i.bucket.textSizeData.kind === "composite") {
            const {
              minZoom: M,
              maxZoom: I
            } = i.bucket.textSizeData;
            u.compositeTextSizes = [o["text-size"].possiblyEvaluate(new Qn(M), i.canonical), o["text-size"].possiblyEvaluate(new Qn(I), i.canonical)]
          }
          if (i.bucket.iconSizeData.kind === "composite") {
            const {
              minZoom: M,
              maxZoom: I
            } = i.bucket.iconSizeData;
            u.compositeIconSizes = [o["icon-size"].possiblyEvaluate(new Qn(M), i.canonical), o["icon-size"].possiblyEvaluate(new Qn(I), i.canonical)]
          }
          const _ = n.get("text-line-height") * Ni,
            m = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point",
            y = n.get("text-keep-upright"),
            b = n.get("text-size");
          for (const M of i.bucket.features) {
            const I = n.get("text-font").evaluate(M, {}, i.canonical).join(","),
              D = b.evaluate(M, {}, i.canonical),
              B = u.layoutTextSize.evaluate(M, {}, i.canonical),
              V = u.layoutIconSize.evaluate(M, {}, i.canonical),
              H = {
                horizontal: {},
                vertical: void 0
              },
              K = M.text;
            let re, pe = [0, 0];
            if (K) {
              const Ae = K.toString(),
                ot = n.get("text-letter-spacing").evaluate(M, {}, i.canonical) * Ni,
                gt = bu(Ae) ? ot : 0,
                er = n.get("text-anchor").evaluate(M, {}, i.canonical),
                Pr = Qg(t, M, i.canonical);
              if (!Pr) {
                const xr = n.get("text-radial-offset").evaluate(M, {}, i.canonical);
                pe = xr ? Jg(er, [xr * Ni, Bf]) : n.get("text-offset").evaluate(M, {}, i.canonical).map((kr => kr * Ni))
              }
              let _r = m ? "center" : n.get("text-justify").evaluate(M, {}, i.canonical);
              const wr = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(M, {}, i.canonical) * Ni : 1 / 0,
                Jr = () => {
                  i.bucket.allowVerticalPlacement && xu(Ae) && (H.vertical = $d(K, i.glyphMap, i.glyphPositions, i.imagePositions, I, wr, _, er, "left", gt, pe, k.as.vertical, !0, B, D))
                };
              if (!m && Pr) {
                const xr = new Set;
                if (_r === "auto")
                  for (let jt = 0; jt < Pr.values.length; jt += 2) xr.add(Of(Pr.values[jt]));
                else xr.add(_r);
                let kr = !1;
                for (const jt of xr)
                  if (!H.horizontal[jt])
                    if (kr) H.horizontal[jt] = H.horizontal[0];
                    else {
                      const mn = $d(K, i.glyphMap, i.glyphPositions, i.imagePositions, I, wr, _, "center", jt, gt, pe, k.as.horizontal, !1, B, D);
                      mn && (H.horizontal[jt] = mn, kr = mn.positionedLines.length === 1)
                    } Jr()
              } else {
                _r === "auto" && (_r = Of(er));
                const xr = $d(K, i.glyphMap, i.glyphPositions, i.imagePositions, I, wr, _, er, _r, gt, pe, k.as.horizontal, !1, B, D);
                xr && (H.horizontal[_r] = xr), Jr(), xu(Ae) && m && y && (H.vertical = $d(K, i.glyphMap, i.glyphPositions, i.imagePositions, I, wr, _, er, _r, gt, pe, k.as.vertical, !1, B, D))
              }
            }
            let Ne = !1;
            if (M.icon && M.icon.name) {
              const Ae = i.imageMap[M.icon.name];
              Ae && (re = sb(i.imagePositions[M.icon.name], n.get("icon-offset").evaluate(M, {}, i.canonical), n.get("icon-anchor").evaluate(M, {}, i.canonical)), Ne = !!Ae.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = Ne : i.bucket.sdfIcons !== Ne && It("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ae.pixelRatio !== i.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0))
            }
            const be = tv(H.horizontal) || H.vertical;
            i.bucket.iconsInText = !!be && be.iconsInText, (be || re) && bb(i.bucket, M, H, re, i.imageMap, u, B, V, pe, Ne, i.canonical, i.subdivisionGranularity)
          }
          i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers()
        }, k.cL = wf, k.cM = Tf, k.cN = Pf, k.cO = ig, k.cP = Mf, k.cQ = class {
          constructor(i) {
            this._marks = {
              start: [i.url, "start"].join("#"),
              end: [i.url, "end"].join("#"),
              measure: i.url.toString()
            }, performance.mark(this._marks.start)
          }
          finish() {
            performance.mark(this._marks.end);
            let i = performance.getEntriesByName(this._marks.measure);
            return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i
          }
        }, k.cR = function(i, t, n, o, u) {
          return l(this, void 0, void 0, (function*() {
            if (Fe()) try {
              return yield gr(i, t, n, o, u)
            } catch {}
            return (function(_, m, y, b, M) {
              const I = _.width,
                D = _.height;
              dr && pr || (dr = new OffscreenCanvas(I, D), pr = dr.getContext("2d", {
                willReadFrequently: !0
              })), dr.width = I, dr.height = D, pr.drawImage(_, 0, 0, I, D);
              const B = pr.getImageData(m, y, b, M);
              return pr.clearRect(0, 0, I, D), B.data
            })(i, t, n, o, u)
          }))
        }, k.cS = $m, k.cT = W, k.cU = ng, k.cV = dc, k.cW = Yo, k.cX = function(i, t) {
          const n = new Map;
          if (i != null)
            if (i.type === "Feature") n.set($u(i, t), i);
            else
              for (const o of i.features) n.set($u(o, t), o);
          return n
        }, k.cY = function(i, t) {
          if (i == null) return !0;
          if (i.type === "Feature") return $u(i, t) != null;
          if (i.type === "FeatureCollection") {
            const n = new Set;
            for (const o of i.features) {
              const u = $u(o, t);
              if (u == null || n.has(u)) return !1;
              n.add(u)
            }
            return !0
          }
          return !1
        }, k.cZ = function(i, t, n) {
          var o, u, _, m;
          if (t.removeAll && i.clear(), t.remove)
            for (const y of t.remove) i.delete(y);
          if (t.add)
            for (const y of t.add) {
              const b = $u(y, n);
              b != null && i.set(b, y)
            }
          if (t.update)
            for (const y of t.update) {
              let b = i.get(y.id);
              if (b == null) continue;
              const M = !y.removeAllProperties && (((o = y.removeProperties) === null || o === void 0 ? void 0 : o.length) > 0 || ((u = y.addOrUpdateProperties) === null || u === void 0 ? void 0 : u.length) > 0);
              if ((y.newGeometry || y.removeAllProperties || M) && (b = Object.assign({}, b), i.set(y.id, b), M && (b.properties = Object.assign({}, b.properties))), y.newGeometry && (b.geometry = y.newGeometry), y.removeAllProperties) b.properties = {};
              else if (((_ = y.removeProperties) === null || _ === void 0 ? void 0 : _.length) > 0)
                for (const I of y.removeProperties) Object.prototype.hasOwnProperty.call(b.properties, I) && delete b.properties[I];
              if (((m = y.addOrUpdateProperties) === null || m === void 0 ? void 0 : m.length) > 0)
                for (const {
                    key: I,
                    value: D
                  }
                  of y.addOrUpdateProperties) b.properties[I] = D
            }
        }, k.c_ = go, k.ca = class extends Mu {}, k.cb = class extends h {}, k.cc = function(i, t) {
          return i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3] && i[4] === t[4] && i[5] === t[5] && i[6] === t[6] && i[7] === t[7] && i[8] === t[8] && i[9] === t[9] && i[10] === t[10] && i[11] === t[11] && i[12] === t[12] && i[13] === t[13] && i[14] === t[14] && i[15] === t[15]
        }, k.cd = function(i, t) {
          var n = i[0],
            o = i[1],
            u = i[2],
            _ = i[3],
            m = i[4],
            y = i[5],
            b = i[6],
            M = i[7],
            I = i[8],
            D = i[9],
            B = i[10],
            V = i[11],
            H = i[12],
            K = i[13],
            re = i[14],
            pe = i[15],
            Ne = t[0],
            be = t[1],
            Ae = t[2],
            ot = t[3],
            gt = t[4],
            er = t[5],
            Pr = t[6],
            _r = t[7],
            wr = t[8],
            Jr = t[9],
            xr = t[10],
            kr = t[11],
            jt = t[12],
            mn = t[13],
            xn = t[14],
            cn = t[15];
          return Math.abs(n - Ne) <= Re * Math.max(1, Math.abs(n), Math.abs(Ne)) && Math.abs(o - be) <= Re * Math.max(1, Math.abs(o), Math.abs(be)) && Math.abs(u - Ae) <= Re * Math.max(1, Math.abs(u), Math.abs(Ae)) && Math.abs(_ - ot) <= Re * Math.max(1, Math.abs(_), Math.abs(ot)) && Math.abs(m - gt) <= Re * Math.max(1, Math.abs(m), Math.abs(gt)) && Math.abs(y - er) <= Re * Math.max(1, Math.abs(y), Math.abs(er)) && Math.abs(b - Pr) <= Re * Math.max(1, Math.abs(b), Math.abs(Pr)) && Math.abs(M - _r) <= Re * Math.max(1, Math.abs(M), Math.abs(_r)) && Math.abs(I - wr) <= Re * Math.max(1, Math.abs(I), Math.abs(wr)) && Math.abs(D - Jr) <= Re * Math.max(1, Math.abs(D), Math.abs(Jr)) && Math.abs(B - xr) <= Re * Math.max(1, Math.abs(B), Math.abs(xr)) && Math.abs(V - kr) <= Re * Math.max(1, Math.abs(V), Math.abs(kr)) && Math.abs(H - jt) <= Re * Math.max(1, Math.abs(H), Math.abs(jt)) && Math.abs(K - mn) <= Re * Math.max(1, Math.abs(K), Math.abs(mn)) && Math.abs(re - xn) <= Re * Math.max(1, Math.abs(re), Math.abs(xn)) && Math.abs(pe - cn) <= Re * Math.max(1, Math.abs(pe), Math.abs(cn))
        }, k.ce = function(i, t) {
          return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i
        }, k.cf = i => i.type === "symbol", k.cg = i => i.type === "circle", k.ch = i => i.type === "heatmap", k.ci = i => i.type === "line", k.cj = i => i.type === "fill", k.ck = i => i.type === "fill-extrusion", k.cl = i => i.type === "hillshade", k.cm = i => i.type === "color-relief", k.cn = i => i.type === "background", k.co = i => i.type === "custom", k.cp = Qt, k.cq = function(i, t, n) {
          const o = Mt(t.x - n.x, t.y - n.y),
            u = Mt(i.x - n.x, i.y - n.y);
          var _, m;
          return Rr(Math.atan2(o[0] * u[1] - o[1] * u[0], (_ = o)[0] * (m = u)[0] + _[1] * m[1]))
        }, k.cr = vr, k.cs = function(i, t) {
          return Tr[t] && (i instanceof MouseEvent || i instanceof WheelEvent)
        }, k.ct = function(i, t) {
          return Vt[t] && "touches" in i
        }, k.cu = function(i) {
          return Vt[i] || Tr[i]
        }, k.cv = function(i, t, n) {
          var o = t[0],
            u = t[1];
          return i[0] = n[0] * o + n[4] * u + n[12], i[1] = n[1] * o + n[5] * u + n[13], i
        }, k.cw = function(i, t) {
          const {
            x: n,
            y: o
          } = Gu.fromLngLat(t);
          return !(i < 0 || i > 25 || o < 0 || o >= 1 || n < 0 || n >= 1)
        }, k.cx = function(i, t) {
          return i[0] = t[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = t[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
        }, k.cy = class extends Ql {}, k.cz = kb, k.d = je, k.e = it, k.f = i => l(void 0, void 0, void 0, (function*() {
          if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(i)], {
            type: "image/png"
          });
          try {
            return createImageBitmap(t)
          } catch (n) {
            throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
          }
        })), k.g = q, k.h = i => new Promise(((t, n) => {
          const o = new Image;
          o.onload = () => {
            t(o), URL.revokeObjectURL(o.src), o.onload = null, window.requestAnimationFrame((() => {
              o.src = lr
            }))
          }, o.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const u = new Blob([new Uint8Array(i)], {
            type: "image/png"
          });
          o.src = i.byteLength ? URL.createObjectURL(u) : lr
        })), k.i = yt, k.j = (i, t) => xe(it(i, {
          type: "json"
        }), t), k.k = Xe, k.l = rt, k.m = xe, k.n = (i, t) => xe(it(i, {
          type: "arrayBuffer"
        }), t), k.o = function(i) {
          return new Mf(i).readFields(Yx, [])
        }, k.p = gg, k.q = Du, k.r = na, k.s = Ht, k.t = Q, k.u = Dn, k.v = yd, k.w = It, k.x = Ad, k.y = of, k.z = bd
      })), A("worker", ["./shared"], (function(k) {
        class l {
          constructor(N, q) {
            this.keyCache = {}, N && this.replace(N, q)
          }
          replace(N, q) {
            this._layerConfigs = {}, this._layers = {}, this.update(N, [], q)
          }
          update(N, q, X) {
            for (const le of N) {
              this._layerConfigs[le.id] = le;
              const xe = this._layers[le.id] = k.bM(le, X);
              xe._featureFilter = k.ae(xe.filter, X), this.keyCache[le.id] && delete this.keyCache[le.id]
            }
            for (const le of q) delete this.keyCache[le], delete this._layerConfigs[le], delete this._layers[le];
            this.familiesBySource = {};
            const te = k.cF(Object.values(this._layerConfigs), this.keyCache);
            for (const le of te) {
              const xe = le.map((he => this._layers[he.id])),
                je = xe[0];
              if (je.visibility === "none") continue;
              const Ie = je.source || "";
              let qe = this.familiesBySource[Ie];
              qe || (qe = this.familiesBySource[Ie] = {});
              const rt = je.sourceLayer || "_geojsonTileLayer";
              let Xe = qe[rt];
              Xe || (Xe = qe[rt] = []), Xe.push(xe)
            }
          }
        }
        class j {
          constructor(N) {
            const q = {},
              X = [];
            for (const je in N) {
              const Ie = N[je],
                qe = q[je] = {};
              for (const rt in Ie) {
                const Xe = Ie[+rt];
                if (!Xe || Xe.bitmap.width === 0 || Xe.bitmap.height === 0) continue;
                const he = {
                  x: 0,
                  y: 0,
                  w: Xe.bitmap.width + 2,
                  h: Xe.bitmap.height + 2
                };
                X.push(he), qe[rt] = {
                  rect: he,
                  metrics: Xe.metrics
                }
              }
            }
            const {
              w: te,
              h: le
            } = k.p(X), xe = new k.q({
              width: te || 1,
              height: le || 1
            });
            for (const je in N) {
              const Ie = N[je];
              for (const qe in Ie) {
                const rt = Ie[+qe];
                if (!rt || rt.bitmap.width === 0 || rt.bitmap.height === 0) continue;
                const Xe = q[je][qe].rect;
                k.q.copy(rt.bitmap, xe, {
                  x: 0,
                  y: 0
                }, {
                  x: Xe.x + 1,
                  y: Xe.y + 1
                }, rt.bitmap)
              }
            }
            this.image = xe, this.positions = q
          }
        }
        k.cG("GlyphAtlas", j);
        class W {
          constructor(N) {
            this.tileID = new k.a0(N.tileID.overscaledZ, N.tileID.wrap, N.tileID.canonical.z, N.tileID.canonical.x, N.tileID.canonical.y), this.uid = N.uid, this.zoom = N.zoom, this.pixelRatio = N.pixelRatio, this.tileSize = N.tileSize, this.source = N.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = N.showCollisionBoxes, this.collectResourceTiming = !!N.collectResourceTiming, this.returnDependencies = !!N.returnDependencies, this.promoteId = N.promoteId, this.inFlightDependencies = []
          }
          parse(N, q, X, te, le) {
            return k._(this, void 0, void 0, (function*() {
              this.status = "parsing", this.data = N, this.collisionBoxArray = new k.ac;
              const xe = new k.cH(Object.keys(N.layers).sort()),
                je = new k.cI(this.tileID, this.promoteId);
              je.bucketLayerIDs = [];
              const Ie = {},
                qe = {
                  featureIndex: je,
                  iconDependencies: {},
                  patternDependencies: {},
                  glyphDependencies: {},
                  dashDependencies: {},
                  availableImages: X,
                  subdivisionGranularity: le
                },
                rt = q.familiesBySource[this.source];
              for (const $e in rt) {
                const Ct = N.layers[$e];
                if (!Ct) continue;
                Ct.version === 1 && k.w(`Vector tile source "${this.source}" layer "${$e}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const ir = xe.encode($e),
                  Fr = [];
                for (let br = 0; br < Ct.length; br++) {
                  const nt = Ct.feature(br),
                    cr = je.getId(nt, $e);
                  Fr.push({
                    feature: nt,
                    id: cr,
                    index: br,
                    sourceLayerIndex: ir
                  })
                }
                for (const br of rt[$e]) {
                  const nt = br[0];
                  nt.source !== this.source && k.w(`layer.source = ${nt.source} does not equal this.source = ${this.source}`), nt.isHidden(this.zoom, !0) || ($(br, this.zoom, X), (Ie[nt.id] = nt.createBucket({
                    index: je.bucketLayerIDs.length,
                    layers: br,
                    zoom: this.zoom,
                    pixelRatio: this.pixelRatio,
                    overscaling: this.overscaling,
                    collisionBoxArray: this.collisionBoxArray,
                    sourceLayerIndex: ir,
                    sourceID: this.source
                  })).populate(Fr, qe, this.tileID.canonical), je.bucketLayerIDs.push(br.map((cr => cr.id))))
                }
              }
              const Xe = k.bR(qe.glyphDependencies, ($e => Object.keys($e).map(Number)));
              this.inFlightDependencies.forEach(($e => $e == null ? void 0 : $e.abort())), this.inFlightDependencies = [];
              let he = Promise.resolve({});
              if (Object.keys(Xe).length) {
                const $e = new AbortController;
                this.inFlightDependencies.push($e), he = te.sendAsync({
                  type: "GG",
                  data: {
                    stacks: Xe,
                    source: this.source,
                    tileID: this.tileID,
                    type: "glyphs"
                  }
                }, $e)
              }
              const Q = Object.keys(qe.iconDependencies);
              let Ze = Promise.resolve({});
              if (Q.length) {
                const $e = new AbortController;
                this.inFlightDependencies.push($e), Ze = te.sendAsync({
                  type: "GI",
                  data: {
                    icons: Q,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                  }
                }, $e)
              }
              const vt = Object.keys(qe.patternDependencies);
              let Qe = Promise.resolve({});
              if (vt.length) {
                const $e = new AbortController;
                this.inFlightDependencies.push($e), Qe = te.sendAsync({
                  type: "GI",
                  data: {
                    icons: vt,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                  }
                }, $e)
              }
              const oe = qe.dashDependencies;
              let De = Promise.resolve({});
              if (Object.keys(oe).length) {
                const $e = new AbortController;
                this.inFlightDependencies.push($e), De = te.sendAsync({
                  type: "GDA",
                  data: {
                    dashes: oe
                  }
                }, $e)
              }
              const [Je, Tt, Dt, _t] = yield Promise.all([he, Ze, Qe, De]), zt = new j(Je), Yt = new k.cJ(Tt, Dt);
              for (const $e in Ie) {
                const Ct = Ie[$e];
                Ct instanceof k.ad ? ($(Ct.layers, this.zoom, X), k.cK({
                  bucket: Ct,
                  glyphMap: Je,
                  glyphPositions: zt.positions,
                  imageMap: Tt,
                  imagePositions: Yt.iconPositions,
                  showCollisionBoxes: this.showCollisionBoxes,
                  canonical: this.tileID.canonical,
                  subdivisionGranularity: qe.subdivisionGranularity
                })) : Ct.hasDependencies && (Ct instanceof k.cL || Ct instanceof k.cM || Ct instanceof k.cN) && ($(Ct.layers, this.zoom, X), Ct.addFeatures(qe, this.tileID.canonical, Yt.patternPositions, _t))
              }
              return this.status = "done", {
                buckets: Object.values(Ie).filter(($e => !$e.isEmpty())),
                featureIndex: je,
                collisionBoxArray: this.collisionBoxArray,
                glyphAtlasImage: zt.image,
                imageAtlas: Yt,
                dashPositions: _t,
                glyphMap: this.returnDependencies ? Je : null,
                iconMap: this.returnDependencies ? Tt : null,
                glyphPositions: this.returnDependencies ? zt.positions : null
              }
            }))
          }
        }

        function $(ue, N, q) {
          const X = new k.G(N);
          for (const te of ue) te.recalculate(X, q)
        }
        class J {
          constructor(N, q, X) {
            this.actor = N, this.layerIndex = q, this.availableImages = X, this.fetching = {}, this.loading = {}, this.loaded = {}
          }
          loadVectorTile(N, q) {
            return k._(this, void 0, void 0, (function*() {
              const X = yield k.n(N.request, q);
              try {
                return {
                  vectorTile: new k.cO(new k.cP(X.data)),
                  rawData: X.data,
                  cacheControl: X.cacheControl,
                  expires: X.expires
                }
              } catch (te) {
                const le = new Uint8Array(X.data);
                let xe = `Unable to parse the tile at ${N.request.url}, `;
                throw xe += le[0] === 31 && le[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${te.message}`, new Error(xe)
              }
            }))
          }
          loadTile(N) {
            return k._(this, void 0, void 0, (function*() {
              const q = N.uid,
                X = !!(N && N.request && N.request.collectResourceTiming) && new k.cQ(N.request),
                te = new W(N);
              this.loading[q] = te;
              const le = new AbortController;
              te.abort = le;
              try {
                const xe = yield this.loadVectorTile(N, le);
                if (delete this.loading[q], !xe) return null;
                const je = xe.rawData,
                  Ie = {};
                xe.expires && (Ie.expires = xe.expires), xe.cacheControl && (Ie.cacheControl = xe.cacheControl);
                const qe = {};
                if (X) {
                  const Xe = X.finish();
                  Xe && (qe.resourceTiming = JSON.parse(JSON.stringify(Xe)))
                }
                te.vectorTile = xe.vectorTile;
                const rt = te.parse(xe.vectorTile, this.layerIndex, this.availableImages, this.actor, N.subdivisionGranularity);
                this.loaded[q] = te, this.fetching[q] = {
                  rawTileData: je,
                  cacheControl: Ie,
                  resourceTiming: qe
                };
                try {
                  const Xe = yield rt;
                  return k.e({
                    rawTileData: je.slice(0)
                  }, Xe, Ie, qe)
                } finally {
                  delete this.fetching[q]
                }
              } catch (xe) {
                throw delete this.loading[q], te.status = "done", this.loaded[q] = te, xe
              }
            }))
          }
          reloadTile(N) {
            return k._(this, void 0, void 0, (function*() {
              const q = N.uid;
              if (!this.loaded || !this.loaded[q]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const X = this.loaded[q];
              if (X.showCollisionBoxes = N.showCollisionBoxes, X.status === "parsing") {
                const te = yield X.parse(X.vectorTile, this.layerIndex, this.availableImages, this.actor, N.subdivisionGranularity);
                let le;
                if (this.fetching[q]) {
                  const {
                    rawTileData: xe,
                    cacheControl: je,
                    resourceTiming: Ie
                  } = this.fetching[q];
                  delete this.fetching[q], le = k.e({
                    rawTileData: xe.slice(0)
                  }, te, je, Ie)
                } else le = te;
                return le
              }
              if (X.status === "done" && X.vectorTile) return X.parse(X.vectorTile, this.layerIndex, this.availableImages, this.actor, N.subdivisionGranularity)
            }))
          }
          abortTile(N) {
            return k._(this, void 0, void 0, (function*() {
              const q = this.loading,
                X = N.uid;
              q && q[X] && q[X].abort && (q[X].abort.abort(), delete q[X])
            }))
          }
          removeTile(N) {
            return k._(this, void 0, void 0, (function*() {
              this.loaded && this.loaded[N.uid] && delete this.loaded[N.uid]
            }))
          }
        }
        class ce {
          constructor() {
            this.loaded = {}
          }
          loadTile(N) {
            return k._(this, void 0, void 0, (function*() {
              const {
                uid: q,
                encoding: X,
                rawImageData: te,
                redFactor: le,
                greenFactor: xe,
                blueFactor: je,
                baseShift: Ie
              } = N, qe = te.width + 2, rt = te.height + 2, Xe = k.b(te) ? new k.R({
                width: qe,
                height: rt
              }, yield k.cR(te, -1, -1, qe, rt)) : te, he = new k.cS(q, Xe, X, le, xe, je, Ie);
              return this.loaded = this.loaded || {}, this.loaded[q] = he, he
            }))
          }
          removeTile(N) {
            const q = this.loaded,
              X = N.uid;
            q && q[X] && delete q[X]
          }
        }
        var ge, fe, Z = (function() {
            if (fe) return ge;

            function ue(q, X) {
              if (q.length !== 0) {
                N(q[0], X);
                for (var te = 1; te < q.length; te++) N(q[te], !X)
              }
            }

            function N(q, X) {
              for (var te = 0, le = 0, xe = 0, je = q.length, Ie = je - 1; xe < je; Ie = xe++) {
                var qe = (q[xe][0] - q[Ie][0]) * (q[Ie][1] + q[xe][1]),
                  rt = te + qe;
                le += Math.abs(te) >= Math.abs(qe) ? te - rt + qe : qe - rt + te, te = rt
              }
              te + le >= 0 != !!X && q.reverse()
            }
            return fe = 1, ge = function q(X, te) {
              var le, xe = X && X.type;
              if (xe === "FeatureCollection")
                for (le = 0; le < X.features.length; le++) q(X.features[le], te);
              else if (xe === "GeometryCollection")
                for (le = 0; le < X.geometries.length; le++) q(X.geometries[le], te);
              else if (xe === "Feature") q(X.geometry, te);
              else if (xe === "Polygon") ue(X.coordinates, te);
              else if (xe === "MultiPolygon")
                for (le = 0; le < X.coordinates.length; le++) ue(X.coordinates[le], te);
              return X
            }
          })(),
          de = k.cT(Z);
        class Fe extends k.cV {
          constructor(N, q) {
            super(new k.cP, 0, q, [], []), this.feature = N, this.type = N.type, this.properties = N.tags ? N.tags : {}, "id" in N && (typeof N.id == "string" ? this.id = parseInt(N.id, 10) : typeof N.id != "number" || isNaN(N.id) || (this.id = N.id))
          }
          loadGeometry() {
            const N = [],
              q = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const X of q) {
              const te = [];
              for (const le of X) te.push(new k.P(le[0], le[1]));
              N.push(te)
            }
            return N
          }
        }
        class Re extends k.cU {
          constructor(N, q) {
            super(new k.cP), this.layers = {
              _geojsonTileLayer: this
            }, this.name = "_geojsonTileLayer", this.version = q ? q.version : 1, this.extent = q ? q.extent : 4096, this.length = N.length, this.features = N
          }
          feature(N) {
            return new Fe(this.features[N], this.extent)
          }
        }

        function Pe(ue, N) {
          N.writeVarintField(15, ue.version || 1), N.writeStringField(1, ue.name || ""), N.writeVarintField(5, ue.extent || 4096);
          const q = {
            keys: [],
            values: [],
            keycache: {},
            valuecache: {}
          };
          for (let le = 0; le < ue.length; le++) q.feature = ue.feature(le), N.writeMessage(2, Ge, q);
          const X = q.keys;
          for (const le of X) N.writeStringField(3, le);
          const te = q.values;
          for (const le of te) N.writeMessage(4, Ye, le)
        }

        function Ge(ue, N) {
          if (!ue.feature) return;
          const q = ue.feature;
          q.id !== void 0 && N.writeVarintField(1, q.id), N.writeMessage(2, et, ue), N.writeVarintField(3, q.type), N.writeMessage(4, Me, q)
        }

        function et(ue, N) {
          var q;
          for (const X in (q = ue.feature) == null ? void 0 : q.properties) {
            let te = ue.feature.properties[X],
              le = ue.keycache[X];
            if (te === null) continue;
            le === void 0 && (ue.keys.push(X), le = ue.keys.length - 1, ue.keycache[X] = le), N.writeVarint(le), typeof te != "string" && typeof te != "boolean" && typeof te != "number" && (te = JSON.stringify(te));
            const xe = typeof te + ":" + te;
            let je = ue.valuecache[xe];
            je === void 0 && (ue.values.push(te), je = ue.values.length - 1, ue.valuecache[xe] = je), N.writeVarint(je)
          }
        }

        function Ve(ue, N) {
          return (N << 3) + (7 & ue)
        }

        function ve(ue) {
          return ue << 1 ^ ue >> 31
        }

        function Me(ue, N) {
          const q = ue.loadGeometry(),
            X = ue.type;
          let te = 0,
            le = 0;
          for (const xe of q) {
            let je = 1;
            X === 1 && (je = xe.length), N.writeVarint(Ve(1, je));
            const Ie = X === 3 ? xe.length - 1 : xe.length;
            for (let qe = 0; qe < Ie; qe++) {
              qe === 1 && X !== 1 && N.writeVarint(Ve(2, Ie - 1));
              const rt = xe[qe].x - te,
                Xe = xe[qe].y - le;
              N.writeVarint(ve(rt)), N.writeVarint(ve(Xe)), te += rt, le += Xe
            }
            ue.type === 3 && N.writeVarint(Ve(7, 1))
          }
        }

        function Ye(ue, N) {
          const q = typeof ue;
          q === "string" ? N.writeStringField(1, ue) : q === "boolean" ? N.writeBooleanField(7, ue) : q === "number" && (ue % 1 != 0 ? N.writeDoubleField(3, ue) : ue < 0 ? N.writeSVarintField(6, ue) : N.writeVarintField(5, ue))
        }
        const Ce = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: ue => ue
          },
          Oe = Math.fround || (ut = new Float32Array(1), ue => (ut[0] = +ue, ut[0]));
        var ut;
        class Ue {
          constructor(N) {
            this.options = Object.assign(Object.create(Ce), N), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []
          }
          load(N) {
            const {
              log: q,
              minZoom: X,
              maxZoom: te
            } = this.options;
            q && console.time("total time");
            const le = `prepare ${N.length} points`;
            q && console.time(le), this.points = N;
            const xe = [];
            for (let Ie = 0; Ie < N.length; Ie++) {
              const qe = N[Ie];
              if (!qe.geometry) continue;
              const [rt, Xe] = qe.geometry.coordinates, he = Oe(Ft(rt)), Q = Oe(Jt(Xe));
              xe.push(he, Q, 1 / 0, Ie, -1, 1), this.options.reduce && xe.push(0)
            }
            let je = this.trees[te + 1] = this._createTree(xe);
            q && console.timeEnd(le);
            for (let Ie = te; Ie >= X; Ie--) {
              const qe = +Date.now();
              je = this.trees[Ie] = this._createTree(this._cluster(je, Ie)), q && console.log("z%d: %d clusters in %dms", Ie, je.numItems, +Date.now() - qe)
            }
            return q && console.timeEnd("total time"), this
          }
          getClusters(N, q) {
            let X = ((N[0] + 180) % 360 + 360) % 360 - 180;
            const te = Math.max(-90, Math.min(90, N[1]));
            let le = N[2] === 180 ? 180 : ((N[2] + 180) % 360 + 360) % 360 - 180;
            const xe = Math.max(-90, Math.min(90, N[3]));
            if (N[2] - N[0] >= 360) X = -180, le = 180;
            else if (X > le) {
              const Xe = this.getClusters([X, te, 180, xe], q),
                he = this.getClusters([-180, te, le, xe], q);
              return Xe.concat(he)
            }
            const je = this.trees[this._limitZoom(q)],
              Ie = je.range(Ft(X), Jt(xe), Ft(le), Jt(te)),
              qe = je.data,
              rt = [];
            for (const Xe of Ie) {
              const he = this.stride * Xe;
              rt.push(qe[he + 5] > 1 ? Ke(qe, he, this.clusterProps) : this.points[qe[he + 3]])
            }
            return rt
          }
          getChildren(N) {
            const q = this._getOriginId(N),
              X = this._getOriginZoom(N),
              te = "No cluster with the specified id.",
              le = this.trees[X];
            if (!le) throw new Error(te);
            const xe = le.data;
            if (q * this.stride >= xe.length) throw new Error(te);
            const je = this.options.radius / (this.options.extent * Math.pow(2, X - 1)),
              Ie = le.within(xe[q * this.stride], xe[q * this.stride + 1], je),
              qe = [];
            for (const rt of Ie) {
              const Xe = rt * this.stride;
              xe[Xe + 4] === N && qe.push(xe[Xe + 5] > 1 ? Ke(xe, Xe, this.clusterProps) : this.points[xe[Xe + 3]])
            }
            if (qe.length === 0) throw new Error(te);
            return qe
          }
          getLeaves(N, q, X) {
            const te = [];
            return this._appendLeaves(te, N, q = q || 10, X = X || 0, 0), te
          }
          getTile(N, q, X) {
            const te = this.trees[this._limitZoom(N)],
              le = Math.pow(2, N),
              {
                extent: xe,
                radius: je
              } = this.options,
              Ie = je / xe,
              qe = (X - Ie) / le,
              rt = (X + 1 + Ie) / le,
              Xe = {
                features: []
              };
            return this._addTileFeatures(te.range((q - Ie) / le, qe, (q + 1 + Ie) / le, rt), te.data, q, X, le, Xe), q === 0 && this._addTileFeatures(te.range(1 - Ie / le, qe, 1, rt), te.data, le, X, le, Xe), q === le - 1 && this._addTileFeatures(te.range(0, qe, Ie / le, rt), te.data, -1, X, le, Xe), Xe.features.length ? Xe : null
          }
          getClusterExpansionZoom(N) {
            let q = this._getOriginZoom(N) - 1;
            for (; q <= this.options.maxZoom;) {
              const X = this.getChildren(N);
              if (q++, X.length !== 1) break;
              N = X[0].properties.cluster_id
            }
            return q
          }
          _appendLeaves(N, q, X, te, le) {
            const xe = this.getChildren(q);
            for (const je of xe) {
              const Ie = je.properties;
              if (Ie && Ie.cluster ? le + Ie.point_count <= te ? le += Ie.point_count : le = this._appendLeaves(N, Ie.cluster_id, X, te, le) : le < te ? le++ : N.push(je), N.length === X) break
            }
            return le
          }
          _createTree(N) {
            const q = new k.aM(N.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let X = 0; X < N.length; X += this.stride) q.add(N[X], N[X + 1]);
            return q.finish(), q.data = N, q
          }
          _addTileFeatures(N, q, X, te, le, xe) {
            for (const je of N) {
              const Ie = je * this.stride,
                qe = q[Ie + 5] > 1;
              let rt, Xe, he;
              if (qe) rt = St(q, Ie, this.clusterProps), Xe = q[Ie], he = q[Ie + 1];
              else {
                const vt = this.points[q[Ie + 3]];
                rt = vt.properties;
                const [Qe, oe] = vt.geometry.coordinates;
                Xe = Ft(Qe), he = Jt(oe)
              }
              const Q = {
                type: 1,
                geometry: [
                  [Math.round(this.options.extent * (Xe * le - X)), Math.round(this.options.extent * (he * le - te))]
                ],
                tags: rt
              };
              let Ze;
              Ze = qe || this.options.generateId ? q[Ie + 3] : this.points[q[Ie + 3]].id, Ze !== void 0 && (Q.id = Ze), xe.features.push(Q)
            }
          }
          _limitZoom(N) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+N), this.options.maxZoom + 1))
          }
          _cluster(N, q) {
            const {
              radius: X,
              extent: te,
              reduce: le,
              minPoints: xe
            } = this.options, je = X / (te * Math.pow(2, q)), Ie = N.data, qe = [], rt = this.stride;
            for (let Xe = 0; Xe < Ie.length; Xe += rt) {
              if (Ie[Xe + 2] <= q) continue;
              Ie[Xe + 2] = q;
              const he = Ie[Xe],
                Q = Ie[Xe + 1],
                Ze = N.within(Ie[Xe], Ie[Xe + 1], je),
                vt = Ie[Xe + 5];
              let Qe = vt;
              for (const oe of Ze) {
                const De = oe * rt;
                Ie[De + 2] > q && (Qe += Ie[De + 5])
              }
              if (Qe > vt && Qe >= xe) {
                let oe, De = he * vt,
                  Je = Q * vt,
                  Tt = -1;
                const Dt = (Xe / rt << 5) + (q + 1) + this.points.length;
                for (const _t of Ze) {
                  const zt = _t * rt;
                  if (Ie[zt + 2] <= q) continue;
                  Ie[zt + 2] = q;
                  const Yt = Ie[zt + 5];
                  De += Ie[zt] * Yt, Je += Ie[zt + 1] * Yt, Ie[zt + 4] = Dt, le && (oe || (oe = this._map(Ie, Xe, !0), Tt = this.clusterProps.length, this.clusterProps.push(oe)), le(oe, this._map(Ie, zt)))
                }
                Ie[Xe + 4] = Dt, qe.push(De / Qe, Je / Qe, 1 / 0, Dt, -1, Qe), le && qe.push(Tt)
              } else {
                for (let oe = 0; oe < rt; oe++) qe.push(Ie[Xe + oe]);
                if (Qe > 1)
                  for (const oe of Ze) {
                    const De = oe * rt;
                    if (!(Ie[De + 2] <= q)) {
                      Ie[De + 2] = q;
                      for (let Je = 0; Je < rt; Je++) qe.push(Ie[De + Je])
                    }
                  }
              }
            }
            return qe
          }
          _getOriginId(N) {
            return N - this.points.length >> 5
          }
          _getOriginZoom(N) {
            return (N - this.points.length) % 32
          }
          _map(N, q, X) {
            if (N[q + 5] > 1) {
              const xe = this.clusterProps[N[q + 6]];
              return X ? Object.assign({}, xe) : xe
            }
            const te = this.points[N[q + 3]].properties,
              le = this.options.map(te);
            return X && le === te ? Object.assign({}, le) : le
          }
        }

        function Ke(ue, N, q) {
          return {
            type: "Feature",
            id: ue[N + 3],
            properties: St(ue, N, q),
            geometry: {
              type: "Point",
              coordinates: [(X = ue[N], 360 * (X - .5)), Mt(ue[N + 1])]
            }
          };
          var X
        }

        function St(ue, N, q) {
          const X = ue[N + 5],
            te = X >= 1e4 ? `${Math.round(X/1e3)}k` : X >= 1e3 ? Math.round(X / 100) / 10 + "k" : X,
            le = ue[N + 6],
            xe = le === -1 ? {} : Object.assign({}, q[le]);
          return Object.assign(xe, {
            cluster: !0,
            cluster_id: ue[N + 3],
            point_count: X,
            point_count_abbreviated: te
          })
        }

        function Ft(ue) {
          return ue / 360 + .5
        }

        function Jt(ue) {
          const N = Math.sin(ue * Math.PI / 180),
            q = .5 - .25 * Math.log((1 + N) / (1 - N)) / Math.PI;
          return q < 0 ? 0 : q > 1 ? 1 : q
        }

        function Mt(ue) {
          const N = (180 - 360 * ue) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(N)) / Math.PI - 90
        }

        function ct(ue, N, q, X) {
          let te = X;
          const le = N + (q - N >> 1);
          let xe, je = q - N;
          const Ie = ue[N],
            qe = ue[N + 1],
            rt = ue[q],
            Xe = ue[q + 1];
          for (let he = N + 3; he < q; he += 3) {
            const Q = wt(ue[he], ue[he + 1], Ie, qe, rt, Xe);
            if (Q > te) xe = he, te = Q;
            else if (Q === te) {
              const Ze = Math.abs(he - le);
              Ze < je && (xe = he, je = Ze)
            }
          }
          te > X && (xe - N > 3 && ct(ue, N, xe, X), ue[xe + 2] = te, q - xe > 3 && ct(ue, xe, q, X))
        }

        function wt(ue, N, q, X, te, le) {
          let xe = te - q,
            je = le - X;
          if (xe !== 0 || je !== 0) {
            const Ie = ((ue - q) * xe + (N - X) * je) / (xe * xe + je * je);
            Ie > 1 ? (q = te, X = le) : Ie > 0 && (q += xe * Ie, X += je * Ie)
          }
          return xe = ue - q, je = N - X, xe * xe + je * je
        }

        function ft(ue, N, q, X) {
          const te = {
            id: ue ?? null,
            type: N,
            geometry: q,
            tags: X,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
          };
          if (N === "Point" || N === "MultiPoint" || N === "LineString") $t(te, q);
          else if (N === "Polygon") $t(te, q[0]);
          else if (N === "MultiLineString")
            for (const le of q) $t(te, le);
          else if (N === "MultiPolygon")
            for (const le of q) $t(te, le[0]);
          return te
        }

        function $t(ue, N) {
          for (let q = 0; q < N.length; q += 3) ue.minX = Math.min(ue.minX, N[q]), ue.minY = Math.min(ue.minY, N[q + 1]), ue.maxX = Math.max(ue.maxX, N[q]), ue.maxY = Math.max(ue.maxY, N[q + 1])
        }

        function Et(ue, N, q, X) {
          if (!N.geometry) return;
          const te = N.geometry.coordinates;
          if (te && te.length === 0) return;
          const le = N.geometry.type,
            xe = Math.pow(q.tolerance / ((1 << q.maxZoom) * q.extent), 2);
          let je = [],
            Ie = N.id;
          if (q.promoteId ? Ie = N.properties[q.promoteId] : q.generateId && (Ie = X || 0), le === "Point") Qt(te, je);
          else if (le === "MultiPoint")
            for (const qe of te) Qt(qe, je);
          else if (le === "LineString") vr(te, je, xe, !1);
          else if (le === "MultiLineString") {
            if (q.lineMetrics) {
              for (const qe of te) je = [], vr(qe, je, xe, !1), ue.push(ft(Ie, "LineString", je, N.properties));
              return
            }
            Kt(te, je, xe, !1)
          } else if (le === "Polygon") Kt(te, je, xe, !0);
          else {
            if (le !== "MultiPolygon") {
              if (le === "GeometryCollection") {
                for (const qe of N.geometry.geometries) Et(ue, {
                  id: Ie,
                  geometry: qe,
                  properties: N.properties
                }, q, X);
                return
              }
              throw new Error("Input data is not a valid GeoJSON object.")
            }
            for (const qe of te) {
              const rt = [];
              Kt(qe, rt, xe, !0), je.push(rt)
            }
          }
          ue.push(ft(Ie, le, je, N.properties))
        }

        function Qt(ue, N) {
          N.push(Bt(ue[0]), it(ue[1]), 0)
        }

        function vr(ue, N, q, X) {
          let te, le, xe = 0;
          for (let Ie = 0; Ie < ue.length; Ie++) {
            const qe = Bt(ue[Ie][0]),
              rt = it(ue[Ie][1]);
            N.push(qe, rt, 0), Ie > 0 && (xe += X ? (te * rt - qe * le) / 2 : Math.sqrt(Math.pow(qe - te, 2) + Math.pow(rt - le, 2))), te = qe, le = rt
          }
          const je = N.length - 3;
          N[2] = 1, ct(N, 0, je, q), N[je + 2] = 1, N.size = Math.abs(xe), N.start = 0, N.end = N.size
        }

        function Kt(ue, N, q, X) {
          for (let te = 0; te < ue.length; te++) {
            const le = [];
            vr(ue[te], le, q, X), N.push(le)
          }
        }

        function Bt(ue) {
          return ue / 360 + .5
        }

        function it(ue) {
          const N = Math.sin(ue * Math.PI / 180),
            q = .5 - .25 * Math.log((1 + N) / (1 - N)) / Math.PI;
          return q < 0 ? 0 : q > 1 ? 1 : q
        }

        function He(ue, N, q, X, te, le, xe, je) {
          if (X /= N, le >= (q /= N) && xe < X) return ue;
          if (xe < q || le >= X) return null;
          const Ie = [];
          for (const qe of ue) {
            const rt = qe.geometry;
            let Xe = qe.type;
            const he = te === 0 ? qe.minX : qe.minY,
              Q = te === 0 ? qe.maxX : qe.maxY;
            if (he >= q && Q < X) {
              Ie.push(qe);
              continue
            }
            if (Q < q || he >= X) continue;
            let Ze = [];
            if (Xe === "Point" || Xe === "MultiPoint") Ot(rt, Ze, q, X, te);
            else if (Xe === "LineString") Gt(rt, Ze, q, X, te, !1, je.lineMetrics);
            else if (Xe === "MultiLineString") nr(rt, Ze, q, X, te, !1);
            else if (Xe === "Polygon") nr(rt, Ze, q, X, te, !0);
            else if (Xe === "MultiPolygon")
              for (const vt of rt) {
                const Qe = [];
                nr(vt, Qe, q, X, te, !0), Qe.length && Ze.push(Qe)
              }
            if (Ze.length) {
              if (je.lineMetrics && Xe === "LineString") {
                for (const vt of Ze) Ie.push(ft(qe.id, Xe, vt, qe.tags));
                continue
              }
              Xe !== "LineString" && Xe !== "MultiLineString" || (Ze.length === 1 ? (Xe = "LineString", Ze = Ze[0]) : Xe = "MultiLineString"), Xe !== "Point" && Xe !== "MultiPoint" || (Xe = Ze.length === 3 ? "Point" : "MultiPoint"), Ie.push(ft(qe.id, Xe, Ze, qe.tags))
            }
          }
          return Ie.length ? Ie : null
        }

        function Ot(ue, N, q, X, te) {
          for (let le = 0; le < ue.length; le += 3) {
            const xe = ue[le + te];
            xe >= q && xe <= X && It(N, ue[le], ue[le + 1], ue[le + 2])
          }
        }

        function Gt(ue, N, q, X, te, le, xe) {
          let je = kt(ue);
          const Ie = te === 0 ? mt : yt;
          let qe, rt, Xe = ue.start;
          for (let Qe = 0; Qe < ue.length - 3; Qe += 3) {
            const oe = ue[Qe],
              De = ue[Qe + 1],
              Je = ue[Qe + 2],
              Tt = ue[Qe + 3],
              Dt = ue[Qe + 4],
              _t = te === 0 ? oe : De,
              zt = te === 0 ? Tt : Dt;
            let Yt = !1;
            xe && (qe = Math.sqrt(Math.pow(oe - Tt, 2) + Math.pow(De - Dt, 2))), _t < q ? zt > q && (rt = Ie(je, oe, De, Tt, Dt, q), xe && (je.start = Xe + qe * rt)) : _t > X ? zt < X && (rt = Ie(je, oe, De, Tt, Dt, X), xe && (je.start = Xe + qe * rt)) : It(je, oe, De, Je), zt < q && _t >= q && (rt = Ie(je, oe, De, Tt, Dt, q), Yt = !0), zt > X && _t <= X && (rt = Ie(je, oe, De, Tt, Dt, X), Yt = !0), !le && Yt && (xe && (je.end = Xe + qe * rt), N.push(je), je = kt(ue)), xe && (Xe += qe)
          }
          let he = ue.length - 3;
          const Q = ue[he],
            Ze = ue[he + 1],
            vt = te === 0 ? Q : Ze;
          vt >= q && vt <= X && It(je, Q, Ze, ue[he + 2]), he = je.length - 3, le && he >= 3 && (je[he] !== je[0] || je[he + 1] !== je[1]) && It(je, je[0], je[1], je[2]), je.length && N.push(je)
        }

        function kt(ue) {
          const N = [];
          return N.size = ue.size, N.start = ue.start, N.end = ue.end, N
        }

        function nr(ue, N, q, X, te, le) {
          for (const xe of ue) Gt(xe, N, q, X, te, le, !1)
        }

        function It(ue, N, q, X) {
          ue.push(N, q, X)
        }

        function mt(ue, N, q, X, te, le) {
          const xe = (le - N) / (X - N);
          return It(ue, le, q + (te - q) * xe, 1), xe
        }

        function yt(ue, N, q, X, te, le) {
          const xe = (le - q) / (te - q);
          return It(ue, N + (X - N) * xe, le, 1), xe
        }

        function bt(ue, N) {
          const q = [];
          for (let X = 0; X < ue.length; X++) {
            const te = ue[X],
              le = te.type;
            let xe;
            if (le === "Point" || le === "MultiPoint" || le === "LineString") xe = Lt(te.geometry, N);
            else if (le === "MultiLineString" || le === "Polygon") {
              xe = [];
              for (const je of te.geometry) xe.push(Lt(je, N))
            } else if (le === "MultiPolygon") {
              xe = [];
              for (const je of te.geometry) {
                const Ie = [];
                for (const qe of je) Ie.push(Lt(qe, N));
                xe.push(Ie)
              }
            }
            q.push(ft(te.id, le, xe, te.tags))
          }
          return q
        }

        function Lt(ue, N) {
          const q = [];
          q.size = ue.size, ue.start !== void 0 && (q.start = ue.start, q.end = ue.end);
          for (let X = 0; X < ue.length; X += 3) q.push(ue[X] + N, ue[X + 1], ue[X + 2]);
          return q
        }

        function st(ue, N) {
          if (ue.transformed) return ue;
          const q = 1 << ue.z,
            X = ue.x,
            te = ue.y;
          for (const le of ue.features) {
            const xe = le.geometry,
              je = le.type;
            if (le.geometry = [], je === 1)
              for (let Ie = 0; Ie < xe.length; Ie += 2) le.geometry.push(lr(xe[Ie], xe[Ie + 1], N, q, X, te));
            else
              for (let Ie = 0; Ie < xe.length; Ie++) {
                const qe = [];
                for (let rt = 0; rt < xe[Ie].length; rt += 2) qe.push(lr(xe[Ie][rt], xe[Ie][rt + 1], N, q, X, te));
                le.geometry.push(qe)
              }
          }
          return ue.transformed = !0, ue
        }

        function lr(ue, N, q, X, te, le) {
          return [Math.round(q * (ue * X - te)), Math.round(q * (N * X - le))]
        }

        function gr(ue, N, q, X, te) {
          const le = N === te.maxZoom ? 0 : te.tolerance / ((1 << N) * te.extent),
            xe = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: ue.length,
              source: null,
              x: q,
              y: X,
              z: N,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0
            };
          for (const je of ue) dr(xe, je, le, te);
          return xe
        }

        function dr(ue, N, q, X) {
          const te = N.geometry,
            le = N.type,
            xe = [];
          if (ue.minX = Math.min(ue.minX, N.minX), ue.minY = Math.min(ue.minY, N.minY), ue.maxX = Math.max(ue.maxX, N.maxX), ue.maxY = Math.max(ue.maxY, N.maxY), le === "Point" || le === "MultiPoint")
            for (let je = 0; je < te.length; je += 3) xe.push(te[je], te[je + 1]), ue.numPoints++, ue.numSimplified++;
          else if (le === "LineString") pr(xe, te, ue, q, !1, !1);
          else if (le === "MultiLineString" || le === "Polygon")
            for (let je = 0; je < te.length; je++) pr(xe, te[je], ue, q, le === "Polygon", je === 0);
          else if (le === "MultiPolygon")
            for (let je = 0; je < te.length; je++) {
              const Ie = te[je];
              for (let qe = 0; qe < Ie.length; qe++) pr(xe, Ie[qe], ue, q, !0, qe === 0)
            }
          if (xe.length) {
            let je = N.tags || null;
            if (le === "LineString" && X.lineMetrics) {
              je = {};
              for (const qe in N.tags) je[qe] = N.tags[qe];
              je.mapbox_clip_start = te.start / te.size, je.mapbox_clip_end = te.end / te.size
            }
            const Ie = {
              geometry: xe,
              type: le === "Polygon" || le === "MultiPolygon" ? 3 : le === "LineString" || le === "MultiLineString" ? 2 : 1,
              tags: je
            };
            N.id !== null && (Ie.id = N.id), ue.features.push(Ie)
          }
        }

        function pr(ue, N, q, X, te, le) {
          const xe = X * X;
          if (X > 0 && N.size < (te ? xe : X)) return void(q.numPoints += N.length / 3);
          const je = [];
          for (let Ie = 0; Ie < N.length; Ie += 3)(X === 0 || N[Ie + 2] > xe) && (q.numSimplified++, je.push(N[Ie], N[Ie + 1])), q.numPoints++;
          te && (function(Ie, qe) {
            let rt = 0;
            for (let Xe = 0, he = Ie.length, Q = he - 2; Xe < he; Q = Xe, Xe += 2) rt += (Ie[Xe] - Ie[Q]) * (Ie[Xe + 1] + Ie[Q + 1]);
            if (rt > 0 === qe)
              for (let Xe = 0, he = Ie.length; Xe < he / 2; Xe += 2) {
                const Q = Ie[Xe],
                  Ze = Ie[Xe + 1];
                Ie[Xe] = Ie[he - 2 - Xe], Ie[Xe + 1] = Ie[he - 1 - Xe], Ie[he - 2 - Xe] = Q, Ie[he - 1 - Xe] = Ze
              }
          })(je, le), ue.push(je)
        }
        const Ht = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0
        };
        class Sr {
          constructor(N, q) {
            const X = (q = this.options = (function(le, xe) {
              for (const je in xe) le[je] = xe[je];
              return le
            })(Object.create(Ht), q)).debug;
            if (X && console.time("preprocess data"), q.maxZoom < 0 || q.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (q.promoteId && q.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let te = (function(le, xe) {
              const je = [];
              if (le.type === "FeatureCollection")
                for (let Ie = 0; Ie < le.features.length; Ie++) Et(je, le.features[Ie], xe, Ie);
              else Et(je, le.type === "Feature" ? le : {
                geometry: le
              }, xe);
              return je
            })(N, q);
            this.tiles = {}, this.tileCoords = [], X && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", q.indexMaxZoom, q.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), te = (function(le, xe) {
              const je = xe.buffer / xe.extent;
              let Ie = le;
              const qe = He(le, 1, -1 - je, je, 0, -1, 2, xe),
                rt = He(le, 1, 1 - je, 2 + je, 0, -1, 2, xe);
              return (qe || rt) && (Ie = He(le, 1, -je, 1 + je, 0, -1, 2, xe) || [], qe && (Ie = bt(qe, 1).concat(Ie)), rt && (Ie = Ie.concat(bt(rt, -1)))), Ie
            })(te, q), te.length && this.splitTile(te, 0, 0, 0), X && (te.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
          }
          splitTile(N, q, X, te, le, xe, je) {
            const Ie = [N, q, X, te],
              qe = this.options,
              rt = qe.debug;
            for (; Ie.length;) {
              te = Ie.pop(), X = Ie.pop(), q = Ie.pop(), N = Ie.pop();
              const Xe = 1 << q,
                he = Rr(q, X, te);
              let Q = this.tiles[he];
              if (!Q && (rt > 1 && console.time("creation"), Q = this.tiles[he] = gr(N, q, X, te, qe), this.tileCoords.push({
                  z: q,
                  x: X,
                  y: te
                }), rt)) {
                rt > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", q, X, te, Q.numFeatures, Q.numPoints, Q.numSimplified), console.timeEnd("creation"));
                const Yt = `z${q}`;
                this.stats[Yt] = (this.stats[Yt] || 0) + 1, this.total++
              }
              if (Q.source = N, le == null) {
                if (q === qe.indexMaxZoom || Q.numPoints <= qe.indexMaxPoints) continue
              } else {
                if (q === qe.maxZoom || q === le) continue;
                if (le != null) {
                  const Yt = le - q;
                  if (X !== xe >> Yt || te !== je >> Yt) continue
                }
              }
              if (Q.source = null, N.length === 0) continue;
              rt > 1 && console.time("clipping");
              const Ze = .5 * qe.buffer / qe.extent,
                vt = .5 - Ze,
                Qe = .5 + Ze,
                oe = 1 + Ze;
              let De = null,
                Je = null,
                Tt = null,
                Dt = null,
                _t = He(N, Xe, X - Ze, X + Qe, 0, Q.minX, Q.maxX, qe),
                zt = He(N, Xe, X + vt, X + oe, 0, Q.minX, Q.maxX, qe);
              N = null, _t && (De = He(_t, Xe, te - Ze, te + Qe, 1, Q.minY, Q.maxY, qe), Je = He(_t, Xe, te + vt, te + oe, 1, Q.minY, Q.maxY, qe), _t = null), zt && (Tt = He(zt, Xe, te - Ze, te + Qe, 1, Q.minY, Q.maxY, qe), Dt = He(zt, Xe, te + vt, te + oe, 1, Q.minY, Q.maxY, qe), zt = null), rt > 1 && console.timeEnd("clipping"), Ie.push(De || [], q + 1, 2 * X, 2 * te), Ie.push(Je || [], q + 1, 2 * X, 2 * te + 1), Ie.push(Tt || [], q + 1, 2 * X + 1, 2 * te), Ie.push(Dt || [], q + 1, 2 * X + 1, 2 * te + 1)
            }
          }
          getTile(N, q, X) {
            N = +N, q = +q, X = +X;
            const te = this.options,
              {
                extent: le,
                debug: xe
              } = te;
            if (N < 0 || N > 24) return null;
            const je = 1 << N,
              Ie = Rr(N, q = q + je & je - 1, X);
            if (this.tiles[Ie]) return st(this.tiles[Ie], le);
            xe > 1 && console.log("drilling down to z%d-%d-%d", N, q, X);
            let qe, rt = N,
              Xe = q,
              he = X;
            for (; !qe && rt > 0;) rt--, Xe >>= 1, he >>= 1, qe = this.tiles[Rr(rt, Xe, he)];
            return qe && qe.source ? (xe > 1 && (console.log("found parent tile z%d-%d-%d", rt, Xe, he), console.time("drilling down")), this.splitTile(qe.source, rt, Xe, he, N, q, X), xe > 1 && console.timeEnd("drilling down"), this.tiles[Ie] ? st(this.tiles[Ie], le) : null) : null
          }
        }

        function Rr(ue, N, q) {
          return 32 * ((1 << ue) * q + N) + ue
        }
        class Vt extends J {
          constructor(N, q, X, te = Tr) {
            super(N, q, X), this._dataUpdateable = new Map, this._createGeoJSONIndex = te
          }
          loadVectorTile(N, q) {
            return k._(this, void 0, void 0, (function*() {
              const X = N.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const te = this._geoJSONIndex.getTile(X.z, X.x, X.y);
              if (!te) return null;
              const le = new Re(te.features, {
                version: 2,
                extent: k.a3
              });
              let xe = (function(je) {
                const Ie = new k.cP;
                return (function(qe, rt) {
                  for (const Xe in qe.layers) rt.writeMessage(3, Pe, qe.layers[Xe])
                })(je, Ie), Ie.finish()
              })(le);
              return xe.byteOffset === 0 && xe.byteLength === xe.buffer.byteLength || (xe = new Uint8Array(xe)), {
                vectorTile: le,
                rawData: xe.buffer
              }
            }))
          }
          loadData(N) {
            return k._(this, void 0, void 0, (function*() {
              var q;
              (q = this._pendingRequest) === null || q === void 0 || q.abort();
              const X = !!(N && N.request && N.request.collectResourceTiming) && new k.cQ(N.request);
              this._pendingRequest = new AbortController;
              try {
                (!this._pendingData || N.request || N.data || N.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(N, this._pendingRequest));
                const te = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(te, N), this.loaded = {};
                const le = {
                  data: te
                };
                if (X) {
                  const xe = X.finish();
                  xe && (le.resourceTiming = {}, le.resourceTiming[N.source] = JSON.parse(JSON.stringify(xe)))
                }
                return le
              } catch (te) {
                if (delete this._pendingRequest, k.cB(te)) return {
                  abandoned: !0
                };
                throw te
              }
            }))
          }
          getData() {
            return k._(this, void 0, void 0, (function*() {
              return this._pendingData
            }))
          }
          reloadTile(N) {
            const q = this.loaded;
            return q && q[N.uid] ? super.reloadTile(N) : this.loadTile(N)
          }
          loadAndProcessGeoJSON(N, q) {
            return k._(this, void 0, void 0, (function*() {
              let X = yield this.loadGeoJSON(N, q);
              if (delete this._pendingRequest, typeof X != "object") throw new Error(`Input data given to '${N.source}' is not a valid GeoJSON object.`);
              if (de(X, !0), N.filter) {
                const te = k.cW(N.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1
                });
                if (te.result === "error") throw new Error(te.value.map((xe => `${xe.key}: ${xe.message}`)).join(", "));
                X = {
                  type: "FeatureCollection",
                  features: X.features.filter((xe => te.value.evaluate({
                    zoom: 0
                  }, xe)))
                }
              }
              return X
            }))
          }
          loadGeoJSON(N, q) {
            return k._(this, void 0, void 0, (function*() {
              const {
                promoteId: X
              } = N;
              if (N.request) {
                const te = yield k.j(N.request, q);
                return this._dataUpdateable = k.cY(te.data, X) ? k.cX(te.data, X) : void 0, te.data
              }
              if (typeof N.data == "string") try {
                const te = JSON.parse(N.data);
                return this._dataUpdateable = k.cY(te, X) ? k.cX(te, X) : void 0, te
              } catch {
                throw new Error(`Input data given to '${N.source}' is not a valid GeoJSON object.`)
              }
              if (!N.dataDiff) throw new Error(`Input data given to '${N.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${N.source}`);
              return k.cZ(this._dataUpdateable, N.dataDiff, X), {
                type: "FeatureCollection",
                features: Array.from(this._dataUpdateable.values())
              }
            }))
          }
          removeSource(N) {
            return k._(this, void 0, void 0, (function*() {
              this._pendingRequest && this._pendingRequest.abort()
            }))
          }
          getClusterExpansionZoom(N) {
            return this._geoJSONIndex.getClusterExpansionZoom(N.clusterId)
          }
          getClusterChildren(N) {
            return this._geoJSONIndex.getChildren(N.clusterId)
          }
          getClusterLeaves(N) {
            return this._geoJSONIndex.getLeaves(N.clusterId, N.limit, N.offset)
          }
        }

        function Tr(ue, N) {
          return N.cluster ? new Ue((function({
            superclusterOptions: q,
            clusterProperties: X
          }) {
            if (!X || !q) return q;
            const te = {},
              le = {},
              xe = {
                accumulated: null,
                zoom: 0
              },
              je = {
                properties: null
              },
              Ie = Object.keys(X);
            for (const qe of Ie) {
              const [rt, Xe] = X[qe], he = k.cW(Xe), Q = k.cW(typeof rt == "string" ? [rt, ["accumulated"],
                ["get", qe]
              ] : rt);
              te[qe] = he.value, le[qe] = Q.value
            }
            return q.map = qe => {
              je.properties = qe;
              const rt = {};
              for (const Xe of Ie) rt[Xe] = te[Xe].evaluate(xe, je);
              return rt
            }, q.reduce = (qe, rt) => {
              je.properties = rt;
              for (const Xe of Ie) xe.accumulated = qe[Xe], qe[Xe] = le[Xe].evaluate(xe, je)
            }, q
          })(N)).load(ue.features) : (function(q, X) {
            return new Sr(q, X)
          })(ue, N.geojsonVtOptions)
        }
        class Xt {
          constructor(N) {
            this.self = N, this.actor = new k.K(N), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = new Map, this.self.registerWorkerSource = (q, X) => {
              if (this.externalWorkerSourceTypes[q]) throw new Error(`Worker source with name "${q}" already registered.`);
              this.externalWorkerSourceTypes[q] = X
            }, this.self.addProtocol = k.cD, this.self.removeProtocol = k.cE, this.self.registerRTLTextPlugin = q => {
              k.c_.setMethods(q)
            }, this.actor.registerMessageHandler("LDT", ((q, X) => this._getDEMWorkerSource(q, X.source).loadTile(X))), this.actor.registerMessageHandler("RDT", ((q, X) => k._(this, void 0, void 0, (function*() {
              this._getDEMWorkerSource(q, X.source).removeTile(X)
            })))), this.actor.registerMessageHandler("GCEZ", ((q, X) => k._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(q, X.type, X.source).getClusterExpansionZoom(X)
            })))), this.actor.registerMessageHandler("GCC", ((q, X) => k._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(q, X.type, X.source).getClusterChildren(X)
            })))), this.actor.registerMessageHandler("GCL", ((q, X) => k._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(q, X.type, X.source).getClusterLeaves(X)
            })))), this.actor.registerMessageHandler("LD", ((q, X) => this._getWorkerSource(q, X.type, X.source).loadData(X))), this.actor.registerMessageHandler("GD", ((q, X) => this._getWorkerSource(q, X.type, X.source).getData())), this.actor.registerMessageHandler("LT", ((q, X) => this._getWorkerSource(q, X.type, X.source).loadTile(X))), this.actor.registerMessageHandler("RT", ((q, X) => this._getWorkerSource(q, X.type, X.source).reloadTile(X))), this.actor.registerMessageHandler("AT", ((q, X) => this._getWorkerSource(q, X.type, X.source).abortTile(X))), this.actor.registerMessageHandler("RMT", ((q, X) => this._getWorkerSource(q, X.type, X.source).removeTile(X))), this.actor.registerMessageHandler("RS", ((q, X) => k._(this, void 0, void 0, (function*() {
              if (!this.workerSources[q] || !this.workerSources[q][X.type] || !this.workerSources[q][X.type][X.source]) return;
              const te = this.workerSources[q][X.type][X.source];
              delete this.workerSources[q][X.type][X.source], te.removeSource !== void 0 && te.removeSource(X)
            })))), this.actor.registerMessageHandler("RM", (q => k._(this, void 0, void 0, (function*() {
              delete this.layerIndexes[q], delete this.availableImages[q], delete this.workerSources[q], delete this.demWorkerSources[q], this.globalStates.delete(q)
            })))), this.actor.registerMessageHandler("SR", ((q, X) => k._(this, void 0, void 0, (function*() {
              this.referrer = X
            })))), this.actor.registerMessageHandler("SRPS", ((q, X) => this._syncRTLPluginState(q, X))), this.actor.registerMessageHandler("IS", ((q, X) => k._(this, void 0, void 0, (function*() {
              this.self.importScripts(X)
            })))), this.actor.registerMessageHandler("SI", ((q, X) => this._setImages(q, X))), this.actor.registerMessageHandler("UL", ((q, X) => k._(this, void 0, void 0, (function*() {
              this._getLayerIndex(q).update(X.layers, X.removedIds, this._getGlobalState(q))
            })))), this.actor.registerMessageHandler("UGS", ((q, X) => k._(this, void 0, void 0, (function*() {
              const te = this._getGlobalState(q);
              for (const le in X) te[le] = X[le]
            })))), this.actor.registerMessageHandler("SL", ((q, X) => k._(this, void 0, void 0, (function*() {
              this._getLayerIndex(q).replace(X, this._getGlobalState(q))
            }))))
          }
          _getGlobalState(N) {
            let q = this.globalStates.get(N);
            return q || (q = {}, this.globalStates.set(N, q)), q
          }
          _setImages(N, q) {
            return k._(this, void 0, void 0, (function*() {
              this.availableImages[N] = q;
              for (const X in this.workerSources[N]) {
                const te = this.workerSources[N][X];
                for (const le in te) te[le].availableImages = q
              }
            }))
          }
          _syncRTLPluginState(N, q) {
            return k._(this, void 0, void 0, (function*() {
              return yield k.c_.syncState(q, this.self.importScripts)
            }))
          }
          _getAvailableImages(N) {
            let q = this.availableImages[N];
            return q || (q = []), q
          }
          _getLayerIndex(N) {
            let q = this.layerIndexes[N];
            return q || (q = this.layerIndexes[N] = new l), q
          }
          _getWorkerSource(N, q, X) {
            if (this.workerSources[N] || (this.workerSources[N] = {}), this.workerSources[N][q] || (this.workerSources[N][q] = {}), !this.workerSources[N][q][X]) {
              const te = {
                sendAsync: (le, xe) => (le.targetMapId = N, this.actor.sendAsync(le, xe))
              };
              switch (q) {
                case "vector":
                  this.workerSources[N][q][X] = new J(te, this._getLayerIndex(N), this._getAvailableImages(N));
                  break;
                case "geojson":
                  this.workerSources[N][q][X] = new Vt(te, this._getLayerIndex(N), this._getAvailableImages(N));
                  break;
                default:
                  this.workerSources[N][q][X] = new this.externalWorkerSourceTypes[q](te, this._getLayerIndex(N), this._getAvailableImages(N))
              }
            }
            return this.workerSources[N][q][X]
          }
          _getDEMWorkerSource(N, q) {
            return this.demWorkerSources[N] || (this.demWorkerSources[N] = {}), this.demWorkerSources[N][q] || (this.demWorkerSources[N][q] = new ce), this.demWorkerSources[N][q]
          }
        }
        return k.i(self) && (self.worker = new Xt(self)), Xt
      })), A("index", ["exports", "./shared"], (function(k, l) {
        var j = "5.11.0";

        function W() {
          var p = new l.A(4);
          return l.A != Float32Array && (p[1] = 0, p[2] = 0), p[0] = 1, p[3] = 1, p
        }
        let $, J;
        const ce = {
            frame(p, e, a) {
              const c = requestAnimationFrame((f => {
                  h(), e(f)
                })),
                {
                  unsubscribe: h
                } = l.s(p.signal, "abort", (() => {
                  h(), cancelAnimationFrame(c), a(l.c())
                }), !1)
            },
            frameAsync(p) {
              return new Promise(((e, a) => {
                this.frame(p, e, a)
              }))
            },
            getImageData(p, e = 0) {
              return this.getImageCanvasContext(p).getImageData(-e, -e, p.width + 2 * e, p.height + 2 * e)
            },
            getImageCanvasContext(p) {
              const e = window.document.createElement("canvas"),
                a = e.getContext("2d", {
                  willReadFrequently: !0
                });
              if (!a) throw new Error("failed to create canvas 2d context");
              return e.width = p.width, e.height = p.height, a.drawImage(p, 0, 0, p.width, p.height), a
            },
            resolveURL: p => ($ || ($ = document.createElement("a")), $.href = p, $.href),
            hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
            get prefersReducedMotion() {
              return !!matchMedia && (J == null && (J = matchMedia("(prefers-reduced-motion: reduce)")), J.matches)
            }
          },
          ge = new class {
            constructor() {
              this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null
            }
            getCurrentTime() {
              return this._frozenAt !== null ? this._frozenAt : this._realTime()
            }
            setNow(p) {
              this._frozenAt = p
            }
            restoreNow() {
              this._frozenAt = null
            }
            isFrozen() {
              return this._frozenAt !== null
            }
          };

        function fe() {
          return ge.getCurrentTime()
        }
        class Z {
          static testProp(e) {
            if (!Z.docStyle) return e[0];
            for (let a = 0; a < e.length; a++)
              if (e[a] in Z.docStyle) return e[a];
            return e[0]
          }
          static create(e, a, c) {
            const h = window.document.createElement(e);
            return a !== void 0 && (h.className = a), c && c.appendChild(h), h
          }
          static createNS(e, a) {
            return window.document.createElementNS(e, a)
          }
          static disableDrag() {
            Z.docStyle && Z.selectProp && (Z.userSelect = Z.docStyle[Z.selectProp], Z.docStyle[Z.selectProp] = "none")
          }
          static enableDrag() {
            Z.docStyle && Z.selectProp && (Z.docStyle[Z.selectProp] = Z.userSelect)
          }
          static setTransform(e, a) {
            e.style[Z.transformProp] = a
          }
          static addEventListener(e, a, c, h = {}) {
            e.addEventListener(a, c, "passive" in h ? h : h.capture)
          }
          static removeEventListener(e, a, c, h = {}) {
            e.removeEventListener(a, c, "passive" in h ? h : h.capture)
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", Z.suppressClickInternal, !0)
          }
          static suppressClick() {
            window.addEventListener("click", Z.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", Z.suppressClickInternal, !0)
            }), 0)
          }
          static getScale(e) {
            const a = e.getBoundingClientRect();
            return {
              x: a.width / e.offsetWidth || 1,
              y: a.height / e.offsetHeight || 1,
              boundingClientRect: a
            }
          }
          static getPoint(e, a, c) {
            const h = a.boundingClientRect;
            return new l.P((c.clientX - h.left) / a.x - e.clientLeft, (c.clientY - h.top) / a.y - e.clientTop)
          }
          static mousePos(e, a) {
            const c = Z.getScale(e);
            return Z.getPoint(e, c, a)
          }
          static touchPos(e, a) {
            const c = [],
              h = Z.getScale(e);
            for (let f = 0; f < a.length; f++) c.push(Z.getPoint(e, h, a[f]));
            return c
          }
          static mouseButton(e) {
            return e.button
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e)
          }
          static sanitize(e) {
            const a = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"),
              c = a.querySelectorAll("script");
            for (const h of c) h.remove();
            return Z.clean(a), a.innerHTML
          }
          static isPossiblyDangerous(e, a) {
            const c = a.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !c.includes("javascript:") && !c.includes("data:")) || !!e.startsWith("on") || void 0
          }
          static clean(e) {
            const a = e.children;
            for (const c of a) Z.removeAttributes(c), Z.clean(c)
          }
          static removeAttributes(e) {
            for (const {
                name: a,
                value: c
              }
              of e.attributes) Z.isPossiblyDangerous(a, c) && e.removeAttribute(a)
          }
        }
        Z.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, Z.selectProp = Z.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), Z.transformProp = Z.testProp(["transform", "WebkitTransform"]);
        const de = {
          supported: !1,
          testSupport: function(p) {
            !Pe && Re && (Ge ? et(p) : Fe = p)
          }
        };
        let Fe, Re, Pe = !1,
          Ge = !1;

        function et(p) {
          const e = p.createTexture();
          p.bindTexture(p.TEXTURE_2D, e);
          try {
            if (p.texImage2D(p.TEXTURE_2D, 0, p.RGBA, p.RGBA, p.UNSIGNED_BYTE, Re), p.isContextLost()) return;
            de.supported = !0
          } catch {}
          p.deleteTexture(e), Pe = !0
        }
        var Ve;
        typeof document < "u" && (Re = document.createElement("img"), Re.onload = () => {
          Fe && et(Fe), Fe = null, Ge = !0
        }, Re.onerror = () => {
          Pe = !0, Fe = null
        }, Re.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(p) {
          let e, a, c, h;
          p.resetRequestQueue = () => {
            e = [], a = 0, c = 0, h = {}
          }, p.addThrottleControl = T => {
            const C = c++;
            return h[C] = T, C
          }, p.removeThrottleControl = T => {
            delete h[T], v()
          }, p.getImage = (T, C, z = !0) => new Promise(((F, R) => {
            de.supported && (T.headers || (T.headers = {}), T.headers.accept = "image/webp,*/*"), l.e(T, {
              type: "image"
            }), e.push({
              abortController: C,
              requestParameters: T,
              supportImageRefresh: z,
              state: "queued",
              onError: U => {
                R(U)
              },
              onSuccess: U => {
                F(U)
              }
            }), v()
          }));
          const f = T => l._(this, void 0, void 0, (function*() {
              T.state = "running";
              const {
                requestParameters: C,
                supportImageRefresh: z,
                onError: F,
                onSuccess: R,
                abortController: U
              } = T, Y = z === !1 && !l.i(self) && !l.g(C.url) && (!C.headers || Object.keys(C.headers).reduce(((ae, me) => ae && me === "accept"), !0));
              a++;
              const ne = Y ? w(C, U) : l.m(C, U);
              try {
                const ae = yield ne;
                delete T.abortController, T.state = "completed", ae.data instanceof HTMLImageElement || l.b(ae.data) ? R(ae) : ae.data && R({
                  data: yield(ie = ae.data, typeof createImageBitmap == "function" ? l.f(ie) : l.h(ie)),
                  cacheControl: ae.cacheControl,
                  expires: ae.expires
                })
              } catch (ae) {
                delete T.abortController, F(ae)
              } finally {
                a--, v()
              }
              var ie
            })),
            v = () => {
              const T = (() => {
                for (const C of Object.keys(h))
                  if (h[C]()) return !0;
                return !1
              })() ? l.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : l.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let C = a; C < T && e.length > 0; C++) {
                const z = e.shift();
                z.abortController.signal.aborted ? C-- : f(z)
              }
            },
            w = (T, C) => new Promise(((z, F) => {
              const R = new Image,
                U = T.url,
                Y = T.credentials;
              Y && Y === "include" ? R.crossOrigin = "use-credentials" : (Y && Y === "same-origin" || !l.d(U)) && (R.crossOrigin = "anonymous"), C.signal.addEventListener("abort", (() => {
                R.src = "", F(l.c())
              })), R.fetchPriority = "high", R.onload = () => {
                R.onerror = R.onload = null, z({
                  data: R
                })
              }, R.onerror = () => {
                R.onerror = R.onload = null, C.signal.aborted || F(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
              }, R.src = U
            }))
        })(Ve || (Ve = {})), Ve.resetRequestQueue();
        class ve {
          constructor(e) {
            this._transformRequestFn = e ?? null
          }
          transformRequest(e, a) {
            return this._transformRequestFn && this._transformRequestFn(e, a) || {
              url: e
            }
          }
          setTransformRequest(e) {
            this._transformRequestFn = e
          }
        }

        function Me(p) {
          const e = [];
          if (typeof p == "string") e.push({
            id: "default",
            url: p
          });
          else if (p && p.length > 0) {
            const a = [];
            for (const {
                id: c,
                url: h
              }
              of p) {
              const f = `${c}${h}`;
              a.indexOf(f) === -1 && (a.push(f), e.push({
                id: c,
                url: h
              }))
            }
          }
          return e
        }

        function Ye(p, e, a) {
          try {
            const c = new URL(p);
            return c.pathname += `${e}${a}`, c.toString()
          } catch {
            throw new Error(`Invalid sprite URL "${p}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
          }
        }

        function Ce(p) {
          const {
            userImage: e
          } = p;
          return !!(e && e.render && e.render()) && (p.data.replace(new Uint8Array(e.data.buffer)), !0)
        }
        class Oe extends l.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new l.R({
              width: 1,
              height: 1
            }), this.dirty = !0
          }
          isLoaded() {
            return this.loaded
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const {
                  ids: a,
                  promiseResolve: c
                }
                of this.requestors) c(this._getImagesForIds(a));
              this.requestors = []
            }
          }
          getImage(e) {
            const a = this.images[e];
            if (a && !a.data && a.spriteData) {
              const c = a.spriteData;
              a.data = new l.R({
                width: c.width,
                height: c.height
              }, c.context.getImageData(c.x, c.y, c.width, c.height).data), a.spriteData = null
            }
            return a
          }
          addImage(e, a) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, a) && (this.images[e] = a)
          }
          _validate(e, a) {
            let c = !0;
            const h = a.data || a.spriteData;
            return this._validateStretch(a.stretchX, h && h.width) || (this.fire(new l.k(new Error(`Image "${e}" has invalid "stretchX" value`))), c = !1), this._validateStretch(a.stretchY, h && h.height) || (this.fire(new l.k(new Error(`Image "${e}" has invalid "stretchY" value`))), c = !1), this._validateContent(a.content, a) || (this.fire(new l.k(new Error(`Image "${e}" has invalid "content" value`))), c = !1), c
          }
          _validateStretch(e, a) {
            if (!e) return !0;
            let c = 0;
            for (const h of e) {
              if (h[0] < c || h[1] < h[0] || a < h[1]) return !1;
              c = h[1]
            }
            return !0
          }
          _validateContent(e, a) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const c = a.spriteData,
              h = c && c.width || a.data.width,
              f = c && c.height || a.data.height;
            return !(e[0] < 0 || h < e[0] || e[1] < 0 || f < e[1] || e[2] < 0 || h < e[2] || e[3] < 0 || f < e[3] || e[2] < e[0] || e[3] < e[1])
          }
          updateImage(e, a, c = !0) {
            const h = this.getImage(e);
            if (c && (h.data.width !== a.data.width || h.data.height !== a.data.height)) throw new Error(`size mismatch between old image (${h.data.width}x${h.data.height}) and new image (${a.data.width}x${a.data.height}).`);
            a.version = h.version + 1, this.images[e] = a, this.updatedImages[e] = !0
          }
          removeImage(e) {
            const a = this.images[e];
            delete this.images[e], delete this.patterns[e], a.userImage && a.userImage.onRemove && a.userImage.onRemove()
          }
          listImages() {
            return Object.keys(this.images)
          }
          getImages(e) {
            return new Promise(((a, c) => {
              let h = !0;
              if (!this.isLoaded())
                for (const f of e) this.images[f] || (h = !1);
              this.isLoaded() || h ? a(this._getImagesForIds(e)) : this.requestors.push({
                ids: e,
                promiseResolve: a
              })
            }))
          }
          _getImagesForIds(e) {
            const a = {};
            for (const c of e) {
              let h = this.getImage(c);
              h || (this.fire(new l.l("styleimagemissing", {
                id: c
              })), h = this.getImage(c)), h ? a[c] = {
                data: h.data.clone(),
                pixelRatio: h.pixelRatio,
                sdf: h.sdf,
                version: h.version,
                stretchX: h.stretchX,
                stretchY: h.stretchY,
                content: h.content,
                textFitWidth: h.textFitWidth,
                textFitHeight: h.textFitHeight,
                hasRenderCallback: !!(h.userImage && h.userImage.render)
              } : l.w(`Image "${c}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
            }
            return a
          }
          getPixelSize() {
            const {
              width: e,
              height: a
            } = this.atlasImage;
            return {
              width: e,
              height: a
            }
          }
          getPattern(e) {
            const a = this.patterns[e],
              c = this.getImage(e);
            if (!c) return null;
            if (a && a.position.version === c.version) return a.position;
            if (a) a.position.version = c.version;
            else {
              const h = {
                  w: c.data.width + 2,
                  h: c.data.height + 2,
                  x: 0,
                  y: 0
                },
                f = new l.I(h, c);
              this.patterns[e] = {
                bin: h,
                position: f
              }
            }
            return this._updatePatternAtlas(), this.patterns[e].position
          }
          bind(e) {
            const a = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new l.T(e, this.atlasImage, a.RGBA), this.atlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE)
          }
          _updatePatternAtlas() {
            const e = [];
            for (const f in this.patterns) e.push(this.patterns[f].bin);
            const {
              w: a,
              h: c
            } = l.p(e), h = this.atlasImage;
            h.resize({
              width: a || 1,
              height: c || 1
            });
            for (const f in this.patterns) {
              const {
                bin: v
              } = this.patterns[f], w = v.x + 1, T = v.y + 1, C = this.getImage(f).data, z = C.width, F = C.height;
              l.R.copy(C, h, {
                x: 0,
                y: 0
              }, {
                x: w,
                y: T
              }, {
                width: z,
                height: F
              }), l.R.copy(C, h, {
                x: 0,
                y: F - 1
              }, {
                x: w,
                y: T - 1
              }, {
                width: z,
                height: 1
              }), l.R.copy(C, h, {
                x: 0,
                y: 0
              }, {
                x: w,
                y: T + F
              }, {
                width: z,
                height: 1
              }), l.R.copy(C, h, {
                x: z - 1,
                y: 0
              }, {
                x: w - 1,
                y: T
              }, {
                width: 1,
                height: F
              }), l.R.copy(C, h, {
                x: 0,
                y: 0
              }, {
                x: w + z,
                y: T
              }, {
                width: 1,
                height: F
              })
            }
            this.dirty = !0
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {}
          }
          dispatchRenderCallbacks(e) {
            for (const a of e) {
              if (this.callbackDispatchedThisFrame[a]) continue;
              this.callbackDispatchedThisFrame[a] = !0;
              const c = this.getImage(a);
              c || l.w(`Image with ID: "${a}" was not found`), Ce(c) && this.updateImage(a, c)
            }
          }
        }
        const ut = 1e20;

        function Ue(p, e, a, c, h, f, v, w, T) {
          for (let C = e; C < e + c; C++) Ke(p, a * f + C, f, h, v, w, T);
          for (let C = a; C < a + h; C++) Ke(p, C * f + e, 1, c, v, w, T)
        }

        function Ke(p, e, a, c, h, f, v) {
          f[0] = 0, v[0] = -ut, v[1] = ut, h[0] = p[e];
          for (let w = 1, T = 0, C = 0; w < c; w++) {
            h[w] = p[e + w * a];
            const z = w * w;
            do {
              const F = f[T];
              C = (h[w] - h[F] + z - F * F) / (w - F) / 2
            } while (C <= v[T] && --T > -1);
            T++, f[T] = w, v[T] = C, v[T + 1] = ut
          }
          for (let w = 0, T = 0; w < c; w++) {
            for (; v[T + 1] < w;) T++;
            const C = f[T],
              z = w - C;
            p[e + w * a] = h[C] + z * z
          }
        }
        const St = l.v.layout_symbol["text-font"].default.join(",");
        class Ft {
          constructor(e, a, c) {
            this.requestManager = e, this.localIdeographFontFamily = a, this.entries = {}, this.lang = c
          }
          setURL(e) {
            this.url = e
          }
          getGlyphs(e) {
            return l._(this, void 0, void 0, (function*() {
              const a = [];
              for (const f in e)
                for (const v of e[f]) a.push(this._getAndCacheGlyphsPromise(f, v));
              const c = yield Promise.all(a), h = {};
              for (const {
                  stack: f,
                  id: v,
                  glyph: w
                }
                of c) h[f] || (h[f] = {}), h[f][v] = w && {
                id: w.id,
                bitmap: w.bitmap.clone(),
                metrics: w.metrics
              };
              return h
            }))
          }
          _getAndCacheGlyphsPromise(e, a) {
            return l._(this, void 0, void 0, (function*() {
              let c = this.entries[e];
              c || (c = this.entries[e] = {
                glyphs: {},
                requests: {},
                ranges: {}
              });
              let h = c.glyphs[a];
              return h !== void 0 ? {
                stack: e,
                id: a,
                glyph: h
              } : !this.url || this._charUsesLocalIdeographFontFamily(a) ? (h = c.glyphs[a] = this._drawGlyph(c, e, a), {
                stack: e,
                id: a,
                glyph: h
              }) : yield this._downloadAndCacheRangePromise(e, a)
            }))
          }
          _downloadAndCacheRangePromise(e, a) {
            return l._(this, void 0, void 0, (function*() {
              const c = Math.floor(a / 256);
              if (256 * c > 65535) throw new Error("glyphs > 65535 not supported");
              const h = this.entries[e];
              if (h.ranges[c]) return {
                stack: e,
                id: a,
                glyph: null
              };
              if (!h.requests[c]) {
                const f = Ft.loadGlyphRange(e, c, this.url, this.requestManager);
                h.requests[c] = f
              }
              try {
                const f = yield h.requests[c];
                for (const v in f) h.glyphs[+v] = f[+v];
                return h.ranges[c] = !0, {
                  stack: e,
                  id: a,
                  glyph: f[a] || null
                }
              } catch (f) {
                const v = h.glyphs[a] = this._drawGlyph(h, e, a);
                return this._warnOnMissingGlyphRange(v, c, a, f), {
                  stack: e,
                  id: a,
                  glyph: v
                }
              }
            }))
          }
          _warnOnMissingGlyphRange(e, a, c, h) {
            const f = 256 * a,
              v = f + 255,
              w = c.toString(16).padStart(4, "0").toUpperCase();
            l.w(`Unable to load glyph range ${a}, ${f}-${v}. Rendering codepoint U+${w} locally instead. ${h}`)
          }
          _charUsesLocalIdeographFontFamily(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || l.u["CJK Unified Ideographs"](e) || l.u["Hangul Syllables"](e) || l.u.Hiragana(e) || l.u.Katakana(e) || l.u["CJK Symbols and Punctuation"](e) || l.u["Halfwidth and Fullwidth Forms"](e))
          }
          _drawGlyph(e, a, c) {
            const h = a === St && this.localIdeographFontFamily !== "" && this._charUsesLocalIdeographFontFamily(c),
              f = h ? "ideographTinySDF" : "tinySDF";
            e[f] || (e[f] = this._createTinySDF(h ? this.localIdeographFontFamily : a));
            const v = e[f].draw(String.fromCharCode(c));
            return {
              id: c,
              bitmap: new l.q({
                width: v.width || 60,
                height: v.height || 60
              }, v.data),
              metrics: {
                width: v.glyphWidth / 2 || 24,
                height: v.glyphHeight / 2 || 24,
                left: v.glyphLeft / 2 + .5 || 0,
                top: v.glyphTop / 2 - 27.5 || -8,
                advance: v.glyphAdvance / 2 || 24,
                isDoubleResolution: !0
              }
            }
          }
          _createTinySDF(e) {
            const a = e ? e.split(",") : [];
            a.push("sans-serif");
            const c = a.map((h => /[-\w]+/.test(h) ? h : `'${CSS.escape(h)}'`)).join(",");
            return new Ft.TinySDF({
              fontSize: 48,
              buffer: 6,
              radius: 16,
              cutoff: .25,
              fontFamily: c,
              fontWeight: this._fontWeight(a[0]),
              fontStyle: this._fontStyle(a[0]),
              lang: this.lang
            })
          }
          _fontStyle(e) {
            return /italic/i.test(e) ? "italic" : /oblique/i.test(e) ? "oblique" : "normal"
          }
          _fontWeight(e) {
            const a = {
              thin: 100,
              hairline: 100,
              "extra light": 200,
              "ultra light": 200,
              light: 300,
              normal: 400,
              regular: 400,
              medium: 500,
              semibold: 600,
              demibold: 600,
              bold: 700,
              "extra bold": 800,
              "ultra bold": 800,
              black: 900,
              heavy: 900,
              "extra black": 950,
              "ultra black": 950
            };
            let c;
            for (const [h, f] of Object.entries(a)) new RegExp(`\\b${h}\\b`, "i").test(e) && (c = `${f}`);
            return c
          }
        }
        Ft.loadGlyphRange = function(p, e, a, c) {
          return l._(this, void 0, void 0, (function*() {
            const h = 256 * e,
              f = h + 255,
              v = c.transformRequest(a.replace("{fontstack}", p).replace("{range}", `${h}-${f}`), "Glyphs"),
              w = yield l.n(v, new AbortController);
            if (!w || !w.data) throw new Error(`Could not load glyph range. range: ${e}, ${h}-${f}`);
            const T = {};
            for (const C of l.o(w.data)) T[C.id] = C;
            return T
          }))
        }, Ft.TinySDF = class {
          constructor({
            fontSize: p = 24,
            buffer: e = 3,
            radius: a = 8,
            cutoff: c = .25,
            fontFamily: h = "sans-serif",
            fontWeight: f = "normal",
            fontStyle: v = "normal",
            lang: w = null
          } = {}) {
            this.buffer = e, this.cutoff = c, this.radius = a, this.lang = w;
            const T = this.size = p + 4 * e,
              C = this._createCanvas(T),
              z = this.ctx = C.getContext("2d", {
                willReadFrequently: !0
              });
            z.font = `${v} ${f} ${p}px ${h}`, z.textBaseline = "alphabetic", z.textAlign = "left", z.fillStyle = "black", this.gridOuter = new Float64Array(T * T), this.gridInner = new Float64Array(T * T), this.f = new Float64Array(T), this.z = new Float64Array(T + 1), this.v = new Uint16Array(T)
          }
          _createCanvas(p) {
            const e = document.createElement("canvas");
            return e.width = e.height = p, e
          }
          draw(p) {
            const {
              width: e,
              actualBoundingBoxAscent: a,
              actualBoundingBoxDescent: c,
              actualBoundingBoxLeft: h,
              actualBoundingBoxRight: f
            } = this.ctx.measureText(p), v = Math.ceil(a), w = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(f - h))), T = Math.min(this.size - this.buffer, v + Math.ceil(c)), C = w + 2 * this.buffer, z = T + 2 * this.buffer, F = Math.max(C * z, 0), R = new Uint8ClampedArray(F), U = {
              data: R,
              width: C,
              height: z,
              glyphWidth: w,
              glyphHeight: T,
              glyphTop: v,
              glyphLeft: 0,
              glyphAdvance: e
            };
            if (w === 0 || T === 0) return U;
            const {
              ctx: Y,
              buffer: ne,
              gridInner: ie,
              gridOuter: ae
            } = this;
            this.lang && (Y.lang = this.lang), Y.clearRect(ne, ne, w, T), Y.fillText(p, ne, ne + v);
            const me = Y.getImageData(ne, ne, w, T);
            ae.fill(ut, 0, F), ie.fill(0, 0, F);
            for (let ke = 0; ke < T; ke++)
              for (let _e = 0; _e < w; _e++) {
                const Te = me.data[4 * (ke * w + _e) + 3] / 255;
                if (Te === 0) continue;
                const Ee = (ke + ne) * C + _e + ne;
                if (Te === 1) ae[Ee] = 0, ie[Ee] = ut;
                else {
                  const ye = .5 - Te;
                  ae[Ee] = ye > 0 ? ye * ye : 0, ie[Ee] = ye < 0 ? ye * ye : 0
                }
              }
            Ue(ae, 0, 0, C, z, C, this.f, this.v, this.z), Ue(ie, ne, ne, w, T, C, this.f, this.v, this.z);
            for (let ke = 0; ke < F; ke++) {
              const _e = Math.sqrt(ae[ke]) - Math.sqrt(ie[ke]);
              R[ke] = Math.round(255 - 255 * (_e / this.radius + this.cutoff))
            }
            return U
          }
        };
        class Jt {
          constructor() {
            this.specification = l.t.light.position
          }
          possiblyEvaluate(e, a) {
            return l.C(e.expression.evaluate(a))
          }
          interpolate(e, a, c) {
            return {
              x: l.F.number(e.x, a.x, c),
              y: l.F.number(e.y, a.y, c),
              z: l.F.number(e.z, a.z, c)
            }
          }
        }
        let Mt;
        class ct extends l.E {
          constructor(e) {
            super(), Mt = Mt || new l.r({
              anchor: new l.D(l.t.light.anchor),
              position: new Jt,
              color: new l.D(l.t.light.color),
              intensity: new l.D(l.t.light.intensity)
            }), this._transitionable = new l.x(Mt, void 0), this.setLight(e), this._transitioning = this._transitionable.untransitioned()
          }
          getLight() {
            return this._transitionable.serialize()
          }
          setLight(e, a = {}) {
            if (!this._validate(l.y, e, a))
              for (const c in e) {
                const h = e[c];
                c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), h) : this._transitionable.setValue(c, h)
              }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, a, c) {
            return (!c || c.validate !== !1) && l.z(this, e.call(l.B, {
              value: a,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: l.t
            }))
          }
        }
        const wt = new l.r({
          "sky-color": new l.D(l.t.sky["sky-color"]),
          "horizon-color": new l.D(l.t.sky["horizon-color"]),
          "fog-color": new l.D(l.t.sky["fog-color"]),
          "fog-ground-blend": new l.D(l.t.sky["fog-ground-blend"]),
          "horizon-fog-blend": new l.D(l.t.sky["horizon-fog-blend"]),
          "sky-horizon-blend": new l.D(l.t.sky["sky-horizon-blend"]),
          "atmosphere-blend": new l.D(l.t.sky["atmosphere-blend"])
        });
        class ft extends l.E {
          constructor(e) {
            super(), this._transitionable = new l.x(wt, void 0), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new l.G(0))
          }
          setSky(e, a = {}) {
            if (!this._validate(l.H, e, a)) {
              e || (e = {
                "sky-color": "transparent",
                "horizon-color": "transparent",
                "fog-color": "transparent",
                "fog-ground-blend": 1,
                "atmosphere-blend": 0
              });
              for (const c in e) {
                const h = e[c];
                c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), h) : this._transitionable.setValue(c, h)
              }
            }
          }
          getSky() {
            return this._transitionable.serialize()
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, a, c = {}) {
            return (c == null ? void 0 : c.validate) !== !1 && l.z(this, e.call(l.B, l.e({
              value: a,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: l.t
            })))
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
          }
        }
        class $t {
          constructor(e, a) {
            this.width = e, this.height = a, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {}
          }
          getDash(e, a) {
            const c = e.join(",") + String(a);
            return this.dashEntry[c] || (this.dashEntry[c] = this.addDash(e, a)), this.dashEntry[c]
          }
          getDashRanges(e, a, c) {
            const h = [];
            let f = e.length % 2 == 1 ? -e[e.length - 1] * c : 0,
              v = e[0] * c,
              w = !0;
            h.push({
              left: f,
              right: v,
              isDash: w,
              zeroLength: e[0] === 0
            });
            let T = e[0];
            for (let C = 1; C < e.length; C++) {
              w = !w;
              const z = e[C];
              f = T * c, T += z, v = T * c, h.push({
                left: f,
                right: v,
                isDash: w,
                zeroLength: z === 0
              })
            }
            return h
          }
          addRoundDash(e, a, c) {
            const h = a / 2;
            for (let f = -c; f <= c; f++) {
              const v = this.width * (this.nextRow + c + f);
              let w = 0,
                T = e[w];
              for (let C = 0; C < this.width; C++) {
                C / T.right > 1 && (T = e[++w]);
                const z = Math.abs(C - T.left),
                  F = Math.abs(C - T.right),
                  R = Math.min(z, F);
                let U;
                const Y = f / c * (h + 1);
                if (T.isDash) {
                  const ne = h - Math.abs(Y);
                  U = Math.sqrt(R * R + ne * ne)
                } else U = h - Math.sqrt(R * R + Y * Y);
                this.data[v + C] = Math.max(0, Math.min(255, U + 128))
              }
            }
          }
          addRegularDash(e) {
            for (let w = e.length - 1; w >= 0; --w) {
              const T = e[w],
                C = e[w + 1];
              T.zeroLength ? e.splice(w, 1) : C && C.isDash === T.isDash && (C.left = T.left, e.splice(w, 1))
            }
            const a = e[0],
              c = e[e.length - 1];
            a.isDash === c.isDash && (a.left = c.left - this.width, c.right = a.right + this.width);
            const h = this.width * this.nextRow;
            let f = 0,
              v = e[f];
            for (let w = 0; w < this.width; w++) {
              w / v.right > 1 && (v = e[++f]);
              const T = Math.abs(w - v.left),
                C = Math.abs(w - v.right),
                z = Math.min(T, C);
              this.data[h + w] = Math.max(0, Math.min(255, (v.isDash ? z : -z) + 128))
            }
          }
          addDash(e, a) {
            const c = a ? 7 : 0,
              h = 2 * c + 1;
            if (this.nextRow + h > this.height) return l.w("LineAtlas out of space"), null;
            let f = 0;
            for (let w = 0; w < e.length; w++) f += e[w];
            if (f !== 0) {
              const w = this.width / f,
                T = this.getDashRanges(e, this.width, w);
              a ? this.addRoundDash(T, w, c) : this.addRegularDash(T)
            }
            const v = {
              y: this.nextRow + c,
              height: 2 * c,
              width: f
            };
            return this.nextRow += h, this.dirty = !0, v
          }
          bind(e) {
            const a = e.gl;
            this.texture ? (a.bindTexture(a.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this.width, this.height, a.ALPHA, a.UNSIGNED_BYTE, this.data))) : (this.texture = a.createTexture(), a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), a.texImage2D(a.TEXTURE_2D, 0, a.ALPHA, this.width, this.height, 0, a.ALPHA, a.UNSIGNED_BYTE, this.data))
          }
        }
        const Et = "maplibre_preloaded_worker_pool";
        class Qt {
          constructor() {
            this.active = {}
          }
          acquire(e) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < Qt.workerCount;) this.workers.push(new Worker(l.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice()
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach((a => {
              a.terminate()
            })), this.workers = null)
          }
          isPreloaded() {
            return !!this.active[Et]
          }
          numActive() {
            return Object.keys(this.active).length
          }
        }
        const vr = Math.floor(ce.hardwareConcurrency / 2);
        let Kt, Bt;

        function it() {
          return Kt || (Kt = new Qt), Kt
        }
        Qt.workerCount = l.J(globalThis) ? Math.max(Math.min(vr, 3), 1) : 1;
        class He {
          constructor(e, a) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = a;
            const c = this.workerPool.acquire(a);
            for (let h = 0; h < c.length; h++) {
              const f = new l.K(c[h], a);
              f.name = `Worker ${h}`, this.actors.push(f)
            }
            if (!this.actors.length) throw new Error("No actors found")
          }
          broadcast(e, a) {
            const c = [];
            for (const h of this.actors) c.push(h.sendAsync({
              type: e,
              data: a
            }));
            return Promise.all(c)
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
          }
          remove(e = !0) {
            this.actors.forEach((a => {
              a.remove()
            })), this.actors = [], e && this.workerPool.release(this.id)
          }
          registerMessageHandler(e, a) {
            for (const c of this.actors) c.registerMessageHandler(e, a)
          }
        }

        function Ot() {
          return Bt || (Bt = new He(it(), l.L), Bt.registerMessageHandler("GR", ((p, e, a) => l.m(e, a)))), Bt
        }

        function Gt(p, e) {
          const a = l.M();
          return l.N(a, a, [1, 1, 0]), l.O(a, a, [.5 * p.width, .5 * p.height, 1]), p.calculatePosMatrix ? l.Q(a, a, p.calculatePosMatrix(e.toUnwrapped())) : a
        }

        function kt(p, e, a, c, h, f, v) {
          var w;
          const T = (function(R, U, Y) {
              if (R)
                for (const ne of R) {
                  const ie = U[ne];
                  if (ie && ie.source === Y && ie.type === "fill-extrusion") return !0
                } else
                  for (const ne in U) {
                    const ie = U[ne];
                    if (ie.source === Y && ie.type === "fill-extrusion") return !0
                  }
              return !1
            })((w = h == null ? void 0 : h.layers) !== null && w !== void 0 ? w : null, e, p.id),
            C = f.maxPitchScaleFactor(),
            z = p.tilesIn(c, C, T);
          z.sort(nr);
          const F = [];
          for (const R of z) F.push({
            wrappedTileID: R.tileID.wrapped().key,
            queryResults: R.tile.queryRenderedFeatures(e, a, p.getState(), R.queryGeometry, R.cameraQueryGeometry, R.scale, h, f, C, Gt(f, R.tileID), v ? (U, Y) => v(R.tileID, U, Y) : void 0)
          });
          return (function(R, U) {
            for (const Y in R)
              for (const ne of R[Y]) It(ne, U);
            return R
          })((function(R) {
            const U = {},
              Y = {};
            for (const ne of R) {
              const ie = ne.queryResults,
                ae = ne.wrappedTileID,
                me = Y[ae] = Y[ae] || {};
              for (const ke in ie) {
                const _e = ie[ke],
                  Te = me[ke] = me[ke] || {},
                  Ee = U[ke] = U[ke] || [];
                for (const ye of _e) Te[ye.featureIndex] || (Te[ye.featureIndex] = !0, Ee.push(ye))
              }
            }
            return U
          })(F), p)
        }

        function nr(p, e) {
          const a = p.tileID,
            c = e.tileID;
          return a.overscaledZ - c.overscaledZ || a.canonical.y - c.canonical.y || a.wrap - c.wrap || a.canonical.x - c.canonical.x
        }

        function It(p, e) {
          const a = p.feature,
            c = e.getFeatureState(a.layer["source-layer"], a.id);
          a.source = a.layer.source, a.layer["source-layer"] && (a.sourceLayer = a.layer["source-layer"]), a.state = c
        }

        function mt(p, e, a) {
          return l._(this, void 0, void 0, (function*() {
            let c = p;
            if (p.url ? c = (yield l.j(e.transformRequest(p.url, "Source"), a)).data : yield ce.frameAsync(a), !c) return null;
            const h = l.S(l.e(c, p), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in c && c.vector_layers && (h.vectorLayerIds = c.vector_layers.map((f => f.id))), h
          }))
        }
        class yt {
          constructor(e, a) {
            e && (a ? this.setSouthWest(e).setNorthEast(a) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
          }
          setNorthEast(e) {
            return this._ne = e instanceof l.U ? new l.U(e.lng, e.lat) : l.U.convert(e), this
          }
          setSouthWest(e) {
            return this._sw = e instanceof l.U ? new l.U(e.lng, e.lat) : l.U.convert(e), this
          }
          extend(e) {
            const a = this._sw,
              c = this._ne;
            let h, f;
            if (e instanceof l.U) h = e, f = e;
            else {
              if (!(e instanceof yt)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(yt.convert(e)) : this.extend(l.U.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(l.U.convert(e)) : this;
              if (h = e._sw, f = e._ne, !h || !f) return this
            }
            return a || c ? (a.lng = Math.min(h.lng, a.lng), a.lat = Math.min(h.lat, a.lat), c.lng = Math.max(f.lng, c.lng), c.lat = Math.max(f.lat, c.lat)) : (this._sw = new l.U(h.lng, h.lat), this._ne = new l.U(f.lng, f.lat)), this
          }
          getCenter() {
            return new l.U((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
          }
          getSouthWest() {
            return this._sw
          }
          getNorthEast() {
            return this._ne
          }
          getNorthWest() {
            return new l.U(this.getWest(), this.getNorth())
          }
          getSouthEast() {
            return new l.U(this.getEast(), this.getSouth())
          }
          getWest() {
            return this._sw.lng
          }
          getSouth() {
            return this._sw.lat
          }
          getEast() {
            return this._ne.lng
          }
          getNorth() {
            return this._ne.lat
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()]
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
          }
          isEmpty() {
            return !(this._sw && this._ne)
          }
          contains(e) {
            const {
              lng: a,
              lat: c
            } = l.U.convert(e);
            let h = this._sw.lng <= a && a <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (h = this._sw.lng >= a && a >= this._ne.lng), this._sw.lat <= c && c <= this._ne.lat && h
          }
          intersects(e) {
            if ((e = yt.convert(e)).getNorth() < this.getSouth() || e.getSouth() > this.getNorth()) return !1;
            const a = l.V(this.getWest(), -180, 180),
              c = l.V(this.getEast(), -180, 180),
              h = l.V(e.getWest(), -180, 180),
              f = l.V(e.getEast(), -180, 180),
              v = a > c,
              w = h > f;
            return !(!v || !w) || (v ? f >= a || h <= c : w ? c >= h || a <= f : !(h > c || f < a))
          }
          static convert(e) {
            return e instanceof yt ? e : e && new yt(e)
          }
          static fromLngLat(e, a = 0) {
            const c = 360 * a / 40075017,
              h = c / Math.cos(Math.PI / 180 * e.lat);
            return new yt(new l.U(e.lng - h, e.lat - c), new l.U(e.lng + h, e.lat + c))
          }
          adjustAntiMeridian() {
            const e = new l.U(this._sw.lng, this._sw.lat),
              a = new l.U(this._ne.lng, this._ne.lat);
            return new yt(e, e.lng > a.lng ? new l.U(a.lng + 360, a.lat) : a)
          }
        }
        class bt {
          constructor(e, a, c) {
            this.bounds = yt.convert(this.validateBounds(e)), this.minzoom = a || 0, this.maxzoom = c || 24
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
          }
          contains(e) {
            const a = Math.pow(2, e.z),
              c = Math.floor(l.X(this.bounds.getWest()) * a),
              h = Math.floor(l.W(this.bounds.getNorth()) * a),
              f = Math.ceil(l.X(this.bounds.getEast()) * a),
              v = Math.ceil(l.W(this.bounds.getSouth()) * a);
            return e.x >= c && e.x < f && e.y >= h && e.y < v
          }
        }
        class Lt extends l.E {
          constructor(e, a, c, h) {
            if (super(), this.id = e, this.dispatcher = c, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, l.e(this, l.S(a, ["url", "scheme", "tileSize", "promoteId"])), this._options = l.e({
                type: "vector"
              }, a), this._collectResourceTiming = a.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(h)
          }
          load() {
            return l._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new l.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const e = yield mt(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.tileManagers[this.id].clearTiles(), e && (l.e(this, e), e.bounds && (this.tileBounds = new bt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new l.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new l.l("data", {
                  dataType: "source",
                  sourceDataType: "content"
                })))
              } catch (e) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new l.k(e))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load()
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          serialize() {
            return l.e({}, this._options)
          }
          loadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                c = {
                  request: this.map._requestManager.transformRequest(a, "Tile"),
                  uid: e.uid,
                  tileID: e.tileID,
                  zoom: e.tileID.overscaledZ,
                  tileSize: this.tileSize * e.tileID.overscaleFactor(),
                  type: this.type,
                  source: this.id,
                  pixelRatio: this.map.getPixelRatio(),
                  showCollisionBoxes: this.map.showCollisionBoxes,
                  promoteId: this.promoteId,
                  subdivisionGranularity: this.map.style.projection.subdivisionGranularity
                };
              c.request.collectResourceTiming = this._collectResourceTiming;
              let h = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((f, v) => {
                  e.reloadPromise = {
                    resolve: f,
                    reject: v
                  }
                }))
              } else e.actor = this.dispatcher.getActor(), h = "LT";
              e.abortController = new AbortController;
              try {
                const f = yield e.actor.sendAsync({
                  type: h,
                  data: c
                }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, f)
              } catch (f) {
                if (delete e.abortController, e.aborted) return;
                if (f && f.status !== 404) throw f;
                this._afterTileLoadWorkerResponse(e, null)
              }
            }))
          }
          _afterTileLoadWorkerResponse(e, a) {
            if (a && a.resourceTiming && (e.resourceTiming = a.resourceTiming), a && this.map._refreshExpiredTiles && e.setExpiryData(a), e.loadVectorData(a, this.map.painter), e.reloadPromise) {
              const c = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(c.resolve).catch(c.reject)
            }
          }
          abortTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({
                type: "AT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          unloadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class st extends l.E {
          constructor(e, a, c, h) {
            super(), this.id = e, this.dispatcher = c, this.setEventedParent(h), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = l.e({
              type: "raster"
            }, a), l.e(this, l.S(a, ["url", "scheme", "tileSize"]))
          }
          load() {
            return l._(this, arguments, void 0, (function*(e = !1) {
              this._loaded = !1, this.fire(new l.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const a = yield mt(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, a && (l.e(this, a), a.bounds && (this.tileBounds = new bt(a.bounds, this.minzoom, this.maxzoom)), this.fire(new l.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new l.l("data", {
                  dataType: "source",
                  sourceDataType: "content",
                  sourceDataChanged: e
                })))
              } catch (a) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new l.k(a))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0)
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          serialize() {
            return l.e({}, this._options)
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          loadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController;
              try {
                const c = yield Ve.getImage(this.map._requestManager.transformRequest(a, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (c && c.data) {
                  this.map._refreshExpiredTiles && (c.cacheControl || c.expires) && e.setExpiryData({
                    cacheControl: c.cacheControl,
                    expires: c.expires
                  });
                  const h = this.map.painter.context,
                    f = h.gl,
                    v = c.data;
                  e.texture = this.map.painter.getTileTexture(v.width), e.texture ? e.texture.update(v, {
                    useMipmap: !0
                  }) : (e.texture = new l.T(h, v, f.RGBA, {
                    useMipmap: !0
                  }), e.texture.bind(f.LINEAR, f.CLAMP_TO_EDGE, f.LINEAR_MIPMAP_NEAREST)), e.state = "loaded"
                }
              } catch (c) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (c) throw e.state = "errored", c
              }
            }))
          }
          abortTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController)
            }))
          }
          unloadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.texture && this.map.painter.saveTileTexture(e.texture)
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class lr extends st {
          constructor(e, a, c, h) {
            super(e, a, c, h), this.type = "raster-dem", this.maxzoom = 22, this._options = l.e({
              type: "raster-dem"
            }, a), this.encoding = a.encoding || "mapbox", this.redFactor = a.redFactor, this.greenFactor = a.greenFactor, this.blueFactor = a.blueFactor, this.baseShift = a.baseShift
          }
          loadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                c = this.map._requestManager.transformRequest(a, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController;
              try {
                const h = yield Ve.getImage(c, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (h && h.data) {
                  const f = h.data;
                  this.map._refreshExpiredTiles && (h.cacheControl || h.expires) && e.setExpiryData({
                    cacheControl: h.cacheControl,
                    expires: h.expires
                  });
                  const v = l.b(f) && l.Y() ? f : yield this.readImageNow(f), w = {
                    type: this.type,
                    uid: e.uid,
                    source: this.id,
                    rawImageData: v,
                    encoding: this.encoding,
                    redFactor: this.redFactor,
                    greenFactor: this.greenFactor,
                    blueFactor: this.blueFactor,
                    baseShift: this.baseShift
                  };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const T = yield e.actor.sendAsync({
                      type: "LDT",
                      data: w
                    });
                    e.dem = T, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded"
                  }
                }
              } catch (h) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (h) throw e.state = "errored", h
              }
            }))
          }
          readImageNow(e) {
            return l._(this, void 0, void 0, (function*() {
              if (typeof VideoFrame < "u" && l.Z()) {
                const a = e.width + 2,
                  c = e.height + 2;
                try {
                  return new l.R({
                    width: a,
                    height: c
                  }, yield l.$(e, -1, -1, a, c))
                } catch {}
              }
              return ce.getImageData(e, 1)
            }))
          }
          _getNeighboringTiles(e) {
            const a = e.canonical,
              c = Math.pow(2, a.z),
              h = (a.x - 1 + c) % c,
              f = a.x === 0 ? e.wrap - 1 : e.wrap,
              v = (a.x + 1 + c) % c,
              w = a.x + 1 === c ? e.wrap + 1 : e.wrap,
              T = {};
            return T[new l.a0(e.overscaledZ, f, a.z, h, a.y).key] = {
              backfilled: !1
            }, T[new l.a0(e.overscaledZ, w, a.z, v, a.y).key] = {
              backfilled: !1
            }, a.y > 0 && (T[new l.a0(e.overscaledZ, f, a.z, h, a.y - 1).key] = {
              backfilled: !1
            }, T[new l.a0(e.overscaledZ, e.wrap, a.z, a.x, a.y - 1).key] = {
              backfilled: !1
            }, T[new l.a0(e.overscaledZ, w, a.z, v, a.y - 1).key] = {
              backfilled: !1
            }), a.y + 1 < c && (T[new l.a0(e.overscaledZ, f, a.z, h, a.y + 1).key] = {
              backfilled: !1
            }, T[new l.a0(e.overscaledZ, e.wrap, a.z, a.x, a.y + 1).key] = {
              backfilled: !1
            }, T[new l.a0(e.overscaledZ, w, a.z, v, a.y + 1).key] = {
              backfilled: !1
            }), T
          }
          unloadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({
                type: "RDT",
                data: {
                  type: this.type,
                  uid: e.uid,
                  source: this.id
                }
              }))
            }))
          }
        }

        function gr(p) {
          return p.type === "GeometryCollection" ? p.geometries.map((e => e.coordinates)).flat(1 / 0) : p.coordinates.flat(1 / 0)
        }

        function dr(p) {
          const e = new yt;
          let a;
          switch (p.type) {
            case "FeatureCollection":
              a = p.features.map((c => gr(c.geometry))).flat(1 / 0);
              break;
            case "Feature":
              a = gr(p.geometry);
              break;
            default:
              a = gr(p)
          }
          if (a.length == 0) return e;
          for (let c = 0; c < a.length - 1; c += 2) e.extend([a[c], a[c + 1]]);
          return e
        }
        class pr extends l.E {
          constructor(e, a, c, h) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = {
              data: a.data
            }, this.actor = c.getActor(), this.setEventedParent(h), this._data = a.data, this._options = l.e({}, a), this._collectResourceTiming = a.collectResourceTiming, a.maxzoom !== void 0 && (this.maxzoom = a.maxzoom), a.type && (this.type = a.type), a.attribution && (this.attribution = a.attribution), this.promoteId = a.promoteId, a.clusterMaxZoom !== void 0 && this.maxzoom <= a.clusterMaxZoom && l.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${a.clusterMaxZoom}".`), this.workerOptions = l.e({
              source: this.id,
              cluster: a.cluster || !1,
              geojsonVtOptions: {
                buffer: this._pixelsToTileUnits(a.buffer !== void 0 ? a.buffer : 128),
                tolerance: this._pixelsToTileUnits(a.tolerance !== void 0 ? a.tolerance : .375),
                extent: l.a3,
                maxZoom: this.maxzoom,
                lineMetrics: a.lineMetrics || !1,
                generateId: a.generateId || !1
              },
              superclusterOptions: {
                maxZoom: this._getClusterMaxZoom(a.clusterMaxZoom),
                minPoints: Math.max(2, a.clusterMinPoints || 2),
                extent: l.a3,
                radius: this._pixelsToTileUnits(a.clusterRadius || 50),
                log: !1,
                generateId: a.generateId || !1
              },
              clusterProperties: a.clusterProperties,
              filter: a.filter
            }, a.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
          }
          _hasPendingWorkerUpdate() {
            return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged
          }
          _pixelsToTileUnits(e) {
            return e * (l.a3 / this.tileSize)
          }
          _getClusterMaxZoom(e) {
            const a = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || l.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${a}"`), a
          }
          load() {
            return l._(this, void 0, void 0, (function*() {
              yield this._updateWorkerData()
            }))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = {
              data: e
            }, this._updateWorkerData(), this
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = l.a4(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this
          }
          getData() {
            return l._(this, void 0, void 0, (function*() {
              const e = l.e({
                type: this.type
              }, this.workerOptions);
              return this.actor.sendAsync({
                type: "GD",
                data: e
              })
            }))
          }
          getBounds() {
            return l._(this, void 0, void 0, (function*() {
              return dr(yield this.getData())
            }))
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({
              type: "GCEZ",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({
              type: "GCC",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterLeaves(e, a, c) {
            return this.actor.sendAsync({
              type: "GCL",
              data: {
                type: this.type,
                source: this.id,
                clusterId: e,
                limit: a,
                offset: c
              }
            })
          }
          _updateWorkerData() {
            return l._(this, void 0, void 0, (function*() {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void l.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const {
                data: e,
                diff: a
              } = this._pendingWorkerUpdate, c = l.e({
                type: this.type
              }, this.workerOptions);
              e ? (typeof e == "string" ? (c.request = this.map._requestManager.transformRequest(ce.resolveURL(e), "Source"), c.request.collectResourceTiming = this._collectResourceTiming) : c.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : a && (c.dataDiff = a, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = !0, this.fire(new l.l("dataloading", {
                dataType: "source"
              }));
              try {
                const h = yield this.actor.sendAsync({
                  type: "LD",
                  data: c
                });
                if (this._isUpdatingWorker = !1, this._removed || h.abandoned) return void this.fire(new l.l("dataabort", {
                  dataType: "source"
                }));
                this._data = h.data;
                let f = null;
                h.resourceTiming && h.resourceTiming[this.id] && (f = h.resourceTiming[this.id].slice(0));
                const v = {
                  dataType: "source"
                };
                this._collectResourceTiming && f && f.length > 0 && l.e(v, {
                  resourceTiming: f
                }), this.fire(new l.l("data", Object.assign(Object.assign({}, v), {
                  sourceDataType: "metadata"
                }))), this.fire(new l.l("data", Object.assign(Object.assign({}, v), {
                  sourceDataType: "content",
                  shouldReloadTileOptions: this._getShouldReloadTileOptions(a)
                })))
              } catch (h) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new l.l("dataabort", {
                  dataType: "source"
                }));
                this.fire(new l.k(h))
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData()
              }
            }))
          }
          _getShouldReloadTileOptions(e) {
            if (!e || e.removeAll) return;
            const {
              add: a = [],
              update: c = [],
              remove: h = []
            } = e || {}, f = new Set([...c.map((v => v.id)), ...h]);
            return {
              nextBounds: [...c.map((v => v.newGeometry)), ...a.map((v => v.geometry))].map((v => dr(v))),
              prevIds: f
            }
          }
          shouldReloadTile(e, {
            nextBounds: a,
            prevIds: c
          }) {
            const h = e.latestFeatureIndex.loadVTLayers();
            for (let T = 0; T < e.latestFeatureIndex.featureIndexArray.length; T++) {
              const C = e.latestFeatureIndex.featureIndexArray.get(T),
                z = h._geojsonTileLayer.feature(C.featureIndex);
              if (c.has(z.id)) return !0
            }
            const {
              buffer: f,
              extent: v
            } = this.workerOptions.geojsonVtOptions, w = (function({
              x: T,
              y: C,
              z
            }, F = 0) {
              const R = l.a1((T - F) / Math.pow(2, z)),
                U = l.a2((C + 1 + F) / Math.pow(2, z)),
                Y = l.a1((T + 1 + F) / Math.pow(2, z)),
                ne = l.a2((C - F) / Math.pow(2, z));
              return new yt([R, U], [Y, ne])
            })(e.tileID.canonical, f / v);
            for (const T of a)
              if (w.intersects(T)) return !0;
            return !1
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate()
          }
          loadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              const a = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const c = {
                type: this.type,
                uid: e.uid,
                tileID: e.tileID,
                zoom: e.tileID.overscaledZ,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity: this.map.style.projection.subdivisionGranularity
              };
              e.abortController = new AbortController;
              const h = yield this.actor.sendAsync({
                type: a,
                data: c
              }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(h, this.map.painter, a === "RT")
            }))
          }
          abortTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0
            }))
          }
          unloadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), yield this.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              })
            }))
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({
              type: "RS",
              data: {
                type: this.type,
                source: this.id
              }
            })
          }
          serialize() {
            return l.e({}, this._options, {
              type: this.type,
              data: this._data
            })
          }
          hasTransition() {
            return !1
          }
        }
        class Ht extends l.E {
          constructor(e, a, c, h) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = c, this.coordinates = a.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(h), this.options = a
          }
          load(e) {
            return l._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new l.l("dataloading", {
                dataType: "source"
              })), this.url = this.options.url, this._request = new AbortController;
              try {
                const a = yield Ve.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, a && a.data && (this.image = a.data, e && (this.coordinates = e), this._finishLoading())
              } catch (a) {
                this._request = null, this._loaded = !0, this.fire(new l.k(a))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null
            })), this) : this
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new l.l("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null)
          }
          setCoordinates(e) {
            this.coordinates = e;
            const a = e.map(l.a5.fromLngLat);
            var c;
            return this.tileID = (function(h) {
              const f = l.a6.fromPoints(h),
                v = f.width(),
                w = f.height(),
                T = Math.max(v, w),
                C = Math.max(0, Math.floor(-Math.log(T) / Math.LN2)),
                z = Math.pow(2, C);
              return new l.a8(C, Math.floor((f.minX + f.maxX) / 2 * z), Math.floor((f.minY + f.maxY) / 2 * z))
            })(a), this.terrainTileRanges = this._getOverlappingTileRanges(a), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = a.map((h => this.tileID.getTilePoint(h)._round())), this.flippedWindingOrder = ((c = this.tileCoords)[1].x - c[0].x) * (c[2].y - c[0].y) - (c[1].y - c[0].y) * (c[2].x - c[0].x) < 0, this.fire(new l.l("data", {
              dataType: "source",
              sourceDataType: "content"
            })), this
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context,
              a = e.gl;
            this.texture || (this.texture = new l.T(e, this.image, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let c = !1;
            for (const h in this.tiles) {
              const f = this.tiles[h];
              f.state !== "loaded" && (f.state = "loaded", f.texture = this.texture, c = !0)
            }
            c && this.fire(new l.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          loadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored"
            }))
          }
          serialize() {
            return {
              type: "image",
              url: this.options.url,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return !1
          }
          _getOverlappingTileRanges(e) {
            const {
              minX: a,
              minY: c,
              maxX: h,
              maxY: f
            } = l.a6.fromPoints(e), v = {};
            for (let w = 0; w <= l.a7; w++) {
              const T = Math.pow(2, w),
                C = Math.floor(a * T),
                z = Math.floor(c * T),
                F = Math.floor(h * T),
                R = Math.floor(f * T);
              v[w] = {
                minTileX: C,
                minTileY: z,
                maxTileX: F,
                maxTileY: R
              }
            }
            return v
          }
        }
        class Sr extends Ht {
          constructor(e, a, c, h) {
            super(e, a, c, h), this.roundZoom = !0, this.type = "video", this.options = a
          }
          load() {
            return l._(this, void 0, void 0, (function*() {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const a of e.urls) this.urls.push(this.map._requestManager.transformRequest(a, "Source").url);
              try {
                const a = yield l.a9(this.urls);
                if (this._loaded = !0, !a) return;
                this.video = a, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint()
                })), this.map && this.video.play(), this._finishLoading()
              } catch (a) {
                this.fire(new l.k(a))
              }
            }))
          }
          pause() {
            this.video && this.video.pause()
          }
          play() {
            this.video && this.video.play()
          }
          seek(e) {
            if (this.video) {
              const a = this.video.seekable;
              e < a.start(0) || e > a.end(0) ? this.fire(new l.k(new l.aa(`sources.${this.id}`, null, `Playback for this video can be set only between the ${a.start(0)} and ${a.end(0)}-second mark.`))) : this.video.currentTime = e
            }
          }
          getVideo() {
            return this.video
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context,
              a = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, a.RGBA, a.UNSIGNED_BYTE, this.video)) : (this.texture = new l.T(e, this.video, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let c = !1;
            for (const h in this.tiles) {
              const f = this.tiles[h];
              f.state !== "loaded" && (f.state = "loaded", f.texture = this.texture, c = !0)
            }
            c && this.fire(new l.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this.video && !this.video.paused
          }
        }
        class Rr extends Ht {
          constructor(e, a, c, h) {
            super(e, a, c, h), a.coordinates ? Array.isArray(a.coordinates) && a.coordinates.length === 4 && !a.coordinates.some((f => !Array.isArray(f) || f.length !== 2 || f.some((v => typeof v != "number")))) || this.fire(new l.k(new l.aa(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new l.k(new l.aa(`sources.${e}`, null, 'missing required property "coordinates"'))), a.animate && typeof a.animate != "boolean" && this.fire(new l.k(new l.aa(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), a.canvas ? typeof a.canvas == "string" || a.canvas instanceof HTMLCanvasElement || this.fire(new l.k(new l.aa(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new l.k(new l.aa(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = a, this.animate = a.animate === void 0 || a.animate
          }
          load() {
            return l._(this, void 0, void 0, (function*() {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new l.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint()
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1)
              }, this._finishLoading())
            }))
          }
          getCanvas() {
            return this.canvas
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play()
          }
          onRemove() {
            this.pause()
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const a = this.map.painter.context,
              c = a.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
              premultiply: !0
            }) : this.texture = new l.T(a, this.canvas, c.RGBA, {
              premultiply: !0
            });
            let h = !1;
            for (const f in this.tiles) {
              const v = this.tiles[f];
              v.state !== "loaded" && (v.state = "loaded", v.texture = this.texture, h = !0)
            }
            h && this.fire(new l.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "canvas",
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this._playing
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height])
              if (isNaN(e) || e <= 0) return !0;
            return !1
          }
        }
        const Vt = {},
          Tr = p => {
            switch (p) {
              case "geojson":
                return pr;
              case "image":
                return Ht;
              case "raster":
                return st;
              case "raster-dem":
                return lr;
              case "vector":
                return Lt;
              case "video":
                return Sr;
              case "canvas":
                return Rr
            }
            return Vt[p]
          },
          Xt = "RTLPluginLoaded";
        class ue extends l.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Ot()
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", {
              pluginStatus: e,
              pluginURL: this.url
            }).catch((a => {
              throw this.status = "error", a
            }))
          }
          getRTLTextPluginStatus() {
            return this.status
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null
          }
          setRTLTextPlugin(e) {
            return l._(this, arguments, void 0, (function*(a, c = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = ce.resolveURL(a), !this.url) throw new Error(`requested url ${a} is invalid`);
              if (this.status === "unavailable") {
                if (!c) return this._requestImport();
                this.status = "deferred", this._syncState(this.status)
              } else if (this.status === "requested") return this._requestImport()
            }))
          }
          _requestImport() {
            return l._(this, void 0, void 0, (function*() {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new l.l(Xt))
            }))
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
          }
        }
        let N = null;

        function q() {
          return N || (N = new ue), N
        }
        var X, te;
        (function(p) {
          p[p.Base = 0] = "Base", p[p.Parent = 1] = "Parent"
        })(X || (X = {})), (function(p) {
          p[p.Departing = 0] = "Departing", p[p.Incoming = 1] = "Incoming"
        })(te || (te = {}));
        class le {
          constructor(e, a) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e, this.uid = l.ab(), this.uses = 0, this.tileSize = a, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading"
          }
          isRenderable(e) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e || !this.holdingForSymbolFade())
          }
          setCrossFadeLogic({
            fadingRole: e,
            fadingDirection: a,
            fadingParentID: c,
            fadeEndTime: h
          }) {
            this.resetFadeLogic(), this.fadingRole = e, this.fadingDirection = a, this.fadingParentID = c, this.fadeEndTime = h
          }
          setSelfFadeLogic(e) {
            this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = e
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = fe(), this.fadeEndTime = 0, this.fadeOpacity = 1
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null
          }
          loadVectorData(e, a, c) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(h, f) {
                const v = {};
                if (!f) return v;
                for (const w of h) {
                  const T = w.layerIds.map((C => f.getLayer(C))).filter(Boolean);
                  if (T.length !== 0) {
                    w.layers = T, w.stateDependentLayerIds && (w.stateDependentLayers = w.stateDependentLayerIds.map((C => T.filter((z => z.id === C))[0])));
                    for (const C of T) v[C.id] = w
                  }
                }
                return v
              })(e.buckets, a == null ? void 0 : a.style), this.hasSymbolBuckets = !1;
              for (const h in this.buckets) {
                const f = this.buckets[h];
                if (f instanceof l.ad) {
                  if (this.hasSymbolBuckets = !0, !c) break;
                  f.justReloaded = !0
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets)
                for (const h in this.buckets) {
                  const f = this.buckets[h];
                  if (f instanceof l.ad && f.hasRTLText) {
                    this.hasRTLText = !0, q().lazyLoad();
                    break
                  }
                }
              this.queryPadding = 0;
              for (const h in this.buckets) {
                const f = this.buckets[h];
                this.queryPadding = Math.max(this.queryPadding, a.style.getLayer(h).queryRadius(f))
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), this.dashPositions = e.dashPositions
            } else this.collisionBoxArray = new l.ac
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded"
          }
          getBucket(e) {
            return this.buckets[e.id]
          }
          upload(e) {
            for (const c in this.buckets) {
              const h = this.buckets[c];
              h.uploadPending() && h.upload(e)
            }
            const a = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new l.T(e, this.imageAtlas.image, a.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new l.T(e, this.glyphAtlasImage, a.ALPHA), this.glyphAtlasImage = null)
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
          }
          queryRenderedFeatures(e, a, c, h, f, v, w, T, C, z, F) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
              queryGeometry: h,
              cameraQueryGeometry: f,
              scale: v,
              tileSize: this.tileSize,
              pixelPosMatrix: z,
              transform: T,
              params: w,
              queryPadding: this.queryPadding * C,
              getElevation: F
            }, e, a, c) : {}
          }
          querySourceFeatures(e, a) {
            const c = this.latestFeatureIndex;
            if (!c || !c.rawTileData) return;
            const h = c.loadVTLayers(),
              f = a && a.sourceLayer ? a.sourceLayer : "",
              v = h._geojsonTileLayer || h[f];
            if (!v) return;
            const w = l.ae(a == null ? void 0 : a.filter, a == null ? void 0 : a.globalState),
              {
                z: T,
                x: C,
                y: z
              } = this.tileID.canonical,
              F = {
                z: T,
                x: C,
                y: z
              };
            for (let R = 0; R < v.length; R++) {
              const U = v.feature(R);
              if (w.needGeometry) {
                const ie = l.af(U, !0);
                if (!w.filter(new l.G(this.tileID.overscaledZ), ie, this.tileID.canonical)) continue
              } else if (!w.filter(new l.G(this.tileID.overscaledZ), U)) continue;
              const Y = c.getId(U, f),
                ne = new l.ag(U, T, C, z, Y);
              ne.tile = F, e.push(ne)
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
          }
          setExpiryData(e) {
            const a = this.expirationTime;
            if (e.cacheControl) {
              const c = l.ah(e.cacheControl);
              c["max-age"] && (this.expirationTime = Date.now() + 1e3 * c["max-age"])
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const c = Date.now();
              let h = !1;
              if (this.expirationTime > c) h = !1;
              else if (a)
                if (this.expirationTime < a) h = !0;
                else {
                  const f = this.expirationTime - a;
                  f ? this.expirationTime = c + Math.max(f, 3e4) : h = !0
                }
              else h = !0;
              h ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
          }
          setFeatureState(e, a) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const c = this.latestFeatureIndex.loadVTLayers();
            for (const h in this.buckets) {
              if (!a.style.hasLayer(h)) continue;
              const f = this.buckets[h],
                v = f.layers[0].sourceLayer || "_geojsonTileLayer",
                w = c[v],
                T = e[v];
              if (!w || !T || Object.keys(T).length === 0) continue;
              f.update(T, w, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const C = a && a.style && a.style.getLayer(h);
              C && (this.queryPadding = Math.max(this.queryPadding, C.queryRadius(f)))
            }
          }
          holdingForSymbolFade() {
            return this.symbolFadeHoldUntil !== void 0
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < fe()
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0
          }
          setSymbolHoldDuration(e) {
            this.symbolFadeHoldUntil = fe() + e
          }
          setDependencies(e, a) {
            const c = {};
            for (const h of a) c[h] = !0;
            this.dependencies[e] = c
          }
          hasDependency(e, a) {
            for (const c of e) {
              const h = this.dependencies[c];
              if (h) {
                for (const f of a)
                  if (h[f]) return !0
              }
            }
            return !1
          }
        }
        class xe {
          constructor(e, a) {
            this.max = e, this.onRemove = a, this.reset()
          }
          reset() {
            for (const e in this.data)
              for (const a of this.data[e]) a.timeout && clearTimeout(a.timeout), this.onRemove(a.value);
            return this.data = {}, this.order = [], this
          }
          add(e, a, c) {
            const h = e.wrapped().key;
            this.data[h] === void 0 && (this.data[h] = []);
            const f = {
              value: a,
              timeout: void 0
            };
            if (c !== void 0 && (f.timeout = setTimeout((() => {
                this.remove(e, f)
              }), c)), this.data[h].push(f), this.order.push(h), this.order.length > this.max) {
              const v = this._getAndRemoveByKey(this.order[0]);
              v && this.onRemove(v)
            }
            return this
          }
          has(e) {
            return e.wrapped().key in this.data
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
          }
          _getAndRemoveByKey(e) {
            const a = this.data[e].shift();
            return a.timeout && clearTimeout(a.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), a.value
          }
          getByKey(e) {
            const a = this.data[e];
            return a ? a[0].value : null
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null
          }
          remove(e, a) {
            if (!this.has(e)) return this;
            const c = e.wrapped().key,
              h = a === void 0 ? 0 : this.data[c].indexOf(a),
              f = this.data[c][h];
            return this.data[c].splice(h, 1), f.timeout && clearTimeout(f.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(f.value), this.order.splice(this.order.indexOf(c), 1), this
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max;) {
              const a = this._getAndRemoveByKey(this.order[0]);
              a && this.onRemove(a)
            }
            return this
          }
          filter(e) {
            const a = [];
            for (const c in this.data)
              for (const h of this.data[c]) e(h.value) || a.push(h);
            for (const c of a) this.remove(c.value.tileID, c)
          }
        }
        class je {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {}
          }
          updateState(e, a, c) {
            const h = String(a);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][h] = this.stateChanges[e][h] || {}, l.e(this.stateChanges[e][h], c), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const f in this.state[e]) f !== h && (this.deletedStates[e][f] = null)
            } else if (this.deletedStates[e] && this.deletedStates[e][h] === null) {
              this.deletedStates[e][h] = {};
              for (const f in this.state[e][h]) c[f] || (this.deletedStates[e][h][f] = null)
            } else
              for (const f in c) this.deletedStates[e] && this.deletedStates[e][h] && this.deletedStates[e][h][f] === null && delete this.deletedStates[e][h][f]
          }
          removeFeatureState(e, a, c) {
            if (this.deletedStates[e] === null) return;
            const h = String(a);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, c && a !== void 0) this.deletedStates[e][h] !== null && (this.deletedStates[e][h] = this.deletedStates[e][h] || {}, this.deletedStates[e][h][c] = null);
            else if (a !== void 0)
              if (this.stateChanges[e] && this.stateChanges[e][h])
                for (c in this.deletedStates[e][h] = {}, this.stateChanges[e][h]) this.deletedStates[e][h][c] = null;
              else this.deletedStates[e][h] = null;
            else this.deletedStates[e] = null
          }
          getState(e, a) {
            const c = String(a),
              h = l.e({}, (this.state[e] || {})[c], (this.stateChanges[e] || {})[c]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const f = this.deletedStates[e][a];
              if (f === null) return {};
              for (const v in f) delete h[v]
            }
            return h
          }
          initializeTileState(e, a) {
            e.setFeatureState(this.state, a)
          }
          coalesceChanges(e, a) {
            const c = {};
            for (const h in this.stateChanges) {
              this.state[h] = this.state[h] || {};
              const f = {};
              for (const v in this.stateChanges[h]) this.state[h][v] || (this.state[h][v] = {}), l.e(this.state[h][v], this.stateChanges[h][v]), f[v] = this.state[h][v];
              c[h] = f
            }
            for (const h in this.deletedStates) {
              this.state[h] = this.state[h] || {};
              const f = {};
              if (this.deletedStates[h] === null)
                for (const v in this.state[h]) f[v] = {}, this.state[h][v] = {};
              else
                for (const v in this.deletedStates[h]) {
                  if (this.deletedStates[h][v] === null) this.state[h][v] = {};
                  else
                    for (const w of Object.keys(this.deletedStates[h][v])) delete this.state[h][v][w];
                  f[v] = this.state[h][v]
                }
              c[h] = c[h] || {}, l.e(c[h], f)
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(c).length !== 0)
              for (const h in e) e[h].setFeatureState(c, a)
          }
        }
        const Ie = 89.25;

        function qe(p, e) {
          const a = l.ai(e.lat, -l.aj, l.aj);
          return new l.P(l.X(e.lng) * p, l.W(a) * p)
        }

        function rt(p, e) {
          return new l.a5(e.x / p, e.y / p).toLngLat()
        }

        function Xe(p) {
          return p.cameraToCenterDistance * Math.min(.85 * Math.tan(l.ak(90 - p.pitch)), Math.tan(l.ak(Ie - p.pitch)))
        }

        function he(p, e) {
          const a = p.canonical,
            c = e / l.al(a.z),
            h = a.x + Math.pow(2, a.z) * p.wrap,
            f = l.am(new Float64Array(16));
          return l.N(f, f, [h * c, a.y * c, 0]), l.O(f, f, [c / l.a3, c / l.a3, 1]), f
        }

        function Q(p, e, a, c, h) {
          const f = l.a5.fromLngLat(p, e),
            v = h * l.an(1, p.lat),
            w = v * Math.cos(l.ak(a)),
            T = Math.sqrt(v * v - w * w),
            C = T * Math.sin(l.ak(-c)),
            z = T * Math.cos(l.ak(-c));
          return new l.a5(f.x + C, f.y + z, f.z + w)
        }

        function Ze(p, e, a) {
          const c = e.intersectsFrustum(p);
          if (!a || c === 0) return c;
          const h = e.intersectsPlane(a);
          return h === 0 ? 0 : c === 2 && h === 2 ? 2 : 1
        }

        function vt(p, e, a) {
          let c = 0;
          const h = (a - e) / 10;
          for (let f = 0; f < 10; f++) c += h * Math.pow(Math.cos(e + (f + .5) / 10 * (a - e)), p);
          return c
        }

        function Qe(p, e) {
          return function(a, c, h, f, v) {
            const w = 2 * ((p - 1) / l.ao(Math.cos(l.ak(Ie - v)) / Math.cos(l.ak(Ie))) - 1),
              T = Math.acos(h / f),
              C = 2 * vt(w - 1, 0, l.ak(v / 2)),
              z = Math.min(l.ak(Ie), T + l.ak(v / 2)),
              F = vt(w - 1, Math.min(z, T - l.ak(v / 2)), z),
              R = Math.atan(c / h),
              U = Math.hypot(c, h);
            let Y = a;
            return Y += l.ao(f / U / Math.max(.5, Math.cos(l.ak(v / 2)))), Y += w * l.ao(Math.cos(R)) / 2, Y -= l.ao(Math.max(1, F / C / e)) / 2, Y
          }
        }
        const oe = Qe(9.314, 3);

        function De(p, e) {
          const a = (e.roundZoom ? Math.round : Math.floor)(p.zoom + l.ao(p.tileSize / e.tileSize));
          return Math.max(0, a)
        }

        function Je(p, e) {
          const a = p.getCameraFrustum(),
            c = p.getClippingPlane(),
            h = p.screenPointToMercatorCoordinate(p.getCameraPoint()),
            f = l.a5.fromLngLat(p.center, p.elevation);
          h.z = f.z + Math.cos(p.pitchInRadians) * p.cameraToCenterDistance / p.worldSize;
          const v = p.getCoveringTilesDetailsProvider(),
            w = v.allowVariableZoom(p, e),
            T = De(p, e),
            C = e.minzoom || 0,
            z = e.maxzoom !== void 0 ? e.maxzoom : p.maxZoom,
            F = Math.min(Math.max(0, T), z),
            R = Math.pow(2, F),
            U = [R * h.x, R * h.y, 0],
            Y = [R * f.x, R * f.y, 0],
            ne = Math.hypot(f.x - h.x, f.y - h.y),
            ie = Math.abs(f.z - h.z),
            ae = Math.hypot(ne, ie),
            me = Te => ({
              zoom: 0,
              x: 0,
              y: 0,
              wrap: Te,
              fullyVisible: !1
            }),
            ke = [],
            _e = [];
          if (p.renderWorldCopies && v.allowWorldCopies())
            for (let Te = 1; Te <= 3; Te++) ke.push(me(-Te)), ke.push(me(Te));
          for (ke.push(me(0)); ke.length > 0;) {
            const Te = ke.pop(),
              Ee = Te.x,
              ye = Te.y;
            let Be = Te.fullyVisible;
            const ht = {
                x: Ee,
                y: ye,
                z: Te.zoom
              },
              at = v.getTileBoundingVolume(ht, Te.wrap, p.elevation, e);
            if (!Be) {
              const hr = Ze(a, at, c);
              if (hr === 0) continue;
              Be = hr === 2
            }
            const lt = v.distanceToTile2d(h.x, h.y, ht, at);
            let pt = T;
            w && (pt = (e.calculateTileZoom || oe)(p.zoom + l.ao(p.tileSize / e.tileSize), lt, ie, ae, p.fov)), pt = (e.roundZoom ? Math.round : Math.floor)(pt), pt = Math.max(0, pt);
            const ur = Math.min(pt, z);
            if (Te.wrap = v.getWrap(f, ht, Te.wrap), Te.zoom >= ur) {
              if (Te.zoom < C) continue;
              const hr = F - Te.zoom,
                Nt = U[0] - .5 - (Ee << hr),
                Ur = U[1] - .5 - (ye << hr),
                Tn = e.reparseOverscaled ? Math.max(Te.zoom, pt) : Te.zoom;
              _e.push({
                tileID: new l.a0(Te.zoom === z ? Tn : Te.zoom, Te.wrap, Te.zoom, Ee, ye),
                distanceSq: l.ap([Y[0] - .5 - Ee, Y[1] - .5 - ye]),
                tileDistanceToCamera: Math.sqrt(Nt * Nt + Ur * Ur)
              })
            } else
              for (let hr = 0; hr < 4; hr++) ke.push({
                zoom: Te.zoom + 1,
                x: (Ee << 1) + hr % 2,
                y: (ye << 1) + (hr >> 1),
                wrap: Te.wrap,
                fullyVisible: Be
              })
          }
          return _e.sort(((Te, Ee) => Te.distanceSq - Ee.distanceSq)).map((Te => Te.tileID))
        }
        const Tt = l.a6.fromPoints([new l.P(0, 0), new l.P(l.a3, l.a3)]);
        class Dt extends l.E {
          constructor(e, a, c) {
            super(), this.id = e, this.dispatcher = c, this.on("data", (h => this._dataHandler(h))), this.on("dataloading", (() => {
              this._sourceErrored = !1
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded()
            })), this._source = ((h, f, v, w) => {
              const T = new(Tr(f.type))(h, f, v, w);
              if (T.id !== h) throw new Error(`Expected Source id to be ${h} instead of ${T.id}`);
              return T
            })(e, a, c, this), this._tiles = {}, this._cache = new xe(0, (h => this._unloadTile(h))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new je, this._didEmitContent = !1, this._updated = !1
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e)
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e)
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const a = this._tiles[e];
              if (a.state !== "loaded" && a.state !== "errored") return !1
            }
            return !0
          }
          getSource() {
            return this._source
          }
          getState() {
            return this._state
          }
          pause() {
            this._paused = !0
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain)
          }
          _loadTile(e, a, c) {
            return l._(this, void 0, void 0, (function*() {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, a, c)
              } catch (h) {
                e.state = "errored", h.status !== 404 ? this._source.fire(new l.k(h, {
                  tile: e
                })) : this.update(this.transform, this.terrain)
              }
            }))
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e)
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new l.l("dataabort", {
              tile: e,
              coord: e.tileID,
              dataType: "source"
            }))
          }
          serialize() {
            return this._source.serialize()
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const a in this._tiles) {
              const c = this._tiles[a];
              c.upload(e), c.prepare(this.map.style.imageManager)
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e => e.tileID)).sort(_t).map((e => e.key))
          }
          getRenderableIds(e) {
            const a = [];
            for (const c in this._tiles) this._isIdRenderable(c, e) && a.push(this._tiles[c]);
            return e ? a.sort(((c, h) => {
              const f = c.tileID,
                v = h.tileID,
                w = new l.P(f.canonical.x, f.canonical.y)._rotate(-this.transform.bearingInRadians),
                T = new l.P(v.canonical.x, v.canonical.y)._rotate(-this.transform.bearingInRadians);
              return f.overscaledZ - v.overscaledZ || T.y - w.y || T.x - w.x
            })).map((c => c.tileID.key)) : a.map((c => c.tileID)).sort(_t).map((c => c.key))
          }
          hasRenderableParent(e) {
            const a = e.overscaledZ - 1;
            if (a >= this._source.minzoom) {
              const c = this.getLoadedTile(e.scaledTo(a));
              if (c) return this._isIdRenderable(c.tileID.key)
            }
            return !1
          }
          _isIdRenderable(e, a = !1) {
            var c;
            return (c = this._tiles[e]) === null || c === void 0 ? void 0 : c.isRenderable(a)
          }
          reload(e, a = void 0) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const c in this._tiles) a && this._source.shouldReloadTile && !this._source.shouldReloadTile(this._tiles[c], a) || (e ? this._reloadTile(c, "expired") : this._tiles[c].state !== "errored" && this._reloadTile(c, "reloading"))
            }
          }
          _reloadTile(e, a) {
            return l._(this, void 0, void 0, (function*() {
              const c = this._tiles[e];
              c && (c.state !== "loading" && (c.state = a), yield this._loadTile(c, e, a))
            }))
          }
          _tileLoaded(e, a, c) {
            e.timeAdded = fe(), e.selfFading && (e.fadeEndTime = e.timeAdded + this._rasterFadeDuration), c === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(a, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new l.l("data", {
              dataType: "source",
              tile: e,
              coord: e.tileID
            }))
          }
          _backfillDEM(e) {
            const a = this.getRenderableIds();
            for (let h = 0; h < a.length; h++) {
              const f = a[h];
              if (e.neighboringTiles && e.neighboringTiles[f]) {
                const v = this.getTileByID(f);
                c(e, v), c(v, e)
              }
            }

            function c(h, f) {
              h.needsHillshadePrepare = !0, h.needsTerrainPrepare = !0;
              let v = f.tileID.canonical.x - h.tileID.canonical.x;
              const w = f.tileID.canonical.y - h.tileID.canonical.y,
                T = Math.pow(2, h.tileID.canonical.z),
                C = f.tileID.key;
              v === 0 && w === 0 || Math.abs(w) > 1 || (Math.abs(v) > 1 && (Math.abs(v + T) === 1 ? v += T : Math.abs(v - T) === 1 && (v -= T)), f.dem && h.dem && (h.dem.backfillBorder(f.dem, v, w), h.neighboringTiles && h.neighboringTiles[C] && (h.neighboringTiles[C].backfilled = !0)))
            }
          }
          getTile(e) {
            return this.getTileByID(e.key)
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          _retainLoadedChildren(e, a) {
            const c = Object.values(e),
              h = this._getLoadedDescendents(c),
              f = {};
            for (const v of c) {
              const w = h[v.key];
              if (!(w != null && w.length)) {
                f[v.key] = v;
                continue
              }
              const T = v.overscaledZ + Dt.maxUnderzooming,
                C = w.filter((R => R.tileID.overscaledZ <= T));
              if (!C.length) {
                f[v.key] = v;
                continue
              }
              const z = Math.min(...C.map((R => R.tileID.overscaledZ))),
                F = C.filter((R => R.tileID.overscaledZ === z)).map((R => R.tileID));
              for (const R of F) a[R.key] = R;
              this._areDescendentsComplete(F, z, v.overscaledZ) || (f[v.key] = v)
            }
            return f
          }
          _getLoadedDescendents(e) {
            var a;
            const c = {};
            for (const h in this._tiles) {
              const f = this._tiles[h];
              if (f.hasData())
                for (const v of e) f.tileID.isChildOf(v) && (c[a = v.key] || (c[a] = [])).push(f)
            }
            return c
          }
          _areDescendentsComplete(e, a, c) {
            return e.length === 1 && e[0].isOverscaled() ? e[0].overscaledZ === a : Math.pow(4, a - c) === e.length
          }
          getLoadedTile(e) {
            const a = this._tiles[e.key];
            return a != null && a.hasData() ? a : null
          }
          updateCacheSize(e) {
            const a = Math.ceil(e.width / this._source.tileSize) + 1,
              c = Math.ceil(e.height / this._source.tileSize) + 1,
              h = Math.floor(a * c * (this._maxTileCacheZoomLevels === null ? l.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)),
              f = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, h) : h;
            this._cache.setMaxSize(f)
          }
          handleWrapJump(e) {
            const a = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, a) {
              const c = {};
              for (const h in this._tiles) {
                const f = this._tiles[h];
                f.tileID = f.tileID.unwrapTo(f.tileID.wrap + a), c[f.tileID.key] = f
              }
              this._tiles = c, this._resetTileReloadTimers()
            }
          }
          update(e, a) {
            if (!this._sourceLoaded || this._paused) return;
            let c;
            this.transform = e, this.terrain = a, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? c = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((T => new l.a0(T.canonical.z, T.wrap, T.canonical.z, T.canonical.x, T.canonical.y))) : (c = Je(e, {
              tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
              minzoom: this._source.minzoom,
              maxzoom: this._source.maxzoom,
              roundZoom: !this.usedForTerrain && this._source.roundZoom,
              reparseOverscaled: this._source.reparseOverscaled,
              terrain: a,
              calculateTileZoom: this._source.calculateTileZoom
            }), this._source.hasTile && (c = c.filter((T => this._source.hasTile(T))))) : c = [], this.usedForTerrain && (c = this._addTerrainIdealTiles(c));
            const h = c.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, h && this.fire(new l.l("data", {
              sourceDataType: "idle",
              dataType: "source",
              sourceId: this.id
            }));
            const f = De(e, this._source),
              v = this._updateRetainedTiles(c, f),
              w = zt(this._source.type);
            w && this._rasterFadeDuration > 0 && !a && this._updateFadingTiles(c, v), w ? this._cleanUpRasterTiles(v) : this._cleanUpVectorTiles(v)
          }
          _cleanUpRasterTiles(e) {
            for (const a in this._tiles) e[a] || this._removeTile(a)
          }
          _cleanUpVectorTiles(e) {
            for (const a in this._tiles) {
              const c = this._tiles[a];
              e[a] ? c.clearSymbolFadeHold() : c.hasSymbolBuckets ? c.holdingForSymbolFade() ? c.symbolFadeFinished() && this._removeTile(a) : c.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(a)
            }
          }
          _addTerrainIdealTiles(e) {
            const a = [];
            for (const c of e)
              if (c.canonical.z > this._source.minzoom) {
                const h = c.scaledTo(c.canonical.z - 1);
                a.push(h);
                const f = c.scaledTo(Math.max(this._source.minzoom, Math.min(c.canonical.z, 5)));
                a.push(f)
              } return e.concat(a)
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForSymbolFade() && this._removeTile(e)
          }
          _updateRetainedTiles(e, a) {
            var c;
            const h = {},
              f = {},
              v = Math.max(a - Dt.maxOverzooming, this._source.minzoom);
            let w = {};
            for (const T of e) {
              const C = this._addTile(T);
              h[T.key] = T, C.hasData() || (w[T.key] = T)
            }
            w = this._retainLoadedChildren(w, h);
            for (const T in w) {
              const C = w[T];
              let z = this._tiles[T],
                F = z == null ? void 0 : z.wasRequested();
              for (let R = C.overscaledZ - 1; R >= v; --R) {
                const U = C.scaledTo(R);
                if (f[U.key]) break;
                if (f[U.key] = !0, z = this.getTile(U), !z && F && (z = this._addTile(U)), z) {
                  const Y = z.hasData();
                  if ((Y || !(!((c = this.map) === null || c === void 0) && c.cancelPendingTileRequestsWhileZooming) || F) && (h[U.key] = U), F = z.wasRequested(), Y) break
                }
              }
            }
            return h
          }
          _updateFadingTiles(e, a) {
            const c = fe(),
              h = l.aq(e);
            for (const f of e) {
              const v = this._tiles[f.key];
              v.fadingDirection !== te.Departing && v.fadeOpacity !== 0 || v.resetFadeLogic(), this._updateFadingAncestor(v, a, c) || this._updateFadingDescendents(v, a, c) || this._updateFadingEdge(v, h, c) || v.resetFadeLogic()
            }
          }
          _updateFadingAncestor(e, a, c) {
            if (!e.hasData()) return !1;
            const {
              tileID: h,
              fadingRole: f,
              fadingDirection: v,
              fadingParentID: w
            } = e;
            if (f === X.Base && v === te.Incoming && w) return a[w.key] = w, !0;
            const T = Math.max(h.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
            for (let C = h.overscaledZ - 1; C >= T; C--) {
              const z = h.scaledTo(C),
                F = this.getLoadedTile(z);
              if (F) return e.setCrossFadeLogic({
                fadingRole: X.Base,
                fadingDirection: te.Incoming,
                fadingParentID: F.tileID,
                fadeEndTime: c + this._rasterFadeDuration
              }), F.setCrossFadeLogic({
                fadingRole: X.Parent,
                fadingDirection: te.Departing,
                fadeEndTime: c + this._rasterFadeDuration
              }), a[z.key] = z, !0
            }
            return !1
          }
          _updateFadingDescendents(e, a, c) {
            if (!e.hasData()) return !1;
            const h = e.tileID.children(this._source.maxzoom);
            let f = this._updateFadingChildren(e, h, a, c);
            if (f) return !0;
            for (const v of h) {
              const w = v.children(this._source.maxzoom);
              this._updateFadingChildren(e, w, a, c) && (f = !0)
            }
            return f
          }
          _updateFadingChildren(e, a, c, h) {
            if (a[0].overscaledZ >= this._source.maxzoom) return !1;
            let f = !1;
            for (const v of a) {
              const w = this.getLoadedTile(v);
              if (!w) continue;
              const {
                fadingRole: T,
                fadingDirection: C,
                fadingParentID: z
              } = w;
              T === X.Base && C === te.Departing && z || (w.setCrossFadeLogic({
                fadingRole: X.Base,
                fadingDirection: te.Departing,
                fadingParentID: e.tileID,
                fadeEndTime: h + this._rasterFadeDuration
              }), e.setCrossFadeLogic({
                fadingRole: X.Parent,
                fadingDirection: te.Incoming,
                fadeEndTime: h + this._rasterFadeDuration
              })), c[v.key] = v, f = !0
            }
            return f
          }
          _updateFadingEdge(e, a, c) {
            const h = e.tileID;
            return !!e.selfFading || !e.hasData() && !!a.has(h) && (e.setSelfFadeLogic(c + this._rasterFadeDuration), !0)
          }
          _addTile(e) {
            let a = this._tiles[e.key];
            if (a) return a;
            a = this._cache.getAndRemove(e), a && (a.resetFadeLogic(), this._setTileReloadTimer(e.key, a), a.tileID = e, this._state.initializeTileState(a, this.map ? this.map.painter : null));
            const c = a;
            return a || (a = new le(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(a, e.key, a.state)), a.uses++, this._tiles[e.key] = a, c || this._source.fire(new l.l("dataloading", {
              tile: a,
              coord: a.tileID,
              dataType: "source"
            })), a
          }
          _setTileReloadTimer(e, a) {
            this._clearTileReloadTimer(e);
            const c = a.getExpiryTimeout();
            c && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e]
            }), c))
          }
          _clearTileReloadTimer(e) {
            const a = this._timers[e];
            a && (clearTimeout(a), delete this._timers[e])
          }
          _resetTileReloadTimers() {
            for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];
            for (const e in this._tiles) this._setTileReloadTimer(e, this._tiles[e])
          }
          refreshTiles(e) {
            for (const a in this._tiles)(this._isIdRenderable(a) || this._tiles[a].state == "errored") && e.some((c => c.equals(this._tiles[a].tileID.canonical))) && this._reloadTile(a, "expired")
          }
          _removeTile(e) {
            const a = this._tiles[e];
            a && (a.uses--, delete this._tiles[e], this._clearTileReloadTimer(e), a.uses > 0 || (a.hasData() && a.state !== "reloading" ? this._cache.add(a.tileID, a, a.getExpiryTimeout()) : (a.aborted = !0, this._abortTile(a), this._unloadTile(a))))
          }
          _dataHandler(e) {
            e.dataType === "source" && (e.sourceDataType !== "metadata" ? e.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(e.sourceDataChanged, e.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0)
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset()
          }
          tilesIn(e, a, c) {
            const h = [],
              f = this.transform;
            if (!f) return h;
            const v = f.getCoveringTilesDetailsProvider().allowWorldCopies(),
              w = c ? f.getCameraQueryGeometry(e) : e,
              T = U => f.screenPointToMercatorCoordinate(U, this.terrain),
              C = this.transformBbox(e, T, !v),
              z = this.transformBbox(w, T, !v),
              F = this.getIds(),
              R = l.a6.fromPoints(z);
            for (let U = 0; U < F.length; U++) {
              const Y = this._tiles[F[U]];
              if (Y.holdingForSymbolFade()) continue;
              const ne = v ? [Y.tileID] : [Y.tileID.unwrapTo(-1), Y.tileID.unwrapTo(0)],
                ie = Math.pow(2, f.zoom - Y.tileID.overscaledZ),
                ae = a * Y.queryPadding * l.a3 / Y.tileSize / ie;
              for (const me of ne) {
                const ke = R.map((_e => me.getTilePoint(new l.a5(_e.x, _e.y))));
                if (ke.expandBy(ae), ke.intersects(Tt)) {
                  const _e = C.map((Ee => me.getTilePoint(Ee))),
                    Te = z.map((Ee => me.getTilePoint(Ee)));
                  h.push({
                    tile: Y,
                    tileID: v ? me : me.unwrapTo(0),
                    queryGeometry: _e,
                    cameraQueryGeometry: Te,
                    scale: ie
                  })
                }
              }
            }
            return h
          }
          transformBbox(e, a, c) {
            let h = e.map(a);
            if (c) {
              const f = l.a6.fromPoints(e);
              f.shrinkBy(.001 * Math.min(f.width(), f.height()));
              const v = f.map(a);
              l.a6.fromPoints(h).covers(v) || (h = h.map((w => w.x > .5 ? new l.a5(w.x - 1, w.y, w.z) : w)))
            }
            return h
          }
          getVisibleCoordinates(e) {
            const a = this.getRenderableIds(e).map((c => this._tiles[c].tileID));
            return this.transform && this.transform.populateCache(a), a
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (zt(this._source.type) && this._rasterFadeDuration > 0) {
              const e = fe();
              for (const a in this._tiles)
                if (this._tiles[a].fadeEndTime >= e) return !0
            }
            return !1
          }
          setRasterFadeDuration(e) {
            this._rasterFadeDuration = e
          }
          setFeatureState(e, a, c) {
            this._state.updateState(e = e || "_geojsonTileLayer", a, c)
          }
          removeFeatureState(e, a, c) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", a, c)
          }
          getFeatureState(e, a) {
            return this._state.getState(e = e || "_geojsonTileLayer", a)
          }
          setDependencies(e, a, c) {
            const h = this._tiles[e];
            h && h.setDependencies(a, c)
          }
          reloadTilesForDependencies(e, a) {
            for (const c in this._tiles) this._tiles[c].hasDependency(e, a) && this._reloadTile(c, "reloading");
            this._cache.filter((c => !c.hasDependency(e, a)))
          }
        }

        function _t(p, e) {
          const a = Math.abs(2 * p.wrap) - +(p.wrap < 0),
            c = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return p.overscaledZ - e.overscaledZ || c - a || e.canonical.y - p.canonical.y || e.canonical.x - p.canonical.x
        }

        function zt(p) {
          return p === "raster" || p === "image" || p === "video"
        }
        Dt.maxOverzooming = 10, Dt.maxUnderzooming = 3;
        class Yt {
          constructor(e, a) {
            this.reset(e, a)
          }
          reset(e, a) {
            this.points = e || [], this._distances = [0];
            for (let c = 1; c < this.points.length; c++) this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(a || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = l.ai(e, 0, 1);
            let a = 1,
              c = this._distances[a];
            const h = e * this.paddedLength + this.padding;
            for (; c < h && a < this._distances.length;) c = this._distances[++a];
            const f = a - 1,
              v = this._distances[f],
              w = c - v,
              T = w > 0 ? (h - v) / w : 0;
            return this.points[f].mult(1 - T).add(this.points[a].mult(T))
          }
        }

        function $e(p, e) {
          let a = !0;
          return p === "always" || p !== "never" && e !== "never" || (a = !1), a
        }
        class Ct {
          constructor(e, a, c) {
            const h = this.boxCells = [],
              f = this.circleCells = [];
            this.xCellCount = Math.ceil(e / c), this.yCellCount = Math.ceil(a / c);
            for (let v = 0; v < this.xCellCount * this.yCellCount; v++) h.push([]), f.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = a, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / a, this.boxUid = 0, this.circleUid = 0
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length
          }
          insert(e, a, c, h, f) {
            this._forEachCell(a, c, h, f, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(a), this.bboxes.push(c), this.bboxes.push(h), this.bboxes.push(f)
          }
          insertCircle(e, a, c, h) {
            this._forEachCell(a - h, c - h, a + h, c + h, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(a), this.circles.push(c), this.circles.push(h)
          }
          _insertBoxCell(e, a, c, h, f, v) {
            this.boxCells[f].push(v)
          }
          _insertCircleCell(e, a, c, h, f, v) {
            this.circleCells[f].push(v)
          }
          _query(e, a, c, h, f, v, w) {
            if (c < 0 || e > this.width || h < 0 || a > this.height) return [];
            const T = [];
            if (e <= 0 && a <= 0 && this.width <= c && this.height <= h) {
              if (f) return [{
                key: null,
                x1: e,
                y1: a,
                x2: c,
                y2: h
              }];
              for (let C = 0; C < this.boxKeys.length; C++) T.push({
                key: this.boxKeys[C],
                x1: this.bboxes[4 * C],
                y1: this.bboxes[4 * C + 1],
                x2: this.bboxes[4 * C + 2],
                y2: this.bboxes[4 * C + 3]
              });
              for (let C = 0; C < this.circleKeys.length; C++) {
                const z = this.circles[3 * C],
                  F = this.circles[3 * C + 1],
                  R = this.circles[3 * C + 2];
                T.push({
                  key: this.circleKeys[C],
                  x1: z - R,
                  y1: F - R,
                  x2: z + R,
                  y2: F + R
                })
              }
            } else this._forEachCell(e, a, c, h, this._queryCell, T, {
              hitTest: f,
              overlapMode: v,
              seenUids: {
                box: {},
                circle: {}
              }
            }, w);
            return T
          }
          query(e, a, c, h) {
            return this._query(e, a, c, h, !1, null)
          }
          hitTest(e, a, c, h, f, v) {
            return this._query(e, a, c, h, !0, f, v).length > 0
          }
          hitTestCircle(e, a, c, h, f) {
            const v = e - c,
              w = e + c,
              T = a - c,
              C = a + c;
            if (w < 0 || v > this.width || C < 0 || T > this.height) return !1;
            const z = [];
            return this._forEachCell(v, T, w, C, this._queryCellCircle, z, {
              hitTest: !0,
              overlapMode: h,
              circle: {
                x: e,
                y: a,
                radius: c
              },
              seenUids: {
                box: {},
                circle: {}
              }
            }, f), z.length > 0
          }
          _queryCell(e, a, c, h, f, v, w, T) {
            const {
              seenUids: C,
              hitTest: z,
              overlapMode: F
            } = w, R = this.boxCells[f];
            if (R !== null) {
              const Y = this.bboxes;
              for (const ne of R)
                if (!C.box[ne]) {
                  C.box[ne] = !0;
                  const ie = 4 * ne,
                    ae = this.boxKeys[ne];
                  if (e <= Y[ie + 2] && a <= Y[ie + 3] && c >= Y[ie + 0] && h >= Y[ie + 1] && (!T || T(ae)) && (!z || !$e(F, ae.overlapMode)) && (v.push({
                      key: ae,
                      x1: Y[ie],
                      y1: Y[ie + 1],
                      x2: Y[ie + 2],
                      y2: Y[ie + 3]
                    }), z)) return !0
                }
            }
            const U = this.circleCells[f];
            if (U !== null) {
              const Y = this.circles;
              for (const ne of U)
                if (!C.circle[ne]) {
                  C.circle[ne] = !0;
                  const ie = 3 * ne,
                    ae = this.circleKeys[ne];
                  if (this._circleAndRectCollide(Y[ie], Y[ie + 1], Y[ie + 2], e, a, c, h) && (!T || T(ae)) && (!z || !$e(F, ae.overlapMode))) {
                    const me = Y[ie],
                      ke = Y[ie + 1],
                      _e = Y[ie + 2];
                    if (v.push({
                        key: ae,
                        x1: me - _e,
                        y1: ke - _e,
                        x2: me + _e,
                        y2: ke + _e
                      }), z) return !0
                  }
                }
            }
            return !1
          }
          _queryCellCircle(e, a, c, h, f, v, w, T) {
            const {
              circle: C,
              seenUids: z,
              overlapMode: F
            } = w, R = this.boxCells[f];
            if (R !== null) {
              const Y = this.bboxes;
              for (const ne of R)
                if (!z.box[ne]) {
                  z.box[ne] = !0;
                  const ie = 4 * ne,
                    ae = this.boxKeys[ne];
                  if (this._circleAndRectCollide(C.x, C.y, C.radius, Y[ie + 0], Y[ie + 1], Y[ie + 2], Y[ie + 3]) && (!T || T(ae)) && !$e(F, ae.overlapMode)) return v.push(!0), !0
                }
            }
            const U = this.circleCells[f];
            if (U !== null) {
              const Y = this.circles;
              for (const ne of U)
                if (!z.circle[ne]) {
                  z.circle[ne] = !0;
                  const ie = 3 * ne,
                    ae = this.circleKeys[ne];
                  if (this._circlesCollide(Y[ie], Y[ie + 1], Y[ie + 2], C.x, C.y, C.radius) && (!T || T(ae)) && !$e(F, ae.overlapMode)) return v.push(!0), !0
                }
            }
          }
          _forEachCell(e, a, c, h, f, v, w, T) {
            const C = this._convertToXCellCoord(e),
              z = this._convertToYCellCoord(a),
              F = this._convertToXCellCoord(c),
              R = this._convertToYCellCoord(h);
            for (let U = C; U <= F; U++)
              for (let Y = z; Y <= R; Y++)
                if (f.call(this, e, a, c, h, this.xCellCount * Y + U, v, w, T)) return
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
          }
          _circlesCollide(e, a, c, h, f, v) {
            const w = h - e,
              T = f - a,
              C = c + v;
            return C * C > w * w + T * T
          }
          _circleAndRectCollide(e, a, c, h, f, v, w) {
            const T = (v - h) / 2,
              C = Math.abs(e - (h + T));
            if (C > T + c) return !1;
            const z = (w - f) / 2,
              F = Math.abs(a - (f + z));
            if (F > z + c) return !1;
            if (C <= T || F <= z) return !0;
            const R = C - T,
              U = F - z;
            return R * R + U * U <= c * c
          }
        }

        function ir(p, e, a) {
          const c = l.M();
          if (!p) {
            const {
              vecSouth: F,
              vecEast: R
            } = br(e), U = W();
            U[0] = R[0], U[1] = R[1], U[2] = F[0], U[3] = F[1], h = U, (z = (v = (f = U)[0]) * (C = f[3]) - (T = f[2]) * (w = f[1])) && (h[0] = C * (z = 1 / z), h[1] = -w * z, h[2] = -T * z, h[3] = v * z), c[0] = U[0], c[1] = U[1], c[4] = U[2], c[5] = U[3]
          }
          var h, f, v, w, T, C, z;
          return l.O(c, c, [1 / a, 1 / a, 1]), c
        }

        function Fr(p, e, a, c) {
          if (p) {
            const h = l.M();
            if (!e) {
              const {
                vecSouth: f,
                vecEast: v
              } = br(a);
              h[0] = v[0], h[1] = v[1], h[4] = f[0], h[5] = f[1]
            }
            return l.O(h, h, [c, c, 1]), h
          }
          return a.pixelsToClipSpaceMatrix
        }

        function br(p) {
          const e = Math.cos(p.rollInRadians),
            a = Math.sin(p.rollInRadians),
            c = Math.cos(p.pitchInRadians),
            h = Math.cos(p.bearingInRadians),
            f = Math.sin(p.bearingInRadians),
            v = l.av();
          v[0] = -h * c * a - f * e, v[1] = -f * c * a + h * e;
          const w = l.aw(v);
          w < 1e-9 ? l.ax(v) : l.ay(v, v, 1 / w);
          const T = l.av();
          T[0] = h * c * e - f * a, T[1] = f * c * e + h * a;
          const C = l.aw(T);
          return C < 1e-9 ? l.ax(T) : l.ay(T, T, 1 / C), {
            vecEast: T,
            vecSouth: v
          }
        }

        function nt(p, e, a, c) {
          let h;
          c ? (h = [p, e, c(p, e), 1], l.aA(h, h, a)) : (h = [p, e, 0, 1], Kr(h, h, a));
          const f = h[3];
          return {
            point: new l.P(h[0] / f, h[1] / f),
            signedDistanceFromCamera: f,
            isOccluded: !1
          }
        }

        function cr(p, e) {
          return .5 + p / e * .5
        }

        function ar(p, e) {
          return p.x >= -e[0] && p.x <= e[0] && p.y >= -e[1] && p.y <= e[1]
        }

        function Ar(p, e, a, c, h, f, v, w, T, C, z, F, R) {
          const U = a ? p.textSizeData : p.iconSizeData,
            Y = l.ar(U, e.transform.zoom),
            ne = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1],
            ie = a ? p.text.dynamicLayoutVertexArray : p.icon.dynamicLayoutVertexArray;
          ie.clear();
          const ae = p.lineVertexArray,
            me = a ? p.text.placedSymbolArray : p.icon.placedSymbolArray,
            ke = e.transform.width / e.transform.height;
          let _e = !1;
          for (let Te = 0; Te < me.length; Te++) {
            const Ee = me.get(Te);
            if (Ee.hidden || Ee.writingMode === l.as.vertical && !_e) {
              tn(Ee.numGlyphs, ie);
              continue
            }
            _e = !1;
            const ye = new l.P(Ee.anchorX, Ee.anchorY),
              Be = {
                getElevation: R,
                pitchedLabelPlaneMatrix: c,
                lineVertexArray: ae,
                pitchWithMap: f,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: e.transform,
                tileAnchorPoint: ye,
                unwrappedTileID: T,
                width: C,
                height: z,
                translation: F
              },
              ht = qt(Ee.anchorX, Ee.anchorY, Be);
            if (!ar(ht.point, ne)) {
              tn(Ee.numGlyphs, ie);
              continue
            }
            const at = cr(e.transform.cameraToCenterDistance, ht.signedDistanceFromCamera),
              lt = l.at(U, Y, Ee),
              pt = f ? lt * e.transform.getPitchedTextCorrection(Ee.anchorX, Ee.anchorY, T) / at : lt * at,
              ur = Mr({
                projectionContext: Be,
                pitchedLabelPlaneMatrixInverse: h,
                symbol: Ee,
                fontSize: pt,
                flip: !1,
                keepUpright: v,
                glyphOffsetArray: p.glyphOffsetArray,
                dynamicLayoutVertexArray: ie,
                aspectRatio: ke,
                rotateToLine: w
              });
            _e = ur.useVertical, (ur.notEnoughRoom || _e || ur.needsFlipping && Mr({
              projectionContext: Be,
              pitchedLabelPlaneMatrixInverse: h,
              symbol: Ee,
              fontSize: pt,
              flip: !0,
              keepUpright: v,
              glyphOffsetArray: p.glyphOffsetArray,
              dynamicLayoutVertexArray: ie,
              aspectRatio: ke,
              rotateToLine: w
            }).notEnoughRoom) && tn(Ee.numGlyphs, ie)
          }
          a ? p.text.dynamicLayoutVertexBuffer.updateData(ie) : p.icon.dynamicLayoutVertexBuffer.updateData(ie)
        }

        function qr(p, e, a, c, h, f, v, w) {
          const T = f.glyphStartIndex + f.numGlyphs,
            C = f.lineStartIndex,
            z = f.lineStartIndex + f.lineLength,
            F = e.getoffsetX(f.glyphStartIndex),
            R = e.getoffsetX(T - 1),
            U = Wt(p * F, a, c, h, f.segment, C, z, w, v);
          if (!U) return null;
          const Y = Wt(p * R, a, c, h, f.segment, C, z, w, v);
          return Y ? w.projectionCache.anyProjectionOccluded ? null : {
            first: U,
            last: Y
          } : null
        }

        function Gr(p, e, a, c) {
          return p === l.as.horizontal && Math.abs(a.y - e.y) > Math.abs(a.x - e.x) * c ? {
            useVertical: !0
          } : (p === l.as.vertical ? e.y < a.y : e.x > a.x) ? {
            needsFlipping: !0
          } : null
        }

        function Mr(p) {
          const {
            projectionContext: e,
            pitchedLabelPlaneMatrixInverse: a,
            symbol: c,
            fontSize: h,
            flip: f,
            keepUpright: v,
            glyphOffsetArray: w,
            dynamicLayoutVertexArray: T,
            aspectRatio: C,
            rotateToLine: z
          } = p, F = h / 24, R = c.lineOffsetX * F, U = c.lineOffsetY * F;
          let Y;
          if (c.numGlyphs > 1) {
            const ne = c.glyphStartIndex + c.numGlyphs,
              ie = c.lineStartIndex,
              ae = c.lineStartIndex + c.lineLength,
              me = qr(F, w, R, U, f, c, z, e);
            if (!me) return {
              notEnoughRoom: !0
            };
            const ke = tt(me.first.point.x, me.first.point.y, e, a),
              _e = tt(me.last.point.x, me.last.point.y, e, a);
            if (v && !f) {
              const Te = Gr(c.writingMode, ke, _e, C);
              if (Te) return Te
            }
            Y = [me.first];
            for (let Te = c.glyphStartIndex + 1; Te < ne - 1; Te++) {
              const Ee = Wt(F * w.getoffsetX(Te), R, U, f, c.segment, ie, ae, e, z);
              if (!Ee) return {
                notEnoughRoom: !0
              };
              Y.push(Ee)
            }
            Y.push(me.last)
          } else {
            if (v && !f) {
              const ie = Le(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point,
                ae = c.lineStartIndex + c.segment + 1,
                me = new l.P(e.lineVertexArray.getx(ae), e.lineVertexArray.gety(ae)),
                ke = Le(me.x, me.y, e),
                _e = ke.signedDistanceFromCamera > 0 ? ke.point : Sn(e.tileAnchorPoint, me, ie, 1, e),
                Te = tt(ie.x, ie.y, e, a),
                Ee = tt(_e.x, _e.y, e, a),
                ye = Gr(c.writingMode, Te, Ee, C);
              if (ye) return ye
            }
            const ne = Wt(F * w.getoffsetX(c.glyphStartIndex), R, U, f, c.segment, c.lineStartIndex, c.lineStartIndex + c.lineLength, e, z);
            if (!ne || e.projectionCache.anyProjectionOccluded) return {
              notEnoughRoom: !0
            };
            Y = [ne]
          }
          for (const ne of Y) l.az(T, ne.point, ne.angle);
          return {}
        }

        function Sn(p, e, a, c, h) {
          const f = p.add(p.sub(e)._unit()),
            v = Le(f.x, f.y, h).point,
            w = a.sub(v);
          return a.add(w._mult(c / w.mag()))
        }

        function Vr(p, e, a) {
          const c = e.projectionCache;
          if (c.projections[p]) return c.projections[p];
          const h = new l.P(e.lineVertexArray.getx(p), e.lineVertexArray.gety(p)),
            f = Le(h.x, h.y, e);
          if (f.signedDistanceFromCamera > 0) return c.projections[p] = f.point, c.anyProjectionOccluded = c.anyProjectionOccluded || f.isOccluded, f.point;
          const v = p - a.direction;
          return Sn(a.distanceFromAnchor === 0 ? e.tileAnchorPoint : new l.P(e.lineVertexArray.getx(v), e.lineVertexArray.gety(v)), h, a.previousVertex, a.absOffsetX - a.distanceFromAnchor + 1, e)
        }

        function Le(p, e, a) {
          const c = p + a.translation[0],
            h = e + a.translation[1];
          let f;
          return a.pitchWithMap ? (f = nt(c, h, a.pitchedLabelPlaneMatrix, a.getElevation), f.isOccluded = !1) : (f = a.transform.projectTileCoordinates(c, h, a.unwrappedTileID, a.getElevation), f.point.x = (.5 * f.point.x + .5) * a.width, f.point.y = (.5 * -f.point.y + .5) * a.height), f
        }

        function tt(p, e, a, c) {
          if (a.pitchWithMap) {
            const h = [p, e, 0, 1];
            return l.aA(h, h, c), a.transform.projectTileCoordinates(h[0] / h[3], h[1] / h[3], a.unwrappedTileID, a.getElevation).point
          }
          return {
            x: p / a.width * 2 - 1,
            y: 1 - e / a.height * 2
          }
        }

        function qt(p, e, a) {
          return a.transform.projectTileCoordinates(p, e, a.unwrappedTileID, a.getElevation)
        }

        function Ut(p, e, a) {
          return p._unit()._perp()._mult(e * a)
        }

        function fr(p, e, a, c, h, f, v, w, T) {
          if (w.projectionCache.offsets[p]) return w.projectionCache.offsets[p];
          const C = a.add(e);
          if (p + T.direction < c || p + T.direction >= h) return w.projectionCache.offsets[p] = C, C;
          const z = Vr(p + T.direction, w, T),
            F = Ut(z.sub(a), v, T.direction),
            R = a.add(F),
            U = z.add(F);
          return w.projectionCache.offsets[p] = l.aB(f, C, R, U) || C, w.projectionCache.offsets[p]
        }

        function Wt(p, e, a, c, h, f, v, w, T) {
          const C = c ? p - e : p + e;
          let z = C > 0 ? 1 : -1,
            F = 0;
          c && (z *= -1, F = Math.PI), z < 0 && (F += Math.PI);
          let R, U = z > 0 ? f + h : f + h + 1;
          w.projectionCache.cachedAnchorPoint ? R = w.projectionCache.cachedAnchorPoint : (R = Le(w.tileAnchorPoint.x, w.tileAnchorPoint.y, w).point, w.projectionCache.cachedAnchorPoint = R);
          let Y, ne, ie = R,
            ae = R,
            me = 0,
            ke = 0;
          const _e = Math.abs(C),
            Te = [];
          let Ee;
          for (; me + ke <= _e;) {
            if (U += z, U < f || U >= v) return null;
            me += ke, ae = ie, ne = Y;
            const ht = {
              absOffsetX: _e,
              direction: z,
              distanceFromAnchor: me,
              previousVertex: ae
            };
            if (ie = Vr(U, w, ht), a === 0) Te.push(ae), Ee = ie.sub(ae);
            else {
              let at;
              const lt = ie.sub(ae);
              at = lt.mag() === 0 ? Ut(Vr(U + z, w, ht).sub(ie), a, z) : Ut(lt, a, z), ne || (ne = ae.add(at)), Y = fr(U, at, ie, f, v, ne, a, w, ht), Te.push(ne), Ee = Y.sub(ne)
            }
            ke = Ee.mag()
          }
          const ye = Ee._mult((_e - me) / ke)._add(ne || ae),
            Be = F + Math.atan2(ie.y - ae.y, ie.x - ae.x);
          return Te.push(ye), {
            point: ye,
            angle: T ? Be : 0,
            path: Te
          }
        }
        const yr = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

        function tn(p, e) {
          for (let a = 0; a < p; a++) {
            const c = e.length;
            e.resize(c + 4), e.float32.set(yr, 3 * c)
          }
        }

        function Kr(p, e, a) {
          const c = e[0],
            h = e[1];
          return p[0] = a[0] * c + a[4] * h + a[12], p[1] = a[1] * c + a[5] * h + a[13], p[3] = a[3] * c + a[7] * h + a[15], p
        }
        const Br = 100;
        class Cr {
          constructor(e, a = new Ct(e.width + 200, e.height + 200, 25), c = new Ct(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = a, this.ignoredGrid = c, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Br, this.screenBottomBoundary = e.height + Br, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6
          }
          placeCollisionBox(e, a, c, h, f, v, w, T, C, z, F, R) {
            const U = this.projectAndGetPerspectiveRatio(e.anchorPointX + T[0], e.anchorPointY + T[1], f, z, R),
              Y = c * U.perspectiveRatio;
            let ne;
            if (v || w) ne = this._projectCollisionBox(e, Y, h, f, v, w, T, U, z, F, R);
            else {
              const Ee = U.x + (F ? F.x * Y : 0),
                ye = U.y + (F ? F.y * Y : 0);
              ne = {
                allPointsOccluded: !1,
                box: [Ee + e.x1 * Y, ye + e.y1 * Y, Ee + e.x2 * Y, ye + e.y2 * Y]
              }
            }
            const [ie, ae, me, ke] = ne.box, _e = v ? ne.allPointsOccluded : U.isOccluded;
            let Te = _e;
            return Te || (Te = U.perspectiveRatio < this.perspectiveRatioCutoff), Te || (Te = !this.isInsideGrid(ie, ae, me, ke)), Te || a !== "always" && this.grid.hitTest(ie, ae, me, ke, a, C) ? {
              box: [ie, ae, me, ke],
              placeable: !1,
              offscreen: !1,
              occluded: _e
            } : {
              box: [ie, ae, me, ke],
              placeable: !0,
              offscreen: this.isOffscreen(ie, ae, me, ke),
              occluded: _e
            }
          }
          placeCollisionCircles(e, a, c, h, f, v, w, T, C, z, F, R, U, Y) {
            const ne = [],
              ie = new l.P(a.anchorX, a.anchorY),
              ae = this.getPerspectiveRatio(ie.x, ie.y, v, Y),
              me = (C ? f * this.transform.getPitchedTextCorrection(a.anchorX, a.anchorY, v) / ae : f * ae) / l.aF,
              ke = {
                getElevation: Y,
                pitchedLabelPlaneMatrix: w,
                lineVertexArray: c,
                pitchWithMap: C,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: this.transform,
                tileAnchorPoint: ie,
                unwrappedTileID: v,
                width: this.transform.width,
                height: this.transform.height,
                translation: U
              },
              _e = qr(me, h, a.lineOffsetX * me, a.lineOffsetY * me, !1, a, !1, ke);
            let Te = !1,
              Ee = !1,
              ye = !0;
            if (_e) {
              const Be = .5 * F * ae + R,
                ht = new l.P(-100, -100),
                at = new l.P(this.screenRightBoundary, this.screenBottomBoundary),
                lt = new Yt,
                pt = _e.first,
                ur = _e.last;
              let hr = [];
              for (let Tn = pt.path.length - 1; Tn >= 1; Tn--) hr.push(pt.path[Tn]);
              for (let Tn = 1; Tn < ur.path.length; Tn++) hr.push(ur.path[Tn]);
              const Nt = 2.5 * Be;
              if (C) {
                const Tn = this.projectPathToScreenSpace(hr, ke);
                hr = Tn.some((Hn => Hn.signedDistanceFromCamera <= 0)) ? [] : Tn.map((Hn => Hn.point))
              }
              let Ur = [];
              if (hr.length > 0) {
                const Tn = hr[0].clone(),
                  Hn = hr[0].clone();
                for (let zn = 1; zn < hr.length; zn++) Tn.x = Math.min(Tn.x, hr[zn].x), Tn.y = Math.min(Tn.y, hr[zn].y), Hn.x = Math.max(Hn.x, hr[zn].x), Hn.y = Math.max(Hn.y, hr[zn].y);
                Ur = Tn.x >= ht.x && Hn.x <= at.x && Tn.y >= ht.y && Hn.y <= at.y ? [hr] : Hn.x < ht.x || Tn.x > at.x || Hn.y < ht.y || Tn.y > at.y ? [] : l.aC([hr], ht.x, ht.y, at.x, at.y)
              }
              for (const Tn of Ur) {
                lt.reset(Tn, .25 * Be);
                let Hn = 0;
                Hn = lt.length <= .5 * Be ? 1 : Math.ceil(lt.paddedLength / Nt) + 1;
                for (let zn = 0; zn < Hn; zn++) {
                  const ei = zn / Math.max(Hn - 1, 1),
                    _i = lt.lerp(ei),
                    ni = _i.x + Br,
                    Ai = _i.y + Br;
                  ne.push(ni, Ai, Be, 0);
                  const hi = ni - Be,
                    Oi = Ai - Be,
                    di = ni + Be,
                    Mi = Ai + Be;
                  if (ye = ye && this.isOffscreen(hi, Oi, di, Mi), Ee = Ee || this.isInsideGrid(hi, Oi, di, Mi), e !== "always" && this.grid.hitTestCircle(ni, Ai, Be, e, z) && (Te = !0, !T)) return {
                    circles: [],
                    offscreen: !1,
                    collisionDetected: Te
                  }
                }
              }
            }
            return {
              circles: !T && Te || !Ee || ae < this.perspectiveRatioCutoff ? [] : ne,
              offscreen: ye,
              collisionDetected: Te
            }
          }
          projectPathToScreenSpace(e, a) {
            const c = (function(h, f) {
              const v = l.M();
              return l.au(v, f.pitchedLabelPlaneMatrix), h.map((w => {
                const T = nt(w.x, w.y, v, f.getElevation),
                  C = f.transform.projectTileCoordinates(T.point.x, T.point.y, f.unwrappedTileID, f.getElevation);
                return C.point.x = (.5 * C.point.x + .5) * f.width, C.point.y = (.5 * -C.point.y + .5) * f.height, C
              }))
            })(e, a);
            return (function(h) {
              let f = 0,
                v = 0,
                w = 0,
                T = 0;
              for (let C = 0; C < h.length; C++) h[C].isOccluded ? (w = C + 1, T = 0) : (T++, T > v && (v = T, f = w));
              return h.slice(f, f + v)
            })(c)
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const a = [],
              c = new l.a6;
            for (const F of e) {
              const R = new l.P(F.x + Br, F.y + Br);
              c.extend(R), a.push(R)
            }
            const {
              minX: h,
              minY: f,
              maxX: v,
              maxY: w
            } = c, T = this.grid.query(h, f, v, w).concat(this.ignoredGrid.query(h, f, v, w)), C = {}, z = {};
            for (const F of T) {
              const R = F.key;
              if (C[R.bucketInstanceId] === void 0 && (C[R.bucketInstanceId] = {}), C[R.bucketInstanceId][R.featureIndex]) continue;
              const U = [new l.P(F.x1, F.y1), new l.P(F.x2, F.y1), new l.P(F.x2, F.y2), new l.P(F.x1, F.y2)];
              l.aD(a, U) && (C[R.bucketInstanceId][R.featureIndex] = !0, z[R.bucketInstanceId] === void 0 && (z[R.bucketInstanceId] = []), z[R.bucketInstanceId].push(R.featureIndex))
            }
            return z
          }
          insertCollisionBox(e, a, c, h, f, v) {
            (c ? this.ignoredGrid : this.grid).insert({
              bucketInstanceId: h,
              featureIndex: f,
              collisionGroupID: v,
              overlapMode: a
            }, e[0], e[1], e[2], e[3])
          }
          insertCollisionCircles(e, a, c, h, f, v) {
            const w = c ? this.ignoredGrid : this.grid,
              T = {
                bucketInstanceId: h,
                featureIndex: f,
                collisionGroupID: v,
                overlapMode: a
              };
            for (let C = 0; C < e.length; C += 4) w.insertCircle(T, e[C], e[C + 1], e[C + 2])
          }
          projectAndGetPerspectiveRatio(e, a, c, h, f) {
            if (f) {
              let v;
              h ? (v = [e, a, h(e, a), 1], l.aA(v, v, f)) : (v = [e, a, 0, 1], Kr(v, v, f));
              const w = v[3];
              return {
                x: (v[0] / w + 1) / 2 * this.transform.width + Br,
                y: (-v[1] / w + 1) / 2 * this.transform.height + Br,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / w * .5,
                isOccluded: !1,
                signedDistanceFromCamera: w
              }
            } {
              const v = this.transform.projectTileCoordinates(e, a, c, h);
              return {
                x: (v.point.x + 1) / 2 * this.transform.width + Br,
                y: (1 - v.point.y) / 2 * this.transform.height + Br,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / v.signedDistanceFromCamera * .5,
                isOccluded: v.isOccluded,
                signedDistanceFromCamera: v.signedDistanceFromCamera
              }
            }
          }
          getPerspectiveRatio(e, a, c, h) {
            const f = this.transform.projectTileCoordinates(e, a, c, h);
            return .5 + this.transform.cameraToCenterDistance / f.signedDistanceFromCamera * .5
          }
          isOffscreen(e, a, c, h) {
            return c < Br || e >= this.screenRightBoundary || h < Br || a > this.screenBottomBoundary
          }
          isInsideGrid(e, a, c, h) {
            return c >= 0 && e < this.gridRightBoundary && h >= 0 && a < this.gridBottomBoundary
          }
          getViewportMatrix() {
            const e = l.am([]);
            return l.N(e, e, [-100, -100, 0]), e
          }
          _projectCollisionBox(e, a, c, h, f, v, w, T, C, z, F) {
            let R = 1,
              U = 0,
              Y = 0,
              ne = 1;
            const ie = e.anchorPointX + w[0],
              ae = e.anchorPointY + w[1];
            if (v && !f) {
              const hr = this.projectAndGetPerspectiveRatio(ie + 1, ae, h, C, F),
                Nt = hr.x - T.x,
                Ur = Math.atan((hr.y - T.y) / Nt) + (Nt < 0 ? Math.PI : 0),
                Tn = Math.sin(Ur),
                Hn = Math.cos(Ur);
              R = Hn, U = Tn, Y = -Tn, ne = Hn
            } else if (!v && f) {
              const hr = br(this.transform);
              R = hr.vecEast[0], U = hr.vecEast[1], Y = hr.vecSouth[0], ne = hr.vecSouth[1]
            }
            let me = T.x,
              ke = T.y,
              _e = a;
            f && (me = ie, ke = ae, _e = Math.pow(2, -(this.transform.zoom - c.overscaledZ)), _e *= this.transform.getPitchedTextCorrection(ie, ae, h), z || (_e *= l.ai(.5 + T.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), z && (me += R * z.x * _e + Y * z.y * _e, ke += U * z.x * _e + ne * z.y * _e);
            const Te = e.x1 * _e,
              Ee = e.x2 * _e,
              ye = (Te + Ee) / 2,
              Be = e.y1 * _e,
              ht = e.y2 * _e,
              at = (Be + ht) / 2,
              lt = [{
                offsetX: Te,
                offsetY: Be
              }, {
                offsetX: ye,
                offsetY: Be
              }, {
                offsetX: Ee,
                offsetY: Be
              }, {
                offsetX: Ee,
                offsetY: at
              }, {
                offsetX: Ee,
                offsetY: ht
              }, {
                offsetX: ye,
                offsetY: ht
              }, {
                offsetX: Te,
                offsetY: ht
              }, {
                offsetX: Te,
                offsetY: at
              }];
            let pt = [];
            for (const {
                offsetX: hr,
                offsetY: Nt
              }
              of lt) pt.push(new l.P(me + R * hr + Y * Nt, ke + U * hr + ne * Nt));
            let ur = !1;
            if (f) {
              const hr = pt.map((Nt => this.projectAndGetPerspectiveRatio(Nt.x, Nt.y, h, C, F)));
              ur = hr.some((Nt => !Nt.isOccluded)), pt = hr.map((Nt => new l.P(Nt.x, Nt.y)))
            } else ur = !0;
            return {
              box: l.aE(pt),
              allPointsOccluded: !ur
            }
          }
        }
        class Yr {
          constructor(e, a, c, h) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? a : -a))) : h && c ? 1 : 0, this.placed = c
          }
          isHidden() {
            return this.opacity === 0 && !this.placed
          }
        }
        class Ln {
          constructor(e, a, c, h, f) {
            this.text = new Yr(e ? e.text : null, a, c, f), this.icon = new Yr(e ? e.icon : null, a, h, f)
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden()
          }
        }
        class In {
          constructor(e, a, c) {
            this.text = e, this.icon = a, this.skipFade = c
          }
        }
        class Wr {
          constructor(e, a, c, h, f) {
            this.bucketInstanceId = e, this.featureIndex = a, this.sourceLayerIndex = c, this.bucketIndex = h, this.tileID = f
          }
        }
        class jr {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {}
          }
          get(e) {
            if (this.crossSourceCollisions) return {
              ID: 0,
              predicate: null
            };
            if (!this.collisionGroups[e]) {
              const a = ++this.maxGroupID;
              this.collisionGroups[e] = {
                ID: a,
                predicate: c => c.collisionGroupID === a
              }
            }
            return this.collisionGroups[e]
          }
        }

        function wn(p, e, a, c, h) {
          const {
            horizontalAlign: f,
            verticalAlign: v
          } = l.aL(p);
          return new l.P(-(f - .5) * e + c[0] * h, -(v - .5) * a + c[1] * h)
        }
        class En {
          constructor(e, a, c, h, f) {
            this.transform = e.clone(), this.terrain = a, this.collisionIndex = new Cr(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = c, this.retainedQueryData = {}, this.collisionGroups = new jr(h), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = f, f && (f.prevPlacement = void 0), this.placedOrientations = {}
          }
          _getTerrainElevationFunc(e) {
            const a = this.terrain;
            return a ? (c, h) => a.getElevation(e, c, h) : null
          }
          getBucketParts(e, a, c, h) {
            const f = c.getBucket(a),
              v = c.latestFeatureIndex;
            if (!f || !v || a.id !== f.layerIds[0]) return;
            const w = c.collisionBoxArray,
              T = f.layers[0].layout,
              C = f.layers[0].paint,
              z = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ),
              F = c.tileSize / l.a3,
              R = c.tileID.toUnwrapped(),
              U = T.get("text-rotation-alignment") === "map",
              Y = l.aG(c, 1, this.transform.zoom),
              ne = l.aH(this.collisionIndex.transform, c, C.get("text-translate"), C.get("text-translate-anchor")),
              ie = l.aH(this.collisionIndex.transform, c, C.get("icon-translate"), C.get("icon-translate-anchor")),
              ae = ir(U, this.transform, Y);
            this.retainedQueryData[f.bucketInstanceId] = new Wr(f.bucketInstanceId, v, f.sourceLayerIndex, f.index, c.tileID);
            const me = {
              bucket: f,
              layout: T,
              translationText: ne,
              translationIcon: ie,
              unwrappedTileID: R,
              pitchedLabelPlaneMatrix: ae,
              scale: z,
              textPixelRatio: F,
              holdingForFade: c.holdingForSymbolFade(),
              collisionBoxArray: w,
              partiallyEvaluatedTextSize: l.ar(f.textSizeData, this.transform.zoom),
              collisionGroup: this.collisionGroups.get(f.sourceID)
            };
            if (h)
              for (const ke of f.sortKeyRanges) {
                const {
                  sortKey: _e,
                  symbolInstanceStart: Te,
                  symbolInstanceEnd: Ee
                } = ke;
                e.push({
                  sortKey: _e,
                  symbolInstanceStart: Te,
                  symbolInstanceEnd: Ee,
                  parameters: me
                })
              } else e.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: f.symbolInstances.length,
                parameters: me
              })
          }
          attemptAnchorPlacement(e, a, c, h, f, v, w, T, C, z, F, R, U, Y, ne, ie, ae, me, ke, _e) {
            const Te = l.aI[e.textAnchor],
              Ee = [e.textOffset0, e.textOffset1],
              ye = wn(Te, c, h, Ee, f),
              Be = this.collisionIndex.placeCollisionBox(a, R, T, C, z, w, v, ie, F.predicate, ke, ye, _e);
            if ((!me || this.collisionIndex.placeCollisionBox(me, R, T, C, z, w, v, ae, F.predicate, ke, ye, _e).placeable) && Be.placeable) {
              let ht;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[U.crossTileID] && this.prevPlacement.placements[U.crossTileID] && this.prevPlacement.placements[U.crossTileID].text && (ht = this.prevPlacement.variableOffsets[U.crossTileID].anchor), U.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[U.crossTileID] = {
                textOffset: Ee,
                width: c,
                height: h,
                anchor: Te,
                textBoxScale: f,
                prevAnchor: ht
              }, this.markUsedJustification(Y, Te, U, ne), Y.allowVerticalPlacement && (this.markUsedOrientation(Y, ne, U), this.placedOrientations[U.crossTileID] = ne), {
                shift: ye,
                placedGlyphBoxes: Be
              }
            }
          }
          placeLayerBucketPart(e, a, c) {
            const {
              bucket: h,
              layout: f,
              translationText: v,
              translationIcon: w,
              unwrappedTileID: T,
              pitchedLabelPlaneMatrix: C,
              textPixelRatio: z,
              holdingForFade: F,
              collisionBoxArray: R,
              partiallyEvaluatedTextSize: U,
              collisionGroup: Y
            } = e.parameters, ne = f.get("text-optional"), ie = f.get("icon-optional"), ae = l.aJ(f, "text-overlap", "text-allow-overlap"), me = ae === "always", ke = l.aJ(f, "icon-overlap", "icon-allow-overlap"), _e = ke === "always", Te = f.get("text-rotation-alignment") === "map", Ee = f.get("text-pitch-alignment") === "map", ye = f.get("icon-text-fit") !== "none", Be = f.get("symbol-z-order") === "viewport-y", ht = me && (_e || !h.hasIconData() || ie), at = _e && (me || !h.hasTextData() || ne);
            !h.collisionArrays && R && h.deserializeCollisionBoxes(R);
            const lt = this.retainedQueryData[h.bucketInstanceId].tileID,
              pt = this._getTerrainElevationFunc(lt),
              ur = this.transform.getFastPathSimpleProjectionMatrix(lt),
              hr = (Nt, Ur, Tn) => {
                var Hn, zn;
                if (a[Nt.crossTileID]) return;
                if (F) return void(this.placements[Nt.crossTileID] = new In(!1, !1, !1));
                let ei = !1,
                  _i = !1,
                  ni = !0,
                  Ai = null,
                  hi = {
                    box: null,
                    placeable: !1,
                    offscreen: null,
                    occluded: !1
                  },
                  Oi = {
                    placeable: !1
                  },
                  di = null,
                  Mi = null,
                  da = null,
                  ns = 0,
                  yo = 0,
                  io = 0;
                Ur.textFeatureIndex ? ns = Ur.textFeatureIndex : Nt.useRuntimeCollisionCircles && (ns = Nt.featureIndex), Ur.verticalTextFeatureIndex && (yo = Ur.verticalTextFeatureIndex);
                const is = Ur.textBox;
                if (is) {
                  const pa = Ii => {
                      let ki = l.as.horizontal;
                      if (h.allowVerticalPlacement && !Ii && this.prevPlacement) {
                        const qi = this.prevPlacement.placedOrientations[Nt.crossTileID];
                        qi && (this.placedOrientations[Nt.crossTileID] = qi, ki = qi, this.markUsedOrientation(h, ki, Nt))
                      }
                      return ki
                    },
                    xo = (Ii, ki) => {
                      if (h.allowVerticalPlacement && Nt.numVerticalGlyphVertices > 0 && Ur.verticalTextBox) {
                        for (const qi of h.writingModes)
                          if (qi === l.as.vertical ? (hi = ki(), Oi = hi) : hi = Ii(), hi && hi.placeable) break
                      } else hi = Ii()
                    },
                    Lo = Nt.textAnchorOffsetStartIndex,
                    ll = Nt.textAnchorOffsetEndIndex;
                  if (ll === Lo) {
                    const Ii = (ki, qi) => {
                      const oi = this.collisionIndex.placeCollisionBox(ki, ae, z, lt, T, Ee, Te, v, Y.predicate, pt, void 0, ur);
                      return oi && oi.placeable && (this.markUsedOrientation(h, qi, Nt), this.placedOrientations[Nt.crossTileID] = qi), oi
                    };
                    xo((() => Ii(is, l.as.horizontal)), (() => {
                      const ki = Ur.verticalTextBox;
                      return h.allowVerticalPlacement && Nt.numVerticalGlyphVertices > 0 && ki ? Ii(ki, l.as.vertical) : {
                        box: null,
                        offscreen: null
                      }
                    })), pa(hi && hi.placeable)
                  } else {
                    let Ii = l.aI[(zn = (Hn = this.prevPlacement) === null || Hn === void 0 ? void 0 : Hn.variableOffsets[Nt.crossTileID]) === null || zn === void 0 ? void 0 : zn.anchor];
                    const ki = (oi, Ga, Do) => {
                      const Rd = oi.x2 - oi.x1,
                        jd = oi.y2 - oi.y1,
                        Fd = Nt.textBoxScale,
                        os = ye && ke === "never" ? Ga : null;
                      let ss = null,
                        Eu = ae === "never" ? 1 : 2,
                        ac = "never";
                      Ii && Eu++;
                      for (let Lu = 0; Lu < Eu; Lu++) {
                        for (let bo = Lo; bo < ll; bo++) {
                          const Ro = h.textAnchorOffsets.get(bo);
                          if (Ii && Ro.textAnchor !== Ii) continue;
                          const oc = this.attemptAnchorPlacement(Ro, oi, Rd, jd, Fd, Te, Ee, z, lt, T, Y, ac, Nt, h, Do, v, w, os, pt);
                          if (oc && (ss = oc.placedGlyphBoxes, ss && ss.placeable)) return ei = !0, Ai = oc.shift, ss
                        }
                        Ii ? Ii = null : ac = ae
                      }
                      return c && !ss && (ss = {
                        box: this.collisionIndex.placeCollisionBox(is, "always", z, lt, T, Ee, Te, v, Y.predicate, pt, void 0, ur).box,
                        offscreen: !1,
                        placeable: !1,
                        occluded: !1
                      }), ss
                    };
                    xo((() => ki(is, Ur.iconBox, l.as.horizontal)), (() => {
                      const oi = Ur.verticalTextBox;
                      return h.allowVerticalPlacement && (!hi || !hi.placeable) && Nt.numVerticalGlyphVertices > 0 && oi ? ki(oi, Ur.verticalIconBox, l.as.vertical) : {
                        box: null,
                        occluded: !0,
                        offscreen: null
                      }
                    })), hi && (ei = hi.placeable, ni = hi.offscreen);
                    const qi = pa(hi && hi.placeable);
                    if (!ei && this.prevPlacement) {
                      const oi = this.prevPlacement.variableOffsets[Nt.crossTileID];
                      oi && (this.variableOffsets[Nt.crossTileID] = oi, this.markUsedJustification(h, oi.anchor, Nt, qi))
                    }
                  }
                }
                if (di = hi, ei = di && di.placeable, ni = di && di.offscreen, Nt.useRuntimeCollisionCircles && Nt.centerJustifiedTextSymbolIndex >= 0) {
                  const pa = h.text.placedSymbolArray.get(Nt.centerJustifiedTextSymbolIndex),
                    xo = l.at(h.textSizeData, U, pa),
                    Lo = f.get("text-padding");
                  Mi = this.collisionIndex.placeCollisionCircles(ae, pa, h.lineVertexArray, h.glyphOffsetArray, xo, T, C, c, Ee, Y.predicate, Nt.collisionCircleDiameter, Lo, v, pt), Mi.circles.length && Mi.collisionDetected && !c && l.w("Collisions detected, but collision boxes are not shown"), ei = me || Mi.circles.length > 0 && !Mi.collisionDetected, ni = ni && Mi.offscreen
                }
                if (Ur.iconFeatureIndex && (io = Ur.iconFeatureIndex), Ur.iconBox) {
                  const pa = xo => this.collisionIndex.placeCollisionBox(xo, ke, z, lt, T, Ee, Te, w, Y.predicate, pt, ye && Ai ? Ai : void 0, ur);
                  Oi && Oi.placeable && Ur.verticalIconBox ? (da = pa(Ur.verticalIconBox), _i = da.placeable) : (da = pa(Ur.iconBox), _i = da.placeable), ni = ni && da.offscreen
                }
                const Es = ne || Nt.numHorizontalGlyphVertices === 0 && Nt.numVerticalGlyphVertices === 0,
                  as = ie || Nt.numIconVertices === 0;
                Es || as ? as ? Es || (_i = _i && ei) : ei = _i && ei : _i = ei = _i && ei;
                const ba = _i && da.placeable;
                if (ei && di.placeable && this.collisionIndex.insertCollisionBox(di.box, ae, f.get("text-ignore-placement"), h.bucketInstanceId, Oi && Oi.placeable && yo ? yo : ns, Y.ID), ba && this.collisionIndex.insertCollisionBox(da.box, ke, f.get("icon-ignore-placement"), h.bucketInstanceId, io, Y.ID), Mi && ei && this.collisionIndex.insertCollisionCircles(Mi.circles, ae, f.get("text-ignore-placement"), h.bucketInstanceId, ns, Y.ID), c && this.storeCollisionData(h.bucketInstanceId, Tn, Ur, di, da, Mi), Nt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                if (h.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[Nt.crossTileID] = new In((ei || ht) && !(di != null && di.occluded), (_i || at) && !(da != null && da.occluded), ni || h.justReloaded), a[Nt.crossTileID] = !0
              };
            if (Be) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const Nt = h.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Ur = Nt.length - 1; Ur >= 0; --Ur) {
                const Tn = Nt[Ur];
                hr(h.symbolInstances.get(Tn), h.collisionArrays[Tn], Tn)
              }
            } else
              for (let Nt = e.symbolInstanceStart; Nt < e.symbolInstanceEnd; Nt++) hr(h.symbolInstances.get(Nt), h.collisionArrays[Nt], Nt);
            h.justReloaded = !1
          }
          storeCollisionData(e, a, c, h, f, v) {
            if (c.textBox || c.iconBox) {
              let w, T;
              this.collisionBoxArrays.has(e) ? w = this.collisionBoxArrays.get(e) : (w = new Map, this.collisionBoxArrays.set(e, w)), w.has(a) ? T = w.get(a) : (T = {
                text: null,
                icon: null
              }, w.set(a, T)), c.textBox && (T.text = h.box), c.iconBox && (T.icon = f.box)
            }
            if (v) {
              let w = this.collisionCircleArrays[e];
              w === void 0 && (w = this.collisionCircleArrays[e] = []);
              for (let T = 0; T < v.circles.length; T += 4) w.push(v.circles[T + 0] - Br), w.push(v.circles[T + 1] - Br), w.push(v.circles[T + 2]), w.push(v.collisionDetected ? 1 : 0)
            }
          }
          markUsedJustification(e, a, c, h) {
            let f;
            f = h === l.as.vertical ? c.verticalPlacedTextSymbolIndex : {
              left: c.leftJustifiedTextSymbolIndex,
              center: c.centerJustifiedTextSymbolIndex,
              right: c.rightJustifiedTextSymbolIndex
            } [l.aK(a)];
            const v = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex, c.verticalPlacedTextSymbolIndex];
            for (const w of v) w >= 0 && (e.text.placedSymbolArray.get(w).crossTileID = f >= 0 && w !== f ? 0 : c.crossTileID)
          }
          markUsedOrientation(e, a, c) {
            const h = a === l.as.horizontal || a === l.as.horizontalOnly ? a : 0,
              f = a === l.as.vertical ? a : 0,
              v = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex];
            for (const w of v) e.text.placedSymbolArray.get(w).placedOrientation = h;
            c.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(c.verticalPlacedTextSymbolIndex).placedOrientation = f)
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const a = this.prevPlacement;
            let c = !1;
            this.prevZoomAdjustment = a ? a.zoomAdjustment(this.transform.zoom) : 0;
            const h = a ? a.symbolFadeChange(e) : 1,
              f = a ? a.opacities : {},
              v = a ? a.variableOffsets : {},
              w = a ? a.placedOrientations : {};
            for (const T in this.placements) {
              const C = this.placements[T],
                z = f[T];
              z ? (this.opacities[T] = new Ln(z, h, C.text, C.icon), c = c || C.text !== z.text.placed || C.icon !== z.icon.placed) : (this.opacities[T] = new Ln(null, h, C.text, C.icon, C.skipFade), c = c || C.text || C.icon)
            }
            for (const T in f) {
              const C = f[T];
              if (!this.opacities[T]) {
                const z = new Ln(C, h, !1, !1);
                z.isHidden() || (this.opacities[T] = z, c = c || C.text.placed || C.icon.placed)
              }
            }
            for (const T in v) this.variableOffsets[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.variableOffsets[T] = v[T]);
            for (const T in w) this.placedOrientations[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.placedOrientations[T] = w[T]);
            if (a && a.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            c ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = a ? a.lastPlacementChangeTime : e)
          }
          updateLayerOpacities(e, a) {
            const c = {};
            for (const h of a) {
              const f = h.getBucket(e);
              f && h.latestFeatureIndex && e.id === f.layerIds[0] && this.updateBucketOpacities(f, h.tileID, c, h.collisionBoxArray)
            }
          }
          updateBucketOpacities(e, a, c, h) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const f = e.layers[0],
              v = f.layout,
              w = new Ln(null, 0, !1, !1, !0),
              T = v.get("text-allow-overlap"),
              C = v.get("icon-allow-overlap"),
              z = f._unevaluatedLayout.hasValue("text-variable-anchor") || f._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
              F = v.get("text-rotation-alignment") === "map",
              R = v.get("text-pitch-alignment") === "map",
              U = v.get("icon-text-fit") !== "none",
              Y = new Ln(null, 0, T && (C || !e.hasIconData() || v.get("icon-optional")), C && (T || !e.hasTextData() || v.get("text-optional")), !0);
            !e.collisionArrays && h && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(h);
            const ne = (ae, me, ke) => {
                for (let _e = 0; _e < me / 4; _e++) ae.opacityVertexArray.emplaceBack(ke);
                ae.hasVisibleVertices = ae.hasVisibleVertices || ke !== qa
              },
              ie = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let ae = 0; ae < e.symbolInstances.length; ae++) {
              const me = e.symbolInstances.get(ae),
                {
                  numHorizontalGlyphVertices: ke,
                  numVerticalGlyphVertices: _e,
                  crossTileID: Te
                } = me;
              let Ee = this.opacities[Te];
              c[Te] ? Ee = w : Ee || (Ee = Y, this.opacities[Te] = Ee), c[Te] = !0;
              const ye = me.numIconVertices > 0,
                Be = this.placedOrientations[me.crossTileID],
                ht = Be === l.as.vertical,
                at = Be === l.as.horizontal || Be === l.as.horizontalOnly;
              if (ke > 0 || _e > 0) {
                const pt = Oa(Ee.text);
                ne(e.text, ke, ht ? qa : pt), ne(e.text, _e, at ? qa : pt);
                const ur = Ee.text.isHidden();
                [me.rightJustifiedTextSymbolIndex, me.centerJustifiedTextSymbolIndex, me.leftJustifiedTextSymbolIndex].forEach((Ur => {
                  Ur >= 0 && (e.text.placedSymbolArray.get(Ur).hidden = ur || ht ? 1 : 0)
                })), me.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(me.verticalPlacedTextSymbolIndex).hidden = ur || at ? 1 : 0);
                const hr = this.variableOffsets[me.crossTileID];
                hr && this.markUsedJustification(e, hr.anchor, me, Be);
                const Nt = this.placedOrientations[me.crossTileID];
                Nt && (this.markUsedJustification(e, "left", me, Nt), this.markUsedOrientation(e, Nt, me))
              }
              if (ye) {
                const pt = Oa(Ee.icon),
                  ur = !(U && me.verticalPlacedIconSymbolIndex && ht);
                me.placedIconSymbolIndex >= 0 && (ne(e.icon, me.numIconVertices, ur ? pt : qa), e.icon.placedSymbolArray.get(me.placedIconSymbolIndex).hidden = Ee.icon.isHidden()), me.verticalPlacedIconSymbolIndex >= 0 && (ne(e.icon, me.numVerticalIconVertices, ur ? qa : pt), e.icon.placedSymbolArray.get(me.verticalPlacedIconSymbolIndex).hidden = Ee.icon.isHidden())
              }
              const lt = ie && ie.has(ae) ? ie.get(ae) : {
                text: null,
                icon: null
              };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const pt = e.collisionArrays[ae];
                if (pt) {
                  let ur = new l.P(0, 0);
                  if (pt.textBox || pt.verticalTextBox) {
                    let hr = !0;
                    if (z) {
                      const Nt = this.variableOffsets[Te];
                      Nt ? (ur = wn(Nt.anchor, Nt.width, Nt.height, Nt.textOffset, Nt.textBoxScale), F && ur._rotate(R ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : hr = !1
                    }
                    if (pt.textBox || pt.verticalTextBox) {
                      let Nt;
                      pt.textBox && (Nt = ht), pt.verticalTextBox && (Nt = at), Mn(e.textCollisionBox.collisionVertexArray, Ee.text.placed, !hr || Nt, lt.text, ur.x, ur.y)
                    }
                  }
                  if (pt.iconBox || pt.verticalIconBox) {
                    const hr = !!(!at && pt.verticalIconBox);
                    let Nt;
                    pt.iconBox && (Nt = hr), pt.verticalIconBox && (Nt = !hr), Mn(e.iconCollisionBox.collisionVertexArray, Ee.icon.placed, Nt, lt.icon, U ? ur.x : 0, U ? ur.y : 0)
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId])
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5)
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
          }
          stillRecent(e, a) {
            const c = this.zoomAtLastRecencyCheck === a ? 1 - this.zoomAdjustment(a) : 1;
            return this.zoomAtLastRecencyCheck = a, this.commitTime + this.fadeDuration * c > e
          }
          setStale() {
            this.stale = !0
          }
        }

        function Mn(p, e, a, c, h, f) {
          c && c.length !== 0 || (c = [0, 0, 0, 0]);
          const v = c[0] - Br,
            w = c[1] - Br,
            T = c[2] - Br,
            C = c[3] - Br;
          p.emplaceBack(e ? 1 : 0, a ? 1 : 0, h || 0, f || 0, v, w), p.emplaceBack(e ? 1 : 0, a ? 1 : 0, h || 0, f || 0, T, w), p.emplaceBack(e ? 1 : 0, a ? 1 : 0, h || 0, f || 0, T, C), p.emplaceBack(e ? 1 : 0, a ? 1 : 0, h || 0, f || 0, v, C)
        }
        const qn = Math.pow(2, 25),
          Gn = Math.pow(2, 24),
          Jn = Math.pow(2, 17),
          Zn = Math.pow(2, 16),
          ri = Math.pow(2, 9),
          la = Math.pow(2, 8),
          Hi = Math.pow(2, 1);

        function Oa(p) {
          if (p.opacity === 0 && !p.placed) return 0;
          if (p.opacity === 1 && p.placed) return 4294967295;
          const e = p.placed ? 1 : 0,
            a = Math.floor(127 * p.opacity);
          return a * qn + e * Gn + a * Jn + e * Zn + a * ri + e * la + a * Hi + e
        }
        const qa = 0;
        class Aa {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []
          }
          continuePlacement(e, a, c, h, f) {
            const v = this._bucketParts;
            for (; this._currentTileIndex < e.length;)
              if (a.getBucketParts(v, h, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, f()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, v.sort(((w, T) => w.sortKey - T.sortKey))); this._currentPartIndex < v.length;)
              if (a.placeLayerBucketPart(v[this._currentPartIndex], this._seenCrossTileIDs, c), this._currentPartIndex++, f()) return !0;
            return !1
          }
        }
        class za {
          constructor(e, a, c, h, f, v, w, T) {
            this.placement = new En(e, a, v, w, T), this._currentPlacementIndex = c.length - 1, this._forceFullPlacement = h, this._showCollisionBoxes = f, this._done = !1
          }
          isDone() {
            return this._done
          }
          continuePlacement(e, a, c) {
            const h = fe(),
              f = () => !this._forceFullPlacement && fe() - h > 2;
            for (; this._currentPlacementIndex >= 0;) {
              const v = a[e[this._currentPlacementIndex]],
                w = this.placement.collisionIndex.transform.zoom;
              if (v.type === "symbol" && (!v.minzoom || v.minzoom <= w) && (!v.maxzoom || v.maxzoom > w)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Aa(v)), this._inProgressLayer.continuePlacement(c[v.source], this.placement, this._showCollisionBoxes, v, f)) return;
                delete this._inProgressLayer
              }
              this._currentPlacementIndex--
            }
            this._done = !0
          }
          commit(e) {
            return this.placement.commit(e), this.placement
          }
        }
        const Ea = 512 / l.a3 / 2;
        class eo {
          constructor(e, a, c) {
            this.tileID = e, this.bucketInstanceId = c, this._symbolsByKey = {};
            const h = new Map;
            for (let f = 0; f < a.length; f++) {
              const v = a.get(f),
                w = v.key,
                T = h.get(w);
              T ? T.push(v) : h.set(w, [v])
            }
            for (const [f, v] of h) {
              const w = {
                positions: v.map((T => ({
                  x: Math.floor(T.anchorX * Ea),
                  y: Math.floor(T.anchorY * Ea)
                }))),
                crossTileIDs: v.map((T => T.crossTileID))
              };
              if (w.positions.length > 128) {
                const T = new l.aM(w.positions.length, 16, Uint16Array);
                for (const {
                    x: C,
                    y: z
                  }
                  of w.positions) T.add(C, z);
                T.finish(), delete w.positions, w.index = T
              }
              this._symbolsByKey[f] = w
            }
          }
          getScaledCoordinates(e, a) {
            const {
              x: c,
              y: h,
              z: f
            } = this.tileID.canonical, {
              x: v,
              y: w,
              z: T
            } = a.canonical, C = Ea / Math.pow(2, T - f), z = (w * l.a3 + e.anchorY) * C, F = h * l.a3 * Ea;
            return {
              x: Math.floor((v * l.a3 + e.anchorX) * C - c * l.a3 * Ea),
              y: Math.floor(z - F)
            }
          }
          findMatches(e, a, c) {
            const h = this.tileID.canonical.z < a.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - a.canonical.z);
            for (let f = 0; f < e.length; f++) {
              const v = e.get(f);
              if (v.crossTileID) continue;
              const w = this._symbolsByKey[v.key];
              if (!w) continue;
              const T = this.getScaledCoordinates(v, a);
              if (w.index) {
                const C = w.index.range(T.x - h, T.y - h, T.x + h, T.y + h).sort();
                for (const z of C) {
                  const F = w.crossTileIDs[z];
                  if (!c[F]) {
                    c[F] = !0, v.crossTileID = F;
                    break
                  }
                }
              } else if (w.positions)
                for (let C = 0; C < w.positions.length; C++) {
                  const z = w.positions[C],
                    F = w.crossTileIDs[C];
                  if (Math.abs(z.x - T.x) <= h && Math.abs(z.y - T.y) <= h && !c[F]) {
                    c[F] = !0, v.crossTileID = F;
                    break
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({
              crossTileIDs: e
            }) => e))
          }
        }
        class dt {
          constructor() {
            this.maxCrossTileID = 0
          }
          generate() {
            return ++this.maxCrossTileID
          }
        }
        class At {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
          }
          handleWrapJump(e) {
            const a = Math.round((e - this.lng) / 360);
            if (a !== 0)
              for (const c in this.indexes) {
                const h = this.indexes[c],
                  f = {};
                for (const v in h) {
                  const w = h[v];
                  w.tileID = w.tileID.unwrapTo(w.tileID.wrap + a), f[w.tileID.key] = w
                }
                this.indexes[c] = f
              }
            this.lng = e
          }
          addBucket(e, a, c) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === a.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
            }
            for (let f = 0; f < a.symbolInstances.length; f++) a.symbolInstances.get(f).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const h = this.usedCrossTileIDs[e.overscaledZ];
            for (const f in this.indexes) {
              const v = this.indexes[f];
              if (Number(f) > e.overscaledZ)
                for (const w in v) {
                  const T = v[w];
                  T.tileID.isChildOf(e) && T.findMatches(a.symbolInstances, e, h)
                } else {
                  const w = v[e.scaledTo(Number(f)).key];
                  w && w.findMatches(a.symbolInstances, e, h)
                }
            }
            for (let f = 0; f < a.symbolInstances.length; f++) {
              const v = a.symbolInstances.get(f);
              v.crossTileID || (v.crossTileID = c.generate(), h[v.crossTileID] = !0)
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new eo(e, a.symbolInstances, a.bucketInstanceId), !0
          }
          removeBucketCrossTileIDs(e, a) {
            for (const c of a.getCrossTileIDsLists())
              for (const h of c) delete this.usedCrossTileIDs[e][h]
          }
          removeStaleBuckets(e) {
            let a = !1;
            for (const c in this.indexes) {
              const h = this.indexes[c];
              for (const f in h) e[h[f].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, h[f]), delete h[f], a = !0)
            }
            return a
          }
        }
        class Zt {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new dt, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
          }
          addLayer(e, a, c) {
            let h = this.layerIndexes[e.id];
            h === void 0 && (h = this.layerIndexes[e.id] = new At);
            let f = !1;
            const v = {};
            h.handleWrapJump(c);
            for (const w of a) {
              const T = w.getBucket(e);
              T && e.id === T.layerIds[0] && (T.bucketInstanceId || (T.bucketInstanceId = ++this.maxBucketInstanceId), h.addBucket(w.tileID, T, this.crossTileIDs) && (f = !0), v[T.bucketInstanceId] = !0)
            }
            return h.removeStaleBuckets(v) && (f = !0), f
          }
          pruneUnusedLayers(e) {
            const a = {};
            e.forEach((c => {
              a[c] = !0
            }));
            for (const c in this.layerIndexes) a[c] || delete this.layerIndexes[c]
          }
        }
        var gn = "void main() {fragColor=vec4(1.0);}";
        const Nr = {
          prelude: un(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
          projectionMercator: un("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
          projectionGlobe: un("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
          background: un(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          backgroundPattern: un(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
          circle: un(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
          clippingMask: un(gn, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          heatmap: un(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
          heatmapTexture: un(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
          collisionBox: un("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
          collisionCircle: un("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
          colorRelief: un(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          debug: un("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
          depth: un(gn, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
          fill: un(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
          fillOutline: un(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillOutlinePattern: un(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillPattern: un(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
          fillExtrusion: un(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
          fillExtrusionPattern: un(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
          hillshadePrepare: un(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
          hillshade: un(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          line: un(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          lineGradient: un(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          linePattern: un(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
          lineSDF: un(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          lineGradientSDF: un(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          raster: un(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
          symbolIcon: un(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
          symbolSDF: un(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
          symbolTextAndIcon: un(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
          terrain: un("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
          terrainDepth: un("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
          terrainCoords: un("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
          projectionErrorMeasurement: un("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
          atmosphere: un(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
          sky: un("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
        };

        function un(p, e) {
          const a = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            c = e.match(/in ([\w]+) ([\w]+)/g),
            h = p.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            f = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            v = f ? f.concat(h) : h,
            w = {};
          return {
            fragmentSource: p = p.replace(a, ((T, C, z, F, R) => (w[R] = !0, C === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
in ${z} ${F} ${R};
#else
uniform ${z} ${F} u_${R};
#endif
` : `
#ifdef HAS_UNIFORM_u_${R}
    ${z} ${F} ${R} = u_${R};
#endif
`))),
            vertexSource: e = e.replace(a, ((T, C, z, F, R) => {
              const U = F === "float" ? "vec2" : "vec4",
                Y = R.match(/color/) ? "color" : U;
              return w[R] ? C === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
uniform lowp float u_${R}_t;
in ${z} ${U} a_${R};
out ${z} ${F} ${R};
#else
uniform ${z} ${F} u_${R};
#endif
` : Y === "vec4" ? `
#ifndef HAS_UNIFORM_u_${R}
    ${R} = a_${R};
#else
    ${z} ${F} ${R} = u_${R};
#endif
` : `
#ifndef HAS_UNIFORM_u_${R}
    ${R} = unpack_mix_${Y}(a_${R}, u_${R}_t);
#else
    ${z} ${F} ${R} = u_${R};
#endif
` : C === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
uniform lowp float u_${R}_t;
in ${z} ${U} a_${R};
#else
uniform ${z} ${F} u_${R};
#endif
` : Y === "vec4" ? `
#ifndef HAS_UNIFORM_u_${R}
    ${z} ${F} ${R} = a_${R};
#else
    ${z} ${F} ${R} = u_${R};
#endif
` : `
#ifndef HAS_UNIFORM_u_${R}
    ${z} ${F} ${R} = unpack_mix_${Y}(a_${R}, u_${R}_t);
#else
    ${z} ${F} ${R} = u_${R};
#endif
`
            })),
            staticAttributes: c,
            staticUniforms: v
          }
        }
        class Fn {
          constructor(e, a, c) {
            this.vertexBuffer = e, this.indexBuffer = a, this.segments = c
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null
          }
        }
        var Rn = l.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }]);
        const Xn = "#define PROJECTION_MERCATOR",
          zr = "mercator";
        class mr {
          constructor() {
            this._cachedMesh = null
          }
          get name() {
            return "mercator"
          }
          get useSubdivision() {
            return !1
          }
          get shaderVariantName() {
            return zr
          }
          get shaderDefine() {
            return Xn
          }
          get shaderPreludeCode() {
            return Nr.projectionMercator
          }
          get vertexShaderPreludeCode() {
            return Nr.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return l.aO.noSubdivision
          }
          get useGlobeControls() {
            return !1
          }
          get transitionState() {
            return 0
          }
          get latitudeErrorCorrectionRadians() {
            return 0
          }
          destroy() {}
          updateGPUdependent(e) {}
          getMeshFromTileID(e, a, c, h, f) {
            if (this._cachedMesh) return this._cachedMesh;
            const v = new l.aP;
            v.emplaceBack(0, 0), v.emplaceBack(l.a3, 0), v.emplaceBack(0, l.a3), v.emplaceBack(l.a3, l.a3);
            const w = e.createVertexBuffer(v, Rn.members),
              T = l.aQ.simpleSegment(0, 0, 4, 2),
              C = new l.aR;
            C.emplaceBack(1, 0, 2), C.emplaceBack(1, 2, 3);
            const z = e.createIndexBuffer(C);
            return this._cachedMesh = new Fn(w, z, T), this._cachedMesh
          }
          recalculate() {}
          hasTransition() {
            return !1
          }
          setErrorQueryLatitudeDegrees(e) {}
        }
        class nn {
          constructor(e = 0, a = 0, c = 0, h = 0) {
            if (isNaN(e) || e < 0 || isNaN(a) || a < 0 || isNaN(c) || c < 0 || isNaN(h) || h < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = a, this.left = c, this.right = h
          }
          interpolate(e, a, c) {
            return a.top != null && e.top != null && (this.top = l.F.number(e.top, a.top, c)), a.bottom != null && e.bottom != null && (this.bottom = l.F.number(e.bottom, a.bottom, c)), a.left != null && e.left != null && (this.left = l.F.number(e.left, a.left, c)), a.right != null && e.right != null && (this.right = l.F.number(e.right, a.right, c)), this
          }
          getCenter(e, a) {
            const c = l.ai((this.left + e - this.right) / 2, 0, e),
              h = l.ai((this.top + a - this.bottom) / 2, 0, a);
            return new l.P(c, h)
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
          }
          clone() {
            return new nn(this.top, this.bottom, this.left, this.right)
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right
            }
          }
        }

        function sn(p, e) {
          if (!p.renderWorldCopies || p.lngRange) return;
          const a = e.lng - p.center.lng;
          e.lng += a > 180 ? -360 : a < -180 ? 360 : 0
        }

        function Kn(p) {
          return Math.max(0, Math.floor(p))
        }
        class kn {
          constructor(e, a) {
            var c;
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = (a == null ? void 0 : a.renderWorldCopies) === void 0 || !!(a != null && a.renderWorldCopies), this._minZoom = (a == null ? void 0 : a.minZoom) || 0, this._maxZoom = (a == null ? void 0 : a.maxZoom) || 22, this._minPitch = (a == null ? void 0 : a.minPitch) == null ? 0 : a == null ? void 0 : a.minPitch, this._maxPitch = (a == null ? void 0 : a.maxPitch) == null ? 60 : a == null ? void 0 : a.maxPitch, this._constrain = (c = a == null ? void 0 : a.constrain) !== null && c !== void 0 ? c : this._callbacks.constrain, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new l.U(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Kn(this._zoom), this._scale = l.al(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new nn, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0
          }
          apply(e, a, c) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = Kn(this._zoom), this._scale = l.al(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new nn(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !c && e.autoCalculateNearFarZ, a && this.constrainInternal(), this._calcMatrices()
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e
          }
          get tileSize() {
            return this._tileSize
          }
          get tileZoom() {
            return this._tileZoom
          }
          get scale() {
            return this._scale
          }
          get width() {
            return this._width
          }
          get height() {
            return this._height
          }
          get bearingInRadians() {
            return this._bearingInRadians
          }
          get lngRange() {
            return this._lngRange
          }
          get latRange() {
            return this._latRange
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits
          }
          get minZoom() {
            return this._minZoom
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get maxZoom() {
            return this._maxZoom
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get minPitch() {
            return this._minPitch
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)))
          }
          get maxPitch() {
            return this._maxPitch
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)))
          }
          get renderWorldCopies() {
            return this._renderWorldCopies
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e
          }
          get constrain() {
            return this._constrain
          }
          setConstrain(e) {
            e || (e = this._callbacks.constrain), this._constrain = e, this.constrainInternal(), this._calcMatrices()
          }
          get worldSize() {
            return this._tileSize * this._scale
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2))
          }
          get size() {
            return new l.P(this._width, this._height)
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180
          }
          setBearing(e) {
            const a = l.V(e, -180, 180) * Math.PI / 180;
            var c, h, f, v, w, T, C, z, F;
            this._bearingInRadians !== a && (this._unmodified = !1, this._bearingInRadians = a, this._calcMatrices(), this._rotationMatrix = W(), c = this._rotationMatrix, f = -this._bearingInRadians, v = (h = this._rotationMatrix)[0], w = h[1], T = h[2], C = h[3], z = Math.sin(f), F = Math.cos(f), c[0] = v * F + T * z, c[1] = w * F + C * z, c[2] = v * -z + T * F, c[3] = w * -z + C * F)
          }
          get rotationMatrix() {
            return this._rotationMatrix
          }
          get pitchInRadians() {
            return this._pitchInRadians
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180
          }
          setPitch(e) {
            const a = l.ai(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== a && (this._unmodified = !1, this._pitchInRadians = a, this._calcMatrices())
          }
          get rollInRadians() {
            return this._rollInRadians
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180
          }
          setRoll(e) {
            const a = e / 180 * Math.PI;
            this._rollInRadians !== a && (this._unmodified = !1, this._rollInRadians = a, this._calcMatrices())
          }
          get fovInRadians() {
            return this._fovInRadians
          }
          get fov() {
            return l.aS(this._fovInRadians)
          }
          setFov(e) {
            e = l.ai(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = l.ak(e), this._calcMatrices())
          }
          get zoom() {
            return this._zoom
          }
          setZoom(e) {
            const a = this.constrain(this._center, e).zoom;
            this._zoom !== a && (this._unmodified = !1, this._zoom = a, this._tileZoom = Math.max(0, Math.floor(a)), this._scale = l.al(a), this.constrainInternal(), this._calcMatrices())
          }
          get center() {
            return this._center
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this.constrainInternal(), this._calcMatrices())
          }
          get elevation() {
            return this._elevation
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this.constrainInternal(), this._calcMatrices())
          }
          get padding() {
            return this._edgeInsets.toJSON()
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices())
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height)
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter
          }
          get unmodified() {
            return this._unmodified
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance
          }
          get nearZ() {
            return this._nearZ
          }
          get farZ() {
            return this._farZ
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ
          }
          overrideNearFarZ(e, a) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = a, this._calcMatrices()
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices()
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e)
          }
          interpolatePadding(e, a, c) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, a, c), this.constrainInternal(), this._calcMatrices()
          }
          resize(e, a, c = !0) {
            this._width = e, this._height = a, c && this.constrainInternal(), this._calcMatrices()
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new yt([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-l.aj, l.aj])
          }
          getCameraQueryGeometry(e, a) {
            if (a.length === 1) return [a[0], e];
            {
              const {
                minX: c,
                minY: h,
                maxX: f,
                maxY: v
              } = l.a6.fromPoints(a).extend(e);
              return [new l.P(c, h), new l.P(f, h), new l.P(f, v), new l.P(c, v), new l.P(c, h)]
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified,
              {
                center: a,
                zoom: c
              } = this.constrain(this.center, this.zoom);
            this.setCenter(a), this.setZoom(c), this._unmodified = e, this._constraining = !1
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = l.am(new Float64Array(16));
              l.O(e, e, [this._width / 2, -this._height / 2, 1]), l.N(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = l.am(new Float64Array(16)), l.O(e, e, [1, -1, 1]), l.N(e, e, [-1, -1, 0]), l.O(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
            }
            this._callbacks.calcMatrices()
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, h) {
            const f = c !== void 0 ? c : this.bearing,
              v = h = h !== void 0 ? h : this.pitch,
              w = l.a5.fromLngLat(e, a),
              T = -Math.cos(l.ak(v)),
              C = Math.sin(l.ak(v)),
              z = C * Math.sin(l.ak(f)),
              F = -C * Math.cos(l.ak(f));
            let R = this.elevation;
            const U = a - R;
            let Y;
            T * U >= 0 || Math.abs(T) < .1 ? (Y = 1e4, R = a + Y * T) : Y = -U / T;
            let ne, ie, ae = l.aT(1, w.y),
              me = 0;
            do {
              if (me += 1, me > 10) break;
              ie = Y / ae, ne = new l.a5(w.x + z * ie, w.y + F * ie), ae = 1 / ne.meterInMercatorCoordinateUnits()
            } while (Math.abs(Y - ie * ae) > 1e-12);
            return {
              center: ne.toLngLat(),
              elevation: R,
              zoom: l.ao(this.height / 2 / Math.tan(this.fovInRadians / 2) / ie / this.tileSize)
            }
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const a = l.an(1, this.center.lat) * this.worldSize,
              c = this.cameraToCenterDistance / a,
              h = l.a5.fromLngLat(this.center, this.elevation),
              f = Q(this.center, this.elevation, this.pitch, this.bearing, c);
            this._elevation = e;
            const v = this.calculateCenterFromCameraLngLatAlt(f.toLngLat(), l.aT(f.z, h.y), this.bearing, this.pitch);
            this._elevation = v.elevation, this._center = v.center, this.setZoom(v.zoom)
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new l.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)))
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
          }
          getCameraLngLat() {
            const e = l.an(1, this.center.lat) * this.worldSize;
            return Q(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const a = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / a, e.canonical.y / a, 1 / a / l.a3, 1 / a / l.a3]
          }
        }
        class Cn {
          constructor(e, a) {
            this.min = e, this.max = a, this.center = l.aU([], l.aV([], this.min, this.max), .5)
          }
          quadrant(e) {
            const a = [e % 2 == 0, e < 2],
              c = l.aW(this.min),
              h = l.aW(this.max);
            for (let f = 0; f < a.length; f++) c[f] = a[f] ? this.min[f] : this.center[f], h[f] = a[f] ? this.center[f] : this.max[f];
            return h[2] = this.max[2], new Cn(c, h)
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
          }
          intersectsFrustum(e) {
            let a = !0;
            for (let c = 0; c < e.planes.length; c++) {
              const h = this.intersectsPlane(e.planes[c]);
              if (h === 0) return 0;
              h === 1 && (a = !1)
            }
            return a ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
          }
          intersectsPlane(e) {
            let a = e[3],
              c = e[3];
            for (let h = 0; h < 3; h++) e[h] > 0 ? (a += e[h] * this.min[h], c += e[h] * this.max[h]) : (c += e[h] * this.min[h], a += e[h] * this.max[h]);
            return a >= 0 ? 2 : c < 0 ? 0 : 1
          }
        }
        class $n {
          distanceToTile2d(e, a, c, h) {
            const f = h.distanceX([e, a]),
              v = h.distanceY([e, a]);
            return Math.hypot(f, v)
          }
          getWrap(e, a, c) {
            return c
          }
          getTileBoundingVolume(e, a, c, h) {
            var f, v;
            let w = 0,
              T = 0;
            if (h != null && h.terrain) {
              const z = new l.a0(e.z, a, e.z, e.x, e.y),
                F = h.terrain.getMinMaxElevation(z);
              w = (f = F.minElevation) !== null && f !== void 0 ? f : Math.min(0, c), T = (v = F.maxElevation) !== null && v !== void 0 ? v : Math.max(0, c)
            }
            const C = 1 << e.z;
            return new Cn([a + e.x / C, e.y / C, w], [a + (e.x + 1) / C, (e.y + 1) / C, T])
          }
          allowVariableZoom(e, a) {
            const c = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height,
              h = l.ai(78.5 - c / 2, 0, 60);
            return !!a.terrain || e.pitch > h
          }
          allowWorldCopies() {
            return !0
          }
          prepareNextFrame() {}
        }
        class bi {
          constructor(e, a, c) {
            this.points = e, this.planes = a, this.aabb = c
          }
          static fromInvProjectionMatrix(e, a = 1, c = 0, h, f) {
            const v = f ? [
                [6, 5, 4],
                [0, 1, 2],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ] : [
                [0, 1, 2],
                [6, 5, 4],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ],
              w = Math.pow(2, c),
              T = [
                [-1, 1, -1, 1],
                [1, 1, -1, 1],
                [1, -1, -1, 1],
                [-1, -1, -1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, -1, 1, 1],
                [-1, -1, 1, 1]
              ].map((R => (function(U, Y, ne, ie) {
                const ae = l.aA([], U, Y),
                  me = 1 / ae[3] / ne * ie;
                return l.a$(ae, ae, [me, me, 1 / ae[3], me])
              })(R, e, a, w)));
            h && (function(R, U, Y, ne) {
              const ie = ne ? 4 : 0,
                ae = ne ? 0 : 4;
              let me = 0;
              const ke = [],
                _e = [];
              for (let ye = 0; ye < 4; ye++) {
                const Be = l.aX([], R[ye + ae], R[ye + ie]),
                  ht = l.b0(Be);
                l.aU(Be, Be, 1 / ht), ke.push(ht), _e.push(Be)
              }
              for (let ye = 0; ye < 4; ye++) {
                const Be = l.b1(R[ye + ie], _e[ye], Y);
                me = Be !== null && Be >= 0 ? Math.max(me, Be) : Math.max(me, ke[ye])
              }
              const Te = (function(ye, Be) {
                  const ht = l.aX([], ye[Be[0]], ye[Be[1]]),
                    at = l.aX([], ye[Be[2]], ye[Be[1]]),
                    lt = [0, 0, 0, 0];
                  return l.aY(lt, l.aZ([], ht, at)), lt[3] = -l.a_(lt, ye[Be[0]]), lt
                })(R, U),
                Ee = (function(ye, Be) {
                  const ht = l.b2(ye),
                    at = l.b3([], ye, 1 / ht),
                    lt = l.aX([], Be, l.aU([], at, l.a_(Be, at))),
                    pt = l.b2(lt);
                  if (pt > 0) {
                    const ur = Math.sqrt(1 - at[3] * at[3]),
                      hr = l.aU([], at, -at[3]),
                      Nt = l.aV([], hr, l.aU([], lt, ur / pt));
                    return l.b4(Be, Nt)
                  }
                  return null
                })(Y, Te);
              if (Ee !== null) {
                const ye = Ee / l.a_(_e[0], Te);
                me = Math.min(me, ye)
              }
              for (let ye = 0; ye < 4; ye++) {
                const Be = Math.min(me, ke[ye]);
                R[ye + ae] = [R[ye + ie][0] + _e[ye][0] * Be, R[ye + ie][1] + _e[ye][1] * Be, R[ye + ie][2] + _e[ye][2] * Be, 1]
              }
            })(T, v[0], h, f);
            const C = v.map((R => {
                const U = l.aX([], T[R[0]], T[R[1]]),
                  Y = l.aX([], T[R[2]], T[R[1]]),
                  ne = l.aY([], l.aZ([], U, Y)),
                  ie = -l.a_(ne, T[R[1]]);
                return ne.concat(ie)
              })),
              z = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
              F = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const R of T)
              for (let U = 0; U < 3; U++) z[U] = Math.min(z[U], R[U]), F[U] = Math.max(F[U], R[U]);
            return new bi(T, C, new Cn(z, F))
          }
        }
        class Nn {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, a, c = !0) {
            this._helper.resize(e, a, c)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e, a) {}
          constructor(e) {
            this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this.defaultConstrain = (a, c) => {
              c = l.ai(+c, this.minZoom, this.maxZoom);
              const h = {
                center: new l.U(a.lng, a.lat),
                zoom: c
              };
              let f = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && f === null) {
                const _e = 179.9999999999;
                f = [-_e, _e]
              }
              const v = this.tileSize * l.al(h.zoom);
              let w = 0,
                T = v,
                C = 0,
                z = v,
                F = 0,
                R = 0;
              const {
                x: U,
                y: Y
              } = this.size;
              if (this._helper._latRange) {
                const _e = this._helper._latRange;
                w = l.W(_e[1]) * v, T = l.W(_e[0]) * v, T - w < Y && (F = Y / (T - w))
              }
              f && (C = l.V(l.X(f[0]) * v, 0, v), z = l.V(l.X(f[1]) * v, 0, v), z < C && (z += v), z - C < U && (R = U / (z - C)));
              const {
                x: ne,
                y: ie
              } = qe(v, a);
              let ae, me;
              const ke = Math.max(R || 0, F || 0);
              if (ke) {
                const _e = new l.P(R ? (z + C) / 2 : ne, F ? (T + w) / 2 : ie);
                return h.center = rt(v, _e).wrap(), h.zoom += l.ao(ke), h
              }
              if (this._helper._latRange) {
                const _e = Y / 2;
                ie - _e < w && (me = w + _e), ie + _e > T && (me = T - _e)
              }
              if (f) {
                const _e = (C + z) / 2;
                let Te = ne;
                this._helper._renderWorldCopies && (Te = l.V(ne, _e - v / 2, _e + v / 2));
                const Ee = U / 2;
                Te - Ee < C && (ae = C + Ee), Te + Ee > z && (ae = z - Ee)
              }
              if (ae !== void 0 || me !== void 0) {
                const _e = new l.P(ae ?? ne, me ?? ie);
                h.center = rt(v, _e).wrap()
              }
              return h
            }, this._helper = new kn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (a, c) => this.defaultConstrain(a, c)
            }, e), this._coveringTilesDetailsProvider = new $n
          }
          clone() {
            const e = new Nn;
            return e.apply(this), e
          }
          apply(e, a, c) {
            this._helper.apply(e, a, c)
          }
          get cameraPosition() {
            return this._cameraPosition
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix
          }
          get mercatorMatrix() {
            return this._mercatorMatrix
          }
          getVisibleUnwrappedCoordinates(e) {
            const a = [new l.b5(0, e)];
            if (this._helper._renderWorldCopies) {
              const c = this.screenPointToMercatorCoordinate(new l.P(0, 0)),
                h = this.screenPointToMercatorCoordinate(new l.P(this._helper._width, 0)),
                f = this.screenPointToMercatorCoordinate(new l.P(this._helper._width, this._helper._height)),
                v = this.screenPointToMercatorCoordinate(new l.P(0, this._helper._height)),
                w = Math.floor(Math.min(c.x, h.x, f.x, v.x)),
                T = Math.floor(Math.max(c.x, h.x, f.x, v.x)),
                C = 1;
              for (let z = w - C; z <= T + C; z++) z !== 0 && a.push(new l.b5(z, e))
            }
            return a
          }
          getCameraFrustum() {
            return bi.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
          }
          getClippingPlane() {
            return null
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            const a = this.screenPointToLocation(this.centerPoint, e),
              c = e ? e.getElevationForLngLatZoom(a, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(c)
          }
          setLocationAtPoint(e, a) {
            const c = l.an(this.elevation, this.center.lat),
              h = this.screenPointToMercatorCoordinateAtZ(a, c),
              f = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, c),
              v = l.a5.fromLngLat(e),
              w = new l.a5(v.x - (h.x - f.x), v.y - (h.y - f.y));
            this.setCenter(w == null ? void 0 : w.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
          }
          locationToScreenPoint(e, a) {
            return a ? this.coordinatePoint(l.a5.fromLngLat(e), a.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(l.a5.fromLngLat(e))
          }
          screenPointToLocation(e, a) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, a)) === null || c === void 0 ? void 0 : c.toLngLat()
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const c = a.pointCoordinate(e);
              if (c != null) return c
            }
            return this.screenPointToMercatorCoordinateAtZ(e)
          }
          screenPointToMercatorCoordinateAtZ(e, a) {
            const c = a || 0,
              h = [e.x, e.y, 0, 1],
              f = [e.x, e.y, 1, 1];
            l.aA(h, h, this._pixelMatrixInverse), l.aA(f, f, this._pixelMatrixInverse);
            const v = h[3],
              w = f[3],
              T = h[1] / v,
              C = f[1] / w,
              z = h[2] / v,
              F = f[2] / w,
              R = z === F ? 0 : (c - z) / (F - z);
            return new l.a5(l.F.number(h[0] / v, f[0] / w, R) / this.worldSize, l.F.number(T, C, R) / this.worldSize, c)
          }
          coordinatePoint(e, a = 0, c = this._pixelMatrix) {
            const h = [e.x * this.worldSize, e.y * this.worldSize, a, 1];
            return l.aA(h, h, c), new l.P(h[0] / h[3], h[1] / h[3])
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - Xe(this));
            return new yt().extend(this.screenPointToLocation(new l.P(0, e))).extend(this.screenPointToLocation(new l.P(this._helper._width, e))).extend(this.screenPointToLocation(new l.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new l.P(0, this._helper._height)))
          }
          isPointOnMapSurface(e, a) {
            return a ? a.pointCoordinate(e) != null : e.y > this.height / 2 - Xe(this)
          }
          calculatePosMatrix(e, a = !1, c) {
            var h;
            const f = (h = e.key) !== null && h !== void 0 ? h : l.b6(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y),
              v = a ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (v.has(f)) {
              const C = v.get(f);
              return c ? C.f32 : C.f64
            }
            const w = he(e, this.worldSize);
            l.Q(w, a ? this._alignedProjMatrix : this._viewProjMatrix, w);
            const T = {
              f64: w,
              f32: new Float32Array(w)
            };
            return v.set(f, T), c ? T.f32 : T.f64
          }
          calculateFogMatrix(e) {
            const a = e.key,
              c = this._fogMatrixCacheF32;
            if (c.has(a)) return c.get(a);
            const h = he(e, this.worldSize);
            return l.Q(h, this._fogMatrix, h), c.set(a, new Float32Array(h)), c.get(a)
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, h) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, h)
          }
          _calculateNearFarZIfNeeded(e, a, c) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const h = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100),
              f = e - h * this._helper._pixelPerMeter / Math.cos(a),
              v = h < 0 ? f : e,
              w = Math.PI / 2 + this.pitchInRadians,
              T = l.ak(this.fov) * (Math.abs(Math.cos(l.ak(this.roll))) * this.height + Math.abs(Math.sin(l.ak(this.roll))) * this.width) / this.height * (.5 + c.y / this.height),
              C = Math.sin(T) * v / Math.sin(l.ai(Math.PI - w - T, .01, Math.PI - .01)),
              z = Xe(this),
              F = Math.atan(z / this._helper.cameraToCenterDistance),
              R = l.ak(.75),
              U = F > R ? 2 * F * (.5 + c.y / (2 * z)) : R,
              Y = Math.sin(U) * v / Math.sin(l.ai(Math.PI - w - U, .01, Math.PI - .01)),
              ne = Math.min(C, Y);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - a) * ne + v), this._helper._nearZ = this._helper._height / 50
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset,
              a = qe(this.worldSize, this.center),
              c = a.x,
              h = a.y;
            this._helper._pixelPerMeter = l.an(1, this.center.lat) * this.worldSize;
            const f = l.ak(Math.min(this.pitch, Ie)),
              v = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(f));
            let w;
            this._calculateNearFarZIfNeeded(v, f, e), w = new Float64Array(16), l.b7(w, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), l.au(this._invProjMatrix, w), w[8] = 2 * -e.x / this._helper._width, w[9] = 2 * e.y / this._helper._height, this._projectionMatrix = l.b8(w), l.O(w, w, [1, -1, 1]), l.N(w, w, [0, 0, -this._helper.cameraToCenterDistance]), l.b9(w, w, -this.rollInRadians), l.ba(w, w, this.pitchInRadians), l.b9(w, w, -this.bearingInRadians), l.N(w, w, [-c, -h, 0]), this._mercatorMatrix = l.O([], w, [this.worldSize, this.worldSize, this.worldSize]), l.O(w, w, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = l.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, w), l.N(w, w, [0, 0, -this.elevation]), this._viewProjMatrix = w, this._invViewProjMatrix = l.au([], w);
            const T = [0, 0, -1, 1];
            l.aA(T, T, this._invViewProjMatrix), this._cameraPosition = [T[0] / T[3], T[1] / T[3], T[2] / T[3]], this._fogMatrix = new Float64Array(16), l.b7(this._fogMatrix, this.fovInRadians, this.width / this.height, v, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, l.O(this._fogMatrix, this._fogMatrix, [1, -1, 1]), l.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), l.b9(this._fogMatrix, this._fogMatrix, -this.rollInRadians), l.ba(this._fogMatrix, this._fogMatrix, this.pitchInRadians), l.b9(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), l.N(this._fogMatrix, this._fogMatrix, [-c, -h, 0]), l.O(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), l.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = l.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, w);
            const C = this._helper._width % 2 / 2,
              z = this._helper._height % 2 / 2,
              F = Math.cos(this.bearingInRadians),
              R = Math.sin(-this.bearingInRadians),
              U = c - Math.round(c) + F * C + R * z,
              Y = h - Math.round(h) + F * z + R * C,
              ne = new Float64Array(w);
            if (l.N(ne, ne, [U > .5 ? U - 1 : U, Y > .5 ? Y - 1 : Y, 0]), this._alignedProjMatrix = ne, w = l.au(new Float64Array(16), this._pixelMatrix), !w) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = w, this._clearMatrixCaches()
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear()
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new l.P(0, 0)),
              a = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return l.aA(a, a, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            const e = l.an(1, this.center.lat) * this.worldSize;
            return Q(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
          }
          lngLatToCameraDepth(e, a) {
            const c = l.a5.fromLngLat(e),
              h = [c.x * this.worldSize, c.y * this.worldSize, a, 1];
            return l.aA(h, h, this._viewProjMatrix), h[2] / h[3]
          }
          getProjectionData(e) {
            const {
              overscaledTileID: a,
              aligned: c,
              applyTerrainMatrix: h
            } = e, f = this._helper.getMercatorTileCoordinates(a), v = a ? this.calculatePosMatrix(a, c, !0) : null;
            let w;
            return w = a && a.terrainRttPosMatrix32f && h ? a.terrainRttPosMatrix32f : v || l.bb(), {
              mainMatrix: w,
              tileMercatorCoords: f,
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: w
            }
          }
          isLocationOccluded(e) {
            return !1
          }
          getPixelScale() {
            return 1
          }
          getCircleRadiusCorrection() {
            return 1
          }
          getPitchedTextCorrection(e, a, c) {
            return 1
          }
          transformLightDirection(e) {
            return l.aW(e)
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.")
          }
          projectTileCoordinates(e, a, c, h) {
            const f = this.calculatePosMatrix(c);
            let v;
            h ? (v = [e, a, h(e, a), 1], l.aA(v, v, f)) : (v = [e, a, 0, 1], Kr(v, v, f));
            const w = v[3];
            return {
              point: new l.P(v[0] / w, v[1] / w),
              signedDistanceFromCamera: w,
              isOccluded: !1
            }
          }
          populateCache(e) {
            for (const a of e) this.calculatePosMatrix(a)
          }
          getMatrixForModel(e, a) {
            const c = l.a5.fromLngLat(e, a),
              h = c.meterInMercatorCoordinateUnits(),
              f = l.bc();
            return l.N(f, f, [c.x, c.y, c.z]), l.b9(f, f, Math.PI), l.ba(f, f, Math.PI / 2), l.O(f, f, [-h, h, h]), f
          }
          getProjectionDataForCustomLayer(e = !0) {
            const a = new l.a0(0, 0, 0, 0, 0),
              c = this.getProjectionData({
                overscaledTileID: a,
                applyGlobeMatrix: e
              }),
              h = he(a, this.worldSize);
            l.Q(h, this._viewProjMatrix, h), c.tileMercatorCoords = [0, 0, 1, 1];
            const f = [l.a3, l.a3, this.worldSize / this._helper.pixelsPerMeter],
              v = l.bd();
            return l.O(v, h, f), c.fallbackMatrix = v, c.mainMatrix = v, c
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e)
          }
        }

        function fn() {
          l.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
        }

        function _n(p) {
          if (p.useSlerp)
            if (p.k < 1) {
              const e = l.be(p.startEulerAngles.roll, p.startEulerAngles.pitch, p.startEulerAngles.bearing),
                a = l.be(p.endEulerAngles.roll, p.endEulerAngles.pitch, p.endEulerAngles.bearing),
                c = new Float64Array(4);
              l.bf(c, e, a, p.k);
              const h = l.bg(c);
              p.tr.setRoll(h.roll), p.tr.setPitch(h.pitch), p.tr.setBearing(h.bearing)
            } else p.tr.setRoll(p.endEulerAngles.roll), p.tr.setPitch(p.endEulerAngles.pitch), p.tr.setBearing(p.endEulerAngles.bearing);
          else p.tr.setRoll(l.F.number(p.startEulerAngles.roll, p.endEulerAngles.roll, p.k)), p.tr.setPitch(l.F.number(p.startEulerAngles.pitch, p.endEulerAngles.pitch, p.k)), p.tr.setBearing(l.F.number(p.startEulerAngles.bearing, p.endEulerAngles.bearing, p.k))
        }

        function Vn(p, e, a, c, h) {
          const f = h.padding,
            v = qe(h.worldSize, a.getNorthWest()),
            w = qe(h.worldSize, a.getNorthEast()),
            T = qe(h.worldSize, a.getSouthEast()),
            C = qe(h.worldSize, a.getSouthWest()),
            z = l.ak(-c),
            F = v.rotate(z),
            R = w.rotate(z),
            U = T.rotate(z),
            Y = C.rotate(z),
            ne = new l.P(Math.max(F.x, R.x, Y.x, U.x), Math.max(F.y, R.y, Y.y, U.y)),
            ie = new l.P(Math.min(F.x, R.x, Y.x, U.x), Math.min(F.y, R.y, Y.y, U.y)),
            ae = ne.sub(ie),
            me = (h.width - (f.left + f.right + e.left + e.right)) / ae.x,
            ke = (h.height - (f.top + f.bottom + e.top + e.bottom)) / ae.y;
          if (ke < 0 || me < 0) return void fn();
          const _e = Math.min(l.ao(h.scale * Math.min(me, ke)), p.maxZoom),
            Te = l.P.convert(p.offset),
            Ee = new l.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(l.ak(c)),
            ye = Te.add(Ee).mult(h.scale / l.al(_e));
          return {
            center: rt(h.worldSize, v.add(T).div(2).sub(ye)),
            zoom: _e,
            bearing: c
          }
        }
        class ci {
          get useGlobeControls() {
            return !1
          }
          handlePanInertia(e, a) {
            const c = e.mag(),
              h = Math.abs(Xe(a));
            return {
              easingOffset: e.mult(Math.min(.75 * h / c, 1)),
              easingCenter: a.center
            }
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta), e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta)
          }
          handleMapControlsPan(e, a, c) {
            e.around.distSqr(a.centerPoint) < .01 || a.setLocationAtPoint(c, e.around)
          }
          cameraForBoxAndBearing(e, a, c, h, f) {
            return Vn(e, a, c, h, f)
          }
          handleJumpToCenterZoom(e, a) {
            e.zoom !== (a.zoom !== void 0 ? +a.zoom : e.zoom) && e.setZoom(+a.zoom), a.center !== void 0 && e.setCenter(l.U.convert(a.center))
          }
          handleEaseTo(e, a) {
            const c = e.zoom,
              h = e.padding,
              f = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              v = {
                roll: a.roll === void 0 ? e.roll : a.roll,
                pitch: a.pitch === void 0 ? e.pitch : a.pitch,
                bearing: a.bearing === void 0 ? e.bearing : a.bearing
              },
              w = a.zoom !== void 0,
              T = !e.isPaddingEqual(a.padding);
            let C = !1;
            const z = w ? +a.zoom : e.zoom;
            let F = e.centerPoint.add(a.offsetAsPoint);
            const R = e.screenPointToLocation(F),
              {
                center: U,
                zoom: Y
              } = e.constrain(l.U.convert(a.center || R), z ?? c);
            sn(e, U);
            const ne = qe(e.worldSize, R),
              ie = qe(e.worldSize, U).sub(ne),
              ae = l.al(Y - c);
            return C = Y !== c, {
              easeFunc: me => {
                if (C && e.setZoom(l.F.number(c, Y, me)), l.bh(f, v) || _n({
                    startEulerAngles: f,
                    endEulerAngles: v,
                    tr: e,
                    k: me,
                    useSlerp: f.roll != v.roll
                  }), T && (e.interpolatePadding(h, a.padding, me), F = e.centerPoint.add(a.offsetAsPoint)), a.around) e.setLocationAtPoint(a.around, a.aroundPoint);
                else {
                  const ke = l.al(e.zoom - c),
                    _e = Y > c ? Math.min(2, ae) : Math.max(.5, ae),
                    Te = Math.pow(_e, 1 - me),
                    Ee = rt(e.worldSize, ne.add(ie.mult(me * Te)).mult(ke));
                  e.setLocationAtPoint(e.renderWorldCopies ? Ee.wrap() : Ee, F)
                }
              },
              isZooming: C,
              elevationCenter: U
            }
          }
          handleFlyTo(e, a) {
            const c = a.zoom !== void 0,
              h = e.zoom,
              f = e.constrain(l.U.convert(a.center || a.locationAtOffset), c ? +a.zoom : h),
              v = f.center,
              w = f.zoom;
            sn(e, v);
            const T = qe(e.worldSize, a.locationAtOffset),
              C = qe(e.worldSize, v).sub(T),
              z = C.mag(),
              F = l.al(w - h);
            let R;
            if (a.minZoom !== void 0) {
              const U = Math.min(+a.minZoom, h, w),
                Y = e.constrain(v, U).zoom;
              R = l.al(Y - h)
            }
            return {
              easeFunc: (U, Y, ne, ie) => {
                e.setZoom(U === 1 ? w : h + l.ao(Y));
                const ae = U === 1 ? v : rt(e.worldSize, T.add(C.mult(ne)).mult(Y));
                e.setLocationAtPoint(e.renderWorldCopies ? ae.wrap() : ae, ie)
              },
              scaleOfZoom: F,
              targetCenter: v,
              scaleOfMinZoom: R,
              pixelPathLength: z
            }
          }
        }
        class an {
          constructor(e, a, c) {
            this.blendFunction = e, this.blendColor = a, this.mask = c
          }
        }
        an.Replace = [1, 0], an.disabled = new an(an.Replace, l.bi.transparent, [!1, !1, !1, !1]), an.unblended = new an(an.Replace, l.bi.transparent, [!0, !0, !0, !0]), an.alphaBlended = new an([1, 771], l.bi.transparent, [!0, !0, !0, !0]);
        const Si = 2305;
        class ln {
          constructor(e, a, c) {
            this.enable = e, this.mode = a, this.frontFace = c
          }
        }
        ln.disabled = new ln(!1, 1029, Si), ln.backCCW = new ln(!0, 1029, Si), ln.frontCCW = new ln(!0, 1028, Si);
        class dn {
          constructor(e, a, c) {
            this.func = e, this.mask = a, this.range = c
          }
        }
        dn.ReadOnly = !1, dn.ReadWrite = !0, dn.disabled = new dn(519, dn.ReadOnly, [0, 1]);
        const Na = 7680;
        class An {
          constructor(e, a, c, h, f, v) {
            this.test = e, this.ref = a, this.mask = c, this.fail = h, this.depthFail = f, this.pass = v
          }
        }
        An.disabled = new An({
          func: 519,
          mask: 0
        }, 0, 0, Na, Na, Na);
        const Bi = new WeakMap;

        function Di(p) {
          var e;
          if (Bi.has(p)) return Bi.get(p);
          {
            const a = (e = p.getParameter(p.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return Bi.set(p, a), a
          }
        }
        class La {
          get awaitingQuery() {
            return !!this._readbackQueue
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const a = e.context,
              c = a.gl;
            this._texFormat = c.RGBA, this._texType = c.UNSIGNED_BYTE;
            const h = new l.aP;
            h.emplaceBack(-1, -1), h.emplaceBack(2, -1), h.emplaceBack(-1, 2);
            const f = new l.aR;
            f.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Fn(a.createVertexBuffer(h, Rn.members), a.createIndexBuffer(f), l.aQ.simpleSegment(0, 0, h.length, f.length)), this._resultBuffer = new Uint8Array(4), a.activeTexture.set(c.TEXTURE1);
            const v = c.createTexture();
            c.bindTexture(c.TEXTURE_2D, v), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST), c.texImage2D(c.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = a.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(v), Di(c) && (this._pbo = c.createBuffer(), c.bindBuffer(c.PIXEL_PACK_BUFFER, this._pbo), c.bufferData(c.PIXEL_PACK_BUFFER, 4, c.STREAM_READ), c.bindBuffer(c.PIXEL_PACK_BUFFER, null))
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null
          }
          updateErrorLoop(e, a) {
            const c = this._updateCount;
            return this._readbackQueue ? c >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : c >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, a), this._updateCount++, this._measuredError
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context,
              a = e.gl;
            e.activeTexture.set(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer)
          }
          _renderErrorTexture(e, a) {
            const c = this._cachedRenderContext.context,
              h = c.gl;
            if (this._bindFramebuffer(), c.viewport.set([0, 0, this._texWidth, this._texHeight]), c.clear({
                color: l.bi.transparent
              }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(c, h.TRIANGLES, dn.disabled, An.disabled, an.unblended, ln.disabled, ((f, v) => ({
                u_input: f,
                u_output_expected: v
              }))(e, a), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Di(h)) {
              h.bindBuffer(h.PIXEL_PACK_BUFFER, this._pbo), h.readBuffer(h.COLOR_ATTACHMENT0), h.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), h.bindBuffer(h.PIXEL_PACK_BUFFER, null);
              const f = h.fenceSync(h.SYNC_GPU_COMMANDS_COMPLETE, 0);
              h.flush(), this._readbackQueue = {
                frameNumberIssued: this._updateCount,
                sync: f
              }
            } else this._readbackQueue = {
              frameNumberIssued: this._updateCount,
              sync: null
            }
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Di(e)) {
              const a = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (a === e.WAIT_FAILED) return l.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void(this._lastReadbackFrame = this._updateCount);
              if (a === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = La._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount
          }
          static _parseRGBA8float(e) {
            let a = 0;
            return a += e[0] / 256, a += e[1] / 65536, a += e[2] / 16777216, e[3] < 127 && (a = -a), a / 128
          }
        }
        const Da = l.a3 / 128;

        function ga(p, e) {
          const a = p.granularity !== void 0 ? Math.max(p.granularity, 1) : 1,
            c = a + (p.generateBorders ? 2 : 0),
            h = a + (p.extendToNorthPole || p.generateBorders ? 1 : 0) + (p.extendToSouthPole || p.generateBorders ? 1 : 0),
            f = c + 1,
            v = h + 1,
            w = p.generateBorders ? -1 : 0,
            T = p.generateBorders || p.extendToNorthPole ? -1 : 0,
            C = a + (p.generateBorders ? 1 : 0),
            z = a + (p.generateBorders || p.extendToSouthPole ? 1 : 0),
            F = f * v,
            R = c * h * 6,
            U = f * v > 65536;
          if (U && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const Y = U || e === "32bit",
            ne = new Int16Array(2 * F);
          let ie = 0;
          for (let ke = T; ke <= z; ke++)
            for (let _e = w; _e <= C; _e++) {
              let Te = _e / a * l.a3;
              _e === -1 && (Te = -Da), _e === a + 1 && (Te = l.a3 + Da);
              let Ee = ke / a * l.a3;
              ke === -1 && (Ee = p.extendToNorthPole ? l.bk : -Da), ke === a + 1 && (Ee = p.extendToSouthPole ? l.bl : l.a3 + Da), ne[ie++] = Te, ne[ie++] = Ee
            }
          const ae = Y ? new Uint32Array(R) : new Uint16Array(R);
          let me = 0;
          for (let ke = 0; ke < h; ke++)
            for (let _e = 0; _e < c; _e++) {
              const Te = _e + 1 + ke * f,
                Ee = _e + (ke + 1) * f,
                ye = _e + 1 + (ke + 1) * f;
              ae[me++] = _e + ke * f, ae[me++] = Ee, ae[me++] = Te, ae[me++] = Te, ae[me++] = Ee, ae[me++] = ye
            }
          return {
            vertices: ne.buffer.slice(0),
            indices: ae.buffer.slice(0),
            uses32bitIndices: Y
          }
        }
        const va = new l.aO({
          fill: new l.bm(128, 2),
          line: new l.bm(512, 0),
          tile: new l.bm(128, 32),
          stencil: new l.bm(128, 1),
          circle: 3
        });
        class to {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3
          }
          get name() {
            return "vertical-perspective"
          }
          get transitionState() {
            return 1
          }
          get useSubdivision() {
            return !0
          }
          get shaderVariantName() {
            return "globe"
          }
          get shaderDefine() {
            return "#define GLOBE"
          }
          get shaderPreludeCode() {
            return Nr.projectionGlobe
          }
          get vertexShaderPreludeCode() {
            return Nr.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return va
          }
          get useGlobeControls() {
            return !0
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy()
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new La(e));
            const a = l.W(this._errorQueryLatitudeDegrees),
              c = 2 * Math.atan(Math.exp(Math.PI - a * Math.PI * 2)) - .5 * Math.PI,
              h = this._errorMeasurement.updateErrorLoop(a, c),
              f = fe();
            h !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = h, this._errorMeasurementLastChangeTime = f);
            const v = Math.min(Math.max((f - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
            this._errorCorrectionUsable = l.bn(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, l.bo(v))
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders?"b":""}${e.extendToNorthPole?"n":""}${e.extendToSouthPole?"s":""}`
          }
          getMeshFromTileID(e, a, c, h, f) {
            const v = (f === "stencil" ? va.stencil : va.tile).getGranularityForZoomLevel(a.z);
            return this._getMesh(e, {
              granularity: v,
              generateBorders: c,
              extendToNorthPole: a.y === 0 && h,
              extendToSouthPole: a.y === (1 << a.z) - 1 && h
            })
          }
          _getMesh(e, a) {
            const c = this._getMeshKey(a);
            if (c in this._tileMeshCache) return this._tileMeshCache[c];
            const h = (function(f, v) {
              const w = ga(v, "16bit"),
                T = l.aP.deserialize({
                  arrayBuffer: w.vertices,
                  length: w.vertices.byteLength / 2 / 2
                }),
                C = l.aR.deserialize({
                  arrayBuffer: w.indices,
                  length: w.indices.byteLength / 2 / 3
                });
              return new Fn(f.createVertexBuffer(T, Rn.members), f.createIndexBuffer(C), l.aQ.simpleSegment(0, 0, T.length, C.length))
            })(e, a);
            return this._tileMeshCache[c] = h, h
          }
          recalculate(e) {}
          hasTransition() {
            const e = fe();
            let a = !1;
            return a = a || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, a = a || this._errorMeasurement && this._errorMeasurement.awaitingQuery, a
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e
          }
        }
        const so = new l.r({
          type: new l.D(l.t.projection.type)
        });
        class ii extends l.E {
          constructor(e) {
            super(), this._transitionable = new l.x(so, void 0), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new l.G(0)), this._mercatorProjection = new mr, this._verticalPerspectiveProjection = new to
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof l.bp) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition
            }
            return 1
          }
          get useGlobeRendering() {
            return this.transitionState > 0
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
          }
          get name() {
            return "globe"
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity
          }
          get useGlobeControls() {
            return this.transitionState > 0
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy()
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e)
          }
          getMeshFromTileID(e, a, c, h, f) {
            return this.currentProjection.getMeshFromTileID(e, a, c, h, f)
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator")
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
          }
        }

        function ui(p) {
          const e = ca(p.worldSize, p.center.lat);
          return 2 * Math.PI * e
        }

        function Xi(p, e, a, c, h) {
          const f = 1 / (1 << h),
            v = e / l.a3 * f + c * f,
            w = l.br((p / l.a3 * f + a * f) * Math.PI * 2 + Math.PI, 2 * Math.PI),
            T = 2 * Math.atan(Math.exp(Math.PI - v * Math.PI * 2)) - .5 * Math.PI,
            C = Math.cos(T),
            z = new Float64Array(3);
          return z[0] = Math.sin(w) * C, z[1] = Math.sin(T), z[2] = Math.cos(w) * C, z
        }

        function ai(p) {
          return (function(e, a) {
            const c = Math.cos(a),
              h = new Float64Array(3);
            return h[0] = Math.sin(e) * c, h[1] = Math.sin(a), h[2] = Math.cos(e) * c, h
          })(p.lng * Math.PI / 180, p.lat * Math.PI / 180)
        }

        function ca(p, e) {
          return p / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
        }

        function lo(p) {
          const e = Math.asin(p[1]) / Math.PI * 180,
            a = Math.sqrt(p[0] * p[0] + p[2] * p[2]);
          if (a > 1e-6) {
            const c = p[0] / a,
              h = Math.acos(p[2] / a),
              f = (c > 0 ? h : -h) / Math.PI * 180;
            return new l.U(l.V(f, -180, 180), e)
          }
          return new l.U(0, e)
        }

        function co(p) {
          return Math.cos(p * Math.PI / 180)
        }

        function On(p, e) {
          const a = co(p),
            c = co(e);
          return l.ao(c / a)
        }

        function xs(p, e) {
          const a = p.rotate(e.bearingInRadians),
            c = e.zoom + On(e.center.lat, 0),
            h = l.bn(1 / co(e.center.lat), 1 / co(Math.min(Math.abs(e.center.lat), 60)), l.bq(c, 7, 3, 0, 1)),
            f = 360 / ui({
              worldSize: e.worldSize,
              center: {
                lat: e.center.lat
              }
            });
          return new l.U(e.center.lng - a.x * f * h, l.ai(e.center.lat + a.y * f, -l.aj, l.aj))
        }

        function Yi(p) {
          const e = .5 * p,
            a = Math.sin(e),
            c = Math.cos(e);
          return Math.log(a + c) - Math.log(c - a)
        }

        function uo(p, e, a, c) {
          const h = p.lat + a * c;
          if (Math.abs(a) > 1) {
            const f = (Math.sign(p.lat + a) !== Math.sign(p.lat) ? -Math.abs(p.lat) : Math.abs(p.lat)) * Math.PI / 180,
              v = Math.abs(p.lat + a) * Math.PI / 180,
              w = Yi(f + c * (v - f)),
              T = Yi(f),
              C = Yi(v);
            return new l.U(p.lng + e * ((w - T) / (C - T)), h)
          }
          return new l.U(p.lng + e * c, h)
        }
        class Ml {
          constructor(e) {
            this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._boundingVolumeFactory = e
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1
          }
          getTileBoundingVolume(e, a, c, h) {
            const f = `${e.z}_${e.x}_${e.y}_${h!=null&&h.terrain?"t":""}`,
              v = this._cache.get(f);
            if (v) return v;
            const w = this._cachePrevious.get(f);
            if (w) return this._cache.set(f, w), w;
            const T = this._boundingVolumeFactory(e, a, c, h);
            return this._cache.set(f, T), this._hadAnyChanges = !0, T
          }
        }
        class Uo {
          constructor(e, a, c, h) {
            this.min = c, this.max = h, this.points = e, this.planes = a
          }
          static fromAabb(e, a) {
            const c = [];
            for (let h = 0; h < 8; h++) c.push([1 & ~h ? e[0] : a[0], (h >> 1 & 1) == 1 ? a[1] : e[1], (h >> 2 & 1) == 1 ? a[2] : e[2]]);
            return new Uo(c, [
              [-1, 0, 0, a[0]],
              [1, 0, 0, -e[0]],
              [0, -1, 0, a[1]],
              [0, 1, 0, -e[1]],
              [0, 0, -1, a[2]],
              [0, 0, 1, -e[2]]
            ], e, a)
          }
          static fromCenterSizeAngles(e, a, c) {
            const h = l.bu([], c[0], c[1], c[2]),
              f = l.bv([], [a[0], 0, 0], h),
              v = l.bv([], [0, a[1], 0], h),
              w = l.bv([], [0, 0, a[2]], h),
              T = [...e],
              C = [...e];
            for (let F = 0; F < 8; F++)
              for (let R = 0; R < 3; R++) {
                const U = e[R] + f[R] * (1 & ~F ? -1 : 1) + v[R] * ((F >> 1 & 1) == 1 ? 1 : -1) + w[R] * ((F >> 2 & 1) == 1 ? 1 : -1);
                T[R] = Math.min(T[R], U), C[R] = Math.max(C[R], U)
              }
            const z = [];
            for (let F = 0; F < 8; F++) {
              const R = [...e];
              l.aV(R, R, l.aU([], f, 1 & ~F ? -1 : 1)), l.aV(R, R, l.aU([], v, (F >> 1 & 1) == 1 ? 1 : -1)), l.aV(R, R, l.aU([], w, (F >> 2 & 1) == 1 ? 1 : -1)), z.push(R)
            }
            return new Uo(z, [
              [...f, -l.a_(f, z[0])],
              [...v, -l.a_(v, z[0])],
              [...w, -l.a_(w, z[0])],
              [-f[0], -f[1], -f[2], -l.a_(f, z[7])],
              [-v[0], -v[1], -v[2], -l.a_(v, z[7])],
              [-w[0], -w[1], -w[2], -l.a_(w, z[7])]
            ], T, C)
          }
          intersectsFrustum(e) {
            let a = !0;
            const c = this.points.length,
              h = this.planes.length,
              f = e.planes.length,
              v = e.points.length;
            for (let w = 0; w < f; w++) {
              const T = e.planes[w];
              let C = 0;
              for (let z = 0; z < c; z++) {
                const F = this.points[z];
                T[0] * F[0] + T[1] * F[1] + T[2] * F[2] + T[3] >= 0 && C++
              }
              if (C === 0) return 0;
              C < c && (a = !1)
            }
            if (a) return 2;
            for (let w = 0; w < h; w++) {
              const T = this.planes[w];
              let C = 0;
              for (let z = 0; z < v; z++) {
                const F = e.points[z];
                T[0] * F[0] + T[1] * F[1] + T[2] * F[2] + T[3] >= 0 && C++
              }
              if (C === 0) return 0
            }
            return 1
          }
          intersectsPlane(e) {
            const a = this.points.length;
            let c = 0;
            for (let h = 0; h < a; h++) {
              const f = this.points[h];
              e[0] * f[0] + e[1] * f[1] + e[2] * f[2] + e[3] >= 0 && c++
            }
            return c === a ? 2 : c === 0 ? 0 : 1
          }
        }

        function ho(p, e, a) {
          const c = p - e;
          return c < 0 ? -c : Math.max(0, c - a)
        }

        function Uc(p, e, a, c, h) {
          const f = p - a;
          let v;
          return v = f < 0 ? Math.min(-f, 1 + f - h) : f > 1 ? Math.min(Math.max(f - h, 0), 1 - f) : 0, Math.max(v, ho(e, c, h))
        }
        class Up {
          constructor() {
            this._boundingVolumeCache = new Ml(this._computeTileBoundingVolume)
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers()
          }
          distanceToTile2d(e, a, c, h) {
            const f = 1 << c.z,
              v = 1 / f,
              w = c.x / f,
              T = c.y / f;
            let C = 2;
            return C = Math.min(C, Uc(e, a, w, T, v)), C = Math.min(C, Uc(e, a, w + .5, -T - v, v)), C = Math.min(C, Uc(e, a, w + .5, 2 - T - v, v)), C
          }
          getWrap(e, a, c) {
            const h = 1 << a.z,
              f = 1 / h,
              v = a.x / h,
              w = ho(e.x, v, f),
              T = ho(e.x, v - 1, f),
              C = ho(e.x, v + 1, f),
              z = Math.min(w, T, C);
            return z === C ? 1 : z === T ? -1 : 0
          }
          allowVariableZoom(e, a) {
            return De(e, a) > 4
          }
          allowWorldCopies() {
            return !1
          }
          getTileBoundingVolume(e, a, c, h) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, a, c, h)
          }
          _computeTileBoundingVolume(e, a, c, h) {
            var f, v;
            let w = 0,
              T = 0;
            if (h != null && h.terrain) {
              const C = new l.a0(e.z, a, e.z, e.x, e.y),
                z = h.terrain.getMinMaxElevation(C);
              w = (f = z.minElevation) !== null && f !== void 0 ? f : Math.min(0, c), T = (v = z.maxElevation) !== null && v !== void 0 ? v : Math.max(0, c)
            }
            if (w /= l.bx, T /= l.bx, w += 1, T += 1, e.z <= 0) return Uo.fromAabb([-T, -T, -T], [T, T, T]);
            if (e.z === 1) return Uo.fromAabb([e.x === 0 ? -T : 0, e.y === 0 ? 0 : -T, -T], [e.x === 0 ? 0 : T, e.y === 0 ? T : 0, T]);
            {
              const C = [Xi(0, 0, e.x, e.y, e.z), Xi(l.a3, 0, e.x, e.y, e.z), Xi(l.a3, l.a3, e.x, e.y, e.z), Xi(0, l.a3, e.x, e.y, e.z)],
                z = [];
              for (const lt of C) z.push(l.aU([], lt, T));
              if (T !== w)
                for (const lt of C) z.push(l.aU([], lt, w));
              e.y === 0 && z.push([0, 1, 0]), e.y === (1 << e.z) - 1 && z.push([0, -1, 0]);
              const F = [1, 1, 1],
                R = [-1, -1, -1];
              for (const lt of z)
                for (let pt = 0; pt < 3; pt++) F[pt] = Math.min(F[pt], lt[pt]), R[pt] = Math.max(R[pt], lt[pt]);
              const U = Xi(l.a3 / 2, l.a3 / 2, e.x, e.y, e.z),
                Y = l.aZ([], [0, 1, 0], U);
              l.aY(Y, Y);
              const ne = l.aZ([], U, Y);
              l.aY(ne, ne);
              const ie = l.aZ([], C[2], C[1]);
              l.aY(ie, ie);
              const ae = l.aZ([], C[0], C[3]);
              l.aY(ae, ae), z.push(l.aU([], U, T)), e.y >= (1 << e.z) / 2 && z.push(l.aU([], Xi(l.a3 / 2, 0, e.x, e.y, e.z), T)), e.y < (1 << e.z) / 2 && z.push(l.aU([], Xi(l.a3 / 2, l.a3, e.x, e.y, e.z), T));
              const me = Vh(U, z),
                ke = Vh(ne, z),
                _e = [-U[0], -U[1], -U[2], me.max],
                Te = [U[0], U[1], U[2], -me.min],
                Ee = [-ne[0], -ne[1], -ne[2], ke.max],
                ye = [ne[0], ne[1], ne[2], -ke.min],
                Be = [...ie, 0],
                ht = [...ae, 0],
                at = [];
              return e.y === 0 ? at.push(l.bw(ht, Be, _e), l.bw(ht, Be, Te)) : at.push(l.bw(Ee, Be, _e), l.bw(Ee, Be, Te), l.bw(Ee, ht, _e), l.bw(Ee, ht, Te)), e.y === (1 << e.z) - 1 ? at.push(l.bw(ht, Be, _e), l.bw(ht, Be, Te)) : at.push(l.bw(ye, Be, _e), l.bw(ye, Be, Te), l.bw(ye, ht, _e), l.bw(ye, ht, Te)), new Uo(at, [_e, Te, Ee, ye, Be, ht], F, R)
            }
          }
        }

        function Vh(p, e) {
          let a = 1 / 0,
            c = -1 / 0;
          for (const h of e) {
            const f = l.a_(p, h);
            a = Math.min(a, f), c = Math.max(c, f)
          }
          return {
            min: a,
            max: c
          }
        }
        class Il {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, a) {
            this._helper.resize(e, a)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e) {}
          constructor(e) {
            this._cachedClippingPlane = l.by(), this._projectionMatrix = l.bc(), this._globeViewProjMatrix32f = l.bb(), this._globeViewProjMatrixNoCorrection = l.bc(), this._globeViewProjMatrixNoCorrectionInverted = l.bc(), this._globeProjMatrixInverted = l.bc(), this._cameraPosition = l.bs(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (a, c) => {
              const h = l.ai(a.lat, -l.aj, l.aj),
                f = l.ai(+c, this.minZoom + On(0, h), this.maxZoom);
              return {
                center: new l.U(a.lng, h),
                zoom: f
              }
            }, this._helper = new kn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (a, c) => this.defaultConstrain(a, c)
            }, e), this._coveringTilesDetailsProvider = new Up
          }
          clone() {
            const e = new Il;
            return e.apply(this), e
          }
          apply(e, a) {
            this._globeLatitudeErrorCorrectionRadians = a || 0, this._helper.apply(e)
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted
          }
          get cameraPosition() {
            const e = l.bs();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          getProjectionData(e) {
            const {
              overscaledTileID: a,
              applyGlobeMatrix: c
            } = e, h = this._helper.getMercatorTileCoordinates(a);
            return {
              mainMatrix: this._globeViewProjMatrix32f,
              tileMercatorCoords: h,
              clippingPlane: this._cachedClippingPlane,
              projectionTransition: c ? 1 : 0,
              fallbackMatrix: this._globeViewProjMatrix32f
            }
          }
          _computeClippingPlane(e) {
            const a = this.pitchInRadians,
              c = this.cameraToCenterDistance / e,
              h = Math.sin(a) * c,
              f = Math.cos(a) * c + 1,
              v = 1 / Math.sqrt(h * h + f * f) * 1;
            let w = -h,
              T = f;
            const C = Math.sqrt(w * w + T * T);
            w /= C, T /= C;
            const z = [0, w, T];
            l.bz(z, z, [0, 0, 0], -this.bearingInRadians), l.bA(z, z, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), l.bB(z, z, [0, 0, 0], this.center.lng * Math.PI / 180);
            const F = 1 / l.b0(z);
            return l.aU(z, z, F), [...z, -v * F]
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(ai(e))
          }
          transformLightDirection(e) {
            const a = this._helper._center.lng * Math.PI / 180,
              c = this._helper._center.lat * Math.PI / 180,
              h = Math.cos(c),
              f = [Math.sin(a) * h, Math.sin(c), Math.cos(a) * h],
              v = [f[2], 0, -f[0]],
              w = [0, 0, 0];
            l.aZ(w, v, f), l.aY(v, v), l.aY(w, w);
            const T = [0, 0, 0];
            return l.aY(T, [v[0] * e[0] + w[0] * e[1] + f[0] * e[2], v[1] * e[0] + w[1] * e[1] + f[1] * e[2], v[2] * e[0] + w[2] * e[1] + f[2] * e[2]]), T
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getPitchedTextCorrection(e, a, c) {
            const h = (function(w, T, C) {
                const z = 1 / (1 << C.z);
                return new l.a5(w / l.a3 * z + C.x * z, T / l.a3 * z + C.y * z)
              })(e, a, c.canonical),
              f = (v = h.y, [l.br(h.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - v * Math.PI * 2)) - .5 * Math.PI]);
            var v;
            return this.getCircleRadiusCorrection() / Math.cos(f[1])
          }
          projectTileCoordinates(e, a, c, h) {
            const f = c.canonical,
              v = Xi(e, a, f.x, f.y, f.z),
              w = 1 + (h ? h(e, a) : 0) / l.bx,
              T = [v[0] * w, v[1] * w, v[2] * w, 1];
            l.aA(T, T, this._globeViewProjMatrixNoCorrection);
            const C = this._cachedClippingPlane,
              z = C[0] * v[0] + C[1] * v[1] + C[2] * v[2] + C[3] < 0;
            return {
              point: new l.P(T[0] / T[3], T[1] / T[3]),
              signedDistanceFromCamera: T[3],
              isOccluded: z
            }
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = ca(this.worldSize, this.center.lat),
              a = l.bd(),
              c = l.bd();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), l.b7(a, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const h = this.centerOffset;
            a[8] = 2 * -h.x / this._helper._width, a[9] = 2 * h.y / this._helper._height, this._projectionMatrix = l.b8(a), this._globeProjMatrixInverted = l.bd(), l.au(this._globeProjMatrixInverted, a), l.N(a, a, [0, 0, -this.cameraToCenterDistance]), l.b9(a, a, this.rollInRadians), l.ba(a, a, -this.pitchInRadians), l.b9(a, a, this.bearingInRadians), l.N(a, a, [0, 0, -e]);
            const f = l.bs();
            f[0] = e, f[1] = e, f[2] = e, l.ba(c, a, this.center.lat * Math.PI / 180), l.bC(c, c, -this.center.lng * Math.PI / 180), l.O(c, c, f), this._globeViewProjMatrixNoCorrection = c, l.ba(a, a, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), l.bC(a, a, -this.center.lng * Math.PI / 180), l.O(a, a, f), this._globeViewProjMatrix32f = new Float32Array(a), this._globeViewProjMatrixNoCorrectionInverted = l.bd(), l.au(this._globeViewProjMatrixNoCorrectionInverted, c);
            const v = l.bs();
            this._cameraPosition = l.bs(), this._cameraPosition[2] = this.cameraToCenterDistance / e, l.bz(this._cameraPosition, this._cameraPosition, v, -this.rollInRadians), l.bA(this._cameraPosition, this._cameraPosition, v, this.pitchInRadians), l.bz(this._cameraPosition, this._cameraPosition, v, -this.bearingInRadians), l.aV(this._cameraPosition, this._cameraPosition, [0, 0, 1]), l.bA(this._cameraPosition, this._cameraPosition, v, -this.center.lat * Math.PI / 180), l.bB(this._cameraPosition, this._cameraPosition, v, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const w = l.b8(this._globeViewProjMatrixNoCorrectionInverted);
            l.O(w, w, [1, 1, -1]), this._cachedFrustum = bi.fromInvProjectionMatrix(w, 1, 0, this._cachedClippingPlane, !0)
          }
          calculateFogMatrix(e) {
            l.w("calculateFogMatrix is not supported on globe projection.");
            const a = l.bd();
            return l.am(a), a
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new l.b5(0, e)]
          }
          getCameraFrustum() {
            return this._cachedFrustum
          }
          getClippingPlane() {
            return this._cachedClippingPlane
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            e && l.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0)
          }
          maxPitchScaleFactor() {
            return 1
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, a) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const c = ai(e);
            l.aU(c, c, 1 + a / l.bx);
            const h = l.by();
            return l.aA(h, [c[0], c[1], c[2], 1], this._globeViewProjMatrixNoCorrection), h[2] / h[3]
          }
          populateCache(e) {}
          getBounds() {
            const e = .5 * this.width,
              a = .5 * this.height,
              c = [new l.P(0, 0), new l.P(e, 0), new l.P(this.width, 0), new l.P(this.width, a), new l.P(this.width, this.height), new l.P(e, this.height), new l.P(0, this.height), new l.P(0, a)],
              h = [];
            for (const F of c) h.push(this.unprojectScreenPoint(F));
            let f = 0,
              v = 0,
              w = 0,
              T = 0;
            const C = this.center;
            for (const F of h) {
              const R = l.bD(C.lng, F.lng),
                U = l.bD(C.lat, F.lat);
              R < v && (v = R), R > f && (f = R), U < T && (T = U), U > w && (w = U)
            }
            const z = [C.lng + v, C.lat + T, C.lng + f, C.lat + w];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (z[3] = 90, z[0] = -180, z[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (z[1] = -90, z[0] = -180, z[2] = 180), new yt(z)
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, h) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, h)
          }
          setLocationAtPoint(e, a) {
            const c = ai(this.unprojectScreenPoint(a)),
              h = ai(e),
              f = l.bs();
            l.bE(f);
            const v = l.bs();
            l.bB(v, c, f, -this.center.lng * Math.PI / 180), l.bA(v, v, f, this.center.lat * Math.PI / 180);
            const w = h[0] * h[0] + h[2] * h[2],
              T = v[0] * v[0];
            if (w < T) return;
            const C = Math.sqrt(w - T),
              z = -C,
              F = l.bF(h[0], h[2], v[0], C),
              R = l.bF(h[0], h[2], v[0], z),
              U = l.bs();
            l.bB(U, h, f, -F);
            const Y = l.bF(U[1], U[2], v[1], v[2]),
              ne = l.bs();
            l.bB(ne, h, f, -R);
            const ie = l.bF(ne[1], ne[2], v[1], v[2]),
              ae = .5 * Math.PI,
              me = Y >= -ae && Y <= ae,
              ke = ie >= -ae && ie <= ae;
            let _e, Te;
            if (me && ke) {
              const ht = this.center.lng * Math.PI / 180,
                at = this.center.lat * Math.PI / 180;
              l.bG(F, ht) + l.bG(Y, at) < l.bG(R, ht) + l.bG(ie, at) ? (_e = F, Te = Y) : (_e = R, Te = ie)
            } else if (me) _e = F, Te = Y;
            else {
              if (!ke) return;
              _e = R, Te = ie
            }
            const Ee = _e / Math.PI * 180,
              ye = Te / Math.PI * 180,
              Be = this.center.lat;
            this.setCenter(new l.U(Ee, l.ai(ye, -90, 90))), this.setZoom(this.zoom + On(Be, this.center.lat))
          }
          locationToScreenPoint(e, a) {
            const c = ai(e);
            if (a) {
              const h = a.getElevationForLngLatZoom(e, this._helper._tileZoom);
              l.aU(c, c, 1 + h / l.bx)
            }
            return this._projectSurfacePointToScreen(c)
          }
          _projectSurfacePointToScreen(e) {
            const a = l.by();
            return l.aA(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], new l.P((.5 * a[0] + .5) * this.width, (.5 * -a[1] + .5) * this.height)
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const c = a.pointCoordinate(e);
              if (c) return c
            }
            return l.a5.fromLngLat(this.unprojectScreenPoint(e))
          }
          screenPointToLocation(e, a) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, a)) === null || c === void 0 ? void 0 : c.toLngLat()
          }
          isPointOnMapSurface(e, a) {
            const c = this._cameraPosition,
              h = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(c, h)
          }
          getRayDirectionFromPixel(e) {
            const a = l.by();
            a[0] = e.x / this.width * 2 - 1, a[1] = -1 * (e.y / this.height * 2 - 1), a[2] = 1, a[3] = 1, l.aA(a, a, this._globeViewProjMatrixNoCorrectionInverted), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3];
            const c = l.bs();
            c[0] = a[0] - this._cameraPosition[0], c[1] = a[1] - this._cameraPosition[1], c[2] = a[2] - this._cameraPosition[2];
            const h = l.bs();
            return l.aY(h, c), h
          }
          isSurfacePointVisible(e) {
            const a = this._cachedClippingPlane;
            return a[0] * e[0] + a[1] * e[1] + a[2] * e[2] + a[3] >= 0
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const a = l.by();
            return l.aA(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3], a[0] > -1 && a[0] < 1 && a[1] > -1 && a[1] < 1 && a[2] > -1 && a[2] < 1
          }
          rayPlanetIntersection(e, a) {
            const c = l.a_(e, a),
              h = l.bs(),
              f = l.bs();
            l.aU(f, a, c), l.aX(h, e, f);
            const v = 1 - l.a_(h, h);
            if (v < 0) return null;
            const w = l.a_(e, e) - 1,
              T = -c + (c < 0 ? 1 : -1) * Math.sqrt(v),
              C = w / T,
              z = T;
            return {
              tMin: Math.min(C, z),
              tMax: Math.max(C, z)
            }
          }
          unprojectScreenPoint(e) {
            const a = this._cameraPosition,
              c = this.getRayDirectionFromPixel(e),
              h = this.rayPlanetIntersection(a, c);
            if (h) {
              const z = l.bs();
              l.aV(z, a, [c[0] * h.tMin, c[1] * h.tMin, c[2] * h.tMin]);
              const F = l.bs();
              return l.aY(F, z), lo(F)
            }
            const f = this._cachedClippingPlane,
              v = f[0] * c[0] + f[1] * c[1] + f[2] * c[2],
              w = -l.b4(f, a) / v,
              T = l.bs();
            if (w > 0) l.aV(T, a, [c[0] * w, c[1] * w, c[2] * w]);
            else {
              const z = l.bs();
              l.aV(z, a, [2 * c[0], 2 * c[1], 2 * c[2]]);
              const F = l.b4(this._cachedClippingPlane, z);
              l.aX(T, z, [this._cachedClippingPlane[0] * F, this._cachedClippingPlane[1] * F, this._cachedClippingPlane[2] * F])
            }
            const C = (function(z) {
              const F = l.bs();
              return F[0] = z[0] * -z[3], F[1] = z[1] * -z[3], F[2] = z[2] * -z[3], {
                center: F,
                radius: Math.sqrt(1 - z[3] * z[3])
              }
            })(f);
            return lo((function(z, F, R) {
              const U = l.bs();
              l.aX(U, R, z);
              const Y = l.bs();
              return l.bt(Y, z, U, F / l.b2(U)), Y
            })(C.center, C.radius, T))
          }
          getMatrixForModel(e, a) {
            const c = l.U.convert(e),
              h = 1 / l.bx,
              f = l.bc();
            return l.bC(f, f, c.lng / 180 * Math.PI), l.ba(f, f, -c.lat / 180 * Math.PI), l.N(f, f, [0, 0, 1 + a / l.bx]), l.ba(f, f, .5 * Math.PI), l.O(f, f, [h, h, h]), f
          }
          getProjectionDataForCustomLayer(e = !0) {
            const a = this.getProjectionData({
              overscaledTileID: new l.a0(0, 0, 0, 0, 0),
              applyGlobeMatrix: e
            });
            return a.tileMercatorCoords = [0, 0, 1, 1], a
          }
          getFastPathSimpleProjectionMatrix(e) {}
        }
        class Cl {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, a, c = !0) {
            this._helper.resize(e, a, c)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          get isGlobeRendering() {
            return this._globeness > 0
          }
          setTransitionState(e, a) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = a, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
          }
          constructor(e) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (a, c) => this.currentTransform.defaultConstrain(a, c), this._helper = new kn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (a, c) => this.defaultConstrain(a, c)
            }, e), this._globeness = 1, this._mercatorTransform = new Nn, this._verticalPerspectiveTransform = new Il
          }
          clone() {
            const e = new Cl;
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition
          }
          getProjectionData(e) {
            const a = this._mercatorTransform.getProjectionData(e),
              c = this._verticalPerspectiveTransform.getProjectionData(e);
            return {
              mainMatrix: this.isGlobeRendering ? c.mainMatrix : a.mainMatrix,
              clippingPlane: c.clippingPlane,
              tileMercatorCoords: c.tileMercatorCoords,
              projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
              fallbackMatrix: a.fallbackMatrix
            }
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e)
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e)
          }
          getPixelScale() {
            return l.bn(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
          }
          getCircleRadiusCorrection() {
            return l.bn(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
          }
          getPitchedTextCorrection(e, a, c) {
            const h = this._mercatorTransform.getPitchedTextCorrection(e, a, c),
              f = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, a, c);
            return l.bn(h, f, this._globeness)
          }
          projectTileCoordinates(e, a, c, h) {
            return this.currentTransform.projectTileCoordinates(e, a, c, h)
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ)
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e)
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e)
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum()
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane()
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider()
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor()
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, a) {
            return this.currentTransform.lngLatToCameraDepth(e, a)
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e)
          }
          getBounds() {
            return this.currentTransform.getBounds()
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, h) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, h)
          }
          setLocationAtPoint(e, a) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, a), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, a), this.apply(this._verticalPerspectiveTransform)
          }
          locationToScreenPoint(e, a) {
            return this.currentTransform.locationToScreenPoint(e, a)
          }
          screenPointToMercatorCoordinate(e, a) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, a)
          }
          screenPointToLocation(e, a) {
            return this.currentTransform.screenPointToLocation(e, a)
          }
          isPointOnMapSurface(e, a) {
            return this.currentTransform.isPointOnMapSurface(e, a)
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
          }
          getMatrixForModel(e, a) {
            return this.currentTransform.getMatrixForModel(e, a)
          }
          getProjectionDataForCustomLayer(e = !0) {
            const a = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return a;
            const c = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return c.fallbackMatrix = a.mainMatrix, c
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
          }
        }
        class Va {
          get useGlobeControls() {
            return !0
          }
          handlePanInertia(e, a) {
            const c = xs(e, a);
            return Math.abs(c.lng - a.center.lng) > 180 && (c.lng = a.center.lng + 179.5 * Math.sign(c.lng - a.center.lng)), {
              easingCenter: c,
              easingOffset: new l.P(0, 0)
            }
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            const c = e.around,
              h = a.screenPointToLocation(c);
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta);
            const f = a.zoom;
            e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta);
            const v = a.zoom - f;
            if (v === 0) return;
            const w = l.bD(a.center.lng, h.lng),
              T = w / (Math.abs(w / 180) + 1),
              C = l.bD(a.center.lat, h.lat),
              z = a.getRayDirectionFromPixel(c),
              F = a.cameraPosition,
              R = -1 * l.a_(F, z),
              U = l.bs();
            l.aV(U, F, [z[0] * R, z[1] * R, z[2] * R]);
            const Y = l.b0(U) - 1,
              ne = Math.exp(.5 * -Math.max(Y - .3, 0)),
              ie = ca(a.worldSize, a.center.lat) / Math.min(a.width, a.height),
              ae = l.bq(ie, .9, .5, 1, .25),
              me = (1 - l.al(-v)) * Math.min(ne, ae),
              ke = a.center.lat,
              _e = a.zoom,
              Te = new l.U(a.center.lng + T * me, l.ai(a.center.lat + C * me, -l.aj, l.aj));
            a.setLocationAtPoint(h, c);
            const Ee = a.center,
              ye = l.bq(Math.abs(w), 45, 85, 0, 1),
              Be = l.bq(ie, .75, .35, 0, 1),
              ht = Math.pow(Math.max(ye, Be), .25),
              at = l.bD(Ee.lng, Te.lng),
              lt = l.bD(Ee.lat, Te.lat);
            a.setCenter(new l.U(Ee.lng + at * ht, Ee.lat + lt * ht).wrap()), a.setZoom(_e + On(ke, a.center.lat))
          }
          handleMapControlsPan(e, a, c) {
            if (!e.panDelta) return;
            const h = a.center.lat,
              f = a.zoom;
            a.setCenter(xs(e.panDelta, a).wrap()), a.setZoom(f + On(h, a.center.lat))
          }
          cameraForBoxAndBearing(e, a, c, h, f) {
            const v = Vn(e, a, c, h, f),
              w = a.left / f.width * 2 - 1,
              T = (f.width - a.right) / f.width * 2 - 1,
              C = a.top / f.height * -2 + 1,
              z = (f.height - a.bottom) / f.height * -2 + 1,
              F = l.bD(c.getWest(), c.getEast()) < 0,
              R = F ? c.getEast() : c.getWest(),
              U = F ? c.getWest() : c.getEast(),
              Y = Math.max(c.getNorth(), c.getSouth()),
              ne = Math.min(c.getNorth(), c.getSouth()),
              ie = R + .5 * l.bD(R, U),
              ae = Y + .5 * l.bD(Y, ne),
              me = f.clone();
            me.setCenter(v.center), me.setBearing(v.bearing), me.setPitch(0), me.setRoll(0), me.setZoom(v.zoom);
            const ke = me.modelViewProjectionMatrix,
              _e = [ai(c.getNorthWest()), ai(c.getNorthEast()), ai(c.getSouthWest()), ai(c.getSouthEast()), ai(new l.U(U, ae)), ai(new l.U(R, ae)), ai(new l.U(ie, Y)), ai(new l.U(ie, ne))],
              Te = ai(v.center);
            let Ee = Number.POSITIVE_INFINITY;
            for (const ye of _e) w < 0 && (Ee = Va.getLesserNonNegativeNonNull(Ee, Va.solveVectorScale(ye, Te, ke, "x", w))), T > 0 && (Ee = Va.getLesserNonNegativeNonNull(Ee, Va.solveVectorScale(ye, Te, ke, "x", T))), C > 0 && (Ee = Va.getLesserNonNegativeNonNull(Ee, Va.solveVectorScale(ye, Te, ke, "y", C))), z < 0 && (Ee = Va.getLesserNonNegativeNonNull(Ee, Va.solveVectorScale(ye, Te, ke, "y", z)));
            if (Number.isFinite(Ee) && Ee !== 0) return v.zoom = me.zoom + l.ao(Ee), v;
            fn()
          }
          handleJumpToCenterZoom(e, a) {
            const c = e.center.lat,
              h = e.constrain(a.center ? l.U.convert(a.center) : e.center, e.zoom).center;
            e.setCenter(h.wrap());
            const f = a.zoom !== void 0 ? +a.zoom : e.zoom + On(c, h.lat);
            e.zoom !== f && e.setZoom(f)
          }
          handleEaseTo(e, a) {
            const c = e.zoom,
              h = e.center,
              f = e.padding,
              v = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              w = {
                roll: a.roll === void 0 ? e.roll : a.roll,
                pitch: a.pitch === void 0 ? e.pitch : a.pitch,
                bearing: a.bearing === void 0 ? e.bearing : a.bearing
              },
              T = a.zoom !== void 0,
              C = !e.isPaddingEqual(a.padding);
            let z = !1;
            const F = a.center ? l.U.convert(a.center) : h,
              R = e.constrain(F, c).center;
            sn(e, R);
            const U = e.clone();
            U.setCenter(R), U.setZoom(T ? +a.zoom : c + On(h.lat, F.lat)), U.setBearing(a.bearing);
            const Y = new l.P(l.ai(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), l.ai(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            U.setLocationAtPoint(R, Y);
            const ne = (a.offset && a.offsetAsPoint.mag()) > 0 ? U.center : R,
              ie = T ? +a.zoom : c + On(h.lat, ne.lat),
              ae = c + On(h.lat, 0),
              me = ie + On(ne.lat, 0),
              ke = l.bD(h.lng, ne.lng),
              _e = l.bD(h.lat, ne.lat),
              Te = l.al(me - ae);
            return z = ie !== c, {
              easeFunc: Ee => {
                if (l.bh(v, w) || _n({
                    startEulerAngles: v,
                    endEulerAngles: w,
                    tr: e,
                    k: Ee,
                    useSlerp: v.roll != w.roll
                  }), C && e.interpolatePadding(f, a.padding, Ee), a.around) l.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(a.around, a.aroundPoint);
                else {
                  const ye = me > ae ? Math.min(2, Te) : Math.max(.5, Te),
                    Be = Math.pow(ye, 1 - Ee),
                    ht = uo(h, ke, _e, Ee * Be);
                  e.setCenter(ht.wrap())
                }
                if (z) {
                  const ye = l.F.number(ae, me, Ee) + On(0, e.center.lat);
                  e.setZoom(ye)
                }
              },
              isZooming: z,
              elevationCenter: ne
            }
          }
          handleFlyTo(e, a) {
            const c = a.zoom !== void 0,
              h = e.center,
              f = e.zoom,
              v = e.padding,
              w = !e.isPaddingEqual(a.padding),
              T = e.constrain(l.U.convert(a.center || a.locationAtOffset), f).center,
              C = c ? +a.zoom : e.zoom + On(e.center.lat, T.lat),
              z = e.clone();
            z.setCenter(T), z.setZoom(C), z.setBearing(a.bearing);
            const F = new l.P(l.ai(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), l.ai(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            z.setLocationAtPoint(T, F);
            const R = z.center;
            sn(e, R);
            const U = (function(_e, Te, Ee) {
                const ye = ai(Te),
                  Be = ai(Ee),
                  ht = l.a_(ye, Be),
                  at = Math.acos(ht),
                  lt = ui(_e);
                return at / (2 * Math.PI) * lt
              })(e, h, R),
              Y = f + On(h.lat, 0),
              ne = C + On(R.lat, 0),
              ie = l.al(ne - Y);
            let ae;
            if (typeof a.minZoom == "number") {
              const _e = +a.minZoom + On(R.lat, 0),
                Te = Math.min(_e, Y, ne) + On(0, R.lat),
                Ee = e.constrain(R, Te).zoom + On(R.lat, 0);
              ae = l.al(Ee - Y)
            }
            const me = l.bD(h.lng, R.lng),
              ke = l.bD(h.lat, R.lat);
            return {
              easeFunc: (_e, Te, Ee, ye) => {
                const Be = uo(h, me, ke, Ee);
                w && e.interpolatePadding(v, a.padding, _e);
                const ht = _e === 1 ? R : Be;
                e.setCenter(ht.wrap());
                const at = Y + l.ao(Te);
                e.setZoom(_e === 1 ? C : at + On(0, ht.lat))
              },
              scaleOfZoom: ie,
              targetCenter: R,
              scaleOfMinZoom: ae,
              pixelPathLength: U
            }
          }
          static solveVectorScale(e, a, c, h, f) {
            const v = h === "x" ? [c[0], c[4], c[8], c[12]] : [c[1], c[5], c[9], c[13]],
              w = [c[3], c[7], c[11], c[15]],
              T = e[0] * v[0] + e[1] * v[1] + e[2] * v[2],
              C = e[0] * w[0] + e[1] * w[1] + e[2] * w[2],
              z = a[0] * v[0] + a[1] * v[1] + a[2] * v[2],
              F = a[0] * w[0] + a[1] * w[1] + a[2] * w[2];
            return z + f * C === T + f * F || w[3] * (T - z) + v[3] * (F - C) + T * F == z * C ? null : (z + v[3] - f * F - f * w[3]) / (z - T - f * F + f * C)
          }
          static getLesserNonNegativeNonNull(e, a) {
            return a !== null && a >= 0 && a < e ? a : e
          }
        }
        class Zs {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new ci, this._verticalPerspectiveCameraHelper = new Va
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
          }
          handlePanInertia(e, a) {
            return this.currentHelper.handlePanInertia(e, a)
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, a)
          }
          handleMapControlsPan(e, a, c) {
            this.currentHelper.handleMapControlsPan(e, a, c)
          }
          cameraForBoxAndBearing(e, a, c, h, f) {
            return this.currentHelper.cameraForBoxAndBearing(e, a, c, h, f)
          }
          handleJumpToCenterZoom(e, a) {
            this.currentHelper.handleJumpToCenterZoom(e, a)
          }
          handleEaseTo(e, a) {
            return this.currentHelper.handleEaseTo(e, a)
          }
          handleFlyTo(e, a) {
            return this.currentHelper.handleFlyTo(e, a)
          }
        }
        const bs = (p, e) => l.z(p, e && e.filter((a => a.identifier !== "source.canvas"))),
          Al = l.bH();
        class Gs extends l.E {
          constructor(e, a = {}) {
            var c, h;
            super(), this._rtlPluginLoaded = () => {
              for (const v in this.tileManagers) {
                const w = this.tileManagers[v].getSource().type;
                w !== "vector" && w !== "geojson" || this.tileManagers[v].reload()
              }
            }, this.map = e, this.dispatcher = new He(it(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((v, w) => this.getGlyphs(v, w))), this.dispatcher.registerMessageHandler("GI", ((v, w) => this.getImages(v, w))), this.dispatcher.registerMessageHandler("GDA", ((v, w) => this.getDashes(v, w))), this.imageManager = new Oe, this.imageManager.setEventedParent(this);
            const f = ((c = e._container) === null || c === void 0 ? void 0 : c.lang) || typeof document < "u" && ((h = document.documentElement) === null || h === void 0 ? void 0 : h.lang) || void 0;
            this.glyphManager = new Ft(e._requestManager, a.localIdeographFontFamily, f), this.lineAtlas = new $t(256, 512), this.crossTileSymbolIndex = new Zt, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new l.bI, this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", l.bJ()), q().on(Xt, this._rtlPluginLoaded), this.on("data", (v => {
              if (v.dataType !== "source" || v.sourceDataType !== "metadata") return;
              const w = this.tileManagers[v.sourceId];
              if (!w) return;
              const T = w.getSource();
              if (T && T.vectorLayerIds)
                for (const C in this._layers) {
                  const z = this._layers[C];
                  z.source === T.id && this._validateLayer(z)
                }
            }))
          }
          setGlobalStateProperty(e, a) {
            var c, h, f;
            this._checkLoaded();
            const v = a === null ? (f = (h = (c = this.stylesheet.state) === null || c === void 0 ? void 0 : c[e]) === null || h === void 0 ? void 0 : h.default) !== null && f !== void 0 ? f : null : a;
            if (l.bK(v, this._globalState[e])) return this;
            this._globalState[e] = v, this._applyGlobalStateChanges([e])
          }
          getGlobalState() {
            return this._globalState
          }
          setGlobalState(e) {
            this._checkLoaded();
            const a = [];
            for (const c in e) !l.bK(this._globalState[c], e[c].default) && (a.push(c), this._globalState[c] = e[c].default);
            this._applyGlobalStateChanges(a)
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const a = new Set,
              c = {};
            for (const h of e) {
              c[h] = this._globalState[h];
              for (const f in this._layers) {
                const v = this._layers[f],
                  w = v.getLayoutAffectingGlobalStateRefs(),
                  T = v.getPaintAffectingGlobalStateRefs();
                if (w.has(h) && a.add(v.source), T.has(h))
                  for (const {
                      name: C,
                      value: z
                    }
                    of T.get(h)) this._updatePaintProperty(v, C, z)
              }
            }
            this.dispatcher.broadcast("UGS", c);
            for (const h in this.tileManagers) a.has(h) && (this._reloadSource(h), this._changed = !0)
          }
          loadURL(e, a = {}, c) {
            this.fire(new l.l("dataloading", {
              dataType: "style"
            })), a.validate = typeof a.validate != "boolean" || a.validate;
            const h = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController;
            const f = this._loadStyleRequest;
            l.j(h, this._loadStyleRequest).then((v => {
              this._loadStyleRequest = null, this._load(v.data, a, c)
            })).catch((v => {
              this._loadStyleRequest = null, v && !f.signal.aborted && this.fire(new l.k(v))
            }))
          }
          loadJSON(e, a = {}, c) {
            this.fire(new l.l("dataloading", {
              dataType: "style"
            })), this._frameRequest = new AbortController, ce.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, a.validate = a.validate !== !1, this._load(e, a, c)
            })).catch((() => {}))
          }
          loadEmpty() {
            this.fire(new l.l("dataloading", {
              dataType: "style"
            })), this._load(Al, {
              validate: !1
            })
          }
          _load(e, a, c) {
            var h, f;
            let v = a.transformStyle ? a.transformStyle(c, e) : e;
            if (!a.validate || !bs(this, l.B(v))) {
              v = Object.assign({}, v), this._loaded = !0, this.stylesheet = v;
              for (const w in v.sources) this.addSource(w, v.sources[w], {
                validate: !1
              });
              v.sprite ? this._loadSprite(v.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(v.glyphs), this._createLayers(), this.light = new ct(this.stylesheet.light), this._setProjectionInternal(((h = this.stylesheet.projection) === null || h === void 0 ? void 0 : h.type) || "mercator"), this.sky = new ft(this.stylesheet.sky), this.map.setTerrain((f = this.stylesheet.terrain) !== null && f !== void 0 ? f : null), this.fire(new l.l("data", {
                dataType: "style"
              })), this.fire(new l.l("style.load"))
            }
          }
          _createLayers() {
            var e, a, c;
            const h = l.bL(this.stylesheet.layers);
            this.setGlobalState((e = this.stylesheet.state) !== null && e !== void 0 ? e : null), this.dispatcher.broadcast("SL", h), this._order = h.map((f => f.id)), this._layers = {}, this._serializedLayers = null;
            for (const f of h) {
              const v = l.bM(f, this._globalState);
              if (v.setEventedParent(this, {
                  layer: {
                    id: f.id
                  }
                }), this._layers[f.id] = v, l.bN(v) && this.tileManagers[v.source]) {
                const w = (c = (a = f.paint) === null || a === void 0 ? void 0 : a["raster-fade-duration"]) !== null && c !== void 0 ? c : v.paint.get("raster-fade-duration");
                this.tileManagers[v.source].setRasterFadeDuration(w)
              }
            }
          }
          _loadSprite(e, a = !1, c = void 0) {
            let h;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController, (function(f, v, w, T) {
              return l._(this, void 0, void 0, (function*() {
                const C = Me(f),
                  z = w > 1 ? "@2x" : "",
                  F = {},
                  R = {};
                for (const {
                    id: U,
                    url: Y
                  }
                  of C) {
                  const ne = v.transformRequest(Ye(Y, z, ".json"), "SpriteJSON");
                  F[U] = l.j(ne, T);
                  const ie = v.transformRequest(Ye(Y, z, ".png"), "SpriteImage");
                  R[U] = Ve.getImage(ie, T)
                }
                return yield Promise.all([...Object.values(F), ...Object.values(R)]), (function(U, Y) {
                  return l._(this, void 0, void 0, (function*() {
                    const ne = {};
                    for (const ie in U) {
                      ne[ie] = {};
                      const ae = ce.getImageCanvasContext((yield Y[ie]).data),
                        me = (yield U[ie]).data;
                      for (const ke in me) {
                        const {
                          width: _e,
                          height: Te,
                          x: Ee,
                          y: ye,
                          sdf: Be,
                          pixelRatio: ht,
                          stretchX: at,
                          stretchY: lt,
                          content: pt,
                          textFitWidth: ur,
                          textFitHeight: hr
                        } = me[ke];
                        ne[ie][ke] = {
                          data: null,
                          pixelRatio: ht,
                          sdf: Be,
                          stretchX: at,
                          stretchY: lt,
                          content: pt,
                          textFitWidth: ur,
                          textFitHeight: hr,
                          spriteData: {
                            width: _e,
                            height: Te,
                            x: Ee,
                            y: ye,
                            context: ae
                          }
                        }
                      }
                    }
                    return ne
                  }))
                })(F, R)
              }))
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((f => {
              if (this._spriteRequest = null, f)
                for (const v in f) {
                  this._spritesImagesIds[v] = [];
                  const w = this._spritesImagesIds[v] ? this._spritesImagesIds[v].filter((T => !(T in f))) : [];
                  for (const T of w) this.imageManager.removeImage(T), this._changedImages[T] = !0;
                  for (const T in f[v]) {
                    const C = v === "default" ? T : `${v}:${T}`;
                    this._spritesImagesIds[v].push(C), C in this.imageManager.images ? this.imageManager.updateImage(C, f[v][T], !1) : this.imageManager.addImage(C, f[v][T]), a && (this._changedImages[C] = !0)
                  }
                }
            })).catch((f => {
              this._spriteRequest = null, h = f, this.fire(new l.k(h))
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), a && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.l("data", {
                dataType: "style"
              })), c && c(h)
            }))
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.l("data", {
              dataType: "style"
            }))
          }
          _validateLayer(e) {
            const a = this.tileManagers[e.source];
            if (!a) return;
            const c = e.sourceLayer;
            if (!c) return;
            const h = a.getSource();
            (h.type === "geojson" || h.vectorLayerIds && h.vectorLayerIds.indexOf(c) === -1) && this.fire(new l.k(new Error(`Source layer "${c}" does not exist on source "${h.id}" as specified by style layer "${e.id}".`)))
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.tileManagers)
              if (!this.tileManagers[e].loaded()) return !1;
            return !!this.imageManager.isLoaded()
          }
          _serializeByIds(e, a = !1) {
            const c = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(a ? l.bO(c) : c);
            const h = [];
            for (const f of e)
              if (c[f]) {
                const v = a ? l.bO(c[f]) : c[f];
                h.push(v)
              } return h
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const a = Object.keys(this._layers);
            for (const c of a) {
              const h = this._layers[c];
              h.type !== "custom" && (e[c] = h.serialize())
            }
            return e
          }
          hasTransitions() {
            var e, a, c;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((a = this.sky) === null || a === void 0) && a.hasTransition() || !((c = this.projection) === null || c === void 0) && c.hasTransition()) return !0;
            for (const h in this.tileManagers)
              if (this.tileManagers[h].hasTransition()) return !0;
            for (const h in this._layers)
              if (this._layers[h].hasTransition()) return !0;
            return !1
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.")
          }
          update(e) {
            if (!this._loaded) return;
            const a = this._changed;
            if (a) {
              const h = Object.keys(this._updatedLayers),
                f = Object.keys(this._removedLayers);
              (h.length || f.length) && this._updateWorkerLayers(h, f);
              for (const v in this._updatedSources) {
                const w = this._updatedSources[v];
                if (w === "reload") this._reloadSource(v);
                else {
                  if (w !== "clear") throw new Error(`Invalid action ${w}`);
                  this._clearSource(v)
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const v in this._updatedPaintProps) this._layers[v].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates()
            }
            const c = {};
            for (const h in this.tileManagers) {
              const f = this.tileManagers[h];
              c[h] = f.used, f.used = !1
            }
            for (const h of this._order) {
              const f = this._layers[h];
              f.recalculate(e, this._availableImages), !f.isHidden(e.zoom) && f.source && (this.tileManagers[f.source].used = !0)
            }
            for (const h in c) {
              const f = this.tileManagers[h];
              !!c[h] != !!f.used && f.fire(new l.l("data", {
                sourceDataType: "visibility",
                dataType: "source",
                sourceId: h
              }))
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, a && this.fire(new l.l("data", {
              dataType: "style"
            }))
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const a in this.tileManagers) this.tileManagers[a].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {}
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.tileManagers) this.tileManagers[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1
            }
          }
          _updateWorkerLayers(e, a) {
            this.dispatcher.broadcast("UL", {
              layers: this._serializeByIds(e, !1),
              removedIds: a
            })
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1
          }
          setState(e, a = {}) {
            var c;
            this._checkLoaded();
            const h = this.serialize();
            if (e = a.transformStyle ? a.transformStyle(h, e) : e, ((c = a.validate) === null || c === void 0 || c) && bs(this, l.B(e))) return !1;
            (e = l.bO(e)).layers = l.bL(e.layers);
            const f = l.bP(h, e),
              v = this._getOperationsToPerform(f);
            if (v.unimplemented.length > 0) throw new Error(`Unimplemented: ${v.unimplemented.join(", ")}.`);
            if (v.operations.length === 0) return !1;
            for (const w of v.operations) w();
            return this.stylesheet = e, this._serializedLayers = null, !0
          }
          _getOperationsToPerform(e) {
            const a = [],
              c = [];
            for (const h of e) switch (h.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                a.push((() => this.addLayer.apply(this, h.args)));
                break;
              case "removeLayer":
                a.push((() => this.removeLayer.apply(this, h.args)));
                break;
              case "setPaintProperty":
                a.push((() => this.setPaintProperty.apply(this, h.args)));
                break;
              case "setLayoutProperty":
                a.push((() => this.setLayoutProperty.apply(this, h.args)));
                break;
              case "setFilter":
                a.push((() => this.setFilter.apply(this, h.args)));
                break;
              case "addSource":
                a.push((() => this.addSource.apply(this, h.args)));
                break;
              case "removeSource":
                a.push((() => this.removeSource.apply(this, h.args)));
                break;
              case "setLayerZoomRange":
                a.push((() => this.setLayerZoomRange.apply(this, h.args)));
                break;
              case "setLight":
                a.push((() => this.setLight.apply(this, h.args)));
                break;
              case "setGeoJSONSourceData":
                a.push((() => this.setGeoJSONSourceData.apply(this, h.args)));
                break;
              case "setGlyphs":
                a.push((() => this.setGlyphs.apply(this, h.args)));
                break;
              case "setSprite":
                a.push((() => this.setSprite.apply(this, h.args)));
                break;
              case "setTerrain":
                a.push((() => this.map.setTerrain.apply(this, h.args)));
                break;
              case "setSky":
                a.push((() => this.setSky.apply(this, h.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, h.args);
                break;
              case "setGlobalState":
                a.push((() => this.setGlobalState.apply(this, h.args)));
                break;
              case "setTransition":
                a.push((() => {}));
                break;
              default:
                c.push(h.command)
            }
            return {
              operations: a,
              unimplemented: c
            }
          }
          addImage(e, a) {
            if (this.getImage(e)) return this.fire(new l.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, a), this._afterImageUpdated(e)
          }
          updateImage(e, a) {
            this.imageManager.updateImage(e, a)
          }
          getImage(e) {
            return this.imageManager.getImage(e)
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new l.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e)
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.l("data", {
              dataType: "style"
            }))
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages()
          }
          addSource(e, a, c = {}) {
            if (this._checkLoaded(), this.tileManagers[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!a.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(a).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(a.type) >= 0 && this._validate(l.B.source, `sources.${e}`, a, null, c)) return;
            this.map && this.map._collectResourceTiming && (a.collectResourceTiming = !0);
            const h = this.tileManagers[e] = new Dt(e, a, this.dispatcher);
            h.style = this, h.setEventedParent(this, (() => ({
              isSourceLoaded: h.loaded(),
              source: h.serialize(),
              sourceId: e
            }))), h.onAdd(this.map), this._changed = !0
          }
          removeSource(e) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error("There is no source with this ID");
            for (const c in this._layers)
              if (this._layers[c].source === e) return this.fire(new l.k(new Error(`Source "${e}" cannot be removed while layer "${c}" is using it.`)));
            const a = this.tileManagers[e];
            delete this.tileManagers[e], delete this._updatedSources[e], a.fire(new l.l("data", {
              sourceDataType: "metadata",
              dataType: "source",
              sourceId: e
            })), a.setEventedParent(null), a.onRemove(this.map), this._changed = !0
          }
          setGeoJSONSourceData(e, a) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const c = this.tileManagers[e].getSource();
            if (c.type !== "geojson") throw new Error(`geojsonSource.type is ${c.type}, which is !== 'geojson`);
            c.setData(a), this._changed = !0
          }
          getSource(e) {
            return this.tileManagers[e] && this.tileManagers[e].getSource()
          }
          addLayer(e, a, c = {}) {
            this._checkLoaded();
            const h = e.id;
            if (this.getLayer(h)) return void this.fire(new l.k(new Error(`Layer "${h}" already exists on this map.`)));
            let f;
            if (e.type === "custom") {
              if (bs(this, l.bQ(e))) return;
              f = l.bM(e, this._globalState)
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(h, e.source), e = l.bO(e), e = l.e(e, {
                  source: h
                })), this._validate(l.B.layer, `layers.${h}`, e, {
                  arrayIndex: -1
                }, c)) return;
              f = l.bM(e, this._globalState), this._validateLayer(f), f.setEventedParent(this, {
                layer: {
                  id: h
                }
              })
            }
            const v = a ? this._order.indexOf(a) : this._order.length;
            if (a && v === -1) this.fire(new l.k(new Error(`Cannot add layer "${h}" before non-existing layer "${a}".`)));
            else {
              if (this._order.splice(v, 0, h), this._layerOrderChanged = !0, this._layers[h] = f, this._removedLayers[h] && f.source && f.type !== "custom") {
                const w = this._removedLayers[h];
                delete this._removedLayers[h], w.type !== f.type ? this._updatedSources[f.source] = "clear" : (this._updatedSources[f.source] = "reload", this.tileManagers[f.source].pause())
              }
              this._updateLayer(f), f.onAdd && f.onAdd(this.map)
            }
          }
          moveLayer(e, a) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new l.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === a) return;
            const c = this._order.indexOf(e);
            this._order.splice(c, 1);
            const h = a ? this._order.indexOf(a) : this._order.length;
            a && h === -1 ? this.fire(new l.k(new Error(`Cannot move layer "${e}" before non-existing layer "${a}".`))) : (this._order.splice(h, 0, e), this._layerOrderChanged = !0)
          }
          removeLayer(e) {
            this._checkLoaded();
            const a = this._layers[e];
            if (!a) return void this.fire(new l.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            a.setEventedParent(null);
            const c = this._order.indexOf(e);
            this._order.splice(c, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = a, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], a.onRemove && a.onRemove(this.map)
          }
          getLayer(e) {
            return this._layers[e]
          }
          getLayersOrder() {
            return [...this._order]
          }
          hasLayer(e) {
            return e in this._layers
          }
          setLayerZoomRange(e, a, c) {
            this._checkLoaded();
            const h = this.getLayer(e);
            h ? h.minzoom === a && h.maxzoom === c || (a != null && (h.minzoom = a), c != null && (h.maxzoom = c), this._updateLayer(h)) : this.fire(new l.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
          }
          setFilter(e, a, c = {}) {
            this._checkLoaded();
            const h = this.getLayer(e);
            if (h) {
              if (!l.bK(h.filter, a)) return a == null ? (h.setFilter(void 0), void this._updateLayer(h)) : void(this._validate(l.B.filter, `layers.${h.id}.filter`, a, null, c) || (h.setFilter(l.bO(a)), this._updateLayer(h)))
            } else this.fire(new l.k(new Error(`Cannot filter non-existing layer "${e}".`)))
          }
          getFilter(e) {
            return l.bO(this.getLayer(e).filter)
          }
          setLayoutProperty(e, a, c, h = {}) {
            this._checkLoaded();
            const f = this.getLayer(e);
            f ? l.bK(f.getLayoutProperty(a), c) || (f.setLayoutProperty(a, c, h), this._updateLayer(f)) : this.fire(new l.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getLayoutProperty(e, a) {
            const c = this.getLayer(e);
            if (c) return c.getLayoutProperty(a);
            this.fire(new l.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
          }
          setPaintProperty(e, a, c, h = {}) {
            this._checkLoaded();
            const f = this.getLayer(e);
            f ? l.bK(f.getPaintProperty(a), c) || this._updatePaintProperty(f, a, c, h) : this.fire(new l.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          _updatePaintProperty(e, a, c, h = {}) {
            e.setPaintProperty(a, c, h) && this._updateLayer(e), l.bN(e) && a === "raster-fade-duration" && this.tileManagers[e.source].setRasterFadeDuration(c), this._changed = !0, this._updatedPaintProps[e.id] = !0, this._serializedLayers = null
          }
          getPaintProperty(e, a) {
            return this.getLayer(e).getPaintProperty(a)
          }
          setFeatureState(e, a) {
            this._checkLoaded();
            const c = e.source,
              h = e.sourceLayer,
              f = this.tileManagers[c];
            if (f === void 0) return void this.fire(new l.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const v = f.getSource().type;
            v === "geojson" && h ? this.fire(new l.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : v !== "vector" || h ? (e.id === void 0 && this.fire(new l.k(new Error("The feature id parameter must be provided."))), f.setFeatureState(h, e.id, a)) : this.fire(new l.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          removeFeatureState(e, a) {
            this._checkLoaded();
            const c = e.source,
              h = this.tileManagers[c];
            if (h === void 0) return void this.fire(new l.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const f = h.getSource().type,
              v = f === "vector" ? e.sourceLayer : void 0;
            f !== "vector" || v ? a && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new l.k(new Error("A feature id is required to remove its specific state property."))) : h.removeFeatureState(v, e.id, a) : this.fire(new l.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          getFeatureState(e) {
            this._checkLoaded();
            const a = e.source,
              c = e.sourceLayer,
              h = this.tileManagers[a];
            if (h !== void 0) return h.getSource().type !== "vector" || c ? (e.id === void 0 && this.fire(new l.k(new Error("The feature id parameter must be provided."))), h.getFeatureState(c, e.id)) : void this.fire(new l.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new l.k(new Error(`The source '${a}' does not exist in the map's style.`)))
          }
          getTransition() {
            return l.e({
              duration: 300,
              delay: 0
            }, this.stylesheet && this.stylesheet.transition)
          }
          serialize() {
            if (!this._loaded) return;
            const e = l.bR(this.tileManagers, (f => f.serialize())),
              a = this._serializeByIds(this._order, !0),
              c = this.map.getTerrain() || void 0,
              h = this.stylesheet;
            return l.bS({
              version: h.version,
              name: h.name,
              metadata: h.metadata,
              light: h.light,
              sky: h.sky,
              center: h.center,
              zoom: h.zoom,
              bearing: h.bearing,
              pitch: h.pitch,
              sprite: h.sprite,
              glyphs: h.glyphs,
              transition: h.transition,
              projection: h.projection,
              sources: e,
              layers: a,
              terrain: c
            }, (f => f !== void 0))
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.tileManagers[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.tileManagers[e.source].pause()), this._serializedLayers = null, this._changed = !0
          }
          _flattenAndSortRenderedFeatures(e) {
            const a = v => this._layers[v].type === "fill-extrusion",
              c = {},
              h = [];
            for (let v = this._order.length - 1; v >= 0; v--) {
              const w = this._order[v];
              if (a(w)) {
                c[w] = v;
                for (const T of e) {
                  const C = T[w];
                  if (C)
                    for (const z of C) h.push(z)
                }
              }
            }
            h.sort(((v, w) => w.intersectionZ - v.intersectionZ));
            const f = [];
            for (let v = this._order.length - 1; v >= 0; v--) {
              const w = this._order[v];
              if (a(w))
                for (let T = h.length - 1; T >= 0; T--) {
                  const C = h[T].feature;
                  if (c[C.layer.id] < v) break;
                  f.push(C), h.pop()
                } else
                  for (const T of e) {
                    const C = T[w];
                    if (C)
                      for (const z of C) f.push(z.feature)
                  }
            }
            return f
          }
          queryRenderedFeatures(e, a, c) {
            a && a.filter && this._validate(l.B.filter, "queryRenderedFeatures.filter", a.filter, null, a);
            const h = {};
            if (a && a.layers) {
              if (!(Array.isArray(a.layers) || a.layers instanceof Set)) return this.fire(new l.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const C of a.layers) {
                const z = this._layers[C];
                if (!z) return this.fire(new l.k(new Error(`The layer '${C}' does not exist in the map's style and cannot be queried for features.`))), [];
                h[z.source] = !0
              }
            }
            const f = [];
            a.availableImages = this._availableImages;
            const v = this._serializedAllLayers(),
              w = a.layers instanceof Set ? a.layers : Array.isArray(a.layers) ? new Set(a.layers) : null,
              T = Object.assign(Object.assign({}, a), {
                layers: w,
                globalState: this._globalState
              });
            for (const C in this.tileManagers) a.layers && !h[C] || f.push(kt(this.tileManagers[C], this._layers, v, e, T, c, this.map.terrain ? (z, F, R) => this.map.terrain.getElevation(z, F, R) : void 0));
            return this.placement && f.push((function(C, z, F, R, U, Y, ne) {
              const ie = {},
                ae = Y.queryRenderedSymbols(R),
                me = [];
              for (const ke of Object.keys(ae).map(Number)) me.push(ne[ke]);
              me.sort(nr);
              for (const ke of me) {
                const _e = ke.featureIndex.lookupSymbolFeatures(ae[ke.bucketInstanceId], z, ke.bucketIndex, ke.sourceLayerIndex, {
                  filterSpec: U.filter,
                  globalState: U.globalState
                }, U.layers, U.availableImages, C);
                for (const Te in _e) {
                  const Ee = ie[Te] = ie[Te] || [],
                    ye = _e[Te];
                  ye.sort(((Be, ht) => {
                    const at = ke.featureSortOrder;
                    if (at) {
                      const lt = at.indexOf(Be.featureIndex);
                      return at.indexOf(ht.featureIndex) - lt
                    }
                    return ht.featureIndex - Be.featureIndex
                  }));
                  for (const Be of ye) Ee.push(Be)
                }
              }
              return (function(ke, _e, Te) {
                for (const Ee in ke)
                  for (const ye of ke[Ee]) It(ye, Te[_e[Ee].source]);
                return ke
              })(ie, C, F)
            })(this._layers, v, this.tileManagers, e, T, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(f)
          }
          querySourceFeatures(e, a) {
            a != null && a.filter && this._validate(l.B.filter, "querySourceFeatures.filter", a.filter, null, a);
            const c = this.tileManagers[e];
            return c ? (function(h, f) {
              const v = h.getRenderableIds().map((C => h.getTileByID(C))),
                w = [],
                T = {};
              for (let C = 0; C < v.length; C++) {
                const z = v[C],
                  F = z.tileID.canonical.key;
                T[F] || (T[F] = !0, z.querySourceFeatures(w, f))
              }
              return w
            })(c, a ? Object.assign(Object.assign({}, a), {
              globalState: this._globalState
            }) : {
              globalState: this._globalState
            }) : []
          }
          getLight() {
            return this.light.getLight()
          }
          setLight(e, a = {}) {
            this._checkLoaded();
            const c = this.light.getLight();
            let h = !1;
            for (const v in e)
              if (!l.bK(e[v], c[v])) {
                h = !0;
                break
              } if (!h) return;
            const f = {
              now: fe(),
              transition: l.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.light.setLight(e, a), this.light.updateTransitions(f)
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type)
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
          }
          setSky(e, a = {}) {
            this._checkLoaded();
            const c = this.getSky();
            let h = !1;
            if (!e && !c) return;
            if (e && !c) h = !0;
            else if (!e && c) h = !0;
            else
              for (const v in e)
                if (!l.bK(e[v], c[v])) {
                  h = !0;
                  break
                } if (!h) return;
            const f = {
              now: fe(),
              transition: l.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.stylesheet.sky = e, this.sky.setSky(e, a), this.sky.updateTransitions(f)
          }
          _setProjectionInternal(e) {
            const a = (function(c, h) {
              const f = {
                constrain: h
              };
              if (Array.isArray(c)) {
                const v = new ii({
                  type: c
                });
                return {
                  projection: v,
                  transform: new Cl(f),
                  cameraHelper: new Zs(v)
                }
              }
              switch (c) {
                case "mercator":
                  return {
                    projection: new mr, transform: new Nn(f), cameraHelper: new ci
                  };
                case "globe": {
                  const v = new ii({
                    type: ["interpolate", ["linear"],
                      ["zoom"], 11, "vertical-perspective", 12, "mercator"
                    ]
                  });
                  return {
                    projection: v,
                    transform: new Cl(f),
                    cameraHelper: new Zs(v)
                  }
                }
                case "vertical-perspective":
                  return {
                    projection: new to, transform: new Il(f), cameraHelper: new Va
                  };
                default:
                  return l.w(`Unknown projection name: ${c}. Falling back to mercator projection.`), {
                    projection: new mr,
                    transform: new Nn(f),
                    cameraHelper: new ci
                  }
              }
            })(e, this.map.transformConstrain);
            this.projection = a.projection, this.map.migrateProjection(a.transform, a.cameraHelper);
            for (const c in this.tileManagers) this.tileManagers[c].reload()
          }
          _validate(e, a, c, h, f = {}) {
            return (!f || f.validate !== !1) && bs(this, e.call(l.B, l.e({
              key: a,
              style: this.serialize(),
              value: c,
              styleSpec: l.t
            }, h)))
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), q().off(Xt, this._rtlPluginLoaded);
            for (const a in this._layers) this._layers[a].setEventedParent(null);
            for (const a in this.tileManagers) {
              const c = this.tileManagers[a];
              c.setEventedParent(null), c.onRemove(this.map)
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e)
          }
          _clearSource(e) {
            this.tileManagers[e].clearTiles()
          }
          _reloadSource(e) {
            this.tileManagers[e].resume(), this.tileManagers[e].reload()
          }
          _updateSources(e) {
            for (const a in this.tileManagers) this.tileManagers[a].update(e, this.map.terrain)
          }
          _generateCollisionBoxes() {
            for (const e in this.tileManagers) this._reloadSource(e)
          }
          _updatePlacement(e, a, c, h, f = !1) {
            let v = !1,
              w = !1;
            const T = {};
            for (const C of this._order) {
              const z = this._layers[C];
              if (z.type !== "symbol") continue;
              if (!T[z.source]) {
                const R = this.tileManagers[z.source];
                T[z.source] = R.getRenderableIds(!0).map((U => R.getTileByID(U))).sort(((U, Y) => Y.tileID.overscaledZ - U.tileID.overscaledZ || (U.tileID.isLessThan(Y.tileID) ? -1 : 1)))
              }
              const F = this.crossTileSymbolIndex.addLayer(z, T[z.source], e.center.lng);
              v = v || F
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((f = f || this._layerOrderChanged || c === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(fe(), e.zoom)) && (this.pauseablePlacement = new za(e, this.map.terrain, this._order, f, a, c, h, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, T), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(fe()), w = !0), v && this.pauseablePlacement.placement.setStale()), w || v)
              for (const C of this._order) {
                const z = this._layers[C];
                z.type === "symbol" && this.placement.updateLayerOpacities(z, T[z.source])
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(fe())
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.tileManagers) this.tileManagers[e].releaseSymbolFadeTiles()
          }
          getImages(e, a) {
            return l._(this, void 0, void 0, (function*() {
              const c = yield this.imageManager.getImages(a.icons);
              this._updateTilesForChangedImages();
              const h = this.tileManagers[a.source];
              return h && h.setDependencies(a.tileID.key, a.type, a.icons), c
            }))
          }
          getGlyphs(e, a) {
            return l._(this, void 0, void 0, (function*() {
              const c = yield this.glyphManager.getGlyphs(a.stacks), h = this.tileManagers[a.source];
              return h && h.setDependencies(a.tileID.key, a.type, [""]), c
            }))
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null
          }
          setGlyphs(e, a = {}) {
            this._checkLoaded(), e && this._validate(l.B.glyphs, "glyphs", e, null, a) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e))
          }
          getDashes(e, a) {
            return l._(this, void 0, void 0, (function*() {
              const c = {};
              for (const [h, f] of Object.entries(a.dashes)) c[h] = this.lineAtlas.getDash(f.dasharray, f.round);
              return c
            }))
          }
          addSprite(e, a, c = {}, h) {
            this._checkLoaded();
            const f = [{
                id: e,
                url: a
              }],
              v = [...Me(this.stylesheet.sprite), ...f];
            this._validate(l.B.sprite, "sprite", v, null, c) || (this.stylesheet.sprite = v, this._loadSprite(f, !0, h))
          }
          removeSprite(e) {
            this._checkLoaded();
            const a = Me(this.stylesheet.sprite);
            if (a.find((c => c.id === e))) {
              if (this._spritesImagesIds[e])
                for (const c of this._spritesImagesIds[e]) this.imageManager.removeImage(c), this._changedImages[c] = !0;
              a.splice(a.findIndex((c => c.id === e)), 1), this.stylesheet.sprite = a.length > 0 ? a : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.l("data", {
                dataType: "style"
              }))
            } else this.fire(new l.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
          }
          getSprite() {
            return Me(this.stylesheet.sprite)
          }
          setSprite(e, a = {}, c) {
            this._checkLoaded(), e && this._validate(l.B.sprite, "sprite", e, null, a) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, c) : (this._unloadSprite(), c && c(null)))
          }
        }
        var Zc = l.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }, {
          name: "a_texture_pos",
          type: "Int16",
          components: 2
        }]);
        class ro {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null
          }
          bind(e, a, c, h, f, v, w, T, C) {
            this.context = e;
            let z = this.boundPaintVertexBuffers.length !== h.length;
            for (let F = 0; !z && F < h.length; F++) this.boundPaintVertexBuffers[F] !== h[F] && (z = !0);
            !this.vao || this.boundProgram !== a || this.boundLayoutVertexBuffer !== c || z || this.boundIndexBuffer !== f || this.boundVertexOffset !== v || this.boundDynamicVertexBuffer !== w || this.boundDynamicVertexBuffer2 !== T || this.boundDynamicVertexBuffer3 !== C ? this.freshBind(a, c, h, f, v, w, T, C) : (e.bindVertexArray.set(this.vao), w && w.bind(), f && f.dynamicDraw && f.bind(), T && T.bind(), C && C.bind())
          }
          freshBind(e, a, c, h, f, v, w, T) {
            const C = e.numAttributes,
              z = this.context,
              F = z.gl;
            this.vao && this.destroy(), this.vao = z.createVertexArray(), z.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = a, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = h, this.boundVertexOffset = f, this.boundDynamicVertexBuffer = v, this.boundDynamicVertexBuffer2 = w, this.boundDynamicVertexBuffer3 = T, a.enableAttributes(F, e);
            for (const R of c) R.enableAttributes(F, e);
            v && v.enableAttributes(F, e), w && w.enableAttributes(F, e), T && T.enableAttributes(F, e), a.bind(), a.setVertexAttribPointers(F, e, f);
            for (const R of c) R.bind(), R.setVertexAttribPointers(F, e, f);
            v && (v.bind(), v.setVertexAttribPointers(F, e, f)), h && h.bind(), w && (w.bind(), w.setVertexAttribPointers(F, e, f)), T && (T.bind(), T.setVertexAttribPointers(F, e, f)), z.currentNumAttributes = C
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null)
          }
        }
        const Zp = (p, e, a, c, h) => ({
            u_texture: 0,
            u_ele_delta: p,
            u_fog_matrix: e,
            u_fog_color: a ? a.properties.get("fog-color") : l.bi.white,
            u_fog_ground_blend: a ? a.properties.get("fog-ground-blend") : 1,
            u_fog_ground_blend_opacity: h ? 0 : a ? a.calculateFogBlendOpacity(c) : 0,
            u_horizon_color: a ? a.properties.get("horizon-color") : l.bi.white,
            u_horizon_fog_blend: a ? a.properties.get("horizon-fog-blend") : 1,
            u_is_globe_mode: h ? 1 : 0
          }),
          Gc = {
            mainMatrix: "u_projection_matrix",
            tileMercatorCoords: "u_projection_tile_mercator_coords",
            clippingPlane: "u_projection_clipping_plane",
            projectionTransition: "u_projection_transition",
            fallbackMatrix: "u_projection_fallback_matrix"
          };

        function Ao(p) {
          const e = [];
          for (let a = 0; a < p.length; a++) {
            if (p[a] === null) continue;
            const c = p[a].split(" ");
            e.push(c.pop())
          }
          return e
        }
        class $s {
          constructor(e, a, c, h, f, v, w, T, C = []) {
            const z = e.gl;
            this.program = z.createProgram();
            const F = Ao(a.staticAttributes),
              R = c ? c.getBinderAttributes() : [],
              U = F.concat(R),
              Y = Nr.prelude.staticUniforms ? Ao(Nr.prelude.staticUniforms) : [],
              ne = w.staticUniforms ? Ao(w.staticUniforms) : [],
              ie = a.staticUniforms ? Ao(a.staticUniforms) : [],
              ae = c ? c.getBinderUniforms() : [],
              me = Y.concat(ne).concat(ie).concat(ae),
              ke = [];
            for (const at of me) ke.indexOf(at) < 0 && ke.push(at);
            const _e = c ? c.defines() : [];
            Di(z) && _e.unshift("#version 300 es"), f && _e.push("#define OVERDRAW_INSPECTOR;"), v && _e.push("#define TERRAIN3D;"), T && _e.push(T), C && _e.push(...C);
            let Te = _e.concat(Nr.prelude.fragmentSource, w.fragmentSource, a.fragmentSource).join(`
`),
              Ee = _e.concat(Nr.prelude.vertexSource, w.vertexSource, a.vertexSource).join(`
`);
            Di(z) || (Te = (function(at) {
              return at.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
            })(Te), Ee = (function(at) {
              return at.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
            })(Ee));
            const ye = z.createShader(z.FRAGMENT_SHADER);
            if (z.isContextLost()) return void(this.failedToCreate = !0);
            if (z.shaderSource(ye, Te), z.compileShader(ye), !z.getShaderParameter(ye, z.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${z.getShaderInfoLog(ye)}`);
            z.attachShader(this.program, ye);
            const Be = z.createShader(z.VERTEX_SHADER);
            if (z.isContextLost()) return void(this.failedToCreate = !0);
            if (z.shaderSource(Be, Ee), z.compileShader(Be), !z.getShaderParameter(Be, z.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${z.getShaderInfoLog(Be)}`);
            z.attachShader(this.program, Be), this.attributes = {};
            const ht = {};
            this.numAttributes = U.length;
            for (let at = 0; at < this.numAttributes; at++) U[at] && (z.bindAttribLocation(this.program, at, U[at]), this.attributes[U[at]] = at);
            if (z.linkProgram(this.program), !z.getProgramParameter(this.program, z.LINK_STATUS)) throw new Error(`Program failed to link: ${z.getProgramInfoLog(this.program)}`);
            z.deleteShader(Be), z.deleteShader(ye);
            for (let at = 0; at < ke.length; at++) {
              const lt = ke[at];
              if (lt && !ht[lt]) {
                const pt = z.getUniformLocation(this.program, lt);
                pt && (ht[lt] = pt)
              }
            }
            this.fixedUniforms = h(e, ht), this.terrainUniforms = ((at, lt) => ({
              u_depth: new l.bT(at, lt.u_depth),
              u_terrain: new l.bT(at, lt.u_terrain),
              u_terrain_dim: new l.bj(at, lt.u_terrain_dim),
              u_terrain_matrix: new l.bV(at, lt.u_terrain_matrix),
              u_terrain_unpack: new l.bW(at, lt.u_terrain_unpack),
              u_terrain_exaggeration: new l.bj(at, lt.u_terrain_exaggeration)
            }))(e, ht), this.projectionUniforms = ((at, lt) => ({
              u_projection_matrix: new l.bV(at, lt.u_projection_matrix),
              u_projection_tile_mercator_coords: new l.bW(at, lt.u_projection_tile_mercator_coords),
              u_projection_clipping_plane: new l.bW(at, lt.u_projection_clipping_plane),
              u_projection_transition: new l.bj(at, lt.u_projection_transition),
              u_projection_fallback_matrix: new l.bV(at, lt.u_projection_fallback_matrix)
            }))(e, ht), this.binderUniforms = c ? c.getUniforms(e, ht) : []
          }
          draw(e, a, c, h, f, v, w, T, C, z, F, R, U, Y, ne, ie, ae, me, ke) {
            const _e = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(c), e.setStencilMode(h), e.setColorMode(f), e.setCullFace(v), T) {
              e.activeTexture.set(_e.TEXTURE2), _e.bindTexture(_e.TEXTURE_2D, T.depthTexture), e.activeTexture.set(_e.TEXTURE3), _e.bindTexture(_e.TEXTURE_2D, T.texture);
              for (const Ee in this.terrainUniforms) this.terrainUniforms[Ee].set(T[Ee])
            }
            if (C)
              for (const Ee in C) this.projectionUniforms[Gc[Ee]].set(C[Ee]);
            if (w)
              for (const Ee in this.fixedUniforms) this.fixedUniforms[Ee].set(w[Ee]);
            ie && ie.setUniforms(e, this.binderUniforms, Y, {
              zoom: ne
            });
            let Te = 0;
            switch (a) {
              case _e.LINES:
                Te = 2;
                break;
              case _e.TRIANGLES:
                Te = 3;
                break;
              case _e.LINE_STRIP:
                Te = 1
            }
            for (const Ee of U.get()) {
              const ye = Ee.vaos || (Ee.vaos = {});
              (ye[z] || (ye[z] = new ro)).bind(e, this, F, ie ? ie.getPaintVertexBuffers() : [], R, Ee.vertexOffset, ae, me, ke), _e.drawElements(a, Ee.primitiveLength * Te, _e.UNSIGNED_SHORT, Ee.primitiveOffset * Te * 2)
            }
          }
        }

        function Uh(p, e, a) {
          const c = 1 / l.aG(a, 1, e.transform.tileZoom),
            h = Math.pow(2, a.tileID.overscaledZ),
            f = a.tileSize * Math.pow(2, e.transform.tileZoom) / h,
            v = f * (a.tileID.canonical.x + a.tileID.wrap * h),
            w = f * a.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: a.imageAtlasTexture.size,
            u_scale: [c, p.fromScale, p.toScale],
            u_fade: p.t,
            u_pixel_coord_upper: [v >> 16, w >> 16],
            u_pixel_coord_lower: [65535 & v, 65535 & w]
          }
        }
        const Ws = (p, e, a, c) => {
            const h = p.style.light,
              f = h.properties.get("position"),
              v = [f.x, f.y, f.z],
              w = l.bZ();
            h.properties.get("anchor") === "viewport" && l.b_(w, p.transform.bearingInRadians), l.b$(v, v, w);
            const T = p.transform.transformLightDirection(v),
              C = h.properties.get("color");
            return {
              u_lightpos: v,
              u_lightpos_globe: T,
              u_lightintensity: h.properties.get("intensity"),
              u_lightcolor: [C.r, C.g, C.b],
              u_vertical_gradient: +e,
              u_opacity: a,
              u_fill_translate: c
            }
          },
          Gp = (p, e, a, c, h, f, v) => l.e(Ws(p, e, a, c), Uh(f, p, v), {
            u_height_factor: -Math.pow(2, h.overscaledZ) / v.tileSize / 8
          }),
          Zo = (p, e, a, c) => l.e(Uh(e, p, a), {
            u_fill_translate: c
          }),
          $p = (p, e) => ({
            u_world: p,
            u_fill_translate: e
          }),
          Zh = (p, e, a, c, h) => l.e(Zo(p, e, a, h), {
            u_world: c
          }),
          Wp = (p, e, a, c, h) => {
            const f = p.transform;
            let v, w, T = 0;
            if (a.paint.get("circle-pitch-alignment") === "map") {
              const C = l.aG(e, 1, f.zoom);
              v = !0, w = [C, C], T = C / (l.a3 * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * h
            } else v = !1, w = f.pixelsToGLUnits;
            return {
              u_camera_to_center_distance: f.cameraToCenterDistance,
              u_scale_with_map: +(a.paint.get("circle-pitch-scale") === "map"),
              u_pitch_with_map: +v,
              u_device_pixel_ratio: p.pixelRatio,
              u_extrude_scale: w,
              u_globe_extrude_scale: T,
              u_translate: c
            }
          },
          Gh = p => ({
            u_pixel_extrude_scale: [1 / p.width, 1 / p.height]
          }),
          $c = p => ({
            u_viewport_size: [p.width, p.height]
          }),
          Wc = (p, e = 1) => ({
            u_color: p,
            u_overlay: 0,
            u_overlay_scale: e
          }),
          Hc = (p, e, a, c) => {
            const h = l.aG(p, 1, e) / (l.a3 * Math.pow(2, p.tileID.overscaledZ)) * 2 * Math.PI * c;
            return {
              u_extrude_scale: l.aG(p, 1, e),
              u_intensity: a,
              u_globe_extrude_scale: h
            }
          },
          Xc = (p, e, a, c) => {
            const h = l.M();
            l.c0(h, 0, p.width, p.height, 0, 0, 1);
            const f = p.context.gl;
            return {
              u_matrix: h,
              u_world: [f.drawingBufferWidth, f.drawingBufferHeight],
              u_image: a,
              u_color_ramp: c,
              u_opacity: e.paint.get("heatmap-opacity")
            }
          },
          $h = (p, e, a) => {
            const c = a.paint.get("hillshade-accent-color");
            let h;
            switch (a.paint.get("hillshade-method")) {
              case "basic":
                h = 4;
                break;
              case "combined":
                h = 1;
                break;
              case "igor":
                h = 2;
                break;
              case "multidirectional":
                h = 3;
                break;
              default:
                h = 0
            }
            const f = a.getIlluminationProperties();
            for (let v = 0; v < f.directionRadians.length; v++) a.paint.get("hillshade-illumination-anchor") === "viewport" && (f.directionRadians[v] += p.transform.bearingInRadians);
            return {
              u_image: 0,
              u_latrange: Wh(0, e.tileID),
              u_exaggeration: a.paint.get("hillshade-exaggeration"),
              u_altitudes: f.altitudeRadians,
              u_azimuths: f.directionRadians,
              u_accent: c,
              u_method: h,
              u_highlights: f.highlightColor,
              u_shadows: f.shadowColor
            }
          },
          Go = (p, e) => {
            const a = e.stride,
              c = l.M();
            return l.c0(c, 0, l.a3, -l.a3, 0, 0, 1), l.N(c, c, [0, -l.a3, 0]), {
              u_matrix: c,
              u_image: 1,
              u_dimension: [a, a],
              u_zoom: p.overscaledZ,
              u_unpack: e.getUnpackVector()
            }
          };

        function Wh(p, e) {
          const a = Math.pow(2, e.canonical.z),
            c = e.canonical.y;
          return [new l.a5(0, c / a).toLngLat().lat, new l.a5(0, (c + 1) / a).toLngLat().lat]
        }
        const Hh = (p, e, a = 0) => ({
            u_image: 0,
            u_unpack: e.getUnpackVector(),
            u_dimension: [e.stride, e.stride],
            u_elevation_stops: 1,
            u_color_stops: 4,
            u_color_ramp_size: a,
            u_opacity: p.paint.get("color-relief-opacity")
          }),
          zo = (p, e, a, c) => {
            const h = p.transform;
            return {
              u_translation: Yc(p, e, a),
              u_ratio: c / l.aG(e, 1, h.zoom),
              u_device_pixel_ratio: p.pixelRatio,
              u_units_to_pixels: [1 / h.pixelsToGLUnits[0], 1 / h.pixelsToGLUnits[1]]
            }
          },
          Hp = (p, e, a, c, h) => l.e(zo(p, e, a, c), {
            u_image: 0,
            u_image_height: h
          }),
          zl = (p, e, a, c, h) => {
            const f = p.transform,
              v = El(e, f);
            return {
              u_translation: Yc(p, e, a),
              u_texsize: e.imageAtlasTexture.size,
              u_ratio: c / l.aG(e, 1, f.zoom),
              u_device_pixel_ratio: p.pixelRatio,
              u_image: 0,
              u_scale: [v, h.fromScale, h.toScale],
              u_fade: h.t,
              u_units_to_pixels: [1 / f.pixelsToGLUnits[0], 1 / f.pixelsToGLUnits[1]]
            }
          },
          Xp = (p, e, a, c, h) => {
            const f = El(e, p.transform);
            return l.e(zo(p, e, a, c), {
              u_tileratio: f,
              u_crossfade_from: h.fromScale,
              u_crossfade_to: h.toScale,
              u_image: 0,
              u_mix: h.t,
              u_lineatlas_width: p.lineAtlas.width,
              u_lineatlas_height: p.lineAtlas.height
            })
          },
          Yp = (p, e, a, c, h, f) => {
            const v = El(e, p.transform);
            return l.e(zo(p, e, a, c), {
              u_image: 0,
              u_image_height: f,
              u_tileratio: v,
              u_crossfade_from: h.fromScale,
              u_crossfade_to: h.toScale,
              u_image_dash: 1,
              u_mix: h.t,
              u_lineatlas_width: p.lineAtlas.width,
              u_lineatlas_height: p.lineAtlas.height
            })
          };

        function El(p, e) {
          return 1 / l.aG(p, 1, e.tileZoom)
        }

        function Yc(p, e, a) {
          return l.aH(p.transform, e, a.paint.get("line-translate"), a.paint.get("line-translate-anchor"))
        }
        const Xh = (p, e, a, c, h) => {
          return {
            u_tl_parent: p,
            u_scale_parent: e,
            u_buffer_scale: 1,
            u_fade_t: a.mix,
            u_opacity: a.opacity * c.paint.get("raster-opacity"),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: c.paint.get("raster-brightness-min"),
            u_brightness_high: c.paint.get("raster-brightness-max"),
            u_saturation_factor: (v = c.paint.get("raster-saturation"), v > 0 ? 1 - 1 / (1.001 - v) : -v),
            u_contrast_factor: (f = c.paint.get("raster-contrast"), f > 0 ? 1 / (1 - f) : 1 + f),
            u_spin_weights: Kc(c.paint.get("raster-hue-rotate")),
            u_coords_top: [h[0].x, h[0].y, h[1].x, h[1].y],
            u_coords_bottom: [h[3].x, h[3].y, h[2].x, h[2].y]
          };
          var f, v
        };

        function Kc(p) {
          p *= Math.PI / 180;
          const e = Math.sin(p),
            a = Math.cos(p);
          return [(2 * a + 1) / 3, (-Math.sqrt(3) * e - a + 1) / 3, (Math.sqrt(3) * e - a + 1) / 3]
        }
        const Jc = (p, e, a, c, h, f, v, w, T, C, z, F, R) => {
            const U = v.transform;
            return {
              u_is_size_zoom_constant: +(p === "constant" || p === "source"),
              u_is_size_feature_constant: +(p === "constant" || p === "camera"),
              u_size_t: e ? e.uSizeT : 0,
              u_size: e ? e.uSize : 0,
              u_camera_to_center_distance: U.cameraToCenterDistance,
              u_pitch: U.pitch / 360 * 2 * Math.PI,
              u_rotate_symbol: +a,
              u_aspect_ratio: U.width / U.height,
              u_fade_change: v.options.fadeDuration ? v.symbolFadeChange : 1,
              u_label_plane_matrix: w,
              u_coord_matrix: T,
              u_is_text: +z,
              u_pitch_with_map: +c,
              u_is_along_line: h,
              u_is_variable_anchor: f,
              u_texsize: F,
              u_texture: 0,
              u_translation: C,
              u_pitched_scale: R
            }
          },
          Hs = (p, e, a, c, h, f, v, w, T, C, z, F, R, U) => {
            const Y = v.transform;
            return l.e(Jc(p, e, a, c, h, f, v, w, T, C, z, F, U), {
              u_gamma_scale: c ? Math.cos(Y.pitch * Math.PI / 180) * Y.cameraToCenterDistance : 1,
              u_device_pixel_ratio: v.pixelRatio,
              u_is_halo: 1
            })
          },
          po = (p, e, a, c, h, f, v, w, T, C, z, F, R) => l.e(Hs(p, e, a, c, h, f, v, w, T, C, !0, z, 0, R), {
            u_texsize_icon: F,
            u_texture_icon: 1
          }),
          Qc = (p, e) => ({
            u_opacity: p,
            u_color: e
          }),
          eu = (p, e, a, c, h) => l.e((function(f, v, w, T) {
            const C = w.imageManager.getPattern(f.from.toString()),
              z = w.imageManager.getPattern(f.to.toString()),
              {
                width: F,
                height: R
              } = w.imageManager.getPixelSize(),
              U = Math.pow(2, T.tileID.overscaledZ),
              Y = T.tileSize * Math.pow(2, w.transform.tileZoom) / U,
              ne = Y * (T.tileID.canonical.x + T.tileID.wrap * U),
              ie = Y * T.tileID.canonical.y;
            return {
              u_image: 0,
              u_pattern_tl_a: C.tl,
              u_pattern_br_a: C.br,
              u_pattern_tl_b: z.tl,
              u_pattern_br_b: z.br,
              u_texsize: [F, R],
              u_mix: v.t,
              u_pattern_size_a: C.displaySize,
              u_pattern_size_b: z.displaySize,
              u_scale_a: v.fromScale,
              u_scale_b: v.toScale,
              u_tile_units_to_pixels: 1 / l.aG(T, 1, w.transform.tileZoom),
              u_pixel_coord_upper: [ne >> 16, ie >> 16],
              u_pixel_coord_lower: [65535 & ne, 65535 & ie]
            }
          })(a, h, e, c), {
            u_opacity: p
          }),
          Ll = (p, e) => {},
          Yh = {
            fillExtrusion: (p, e) => ({
              u_lightpos: new l.bX(p, e.u_lightpos),
              u_lightpos_globe: new l.bX(p, e.u_lightpos_globe),
              u_lightintensity: new l.bj(p, e.u_lightintensity),
              u_lightcolor: new l.bX(p, e.u_lightcolor),
              u_vertical_gradient: new l.bj(p, e.u_vertical_gradient),
              u_opacity: new l.bj(p, e.u_opacity),
              u_fill_translate: new l.bY(p, e.u_fill_translate)
            }),
            fillExtrusionPattern: (p, e) => ({
              u_lightpos: new l.bX(p, e.u_lightpos),
              u_lightpos_globe: new l.bX(p, e.u_lightpos_globe),
              u_lightintensity: new l.bj(p, e.u_lightintensity),
              u_lightcolor: new l.bX(p, e.u_lightcolor),
              u_vertical_gradient: new l.bj(p, e.u_vertical_gradient),
              u_height_factor: new l.bj(p, e.u_height_factor),
              u_opacity: new l.bj(p, e.u_opacity),
              u_fill_translate: new l.bY(p, e.u_fill_translate),
              u_image: new l.bT(p, e.u_image),
              u_texsize: new l.bY(p, e.u_texsize),
              u_pixel_coord_upper: new l.bY(p, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new l.bY(p, e.u_pixel_coord_lower),
              u_scale: new l.bX(p, e.u_scale),
              u_fade: new l.bj(p, e.u_fade)
            }),
            fill: (p, e) => ({
              u_fill_translate: new l.bY(p, e.u_fill_translate)
            }),
            fillPattern: (p, e) => ({
              u_image: new l.bT(p, e.u_image),
              u_texsize: new l.bY(p, e.u_texsize),
              u_pixel_coord_upper: new l.bY(p, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new l.bY(p, e.u_pixel_coord_lower),
              u_scale: new l.bX(p, e.u_scale),
              u_fade: new l.bj(p, e.u_fade),
              u_fill_translate: new l.bY(p, e.u_fill_translate)
            }),
            fillOutline: (p, e) => ({
              u_world: new l.bY(p, e.u_world),
              u_fill_translate: new l.bY(p, e.u_fill_translate)
            }),
            fillOutlinePattern: (p, e) => ({
              u_world: new l.bY(p, e.u_world),
              u_image: new l.bT(p, e.u_image),
              u_texsize: new l.bY(p, e.u_texsize),
              u_pixel_coord_upper: new l.bY(p, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new l.bY(p, e.u_pixel_coord_lower),
              u_scale: new l.bX(p, e.u_scale),
              u_fade: new l.bj(p, e.u_fade),
              u_fill_translate: new l.bY(p, e.u_fill_translate)
            }),
            circle: (p, e) => ({
              u_camera_to_center_distance: new l.bj(p, e.u_camera_to_center_distance),
              u_scale_with_map: new l.bT(p, e.u_scale_with_map),
              u_pitch_with_map: new l.bT(p, e.u_pitch_with_map),
              u_extrude_scale: new l.bY(p, e.u_extrude_scale),
              u_device_pixel_ratio: new l.bj(p, e.u_device_pixel_ratio),
              u_globe_extrude_scale: new l.bj(p, e.u_globe_extrude_scale),
              u_translate: new l.bY(p, e.u_translate)
            }),
            collisionBox: (p, e) => ({
              u_pixel_extrude_scale: new l.bY(p, e.u_pixel_extrude_scale)
            }),
            collisionCircle: (p, e) => ({
              u_viewport_size: new l.bY(p, e.u_viewport_size)
            }),
            debug: (p, e) => ({
              u_color: new l.bU(p, e.u_color),
              u_overlay: new l.bT(p, e.u_overlay),
              u_overlay_scale: new l.bj(p, e.u_overlay_scale)
            }),
            depth: Ll,
            clippingMask: Ll,
            heatmap: (p, e) => ({
              u_extrude_scale: new l.bj(p, e.u_extrude_scale),
              u_intensity: new l.bj(p, e.u_intensity),
              u_globe_extrude_scale: new l.bj(p, e.u_globe_extrude_scale)
            }),
            heatmapTexture: (p, e) => ({
              u_matrix: new l.bV(p, e.u_matrix),
              u_world: new l.bY(p, e.u_world),
              u_image: new l.bT(p, e.u_image),
              u_color_ramp: new l.bT(p, e.u_color_ramp),
              u_opacity: new l.bj(p, e.u_opacity)
            }),
            hillshade: (p, e) => ({
              u_image: new l.bT(p, e.u_image),
              u_latrange: new l.bY(p, e.u_latrange),
              u_exaggeration: new l.bj(p, e.u_exaggeration),
              u_altitudes: new l.c2(p, e.u_altitudes),
              u_azimuths: new l.c2(p, e.u_azimuths),
              u_accent: new l.bU(p, e.u_accent),
              u_method: new l.bT(p, e.u_method),
              u_shadows: new l.c1(p, e.u_shadows),
              u_highlights: new l.c1(p, e.u_highlights)
            }),
            hillshadePrepare: (p, e) => ({
              u_matrix: new l.bV(p, e.u_matrix),
              u_image: new l.bT(p, e.u_image),
              u_dimension: new l.bY(p, e.u_dimension),
              u_zoom: new l.bj(p, e.u_zoom),
              u_unpack: new l.bW(p, e.u_unpack)
            }),
            colorRelief: (p, e) => ({
              u_image: new l.bT(p, e.u_image),
              u_unpack: new l.bW(p, e.u_unpack),
              u_dimension: new l.bY(p, e.u_dimension),
              u_elevation_stops: new l.bT(p, e.u_elevation_stops),
              u_color_stops: new l.bT(p, e.u_color_stops),
              u_color_ramp_size: new l.bT(p, e.u_color_ramp_size),
              u_opacity: new l.bj(p, e.u_opacity)
            }),
            line: (p, e) => ({
              u_translation: new l.bY(p, e.u_translation),
              u_ratio: new l.bj(p, e.u_ratio),
              u_device_pixel_ratio: new l.bj(p, e.u_device_pixel_ratio),
              u_units_to_pixels: new l.bY(p, e.u_units_to_pixels)
            }),
            lineGradient: (p, e) => ({
              u_translation: new l.bY(p, e.u_translation),
              u_ratio: new l.bj(p, e.u_ratio),
              u_device_pixel_ratio: new l.bj(p, e.u_device_pixel_ratio),
              u_units_to_pixels: new l.bY(p, e.u_units_to_pixels),
              u_image: new l.bT(p, e.u_image),
              u_image_height: new l.bj(p, e.u_image_height)
            }),
            linePattern: (p, e) => ({
              u_translation: new l.bY(p, e.u_translation),
              u_texsize: new l.bY(p, e.u_texsize),
              u_ratio: new l.bj(p, e.u_ratio),
              u_device_pixel_ratio: new l.bj(p, e.u_device_pixel_ratio),
              u_image: new l.bT(p, e.u_image),
              u_units_to_pixels: new l.bY(p, e.u_units_to_pixels),
              u_scale: new l.bX(p, e.u_scale),
              u_fade: new l.bj(p, e.u_fade)
            }),
            lineSDF: (p, e) => ({
              u_translation: new l.bY(p, e.u_translation),
              u_ratio: new l.bj(p, e.u_ratio),
              u_device_pixel_ratio: new l.bj(p, e.u_device_pixel_ratio),
              u_units_to_pixels: new l.bY(p, e.u_units_to_pixels),
              u_image: new l.bT(p, e.u_image),
              u_mix: new l.bj(p, e.u_mix),
              u_tileratio: new l.bj(p, e.u_tileratio),
              u_crossfade_from: new l.bj(p, e.u_crossfade_from),
              u_crossfade_to: new l.bj(p, e.u_crossfade_to),
              u_lineatlas_width: new l.bj(p, e.u_lineatlas_width),
              u_lineatlas_height: new l.bj(p, e.u_lineatlas_height)
            }),
            lineGradientSDF: (p, e) => ({
              u_translation: new l.bY(p, e.u_translation),
              u_ratio: new l.bj(p, e.u_ratio),
              u_device_pixel_ratio: new l.bj(p, e.u_device_pixel_ratio),
              u_units_to_pixels: new l.bY(p, e.u_units_to_pixels),
              u_image: new l.bT(p, e.u_image),
              u_image_height: new l.bj(p, e.u_image_height),
              u_tileratio: new l.bj(p, e.u_tileratio),
              u_crossfade_from: new l.bj(p, e.u_crossfade_from),
              u_crossfade_to: new l.bj(p, e.u_crossfade_to),
              u_image_dash: new l.bT(p, e.u_image_dash),
              u_mix: new l.bj(p, e.u_mix),
              u_lineatlas_width: new l.bj(p, e.u_lineatlas_width),
              u_lineatlas_height: new l.bj(p, e.u_lineatlas_height)
            }),
            raster: (p, e) => ({
              u_tl_parent: new l.bY(p, e.u_tl_parent),
              u_scale_parent: new l.bj(p, e.u_scale_parent),
              u_buffer_scale: new l.bj(p, e.u_buffer_scale),
              u_fade_t: new l.bj(p, e.u_fade_t),
              u_opacity: new l.bj(p, e.u_opacity),
              u_image0: new l.bT(p, e.u_image0),
              u_image1: new l.bT(p, e.u_image1),
              u_brightness_low: new l.bj(p, e.u_brightness_low),
              u_brightness_high: new l.bj(p, e.u_brightness_high),
              u_saturation_factor: new l.bj(p, e.u_saturation_factor),
              u_contrast_factor: new l.bj(p, e.u_contrast_factor),
              u_spin_weights: new l.bX(p, e.u_spin_weights),
              u_coords_top: new l.bW(p, e.u_coords_top),
              u_coords_bottom: new l.bW(p, e.u_coords_bottom)
            }),
            symbolIcon: (p, e) => ({
              u_is_size_zoom_constant: new l.bT(p, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new l.bT(p, e.u_is_size_feature_constant),
              u_size_t: new l.bj(p, e.u_size_t),
              u_size: new l.bj(p, e.u_size),
              u_camera_to_center_distance: new l.bj(p, e.u_camera_to_center_distance),
              u_pitch: new l.bj(p, e.u_pitch),
              u_rotate_symbol: new l.bT(p, e.u_rotate_symbol),
              u_aspect_ratio: new l.bj(p, e.u_aspect_ratio),
              u_fade_change: new l.bj(p, e.u_fade_change),
              u_label_plane_matrix: new l.bV(p, e.u_label_plane_matrix),
              u_coord_matrix: new l.bV(p, e.u_coord_matrix),
              u_is_text: new l.bT(p, e.u_is_text),
              u_pitch_with_map: new l.bT(p, e.u_pitch_with_map),
              u_is_along_line: new l.bT(p, e.u_is_along_line),
              u_is_variable_anchor: new l.bT(p, e.u_is_variable_anchor),
              u_texsize: new l.bY(p, e.u_texsize),
              u_texture: new l.bT(p, e.u_texture),
              u_translation: new l.bY(p, e.u_translation),
              u_pitched_scale: new l.bj(p, e.u_pitched_scale)
            }),
            symbolSDF: (p, e) => ({
              u_is_size_zoom_constant: new l.bT(p, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new l.bT(p, e.u_is_size_feature_constant),
              u_size_t: new l.bj(p, e.u_size_t),
              u_size: new l.bj(p, e.u_size),
              u_camera_to_center_distance: new l.bj(p, e.u_camera_to_center_distance),
              u_pitch: new l.bj(p, e.u_pitch),
              u_rotate_symbol: new l.bT(p, e.u_rotate_symbol),
              u_aspect_ratio: new l.bj(p, e.u_aspect_ratio),
              u_fade_change: new l.bj(p, e.u_fade_change),
              u_label_plane_matrix: new l.bV(p, e.u_label_plane_matrix),
              u_coord_matrix: new l.bV(p, e.u_coord_matrix),
              u_is_text: new l.bT(p, e.u_is_text),
              u_pitch_with_map: new l.bT(p, e.u_pitch_with_map),
              u_is_along_line: new l.bT(p, e.u_is_along_line),
              u_is_variable_anchor: new l.bT(p, e.u_is_variable_anchor),
              u_texsize: new l.bY(p, e.u_texsize),
              u_texture: new l.bT(p, e.u_texture),
              u_gamma_scale: new l.bj(p, e.u_gamma_scale),
              u_device_pixel_ratio: new l.bj(p, e.u_device_pixel_ratio),
              u_is_halo: new l.bT(p, e.u_is_halo),
              u_translation: new l.bY(p, e.u_translation),
              u_pitched_scale: new l.bj(p, e.u_pitched_scale)
            }),
            symbolTextAndIcon: (p, e) => ({
              u_is_size_zoom_constant: new l.bT(p, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new l.bT(p, e.u_is_size_feature_constant),
              u_size_t: new l.bj(p, e.u_size_t),
              u_size: new l.bj(p, e.u_size),
              u_camera_to_center_distance: new l.bj(p, e.u_camera_to_center_distance),
              u_pitch: new l.bj(p, e.u_pitch),
              u_rotate_symbol: new l.bT(p, e.u_rotate_symbol),
              u_aspect_ratio: new l.bj(p, e.u_aspect_ratio),
              u_fade_change: new l.bj(p, e.u_fade_change),
              u_label_plane_matrix: new l.bV(p, e.u_label_plane_matrix),
              u_coord_matrix: new l.bV(p, e.u_coord_matrix),
              u_is_text: new l.bT(p, e.u_is_text),
              u_pitch_with_map: new l.bT(p, e.u_pitch_with_map),
              u_is_along_line: new l.bT(p, e.u_is_along_line),
              u_is_variable_anchor: new l.bT(p, e.u_is_variable_anchor),
              u_texsize: new l.bY(p, e.u_texsize),
              u_texsize_icon: new l.bY(p, e.u_texsize_icon),
              u_texture: new l.bT(p, e.u_texture),
              u_texture_icon: new l.bT(p, e.u_texture_icon),
              u_gamma_scale: new l.bj(p, e.u_gamma_scale),
              u_device_pixel_ratio: new l.bj(p, e.u_device_pixel_ratio),
              u_is_halo: new l.bT(p, e.u_is_halo),
              u_translation: new l.bY(p, e.u_translation),
              u_pitched_scale: new l.bj(p, e.u_pitched_scale)
            }),
            background: (p, e) => ({
              u_opacity: new l.bj(p, e.u_opacity),
              u_color: new l.bU(p, e.u_color)
            }),
            backgroundPattern: (p, e) => ({
              u_opacity: new l.bj(p, e.u_opacity),
              u_image: new l.bT(p, e.u_image),
              u_pattern_tl_a: new l.bY(p, e.u_pattern_tl_a),
              u_pattern_br_a: new l.bY(p, e.u_pattern_br_a),
              u_pattern_tl_b: new l.bY(p, e.u_pattern_tl_b),
              u_pattern_br_b: new l.bY(p, e.u_pattern_br_b),
              u_texsize: new l.bY(p, e.u_texsize),
              u_mix: new l.bj(p, e.u_mix),
              u_pattern_size_a: new l.bY(p, e.u_pattern_size_a),
              u_pattern_size_b: new l.bY(p, e.u_pattern_size_b),
              u_scale_a: new l.bj(p, e.u_scale_a),
              u_scale_b: new l.bj(p, e.u_scale_b),
              u_pixel_coord_upper: new l.bY(p, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new l.bY(p, e.u_pixel_coord_lower),
              u_tile_units_to_pixels: new l.bj(p, e.u_tile_units_to_pixels)
            }),
            terrain: (p, e) => ({
              u_texture: new l.bT(p, e.u_texture),
              u_ele_delta: new l.bj(p, e.u_ele_delta),
              u_fog_matrix: new l.bV(p, e.u_fog_matrix),
              u_fog_color: new l.bU(p, e.u_fog_color),
              u_fog_ground_blend: new l.bj(p, e.u_fog_ground_blend),
              u_fog_ground_blend_opacity: new l.bj(p, e.u_fog_ground_blend_opacity),
              u_horizon_color: new l.bU(p, e.u_horizon_color),
              u_horizon_fog_blend: new l.bj(p, e.u_horizon_fog_blend),
              u_is_globe_mode: new l.bj(p, e.u_is_globe_mode)
            }),
            terrainDepth: (p, e) => ({
              u_ele_delta: new l.bj(p, e.u_ele_delta)
            }),
            terrainCoords: (p, e) => ({
              u_texture: new l.bT(p, e.u_texture),
              u_terrain_coords_id: new l.bj(p, e.u_terrain_coords_id),
              u_ele_delta: new l.bj(p, e.u_ele_delta)
            }),
            projectionErrorMeasurement: (p, e) => ({
              u_input: new l.bj(p, e.u_input),
              u_output_expected: new l.bj(p, e.u_output_expected)
            }),
            atmosphere: (p, e) => ({
              u_sun_pos: new l.bX(p, e.u_sun_pos),
              u_atmosphere_blend: new l.bj(p, e.u_atmosphere_blend),
              u_globe_position: new l.bX(p, e.u_globe_position),
              u_globe_radius: new l.bj(p, e.u_globe_radius),
              u_inv_proj_matrix: new l.bV(p, e.u_inv_proj_matrix)
            }),
            sky: (p, e) => ({
              u_sky_color: new l.bU(p, e.u_sky_color),
              u_horizon_color: new l.bU(p, e.u_horizon_color),
              u_horizon: new l.bY(p, e.u_horizon),
              u_horizon_normal: new l.bY(p, e.u_horizon_normal),
              u_sky_horizon_blend: new l.bj(p, e.u_sky_horizon_blend),
              u_sky_blend: new l.bj(p, e.u_sky_blend)
            })
          };
        class tu {
          constructor(e, a, c) {
            this.context = e;
            const h = e.gl;
            this.buffer = h.createBuffer(), this.dynamicDraw = !!c, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), h.bufferData(h.ELEMENT_ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? h.DYNAMIC_DRAW : h.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer)
          }
          updateData(e) {
            const a = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), a.bufferSubData(a.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        const $o = {
          Int8: "BYTE",
          Uint8: "UNSIGNED_BYTE",
          Int16: "SHORT",
          Uint16: "UNSIGNED_SHORT",
          Int32: "INT",
          Uint32: "UNSIGNED_INT",
          Float32: "FLOAT"
        };
        class ru {
          constructor(e, a, c, h) {
            this.length = a.length, this.attributes = c, this.itemSize = a.bytesPerElement, this.dynamicDraw = h, this.context = e;
            const f = e.gl;
            this.buffer = f.createBuffer(), e.bindVertexBuffer.set(this.buffer), f.bufferData(f.ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? f.DYNAMIC_DRAW : f.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer)
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const a = this.context.gl;
            this.bind(), a.bufferSubData(a.ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          enableAttributes(e, a) {
            for (let c = 0; c < this.attributes.length; c++) {
              const h = a.attributes[this.attributes[c].name];
              h !== void 0 && e.enableVertexAttribArray(h)
            }
          }
          setVertexAttribPointers(e, a, c) {
            for (let h = 0; h < this.attributes.length; h++) {
              const f = this.attributes[h],
                v = a.attributes[f.name];
              v !== void 0 && e.vertexAttribPointer(v, f.components, e[$o[f.type]], !1, this.itemSize, f.offset + this.itemSize * (c || 0))
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        class Wn {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
          }
          get() {
            return this.current
          }
          set(e) {}
          getDefault() {
            return this.default
          }
          setDefault() {
            this.set(this.default)
          }
        }
        class Kp extends Wn {
          getDefault() {
            return l.bi.transparent
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Jp extends Wn {
          getDefault() {
            return 1
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1)
          }
        }
        class Qp extends Wn {
          getDefault() {
            return 0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1)
          }
        }
        class Kh extends Wn {
          getDefault() {
            return [!0, !0, !0, !0]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class ef extends Wn {
          getDefault() {
            return !0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Jh extends Wn {
          getDefault() {
            return 255
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Dl extends Wn {
          getDefault() {
            return {
              func: this.gl.ALWAYS,
              ref: 0,
              mask: 255
            }
          }
          set(e) {
            const a = this.current;
            (e.func !== a.func || e.ref !== a.ref || e.mask !== a.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1)
          }
        }
        class Rl extends Wn {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1)
          }
        }
        class jl extends Wn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST), this.current = e, this.dirty = !1
          }
        }
        class nu extends Wn {
          getDefault() {
            return [0, 1]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Wo extends Wn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST), this.current = e, this.dirty = !1
          }
        }
        class Xs extends Wn {
          getDefault() {
            return this.gl.LESS
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1)
          }
        }
        class ws extends Wn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.BLEND) : a.disable(a.BLEND), this.current = e, this.dirty = !1
          }
        }
        class Ra extends Wn {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Qh extends Wn {
          getDefault() {
            return l.bi.transparent
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class ed extends Wn {
          getDefault() {
            return this.gl.FUNC_ADD
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1)
          }
        }
        class iu extends Wn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.CULL_FACE) : a.disable(a.CULL_FACE), this.current = e, this.dirty = !1
          }
        }
        class Ho extends Wn {
          getDefault() {
            return this.gl.BACK
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1)
          }
        }
        class Fl extends Wn {
          getDefault() {
            return this.gl.CCW
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1)
          }
        }
        class Bl extends Wn {
          getDefault() {
            return null
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1)
          }
        }
        class Ys extends Wn {
          getDefault() {
            return this.gl.TEXTURE0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1)
          }
        }
        class Ol extends Wn {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class td extends Wn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindFramebuffer(a.FRAMEBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class ks extends Wn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindRenderbuffer(a.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Ts extends Wn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindTexture(a.TEXTURE_2D, e), this.current = e, this.dirty = !1
          }
        }
        class rd extends Wn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindBuffer(a.ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class au extends Wn {
          getDefault() {
            return null
          }
          set(e) {
            const a = this.gl;
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class jn extends Wn {
          getDefault() {
            return null
          }
          set(e) {
            var a;
            if (e === this.current && !this.dirty) return;
            const c = this.gl;
            Di(c) ? c.bindVertexArray(e) : (a = c.getExtension("OES_vertex_array_object")) === null || a === void 0 || a.bindVertexArrayOES(e), this.current = e, this.dirty = !1
          }
        }
        class ql extends Wn {
          getDefault() {
            return 4
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1
          }
        }
        class tf extends Wn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class nd extends Wn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class Xo extends Wn {
          constructor(e, a) {
            super(e), this.context = e, this.parent = a
          }
          getDefault() {
            return null
          }
        }
        class rf extends Xo {
          setDirty() {
            this.dirty = !0
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1
          }
        }
        class nf extends Xo {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class id extends Xo {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        const ad = "Framebuffer is not complete";
        class ou {
          constructor(e, a, c, h, f) {
            this.context = e, this.width = a, this.height = c;
            const v = e.gl,
              w = this.framebuffer = v.createFramebuffer();
            if (this.colorAttachment = new rf(e, w), h) this.depthAttachment = f ? new id(e, w) : new nf(e, w);
            else if (f) throw new Error("Stencil cannot be set without depth");
            if (v.checkFramebufferStatus(v.FRAMEBUFFER) !== v.FRAMEBUFFER_COMPLETE) throw new Error(ad)
          }
          destroy() {
            const e = this.context.gl,
              a = this.colorAttachment.get();
            if (a && e.deleteTexture(a), this.depthAttachment) {
              const c = this.depthAttachment.get();
              c && e.deleteRenderbuffer(c)
            }
            e.deleteFramebuffer(this.framebuffer)
          }
        }
        class Nl {
          constructor(e) {
            var a, c;
            if (this.gl = e, this.clearColor = new Kp(this), this.clearDepth = new Jp(this), this.clearStencil = new Qp(this), this.colorMask = new Kh(this), this.depthMask = new ef(this), this.stencilMask = new Jh(this), this.stencilFunc = new Dl(this), this.stencilOp = new Rl(this), this.stencilTest = new jl(this), this.depthRange = new nu(this), this.depthTest = new Wo(this), this.depthFunc = new Xs(this), this.blend = new ws(this), this.blendFunc = new Ra(this), this.blendColor = new Qh(this), this.blendEquation = new ed(this), this.cullFace = new iu(this), this.cullFaceSide = new Ho(this), this.frontFace = new Fl(this), this.program = new Bl(this), this.activeTexture = new Ys(this), this.viewport = new Ol(this), this.bindFramebuffer = new td(this), this.bindRenderbuffer = new ks(this), this.bindTexture = new Ts(this), this.bindVertexBuffer = new rd(this), this.bindElementBuffer = new au(this), this.bindVertexArray = new jn(this), this.pixelStoreUnpack = new ql(this), this.pixelStoreUnpackPremultiplyAlpha = new tf(this), this.pixelStoreUnpackFlipY = new nd(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Di(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const h = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (a = e.RGBA16F) !== null && a !== void 0 ? a : h == null ? void 0 : h.RGBA16F_EXT, this.RGB16F = (c = e.RGB16F) !== null && c !== void 0 ? c : h == null ? void 0 : h.RGB16F_EXT, e.getExtension("EXT_color_buffer_float")
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const h = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = h == null ? void 0 : h.HALF_FLOAT_OES
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
          }
          createIndexBuffer(e, a) {
            return new tu(this, e, a)
          }
          createVertexBuffer(e, a, c) {
            return new ru(this, e, a, c)
          }
          createRenderbuffer(e, a, c) {
            const h = this.gl,
              f = h.createRenderbuffer();
            return this.bindRenderbuffer.set(f), h.renderbufferStorage(h.RENDERBUFFER, e, a, c), this.bindRenderbuffer.set(null), f
          }
          createFramebuffer(e, a, c, h) {
            return new ou(this, e, a, c, h)
          }
          clear({
            color: e,
            depth: a,
            stencil: c
          }) {
            const h = this.gl;
            let f = 0;
            e && (f |= h.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), a !== void 0 && (f |= h.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(a), this.depthMask.set(!0)), c !== void 0 && (f |= h.STENCIL_BUFFER_BIT, this.clearStencil.set(c), this.stencilMask.set(255)), h.clear(f)
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace))
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1)
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
              func: e.test.func,
              ref: e.ref,
              mask: e.test.mask
            })) : this.stencilTest.set(!1)
          }
          setColorMode(e) {
            l.bK(e.blendFunction, an.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask)
          }
          createVertexArray() {
            var e;
            return Di(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
          }
          deleteVertexArray(e) {
            var a;
            return Di(this.gl) ? this.gl.deleteVertexArray(e) : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.deleteVertexArrayOES(e)
          }
          unbindVAO() {
            this.bindVertexArray.set(null)
          }
        }
        let Yo;

        function Ks(p, e, a, c, h) {
          const f = p.context,
            v = p.transform,
            w = f.gl,
            T = p.useProgram("collisionBox"),
            C = [];
          let z = 0,
            F = 0;
          for (let ae = 0; ae < c.length; ae++) {
            const me = c[ae],
              ke = e.getTile(me).getBucket(a);
            if (!ke) continue;
            const _e = h ? ke.textCollisionBox : ke.iconCollisionBox,
              Te = ke.collisionCircleArray;
            Te.length > 0 && (C.push({
              circleArray: Te,
              circleOffset: F,
              coord: me
            }), z += Te.length / 4, F = z), _e && T.draw(f, w.LINES, dn.disabled, An.disabled, p.colorModeForRenderPass(), ln.disabled, Gh(p.transform), p.style.map.terrain && p.style.map.terrain.getTerrainData(me), v.getProjectionData({
              overscaledTileID: me,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }), a.id, _e.layoutVertexBuffer, _e.indexBuffer, _e.segments, null, p.transform.zoom, null, null, _e.collisionVertexBuffer)
          }
          if (!h || !C.length) return;
          const R = p.useProgram("collisionCircle"),
            U = new l.c3;
          U.resize(4 * z), U._trim();
          let Y = 0;
          for (const ae of C)
            for (let me = 0; me < ae.circleArray.length / 4; me++) {
              const ke = 4 * me,
                _e = ae.circleArray[ke + 0],
                Te = ae.circleArray[ke + 1],
                Ee = ae.circleArray[ke + 2],
                ye = ae.circleArray[ke + 3];
              U.emplace(Y++, _e, Te, Ee, ye, 0), U.emplace(Y++, _e, Te, Ee, ye, 1), U.emplace(Y++, _e, Te, Ee, ye, 2), U.emplace(Y++, _e, Te, Ee, ye, 3)
            }(!Yo || Yo.length < 2 * z) && (Yo = (function(ae) {
              const me = 2 * ae,
                ke = new l.c5;
              ke.resize(me), ke._trim();
              for (let _e = 0; _e < me; _e++) {
                const Te = 6 * _e;
                ke.uint16[Te + 0] = 4 * _e + 0, ke.uint16[Te + 1] = 4 * _e + 1, ke.uint16[Te + 2] = 4 * _e + 2, ke.uint16[Te + 3] = 4 * _e + 2, ke.uint16[Te + 4] = 4 * _e + 3, ke.uint16[Te + 5] = 4 * _e + 0
              }
              return ke
            })(z));
          const ne = f.createIndexBuffer(Yo, !0),
            ie = f.createVertexBuffer(U, l.c4.members, !0);
          for (const ae of C) {
            const me = $c(p.transform);
            R.draw(f, w.TRIANGLES, dn.disabled, An.disabled, p.colorModeForRenderPass(), ln.disabled, me, p.style.map.terrain && p.style.map.terrain.getTerrainData(ae.coord), null, a.id, ie, ne, l.aQ.simpleSegment(0, 2 * ae.circleOffset, ae.circleArray.length, ae.circleArray.length / 2), null, p.transform.zoom, null, null, null)
          }
          ie.destroy(), ne.destroy()
        }
        const su = l.am(new Float32Array(16));

        function od(p, e, a, c, h, f) {
          const {
            horizontalAlign: v,
            verticalAlign: w
          } = l.aL(p);
          return new l.P((-(v - .5) * e / h + c[0]) * f, (-(w - .5) * a / h + c[1]) * f)
        }

        function Vl(p, e, a, c, h, f) {
          const v = e.tileAnchorPoint.add(new l.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let w = c.mult(f);
            a || (w = w.rotate(-h));
            const T = v.add(w);
            return nt(T.x, T.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
          }
          if (a) {
            const w = Le(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(p),
              T = Math.atan(w.y / w.x) + (w.x < 0 ? Math.PI : 0);
            return p.add(c.rotate(T))
          }
          return p.add(c)
        }

        function Ul(p, e, a, c, h, f, v, w, T, C, z, F) {
          const R = p.text.placedSymbolArray,
            U = p.text.dynamicLayoutVertexArray,
            Y = p.icon.dynamicLayoutVertexArray,
            ne = {};
          U.clear();
          for (let ie = 0; ie < R.length; ie++) {
            const ae = R.get(ie),
              me = ae.hidden || !ae.crossTileID || p.allowVerticalPlacement && !ae.placedOrientation ? null : c[ae.crossTileID];
            if (me) {
              const ke = new l.P(ae.anchorX, ae.anchorY),
                _e = {
                  getElevation: F,
                  width: h.width,
                  height: h.height,
                  pitchedLabelPlaneMatrix: f,
                  pitchWithMap: a,
                  transform: h,
                  tileAnchorPoint: ke,
                  translation: C,
                  unwrappedTileID: z
                },
                Te = a ? qt(ke.x, ke.y, _e) : Le(ke.x, ke.y, _e),
                Ee = cr(h.cameraToCenterDistance, Te.signedDistanceFromCamera);
              let ye = l.at(p.textSizeData, w, ae) * Ee / l.aF;
              a && (ye *= p.tilePixelRatio / v);
              const {
                width: Be,
                height: ht,
                anchor: at,
                textOffset: lt,
                textBoxScale: pt
              } = me, ur = od(at, Be, ht, lt, pt, ye), hr = h.getPitchedTextCorrection(ke.x + C[0], ke.y + C[1], z), Nt = Vl(Te.point, _e, e, ur, -h.bearingInRadians, hr), Ur = p.allowVerticalPlacement && ae.placedOrientation === l.as.vertical ? Math.PI / 2 : 0;
              for (let Tn = 0; Tn < ae.numGlyphs; Tn++) l.az(U, Nt, Ur);
              T && ae.associatedIconIndex >= 0 && (ne[ae.associatedIconIndex] = {
                shiftedAnchor: Nt,
                angle: Ur
              })
            } else tn(ae.numGlyphs, U)
          }
          if (T) {
            Y.clear();
            const ie = p.icon.placedSymbolArray;
            for (let ae = 0; ae < ie.length; ae++) {
              const me = ie.get(ae);
              if (me.hidden) tn(me.numGlyphs, Y);
              else {
                const ke = ne[ae];
                if (ke)
                  for (let _e = 0; _e < me.numGlyphs; _e++) l.az(Y, ke.shiftedAnchor, ke.angle);
                else tn(me.numGlyphs, Y)
              }
            }
            p.icon.dynamicLayoutVertexBuffer.updateData(Y)
          }
          p.text.dynamicLayoutVertexBuffer.updateData(U)
        }

        function Zl(p, e, a) {
          return a.iconsInText && e ? "symbolTextAndIcon" : p ? "symbolSDF" : "symbolIcon"
        }

        function Ko(p, e, a, c, h, f, v, w, T, C, z, F, R) {
          const U = p.context,
            Y = U.gl,
            ne = p.transform,
            ie = w === "map",
            ae = T === "map",
            me = w !== "viewport" && a.layout.get("symbol-placement") !== "point",
            ke = ie && !ae && !me,
            _e = !a.layout.get("symbol-sort-key").isConstant();
          let Te = !1;
          const Ee = p.getDepthModeForSublayer(0, dn.ReadOnly),
            ye = a._unevaluatedLayout.hasValue("text-variable-anchor") || a._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
            Be = [],
            ht = ne.getCircleRadiusCorrection();
          for (const at of c) {
            const lt = e.getTile(at),
              pt = lt.getBucket(a);
            if (!pt) continue;
            const ur = h ? pt.text : pt.icon;
            if (!ur || !ur.segments.get().length || !ur.hasVisibleVertices) continue;
            const hr = ur.programConfigurations.get(a.id),
              Nt = h || pt.sdfIcons,
              Ur = h ? pt.textSizeData : pt.iconSizeData,
              Tn = ae || ne.pitch !== 0,
              Hn = p.useProgram(Zl(Nt, h, pt), hr),
              zn = l.ar(Ur, ne.zoom),
              ei = p.style.map.terrain && p.style.map.terrain.getTerrainData(at);
            let _i, ni, Ai, hi, Oi = [0, 0],
              di = null;
            if (h) ni = lt.glyphAtlasTexture, Ai = Y.LINEAR, _i = lt.glyphAtlasTexture.size, pt.iconsInText && (Oi = lt.imageAtlasTexture.size, di = lt.imageAtlasTexture, hi = Tn || p.options.rotating || p.options.zooming || Ur.kind === "composite" || Ur.kind === "camera" ? Y.LINEAR : Y.NEAREST);
            else {
              const Ii = a.layout.get("icon-size").constantOr(0) !== 1 || pt.iconsNeedLinear;
              ni = lt.imageAtlasTexture, Ai = Nt || p.options.rotating || p.options.zooming || Ii || Tn ? Y.LINEAR : Y.NEAREST, _i = lt.imageAtlasTexture.size
            }
            const Mi = l.aG(lt, 1, p.transform.zoom),
              da = ir(ie, p.transform, Mi),
              ns = l.M();
            l.au(ns, da);
            const yo = Fr(ae, ie, p.transform, Mi),
              io = l.aH(ne, lt, f, v),
              is = ne.getProjectionData({
                overscaledTileID: at,
                applyGlobeMatrix: !R,
                applyTerrainMatrix: !0
              }),
              Es = ye && pt.hasTextData(),
              as = a.layout.get("icon-text-fit") !== "none" && Es && pt.hasIconData();
            if (me) {
              const Ii = p.style.map.terrain ? (qi, oi) => p.style.map.terrain.getElevation(at, qi, oi) : null,
                ki = a.layout.get("text-rotation-alignment") === "map";
              Ar(pt, p, h, da, ns, ae, C, ki, at.toUnwrapped(), ne.width, ne.height, io, Ii)
            }
            const ba = h && ye || as,
              pa = me || ba ? su : ae ? da : p.transform.clipSpaceToPixelsMatrix,
              xo = Nt && a.paint.get(h ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Lo;
            Lo = Nt ? pt.iconsInText ? po(Ur.kind, zn, ke, ae, me, ba, p, pa, yo, io, _i, Oi, ht) : Hs(Ur.kind, zn, ke, ae, me, ba, p, pa, yo, io, h, _i, 0, ht) : Jc(Ur.kind, zn, ke, ae, me, ba, p, pa, yo, io, h, _i, ht);
            const ll = {
              program: Hn,
              buffers: ur,
              uniformValues: Lo,
              projectionData: is,
              atlasTexture: ni,
              atlasTextureIcon: di,
              atlasInterpolation: Ai,
              atlasInterpolationIcon: hi,
              isSDF: Nt,
              hasHalo: xo
            };
            if (_e && pt.canOverlap) {
              Te = !0;
              const Ii = ur.segments.get();
              for (const ki of Ii) Be.push({
                segments: new l.aQ([ki]),
                sortKey: ki.sortKey,
                state: ll,
                terrainData: ei
              })
            } else Be.push({
              segments: ur.segments,
              sortKey: 0,
              state: ll,
              terrainData: ei
            })
          }
          Te && Be.sort(((at, lt) => at.sortKey - lt.sortKey));
          for (const at of Be) {
            const lt = at.state;
            if (U.activeTexture.set(Y.TEXTURE0), lt.atlasTexture.bind(lt.atlasInterpolation, Y.CLAMP_TO_EDGE), lt.atlasTextureIcon && (U.activeTexture.set(Y.TEXTURE1), lt.atlasTextureIcon && lt.atlasTextureIcon.bind(lt.atlasInterpolationIcon, Y.CLAMP_TO_EDGE)), lt.isSDF) {
              const pt = lt.uniformValues;
              lt.hasHalo && (pt.u_is_halo = 1, Gl(lt.buffers, at.segments, a, p, lt.program, Ee, z, F, pt, lt.projectionData, at.terrainData)), pt.u_is_halo = 0
            }
            Gl(lt.buffers, at.segments, a, p, lt.program, Ee, z, F, lt.uniformValues, lt.projectionData, at.terrainData)
          }
        }

        function Gl(p, e, a, c, h, f, v, w, T, C, z) {
          const F = c.context;
          h.draw(F, F.gl.TRIANGLES, f, v, w, ln.backCCW, T, z, C, a.id, p.layoutVertexBuffer, p.indexBuffer, e, a.paint, c.transform.zoom, p.programConfigurations.get(a.id), p.dynamicLayoutVertexBuffer, p.opacityVertexBuffer)
        }

        function af(p, e, a, c, h) {
          const f = p.context,
            v = f.gl,
            w = An.disabled,
            T = new an([v.ONE, v.ONE], l.bi.transparent, [!0, !0, !0, !0]),
            C = e.getBucket(a);
          if (!C) return;
          const z = c.key;
          let F = a.heatmapFbos.get(z);
          F || (F = sd(f, e.tileSize, e.tileSize), a.heatmapFbos.set(z, F)), f.bindFramebuffer.set(F.framebuffer), f.viewport.set([0, 0, e.tileSize, e.tileSize]), f.clear({
            color: l.bi.transparent
          });
          const R = C.programConfigurations.get(a.id),
            U = p.useProgram("heatmap", R, !h),
            Y = p.transform.getProjectionData({
              overscaledTileID: e.tileID,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }),
            ne = p.style.map.terrain.getTerrainData(c);
          U.draw(f, v.TRIANGLES, dn.disabled, w, T, ln.disabled, Hc(e, p.transform.zoom, a.paint.get("heatmap-intensity"), 1), ne, Y, a.id, C.layoutVertexBuffer, C.indexBuffer, C.segments, a.paint, p.transform.zoom, R)
        }

        function Js(p, e, a, c, h) {
          const f = p.context,
            v = f.gl,
            w = p.transform;
          f.setColorMode(p.colorModeForRenderPass());
          const T = lu(f, e),
            C = a.key,
            z = e.heatmapFbos.get(C);
          if (!z) return;
          f.activeTexture.set(v.TEXTURE0), v.bindTexture(v.TEXTURE_2D, z.colorAttachment.get()), f.activeTexture.set(v.TEXTURE1), T.bind(v.LINEAR, v.CLAMP_TO_EDGE);
          const F = w.getProjectionData({
            overscaledTileID: a,
            applyTerrainMatrix: h,
            applyGlobeMatrix: !c
          });
          p.useProgram("heatmapTexture").draw(f, v.TRIANGLES, dn.disabled, An.disabled, p.colorModeForRenderPass(), ln.disabled, Xc(p, e, 0, 1), null, F, e.id, p.rasterBoundsBuffer, p.quadTriangleIndexBuffer, p.rasterBoundsSegments, e.paint, w.zoom), z.destroy(), e.heatmapFbos.delete(C)
        }

        function sd(p, e, a) {
          var c, h;
          const f = p.gl,
            v = f.createTexture();
          f.bindTexture(f.TEXTURE_2D, v), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.LINEAR), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.LINEAR);
          const w = (c = p.HALF_FLOAT) !== null && c !== void 0 ? c : f.UNSIGNED_BYTE,
            T = (h = p.RGBA16F) !== null && h !== void 0 ? h : f.RGBA;
          f.texImage2D(f.TEXTURE_2D, 0, T, e, a, 0, f.RGBA, w, null);
          const C = p.createFramebuffer(e, a, !1, !1);
          return C.colorAttachment.set(v), C
        }

        function lu(p, e) {
          return e.colorRampTexture || (e.colorRampTexture = new l.T(p, e.colorRamp, p.gl.RGBA)), e.colorRampTexture
        }

        function Qs(p, e, a, c, h, f, v, w) {
          let T = 256;
          if (h.stepInterpolant) {
            const C = e.getSource().maxzoom,
              z = v.canonical.z === C ? Math.ceil(1 << p.transform.maxZoom - v.canonical.z) : 1;
            T = l.ai(l.c7(f.maxLineLength / l.a3 * 1024 * z), 256, a.maxTextureSize)
          }
          return w.gradient = l.c8({
            expression: h.gradientExpression(),
            evaluationKey: "lineProgress",
            resolution: T,
            image: w.gradient || void 0,
            clips: f.lineClipsArray
          }), w.texture ? w.texture.update(w.gradient) : w.texture = new l.T(a, w.gradient, c.RGBA), w.version = h.gradientVersion, w.texture
        }

        function cu(p, e, a, c, h) {
          p.activeTexture.set(e.TEXTURE0), a.imageAtlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE), c.updatePaintBuffers(h)
        }

        function ld(p, e, a, c, h, f) {
          (h || p.lineAtlas.dirty) && (e.activeTexture.set(a.TEXTURE0), p.lineAtlas.bind(e)), c.updatePaintBuffers(f)
        }

        function cd(p, e, a, c, h, f, v) {
          const w = f.gradients[h.id];
          let T = w.texture;
          h.gradientVersion !== w.version && (T = Qs(p, e, a, c, h, f, v, w)), a.activeTexture.set(c.TEXTURE0), T.bind(h.stepInterpolant ? c.NEAREST : c.LINEAR, c.CLAMP_TO_EDGE)
        }

        function $l(p, e, a, c, h, f, v, w, T) {
          const C = f.gradients[h.id];
          let z = C.texture;
          h.gradientVersion !== C.version && (z = Qs(p, e, a, c, h, f, v, C)), a.activeTexture.set(c.TEXTURE0), z.bind(h.stepInterpolant ? c.NEAREST : c.LINEAR, c.CLAMP_TO_EDGE), a.activeTexture.set(c.TEXTURE1), p.lineAtlas.bind(a), w.updatePaintBuffers(T)
        }

        function Wl(p, e, a, c, h) {
          if (!a || !c || !c.imageAtlas) return;
          const f = c.imageAtlas.patternPositions;
          let v = f[a.to.toString()],
            w = f[a.from.toString()];
          if (!v && w && (v = w), !w && v && (w = v), !v || !w) {
            const T = h.getPaintProperty(e);
            v = f[T], w = f[T]
          }
          v && w && p.setConstantPatternPositions(v, w)
        }

        function ud(p, e, a, c, h, f, v, w) {
          const T = p.context.gl,
            C = "fill-pattern",
            z = a.paint.get(C),
            F = z && z.constantOr(1),
            R = a.getCrossfadeParameters();
          let U, Y, ne, ie, ae;
          const me = p.transform,
            ke = a.paint.get("fill-translate"),
            _e = a.paint.get("fill-translate-anchor");
          v ? (Y = F && !a.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", U = T.LINES) : (Y = F ? "fillPattern" : "fill", U = T.TRIANGLES);
          const Te = z.constantOr(null);
          for (const Ee of c) {
            const ye = e.getTile(Ee);
            if (F && !ye.patternsLoaded()) continue;
            const Be = ye.getBucket(a);
            if (!Be) continue;
            const ht = Be.programConfigurations.get(a.id),
              at = p.useProgram(Y, ht),
              lt = p.style.map.terrain && p.style.map.terrain.getTerrainData(Ee);
            F && (p.context.activeTexture.set(T.TEXTURE0), ye.imageAtlasTexture.bind(T.LINEAR, T.CLAMP_TO_EDGE), ht.updatePaintBuffers(R)), Wl(ht, C, Te, ye, a);
            const pt = me.getProjectionData({
                overscaledTileID: Ee,
                applyGlobeMatrix: !w,
                applyTerrainMatrix: !0
              }),
              ur = l.aH(me, ye, ke, _e);
            if (v) {
              ie = Be.indexBuffer2, ae = Be.segments2;
              const Nt = [T.drawingBufferWidth, T.drawingBufferHeight];
              ne = Y === "fillOutlinePattern" && F ? Zh(p, R, ye, Nt, ur) : $p(Nt, ur)
            } else ie = Be.indexBuffer, ae = Be.segments, ne = F ? Zo(p, R, ye, ur) : {
              u_fill_translate: ur
            };
            const hr = p.stencilModeForClipping(Ee);
            at.draw(p.context, U, h, hr, f, ln.backCCW, ne, lt, pt, a.id, Be.layoutVertexBuffer, ie, ae, a.paint, p.transform.zoom, ht)
          }
        }

        function Hl(p, e, a, c, h, f, v, w) {
          const T = p.context,
            C = T.gl,
            z = "fill-extrusion-pattern",
            F = a.paint.get(z),
            R = F.constantOr(1),
            U = a.getCrossfadeParameters(),
            Y = a.paint.get("fill-extrusion-opacity"),
            ne = F.constantOr(null),
            ie = p.transform;
          for (const ae of c) {
            const me = e.getTile(ae),
              ke = me.getBucket(a);
            if (!ke) continue;
            const _e = p.style.map.terrain && p.style.map.terrain.getTerrainData(ae),
              Te = ke.programConfigurations.get(a.id),
              Ee = p.useProgram(R ? "fillExtrusionPattern" : "fillExtrusion", Te);
            R && (p.context.activeTexture.set(C.TEXTURE0), me.imageAtlasTexture.bind(C.LINEAR, C.CLAMP_TO_EDGE), Te.updatePaintBuffers(U));
            const ye = ie.getProjectionData({
              overscaledTileID: ae,
              applyGlobeMatrix: !w,
              applyTerrainMatrix: !0
            });
            Wl(Te, z, ne, me, a);
            const Be = l.aH(ie, me, a.paint.get("fill-extrusion-translate"), a.paint.get("fill-extrusion-translate-anchor")),
              ht = a.paint.get("fill-extrusion-vertical-gradient"),
              at = R ? Gp(p, ht, Y, Be, ae, U, me) : Ws(p, ht, Y, Be);
            Ee.draw(T, T.gl.TRIANGLES, h, f, v, ln.backCCW, at, _e, ye, a.id, ke.layoutVertexBuffer, ke.indexBuffer, ke.segments, a.paint, p.transform.zoom, Te, p.style.map.terrain && ke.centroidVertexBuffer)
          }
        }

        function pi(p, e, a, c, h, f, v, w, T) {
          var C;
          const z = p.style.projection,
            F = p.context,
            R = p.transform,
            U = F.gl,
            Y = [`#define NUM_ILLUMINATION_SOURCES ${a.paint.get("hillshade-highlight-color").values.length}`],
            ne = p.useProgram("hillshade", null, !1, Y),
            ie = !p.options.moving;
          for (const ae of c) {
            const me = e.getTile(ae),
              ke = me.fbo;
            if (!ke) continue;
            const _e = z.getMeshFromTileID(F, ae.canonical, w, !0, "raster"),
              Te = (C = p.style.map.terrain) === null || C === void 0 ? void 0 : C.getTerrainData(ae);
            F.activeTexture.set(U.TEXTURE0), U.bindTexture(U.TEXTURE_2D, ke.colorAttachment.get());
            const Ee = R.getProjectionData({
              overscaledTileID: ae,
              aligned: ie,
              applyGlobeMatrix: !T,
              applyTerrainMatrix: !0
            });
            ne.draw(F, U.TRIANGLES, f, h[ae.overscaledZ], v, ln.backCCW, $h(p, me, a), Te, Ee, a.id, _e.vertexBuffer, _e.indexBuffer, _e.segments)
          }
        }

        function fo(p, e, a, c, h, f, v, w, T) {
          var C;
          const z = p.style.projection,
            F = p.context,
            R = p.transform,
            U = F.gl,
            Y = p.useProgram("colorRelief"),
            ne = !p.options.moving;
          let ie = !0,
            ae = 0;
          for (const me of c) {
            const ke = e.getTile(me),
              _e = ke.dem;
            if (ie) {
              const at = U.getParameter(U.MAX_TEXTURE_SIZE),
                {
                  elevationTexture: lt,
                  colorTexture: pt
                } = a.getColorRampTextures(F, at, _e.getUnpackVector());
              F.activeTexture.set(U.TEXTURE1), lt.bind(U.NEAREST, U.CLAMP_TO_EDGE), F.activeTexture.set(U.TEXTURE4), pt.bind(U.LINEAR, U.CLAMP_TO_EDGE), ie = !1, ae = lt.size[0]
            }
            if (!_e || !_e.data) continue;
            const Te = _e.stride,
              Ee = _e.getPixels();
            if (F.activeTexture.set(U.TEXTURE0), F.pixelStoreUnpackPremultiplyAlpha.set(!1), ke.demTexture = ke.demTexture || p.getTileTexture(Te), ke.demTexture) {
              const at = ke.demTexture;
              at.update(Ee, {
                premultiply: !1
              }), at.bind(U.LINEAR, U.CLAMP_TO_EDGE)
            } else ke.demTexture = new l.T(F, Ee, U.RGBA, {
              premultiply: !1
            }), ke.demTexture.bind(U.LINEAR, U.CLAMP_TO_EDGE);
            const ye = z.getMeshFromTileID(F, me.canonical, w, !0, "raster"),
              Be = (C = p.style.map.terrain) === null || C === void 0 ? void 0 : C.getTerrainData(me),
              ht = R.getProjectionData({
                overscaledTileID: me,
                aligned: ne,
                applyGlobeMatrix: !T,
                applyTerrainMatrix: !0
              });
            Y.draw(F, U.TRIANGLES, f, h[me.overscaledZ], v, ln.backCCW, Hh(a, ke.dem, ae), Be, ht, a.id, ye.vertexBuffer, ye.indexBuffer, ye.segments)
          }
        }
        const ya = [new l.P(0, 0), new l.P(l.a3, 0), new l.P(l.a3, l.a3), new l.P(0, l.a3)];

        function Ps(p, e, a, c, h, f, v, w, T = !1, C = !1) {
          const z = c[c.length - 1].overscaledZ,
            F = p.context,
            R = F.gl,
            U = p.useProgram("raster"),
            Y = p.transform,
            ne = p.style.projection,
            ie = p.colorModeForRenderPass(),
            ae = !p.options.moving,
            me = a.paint.get("raster-opacity"),
            ke = a.paint.get("raster-resampling"),
            _e = a.paint.get("raster-fade-duration"),
            Te = !!p.style.map.terrain;
          for (const Ee of c) {
            const ye = p.getDepthModeForSublayer(Ee.overscaledZ - z, me === 1 ? dn.ReadWrite : dn.ReadOnly, R.LESS),
              Be = e.getTile(Ee),
              ht = ke === "nearest" ? R.NEAREST : R.LINEAR;
            F.activeTexture.set(R.TEXTURE0), Be.texture.bind(ht, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), F.activeTexture.set(R.TEXTURE1);
            const {
              parentTile: at,
              parentScaleBy: lt,
              parentTopLeft: pt,
              fadeValues: ur
            } = Xl(Be, e, _e, Te);
            Be.fadeOpacity = ur.tileOpacity, at ? (at.fadeOpacity = ur.parentTileOpacity, at.texture.bind(ht, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST)) : Be.texture.bind(ht, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), Be.texture.useMipmap && F.extTextureFilterAnisotropic && p.transform.pitch > 20 && R.texParameterf(R.TEXTURE_2D, F.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, F.extTextureFilterAnisotropicMax);
            const hr = p.style.map.terrain && p.style.map.terrain.getTerrainData(Ee),
              Nt = Y.getProjectionData({
                overscaledTileID: Ee,
                aligned: ae,
                applyGlobeMatrix: !C,
                applyTerrainMatrix: !0
              }),
              Ur = Xh(pt, lt, ur.fadeMix, a, w),
              Tn = ne.getMeshFromTileID(F, Ee.canonical, f, v, "raster");
            U.draw(F, R.TRIANGLES, ye, h ? h[Ee.overscaledZ] : An.disabled, ie, T ? ln.frontCCW : ln.backCCW, Ur, hr, Nt, a.id, Tn.vertexBuffer, Tn.indexBuffer, Tn.segments)
          }
        }

        function Xl(p, e, a, c) {
          const h = {
            parentTile: null,
            parentScaleBy: 1,
            parentTopLeft: [0, 0],
            fadeValues: {
              tileOpacity: 1,
              parentTileOpacity: 1,
              fadeMix: {
                opacity: 1,
                mix: 0
              }
            }
          };
          if (a === 0 || c) return h;
          if (p.fadingParentID) {
            const f = e.getLoadedTile(p.fadingParentID);
            if (!f) return h;
            const v = Math.pow(2, f.tileID.overscaledZ - p.tileID.overscaledZ),
              w = [p.tileID.canonical.x * v % 1, p.tileID.canonical.y * v % 1],
              T = (function(C, z, F) {
                const R = fe(),
                  U = (R - z.timeAdded) / F,
                  Y = C.fadingDirection === te.Incoming,
                  ne = l.ai((R - C.timeAdded) / F, 0, 1),
                  ie = l.ai(1 - U, 0, 1),
                  ae = Y ? ne : ie;
                return {
                  tileOpacity: ae,
                  parentTileOpacity: Y ? ie : ne,
                  fadeMix: {
                    opacity: 1,
                    mix: 1 - ae
                  }
                }
              })(p, f, a);
            return {
              parentTile: f,
              parentScaleBy: v,
              parentTopLeft: w,
              fadeValues: T
            }
          }
          if (p.selfFading) {
            const f = (function(v, w) {
              const T = (fe() - v.timeAdded) / w,
                C = l.ai(T, 0, 1);
              return {
                tileOpacity: C,
                fadeMix: {
                  opacity: C,
                  mix: 0
                }
              }
            })(p, a);
            return {
              parentTile: null,
              parentScaleBy: 1,
              parentTopLeft: [0, 0],
              fadeValues: f
            }
          }
          return h
        }
        const hd = new l.bi(1, 0, 0, 1),
          Ss = new l.bi(0, 1, 0, 1),
          uu = new l.bi(0, 0, 1, 1),
          el = new l.bi(1, 0, 1, 1),
          hu = new l.bi(0, 1, 1, 1);

        function du(p, e, a, c) {
          tl(p, 0, e + a / 2, p.transform.width, a, c)
        }

        function pu(p, e, a, c) {
          tl(p, e - a / 2, 0, a, p.transform.height, c)
        }

        function tl(p, e, a, c, h, f) {
          const v = p.context,
            w = v.gl;
          w.enable(w.SCISSOR_TEST), w.scissor(e * p.pixelRatio, a * p.pixelRatio, c * p.pixelRatio, h * p.pixelRatio), v.clear({
            color: f
          }), w.disable(w.SCISSOR_TEST)
        }

        function dd(p, e, a) {
          const c = p.context,
            h = c.gl,
            f = p.useProgram("debug"),
            v = dn.disabled,
            w = An.disabled,
            T = p.colorModeForRenderPass(),
            C = "$debug",
            z = p.style.map.terrain && p.style.map.terrain.getTerrainData(a);
          c.activeTexture.set(h.TEXTURE0);
          const F = e.getTileByID(a.key).latestRawTileData,
            R = Math.floor((F && F.byteLength || 0) / 1024),
            U = e.getTile(a).tileSize,
            Y = 512 / Math.min(U, 512) * (a.overscaledZ / p.transform.zoom) * .5;
          let ne = a.canonical.toString();
          a.overscaledZ !== a.canonical.z && (ne += ` => ${a.overscaledZ}`), (function(ae, me) {
            ae.initDebugOverlayCanvas();
            const ke = ae.debugOverlayCanvas,
              _e = ae.context.gl,
              Te = ae.debugOverlayCanvas.getContext("2d");
            Te.clearRect(0, 0, ke.width, ke.height), Te.shadowColor = "white", Te.shadowBlur = 2, Te.lineWidth = 1.5, Te.strokeStyle = "white", Te.textBaseline = "top", Te.font = "bold 36px Open Sans, sans-serif", Te.fillText(me, 5, 5), Te.strokeText(me, 5, 5), ae.debugOverlayTexture.update(ke), ae.debugOverlayTexture.bind(_e.LINEAR, _e.CLAMP_TO_EDGE)
          })(p, `${ne} ${R}kB`);
          const ie = p.transform.getProjectionData({
            overscaledTileID: a,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0
          });
          f.draw(c, h.TRIANGLES, v, w, an.alphaBlended, ln.disabled, Wc(l.bi.transparent, Y), null, ie, C, p.debugBuffer, p.quadTriangleIndexBuffer, p.debugSegments), f.draw(c, h.LINE_STRIP, v, w, T, ln.disabled, Wc(l.bi.red), z, ie, C, p.debugBuffer, p.tileBorderIndexBuffer, p.debugSegments)
        }

        function fu(p, e, a, c) {
          const {
            isRenderingGlobe: h
          } = c, f = p.context, v = f.gl, w = p.transform, T = p.colorModeForRenderPass(), C = p.getDepthModeFor3D(), z = p.useProgram("terrain");
          f.bindFramebuffer.set(null), f.viewport.set([0, 0, p.width, p.height]);
          for (const F of a) {
            const R = e.getTerrainMesh(F.tileID),
              U = p.renderToTexture.getTexture(F),
              Y = e.getTerrainData(F.tileID);
            f.activeTexture.set(v.TEXTURE0), v.bindTexture(v.TEXTURE_2D, U.texture);
            const ne = e.getMeshFrameDelta(w.zoom),
              ie = w.calculateFogMatrix(F.tileID.toUnwrapped()),
              ae = Zp(ne, ie, p.style.sky, w.pitch, h),
              me = w.getProjectionData({
                overscaledTileID: F.tileID,
                applyTerrainMatrix: !1,
                applyGlobeMatrix: !0
              });
            z.draw(f, v.TRIANGLES, C, An.disabled, T, ln.backCCW, ae, Y, me, "terrain", R.vertexBuffer, R.indexBuffer, R.segments)
          }
        }

        function Eo(p, e) {
          if (!e.mesh) {
            const a = new l.aP;
            a.emplaceBack(-1, -1), a.emplaceBack(1, -1), a.emplaceBack(1, 1), a.emplaceBack(-1, 1);
            const c = new l.aR;
            c.emplaceBack(0, 1, 2), c.emplaceBack(0, 2, 3), e.mesh = new Fn(p.createVertexBuffer(a, Rn.members), p.createIndexBuffer(c), l.aQ.simpleSegment(0, 0, a.length, c.length))
          }
          return e.mesh
        }
        class pd {
          constructor(e, a) {
            this.context = new Nl(e), this.transform = a, this._tileTextures = {}, this.terrainFacilitator = {
              dirty: !0,
              matrix: l.am(new Float64Array(16)),
              renderTime: 0
            }, this.setup(), this.numSublayers = Dt.maxUnderzooming + Dt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Zt
          }
          resize(e, a, c) {
            if (this.width = Math.floor(e * c), this.height = Math.floor(a * c), this.pixelRatio = c, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const h of this.style._order) this.style._layers[h].resize()
          }
          setup() {
            const e = this.context,
              a = new l.aP;
            a.emplaceBack(0, 0), a.emplaceBack(l.a3, 0), a.emplaceBack(0, l.a3), a.emplaceBack(l.a3, l.a3), this.tileExtentBuffer = e.createVertexBuffer(a, Rn.members), this.tileExtentSegments = l.aQ.simpleSegment(0, 0, 4, 2);
            const c = new l.aP;
            c.emplaceBack(0, 0), c.emplaceBack(l.a3, 0), c.emplaceBack(0, l.a3), c.emplaceBack(l.a3, l.a3), this.debugBuffer = e.createVertexBuffer(c, Rn.members), this.debugSegments = l.aQ.simpleSegment(0, 0, 4, 5);
            const h = new l.ca;
            h.emplaceBack(0, 0, 0, 0), h.emplaceBack(l.a3, 0, l.a3, 0), h.emplaceBack(0, l.a3, 0, l.a3), h.emplaceBack(l.a3, l.a3, l.a3, l.a3), this.rasterBoundsBuffer = e.createVertexBuffer(h, Zc.members), this.rasterBoundsSegments = l.aQ.simpleSegment(0, 0, 4, 2);
            const f = new l.aP;
            f.emplaceBack(0, 0), f.emplaceBack(l.a3, 0), f.emplaceBack(0, l.a3), f.emplaceBack(l.a3, l.a3), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(f, Rn.members), this.rasterBoundsSegmentsPosOnly = l.aQ.simpleSegment(0, 0, 4, 5);
            const v = new l.aP;
            v.emplaceBack(0, 0), v.emplaceBack(1, 0), v.emplaceBack(0, 1), v.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(v, Rn.members), this.viewportSegments = l.aQ.simpleSegment(0, 0, 4, 2);
            const w = new l.cb;
            w.emplaceBack(0), w.emplaceBack(1), w.emplaceBack(3), w.emplaceBack(2), w.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(w);
            const T = new l.aR;
            T.emplaceBack(1, 0, 2), T.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(T);
            const C = this.context.gl;
            this.stencilClearMode = new An({
              func: C.ALWAYS,
              mask: 0
            }, 0, 255, C.ZERO, C.ZERO, C.ZERO), this.tileExtentMesh = new Fn(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments)
          }
          clearStencil() {
            const e = this.context,
              a = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const c = l.M();
            l.c0(c, 0, this.width, this.height, 0, 0, 1), l.O(c, c, [a.drawingBufferWidth, a.drawingBufferHeight, 0]);
            const h = {
              mainMatrix: c,
              tileMercatorCoords: [0, 0, 1, 1],
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: c
            };
            this.useProgram("clippingMask", null, !0).draw(e, a.TRIANGLES, dn.disabled, this.stencilClearMode, an.disabled, ln.disabled, null, null, h, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
          }
          _renderTileClippingMasks(e, a, c) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !a || !a.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + a.length > 256 && this.clearStencil();
            const h = this.context;
            h.setColorMode(an.disabled), h.setDepthMode(dn.disabled);
            const f = {};
            for (const v of a) f[v.key] = this.nextStencilID++;
            this._renderTileMasks(f, a, c, !0), this._renderTileMasks(f, a, c, !1), this._tileClippingMaskIDs = f
          }
          _renderTileMasks(e, a, c, h) {
            const f = this.context,
              v = f.gl,
              w = this.style.projection,
              T = this.transform,
              C = this.useProgram("clippingMask");
            for (const z of a) {
              const F = e[z.key],
                R = this.style.map.terrain && this.style.map.terrain.getTerrainData(z),
                U = w.getMeshFromTileID(this.context, z.canonical, h, !0, "stencil"),
                Y = T.getProjectionData({
                  overscaledTileID: z,
                  applyGlobeMatrix: !c,
                  applyTerrainMatrix: !0
                });
              C.draw(f, v.TRIANGLES, dn.disabled, new An({
                func: v.ALWAYS,
                mask: 0
              }, F, 255, v.KEEP, v.KEEP, v.REPLACE), an.disabled, c ? ln.disabled : ln.backCCW, null, R, Y, "$clipping", U.vertexBuffer, U.indexBuffer, U.segments)
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context,
              a = e.gl,
              c = this.style.projection,
              h = this.transform,
              f = this.useProgram("depth"),
              v = this.getDepthModeFor3D(),
              w = Je(h, {
                tileSize: h.tileSize
              });
            for (const T of w) {
              const C = this.style.map.terrain && this.style.map.terrain.getTerrainData(T),
                z = c.getMeshFromTileID(this.context, T.canonical, !0, !0, "raster"),
                F = h.getProjectionData({
                  overscaledTileID: T,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0
                });
              f.draw(e, a.TRIANGLES, v, An.disabled, an.disabled, ln.backCCW, null, C, F, "$clipping", z.vertexBuffer, z.indexBuffer, z.segments)
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++,
              a = this.context.gl;
            return new An({
              func: a.NOTEQUAL,
              mask: 255
            }, e, 255, a.KEEP, a.KEEP, a.REPLACE)
          }
          stencilModeForClipping(e) {
            const a = this.context.gl;
            return new An({
              func: a.EQUAL,
              mask: 255
            }, this._tileClippingMaskIDs[e.key], 0, a.KEEP, a.KEEP, a.REPLACE)
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const a = this.context.gl,
              c = e.sort(((v, w) => w.overscaledZ - v.overscaledZ)),
              h = c[c.length - 1].overscaledZ,
              f = c[0].overscaledZ - h + 1;
            if (f > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + f > 256 && this.clearStencil();
              const v = {};
              for (let w = 0; w < f; w++) v[w + h] = new An({
                func: a.GEQUAL,
                mask: 255
              }, w + this.nextStencilID, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID += f, [v, c]
            }
            return [{
              [h]: An.disabled
            }, c]
          }
          stencilConfigForOverlapTwoPass(e) {
            const a = this.context.gl,
              c = e.sort(((v, w) => w.overscaledZ - v.overscaledZ)),
              h = c[c.length - 1].overscaledZ,
              f = c[0].overscaledZ - h + 1;
            if (this.clearStencil(), f > 1) {
              const v = {},
                w = {};
              for (let T = 0; T < f; T++) v[T + h] = new An({
                func: a.GREATER,
                mask: 255
              }, f + 1 + T, 255, a.KEEP, a.KEEP, a.REPLACE), w[T + h] = new An({
                func: a.GREATER,
                mask: 255
              }, 1 + T, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID = 2 * f + 1, [v, w, c]
            }
            return this.nextStencilID = 3, [{
              [h]: new An({
                func: a.GREATER,
                mask: 255
              }, 2, 255, a.KEEP, a.KEEP, a.REPLACE)
            }, {
              [h]: new An({
                func: a.GREATER,
                mask: 255
              }, 1, 255, a.KEEP, a.KEEP, a.REPLACE)
            }, c]
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new an([e.CONSTANT_COLOR, e.ONE], new l.bi(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? an.unblended : an.alphaBlended
          }
          getDepthModeForSublayer(e, a, c) {
            if (!this.opaquePassEnabledForLayer()) return dn.disabled;
            const h = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new dn(c || this.context.gl.LEQUAL, a, [h, h])
          }
          getDepthModeFor3D() {
            return new dn(this.context.gl.LEQUAL, dn.ReadWrite, this.depthRangeFor3D)
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff
          }
          render(e, a) {
            var c, h;
            this.style = e, this.options = a, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(fe()), this.imageManager.beginFrame();
            const f = this.style._order,
              v = this.style.tileManagers,
              w = {},
              T = {},
              C = {},
              z = {
                isRenderingToTexture: !1,
                isRenderingGlobe: ((c = e.projection) === null || c === void 0 ? void 0 : c.transitionState) > 0
              };
            for (const R in v) {
              const U = v[R];
              U.used && U.prepare(this.context), w[R] = U.getVisibleCoordinates(!1), T[R] = w[R].slice().reverse(), C[R] = U.getVisibleCoordinates(!0).reverse()
            }
            this.opaquePassCutoff = 1 / 0;
            for (let R = 0; R < f.length; R++)
              if (this.style._layers[f[R]].is3D()) {
                this.opaquePassCutoff = R;
                break
              } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const R of f) {
              const U = this.style._layers[R];
              if (!U.hasOffscreenPass() || U.isHidden(this.transform.zoom)) continue;
              const Y = T[U.source];
              (U.type === "custom" || Y.length) && this.renderLayer(this, v[U.source], U, Y, z)
            }
            if ((h = this.style.projection) === null || h === void 0 || h.updateGPUdependent({
                context: this.context,
                useProgram: R => this.useProgram(R)
              }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({
                color: a.showOverdrawInspector ? l.bi.black : l.bi.transparent,
                depth: 1
              }), this.clearStencil(), this.style.sky && (function(R, U) {
                const Y = R.context,
                  ne = Y.gl,
                  ie = ((Ee, ye, Be) => {
                    const ht = Math.cos(ye.rollInRadians),
                      at = Math.sin(ye.rollInRadians),
                      lt = Xe(ye),
                      pt = ye.getProjectionData({
                        overscaledTileID: null,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                      }).projectionTransition;
                    return {
                      u_sky_color: Ee.properties.get("sky-color"),
                      u_horizon_color: Ee.properties.get("horizon-color"),
                      u_horizon: [(ye.width / 2 - lt * at) * Be, (ye.height / 2 + lt * ht) * Be],
                      u_horizon_normal: [-at, ht],
                      u_sky_horizon_blend: Ee.properties.get("sky-horizon-blend") * ye.height / 2 * Be,
                      u_sky_blend: pt
                    }
                  })(U, R.style.map.transform, R.pixelRatio),
                  ae = new dn(ne.LEQUAL, dn.ReadWrite, [0, 1]),
                  me = An.disabled,
                  ke = R.colorModeForRenderPass(),
                  _e = R.useProgram("sky"),
                  Te = Eo(Y, U);
                _e.draw(Y, ne.TRIANGLES, ae, me, ke, ln.disabled, ie, null, void 0, "sky", Te.vertexBuffer, Te.indexBuffer, Te.segments)
              })(this, this.style.sky), this._showOverdrawInspector = a.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = f.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const R = this.style._layers[f[this.currentLayer]],
                  U = v[R.source],
                  Y = w[R.source];
                this._renderTileClippingMasks(R, Y, !1), this.renderLayer(this, U, R, Y, z)
              }
            this.renderPass = "translucent";
            let F = !1;
            for (this.currentLayer = 0; this.currentLayer < f.length; this.currentLayer++) {
              const R = this.style._layers[f[this.currentLayer]],
                U = v[R.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(R, z)) continue;
              this.opaquePassEnabledForLayer() || F || (F = !0, z.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const Y = (R.type === "symbol" ? C : T)[R.source];
              this._renderTileClippingMasks(R, w[R.source], !!this.renderToTexture), this.renderLayer(this, U, R, Y, z)
            }
            if (z.isRenderingGlobe && (function(R, U, Y) {
                const ne = R.context,
                  ie = ne.gl,
                  ae = R.useProgram("atmosphere"),
                  me = new dn(ie.LEQUAL, dn.ReadOnly, [0, 1]),
                  ke = R.transform,
                  _e = (function(pt, ur) {
                    const hr = pt.properties.get("position"),
                      Nt = [-hr.x, -hr.y, -hr.z],
                      Ur = l.am(new Float64Array(16));
                    return pt.properties.get("anchor") === "map" && (l.b9(Ur, Ur, ur.rollInRadians), l.ba(Ur, Ur, -ur.pitchInRadians), l.b9(Ur, Ur, ur.bearingInRadians), l.ba(Ur, Ur, ur.center.lat * Math.PI / 180), l.bC(Ur, Ur, -ur.center.lng * Math.PI / 180)), l.c9(Nt, Nt, Ur), Nt
                  })(Y, R.transform),
                  Te = ke.getProjectionData({
                    overscaledTileID: null,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0
                  }),
                  Ee = U.properties.get("atmosphere-blend") * Te.projectionTransition;
                if (Ee === 0) return;
                const ye = ca(ke.worldSize, ke.center.lat),
                  Be = ke.inverseProjectionMatrix,
                  ht = new Float64Array(4);
                ht[3] = 1, l.aA(ht, ht, ke.modelViewProjectionMatrix), ht[0] /= ht[3], ht[1] /= ht[3], ht[2] /= ht[3], ht[3] = 1, l.aA(ht, ht, Be), ht[0] /= ht[3], ht[1] /= ht[3], ht[2] /= ht[3], ht[3] = 1;
                const at = ((pt, ur, hr, Nt, Ur) => ({
                    u_sun_pos: pt,
                    u_atmosphere_blend: ur,
                    u_globe_position: hr,
                    u_globe_radius: Nt,
                    u_inv_proj_matrix: Ur
                  }))(_e, Ee, [ht[0], ht[1], ht[2]], ye, Be),
                  lt = Eo(ne, U);
                ae.draw(ne, ie.TRIANGLES, me, An.disabled, an.alphaBlended, ln.disabled, at, null, null, "atmosphere", lt.vertexBuffer, lt.indexBuffer, lt.segments)
              })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const R = (function(U, Y) {
                let ne = null;
                const ie = Object.values(U._layers).flatMap((_e => _e.source && !_e.isHidden(Y) ? [U.tileManagers[_e.source]] : [])),
                  ae = ie.filter((_e => _e.getSource().type === "vector")),
                  me = ie.filter((_e => _e.getSource().type !== "vector")),
                  ke = _e => {
                    (!ne || ne.getSource().maxzoom < _e.getSource().maxzoom) && (ne = _e)
                  };
                return ae.forEach((_e => ke(_e))), ne || me.forEach((_e => ke(_e))), ne
              })(this.style, this.transform.zoom);
              R && (function(U, Y, ne) {
                for (let ie = 0; ie < ne.length; ie++) dd(U, Y, ne[ie])
              })(this, R, R.getVisibleCoordinates())
            }
            this.options.showPadding && (function(R) {
              const U = R.transform.padding;
              du(R, R.transform.height - (U.top || 0), 3, hd), du(R, U.bottom || 0, 3, Ss), pu(R, U.left || 0, 3, uu), pu(R, R.transform.width - (U.right || 0), 3, el);
              const Y = R.transform.centerPoint;
              (function(ne, ie, ae, me) {
                tl(ne, ie - 1, ae - 10, 2, 20, me), tl(ne, ie - 10, ae - 1, 20, 2, me)
              })(R, Y.x, R.transform.height - Y.y, hu)
            })(this), this.context.setDefault()
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const a = this.terrainFacilitator.matrix,
              c = this.transform.modelViewProjectionMatrix;
            let h = this.terrainFacilitator.dirty;
            h || (h = e ? !l.cc(a, c) : !l.cd(a, c)), h || (h = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), h && (l.ce(a, c), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(f, v) {
              const w = f.context,
                T = w.gl,
                C = f.transform,
                z = an.unblended,
                F = new dn(T.LEQUAL, dn.ReadWrite, [0, 1]),
                R = v.tileManager.getRenderableTiles(),
                U = f.useProgram("terrainDepth");
              w.bindFramebuffer.set(v.getFramebuffer("depth").framebuffer), w.viewport.set([0, 0, f.width / devicePixelRatio, f.height / devicePixelRatio]), w.clear({
                color: l.bi.transparent,
                depth: 1
              });
              for (const Y of R) {
                const ne = v.getTerrainMesh(Y.tileID),
                  ie = v.getTerrainData(Y.tileID),
                  ae = C.getProjectionData({
                    overscaledTileID: Y.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  }),
                  me = {
                    u_ele_delta: v.getMeshFrameDelta(C.zoom)
                  };
                U.draw(w, T.TRIANGLES, F, An.disabled, z, ln.backCCW, me, ie, ae, "terrain", ne.vertexBuffer, ne.indexBuffer, ne.segments)
              }
              w.bindFramebuffer.set(null), w.viewport.set([0, 0, f.width, f.height])
            })(this, this.style.map.terrain), (function(f, v) {
              const w = f.context,
                T = w.gl,
                C = f.transform,
                z = an.unblended,
                F = new dn(T.LEQUAL, dn.ReadWrite, [0, 1]),
                R = v.getCoordsTexture(),
                U = v.tileManager.getRenderableTiles(),
                Y = f.useProgram("terrainCoords");
              w.bindFramebuffer.set(v.getFramebuffer("coords").framebuffer), w.viewport.set([0, 0, f.width / devicePixelRatio, f.height / devicePixelRatio]), w.clear({
                color: l.bi.transparent,
                depth: 1
              }), v.coordsIndex = [];
              for (const ne of U) {
                const ie = v.getTerrainMesh(ne.tileID),
                  ae = v.getTerrainData(ne.tileID);
                w.activeTexture.set(T.TEXTURE0), T.bindTexture(T.TEXTURE_2D, R.texture);
                const me = {
                    u_terrain_coords_id: (255 - v.coordsIndex.length) / 255,
                    u_texture: 0,
                    u_ele_delta: v.getMeshFrameDelta(C.zoom)
                  },
                  ke = C.getProjectionData({
                    overscaledTileID: ne.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  });
                Y.draw(w, T.TRIANGLES, F, An.disabled, z, ln.backCCW, me, ae, ke, "terrain", ie.vertexBuffer, ie.indexBuffer, ie.segments), v.coordsIndex.push(ne.tileID.key)
              }
              w.bindFramebuffer.set(null), w.viewport.set([0, 0, f.width, f.height])
            })(this, this.style.map.terrain))
          }
          renderLayer(e, a, c, h, f) {
            c.isHidden(this.transform.zoom) || (c.type === "background" || c.type === "custom" || (h || []).length) && (this.id = c.id, l.cf(c) ? (function(v, w, T, C, z, F) {
              if (v.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: R
              } = F, U = An.disabled, Y = v.colorModeForRenderPass();
              (T._unevaluatedLayout.hasValue("text-variable-anchor") || T._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(ne, ie, ae, me, ke, _e, Te, Ee, ye) {
                const Be = ie.transform,
                  ht = ie.style.map.terrain,
                  at = ke === "map",
                  lt = _e === "map";
                for (const pt of ne) {
                  const ur = me.getTile(pt),
                    hr = ur.getBucket(ae);
                  if (!hr || !hr.text || !hr.text.segments.get().length) continue;
                  const Nt = l.ar(hr.textSizeData, Be.zoom),
                    Ur = l.aG(ur, 1, ie.transform.zoom),
                    Tn = ir(at, ie.transform, Ur),
                    Hn = ae.layout.get("icon-text-fit") !== "none" && hr.hasIconData();
                  if (Nt) {
                    const zn = Math.pow(2, Be.zoom - ur.tileID.overscaledZ),
                      ei = ht ? (_i, ni) => ht.getElevation(pt, _i, ni) : null;
                    Ul(hr, at, lt, ye, Be, Tn, zn, Nt, Hn, l.aH(Be, ur, Te, Ee), pt.toUnwrapped(), ei)
                  }
                }
              })(C, v, T, w, T.layout.get("text-rotation-alignment"), T.layout.get("text-pitch-alignment"), T.paint.get("text-translate"), T.paint.get("text-translate-anchor"), z), T.paint.get("icon-opacity").constantOr(1) !== 0 && Ko(v, w, T, C, !1, T.paint.get("icon-translate"), T.paint.get("icon-translate-anchor"), T.layout.get("icon-rotation-alignment"), T.layout.get("icon-pitch-alignment"), T.layout.get("icon-keep-upright"), U, Y, R), T.paint.get("text-opacity").constantOr(1) !== 0 && Ko(v, w, T, C, !0, T.paint.get("text-translate"), T.paint.get("text-translate-anchor"), T.layout.get("text-rotation-alignment"), T.layout.get("text-pitch-alignment"), T.layout.get("text-keep-upright"), U, Y, R), w.map.showCollisionBoxes && (Ks(v, w, T, C, !0), Ks(v, w, T, C, !1))
            })(e, a, c, h, this.style.placement.variableOffsets, f) : l.cg(c) ? (function(v, w, T, C, z) {
              if (v.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: F
              } = z, R = T.paint.get("circle-opacity"), U = T.paint.get("circle-stroke-width"), Y = T.paint.get("circle-stroke-opacity"), ne = !T.layout.get("circle-sort-key").isConstant();
              if (R.constantOr(1) === 0 && (U.constantOr(1) === 0 || Y.constantOr(1) === 0)) return;
              const ie = v.context,
                ae = ie.gl,
                me = v.transform,
                ke = v.getDepthModeForSublayer(0, dn.ReadOnly),
                _e = An.disabled,
                Te = v.colorModeForRenderPass(),
                Ee = [],
                ye = me.getCircleRadiusCorrection();
              for (let Be = 0; Be < C.length; Be++) {
                const ht = C[Be],
                  at = w.getTile(ht),
                  lt = at.getBucket(T);
                if (!lt) continue;
                const pt = T.paint.get("circle-translate"),
                  ur = T.paint.get("circle-translate-anchor"),
                  hr = l.aH(me, at, pt, ur),
                  Nt = lt.programConfigurations.get(T.id),
                  Ur = v.useProgram("circle", Nt),
                  Tn = lt.layoutVertexBuffer,
                  Hn = lt.indexBuffer,
                  zn = v.style.map.terrain && v.style.map.terrain.getTerrainData(ht),
                  ei = {
                    programConfiguration: Nt,
                    program: Ur,
                    layoutVertexBuffer: Tn,
                    indexBuffer: Hn,
                    uniformValues: Wp(v, at, T, hr, ye),
                    terrainData: zn,
                    projectionData: me.getProjectionData({
                      overscaledTileID: ht,
                      applyGlobeMatrix: !F,
                      applyTerrainMatrix: !0
                    })
                  };
                if (ne) {
                  const _i = lt.segments.get();
                  for (const ni of _i) Ee.push({
                    segments: new l.aQ([ni]),
                    sortKey: ni.sortKey,
                    state: ei
                  })
                } else Ee.push({
                  segments: lt.segments,
                  sortKey: 0,
                  state: ei
                })
              }
              ne && Ee.sort(((Be, ht) => Be.sortKey - ht.sortKey));
              for (const Be of Ee) {
                const {
                  programConfiguration: ht,
                  program: at,
                  layoutVertexBuffer: lt,
                  indexBuffer: pt,
                  uniformValues: ur,
                  terrainData: hr,
                  projectionData: Nt
                } = Be.state;
                at.draw(ie, ae.TRIANGLES, ke, _e, Te, ln.backCCW, ur, hr, Nt, T.id, lt, pt, Be.segments, T.paint, v.transform.zoom, ht)
              }
            })(e, a, c, h, f) : l.ch(c) ? (function(v, w, T, C, z) {
              if (T.paint.get("heatmap-opacity") === 0) return;
              const F = v.context,
                {
                  isRenderingToTexture: R,
                  isRenderingGlobe: U
                } = z;
              if (v.style.map.terrain) {
                for (const Y of C) {
                  const ne = w.getTile(Y);
                  w.hasRenderableParent(Y) || (v.renderPass === "offscreen" ? af(v, ne, T, Y, U) : v.renderPass === "translucent" && Js(v, T, Y, R, U))
                }
                F.viewport.set([0, 0, v.width, v.height])
              } else v.renderPass === "offscreen" ? (function(Y, ne, ie, ae) {
                const me = Y.context,
                  ke = me.gl,
                  _e = Y.transform,
                  Te = An.disabled,
                  Ee = new an([ke.ONE, ke.ONE], l.bi.transparent, [!0, !0, !0, !0]);
                (function(ye, Be, ht) {
                  const at = ye.gl;
                  ye.activeTexture.set(at.TEXTURE1), ye.viewport.set([0, 0, Be.width / 4, Be.height / 4]);
                  let lt = ht.heatmapFbos.get(l.c6);
                  lt ? (at.bindTexture(at.TEXTURE_2D, lt.colorAttachment.get()), ye.bindFramebuffer.set(lt.framebuffer)) : (lt = sd(ye, Be.width / 4, Be.height / 4), ht.heatmapFbos.set(l.c6, lt))
                })(me, Y, ie), me.clear({
                  color: l.bi.transparent
                });
                for (let ye = 0; ye < ae.length; ye++) {
                  const Be = ae[ye];
                  if (ne.hasRenderableParent(Be)) continue;
                  const ht = ne.getTile(Be),
                    at = ht.getBucket(ie);
                  if (!at) continue;
                  const lt = at.programConfigurations.get(ie.id),
                    pt = Y.useProgram("heatmap", lt),
                    ur = _e.getProjectionData({
                      overscaledTileID: Be,
                      applyGlobeMatrix: !0,
                      applyTerrainMatrix: !1
                    }),
                    hr = _e.getCircleRadiusCorrection();
                  pt.draw(me, ke.TRIANGLES, dn.disabled, Te, Ee, ln.backCCW, Hc(ht, _e.zoom, ie.paint.get("heatmap-intensity"), hr), null, ur, ie.id, at.layoutVertexBuffer, at.indexBuffer, at.segments, ie.paint, _e.zoom, lt)
                }
                me.viewport.set([0, 0, Y.width, Y.height])
              })(v, w, T, C) : v.renderPass === "translucent" && (function(Y, ne) {
                const ie = Y.context,
                  ae = ie.gl;
                ie.setColorMode(Y.colorModeForRenderPass());
                const me = ne.heatmapFbos.get(l.c6);
                me && (ie.activeTexture.set(ae.TEXTURE0), ae.bindTexture(ae.TEXTURE_2D, me.colorAttachment.get()), ie.activeTexture.set(ae.TEXTURE1), lu(ie, ne).bind(ae.LINEAR, ae.CLAMP_TO_EDGE), Y.useProgram("heatmapTexture").draw(ie, ae.TRIANGLES, dn.disabled, An.disabled, Y.colorModeForRenderPass(), ln.disabled, Xc(Y, ne, 0, 1), null, null, ne.id, Y.viewportBuffer, Y.quadTriangleIndexBuffer, Y.viewportSegments, ne.paint, Y.transform.zoom))
              })(v, T)
            })(e, a, c, h, f) : l.ci(c) ? (function(v, w, T, C, z) {
              if (v.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: F
              } = z, R = T.paint.get("line-opacity"), U = T.paint.get("line-width");
              if (R.constantOr(1) === 0 || U.constantOr(1) === 0) return;
              const Y = v.getDepthModeForSublayer(0, dn.ReadOnly),
                ne = v.colorModeForRenderPass(),
                ie = T.paint.get("line-dasharray"),
                ae = ie.constantOr(1),
                me = T.paint.get("line-pattern"),
                ke = me.constantOr(1),
                _e = T.paint.get("line-gradient"),
                Te = T.getCrossfadeParameters();
              let Ee;
              Ee = ke ? "linePattern" : ae && _e ? "lineGradientSDF" : ae ? "lineSDF" : _e ? "lineGradient" : "line";
              const ye = v.context,
                Be = ye.gl,
                ht = v.transform;
              let at = !0;
              for (const lt of C) {
                const pt = w.getTile(lt);
                if (ke && !pt.patternsLoaded()) continue;
                const ur = pt.getBucket(T);
                if (!ur) continue;
                const hr = ur.programConfigurations.get(T.id),
                  Nt = v.context.program.get(),
                  Ur = v.useProgram(Ee, hr),
                  Tn = at || Ur.program !== Nt,
                  Hn = v.style.map.terrain && v.style.map.terrain.getTerrainData(lt),
                  zn = me.constantOr(null),
                  ei = ie && ie.constantOr(null);
                if (zn && pt.imageAtlas) {
                  const Oi = pt.imageAtlas,
                    di = Oi.patternPositions[zn.to.toString()],
                    Mi = Oi.patternPositions[zn.from.toString()];
                  di && Mi && hr.setConstantPatternPositions(di, Mi)
                } else if (ei) {
                  const Oi = T.layout.get("line-cap") === "round",
                    di = v.lineAtlas.getDash(ei.to, Oi),
                    Mi = v.lineAtlas.getDash(ei.from, Oi);
                  hr.setConstantDashPositions(di, Mi)
                }
                const _i = ht.getProjectionData({
                    overscaledTileID: lt,
                    applyGlobeMatrix: !F,
                    applyTerrainMatrix: !0
                  }),
                  ni = ht.getPixelScale();
                let Ai;
                ke ? (Ai = zl(v, pt, T, ni, Te), cu(ye, Be, pt, hr, Te)) : ae && _e ? (Ai = Yp(v, pt, T, ni, Te, ur.lineClipsArray.length), $l(v, w, ye, Be, T, ur, lt, hr, Te)) : ae ? (Ai = Xp(v, pt, T, ni, Te), ld(v, ye, Be, hr, Tn, Te)) : _e ? (Ai = Hp(v, pt, T, ni, ur.lineClipsArray.length), cd(v, w, ye, Be, T, ur, lt)) : Ai = zo(v, pt, T, ni);
                const hi = v.stencilModeForClipping(lt);
                Ur.draw(ye, Be.TRIANGLES, Y, hi, ne, ln.disabled, Ai, Hn, _i, T.id, ur.layoutVertexBuffer, ur.indexBuffer, ur.segments, T.paint, v.transform.zoom, hr, ur.layoutVertexBuffer2), at = !1
              }
            })(e, a, c, h, f) : l.cj(c) ? (function(v, w, T, C, z) {
              const F = T.paint.get("fill-color"),
                R = T.paint.get("fill-opacity");
              if (R.constantOr(1) === 0) return;
              const {
                isRenderingToTexture: U
              } = z, Y = v.colorModeForRenderPass(), ne = T.paint.get("fill-pattern"), ie = v.opaquePassEnabledForLayer() && !ne.constantOr(1) && F.constantOr(l.bi.transparent).a === 1 && R.constantOr(0) === 1 ? "opaque" : "translucent";
              if (v.renderPass === ie) {
                const ae = v.getDepthModeForSublayer(1, v.renderPass === "opaque" ? dn.ReadWrite : dn.ReadOnly);
                ud(v, w, T, C, ae, Y, !1, U)
              }
              if (v.renderPass === "translucent" && T.paint.get("fill-antialias")) {
                const ae = v.getDepthModeForSublayer(T.getPaintProperty("fill-outline-color") ? 2 : 0, dn.ReadOnly);
                ud(v, w, T, C, ae, Y, !0, U)
              }
            })(e, a, c, h, f) : l.ck(c) ? (function(v, w, T, C, z) {
              const F = T.paint.get("fill-extrusion-opacity");
              if (F === 0) return;
              const {
                isRenderingToTexture: R
              } = z;
              if (v.renderPass === "translucent") {
                const U = new dn(v.context.gl.LEQUAL, dn.ReadWrite, v.depthRangeFor3D);
                if (F !== 1 || T.paint.get("fill-extrusion-pattern").constantOr(1)) Hl(v, w, T, C, U, An.disabled, an.disabled, R), Hl(v, w, T, C, U, v.stencilModeFor3D(), v.colorModeForRenderPass(), R);
                else {
                  const Y = v.colorModeForRenderPass();
                  Hl(v, w, T, C, U, An.disabled, Y, R)
                }
              }
            })(e, a, c, h, f) : l.cl(c) ? (function(v, w, T, C, z) {
              if (v.renderPass !== "offscreen" && v.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: F
              } = z, R = v.context, U = v.style.projection.useSubdivision, Y = v.getDepthModeForSublayer(0, dn.ReadOnly), ne = v.colorModeForRenderPass();
              if (v.renderPass === "offscreen")(function(ie, ae, me, ke, _e, Te, Ee) {
                const ye = ie.context,
                  Be = ye.gl;
                for (const ht of me) {
                  const at = ae.getTile(ht),
                    lt = at.dem;
                  if (!lt || !lt.data || !at.needsHillshadePrepare) continue;
                  const pt = lt.dim,
                    ur = lt.stride,
                    hr = lt.getPixels();
                  if (ye.activeTexture.set(Be.TEXTURE1), ye.pixelStoreUnpackPremultiplyAlpha.set(!1), at.demTexture = at.demTexture || ie.getTileTexture(ur), at.demTexture) {
                    const Ur = at.demTexture;
                    Ur.update(hr, {
                      premultiply: !1
                    }), Ur.bind(Be.NEAREST, Be.CLAMP_TO_EDGE)
                  } else at.demTexture = new l.T(ye, hr, Be.RGBA, {
                    premultiply: !1
                  }), at.demTexture.bind(Be.NEAREST, Be.CLAMP_TO_EDGE);
                  ye.activeTexture.set(Be.TEXTURE0);
                  let Nt = at.fbo;
                  if (!Nt) {
                    const Ur = new l.T(ye, {
                      width: pt,
                      height: pt,
                      data: null
                    }, Be.RGBA);
                    Ur.bind(Be.LINEAR, Be.CLAMP_TO_EDGE), Nt = at.fbo = ye.createFramebuffer(pt, pt, !0, !1), Nt.colorAttachment.set(Ur.texture)
                  }
                  ye.bindFramebuffer.set(Nt.framebuffer), ye.viewport.set([0, 0, pt, pt]), ie.useProgram("hillshadePrepare").draw(ye, Be.TRIANGLES, _e, Te, Ee, ln.disabled, Go(at.tileID, lt), null, null, ke.id, ie.rasterBoundsBuffer, ie.quadTriangleIndexBuffer, ie.rasterBoundsSegments), at.needsHillshadePrepare = !1
                }
              })(v, w, C, T, Y, An.disabled, ne), R.viewport.set([0, 0, v.width, v.height]);
              else if (v.renderPass === "translucent")
                if (U) {
                  const [ie, ae, me] = v.stencilConfigForOverlapTwoPass(C);
                  pi(v, w, T, me, ie, Y, ne, !1, F), pi(v, w, T, me, ae, Y, ne, !0, F)
                } else {
                  const [ie, ae] = v.getStencilConfigForOverlapAndUpdateStencilID(C);
                  pi(v, w, T, ae, ie, Y, ne, !1, F)
                }
            })(e, a, c, h, f) : l.cm(c) ? (function(v, w, T, C, z) {
              if (v.renderPass !== "translucent" || !C.length) return;
              const {
                isRenderingToTexture: F
              } = z, R = v.style.projection.useSubdivision, U = v.getDepthModeForSublayer(0, dn.ReadOnly), Y = v.colorModeForRenderPass();
              if (R) {
                const [ne, ie, ae] = v.stencilConfigForOverlapTwoPass(C);
                fo(v, w, T, ae, ne, U, Y, !1, F), fo(v, w, T, ae, ie, U, Y, !0, F)
              } else {
                const [ne, ie] = v.getStencilConfigForOverlapAndUpdateStencilID(C);
                fo(v, w, T, ie, ne, U, Y, !1, F)
              }
            })(e, a, c, h, f) : l.bN(c) ? (function(v, w, T, C, z) {
              if (v.renderPass !== "translucent" || T.paint.get("raster-opacity") === 0 || !C.length) return;
              const {
                isRenderingToTexture: F
              } = z, R = w.getSource(), U = v.style.projection.useSubdivision;
              if (R instanceof Ht) Ps(v, w, T, C, null, !1, !1, R.tileCoords, R.flippedWindingOrder, F);
              else if (U) {
                const [Y, ne, ie] = v.stencilConfigForOverlapTwoPass(C);
                Ps(v, w, T, ie, Y, !1, !0, ya, !1, F), Ps(v, w, T, ie, ne, !0, !0, ya, !1, F)
              } else {
                const [Y, ne] = v.getStencilConfigForOverlapAndUpdateStencilID(C);
                Ps(v, w, T, ne, Y, !1, !0, ya, !1, F)
              }
            })(e, a, c, h, f) : l.cn(c) ? (function(v, w, T, C, z) {
              const F = T.paint.get("background-color"),
                R = T.paint.get("background-opacity");
              if (R === 0) return;
              const {
                isRenderingToTexture: U
              } = z, Y = v.context, ne = Y.gl, ie = v.style.projection, ae = v.transform, me = ae.tileSize, ke = T.paint.get("background-pattern");
              if (v.isPatternMissing(ke)) return;
              const _e = !ke && F.a === 1 && R === 1 && v.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (v.renderPass !== _e) return;
              const Te = An.disabled,
                Ee = v.getDepthModeForSublayer(0, _e === "opaque" ? dn.ReadWrite : dn.ReadOnly),
                ye = v.colorModeForRenderPass(),
                Be = v.useProgram(ke ? "backgroundPattern" : "background"),
                ht = C || Je(ae, {
                  tileSize: me,
                  terrain: v.style.map.terrain
                });
              ke && (Y.activeTexture.set(ne.TEXTURE0), v.imageManager.bind(v.context));
              const at = T.getCrossfadeParameters();
              for (const lt of ht) {
                const pt = ae.getProjectionData({
                    overscaledTileID: lt,
                    applyGlobeMatrix: !U,
                    applyTerrainMatrix: !0
                  }),
                  ur = ke ? eu(R, v, ke, {
                    tileID: lt,
                    tileSize: me
                  }, at) : Qc(R, F),
                  hr = v.style.map.terrain && v.style.map.terrain.getTerrainData(lt),
                  Nt = ie.getMeshFromTileID(Y, lt.canonical, !1, !0, "raster");
                Be.draw(Y, ne.TRIANGLES, Ee, Te, ye, ln.backCCW, ur, hr, pt, T.id, Nt.vertexBuffer, Nt.indexBuffer, Nt.segments)
              }
            })(e, 0, c, h, f) : l.co(c) && (function(v, w, T, C) {
              const {
                isRenderingGlobe: z
              } = C, F = v.context, R = T.implementation, U = v.style.projection, Y = v.transform, ne = Y.getProjectionDataForCustomLayer(z), ie = {
                farZ: Y.farZ,
                nearZ: Y.nearZ,
                fov: Y.fov * Math.PI / 180,
                modelViewProjectionMatrix: Y.modelViewProjectionMatrix,
                projectionMatrix: Y.projectionMatrix,
                shaderData: {
                  variantName: U.shaderVariantName,
                  vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${U.shaderPreludeCode.vertexSource}`,
                  define: U.shaderDefine
                },
                defaultProjectionData: ne
              }, ae = R.renderingMode ? R.renderingMode : "2d";
              if (v.renderPass === "offscreen") {
                const me = R.prerender;
                me && (v.setCustomLayerDefaults(), F.setColorMode(v.colorModeForRenderPass()), me.call(R, F.gl, ie), F.setDirty(), v.setBaseState())
              } else if (v.renderPass === "translucent") {
                v.setCustomLayerDefaults(), F.setColorMode(v.colorModeForRenderPass()), F.setStencilMode(An.disabled);
                const me = ae === "3d" ? v.getDepthModeFor3D() : v.getDepthModeForSublayer(0, dn.ReadOnly);
                F.setDepthMode(me), R.render(F.gl, ie), F.setDirty(), v.setBaseState(), F.bindFramebuffer.set(null)
              }
            })(e, 0, c, f))
          }
          saveTileTexture(e) {
            const a = this._tileTextures[e.size[0]];
            a ? a.push(e) : this._tileTextures[e.size[0]] = [e]
          }
          getTileTexture(e) {
            const a = this._tileTextures[e];
            return a && a.length > 0 ? a.pop() : null
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const a = this.imageManager.getPattern(e.from.toString()),
              c = this.imageManager.getPattern(e.to.toString());
            return !a || !c
          }
          useProgram(e, a, c = !1, h = []) {
            this.cache = this.cache || {};
            const f = !!this.style.map.terrain,
              v = this.style.projection,
              w = c ? Nr.projectionMercator : v.shaderPreludeCode,
              T = c ? Xn : v.shaderDefine,
              C = e + (a ? a.cacheKey : "") + `/${c?zr:v.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (f ? "/terrain" : "") + (h ? `/${h.join("/")}` : "");
            return this.cache[C] || (this.cache[C] = new $s(this.context, Nr[e], a, Yh[e], this._showOverdrawInspector, f, w, T, h)), this.cache[C]
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD)
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new l.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA))
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy()
          }
          overLimit() {
            const {
              drawingBufferWidth: e,
              drawingBufferHeight: a
            } = this.context.gl;
            return this.width !== e || this.height !== a
          }
        }

        function _u(p, e) {
          let a, c = !1,
            h = null,
            f = null;
          const v = () => {
            h = null, c && (p.apply(f, a), h = setTimeout(v, e), c = !1)
          };
          return (...w) => (c = !0, f = this, a = w, h || v(), h)
        }
        class mu {
          constructor(e) {
            this._getCurrentHash = () => {
              const a = window.location.hash.replace("#", "");
              if (this._hashName) {
                let c;
                return a.split("&").map((h => h.split("="))).forEach((h => {
                  h[0] === this._hashName && (c = h)
                })), (c && c[1] || "").split("/")
              }
              return a.split("/")
            }, this._onHashChange = () => {
              const a = this._getCurrentHash();
              if (!this._isValidHash(a)) return !1;
              const c = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(a[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({
                center: [+a[2], +a[1]],
                zoom: +a[0],
                bearing: c,
                pitch: +(a[4] || 0)
              }), !0
            }, this._updateHashUnthrottled = () => {
              const a = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, a)
            }, this._removeHash = () => {
              const a = this._getCurrentHash();
              if (a.length === 0) return;
              const c = a.join("/");
              let h = c;
              h.split("&").length > 0 && (h = h.split("&")[0]), this._hashName && (h = `${this._hashName}=${c}`);
              let f = window.location.hash.replace(h, "");
              f.startsWith("#&") ? f = f.slice(0, 1) + f.slice(2) : f === "#" && (f = "");
              let v = window.location.href.replace(/(#.+)?$/, f);
              v = v.replace("&&", "&"), window.history.replaceState(window.history.state, null, v)
            }, this._updateHash = _u(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e)
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this
          }
          getHashString(e) {
            const a = this._map.getCenter(),
              c = Math.round(100 * this._map.getZoom()) / 100,
              h = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
              f = Math.pow(10, h),
              v = Math.round(a.lng * f) / f,
              w = Math.round(a.lat * f) / f,
              T = this._map.getBearing(),
              C = this._map.getPitch();
            let z = "";
            if (z += e ? `/${v}/${w}/${c}` : `${c}/${w}/${v}`, (T || C) && (z += "/" + Math.round(10 * T) / 10), C && (z += `/${Math.round(C)}`), this._hashName) {
              const F = this._hashName;
              let R = !1;
              const U = window.location.hash.slice(1).split("&").map((Y => {
                const ne = Y.split("=")[0];
                return ne === F ? (R = !0, `${ne}=${z}`) : Y
              })).filter((Y => Y));
              return R || U.push(`${F}=${z}`), `#${U.join("&")}`
            }
            return `#${z}`
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new l.U(+e[2], +e[1])
            } catch {
              return !1
            }
            const a = +e[0],
              c = +(e[3] || 0),
              h = +(e[4] || 0);
            return a >= this._map.getMinZoom() && a <= this._map.getMaxZoom() && c >= -180 && c <= 180 && h >= this._map.getMinPitch() && h <= this._map.getMaxPitch()
          }
        }
        const Ms = {
            linearity: .3,
            easing: l.cp(0, 0, .3, 1)
          },
          fd = l.e({
            deceleration: 2500,
            maxSpeed: 1400
          }, Ms),
          _d = l.e({
            deceleration: 20,
            maxSpeed: 1400
          }, Ms),
          md = l.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, Ms),
          gd = l.e({
            deceleration: 1e3,
            maxSpeed: 90
          }, Ms),
          Yl = l.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, Ms);
        class vd {
          constructor(e) {
            this._map = e, this.clear()
          }
          clear() {
            this._inertiaBuffer = []
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({
              time: fe(),
              settings: e
            })
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer,
              a = fe();
            for (; e.length > 0 && a - e[0].time > 160;) e.shift()
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const a = {
              zoom: 0,
              bearing: 0,
              pitch: 0,
              roll: 0,
              pan: new l.P(0, 0),
              pinchAround: void 0,
              around: void 0
            };
            for (const {
                settings: f
              }
              of this._inertiaBuffer) a.zoom += f.zoomDelta || 0, a.bearing += f.bearingDelta || 0, a.pitch += f.pitchDelta || 0, a.roll += f.rollDelta || 0, f.panDelta && a.pan._add(f.panDelta), f.around && (a.around = f.around), f.pinchAround && (a.pinchAround = f.pinchAround);
            const c = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
              h = {};
            if (a.pan.mag()) {
              const f = ua(a.pan.mag(), c, l.e({}, fd, e || {})),
                v = a.pan.mult(f.amount / a.pan.mag()),
                w = this._map.cameraHelper.handlePanInertia(v, this._map.transform);
              h.center = w.easingCenter, h.offset = w.easingOffset, ra(h, f)
            }
            if (a.zoom) {
              const f = ua(a.zoom, c, _d);
              h.zoom = this._map.transform.zoom + f.amount, ra(h, f)
            }
            if (a.bearing) {
              const f = ua(a.bearing, c, md);
              h.bearing = this._map.transform.bearing + l.ai(f.amount, -179, 179), ra(h, f)
            }
            if (a.pitch) {
              const f = ua(a.pitch, c, gd);
              h.pitch = this._map.transform.pitch + f.amount, ra(h, f)
            }
            if (a.roll) {
              const f = ua(a.roll, c, Yl);
              h.roll = this._map.transform.roll + l.ai(f.amount, -179, 179), ra(h, f)
            }
            if (h.zoom || h.bearing) {
              const f = a.pinchAround === void 0 ? a.around : a.pinchAround;
              h.around = f ? this._map.unproject(f) : this._map.getCenter()
            }
            return this.clear(), l.e(h, {
              noMoveStart: !0
            })
          }
        }

        function ra(p, e) {
          (!p.duration || p.duration < e.duration) && (p.duration = e.duration, p.easing = e.easing)
        }

        function ua(p, e, a) {
          const {
            maxSpeed: c,
            linearity: h,
            deceleration: f
          } = a, v = l.ai(p * h / (e / 1e3), -c, c), w = Math.abs(v) / (f * h);
          return {
            easing: a.easing,
            duration: 1e3 * w,
            amount: v * (w / 2)
          }
        }
        class xa extends l.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, a, c, h = {}) {
            c = c instanceof MouseEvent ? c : new MouseEvent(e, c);
            const f = Z.mousePos(a.getCanvas(), c),
              v = a.unproject(f);
            super(e, l.e({
              point: f,
              lngLat: v,
              originalEvent: c
            }, h)), this._defaultPrevented = !1, this.target = a
          }
        }
        class ha extends l.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, a, c) {
            const h = e === "touchend" ? c.changedTouches : c.touches,
              f = Z.touchPos(a.getCanvasContainer(), h),
              v = f.map((T => a.unproject(T))),
              w = f.reduce(((T, C, z, F) => T.add(C.div(F.length))), new l.P(0, 0));
            super(e, {
              points: f,
              point: w,
              lngLats: v,
              lngLat: a.unproject(w),
              originalEvent: c
            }), this._defaultPrevented = !1
          }
        }
        class yd extends l.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, a, c) {
            super(e, {
              originalEvent: c
            }), this._defaultPrevented = !1
          }
        }
        class Is {
          constructor(e, a) {
            this._map = e, this._clickTolerance = a.clickTolerance
          }
          reset() {
            delete this._mousedownPos
          }
          wheel(e) {
            return this._firePreventable(new yd(e.type, this._map, e))
          }
          mousedown(e, a) {
            return this._mousedownPos = a, this._firePreventable(new xa(e.type, this._map, e))
          }
          mouseup(e) {
            this._map.fire(new xa(e.type, this._map, e))
          }
          click(e, a) {
            this._mousedownPos && this._mousedownPos.dist(a) >= this._clickTolerance || this._map.fire(new xa(e.type, this._map, e))
          }
          dblclick(e) {
            return this._firePreventable(new xa(e.type, this._map, e))
          }
          mouseover(e) {
            this._map.fire(new xa(e.type, this._map, e))
          }
          mouseout(e) {
            this._map.fire(new xa(e.type, this._map, e))
          }
          touchstart(e) {
            return this._firePreventable(new ha(e.type, this._map, e))
          }
          touchmove(e) {
            this._map.fire(new ha(e.type, this._map, e))
          }
          touchend(e) {
            this._map.fire(new ha(e.type, this._map, e))
          }
          touchcancel(e) {
            this._map.fire(new ha(e.type, this._map, e))
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {}
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class of {
          constructor(e) {
            this._map = e
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent
          }
          mousemove(e) {
            this._map.fire(new xa(e.type, this._map, e))
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new xa("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new xa(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault()
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class rl {
          constructor(e) {
            this._map = e
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat
            }
          }
          get zoom() {
            return this.transform.zoom
          }
          get pitch() {
            return this.transform.pitch
          }
          get bearing() {
            return this.transform.bearing
          }
          unproject(e) {
            return this.transform.screenPointToLocation(l.P.convert(e), this._map.terrain)
          }
        }
        class xd {
          constructor(e, a) {
            this._map = e, this._tr = new rl(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = a.clickTolerance || 1
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
          enable() {
            this.isEnabled() || (this._enabled = !0)
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          mousedown(e, a) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (Z.disableDrag(), this._startPos = this._lastPos = a, this._active = !0)
          }
          mousemoveWindow(e, a) {
            if (!this._active) return;
            const c = a;
            if (this._lastPos.equals(c) || !this._box && c.dist(this._startPos) < this._clickTolerance) return;
            const h = this._startPos;
            this._lastPos = c, this._box || (this._box = Z.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const f = Math.min(h.x, c.x),
              v = Math.max(h.x, c.x),
              w = Math.min(h.y, c.y),
              T = Math.max(h.y, c.y);
            Z.setTransform(this._box, `translate(${f}px,${w}px)`), this._box.style.width = v - f + "px", this._box.style.height = T - w + "px"
          }
          mouseupWindow(e, a) {
            if (!this._active || e.button !== 0) return;
            const c = this._startPos,
              h = a;
            if (this.reset(), Z.suppressClick(), c.x !== h.x || c.y !== h.y) return this._map.fire(new l.l("boxzoomend", {
              originalEvent: e
            })), {
              cameraAnimation: f => f.fitScreenCoordinates(c, h, this._tr.bearing, {
                linear: !0
              })
            };
            this._fireEvent("boxzoomcancel", e)
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e))
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (Z.remove(this._box), this._box = null), Z.enableDrag(), delete this._startPos, delete this._lastPos
          }
          _fireEvent(e, a) {
            return this._map.fire(new l.l(e, {
              originalEvent: a
            }))
          }
        }

        function gu(p, e) {
          if (p.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${p.length}, points ${e.length}`);
          const a = {};
          for (let c = 0; c < p.length; c++) a[p[c].identifier] = e[c];
          return a
        }
        class bd {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1
          }
          touchstart(e, a, c) {
            (this.centroid || c.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), c.length === this.numTouches && (this.centroid = (function(h) {
              const f = new l.P(0, 0);
              for (const v of h) f._add(v);
              return f.div(h.length)
            })(a), this.touches = gu(c, a)))
          }
          touchmove(e, a, c) {
            if (this.aborted || !this.centroid) return;
            const h = gu(c, a);
            for (const f in this.touches) {
              const v = h[f];
              (!v || v.dist(this.touches[f]) > 30) && (this.aborted = !0)
            }
          }
          touchend(e, a, c) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), c.length === 0) {
              const h = !this.aborted && this.centroid;
              if (this.reset(), h) return h
            }
          }
        }
        class Jo {
          constructor(e) {
            this.singleTap = new bd(e), this.numTaps = e.numTaps, this.reset()
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset()
          }
          touchstart(e, a, c) {
            this.singleTap.touchstart(e, a, c)
          }
          touchmove(e, a, c) {
            this.singleTap.touchmove(e, a, c)
          }
          touchend(e, a, c) {
            const h = this.singleTap.touchend(e, a, c);
            if (h) {
              const f = e.timeStamp - this.lastTime < 500,
                v = !this.lastTap || this.lastTap.dist(h) < 30;
              if (f && v || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = h, this.count === this.numTaps) return this.reset(), h
            }
          }
        }
        class _o {
          constructor(e) {
            this._tr = new rl(e), this._zoomIn = new Jo({
              numTouches: 1,
              numTaps: 2
            }), this._zoomOut = new Jo({
              numTouches: 2,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
          }
          touchstart(e, a, c) {
            this._zoomIn.touchstart(e, a, c), this._zoomOut.touchstart(e, a, c)
          }
          touchmove(e, a, c) {
            this._zoomIn.touchmove(e, a, c), this._zoomOut.touchmove(e, a, c)
          }
          touchend(e, a, c) {
            const h = this._zoomIn.touchend(e, a, c),
              f = this._zoomOut.touchend(e, a, c),
              v = this._tr;
            return h ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: w => w.easeTo({
                duration: 300,
                zoom: v.zoom + 1,
                around: v.unproject(h)
              }, {
                originalEvent: e
              })
            }) : f ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: w => w.easeTo({
                duration: 300,
                zoom: v.zoom - 1,
                around: v.unproject(f)
              }, {
                originalEvent: e
              })
            }) : void 0
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Er {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset()
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e)
          }
          _move(...e) {
            const a = this._moveFunction(...e);
            if (a.bearingDelta || a.pitchDelta || a.rollDelta || a.around || a.panDelta) return this._active = !0, a
          }
          dragStart(e, a) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(a) ? a[0] : a, this._activateOnStart && this._lastPoint && (this._active = !0))
          }
          dragMove(e, a) {
            if (!this.isEnabled()) return;
            const c = this._lastPoint;
            if (!c) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const h = Array.isArray(a) ? a[0] : a;
            return !this._moved && h.dist(c) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = h, this._move(c, h))
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && Z.suppressClick(), this.reset(e))
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          getClickTolerance() {
            return this._clickTolerance
          }
        }
        const wd = 0,
          vu = 2,
          kd = {
            [wd]: 1,
            [vu]: 2
          };
        class mo {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent
          }
          startMove(e) {
            const a = Z.mouseButton(e);
            this._eventButton = a
          }
          endMove(e) {
            delete this._eventButton
          }
          isValidStartEvent(e) {
            return this._correctEvent(e)
          }
          isValidMoveEvent(e) {
            return !(function(a, c) {
              const h = kd[c];
              return a.buttons === void 0 || (a.buttons & h) !== h
            })(e, this._eventButton)
          }
          isValidEndEvent(e) {
            return Z.mouseButton(e) === this._eventButton
          }
        }
        class nl {
          constructor() {
            this._firstTouch = void 0
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier
          }
          endMove(e) {
            delete this._firstTouch
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e)
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
        }
        class yu {
          constructor(e = new mo({
            checkCorrectEvent: () => !0
          }), a = new nl) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = a
          }
          _executeRelevantHandler(e, a, c) {
            return e instanceof MouseEvent ? a(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? c(e) : void 0
          }
          startMove(e) {
            this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.startMove(a)), (a => this.oneFingerTouchMoveStateManager.startMove(a)))
          }
          endMove(e) {
            this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.endMove(a)), (a => this.oneFingerTouchMoveStateManager.endMove(a)))
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.isValidStartEvent(a)), (a => this.oneFingerTouchMoveStateManager.isValidStartEvent(a)))
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.isValidMoveEvent(a)), (a => this.oneFingerTouchMoveStateManager.isValidMoveEvent(a)))
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.isValidEndEvent(a)), (a => this.oneFingerTouchMoveStateManager.isValidEndEvent(a)))
          }
        }
        const Dn = p => {
          p.mousedown = p.dragStart, p.mousemoveWindow = p.dragMove, p.mouseup = p.dragEnd, p.contextmenu = e => {
            e.preventDefault()
          }
        };
        class xu {
          constructor(e, a) {
            this._clickTolerance = e.clickTolerance || 1, this._map = a, this.reset()
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new l.P(0, 0)
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
          }
          touchstart(e, a, c) {
            return this._calculateTransform(e, a, c)
          }
          touchmove(e, a, c) {
            if (this._active) {
              if (!this._shouldBePrevented(c.length)) return e.preventDefault(), this._calculateTransform(e, a, c);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
            }
          }
          touchend(e, a, c) {
            this._calculateTransform(e, a, c), this._active && this._shouldBePrevented(c.length) && this.reset()
          }
          touchcancel() {
            this.reset()
          }
          _calculateTransform(e, a, c) {
            c.length > 0 && (this._active = !0);
            const h = gu(c, a),
              f = new l.P(0, 0),
              v = new l.P(0, 0);
            let w = 0;
            for (const C in h) {
              const z = h[C],
                F = this._touches[C];
              F && (f._add(z), v._add(z.sub(F)), w++, h[C] = z)
            }
            if (this._touches = h, this._shouldBePrevented(w) || !v.mag()) return;
            const T = v.div(w);
            return this._sum._add(T), this._sum.mag() < this._clickTolerance ? void 0 : {
              around: f.div(w),
              panDelta: T
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class bu {
          constructor() {
            this.reset()
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches
          }
          touchstart(e, a, c) {
            this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([a[0], a[1]]))
          }
          touchmove(e, a, c) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [h, f] = this._firstTwoTouches, v = Cs(c, a, h), w = Cs(c, a, f);
            if (!v || !w) return;
            const T = this._aroundCenter ? null : v.add(w).div(2);
            return this._move([v, w], T, e)
          }
          touchend(e, a, c) {
            if (!this._firstTwoTouches) return;
            const [h, f] = this._firstTwoTouches, v = Cs(c, a, h), w = Cs(c, a, f);
            v && w || (this._active && Z.suppressClick(), this.reset())
          }
          touchcancel() {
            this.reset()
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center"
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
        }

        function Cs(p, e, a) {
          for (let c = 0; c < p.length; c++)
            if (p[c].identifier === a) return e[c]
        }

        function Td(p, e) {
          return Math.log(p / e) / Math.LN2
        }
        class Pd extends bu {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1])
          }
          _move(e, a) {
            const c = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Td(this._distance, this._startDistance)) < .1)) return this._active = !0, {
              zoomDelta: Td(this._distance, c),
              pinchAround: a
            }
          }
        }

        function wu(p, e) {
          return 180 * p.angleWith(e) / Math.PI
        }
        class Kl extends bu {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1])
          }
          _move(e, a, c) {
            const h = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
              bearingDelta: wu(this._vector, h),
              pinchAround: a
            }
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const a = 25 / (Math.PI * this._minDiameter) * 360,
              c = wu(e, this._startVector);
            return Math.abs(c) < a
          }
        }

        function Jl(p) {
          return Math.abs(p.y) > Math.abs(p.x)
        }
        class Sd extends bu {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints
          }
          touchstart(e, a, c) {
            super.touchstart(e, a, c), this._currentTouchCount = c.length
          }
          _start(e) {
            this._lastPoints = e, Jl(e[0].sub(e[1])) && (this._valid = !1)
          }
          _move(e, a, c) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const h = e[0].sub(this._lastPoints[0]),
              f = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(h, f, c.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, {
              pitchDelta: (h.y + f.y) / 2 * -.5
            }) : void 0
          }
          gestureBeginsVertically(e, a, c) {
            if (this._valid !== void 0) return this._valid;
            const h = e.mag() >= 2,
              f = a.mag() >= 2;
            if (!h && !f) return;
            if (!h || !f) return this._firstMove === void 0 && (this._firstMove = c), c - this._firstMove < 100 && void 0;
            const v = e.y > 0 == a.y > 0;
            return Jl(e) && Jl(a) && v
          }
        }
        const Md = {
          panStep: 100,
          bearingStep: 15,
          pitchStep: 10
        };
        class Id {
          constructor(e) {
            this._tr = new rl(e);
            const a = Md;
            this._panStep = a.panStep, this._bearingStep = a.bearingStep, this._pitchStep = a.pitchStep, this._rotationDisabled = !1
          }
          reset() {
            this._active = !1
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let a = 0,
              c = 0,
              h = 0,
              f = 0,
              v = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                a = 1;
                break;
              case 189:
              case 109:
              case 173:
                a = -1;
                break;
              case 37:
                e.shiftKey ? c = -1 : (e.preventDefault(), f = -1);
                break;
              case 39:
                e.shiftKey ? c = 1 : (e.preventDefault(), f = 1);
                break;
              case 38:
                e.shiftKey ? h = 1 : (e.preventDefault(), v = -1);
                break;
              case 40:
                e.shiftKey ? h = -1 : (e.preventDefault(), v = 1);
                break;
              default:
                return
            }
            return this._rotationDisabled && (c = 0, h = 0), {
              cameraAnimation: w => {
                const T = this._tr;
                w.easeTo({
                  duration: 300,
                  easeId: "keyboardHandler",
                  easing: sf,
                  zoom: a ? Math.round(T.zoom) + a * (e.shiftKey ? 2 : 1) : T.zoom,
                  bearing: T.bearing + c * this._bearingStep,
                  pitch: T.pitch + h * this._pitchStep,
                  offset: [-f * this._panStep, -v * this._panStep],
                  center: T.center
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          disableRotation() {
            this._rotationDisabled = !0
          }
          enableRotation() {
            this._rotationDisabled = !1
          }
        }

        function sf(p) {
          return p * (2 - p)
        }
        const go = 4.000244140625,
          Qn = 1 / 450;
        class Cd {
          constructor(e, a) {
            this._onTimeout = c => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(c)
            }, this._map = e, this._tr = new rl(e), this._triggerRenderFrame = a, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = Qn
          }
          setZoomRate(e) {
            this._defaultZoomRate = e
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0
          }
          isZooming() {
            return !!this._zooming
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center")
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let a = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const c = fe(),
              h = c - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = c, a !== 0 && a % go == 0 ? this._type = "wheel" : a !== 0 && Math.abs(a) < 4 ? this._type = "trackpad" : h > 400 ? (this._type = null, this._lastValue = a, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(h * a) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, a += this._lastValue)), e.shiftKey && a && (a /= 4), this._type && (this._lastWheelEvent = e, this._delta -= a, this._active || this._start(e)), e.preventDefault()
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const a = Z.mousePos(this._map.getCanvas(), e),
              c = this._tr;
            this._aroundPoint = this._aroundCenter ? c.transform.locationToScreenPoint(l.U.convert(c.center)) : a, this._frameId || (this._frameId = !0, this._triggerRenderFrame())
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const w = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += w), typeof this._targetZoom == "number" && (this._targetZoom += w)
            }
            if (this._delta !== 0) {
              const w = this._type === "wheel" && Math.abs(this._delta) > go ? this._wheelZoomRate : this._defaultZoomRate;
              let T = 2 / (1 + Math.exp(-Math.abs(this._delta * w)));
              this._delta < 0 && T !== 0 && (T = 1 / T);
              const C = typeof this._targetZoom != "number" ? e.scale : l.al(this._targetZoom);
              this._targetZoom = e.constrain(e.getCameraLngLat(), l.ao(C * T)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0
            }
            const a = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom,
              c = this._startZoom,
              h = this._easing;
            let f, v = !1;
            if (this._type === "wheel" && c && h) {
              const w = fe() - this._lastWheelEventTime,
                T = Math.min((w + 5) / 200, 1),
                C = h(T);
              f = l.F.number(c, a, C), T < 1 ? this._frameId || (this._frameId = !0) : v = !0
            } else f = a, v = !0;
            return this._active = !0, v && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout
            }), 200)), this._lastExpectedZoom = f, {
              noInertia: !0,
              needsRenderFrame: !v,
              zoomDelta: f - e.zoom,
              around: this._aroundPoint,
              originalEvent: this._lastWheelEvent
            }
          }
          _smoothOutEasing(e) {
            let a = l.cr;
            if (this._prevEase) {
              const c = this._prevEase,
                h = (fe() - c.start) / c.duration,
                f = c.easing(h + .01) - c.easing(h),
                v = .27 / Math.sqrt(f * f + 1e-4) * .01,
                w = Math.sqrt(.0729 - v * v);
              a = l.cp(v, w, .25, 1)
            }
            return this._prevEase = {
              start: fe(),
              duration: e,
              easing: a
            }, a
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout)
          }
        }
        class il {
          constructor(e, a) {
            this._clickZoom = e, this._tapZoom = a
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable()
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable()
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive()
          }
        }
        class ku {
          constructor(e) {
            this._tr = new rl(e), this.reset()
          }
          reset() {
            this._active = !1
          }
          dblclick(e, a) {
            return e.preventDefault(), {
              cameraAnimation: c => {
                c.easeTo({
                  duration: 300,
                  zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                  around: this._tr.unproject(a)
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Ad {
          constructor() {
            this._tap = new Jo({
              numTouches: 1,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset()
          }
          touchstart(e, a, c) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const h = a[0],
                  f = e.timeStamp - this._tapTime < 500,
                  v = this._tapPoint.dist(h) < 30;
                f && v ? c.length > 0 && (this._swipePoint = h, this._swipeTouch = c[0].identifier) : this.reset()
              } else this._tap.touchstart(e, a, c)
          }
          touchmove(e, a, c) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (c[0].identifier !== this._swipeTouch) return;
                const h = a[0],
                  f = h.y - this._swipePoint.y;
                return this._swipePoint = h, e.preventDefault(), this._active = !0, {
                  zoomDelta: f / 128
                }
              }
            } else this._tap.touchmove(e, a, c)
          }
          touchend(e, a, c) {
            if (this._tapTime) this._swipePoint && c.length === 0 && this.reset();
            else {
              const h = this._tap.touchend(e, a, c);
              h && (this._tapTime = e.timeStamp, this._tapPoint = h)
            }
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Tu {
          constructor(e, a, c) {
            this._el = e, this._mousePan = a, this._touchPan = c
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan")
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan")
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled()
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive()
          }
        }
        class Pu {
          constructor(e, a, c, h) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = a, this._mousePitch = c, this._mouseRoll = h
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable()
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable()
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
          }
        }
        class zd {
          constructor(e, a, c, h) {
            this._el = e, this._touchZoom = a, this._touchRotate = c, this._tapDragZoom = h, this._rotationDisabled = !1, this._enabled = !0
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate")
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate")
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable()
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
          }
        }
        class Ua {
          constructor(e, a) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = a, this._enabled = !1
          }
          isActive() {
            return !1
          }
          reset() {}
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = Z.create("div", "maplibregl-cooperative-gesture-screen", e);
            let a = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (a = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const c = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"),
              h = document.createElement("div");
            h.className = "maplibregl-desktop-message", h.textContent = a, this._container.appendChild(h);
            const f = document.createElement("div");
            f.className = "maplibregl-mobile-message", f.textContent = c, this._container.appendChild(f), this._container.setAttribute("aria-hidden", "true")
          }
          _destroyUI() {
            this._container && (Z.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container
          }
          enable() {
            this._setupUI(), this._enabled = !0
          }
          disable() {
            this._enabled = !1, this._destroyUI()
          }
          isEnabled() {
            return this._enabled
          }
          isBypassed(e) {
            return e[this._bypassKey]
          }
          notifyGestureBlocked(e, a) {
            this._enabled && (this._map.fire(new l.l("cooperativegestureprevented", {
              gestureType: e,
              originalEvent: a
            })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show")
            }), 100))
          }
        }
        const Qo = p => p.zoom || p.drag || p.roll || p.pitch || p.rotate;
        class Xr extends l.l {}

        function hn(p) {
          return p.panDelta && p.panDelta.mag() || p.zoomDelta || p.bearingDelta || p.pitchDelta || p.rollDelta
        }
        class al {
          constructor(e, a) {
            this.handleWindowEvent = h => {
              this.handleEvent(h, `${h.type}Window`)
            }, this.handleEvent = (h, f) => {
              if (h.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const v = h.type === "renderFrame" ? void 0 : h,
                w = {
                  needsRenderFrame: !1
                },
                T = {},
                C = {};
              for (const {
                  handlerName: R,
                  handler: U,
                  allowed: Y
                }
                of this._handlers) {
                if (!U.isEnabled()) continue;
                let ne;
                if (this._blockedByActive(C, Y, R)) U.reset();
                else if (U[f || h.type]) {
                  if (l.cs(h, f || h.type)) {
                    const ie = Z.mousePos(this._map.getCanvas(), h);
                    ne = U[f || h.type](h, ie)
                  } else if (l.ct(h, f || h.type)) {
                    const ie = this._getMapTouches(h.touches),
                      ae = Z.touchPos(this._map.getCanvas(), ie);
                    ne = U[f || h.type](h, ae, ie)
                  } else l.cu(f || h.type) || (ne = U[f || h.type](h));
                  this.mergeHandlerResult(w, T, ne, R, v), ne && ne.needsRenderFrame && this._triggerRenderFrame()
                }(ne || U.isActive()) && (C[R] = U)
              }
              const z = {};
              for (const R in this._previousActiveHandlers) C[R] || (z[R] = v);
              this._previousActiveHandlers = C, (Object.keys(z).length || hn(w)) && (this._changes.push([w, T, z]), this._triggerRenderFrame()), (Object.keys(C).length || hn(w)) && this._map._stop(!0), this._updatingCamera = !1;
              const {
                cameraAnimation: F
              } = w;
              F && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], F(this._map))
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new vd(e), this._bearingSnap = a.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(a);
            const c = this._el;
            this._listeners = [
              [c, "touchstart", {
                passive: !0
              }],
              [c, "touchmove", {
                passive: !1
              }],
              [c, "touchend", void 0],
              [c, "touchcancel", void 0],
              [c, "mousedown", void 0],
              [c, "mousemove", void 0],
              [c, "mouseup", void 0],
              [document, "mousemove", {
                capture: !0
              }],
              [document, "mouseup", void 0],
              [c, "mouseover", void 0],
              [c, "mouseout", void 0],
              [c, "dblclick", void 0],
              [c, "click", void 0],
              [c, "keydown", {
                capture: !1
              }],
              [c, "keyup", void 0],
              [c, "wheel", {
                passive: !1
              }],
              [c, "contextmenu", void 0],
              [window, "blur", void 0]
            ];
            for (const [h, f, v] of this._listeners) Z.addEventListener(h, f, h === document ? this.handleWindowEvent : this.handleEvent, v)
          }
          destroy() {
            for (const [e, a, c] of this._listeners) Z.removeEventListener(e, a, e === document ? this.handleWindowEvent : this.handleEvent, c)
          }
          _addDefaultHandlers(e) {
            const a = this._map,
              c = a.getCanvasContainer();
            this._add("mapEvent", new Is(a, e));
            const h = a.boxZoom = new xd(a, e);
            this._add("boxZoom", h), e.interactive && e.boxZoom && h.enable();
            const f = a.cooperativeGestures = new Ua(a, e.cooperativeGestures);
            this._add("cooperativeGestures", f), e.cooperativeGestures && f.enable();
            const v = new _o(a),
              w = new ku(a);
            a.doubleClickZoom = new il(w, v), this._add("tapZoom", v), this._add("clickZoom", w), e.interactive && e.doubleClickZoom && a.doubleClickZoom.enable();
            const T = new Ad;
            this._add("tapDragZoom", T);
            const C = a.touchPitch = new Sd(a);
            this._add("touchPitch", C), e.interactive && e.touchPitch && a.touchPitch.enable(e.touchPitch);
            const z = () => a.project(a.getCenter()),
              F = (function({
                enable: _e,
                clickTolerance: Te,
                aroundCenter: Ee = !0,
                minPixelCenterThreshold: ye = 100,
                rotateDegreesPerPixelMoved: Be = .8
              }, ht) {
                const at = new mo({
                  checkCorrectEvent: lt => Z.mouseButton(lt) === 0 && lt.ctrlKey || Z.mouseButton(lt) === 2 && !lt.ctrlKey
                });
                return new Er({
                  clickTolerance: Te,
                  move: (lt, pt) => {
                    const ur = ht();
                    if (Ee && Math.abs(ur.y - lt.y) > ye) return {
                      bearingDelta: l.cq(new l.P(lt.x, pt.y), pt, ur)
                    };
                    let hr = (pt.x - lt.x) * Be;
                    return Ee && pt.y < ur.y && (hr = -hr), {
                      bearingDelta: hr
                    }
                  },
                  moveStateManager: at,
                  enable: _e,
                  assignEvents: Dn
                })
              })(e, z),
              R = (function({
                enable: _e,
                clickTolerance: Te,
                pitchDegreesPerPixelMoved: Ee = -.5
              }) {
                const ye = new mo({
                  checkCorrectEvent: Be => Z.mouseButton(Be) === 0 && Be.ctrlKey || Z.mouseButton(Be) === 2
                });
                return new Er({
                  clickTolerance: Te,
                  move: (Be, ht) => ({
                    pitchDelta: (ht.y - Be.y) * Ee
                  }),
                  moveStateManager: ye,
                  enable: _e,
                  assignEvents: Dn
                })
              })(e),
              U = (function({
                enable: _e,
                clickTolerance: Te,
                rollDegreesPerPixelMoved: Ee = .3
              }, ye) {
                const Be = new mo({
                  checkCorrectEvent: ht => Z.mouseButton(ht) === 2 && ht.ctrlKey
                });
                return new Er({
                  clickTolerance: Te,
                  move: (ht, at) => {
                    const lt = ye();
                    let pt = (at.x - ht.x) * Ee;
                    return at.y < lt.y && (pt = -pt), {
                      rollDelta: pt
                    }
                  },
                  moveStateManager: Be,
                  enable: _e,
                  assignEvents: Dn
                })
              })(e, z);
            a.dragRotate = new Pu(e, F, R, U), this._add("mouseRotate", F, ["mousePitch"]), this._add("mousePitch", R, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", U, ["mousePitch"]), e.interactive && e.dragRotate && a.dragRotate.enable();
            const Y = (function({
                enable: _e,
                clickTolerance: Te
              }) {
                const Ee = new mo({
                  checkCorrectEvent: ye => Z.mouseButton(ye) === 0 && !ye.ctrlKey
                });
                return new Er({
                  clickTolerance: Te,
                  move: (ye, Be) => ({
                    around: Be,
                    panDelta: Be.sub(ye)
                  }),
                  activateOnStart: !0,
                  moveStateManager: Ee,
                  enable: _e,
                  assignEvents: Dn
                })
              })(e),
              ne = new xu(e, a);
            a.dragPan = new Tu(c, Y, ne), this._add("mousePan", Y), this._add("touchPan", ne, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && a.dragPan.enable(e.dragPan);
            const ie = new Kl,
              ae = new Pd;
            a.touchZoomRotate = new zd(c, ae, ie, T), this._add("touchRotate", ie, ["touchPan", "touchZoom"]), this._add("touchZoom", ae, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && a.touchZoomRotate.enable(e.touchZoomRotate), this._add("blockableMapEvent", new of(a));
            const me = a.scrollZoom = new Cd(a, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", me, ["mousePan"]), e.interactive && e.scrollZoom && a.scrollZoom.enable(e.scrollZoom);
            const ke = a.keyboard = new Id(a);
            this._add("keyboard", ke), e.interactive && e.keyboard && a.keyboard.enable()
          }
          _add(e, a, c) {
            this._handlers.push({
              handlerName: e,
              handler: a,
              allowed: c
            }), this._handlersById[e] = a
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const {
                  handler: a
                }
                of this._handlers) a.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = []
            }
          }
          isActive() {
            for (const {
                handler: e
              }
              of this._handlers)
              if (e.isActive()) return !0;
            return !1
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
          }
          isRotating() {
            return !!this._eventsInProgress.rotate
          }
          isMoving() {
            return !!Qo(this._eventsInProgress) || this.isZooming()
          }
          _blockedByActive(e, a, c) {
            for (const h in e)
              if (h !== c && (!a || a.indexOf(h) < 0)) return !0;
            return !1
          }
          _getMapTouches(e) {
            const a = [];
            for (const c of e) this._el.contains(c.target) && a.push(c);
            return a
          }
          mergeHandlerResult(e, a, c, h, f) {
            if (!c) return;
            l.e(e, c);
            const v = {
              handlerName: h,
              originalEvent: c.originalEvent || f
            };
            c.zoomDelta !== void 0 && (a.zoom = v), c.panDelta !== void 0 && (a.drag = v), c.rollDelta !== void 0 && (a.roll = v), c.pitchDelta !== void 0 && (a.pitch = v), c.bearingDelta !== void 0 && (a.rotate = v)
          }
          _applyChanges() {
            const e = {},
              a = {},
              c = {};
            for (const [h, f, v] of this._changes) h.panDelta && (e.panDelta = (e.panDelta || new l.P(0, 0))._add(h.panDelta)), h.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + h.zoomDelta), h.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + h.bearingDelta), h.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + h.pitchDelta), h.rollDelta && (e.rollDelta = (e.rollDelta || 0) + h.rollDelta), h.around !== void 0 && (e.around = h.around), h.pinchAround !== void 0 && (e.pinchAround = h.pinchAround), h.noInertia && (e.noInertia = h.noInertia), l.e(a, f), l.e(c, v);
            this._updateMapTransform(e, a, c), this._changes = []
          }
          _updateMapTransform(e, a, c) {
            const h = this._map,
              f = h._getTransformForUpdate(),
              v = h.terrain;
            if (!(hn(e) || v && this._terrainMovement)) return this._fireEvents(a, c, !0);
            h._stop(!0);
            let {
              panDelta: w,
              zoomDelta: T,
              bearingDelta: C,
              pitchDelta: z,
              rollDelta: F,
              around: R,
              pinchAround: U
            } = e;
            U !== void 0 && (R = U), R = R || h.transform.centerPoint, v && !f.isPointOnMapSurface(R) && (R = f.centerPoint);
            const Y = {
              panDelta: w,
              zoomDelta: T,
              rollDelta: F,
              pitchDelta: z,
              bearingDelta: C,
              around: R
            };
            this._map.cameraHelper.useGlobeControls && !f.isPointOnMapSurface(R) && (R = f.centerPoint);
            const ne = R.distSqr(f.centerPoint) < .01 ? f.center : f.screenPointToLocation(w ? R.sub(w) : R);
            this._handleMapControls({
              terrain: v,
              tr: f,
              deltasForHelper: Y,
              preZoomAroundLoc: ne,
              combinedEventsInProgress: a,
              panDelta: w
            }), h._applyUpdatedTransform(f), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(a, c, !0)
          }
          _handleMapControls({
            terrain: e,
            tr: a,
            deltasForHelper: c,
            preZoomAroundLoc: h,
            combinedEventsInProgress: f,
            panDelta: v
          }) {
            const w = this._map.cameraHelper;
            if (w.handleMapControlsRollPitchBearingZoom(c, a), e) return w.useGlobeControls ? (this._terrainMovement || !f.drag && !f.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void w.handleMapControlsPan(c, a, h)) : this._terrainMovement || !f.drag && !f.zoom ? void(f.drag && this._terrainMovement && v ? a.setCenter(a.screenPointToLocation(a.centerPoint.sub(v))) : w.handleMapControlsPan(c, a, h)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void w.handleMapControlsPan(c, a, h));
            w.handleMapControlsPan(c, a, h)
          }
          _fireEvents(e, a, c) {
            const h = Qo(this._eventsInProgress),
              f = Qo(e),
              v = {};
            for (const F in e) {
              const {
                originalEvent: R
              } = e[F];
              this._eventsInProgress[F] || (v[`${F}start`] = R), this._eventsInProgress[F] = e[F]
            }!h && f && this._fireEvent("movestart", f.originalEvent);
            for (const F in v) this._fireEvent(F, v[F]);
            f && this._fireEvent("move", f.originalEvent);
            for (const F in e) {
              const {
                originalEvent: R
              } = e[F];
              this._fireEvent(F, R)
            }
            const w = {};
            let T;
            for (const F in this._eventsInProgress) {
              const {
                handlerName: R,
                originalEvent: U
              } = this._eventsInProgress[F];
              this._handlersById[R].isActive() || (delete this._eventsInProgress[F], T = a[R] || U, w[`${F}end`] = T)
            }
            for (const F in w) this._fireEvent(F, w[F]);
            const C = Qo(this._eventsInProgress),
              z = (h || f) && !C;
            if (z && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const F = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && F.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(F)
            }
            if (c && z) {
              this._updatingCamera = !0;
              const F = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                R = U => U !== 0 && -this._bearingSnap < U && U < this._bearingSnap;
              !F || !F.essential && ce.prefersReducedMotion ? (this._map.fire(new l.l("moveend", {
                originalEvent: T
              })), R(this._map.getBearing()) && this._map.resetNorth()) : (R(F.bearing || this._map.getBearing()) && (F.bearing = 0), F.freezeElevation = !0, this._map.easeTo(F, {
                originalEvent: T
              })), this._updatingCamera = !1
            }
          }
          _fireEvent(e, a) {
            this._map.fire(new l.l(e, a ? {
              originalEvent: a
            } : {}))
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e => {
              delete this._frameId, this.handleEvent(new Xr("renderFrame", {
                timeStamp: e
              })), this._applyChanges()
            }))
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame())
          }
        }
        class Ed extends l.E {
          constructor(e, a, c) {
            super(), this._renderFrameCallback = () => {
              const h = Math.min((fe() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(h)), h < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = c.bearingSnap, this.cameraHelper = a, this.on("moveend", (() => {
              delete this._requestedCameraState
            }))
          }
          migrateProjection(e, a) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = a
          }
          getCenter() {
            return new l.U(this.transform.center.lng, this.transform.center.lat)
          }
          setCenter(e, a) {
            return this.jumpTo({
              center: e
            }, a)
          }
          getCenterElevation() {
            return this.transform.elevation
          }
          setCenterElevation(e, a) {
            return this.jumpTo({
              elevation: e
            }, a), this
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e
          }
          panBy(e, a, c) {
            return e = l.P.convert(e).mult(-1), this.panTo(this.transform.center, l.e({
              offset: e
            }, a), c)
          }
          panTo(e, a, c) {
            return this.easeTo(l.e({
              center: e
            }, a), c)
          }
          getZoom() {
            return this.transform.zoom
          }
          setZoom(e, a) {
            return this.jumpTo({
              zoom: e
            }, a), this
          }
          zoomTo(e, a, c) {
            return this.easeTo(l.e({
              zoom: e
            }, a), c)
          }
          zoomIn(e, a) {
            return this.zoomTo(this.getZoom() + 1, e, a), this
          }
          zoomOut(e, a) {
            return this.zoomTo(this.getZoom() - 1, e, a), this
          }
          getVerticalFieldOfView() {
            return this.transform.fov
          }
          setVerticalFieldOfView(e, a) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new l.l("movestart", a)).fire(new l.l("move", a)).fire(new l.l("moveend", a))), this
          }
          getBearing() {
            return this.transform.bearing
          }
          setBearing(e, a) {
            return this.jumpTo({
              bearing: e
            }, a), this
          }
          getPadding() {
            return this.transform.padding
          }
          setPadding(e, a) {
            return this.jumpTo({
              padding: e
            }, a), this
          }
          rotateTo(e, a, c) {
            return this.easeTo(l.e({
              bearing: e
            }, a), c)
          }
          resetNorth(e, a) {
            return this.rotateTo(0, l.e({
              duration: 1e3
            }, e), a), this
          }
          resetNorthPitch(e, a) {
            return this.easeTo(l.e({
              bearing: 0,
              pitch: 0,
              roll: 0,
              duration: 1e3
            }, e), a), this
          }
          snapToNorth(e, a) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, a) : this
          }
          getPitch() {
            return this.transform.pitch
          }
          setPitch(e, a) {
            return this.jumpTo({
              pitch: e
            }, a), this
          }
          getRoll() {
            return this.transform.roll
          }
          setRoll(e, a) {
            return this.jumpTo({
              roll: e
            }, a), this
          }
          cameraForBounds(e, a) {
            e = yt.convert(e).adjustAntiMeridian();
            const c = a && a.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), c, a)
          }
          _cameraForBoxAndBearing(e, a, c, h) {
            const f = {
              top: 0,
              bottom: 0,
              right: 0,
              left: 0
            };
            if (typeof(h = l.e({
                padding: f,
                offset: [0, 0],
                maxZoom: this.transform.maxZoom
              }, h)).padding == "number") {
              const C = h.padding;
              h.padding = {
                top: C,
                bottom: C,
                right: C,
                left: C
              }
            }
            const v = l.e(f, h.padding);
            h.padding = v;
            const w = this.transform,
              T = new yt(e, a);
            return this.cameraHelper.cameraForBoxAndBearing(h, v, T, c, w)
          }
          fitBounds(e, a, c) {
            return this._fitInternal(this.cameraForBounds(e, a), a, c)
          }
          fitScreenCoordinates(e, a, c, h, f) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(l.P.convert(e)), this.transform.screenPointToLocation(l.P.convert(a)), c, h), h, f)
          }
          _fitInternal(e, a, c) {
            return e ? (delete(a = l.e(e, a)).padding, a.linear ? this.easeTo(a, c) : this.flyTo(a, c)) : this
          }
          jumpTo(e, a) {
            this.stop();
            const c = this._getTransformForUpdate();
            let h = !1,
              f = !1,
              v = !1;
            const w = c.zoom;
            this.cameraHelper.handleJumpToCenterZoom(c, e);
            const T = c.zoom !== w;
            return "elevation" in e && c.elevation !== +e.elevation && c.setElevation(+e.elevation), "bearing" in e && c.bearing !== +e.bearing && (h = !0, c.setBearing(+e.bearing)), "pitch" in e && c.pitch !== +e.pitch && (f = !0, c.setPitch(+e.pitch)), "roll" in e && c.roll !== +e.roll && (v = !0, c.setRoll(+e.roll)), e.padding == null || c.isPaddingEqual(e.padding) || c.setPadding(e.padding), this._applyUpdatedTransform(c), this.fire(new l.l("movestart", a)).fire(new l.l("move", a)), T && this.fire(new l.l("zoomstart", a)).fire(new l.l("zoom", a)).fire(new l.l("zoomend", a)), h && this.fire(new l.l("rotatestart", a)).fire(new l.l("rotate", a)).fire(new l.l("rotateend", a)), f && this.fire(new l.l("pitchstart", a)).fire(new l.l("pitch", a)).fire(new l.l("pitchend", a)), v && this.fire(new l.l("rollstart", a)).fire(new l.l("roll", a)).fire(new l.l("rollend", a)), this.fire(new l.l("moveend", a))
          }
          calculateCameraOptionsFromTo(e, a, c, h = 0) {
            const f = l.a5.fromLngLat(e, a),
              v = l.a5.fromLngLat(c, h),
              w = v.x - f.x,
              T = v.y - f.y,
              C = v.z - f.z,
              z = Math.hypot(w, T, C);
            if (z === 0) throw new Error("Can't calculate camera options with same From and To");
            const F = Math.hypot(w, T),
              R = l.ao(this.transform.cameraToCenterDistance / z / this.transform.tileSize),
              U = 180 * Math.atan2(w, -T) / Math.PI;
            let Y = 180 * Math.acos(F / z) / Math.PI;
            return Y = C < 0 ? 90 - Y : 90 + Y, {
              center: v.toLngLat(),
              elevation: h,
              zoom: R,
              pitch: Y,
              bearing: U
            }
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, a, c, h, f) {
            const v = this.transform.calculateCenterFromCameraLngLatAlt(e, a, c, h);
            return {
              center: v.center,
              elevation: v.elevation,
              zoom: v.zoom,
              bearing: c,
              pitch: h,
              roll: f
            }
          }
          easeTo(e, a) {
            this._stop(!1, e.easeId), ((e = l.e({
              offset: [0, 0],
              duration: 500,
              easing: l.cr
            }, e)).animate === !1 || !e.essential && ce.prefersReducedMotion) && (e.duration = 0);
            const c = this._getTransformForUpdate(),
              h = this.getBearing(),
              f = c.pitch,
              v = c.roll,
              w = "bearing" in e ? this._normalizeBearing(e.bearing, h) : h,
              T = "pitch" in e ? +e.pitch : f,
              C = "roll" in e ? this._normalizeBearing(e.roll, v) : v,
              z = "padding" in e ? e.padding : c.padding,
              F = l.P.convert(e.offset);
            let R, U;
            e.around && (R = l.U.convert(e.around), U = c.locationToScreenPoint(R));
            const Y = {
                moving: this._moving,
                zooming: this._zooming,
                rotating: this._rotating,
                pitching: this._pitching,
                rolling: this._rolling
              },
              ne = this.cameraHelper.handleEaseTo(c, {
                bearing: w,
                pitch: T,
                roll: C,
                padding: z,
                around: R,
                aroundPoint: U,
                offsetAsPoint: F,
                offset: e.offset,
                zoom: e.zoom,
                center: e.center
              });
            return this._rotating = this._rotating || h !== w, this._pitching = this._pitching || T !== f, this._rolling = this._rolling || C !== v, this._padding = !c.isPaddingEqual(z), this._zooming = this._zooming || ne.isZooming, this._easeId = e.easeId, this._prepareEase(a, e.noMoveStart, Y), this.terrain && this._prepareElevation(ne.elevationCenter), this._ease((ie => {
              ne.easeFunc(ie), this.terrain && !e.freezeElevation && this._updateElevation(ie), this._applyUpdatedTransform(c), this._fireMoveEvents(a)
            }), (ie => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a, ie)
            }), e), this
          }
          _prepareEase(e, a, c = {}) {
            this._moving = !0, a || c.moving || this.fire(new l.l("movestart", e)), this._zooming && !c.zooming && this.fire(new l.l("zoomstart", e)), this._rotating && !c.rotating && this.fire(new l.l("rotatestart", e)), this._pitching && !c.pitching && this.fire(new l.l("pitchstart", e)), this._rolling && !c.rolling && this.fire(new l.l("rollstart", e))
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const a = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && a !== this._elevationTarget) {
              const c = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (c - (a - (c * e + this._elevationStart)) / (1 - e)), this._elevationTarget = a
            }
            this.transform.setElevation(l.F.number(this._elevationStart, this._elevationTarget, e))
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const a = e.getCameraLngLat(),
              c = e.getCameraAltitude(),
              h = this.terrain ? this.terrain.getElevationForLngLatZoom(a, e.zoom) : 0;
            if (c < h) {
              const f = this.calculateCameraOptionsFromTo(a, h, e.center, e.elevation);
              return {
                pitch: f.pitch,
                zoom: f.zoom
              }
            }
            return {}
          }
          _applyUpdatedTransform(e) {
            const a = [];
            if (a.push((h => this._elevateCameraIfInsideTerrain(h))), this.transformCameraUpdate && a.push((h => this.transformCameraUpdate(h))), !a.length) return;
            const c = e.clone();
            for (const h of a) {
              const f = c.clone(),
                {
                  center: v,
                  zoom: w,
                  roll: T,
                  pitch: C,
                  bearing: z,
                  elevation: F
                } = h(f);
              v && f.setCenter(v), F !== void 0 && f.setElevation(F), w !== void 0 && f.setZoom(w), T !== void 0 && f.setRoll(T), C !== void 0 && f.setPitch(C), z !== void 0 && f.setBearing(z), c.apply(f)
            }
            this.transform.apply(c)
          }
          _fireMoveEvents(e) {
            this.fire(new l.l("move", e)), this._zooming && this.fire(new l.l("zoom", e)), this._rotating && this.fire(new l.l("rotate", e)), this._pitching && this.fire(new l.l("pitch", e)), this._rolling && this.fire(new l.l("roll", e))
          }
          _afterEase(e, a) {
            if (this._easeId && a && this._easeId === a) return;
            delete this._easeId;
            const c = this._zooming,
              h = this._rotating,
              f = this._pitching,
              v = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, c && this.fire(new l.l("zoomend", e)), h && this.fire(new l.l("rotateend", e)), f && this.fire(new l.l("pitchend", e)), v && this.fire(new l.l("rollend", e)), this.fire(new l.l("moveend", e))
          }
          flyTo(e, a) {
            if (!e.essential && ce.prefersReducedMotion) {
              const pt = l.S(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(pt, a)
            }
            this.stop(), e = l.e({
              offset: [0, 0],
              speed: 1.2,
              curve: 1.42,
              easing: l.cr
            }, e);
            const c = this._getTransformForUpdate(),
              h = c.bearing,
              f = c.pitch,
              v = c.roll,
              w = c.padding,
              T = "bearing" in e ? this._normalizeBearing(e.bearing, h) : h,
              C = "pitch" in e ? +e.pitch : f,
              z = "roll" in e ? this._normalizeBearing(e.roll, v) : v,
              F = "padding" in e ? e.padding : c.padding,
              R = l.P.convert(e.offset);
            let U = c.centerPoint.add(R);
            const Y = c.screenPointToLocation(U),
              ne = this.cameraHelper.handleFlyTo(c, {
                bearing: T,
                pitch: C,
                roll: z,
                padding: F,
                locationAtOffset: Y,
                offsetAsPoint: R,
                center: e.center,
                minZoom: e.minZoom,
                zoom: e.zoom
              });
            let ie = e.curve;
            const ae = Math.max(c.width, c.height),
              me = ae / ne.scaleOfZoom,
              ke = ne.pixelPathLength;
            typeof ne.scaleOfMinZoom == "number" && (ie = Math.sqrt(ae / ne.scaleOfMinZoom / ke * 2));
            const _e = ie * ie;

            function Te(pt) {
              const ur = (me * me - ae * ae + (pt ? -1 : 1) * _e * _e * ke * ke) / (2 * (pt ? me : ae) * _e * ke);
              return Math.log(Math.sqrt(ur * ur + 1) - ur)
            }

            function Ee(pt) {
              return (Math.exp(pt) - Math.exp(-pt)) / 2
            }

            function ye(pt) {
              return (Math.exp(pt) + Math.exp(-pt)) / 2
            }
            const Be = Te(!1);
            let ht = function(pt) {
                return ye(Be) / ye(Be + ie * pt)
              },
              at = function(pt) {
                return ae * ((ye(Be) * (Ee(ur = Be + ie * pt) / ye(ur)) - Ee(Be)) / _e) / ke;
                var ur
              },
              lt = (Te(!0) - Be) / ie;
            if (Math.abs(ke) < 2e-6 || !isFinite(lt)) {
              if (Math.abs(ae - me) < 1e-6) return this.easeTo(e, a);
              const pt = me < ae ? -1 : 1;
              lt = Math.abs(Math.log(me / ae)) / ie, at = () => 0, ht = ur => Math.exp(pt * ie * ur)
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * lt / ("screenSpeed" in e ? +e.screenSpeed / ie : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = h !== T, this._pitching = C !== f, this._rolling = z !== v, this._padding = !c.isPaddingEqual(F), this._prepareEase(a, !1), this.terrain && this._prepareElevation(ne.targetCenter), this._ease((pt => {
              const ur = pt * lt,
                hr = 1 / ht(ur),
                Nt = at(ur);
              this._rotating && c.setBearing(l.F.number(h, T, pt)), this._pitching && c.setPitch(l.F.number(f, C, pt)), this._rolling && c.setRoll(l.F.number(v, z, pt)), this._padding && (c.interpolatePadding(w, F, pt), U = c.centerPoint.add(R)), ne.easeFunc(pt, hr, Nt, U), this.terrain && !e.freezeElevation && this._updateElevation(pt), this._applyUpdatedTransform(c), this._fireMoveEvents(a)
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a)
            }), e), this
          }
          isEasing() {
            return !!this._easeFrameId
          }
          stop() {
            return this._stop()
          }
          _stop(e, a) {
            var c;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const h = this._onEaseEnd;
              delete this._onEaseEnd, h.call(this, a)
            }
            return e || (c = this.handlers) === null || c === void 0 || c.stop(!1), this
          }
          _ease(e, a, c) {
            c.animate === !1 || c.duration === 0 ? (e(1), a()) : (this._easeStart = fe(), this._easeOptions = c, this._onEaseFrame = e, this._onEaseEnd = a, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
          }
          _normalizeBearing(e, a) {
            e = l.V(e, -180, 180);
            const c = Math.abs(e - a);
            return Math.abs(e - 360 - a) < c && (e -= 360), Math.abs(e + 360 - a) < c && (e += 360), e
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(l.U.convert(e), this.transform.tileZoom) : null
          }
        }
        const ol = {
          compact: !0,
          customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
        };
        class na {
          constructor(e = ol) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")))
            }, this._updateData = a => {
              !a || a.sourceDataType !== "metadata" && a.sourceDataType !== "visibility" && a.dataType !== "style" && a.type !== "terrain" || this._updateAttributions()
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-right"
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = Z.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = Z.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = Z.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container
          }
          onRemove() {
            Z.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0
          }
          _setElementTitle(e, a) {
            const c = this._map._getUIString(`AttributionControl.${a}`);
            e.title = c, e.setAttribute("aria-label", c)
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((h => typeof h != "string" ? "" : h))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const h = this._map.style.stylesheet;
              this.styleOwner = h.owner, this.styleId = h.id
            }
            const a = this._map.style.tileManagers;
            for (const h in a) {
              const f = a[h];
              if (f.used || f.usedForTerrain) {
                const v = f.getSource();
                v.attribution && e.indexOf(v.attribution) < 0 && e.push(v.attribution)
              }
            }
            e = e.filter((h => String(h).trim())), e.sort(((h, f) => h.length - f.length)), e = e.filter(((h, f) => {
              for (let v = f + 1; v < e.length; v++)
                if (e[v].indexOf(h) >= 0) return !1;
              return !0
            }));
            const c = e.join(" | ");
            c !== this._attribHTML && (this._attribHTML = c, e.length ? (this._innerContainer.innerHTML = Z.sanitize(c), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null)
          }
        }
        class Su {
          constructor(e = {}) {
            this._updateCompact = () => {
              const a = this._container.children;
              if (a.length) {
                const c = a[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && c.classList.add("maplibregl-compact") : c.classList.remove("maplibregl-compact")
              }
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = Z.create("div", "maplibregl-ctrl");
            const a = Z.create("a", "maplibregl-ctrl-logo");
            return a.target = "_blank", a.rel = "noopener nofollow", a.href = "https://maplibre.org/", a.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), a.setAttribute("rel", "noopener nofollow"), this._container.appendChild(a), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
          }
          onRemove() {
            Z.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0
          }
        }
        class Za {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
          }
          add(e) {
            const a = ++this._id;
            return this._queue.push({
              callback: e,
              id: a,
              cancelled: !1
            }), a
          }
          remove(e) {
            const a = this._currentlyRunning,
              c = a ? this._queue.concat(a) : this._queue;
            for (const h of c)
              if (h.id === e) return void(h.cancelled = !0)
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const a = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const c of a)
              if (!c.cancelled && (c.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = []
          }
        }
        var Ld = l.aN([{
          name: "a_pos3d",
          type: "Int16",
          components: 3
        }]);
        class lf extends l.E {
          constructor(e) {
            super(), this._lastTilesetChange = fe(), this.tileManager = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize
          }
          destruct() {
            this.tileManager.usedForTerrain = !1, this.tileManager.tileSize = null
          }
          getSource() {
            return this.tileManager._source
          }
          update(e, a) {
            this.tileManager.update(e, a), this._renderableTilesKeys = [];
            const c = {};
            for (const h of Je(e, {
                tileSize: this.tileSize,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                reparseOverscaled: !1,
                terrain: a,
                calculateTileZoom: this.tileManager._source.calculateTileZoom
              })) c[h.key] = !0, this._renderableTilesKeys.push(h.key), this._tiles[h.key] || (h.terrainRttPosMatrix32f = new Float64Array(16), l.c0(h.terrainRttPosMatrix32f, 0, l.a3, l.a3, 0, 0, 1), this._tiles[h.key] = new le(h, this.tileSize), this._lastTilesetChange = fe());
            for (const h in this._tiles) c[h] || delete this._tiles[h]
          }
          freeRtt(e) {
            for (const a in this._tiles) {
              const c = this._tiles[a];
              (!e || c.tileID.equals(e) || c.tileID.isChildOf(e) || e.isChildOf(c.tileID)) && (c.rtt = [])
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e => this.getTileByID(e)))
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          getTerrainCoords(e, a) {
            return a ? this._getTerrainCoordsForTileRanges(e, a) : this._getTerrainCoordsForRegularTile(e)
          }
          _getTerrainCoordsForRegularTile(e) {
            const a = {};
            for (const c of this._renderableTilesKeys) {
              const h = this._tiles[c].tileID,
                f = e.clone(),
                v = l.bd();
              if (h.canonical.equals(e.canonical)) l.c0(v, 0, l.a3, l.a3, 0, 0, 1);
              else if (h.canonical.isChildOf(e.canonical)) {
                const w = h.canonical.z - e.canonical.z,
                  T = h.canonical.x - (h.canonical.x >> w << w),
                  C = h.canonical.y - (h.canonical.y >> w << w),
                  z = l.a3 >> w;
                l.c0(v, 0, z, z, 0, 0, 1), l.N(v, v, [-T * z, -C * z, 0])
              } else {
                if (!e.canonical.isChildOf(h.canonical)) continue;
                {
                  const w = e.canonical.z - h.canonical.z,
                    T = e.canonical.x - (e.canonical.x >> w << w),
                    C = e.canonical.y - (e.canonical.y >> w << w),
                    z = l.a3 >> w;
                  l.c0(v, 0, l.a3, l.a3, 0, 0, 1), l.N(v, v, [T * z, C * z, 0]), l.O(v, v, [1 / 2 ** w, 1 / 2 ** w, 0])
                }
              }
              f.terrainRttPosMatrix32f = new Float32Array(v), a[c] = f
            }
            return a
          }
          _getTerrainCoordsForTileRanges(e, a) {
            const c = {};
            for (const h of this._renderableTilesKeys) {
              const f = this._tiles[h].tileID;
              if (!this._isWithinTileRanges(f, a)) continue;
              const v = e.clone(),
                w = l.bd();
              if (f.canonical.z === e.canonical.z) {
                const T = e.canonical.x - f.canonical.x,
                  C = e.canonical.y - f.canonical.y;
                l.c0(w, 0, l.a3, l.a3, 0, 0, 1), l.N(w, w, [T * l.a3, C * l.a3, 0])
              } else if (f.canonical.z > e.canonical.z) {
                const T = f.canonical.z - e.canonical.z,
                  C = f.canonical.x - (f.canonical.x >> T << T),
                  z = f.canonical.y - (f.canonical.y >> T << T),
                  F = e.canonical.x - (f.canonical.x >> T),
                  R = e.canonical.y - (f.canonical.y >> T),
                  U = l.a3 >> T;
                l.c0(w, 0, U, U, 0, 0, 1), l.N(w, w, [-C * U + F * l.a3, -z * U + R * l.a3, 0])
              } else {
                const T = e.canonical.z - f.canonical.z,
                  C = e.canonical.x - (e.canonical.x >> T << T),
                  z = e.canonical.y - (e.canonical.y >> T << T),
                  F = (e.canonical.x >> T) - f.canonical.x,
                  R = (e.canonical.y >> T) - f.canonical.y,
                  U = l.a3 << T;
                l.c0(w, 0, U, U, 0, 0, 1), l.N(w, w, [C * l.a3 + F * U, z * l.a3 + R * U, 0])
              }
              v.terrainRttPosMatrix32f = new Float32Array(w), c[h] = v
            }
            return c
          }
          getSourceTile(e, a) {
            const c = this.tileManager._source;
            let h = e.overscaledZ - this.deltaZoom;
            if (h > c.maxzoom && (h = c.maxzoom), h < c.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(h).key);
            let f = this.tileManager.getTileByID(this._sourceTileCache[e.key]);
            if ((!f || !f.dem) && a)
              for (; h >= c.minzoom && (!f || !f.dem);) f = this.tileManager.getTileByID(e.scaledTo(h--).key);
            return f
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e
          }
          _isWithinTileRanges(e, a) {
            return a[e.canonical.z] && e.canonical.x >= a[e.canonical.z].minTileX && e.canonical.x <= a[e.canonical.z].maxTileX && e.canonical.y >= a[e.canonical.z].minTileY && e.canonical.y <= a[e.canonical.z].maxTileY
          }
        }
        class cf {
          constructor(e, a, c) {
            this._meshCache = {}, this.painter = e, this.tileManager = new lf(a), this.options = c, this.exaggeration = typeof c.exaggeration == "number" ? c.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024
          }
          getDEMElevation(e, a, c, h = l.a3) {
            var f;
            if (!(a >= 0 && a < h && c >= 0 && c < h)) return 0;
            const v = this.getTerrainData(e),
              w = (f = v.tile) === null || f === void 0 ? void 0 : f.dem;
            if (!w) return 0;
            const T = l.cv([], [a / h * l.a3, c / h * l.a3], v.u_terrain_matrix),
              C = [T[0] * w.dim, T[1] * w.dim],
              z = Math.floor(C[0]),
              F = Math.floor(C[1]),
              R = C[0] - z,
              U = C[1] - F;
            return w.get(z, F) * (1 - R) * (1 - U) + w.get(z + 1, F) * R * (1 - U) + w.get(z, F + 1) * (1 - R) * U + w.get(z + 1, F + 1) * R * U
          }
          getElevationForLngLatZoom(e, a) {
            if (!l.cw(a, e.wrap())) return 0;
            const {
              tileID: c,
              mercatorX: h,
              mercatorY: f
            } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return this.getElevation(c, h % l.a3, f % l.a3, l.a3)
          }
          getElevation(e, a, c, h = l.a3) {
            return this.getDEMElevation(e, a, c, h) * this.exaggeration
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const h = this.painter.context,
                f = new l.R({
                  width: 1,
                  height: 1
                }, new Uint8Array(4));
              this._emptyDepthTexture = new l.T(h, f, h.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new l.T(h, new l.R({
                width: 1,
                height: 1
              }), h.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemTexture.bind(h.gl.NEAREST, h.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = l.am([])
            }
            const a = this.tileManager.getSourceTile(e, !0);
            if (a && a.dem && (!a.demTexture || a.needsTerrainPrepare)) {
              const h = this.painter.context;
              a.demTexture = this.painter.getTileTexture(a.dem.stride), a.demTexture ? a.demTexture.update(a.dem.getPixels(), {
                premultiply: !1
              }) : a.demTexture = new l.T(h, a.dem.getPixels(), h.gl.RGBA, {
                premultiply: !1
              }), a.demTexture.bind(h.gl.NEAREST, h.gl.CLAMP_TO_EDGE), a.needsTerrainPrepare = !1
            }
            const c = a && a + a.tileID.key + e.key;
            if (c && !this._demMatrixCache[c]) {
              const h = this.tileManager.getSource().maxzoom;
              let f = e.canonical.z - a.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= h ? f = e.canonical.z - h : l.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const v = e.canonical.x - (e.canonical.x >> f << f),
                w = e.canonical.y - (e.canonical.y >> f << f),
                T = l.cx(new Float64Array(16), [1 / (l.a3 << f), 1 / (l.a3 << f), 0]);
              l.N(T, T, [v * l.a3, w * l.a3, 0]), this._demMatrixCache[e.key] = {
                matrix: T,
                coord: e
              }
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: a && a.dem && a.dem.dim || 1,
              u_terrain_matrix: c ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
              u_terrain_unpack: a && a.dem && a.dem.getUnpackVector() || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: (a && a.demTexture || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
              tile: a
            }
          }
          getFramebuffer(e) {
            const a = this.painter,
              c = a.width / devicePixelRatio,
              h = a.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === c && this._fbo.height === h || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new l.T(a.context, {
              width: c,
              height: h,
              data: null
            }, a.context.gl.RGBA, {
              premultiply: !1
            }), this._fboCoordsTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new l.T(a.context, {
              width: c,
              height: h,
              data: null
            }, a.context.gl.RGBA, {
              premultiply: !1
            }), this._fboDepthTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = a.context.createFramebuffer(c, h, !0, !1), this._fbo.depthAttachment.set(a.context.createRenderbuffer(a.context.gl.DEPTH_COMPONENT16, c, h))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const a = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let f = 0, v = 0; f < this._coordsTextureSize; f++)
              for (let w = 0; w < this._coordsTextureSize; w++, v += 4) a[v + 0] = 255 & w, a[v + 1] = 255 & f, a[v + 2] = w >> 8 << 4 | f >> 8, a[v + 3] = 0;
            const c = new l.R({
                width: this._coordsTextureSize,
                height: this._coordsTextureSize
              }, new Uint8Array(a.buffer)),
              h = new l.T(e, c, e.gl.RGBA, {
                premultiply: !1
              });
            return h.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = h, h
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const a = new Uint8Array(4),
              c = this.painter.context,
              h = c.gl,
              f = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio),
              v = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio),
              w = Math.round(this.painter.height / devicePixelRatio);
            c.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), h.readPixels(f, w - v - 1, 1, 1, h.RGBA, h.UNSIGNED_BYTE, a), c.bindFramebuffer.set(null);
            const T = a[0] + (a[2] >> 4 << 8),
              C = a[1] + ((15 & a[2]) << 8),
              z = this.coordsIndex[255 - a[3]],
              F = z && this.tileManager.getTileByID(z);
            if (!F) return null;
            const R = this._coordsTextureSize,
              U = (1 << F.tileID.canonical.z) * R;
            return new l.a5((F.tileID.canonical.x * R + T) / U + F.tileID.wrap, (F.tileID.canonical.y * R + C) / U, this.getElevation(F.tileID, T, C, R))
          }
          depthAtPoint(e) {
            const a = new Uint8Array(4),
              c = this.painter.context,
              h = c.gl;
            return c.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), h.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, h.RGBA, h.UNSIGNED_BYTE, a), c.bindFramebuffer.set(null), (a[0] / 16777216 + a[1] / 65536 + a[2] / 256 + a[3]) / 256
          }
          getTerrainMesh(e) {
            var a;
            const c = ((a = this.painter.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0,
              h = c && e.canonical.y === 0,
              f = c && e.canonical.y === (1 << e.canonical.z) - 1,
              v = `m_${h?"n":""}_${f?"s":""}`;
            if (this._meshCache[v]) return this._meshCache[v];
            const w = this.painter.context,
              T = new l.cy,
              C = new l.aR,
              z = this.meshSize,
              F = l.a3 / z,
              R = z * z;
            for (let ye = 0; ye <= z; ye++)
              for (let Be = 0; Be <= z; Be++) T.emplaceBack(Be * F, ye * F, 0);
            for (let ye = 0; ye < R; ye += z + 1)
              for (let Be = 0; Be < z; Be++) C.emplaceBack(Be + ye, z + Be + ye + 1, z + Be + ye + 2), C.emplaceBack(Be + ye, z + Be + ye + 2, Be + ye + 1);
            const U = T.length,
              Y = U + (z + 1),
              ne = (z + 1) * z,
              ie = h ? l.bk : 0,
              ae = h ? 0 : 1,
              me = f ? l.bl : l.a3,
              ke = f ? 0 : 1;
            for (let ye = 0; ye <= z; ye++) T.emplaceBack(ye * F, ie, ae);
            for (let ye = 0; ye <= z; ye++) T.emplaceBack(ye * F, me, ke);
            for (let ye = 0; ye < z; ye++) C.emplaceBack(ne + ye, Y + ye, Y + ye + 1), C.emplaceBack(ne + ye, Y + ye + 1, ne + ye + 1), C.emplaceBack(0 + ye, U + ye + 1, U + ye), C.emplaceBack(0 + ye, 0 + ye + 1, U + ye + 1);
            const _e = T.length,
              Te = _e + 2 * (z + 1);
            for (const ye of [0, 1])
              for (let Be = 0; Be <= z; Be++)
                for (const ht of [0, 1]) T.emplaceBack(ye * l.a3, Be * F, ht);
            for (let ye = 0; ye < 2 * z; ye += 2) C.emplaceBack(_e + ye, _e + ye + 1, _e + ye + 3), C.emplaceBack(_e + ye, _e + ye + 3, _e + ye + 2), C.emplaceBack(Te + ye, Te + ye + 3, Te + ye + 1), C.emplaceBack(Te + ye, Te + ye + 2, Te + ye + 3);
            const Ee = new Fn(w.createVertexBuffer(T, Ld.members), w.createIndexBuffer(C), l.aQ.simpleSegment(0, 0, T.length, C.length));
            return this._meshCache[v] = Ee, Ee
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * l.bx / Math.pow(2, Math.max(e, 0)) / 5
          }
          getMinTileElevationForLngLatZoom(e, a) {
            var c;
            const {
              tileID: h
            } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return (c = this.getMinMaxElevation(h).minElevation) !== null && c !== void 0 ? c : 0
          }
          getMinMaxElevation(e) {
            const a = this.getTerrainData(e).tile,
              c = {
                minElevation: null,
                maxElevation: null
              };
            return a && a.dem && (c.minElevation = a.dem.min * this.exaggeration, c.maxElevation = a.dem.max * this.exaggeration), c
          }
          _getOverscaledTileIDFromLngLatZoom(e, a) {
            const c = l.a5.fromLngLat(e.wrap()),
              h = (1 << a) * l.a3,
              f = c.x * h,
              v = c.y * h,
              w = Math.floor(f / l.a3),
              T = Math.floor(v / l.a3);
            return {
              tileID: new l.a0(a, 0, a, w, T),
              mercatorX: f,
              mercatorY: v
            }
          }
        }
        class uf {
          constructor(e, a, c) {
            this._context = e, this._size = a, this._tileSize = c, this._objects = [], this._recentlyUsed = [], this._stamp = 0
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy()
          }
          _createObject(e) {
            const a = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0),
              c = new l.T(this._context, {
                width: this._tileSize,
                height: this._tileSize,
                data: null
              }, this._context.gl.RGBA);
            return c.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), a.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), a.colorAttachment.set(c.texture), {
              id: e,
              fbo: a,
              texture: c,
              stamp: -1,
              inUse: !1
            }
          }
          getObjectForId(e) {
            return this._objects[e]
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((a => e.id !== a)), this._recentlyUsed.push(e.id)
          }
          stampObject(e) {
            e.stamp = ++this._stamp
          }
          getOrCreateFreeObject() {
            for (const a of this._recentlyUsed)
              if (!this._objects[a].inUse) return this._objects[a];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e
          }
          freeObject(e) {
            e.inUse = !1
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e)
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((e => !e.inUse)) === !1
          }
        }
        const no = {
          background: !0,
          fill: !0,
          line: !0,
          raster: !0,
          hillshade: !0,
          "color-relief": !0
        };
        class fi {
          constructor(e, a) {
            this.painter = e, this.terrain = a, this.pool = new uf(e.context, 30, a.tileManager.tileSize * a.qualityFactor)
          }
          destruct() {
            this.pool.destruct()
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
          }
          prepareForRender(e, a) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e._order.filter((c => !e._layers[c].isHidden(a))), this._coordsAscending = {};
            for (const c in e.tileManagers) {
              this._coordsAscending[c] = {};
              const h = e.tileManagers[c].getVisibleCoordinates(),
                f = e.tileManagers[c].getSource(),
                v = f instanceof Ht ? f.terrainTileRanges : null;
              for (const w of h) {
                const T = this.terrain.tileManager.getTerrainCoords(w, v);
                for (const C in T) this._coordsAscending[c][C] || (this._coordsAscending[c][C] = []), this._coordsAscending[c][C].push(T[C])
              }
            }
            this._coordsAscendingStr = {};
            for (const c of e._order) {
              const h = e._layers[c],
                f = h.source;
              if (no[h.type] && !this._coordsAscendingStr[f]) {
                this._coordsAscendingStr[f] = {};
                for (const v in this._coordsAscending[f]) this._coordsAscendingStr[f][v] = this._coordsAscending[f][v].map((w => w.key)).sort().join()
              }
            }
            for (const c of this._renderableTiles)
              for (const h in this._coordsAscendingStr) {
                const f = this._coordsAscendingStr[h][c.tileID.key];
                f && f !== c.rttCoords[h] && (c.rtt = [])
              }
          }
          renderLayer(e, a) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const c = Object.assign(Object.assign({}, a), {
                isRenderingToTexture: !0
              }),
              h = e.type,
              f = this.painter,
              v = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (no[h] && (this._prevType && no[this._prevType] || this._stacks.push([]), this._prevType = h, this._stacks[this._stacks.length - 1].push(e.id), !v)) return !0;
            if (no[this._prevType] || no[h] && v) {
              this._prevType = h;
              const w = this._stacks.length - 1,
                T = this._stacks[w] || [];
              for (const C of this._renderableTiles) {
                if (this.pool.isFull() && (fu(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(C), C.rtt[w]) {
                  const F = this.pool.getObjectForId(C.rtt[w].id);
                  if (F.stamp === C.rtt[w].stamp) {
                    this.pool.useObject(F);
                    continue
                  }
                }
                const z = this.pool.getOrCreateFreeObject();
                this.pool.useObject(z), this.pool.stampObject(z), C.rtt[w] = {
                  id: z.id,
                  stamp: z.stamp
                }, f.context.bindFramebuffer.set(z.fbo.framebuffer), f.context.clear({
                  color: l.bi.transparent,
                  stencil: 0
                }), f.currentStencilSource = void 0;
                for (let F = 0; F < T.length; F++) {
                  const R = f.style._layers[T[F]],
                    U = R.source ? this._coordsAscending[R.source][C.tileID.key] : [C.tileID];
                  f.context.viewport.set([0, 0, z.fbo.width, z.fbo.height]), f._renderTileClippingMasks(R, U, !0), f.renderLayer(f, f.style.tileManagers[R.source], R, U, c), R.source && (C.rttCoords[R.source] = this._coordsAscendingStr[R.source][C.tileID.key])
                }
              }
              return fu(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects(), no[h]
            }
            return !1
          }
        }
        const wi = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "MapLibre logo",
            "Map.Title": "Map",
            "Marker.Title": "Map marker",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "Popup.Close": "Close popup",
            "ScaleControl.Feet": "ft",
            "ScaleControl.Meters": "m",
            "ScaleControl.Kilometers": "km",
            "ScaleControl.Miles": "mi",
            "ScaleControl.NauticalMiles": "nm",
            "GlobeControl.Enable": "Enable globe",
            "GlobeControl.Disable": "Disable globe",
            "TerrainControl.Enable": "Enable terrain",
            "TerrainControl.Disable": "Disable terrain",
            "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
            "CooperativeGesturesHandler.MacHelpText": "Use âŒ˜ + scroll to zoom the map",
            "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
          },
          Dd = j,
          As = {
            hash: !1,
            interactive: !0,
            bearingSnap: 7,
            attributionControl: ol,
            maplibreLogo: !1,
            refreshExpiredTiles: !0,
            canvasContextAttributes: {
              antialias: !1,
              preserveDrawingBuffer: !1,
              powerPreference: "high-performance",
              failIfMajorPerformanceCaveat: !1,
              desynchronized: !1,
              contextType: void 0
            },
            scrollZoom: !0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            trackResize: !0,
            center: [0, 0],
            elevation: 0,
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            renderWorldCopies: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: l.a.MAX_TILE_CACHE_ZOOM_LEVELS,
            transformRequest: null,
            transformCameraUpdate: null,
            transformConstrain: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            clickTolerance: 3,
            localIdeographFontFamily: "sans-serif",
            pitchWithRotate: !0,
            rollEnabled: !1,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096],
            cancelPendingTileRequestsWhileZooming: !0,
            centerClampedToGround: !0
          },
          Ql = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1,
            visualizeRoll: !0
          };
        class Mu {
          constructor(e, a, c = !1) {
            this.mousedown = f => {
              this.startMove(f, Z.mousePos(this.element, f)), Z.addEventListener(window, "mousemove", this.mousemove), Z.addEventListener(window, "mouseup", this.mouseup)
            }, this.mousemove = f => {
              this.move(f, Z.mousePos(this.element, f))
            }, this.mouseup = f => {
              this._rotatePitchHandler.dragEnd(f), this.offTemp()
            }, this.touchstart = f => {
              f.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = Z.touchPos(this.element, f.targetTouches)[0], this.startMove(f, this._startPos), Z.addEventListener(window, "touchmove", this.touchmove, {
                passive: !1
              }), Z.addEventListener(window, "touchend", this.touchend))
            }, this.touchmove = f => {
              f.targetTouches.length !== 1 ? this.reset() : (this._lastPos = Z.touchPos(this.element, f.targetTouches)[0], this.move(f, this._lastPos))
            }, this.touchend = f => {
              f.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this._clickTolerance = 10, this.element = a;
            const h = new yu;
            this._rotatePitchHandler = new Er({
              clickTolerance: 3,
              move: (f, v) => {
                const w = a.getBoundingClientRect(),
                  T = new l.P((w.bottom - w.top) / 2, (w.right - w.left) / 2);
                return {
                  bearingDelta: l.cq(new l.P(f.x, v.y), v, T),
                  pitchDelta: c ? -.5 * (v.y - f.y) : void 0
                }
              },
              moveStateManager: h,
              enable: !0,
              assignEvents: () => {}
            }), this.map = e, Z.addEventListener(a, "mousedown", this.mousedown), Z.addEventListener(a, "touchstart", this.touchstart, {
              passive: !1
            }), Z.addEventListener(a, "touchcancel", this.reset)
          }
          startMove(e, a) {
            this._rotatePitchHandler.dragStart(e, a), Z.disableDrag()
          }
          move(e, a) {
            const c = this.map,
              {
                bearingDelta: h,
                pitchDelta: f
              } = this._rotatePitchHandler.dragMove(e, a) || {};
            h && c.setBearing(c.getBearing() + h), f && c.setPitch(c.getPitch() + f)
          }
          off() {
            const e = this.element;
            Z.removeEventListener(e, "mousedown", this.mousedown), Z.removeEventListener(e, "touchstart", this.touchstart, {
              passive: !1
            }), Z.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), Z.removeEventListener(window, "touchend", this.touchend), Z.removeEventListener(e, "touchcancel", this.reset), this.offTemp()
          }
          offTemp() {
            Z.enableDrag(), Z.removeEventListener(window, "mousemove", this.mousemove), Z.removeEventListener(window, "mouseup", this.mouseup), Z.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), Z.removeEventListener(window, "touchend", this.touchend)
          }
        }
        let vo;

        function ec(p, e, a, c = !1) {
          if (c || !a.getCoveringTilesDetailsProvider().allowWorldCopies()) return p == null ? void 0 : p.wrap();
          const h = new l.U(p.lng, p.lat);
          if (p = new l.U(p.lng, p.lat), e) {
            const f = new l.U(p.lng - 360, p.lat),
              v = new l.U(p.lng + 360, p.lat),
              w = a.locationToScreenPoint(p).distSqr(e);
            a.locationToScreenPoint(f).distSqr(e) < w ? p = f : a.locationToScreenPoint(v).distSqr(e) < w && (p = v)
          }
          for (; Math.abs(p.lng - a.center.lng) > 180;) {
            const f = a.locationToScreenPoint(p);
            if (f.x >= 0 && f.y >= 0 && f.x <= a.width && f.y <= a.height) break;
            p.lng > a.center.lng ? p.lng -= 360 : p.lng += 360
          }
          return p.lng !== h.lng && a.isPointOnMapSurface(a.locationToScreenPoint(p)) ? p : h
        }
        const es = {
          center: "translate(-50%,-50%)",
          top: "translate(-50%,0)",
          "top-left": "translate(0,0)",
          "top-right": "translate(-100%,0)",
          bottom: "translate(-50%,-100%)",
          "bottom-left": "translate(0,-100%)",
          "bottom-right": "translate(-100%,-100%)",
          left: "translate(0,-50%)",
          right: "translate(-100%,-50%)"
        };

        function tc(p, e, a) {
          const c = p.classList;
          for (const h in es) c.remove(`maplibregl-${a}-anchor-${h}`);
          c.add(`maplibregl-${a}-anchor-${e}`)
        }
        class sl extends l.E {
          constructor(e) {
            if (super(), this._onKeyPress = a => {
                const c = a.code,
                  h = a.charCode || a.keyCode;
                c !== "Space" && c !== "Enter" && h !== 32 && h !== 13 || this.togglePopup()
              }, this._onMapClick = a => {
                const c = a.originalEvent.target,
                  h = this._element;
                this._popup && (c === h || h.contains(c)) && this.togglePopup()
              }, this._update = a => {
                if (!this._map) return;
                const c = this._map.loaded() && !this._map.isMoving();
                ((a == null ? void 0 : a.type) === "terrain" || (a == null ? void 0 : a.type) === "render" && !c) && this._map.once("render", this._update), this._lngLat = ec(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                let h = "";
                this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? h = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (h = `rotateZ(${this._rotation-this._map.getBearing()}deg)`);
                let f = "";
                this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? f = "rotateX(0deg)" : this._pitchAlignment === "map" && (f = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || a && a.type !== "moveend" || (this._pos = this._pos.round()), Z.setTransform(this._element, `${es[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${f} ${h}`), ce.frameAsync(new AbortController).then((() => {
                  this._updateOpacity(a && a.type === "moveend")
                })).catch((() => {}))
              }, this._onMove = a => {
                if (!this._isDragging) {
                  const c = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = a.point.dist(this._pointerdownPos) >= c
                }
                this._isDragging && (this._pos = a.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new l.l("dragstart"))), this.fire(new l.l("drag")))
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new l.l("dragend")), this._state = "inactive"
              }, this._addDragHandler = a => {
                this._element.contains(a.originalEvent.target) && (a.preventDefault(), this._positionDelta = a.point.sub(this._pos).add(this._offset), this._pointerdownPos = a.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp))
              }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = l.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = Z.create("div");
              const a = Z.createNS("http://www.w3.org/2000/svg", "svg"),
                c = 41,
                h = 27;
              a.setAttributeNS(null, "display", "block"), a.setAttributeNS(null, "height", `${c}px`), a.setAttributeNS(null, "width", `${h}px`), a.setAttributeNS(null, "viewBox", `0 0 ${h} ${c}`);
              const f = Z.createNS("http://www.w3.org/2000/svg", "g");
              f.setAttributeNS(null, "stroke", "none"), f.setAttributeNS(null, "stroke-width", "1"), f.setAttributeNS(null, "fill", "none"), f.setAttributeNS(null, "fill-rule", "evenodd");
              const v = Z.createNS("http://www.w3.org/2000/svg", "g");
              v.setAttributeNS(null, "fill-rule", "nonzero");
              const w = Z.createNS("http://www.w3.org/2000/svg", "g");
              w.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), w.setAttributeNS(null, "fill", "#000000");
              const T = [{
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "9.5",
                ry: "4.77275007"
              }, {
                rx: "8.5",
                ry: "4.29549936"
              }, {
                rx: "7.5",
                ry: "3.81822308"
              }, {
                rx: "6.5",
                ry: "3.34094679"
              }, {
                rx: "5.5",
                ry: "2.86367051"
              }, {
                rx: "4.5",
                ry: "2.38636864"
              }];
              for (const ae of T) {
                const me = Z.createNS("http://www.w3.org/2000/svg", "ellipse");
                me.setAttributeNS(null, "opacity", "0.04"), me.setAttributeNS(null, "cx", "10.5"), me.setAttributeNS(null, "cy", "5.80029008"), me.setAttributeNS(null, "rx", ae.rx), me.setAttributeNS(null, "ry", ae.ry), w.appendChild(me)
              }
              const C = Z.createNS("http://www.w3.org/2000/svg", "g");
              C.setAttributeNS(null, "fill", this._color);
              const z = Z.createNS("http://www.w3.org/2000/svg", "path");
              z.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), C.appendChild(z);
              const F = Z.createNS("http://www.w3.org/2000/svg", "g");
              F.setAttributeNS(null, "opacity", "0.25"), F.setAttributeNS(null, "fill", "#000000");
              const R = Z.createNS("http://www.w3.org/2000/svg", "path");
              R.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), F.appendChild(R);
              const U = Z.createNS("http://www.w3.org/2000/svg", "g");
              U.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), U.setAttributeNS(null, "fill", "#FFFFFF");
              const Y = Z.createNS("http://www.w3.org/2000/svg", "g");
              Y.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const ne = Z.createNS("http://www.w3.org/2000/svg", "circle");
              ne.setAttributeNS(null, "fill", "#000000"), ne.setAttributeNS(null, "opacity", "0.25"), ne.setAttributeNS(null, "cx", "5.5"), ne.setAttributeNS(null, "cy", "5.5"), ne.setAttributeNS(null, "r", "5.4999962");
              const ie = Z.createNS("http://www.w3.org/2000/svg", "circle");
              ie.setAttributeNS(null, "fill", "#FFFFFF"), ie.setAttributeNS(null, "cx", "5.5"), ie.setAttributeNS(null, "cy", "5.5"), ie.setAttributeNS(null, "r", "5.4999962"), Y.appendChild(ne), Y.appendChild(ie), v.appendChild(w), v.appendChild(C), v.appendChild(F), v.appendChild(U), v.appendChild(Y), a.appendChild(v), a.setAttributeNS(null, "height", c * this._scale + "px"), a.setAttributeNS(null, "width", h * this._scale + "px"), this._element.appendChild(a), this._offset = l.P.convert(e && e.offset || [0, -14])
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (a => {
                a.preventDefault()
              })), this._element.addEventListener("mousedown", (a => {
                a.preventDefault()
              })), tc(this._element, this._anchor, "marker"), e && e.className)
              for (const a of e.className.split(" ")) this._element.classList.add(a);
            this._popup = null
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), Z.remove(this._element), this._popup && this._popup.remove(), this
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(e) {
            return this._lngLat = l.U.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this
          }
          getElement() {
            return this._element
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const h = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? {
                  top: [0, 0],
                  "top-left": [0, 0],
                  "top-right": [0, 0],
                  bottom: [0, -38.1],
                  "bottom-left": [h, -1 * (38.1 - 13.5 + h)],
                  "bottom-right": [-h, -1 * (38.1 - 13.5 + h)],
                  left: [13.5, -1 * (38.1 - 13.5)],
                  right: [-13.5, -1 * (38.1 - 13.5)]
                } : this._offset
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress)
            }
            return this
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this
          }
          getPopup() {
            return this._popup
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this
          }
          _updateOpacity(e = !1) {
            var a, c;
            const h = (a = this._map) === null || a === void 0 ? void 0 : a.terrain,
              f = this._map.transform.isLocationOccluded(this._lngLat);
            if (!h || f) {
              const U = f ? this._opacityWhenCovered : this._opacity;
              return void(this._element.style.opacity !== U && (this._element.style.opacity = U))
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null
              }), 100)
            }
            const v = this._map,
              w = v.terrain.depthAtPoint(this._pos),
              T = v.terrain.getElevationForLngLatZoom(this._lngLat, v.transform.tileZoom);
            if (v.transform.lngLatToCameraDepth(this._lngLat, T) - w < .006) return void(this._element.style.opacity = this._opacity);
            const C = -this._offset.y / v.transform.pixelsPerMeter,
              z = Math.sin(v.getPitch() * Math.PI / 180) * C,
              F = v.terrain.depthAtPoint(new l.P(this._pos.x, this._pos.y - this._offset.y)),
              R = v.transform.lngLatToCameraDepth(this._lngLat, T + z) - F > .006;
            !((c = this._popup) === null || c === void 0) && c.isOpen() && R && this._popup.remove(), this._element.style.opacity = R ? this._opacityWhenCovered : this._opacity
          }
          getOffset() {
            return this._offset
          }
          setOffset(e) {
            return this._offset = l.P.convert(e), this._update(), this
          }
          addClassName(e) {
            this._element.classList.add(e)
          }
          removeClassName(e) {
            this._element.classList.remove(e)
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e)
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this
          }
          isDraggable() {
            return this._draggable
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this
          }
          getRotation() {
            return this._rotation
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this
          }
          getRotationAlignment() {
            return this._rotationAlignment
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this
          }
          getPitchAlignment() {
            return this._pitchAlignment
          }
          setOpacity(e, a) {
            return (this._opacity === void 0 || e === void 0 && a === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), a !== void 0 && (this._opacityWhenCovered = a), this._map && this._updateOpacity(!0), this
          }
        }
        const Iu = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3
          },
          fitBoundsOptions: {
            maxZoom: 15
          },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0
        };
        let zs = 0,
          ts = !1;
        const Cu = {
          maxWidth: 100,
          unit: "metric"
        };

        function rc(p, e, a) {
          const c = a && a.maxWidth || 100,
            h = p._container.clientHeight / 2,
            f = p._container.clientWidth / 2,
            v = p.unproject([f - c / 2, h]),
            w = p.unproject([f + c / 2, h]),
            T = Math.round(p.project(w).x - p.project(v).x),
            C = Math.min(c, T, p._container.clientWidth),
            z = v.distanceTo(w);
          if (a && a.unit === "imperial") {
            const F = 3.2808 * z;
            F > 5280 ? rs(e, C, F / 5280, p._getUIString("ScaleControl.Miles")) : rs(e, C, F, p._getUIString("ScaleControl.Feet"))
          } else a && a.unit === "nautical" ? rs(e, C, z / 1852, p._getUIString("ScaleControl.NauticalMiles")) : z >= 1e3 ? rs(e, C, z / 1e3, p._getUIString("ScaleControl.Kilometers")) : rs(e, C, z, p._getUIString("ScaleControl.Meters"))
        }

        function rs(p, e, a, c) {
          const h = (function(f) {
            const v = Math.pow(10, `${Math.floor(f)}`.length - 1);
            let w = f / v;
            return w = w >= 10 ? 10 : w >= 5 ? 5 : w >= 3 ? 3 : w >= 2 ? 2 : w >= 1 ? 1 : (function(T) {
              const C = Math.pow(10, Math.ceil(-Math.log(T) / Math.LN10));
              return Math.round(T * C) / C
            })(w), v * w
          })(a);
          p.style.width = e * (h / a) + "px", p.innerHTML = `${h}&nbsp;${c}`
        }
        const Au = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            subpixelPositioning: !1,
            locationOccludedOpacity: void 0
          },
          nc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

        function ic(p) {
          if (p) {
            if (typeof p == "number") {
              const e = Math.round(Math.abs(p) / Math.SQRT2);
              return {
                center: new l.P(0, 0),
                top: new l.P(0, p),
                "top-left": new l.P(e, e),
                "top-right": new l.P(-e, e),
                bottom: new l.P(0, -p),
                "bottom-left": new l.P(e, -e),
                "bottom-right": new l.P(-e, -e),
                left: new l.P(p, 0),
                right: new l.P(-p, 0)
              }
            }
            if (p instanceof l.P || Array.isArray(p)) {
              const e = l.P.convert(p);
              return {
                center: e,
                top: e,
                "top-left": e,
                "top-right": e,
                bottom: e,
                "bottom-left": e,
                "bottom-right": e,
                left: e,
                right: e
              }
            }
            return {
              center: l.P.convert(p.center || [0, 0]),
              top: l.P.convert(p.top || [0, 0]),
              "top-left": l.P.convert(p["top-left"] || [0, 0]),
              "top-right": l.P.convert(p["top-right"] || [0, 0]),
              bottom: l.P.convert(p.bottom || [0, 0]),
              "bottom-left": l.P.convert(p["bottom-left"] || [0, 0]),
              "bottom-right": l.P.convert(p["bottom-right"] || [0, 0]),
              left: l.P.convert(p.left || [0, 0]),
              right: l.P.convert(p.right || [0, 0])
            }
          }
          return ic(new l.P(0, 0))
        }
        const zu = j;
        k.AJAXError = l.cC, k.Event = l.l, k.Evented = l.E, k.LngLat = l.U, k.MercatorCoordinate = l.a5, k.Point = l.P, k.addProtocol = l.cD, k.config = l.a, k.removeProtocol = l.cE, k.AttributionControl = na, k.BoxZoomHandler = xd, k.CanvasSource = Rr, k.CooperativeGesturesHandler = Ua, k.DoubleClickZoomHandler = il, k.DragPanHandler = Tu, k.DragRotateHandler = Pu, k.EdgeInsets = nn, k.FullscreenControl = class extends l.E {
          constructor(p = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let a = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = a == null ? void 0 : a.shadowRoot) === null || e === void 0) && e.fullscreenElement;) a = a.shadowRoot.fullscreenElement;
              a === this._container !== this._fullscreen && this._handleFullscreenChange()
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
            }, this._fullscreen = !1, p && p.container && (p.container instanceof HTMLElement ? this._container = p.container : l.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange")
          }
          onAdd(p) {
            return this._map = p, this._container || (this._container = this._map.getContainer()), this._controlContainer = Z.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer
          }
          onRemove() {
            Z.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _setupUI() {
            const p = this._fullscreenButton = Z.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            Z.create("span", "maplibregl-ctrl-icon", p).setAttribute("aria-hidden", "true"), p.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _updateTitle() {
            const p = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", p), this._fullscreenButton.title = p
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
          }
          _isFullscreen() {
            return this._fullscreen
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new l.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new l.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize()
          }
        }, k.GeoJSONSource = pr, k.GeolocateControl = class extends l.E {
          constructor(p) {
            super(), this._onSuccess = e => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new l.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`)
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new l.l("geolocate", e)), this._finish()
              }
            }, this._updateCamera = e => {
              const a = new l.U(e.coords.longitude, e.coords.latitude),
                c = e.coords.accuracy,
                h = this._map.getBearing(),
                f = l.e({
                  bearing: h
                }, this.options.fitBoundsOptions),
                v = yt.fromLngLat(a, c);
              this._map.fitBounds(v, f, {
                geolocateSource: !0
              })
            }, this._updateMarker = e => {
              if (e) {
                const a = new l.U(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(a).addTo(this._map), this._userLocationDotMarker.setLngLat(a).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded()
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded()
            }, this._onError = e => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a), this._geolocationWatchID !== void 0 && this._clearWatch()
                } else {
                  if (e.code === 3 && ts) return;
                  this._setErrorState()
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new l.l("error", e)), this._finish()
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e => e.preventDefault())), this._geolocateButton = Z.create("button", "maplibregl-ctrl-geolocate", this._container), Z.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0)
            }, this._finishSetupUI = e => {
              if (this._map) {
                if (e === !1) {
                  l.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a)
                } else {
                  const a = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a)
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = Z.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new sl({
                  element: this._dotElement
                }), this._circleElement = Z.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new sl({
                  element: this._circleElement,
                  pitchAlignment: "map"
                }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (a => {
                  const c = (a == null ? void 0 : a[0]) instanceof ResizeObserverEntry;
                  a.geolocateSource || this._watchState !== "ACTIVE_LOCK" || c || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new l.l("trackuserlocationend")), this.fire(new l.l("userlocationlostfocus")))
                }))
              }
            }, this.options = l.e({}, Iu, p)
          }
          onAdd(p) {
            return this._map = p, this._container = Z.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return l._(this, arguments, void 0, (function*(e = !1) {
                if (vo !== void 0 && !e) return vo;
                if (window.navigator.permissions === void 0) return vo = !!window.navigator.geolocation, vo;
                try {
                  vo = (yield window.navigator.permissions.query({
                    name: "geolocation"
                  })).state !== "denied"
                } catch {
                  vo = !!window.navigator.geolocation
                }
                return vo
              }))
            })().then((e => this._finishSetupUI(e))), this._container
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), Z.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, zs = 0, ts = !1
          }
          _isOutOfMapMaxBounds(p) {
            const e = this._map.getMaxBounds(),
              a = p.coords;
            return e && (a.longitude < e.getWest() || a.longitude > e.getEast() || a.latitude < e.getSouth() || a.latitude > e.getNorth())
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`)
            }
          }
          _updateCircleRadiusIfNeeded() {
            const p = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && p)) return;
            const e = this._map.project(p),
              a = this._map.unproject([e.x + 100, e.y]),
              c = p.distanceTo(a) / 100,
              h = 2 * this._accuracy / c;
            this._circleElement.style.width = `${h.toFixed(2)}px`, this._circleElement.style.height = `${h.toFixed(2)}px`
          }
          trigger() {
            if (!this._setup) return l.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new l.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  zs--, ts = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new l.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new l.l("trackuserlocationstart")), this.fire(new l.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let p;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), zs++, zs > 1 ? (p = {
                  maximumAge: 6e5,
                  timeout: 0
                }, ts = !0) : (p = this.options.positionOptions, ts = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, p)
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
          }
        }, k.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var p;
              const e = (p = this._map.getProjection()) === null || p === void 0 ? void 0 : p.type;
              this._map.setProjection(e !== "mercator" && e ? {
                type: "mercator"
              } : {
                type: "globe"
              }), this._updateGlobeIcon()
            }, this._updateGlobeIcon = () => {
              var p;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((p = this._map.getProjection()) === null || p === void 0 ? void 0 : p.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
            }
          }
          onAdd(p) {
            return this._map = p, this._container = Z.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = Z.create("button", "maplibregl-ctrl-globe", this._container), Z.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container
          }
          onRemove() {
            Z.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0
          }
        }, k.Hash = mu, k.ImageSource = Ht, k.KeyboardHandler = Id, k.LngLatBounds = yt, k.LogoControl = Su, k.Map = class extends Ed {
          constructor(p) {
            var e, a;
            l.cz.mark(l.cA.create);
            const c = Object.assign(Object.assign(Object.assign({}, As), p), {
              canvasContextAttributes: Object.assign(Object.assign({}, As.canvasContextAttributes), p.canvasContextAttributes)
            });
            if (c.minZoom != null && c.maxZoom != null && c.minZoom > c.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (c.minPitch != null && c.maxPitch != null && c.minPitch > c.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (c.minPitch != null && c.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (c.maxPitch != null && c.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const h = new Nn,
              f = new ci;
            if (c.minZoom !== void 0 && h.setMinZoom(c.minZoom), c.maxZoom !== void 0 && h.setMaxZoom(c.maxZoom), c.minPitch !== void 0 && h.setMinPitch(c.minPitch), c.maxPitch !== void 0 && h.setMaxPitch(c.maxPitch), c.renderWorldCopies !== void 0 && h.setRenderWorldCopies(c.renderWorldCopies), c.transformConstrain !== null && h.setConstrain(c.transformConstrain), super(h, f, {
                bearingSnap: c.bearingSnap
              }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Za, this._controls = [], this._mapId = l.ab(), this._contextLost = w => {
                w.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new l.l("webglcontextlost", {
                  originalEvent: w
                }))
              }, this._contextRestored = w => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new l.l("webglcontextrestored", {
                  originalEvent: w
                }))
              }, this._onMapScroll = w => {
                if (w.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
              }, this._onWindowOnline = () => {
                this._update()
              }, this._interactive = c.interactive, this._maxTileCacheSize = c.maxTileCacheSize, this._maxTileCacheZoomLevels = c.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, c.canvasContextAttributes), this._trackResize = c.trackResize === !0, this._bearingSnap = c.bearingSnap, this._centerClampedToGround = c.centerClampedToGround, this._refreshExpiredTiles = c.refreshExpiredTiles === !0, this._fadeDuration = c.fadeDuration, this._crossSourceCollisions = c.crossSourceCollisions === !0, this._collectResourceTiming = c.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, wi), c.locale), this._clickTolerance = c.clickTolerance, this._overridePixelRatio = c.pixelRatio, this._maxCanvasSize = c.maxCanvasSize, this.transformCameraUpdate = c.transformCameraUpdate, this.transformConstrain = c.transformConstrain, this.cancelPendingTileRequestsWhileZooming = c.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Ve.addThrottleControl((() => this.isMoving())), this._requestManager = new ve(c.transformRequest), typeof c.container == "string") {
              if (this._container = document.getElementById(c.container), !this._container) throw new Error(`Container '${c.container}' not found.`)
            } else {
              if (!(c.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = c.container
            }
            if (c.maxBounds && this.setMaxBounds(c.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
                this.painter.terrainFacilitator.dirty = !0, this._update(!0)
              })), this.once("idle", (() => {
                this._idleTriggered = !0
              })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let w = !1;
              const T = _u((C => {
                this._trackResize && !this._removed && (this.resize(C), this.redraw())
              }), 50);
              this._resizeObserver = new ResizeObserver((C => {
                w ? T(C) : w = !0
              })), this._resizeObserver.observe(this._container)
            }
            this.handlers = new al(this, c), this._hash = c.hash && new mu(typeof c.hash == "string" && c.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
              center: c.center,
              elevation: c.elevation,
              zoom: c.zoom,
              bearing: c.bearing,
              pitch: c.pitch,
              roll: c.roll
            }), c.bounds && (this.resize(), this.fitBounds(c.bounds, l.e({}, c.fitBoundsOptions, {
              duration: 0
            }))));
            const v = typeof c.style == "string" || ((a = (e = c.style) === null || e === void 0 ? void 0 : e.projection) === null || a === void 0 ? void 0 : a.type) !== "globe";
            this.resize(null, v), this._localIdeographFontFamily = c.localIdeographFontFamily, this._validateStyle = c.validateStyle, c.style && this.setStyle(c.style, {
              localIdeographFontFamily: c.localIdeographFontFamily
            }), c.attributionControl && this.addControl(new na(typeof c.attributionControl == "boolean" ? void 0 : c.attributionControl)), c.maplibreLogo && this.addControl(new Su, c.logoPosition), this.on("style.load", (() => {
              if (v || this._resizeTransform(), this.transform.unmodified) {
                const w = l.S(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(w)
              }
            })), this.on("data", (w => {
              this._update(w.dataType === "style"), this.fire(new l.l(`${w.dataType}data`, w))
            })), this.on("dataloading", (w => {
              this.fire(new l.l(`${w.dataType}dataloading`, w))
            })), this.on("dataabort", (w => {
              this.fire(new l.l("sourcedataabort", w))
            }))
          }
          _getMapId() {
            return this._mapId
          }
          setGlobalStateProperty(p, e) {
            return this.style.setGlobalStateProperty(p, e), this._update(!0)
          }
          getGlobalState() {
            return this.style.getGlobalState()
          }
          addControl(p, e) {
            if (e === void 0 && (e = p.getDefaultPosition ? p.getDefaultPosition() : "top-right"), !p || !p.onAdd) return this.fire(new l.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a = p.onAdd(this);
            this._controls.push(p);
            const c = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? c.insertBefore(a, c.firstChild) : c.appendChild(a), this
          }
          removeControl(p) {
            if (!p || !p.onRemove) return this.fire(new l.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(p);
            return e > -1 && this._controls.splice(e, 1), p.onRemove(this), this
          }
          hasControl(p) {
            return this._controls.indexOf(p) > -1
          }
          coveringTiles(p) {
            return Je(this.transform, p)
          }
          calculateCameraOptionsFromTo(p, e, a, c) {
            return c == null && this.terrain && (c = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(p, e, a, c)
          }
          resize(p, e = !0) {
            const [a, c] = this._containerDimensions(), h = this._getClampedPixelRatio(a, c);
            if (this._resizeCanvas(a, c, h), this.painter.resize(a, c, h), this.painter.overLimit()) {
              const v = this.painter.context.gl;
              this._maxCanvasSize = [v.drawingBufferWidth, v.drawingBufferHeight];
              const w = this._getClampedPixelRatio(a, c);
              this._resizeCanvas(a, c, w), this.painter.resize(a, c, w)
            }
            this._resizeTransform(e);
            const f = !this._moving;
            return f && (this.stop(), this.fire(new l.l("movestart", p)).fire(new l.l("move", p))), this.fire(new l.l("resize", p)), f && this.fire(new l.l("moveend", p)), this
          }
          _resizeTransform(p = !0) {
            var e;
            const [a, c] = this._containerDimensions();
            this.transform.resize(a, c, p), (e = this._requestedCameraState) === null || e === void 0 || e.resize(a, c, p)
          }
          _getClampedPixelRatio(p, e) {
            const {
              0: a,
              1: c
            } = this._maxCanvasSize, h = this.getPixelRatio(), f = p * h, v = e * h;
            return Math.min(f > a ? a / f : 1, v > c ? c / v : 1) * h
          }
          getPixelRatio() {
            var p;
            return (p = this._overridePixelRatio) !== null && p !== void 0 ? p : devicePixelRatio
          }
          setPixelRatio(p) {
            this._overridePixelRatio = p, this.resize()
          }
          getBounds() {
            return this.transform.getBounds()
          }
          getMaxBounds() {
            return this.transform.getMaxBounds()
          }
          setMaxBounds(p) {
            return this.transform.setMaxBounds(yt.convert(p)), this._update()
          }
          setMinZoom(p) {
            if ((p = p ?? -2) >= -2 && p <= this.transform.maxZoom) return this.transform.setMinZoom(p), this._update(), this.getZoom() < p && this.setZoom(p), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
          }
          getMinZoom() {
            return this.transform.minZoom
          }
          setMaxZoom(p) {
            if ((p = p ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(p), this._update(), this.getZoom() > p && this.setZoom(p), this;
            throw new Error("maxZoom must be greater than the current minZoom")
          }
          getMaxZoom() {
            return this.transform.maxZoom
          }
          setMinPitch(p) {
            if ((p = p ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (p >= 0 && p <= this.transform.maxPitch) return this.transform.setMinPitch(p), this._update(), this.getPitch() < p && this.setPitch(p), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
          }
          getMinPitch() {
            return this.transform.minPitch
          }
          setMaxPitch(p) {
            if ((p = p ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (p >= this.transform.minPitch) return this.transform.setMaxPitch(p), this._update(), this.getPitch() > p && this.setPitch(p), this;
            throw new Error("maxPitch must be greater than the current minPitch")
          }
          getMaxPitch() {
            return this.transform.maxPitch
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies
          }
          setRenderWorldCopies(p) {
            return this.transform.setRenderWorldCopies(p), this._update()
          }
          setTransformConstrain(p) {
            return this.transform.setConstrain(p), this._update()
          }
          project(p) {
            return this.transform.locationToScreenPoint(l.U.convert(p), this.style && this.terrain)
          }
          unproject(p) {
            return this.transform.screenPointToLocation(l.P.convert(p), this.terrain)
          }
          isMoving() {
            var p;
            return this._moving || ((p = this.handlers) === null || p === void 0 ? void 0 : p.isMoving())
          }
          isZooming() {
            var p;
            return this._zooming || ((p = this.handlers) === null || p === void 0 ? void 0 : p.isZooming())
          }
          isRotating() {
            var p;
            return this._rotating || ((p = this.handlers) === null || p === void 0 ? void 0 : p.isRotating())
          }
          _createDelegatedListener(p, e, a) {
            if (p === "mouseenter" || p === "mouseover") {
              let c = !1;
              return {
                layers: e,
                listener: a,
                delegates: {
                  mousemove: f => {
                    const v = e.filter((T => this.getLayer(T))),
                      w = v.length !== 0 ? this.queryRenderedFeatures(f.point, {
                        layers: v
                      }) : [];
                    w.length ? c || (c = !0, a.call(this, new xa(p, this, f.originalEvent, {
                      features: w
                    }))) : c = !1
                  },
                  mouseout: () => {
                    c = !1
                  }
                }
              }
            }
            if (p === "mouseleave" || p === "mouseout") {
              let c = !1;
              return {
                layers: e,
                listener: a,
                delegates: {
                  mousemove: v => {
                    const w = e.filter((T => this.getLayer(T)));
                    (w.length !== 0 ? this.queryRenderedFeatures(v.point, {
                      layers: w
                    }) : []).length ? c = !0 : c && (c = !1, a.call(this, new xa(p, this, v.originalEvent)))
                  },
                  mouseout: v => {
                    c && (c = !1, a.call(this, new xa(p, this, v.originalEvent)))
                  }
                }
              }
            } {
              const c = h => {
                const f = e.filter((w => this.getLayer(w))),
                  v = f.length !== 0 ? this.queryRenderedFeatures(h.point, {
                    layers: f
                  }) : [];
                v.length && (h.features = v, a.call(this, h), delete h.features)
              };
              return {
                layers: e,
                listener: a,
                delegates: {
                  [p]: c
                }
              }
            }
          }
          _saveDelegatedListener(p, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[p] = this._delegatedListeners[p] || [], this._delegatedListeners[p].push(e)
          }
          _removeDelegatedListener(p, e, a) {
            if (!this._delegatedListeners || !this._delegatedListeners[p]) return;
            const c = this._delegatedListeners[p];
            for (let h = 0; h < c.length; h++) {
              const f = c[h];
              if (f.listener === a && f.layers.length === e.length && f.layers.every((v => e.includes(v)))) {
                for (const v in f.delegates) this.off(v, f.delegates[v]);
                return void c.splice(h, 1)
              }
            }
          }
          on(p, e, a) {
            if (a === void 0) return super.on(p, e);
            const c = typeof e == "string" ? [e] : e,
              h = this._createDelegatedListener(p, c, a);
            this._saveDelegatedListener(p, h);
            for (const f in h.delegates) this.on(f, h.delegates[f]);
            return {
              unsubscribe: () => {
                this._removeDelegatedListener(p, c, a)
              }
            }
          }
          once(p, e, a) {
            if (a === void 0) return super.once(p, e);
            const c = typeof e == "string" ? [e] : e,
              h = this._createDelegatedListener(p, c, a);
            for (const f in h.delegates) {
              const v = h.delegates[f];
              h.delegates[f] = (...w) => {
                this._removeDelegatedListener(p, c, a), v(...w)
              }
            }
            this._saveDelegatedListener(p, h);
            for (const f in h.delegates) this.once(f, h.delegates[f]);
            return this
          }
          off(p, e, a) {
            return a === void 0 ? super.off(p, e) : (this._removeDelegatedListener(p, typeof e == "string" ? [e] : e, a), this)
          }
          queryRenderedFeatures(p, e) {
            if (!this.style) return [];
            let a;
            const c = p instanceof l.P || Array.isArray(p),
              h = c ? p : [
                [0, 0],
                [this.transform.width, this.transform.height]
              ];
            if (e = e || (c ? {} : p) || {}, h instanceof l.P || typeof h[0] == "number") a = [l.P.convert(h)];
            else {
              const f = l.P.convert(h[0]),
                v = l.P.convert(h[1]);
              a = [f, new l.P(v.x, f.y), v, new l.P(f.x, v.y), f]
            }
            return this.style.queryRenderedFeatures(a, e, this.transform)
          }
          querySourceFeatures(p, e) {
            return this.style.querySourceFeatures(p, e)
          }
          setStyle(p, e) {
            return (e = l.e({}, {
              localIdeographFontFamily: this._localIdeographFontFamily,
              validate: this._validateStyle
            }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && p ? (this._diffStyle(p, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(p, e))
          }
          setTransformRequest(p) {
            return this._requestManager.setTransformRequest(p), this
          }
          _getUIString(p) {
            const e = this._locale[p];
            if (e == null) throw new Error(`Missing UI string '${p}'`);
            return e
          }
          _updateStyle(p, e) {
            var a, c;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(p, e)));
            const h = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!p)), p ? (this.style = new Gs(this, e || {}), this.style.setEventedParent(this, {
              style: this.style
            }), typeof p == "string" ? this.style.loadURL(p, e, h) : this.style.loadJSON(p, e, h), this) : ((c = (a = this.style) === null || a === void 0 ? void 0 : a.projection) === null || c === void 0 || c.destroy(), delete this.style, this)
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Gs(this, {}), this.style.setEventedParent(this, {
              style: this.style
            }), this.style.loadEmpty())
          }
          _diffStyle(p, e) {
            if (typeof p == "string") {
              const a = this._requestManager.transformRequest(p, "Style");
              l.j(a, new AbortController).then((c => {
                this._updateDiff(c.data, e)
              })).catch((c => {
                c && this.fire(new l.k(c))
              }))
            } else typeof p == "object" && this._updateDiff(p, e)
          }
          _updateDiff(p, e) {
            try {
              this.style.setState(p, e) && this._update(!0)
            } catch (a) {
              l.w(`Unable to perform style diff: ${a.message||a.error||a}.  Rebuilding the style from scratch.`), this._updateStyle(p, e)
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize()
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : l.w("There is no style added to the map.")
          }
          addSource(p, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(p, e), this._update(!0)
          }
          isSourceLoaded(p) {
            const e = this.style && this.style.tileManagers[p];
            if (e !== void 0) return e.loaded();
            this.fire(new l.k(new Error(`There is no tile manager with ID '${p}'`)))
          }
          setTerrain(p) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), p) {
              const e = this.style.tileManagers[p.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${p.source}`);
              this.terrain === null && e.reload();
              for (const a in this.style._layers) {
                const c = this.style._layers[a];
                c.type === "hillshade" && c.source === p.source && l.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), c.type === "color-relief" && c.source === p.source && l.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
              }
              this.terrain = new cf(this.painter, e, p), this.painter.renderToTexture = new fi(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = a => {
                var c;
                a.dataType === "style" ? this.terrain.tileManager.freeRtt() : a.dataType === "source" && a.tile && (a.sourceId !== p.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((c = a.source) === null || c === void 0 ? void 0 : c.type) === "image" ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(a.tile.tileID))
              }, this.style.on("data", this._terrainDataCallback)
            } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new l.l("terrain", {
              terrain: p
            })), this
          }
          getTerrain() {
            var p, e;
            return (e = (p = this.terrain) === null || p === void 0 ? void 0 : p.options) !== null && e !== void 0 ? e : null
          }
          areTilesLoaded() {
            const p = this.style && this.style.tileManagers;
            for (const e in p) {
              const a = p[e]._tiles;
              for (const c in a) {
                const h = a[c];
                if (h.state !== "loaded" && h.state !== "errored") return !1
              }
            }
            return !0
          }
          removeSource(p) {
            return this.style.removeSource(p), this._update(!0)
          }
          getSource(p) {
            return this.style.getSource(p)
          }
          setSourceTileLodParams(p, e, a) {
            if (a) {
              const c = this.getSource(a);
              if (!c) throw new Error(`There is no source with ID "${a}", cannot set LOD parameters`);
              c.calculateTileZoom = Qe(Math.max(1, p), Math.max(1, e))
            } else
              for (const c in this.style.tileManagers) this.style.tileManagers[c].getSource().calculateTileZoom = Qe(Math.max(1, p), Math.max(1, e));
            return this._update(!0), this
          }
          refreshTiles(p, e) {
            const a = this.style.tileManagers[p];
            if (!a) throw new Error(`There is no tile manager with ID "${p}", cannot refresh tile`);
            e === void 0 ? a.reload(!0) : a.refreshTiles(e.map((c => new l.a8(c.z, c.x, c.y))))
          }
          addImage(p, e, a = {}) {
            const {
              pixelRatio: c = 1,
              sdf: h = !1,
              stretchX: f,
              stretchY: v,
              content: w,
              textFitWidth: T,
              textFitHeight: C
            } = a;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || l.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new l.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const {
                  width: z,
                  height: F,
                  data: R
                } = e, U = e;
                return this.style.addImage(p, {
                  data: new l.R({
                    width: z,
                    height: F
                  }, new Uint8Array(R)),
                  pixelRatio: c,
                  stretchX: f,
                  stretchY: v,
                  content: w,
                  textFitWidth: T,
                  textFitHeight: C,
                  sdf: h,
                  version: 0,
                  userImage: U
                }), U.onAdd && U.onAdd(this, p), this
              }
            } {
              const {
                width: z,
                height: F,
                data: R
              } = ce.getImageData(e);
              this.style.addImage(p, {
                data: new l.R({
                  width: z,
                  height: F
                }, R),
                pixelRatio: c,
                stretchX: f,
                stretchY: v,
                content: w,
                textFitWidth: T,
                textFitHeight: C,
                sdf: h,
                version: 0
              })
            }
          }
          updateImage(p, e) {
            const a = this.style.getImage(p);
            if (!a) return this.fire(new l.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const c = e instanceof HTMLImageElement || l.b(e) ? ce.getImageData(e) : e,
              {
                width: h,
                height: f,
                data: v
              } = c;
            if (h === void 0 || f === void 0) return this.fire(new l.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (h !== a.data.width || f !== a.data.height) return this.fire(new l.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const w = !(e instanceof HTMLImageElement || l.b(e));
            return a.data.replace(v, w), this.style.updateImage(p, a), this
          }
          getImage(p) {
            return this.style.getImage(p)
          }
          hasImage(p) {
            return p ? !!this.style.getImage(p) : (this.fire(new l.k(new Error("Missing required image id"))), !1)
          }
          removeImage(p) {
            this.style.removeImage(p)
          }
          loadImage(p) {
            return Ve.getImage(this._requestManager.transformRequest(p, "Image"), new AbortController)
          }
          listImages() {
            return this.style.listImages()
          }
          addLayer(p, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(p, e), this._update(!0)
          }
          moveLayer(p, e) {
            return this.style.moveLayer(p, e), this._update(!0)
          }
          removeLayer(p) {
            return this.style.removeLayer(p), this._update(!0)
          }
          getLayer(p) {
            return this.style.getLayer(p)
          }
          getLayersOrder() {
            return this.style.getLayersOrder()
          }
          setLayerZoomRange(p, e, a) {
            return this.style.setLayerZoomRange(p, e, a), this._update(!0)
          }
          setFilter(p, e, a = {}) {
            return this.style.setFilter(p, e, a), this._update(!0)
          }
          getFilter(p) {
            return this.style.getFilter(p)
          }
          setPaintProperty(p, e, a, c = {}) {
            return this.style.setPaintProperty(p, e, a, c), this._update(!0)
          }
          getPaintProperty(p, e) {
            return this.style.getPaintProperty(p, e)
          }
          setLayoutProperty(p, e, a, c = {}) {
            return this.style.setLayoutProperty(p, e, a, c), this._update(!0)
          }
          getLayoutProperty(p, e) {
            return this.style.getLayoutProperty(p, e)
          }
          setGlyphs(p, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(p, e), this._update(!0)
          }
          getGlyphs() {
            return this.style.getGlyphsUrl()
          }
          addSprite(p, e, a = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(p, e, a, (c => {
              c || this._update(!0)
            })), this
          }
          removeSprite(p) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(p), this._update(!0)
          }
          getSprite() {
            return this.style.getSprite()
          }
          setSprite(p, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(p, e, (a => {
              a || this._update(!0)
            })), this
          }
          setLight(p, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(p, e), this._update(!0)
          }
          getLight() {
            return this.style.getLight()
          }
          setSky(p, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(p, e), this._update(!0)
          }
          getSky() {
            return this.style.getSky()
          }
          setFeatureState(p, e) {
            return this.style.setFeatureState(p, e), this._update()
          }
          removeFeatureState(p, e) {
            return this.style.removeFeatureState(p, e), this._update()
          }
          getFeatureState(p) {
            return this.style.getFeatureState(p)
          }
          getContainer() {
            return this._container
          }
          getCanvasContainer() {
            return this._canvasContainer
          }
          getCanvas() {
            return this._canvas
          }
          _containerDimensions() {
            let p = 0,
              e = 0;
            return this._container && (p = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [p, e]
          }
          _setupContainer() {
            const p = this._container;
            p.classList.add("maplibregl-map");
            const e = this._canvasContainer = Z.create("div", "maplibregl-canvas-container", p);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = Z.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const a = this._containerDimensions(),
              c = this._getClampedPixelRatio(a[0], a[1]);
            this._resizeCanvas(a[0], a[1], c);
            const h = this._controlContainer = Z.create("div", "maplibregl-control-container", p),
              f = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((v => {
              f[v] = Z.create("div", `maplibregl-ctrl-${v} `, h)
            })), this._container.addEventListener("scroll", this._onMapScroll, !1)
          }
          _resizeCanvas(p, e, a) {
            this._canvas.width = Math.floor(a * p), this._canvas.height = Math.floor(a * e), this._canvas.style.width = `${p}px`, this._canvas.style.height = `${e}px`
          }
          _setupPainter() {
            const p = Object.assign(Object.assign({}, this._canvasContextAttributes), {
              alpha: !0,
              depth: !0,
              stencil: !0,
              premultipliedAlpha: !0
            });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", (c => {
              e = {
                requestedAttributes: p
              }, c && (e.statusMessage = c.statusMessage, e.type = c.type)
            }), {
              once: !0
            });
            let a = null;
            if (a = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, p) : this._canvas.getContext("webgl2", p) || this._canvas.getContext("webgl", p), !a) {
              const c = "Failed to initialize WebGL";
              throw e ? (e.message = c, new Error(JSON.stringify(e))) : new Error(c)
            }
            this.painter = new pd(a, this.transform), de.testSupport(a)
          }
          migrateProjection(p, e) {
            super.migrateProjection(p, e), this.painter.transform = p, this.fire(new l.l("projectiontransition", {
              newProjection: this.style.projection.name
            }))
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
          }
          _update(p) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || p, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
          }
          _requestRenderFrame(p) {
            return this._update(), this._renderTaskQueue.add(p)
          }
          _cancelRenderFrame(p) {
            this._renderTaskQueue.remove(p)
          }
          _render(p) {
            var e, a, c, h, f;
            const v = this._idleTriggered ? this._fadeDuration : 0,
              w = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(p), this._removed) return;
            let T = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const F = this.transform.zoom,
                R = fe();
              this.style.zoomHistory.update(F, R);
              const U = new l.G(F, {
                  now: R,
                  fadeDuration: v,
                  zoomHistory: this.style.zoomHistory,
                  transition: this.style.getTransition()
                }),
                Y = U.crossFadingFactor();
              Y === 1 && Y === this._crossFadingFactor || (T = !0, this._crossFadingFactor = Y), this.style.update(U)
            }
            const C = ((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0 !== w;
            (c = this.style.projection) === null || c === void 0 || c.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((h = this.style.projection) === null || h === void 0 ? void 0 : h.transitionState, (f = this.style.projection) === null || f === void 0 ? void 0 : f.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || C) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, v, this._crossSourceCollisions, C), this.painter.render(this.style, {
              showTileBoundaries: this.showTileBoundaries,
              showOverdrawInspector: this._showOverdrawInspector,
              rotating: this.isRotating(),
              zooming: this.isZooming(),
              moving: this.isMoving(),
              fadeDuration: v,
              showPadding: this.showPadding
            }), this.fire(new l.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, l.cz.mark(l.cA.load), this.fire(new l.l("load"))), this.style && (this.style.hasTransitions() || T) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const z = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return z || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new l.l("idle")), !this._loaded || this._fullyLoaded || z || (this._fullyLoaded = !0, l.cz.mark(l.cA.fullLoad)), this
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this
          }
          remove() {
            var p;
            this._hash && this._hash.remove();
            for (const a of this._controls) a.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Ve.removeThrottleControl(this._imageQueueHandle), (p = this._resizeObserver) === null || p === void 0 || p.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), Z.remove(this._canvasContainer), Z.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), l.cz.clearMetrics(), this._removed = !0, this.fire(new l.l("remove"))
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController, ce.frame(this._frameRequest, (p => {
              l.cz.frame(p), this._frameRequest = null;
              try {
                this._render(p)
              } catch (e) {
                if (!l.cB(e) && !(function(a) {
                    return a.message === ad
                  })(e)) throw e
              }
            }), (() => {})))
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries
          }
          set showTileBoundaries(p) {
            this._showTileBoundaries !== p && (this._showTileBoundaries = p, this._update())
          }
          get showPadding() {
            return !!this._showPadding
          }
          set showPadding(p) {
            this._showPadding !== p && (this._showPadding = p, this._update())
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes
          }
          set showCollisionBoxes(p) {
            this._showCollisionBoxes !== p && (this._showCollisionBoxes = p, p ? this.style._generateCollisionBoxes() : this._update())
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector
          }
          set showOverdrawInspector(p) {
            this._showOverdrawInspector !== p && (this._showOverdrawInspector = p, this._update())
          }
          get repaint() {
            return !!this._repaint
          }
          set repaint(p) {
            this._repaint !== p && (this._repaint = p, this.triggerRepaint())
          }
          get vertices() {
            return !!this._vertices
          }
          set vertices(p) {
            this._vertices = p, this._update()
          }
          get version() {
            return Dd
          }
          getCameraTargetElevation() {
            return this.transform.elevation
          }
          getProjection() {
            return this.style.getProjection()
          }
          setProjection(p) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(p), this._update(!0)
          }
        }, k.MapMouseEvent = xa, k.MapTouchEvent = ha, k.MapWheelEvent = yd, k.Marker = sl, k.NavigationControl = class {
          constructor(p) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(),
                a = e === this._map.getMaxZoom(),
                c = e === this._map.getMinZoom();
              this._zoomInButton.disabled = a, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", a.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString())
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing-this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
            }, this._setButtonTitle = (e, a) => {
              const c = this._map._getUIString(`NavigationControl.${a}`);
              e.title = c, e.setAttribute("aria-label", c)
            }, this.options = l.e({}, Ql, p), this._container = Z.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e => this._map.zoomIn({}, {
              originalEvent: e
            }))), Z.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e => this._map.zoomOut({}, {
              originalEvent: e
            }))), Z.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                originalEvent: e
              }) : this._map.resetNorth({}, {
                originalEvent: e
              })
            })), this._compassIcon = Z.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"))
          }
          onAdd(p) {
            return this._map = p, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Mu(this._map, this._compass, this.options.visualizePitch)), this._container
          }
          onRemove() {
            Z.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map
          }
          _createButton(p, e) {
            const a = Z.create("button", p, this._container);
            return a.type = "button", a.addEventListener("click", e), a
          }
        }, k.Popup = class extends l.E {
          constructor(p) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
            }, this.remove = () => (this._content && Z.remove(this._content), this._container && (Z.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new l.l("close"))), this), this._onMouseUp = e => {
              this._update(e.point)
            }, this._onMouseMove = e => {
              this._update(e.point)
            }, this._onDrag = e => {
              this._update(e.point)
            }, this._update = e => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = Z.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = Z.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const v of this.options.className.split(" ")) this._container.classList.add(v);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = ec(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const a = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let c = this.options.anchor;
              const h = ic(this.options.offset);
              if (!c) {
                const v = this._container.offsetWidth,
                  w = this._container.offsetHeight;
                let T;
                T = a.y + h.bottom.y < w ? ["top"] : a.y > this._map.transform.height - w ? ["bottom"] : [], a.x < v / 2 ? T.push("left") : a.x > this._map.transform.width - v / 2 && T.push("right"), c = T.length === 0 ? "bottom" : T.join("-")
              }
              let f = a.add(h[c]);
              this.options.subpixelPositioning || (f = f.round()), Z.setTransform(this._container, `${es[c]} translate(${f.x}px,${f.y}px)`), tc(this._container, c, "popup"), this._updateOpacity()
            }, this._onClose = () => {
              this.remove()
            }, this.options = l.e(Object.create(Au), p)
          }
          addTo(p) {
            return this._map && this.remove(), this._map = p, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new l.l("open")), this
          }
          isOpen() {
            return !!this._map
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(p) {
            return this._lngLat = l.U.convert(p), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this
          }
          getElement() {
            return this._container
          }
          setText(p) {
            return this.setDOMContent(document.createTextNode(p))
          }
          setHTML(p) {
            const e = document.createDocumentFragment(),
              a = document.createElement("body");
            let c;
            for (a.innerHTML = p; c = a.firstChild, c;) e.appendChild(c);
            return this.setDOMContent(e)
          }
          getMaxWidth() {
            var p;
            return (p = this._container) === null || p === void 0 ? void 0 : p.style.maxWidth
          }
          setMaxWidth(p) {
            return this.options.maxWidth = p, this._update(), this
          }
          setDOMContent(p) {
            if (this._content)
              for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = Z.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(p), this._createCloseButton(), this._update(), this._focusFirstElement(), this
          }
          addClassName(p) {
            return this._container && this._container.classList.add(p), this
          }
          removeClassName(p) {
            return this._container && this._container.classList.remove(p), this
          }
          setOffset(p) {
            return this.options.offset = p, this._update(), this
          }
          toggleClassName(p) {
            if (this._container) return this._container.classList.toggle(p)
          }
          setSubpixelPositioning(p) {
            this.options.subpixelPositioning = p
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = Z.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose))
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const p = this._container.querySelector(nc);
            p && p.focus()
          }
        }, k.RasterDEMTileSource = lr, k.RasterTileSource = st, k.ScaleControl = class {
          constructor(p) {
            this._onMove = () => {
              rc(this._map, this._container, this.options)
            }, this.setUnit = e => {
              this.options.unit = e, rc(this._map, this._container, this.options)
            }, this.options = Object.assign(Object.assign({}, Cu), p)
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(p) {
            return this._map = p, this._container = Z.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", p.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container
          }
          onRemove() {
            Z.remove(this._container), this._map.off("move", this._onMove), this._map = void 0
          }
        }, k.ScrollZoomHandler = Cd, k.Style = Gs, k.TerrainControl = class {
          constructor(p) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon()
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
            }, this.options = p
          }
          onAdd(p) {
            return this._map = p, this._container = Z.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = Z.create("button", "maplibregl-ctrl-terrain", this._container), Z.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container
          }
          onRemove() {
            Z.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0
          }
        }, k.TwoFingersTouchPitchHandler = Sd, k.TwoFingersTouchRotateHandler = Kl, k.TwoFingersTouchZoomHandler = Pd, k.TwoFingersTouchZoomRotateHandler = zd, k.VectorTileSource = Lt, k.VideoSource = Sr, k.addSourceType = (p, e) => l._(void 0, void 0, void 0, (function*() {
          if (Tr(p)) throw new Error(`A source type called "${p}" already exists.`);
          ((a, c) => {
            Vt[a] = c
          })(p, e)
        })), k.clearPrewarmedResources = function() {
          const p = Kt;
          p && (p.isPreloaded() && p.numActive() === 1 ? (p.release(Et), Kt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
        }, k.createTileMesh = ga, k.getMaxParallelImageRequests = function() {
          return l.a.MAX_PARALLEL_IMAGE_REQUESTS
        }, k.getRTLTextPluginStatus = function() {
          return q().getRTLTextPluginStatus()
        }, k.getVersion = function() {
          return zu
        }, k.getWorkerCount = function() {
          return Qt.workerCount
        }, k.getWorkerUrl = function() {
          return l.a.WORKER_URL
        }, k.importScriptInWorkers = function(p) {
          return Ot().broadcast("IS", p)
        }, k.isTimeFrozen = function() {
          return ge.isFrozen()
        }, k.now = fe, k.prewarm = function() {
          it().acquire(Et)
        }, k.restoreNow = function() {
          ge.restoreNow()
        }, k.setMaxParallelImageRequests = function(p) {
          l.a.MAX_PARALLEL_IMAGE_REQUESTS = p
        }, k.setNow = function(p) {
          ge.setNow(p)
        }, k.setRTLTextPlugin = function(p, e) {
          return q().setRTLTextPlugin(p, e)
        }, k.setWorkerCount = function(p) {
          Qt.workerCount = p
        }, k.setWorkerUrl = function(p) {
          l.a.WORKER_URL = p
        }
      }));
      var E = r;
      return E
    }))
  })(dp)), dp.exports
}
var ave = ive();
const Yu = rve(ave);
class Lv {
  constructor(s) {
    vn(this, "gm");
    vn(this, "markers", new Map);
    vn(this, "canvases", new Map);
    vn(this, "canvasSize");
    vn(this, "canvasOpacity", .8);
    this.input = s, this.gm = new ja(this.input.tileSize);
    const r = W0(s.img);
    this.canvasSize = Math.ceil(2e3 / r)
  }
  place([s, r]) {
    const x = this.gm.latLonToPixelsFloor(s, r, this.input.zoom),
      A = this.getMarkerId(x),
      E = this.gm.latLonToPixelBoundsLatLon(s, r, this.input.zoom),
      k = this.input.map;
    if (this.input.markerFn && !this.markers.has(A)) {
      const J = this.input.markerFn();
      J.setLngLat({
        lat: E.min[0],
        lng: (E.max[1] + E.min[1]) / 2
      }).addTo(k), this.markers.set(A, J)
    }
    const {
      key: l,
      pos: j,
      innerPos: W
    } = this.getCanvasPos(x);
    let $ = this.canvases.get(l);
    if (!$) {
      const J = this.canvasSize,
        ce = j.x * J,
        ge = j.y * J,
        fe = ce + J - 1,
        Z = ge + J - 1,
        de = this.gm.pixelsToLatLon(ce, Z + 1, this.input.zoom),
        Fe = this.gm.pixelsToLatLon(fe + 1, ge, this.input.zoom);
      $ = new ove({
        id: `${this.input.id}-${l}`,
        img: this.input.img,
        canvasSize: this.canvasSize,
        coordinates: dm({
          min: de,
          max: Fe
        }),
        layerPaint: {
          "raster-resampling": "nearest",
          "raster-opacity": this.canvasOpacity
        }
      }), $.addTo(this.input.map), this.canvases.set(l, $)
    }
    $.place(W.x, W.y)
  }
  clear() {
    const s = this.input.map;
    for (const r of this.canvases.values()) r.removeFrom(s), r.removeDOM();
    this.canvases.clear();
    for (const r of this.markers.values()) r.remove();
    this.markers.clear()
  }
  clearAndPlace(s) {
    this.clear(), this.place(s)
  }
  remove([s, r]) {
    let x = !1;
    const A = this.gm.latLonToPixelsFloor(s, r, this.input.zoom),
      {
        key: E,
        innerPos: k
      } = this.getCanvasPos(A),
      l = this.canvases.get(E);
    l && (x = l.remove(k.x, k.y), l.annotationsCount() === 0 && (this.canvases.delete(E), l.removeFrom(this.input.map), l.removeDOM()));
    const j = this.getMarkerId(A),
      W = this.markers.get(j);
    return W == null || W.remove(), this.markers.delete(j), x
  }
  setCanvasOpacity(s) {
    this.canvasOpacity = s;
    for (const r of this.canvases.values()) r.setOpacity(s)
  }
  getMarkerId([s, r]) {
    return `${this.input.id}:${s},${r}`
  }
  getCanvasPos([s, r]) {
    const x = {
        x: Math.floor(s / this.canvasSize),
        y: Math.floor(r / this.canvasSize)
      },
      A = {
        x: s % this.canvasSize,
        y: r % this.canvasSize
      },
      E = `${x.x},${x.y}`;
    return {
      pos: x,
      innerPos: A,
      key: E
    }
  }
}
class ove {
  constructor(s) {
    vn(this, "annotations", new Set);
    vn(this, "canvas");
    vn(this, "imgSize");
    vn(this, "maps", new Set);
    vn(this, "pendingRepaint", !1);
    this.input = s, this.imgSize = W0(s.img), this.canvas = document.createElement("canvas"), this.canvas.width = this.input.canvasSize * this.imgSize, this.canvas.height = this.input.canvasSize * this.imgSize
  }
  place(s, r) {
    const x = this.getPixelKey(s, r);
    if (this.annotations.has(x)) return !1;
    const A = this.canvas.getContext("2d");
    if (A) {
      const E = s * this.imgSize,
        k = r * this.imgSize;
      A.drawImage(this.input.img, E, k)
    }
    return this.annotations.add(x), this.triggerRepaint(), !0
  }
  remove(s, r) {
    const x = this.getPixelKey(s, r);
    if (!this.annotations.has(x)) return !1;
    const A = this.canvas.getContext("2d");
    if (A) {
      const E = s * this.imgSize,
        k = r * this.imgSize;
      A.clearRect(E, k, this.imgSize, this.imgSize)
    }
    return this.annotations.delete(x), this.triggerRepaint(), !0
  }
  addTo(s) {
    const r = this.input.id;
    s.getSource(r) || s.addSource(r, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates,
      animate: !1
    }), s.getLayer(r) || s.addLayer({
      id: r,
      type: "raster",
      source: r,
      paint: this.input.layerPaint
    }), this.maps.add(s)
  }
  removeFrom(s) {
    const {
      id: r
    } = this.input;
    s.getLayer(r) && s.removeLayer(r), s.getSource(r) && s.removeSource(r), this.maps.delete(s)
  }
  removeDOM() {
    this.canvas.remove()
  }
  annotationsCount() {
    return this.annotations.size
  }
  setOpacity(s) {
    for (const r of this.maps.values()) r.setPaintProperty(this.input.id, "raster-opacity", s)
  }
  getPixelKey(s, r) {
    return `${s},${r}`
  }
  triggerRepaint() {
    this.pendingRepaint || (this.pendingRepaint = !0, requestAnimationFrame(() => {
      for (const s of this.maps.values()) {
        const r = s.getSource(this.input.id);
        r.play(), s.once("render", () => {
          r.pause(), this.pendingRepaint = !1
        })
      }
    }))
  }
}

function W0(d) {
  return Math.max(d.naturalWidth, d.naturalHeight)
}

function sve() {
  return window.matchMedia("(display-mode: standalone)").matches || "standalone" in window.navigator && window.navigator.standalone === !0
}

function lve(d) {
  const s = {
      opaque: !0
    },
    r = d.searchParams.get("lat"),
    x = d.searchParams.get("lng");
  r && x && (s.pos = {
    lat: parseFloat(r),
    lng: parseFloat(x)
  });
  const A = d.searchParams.get("zoom");
  A && (s.zoom = parseFloat(A));
  const E = d.searchParams.get("season");
  E && (s.season = parseInt(E));
  const k = d.searchParams.get("opaque");
  return k && (s.opaque = k !== "0"), d.searchParams.get("select") && (s.select = !0), d.searchParams.get("twitch-migration") && (s.twitchMigration = !0), s.newUser = !!d.searchParams.get("new-user"), s.discordLinked = !!d.searchParams.get("discord-linked"), s.alliance = !!d.searchParams.get("alliance"), s
}

function cve(d, s) {
  return d = new URL(d), s.pos !== void 0 && (d.searchParams.set("lat", s.pos.lat.toString()), d.searchParams.set("lng", s.pos.lng.toString())), s.zoom !== void 0 && d.searchParams.set("zoom", s.zoom.toString()), s.season !== void 0 && d.searchParams.set("season", s.season.toString()), s.opaque !== void 0 && d.searchParams.set("opaque", s.opaque ? "1" : "0"), s.newUser !== void 0 && d.searchParams.set("new-user", s.newUser ? "1" : "0"), s.alliance !== void 0 && d.searchParams.set("alliance", s.alliance ? "1" : "0"), s.select && d.searchParams.set("alliance", "1"), d
}
var v_ = function() {
  return v_ = Object.assign || function(s) {
    for (var r, x = 1, A = arguments.length; x < A; x++) {
      r = arguments[x];
      for (var E in r) Object.prototype.hasOwnProperty.call(r, E) && (s[E] = r[E])
    }
    return s
  }, v_.apply(this, arguments)
};

function No(d, s, r, x) {
  function A(E) {
    return E instanceof r ? E : new r(function(k) {
      k(E)
    })
  }
  return new(r || (r = Promise))(function(E, k) {
    function l($) {
      try {
        W(x.next($))
      } catch (J) {
        k(J)
      }
    }

    function j($) {
      try {
        W(x.throw($))
      } catch (J) {
        k(J)
      }
    }

    function W($) {
      $.done ? E($.value) : A($.value).then(l, j)
    }
    W((x = x.apply(d, s || [])).next())
  })
}

function Vo(d, s) {
  var r = {
      label: 0,
      sent: function() {
        if (E[0] & 1) throw E[1];
        return E[1]
      },
      trys: [],
      ops: []
    },
    x, A, E, k = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return k.next = l(0), k.throw = l(1), k.return = l(2), typeof Symbol == "function" && (k[Symbol.iterator] = function() {
    return this
  }), k;

  function l(W) {
    return function($) {
      return j([W, $])
    }
  }

  function j(W) {
    if (x) throw new TypeError("Generator is already executing.");
    for (; k && (k = 0, W[0] && (r = 0)), r;) try {
      if (x = 1, A && (E = W[0] & 2 ? A.return : W[0] ? A.throw || ((E = A.return) && E.call(A), 0) : A.next) && !(E = E.call(A, W[1])).done) return E;
      switch (A = 0, E && (W = [W[0] & 2, E.value]), W[0]) {
        case 0:
        case 1:
          E = W;
          break;
        case 4:
          return r.label++, {
            value: W[1],
            done: !1
          };
        case 5:
          r.label++, A = W[1], W = [0];
          continue;
        case 7:
          W = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (E = r.trys, !(E = E.length > 0 && E[E.length - 1]) && (W[0] === 6 || W[0] === 2)) {
            r = 0;
            continue
          }
          if (W[0] === 3 && (!E || W[1] > E[0] && W[1] < E[3])) {
            r.label = W[1];
            break
          }
          if (W[0] === 6 && r.label < E[1]) {
            r.label = E[1], E = W;
            break
          }
          if (E && r.label < E[2]) {
            r.label = E[2], r.ops.push(W);
            break
          }
          E[2] && r.ops.pop(), r.trys.pop();
          continue
      }
      W = s.call(d, r)
    } catch ($) {
      W = [6, $], A = 0
    } finally {
      x = E = 0
    }
    if (W[0] & 5) throw W[1];
    return {
      value: W[0] ? W[1] : void 0,
      done: !0
    }
  }
}

function H0(d, s, r) {
  if (r || arguments.length === 2)
    for (var x = 0, A = s.length, E; x < A; x++)(E || !(x in s)) && (E || (E = Array.prototype.slice.call(s, 0, x)), E[x] = s[x]);
  return d.concat(E || Array.prototype.slice.call(s))
}
var X0 = "4.6.2";

function Sp(d, s) {
  return new Promise(function(r) {
    return setTimeout(r, d, s)
  })
}

function uve() {
  return new Promise(function(d) {
    var s = new MessageChannel;
    s.port1.onmessage = function() {
      return d()
    }, s.port2.postMessage(null)
  })
}

function hve(d, s) {
  s === void 0 && (s = 1 / 0);
  var r = window.requestIdleCallback;
  return r ? new Promise(function(x) {
    return r.call(window, function() {
      return x()
    }, {
      timeout: s
    })
  }) : Sp(Math.min(d, s))
}

function Y0(d) {
  return !!d && typeof d.then == "function"
}

function Dv(d, s) {
  try {
    var r = d();
    Y0(r) ? r.then(function(x) {
      return s(!0, x)
    }, function(x) {
      return s(!1, x)
    }) : s(!0, r)
  } catch (x) {
    s(!1, x)
  }
}

function Rv(d, s, r) {
  return r === void 0 && (r = 16), No(this, void 0, void 0, function() {
    var x, A, E, k;
    return Vo(this, function(l) {
      switch (l.label) {
        case 0:
          x = Array(d.length), A = Date.now(), E = 0, l.label = 1;
        case 1:
          return E < d.length ? (x[E] = s(d[E], E), k = Date.now(), k >= A + r ? (A = k, [4, uve()]) : [3, 3]) : [3, 4];
        case 2:
          l.sent(), l.label = 3;
        case 3:
          return ++E, [3, 1];
        case 4:
          return [2, x]
      }
    })
  })
}

function ih(d) {
  return d.then(void 0, function() {}), d
}

function dve(d, s) {
  for (var r = 0, x = d.length; r < x; ++r)
    if (d[r] === s) return !0;
  return !1
}

function pve(d, s) {
  return !dve(d, s)
}

function fm(d) {
  return parseInt(d)
}

function So(d) {
  return parseFloat(d)
}

function hs(d, s) {
  return typeof d == "number" && isNaN(d) ? s : d
}

function Ca(d) {
  return d.reduce(function(s, r) {
    return s + (r ? 1 : 0)
  }, 0)
}

function K0(d, s) {
  if (s === void 0 && (s = 1), Math.abs(s) >= 1) return Math.round(d / s) * s;
  var r = 1 / s;
  return Math.round(d * r) / r
}

function fve(d) {
  for (var s, r, x = "Unexpected syntax '".concat(d, "'"), A = /^\s*([a-z-]*)(.*)$/i.exec(d), E = A[1] || void 0, k = {}, l = /([.:#][\w-]+|\[.+?\])/gi, j = function(ce, ge) {
      k[ce] = k[ce] || [], k[ce].push(ge)
    };;) {
    var W = l.exec(A[2]);
    if (!W) break;
    var $ = W[0];
    switch ($[0]) {
      case ".":
        j("class", $.slice(1));
        break;
      case "#":
        j("id", $.slice(1));
        break;
      case "[": {
        var J = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec($);
        if (J) j(J[1], (r = (s = J[4]) !== null && s !== void 0 ? s : J[5]) !== null && r !== void 0 ? r : "");
        else throw new Error(x);
        break
      }
      default:
        throw new Error(x)
    }
  }
  return [E, k]
}

function _ve(d) {
  for (var s = new Uint8Array(d.length), r = 0; r < d.length; r++) {
    var x = d.charCodeAt(r);
    if (x > 127) return new TextEncoder().encode(d);
    s[r] = x
  }
  return s
}

function Fs(d, s) {
  var r = d[0] >>> 16,
    x = d[0] & 65535,
    A = d[1] >>> 16,
    E = d[1] & 65535,
    k = s[0] >>> 16,
    l = s[0] & 65535,
    j = s[1] >>> 16,
    W = s[1] & 65535,
    $ = 0,
    J = 0,
    ce = 0,
    ge = 0;
  ge += E + W, ce += ge >>> 16, ge &= 65535, ce += A + j, J += ce >>> 16, ce &= 65535, J += x + l, $ += J >>> 16, J &= 65535, $ += r + k, $ &= 65535, d[0] = $ << 16 | J, d[1] = ce << 16 | ge
}

function ao(d, s) {
  var r = d[0] >>> 16,
    x = d[0] & 65535,
    A = d[1] >>> 16,
    E = d[1] & 65535,
    k = s[0] >>> 16,
    l = s[0] & 65535,
    j = s[1] >>> 16,
    W = s[1] & 65535,
    $ = 0,
    J = 0,
    ce = 0,
    ge = 0;
  ge += E * W, ce += ge >>> 16, ge &= 65535, ce += A * W, J += ce >>> 16, ce &= 65535, ce += E * j, J += ce >>> 16, ce &= 65535, J += x * W, $ += J >>> 16, J &= 65535, J += A * j, $ += J >>> 16, J &= 65535, J += E * l, $ += J >>> 16, J &= 65535, $ += r * W + x * j + A * l + E * k, $ &= 65535, d[0] = $ << 16 | J, d[1] = ce << 16 | ge
}

function Tc(d, s) {
  var r = d[0];
  s %= 64, s === 32 ? (d[0] = d[1], d[1] = r) : s < 32 ? (d[0] = r << s | d[1] >>> 32 - s, d[1] = d[1] << s | r >>> 32 - s) : (s -= 32, d[0] = d[1] << s | r >>> 32 - s, d[1] = r << s | d[1] >>> 32 - s)
}

function Ya(d, s) {
  s %= 64, s !== 0 && (s < 32 ? (d[0] = d[1] >>> 32 - s, d[1] = d[1] << s) : (d[0] = d[1] << s - 32, d[1] = 0))
}

function Ti(d, s) {
  d[0] ^= s[0], d[1] ^= s[1]
}
var mve = [4283543511, 3981806797],
  gve = [3301882366, 444984403];

function jv(d) {
  var s = [0, d[0] >>> 1];
  Ti(d, s), ao(d, mve), s[1] = d[0] >>> 1, Ti(d, s), ao(d, gve), s[1] = d[0] >>> 1, Ti(d, s)
}
var np = [2277735313, 289559509],
  ip = [1291169091, 658871167],
  Fv = [0, 5],
  vve = [0, 1390208809],
  yve = [0, 944331445];

function xve(d, s) {
  var r = _ve(d);
  s = s || 0;
  var x = [0, r.length],
    A = x[1] % 16,
    E = x[1] - A,
    k = [0, s],
    l = [0, s],
    j = [0, 0],
    W = [0, 0],
    $;
  for ($ = 0; $ < E; $ = $ + 16) j[0] = r[$ + 4] | r[$ + 5] << 8 | r[$ + 6] << 16 | r[$ + 7] << 24, j[1] = r[$] | r[$ + 1] << 8 | r[$ + 2] << 16 | r[$ + 3] << 24, W[0] = r[$ + 12] | r[$ + 13] << 8 | r[$ + 14] << 16 | r[$ + 15] << 24, W[1] = r[$ + 8] | r[$ + 9] << 8 | r[$ + 10] << 16 | r[$ + 11] << 24, ao(j, np), Tc(j, 31), ao(j, ip), Ti(k, j), Tc(k, 27), Fs(k, l), ao(k, Fv), Fs(k, vve), ao(W, ip), Tc(W, 33), ao(W, np), Ti(l, W), Tc(l, 31), Fs(l, k), ao(l, Fv), Fs(l, yve);
  j[0] = 0, j[1] = 0, W[0] = 0, W[1] = 0;
  var J = [0, 0];
  switch (A) {
    case 15:
      J[1] = r[$ + 14], Ya(J, 48), Ti(W, J);
    case 14:
      J[1] = r[$ + 13], Ya(J, 40), Ti(W, J);
    case 13:
      J[1] = r[$ + 12], Ya(J, 32), Ti(W, J);
    case 12:
      J[1] = r[$ + 11], Ya(J, 24), Ti(W, J);
    case 11:
      J[1] = r[$ + 10], Ya(J, 16), Ti(W, J);
    case 10:
      J[1] = r[$ + 9], Ya(J, 8), Ti(W, J);
    case 9:
      J[1] = r[$ + 8], Ti(W, J), ao(W, ip), Tc(W, 33), ao(W, np), Ti(l, W);
    case 8:
      J[1] = r[$ + 7], Ya(J, 56), Ti(j, J);
    case 7:
      J[1] = r[$ + 6], Ya(J, 48), Ti(j, J);
    case 6:
      J[1] = r[$ + 5], Ya(J, 40), Ti(j, J);
    case 5:
      J[1] = r[$ + 4], Ya(J, 32), Ti(j, J);
    case 4:
      J[1] = r[$ + 3], Ya(J, 24), Ti(j, J);
    case 3:
      J[1] = r[$ + 2], Ya(J, 16), Ti(j, J);
    case 2:
      J[1] = r[$ + 1], Ya(J, 8), Ti(j, J);
    case 1:
      J[1] = r[$], Ti(j, J), ao(j, np), Tc(j, 31), ao(j, ip), Ti(k, j)
  }
  return Ti(k, x), Ti(l, x), Fs(k, l), Fs(l, k), jv(k), jv(l), Fs(k, l), Fs(l, k), ("00000000" + (k[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (k[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (l[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (l[1] >>> 0).toString(16)).slice(-8)
}

function bve(d) {
  var s;
  return v_({
    name: d.name,
    message: d.message,
    stack: (s = d.stack) === null || s === void 0 ? void 0 : s.split(`
`)
  }, d)
}

function wve(d) {
  return /^function\s.*?\{\s*\[native code]\s*}$/.test(String(d))
}

function kve(d) {
  return typeof d != "function"
}

function Tve(d, s) {
  var r = ih(new Promise(function(x) {
    var A = Date.now();
    Dv(d.bind(null, s), function() {
      for (var E = [], k = 0; k < arguments.length; k++) E[k] = arguments[k];
      var l = Date.now() - A;
      if (!E[0]) return x(function() {
        return {
          error: E[1],
          duration: l
        }
      });
      var j = E[1];
      if (kve(j)) return x(function() {
        return {
          value: j,
          duration: l
        }
      });
      x(function() {
        return new Promise(function(W) {
          var $ = Date.now();
          Dv(j, function() {
            for (var J = [], ce = 0; ce < arguments.length; ce++) J[ce] = arguments[ce];
            var ge = l + Date.now() - $;
            if (!J[0]) return W({
              error: J[1],
              duration: ge
            });
            W({
              value: J[1],
              duration: ge
            })
          })
        })
      })
    })
  }));
  return function() {
    return r.then(function(A) {
      return A()
    })
  }
}

function Pve(d, s, r, x) {
  var A = Object.keys(d).filter(function(k) {
      return pve(r, k)
    }),
    E = ih(Rv(A, function(k) {
      return Tve(d[k], s)
    }, x));
  return function() {
    return No(this, void 0, void 0, function() {
      var l, j, W, $, J;
      return Vo(this, function(ce) {
        switch (ce.label) {
          case 0:
            return [4, E];
          case 1:
            return l = ce.sent(), [4, Rv(l, function(ge) {
              return ih(ge())
            }, x)];
          case 2:
            return j = ce.sent(), [4, Promise.all(j)];
          case 3:
            for (W = ce.sent(), $ = {}, J = 0; J < A.length; ++J) $[A[J]] = W[J];
            return [2, $]
        }
      })
    })
  }
}

function J0() {
  var d = window,
    s = navigator;
  return Ca(["MSCSSMatrix" in d, "msSetImmediate" in d, "msIndexedDB" in d, "msMaxTouchPoints" in s, "msPointerEnabled" in s]) >= 4
}

function Sve() {
  var d = window,
    s = navigator;
  return Ca(["msWriteProfilerMark" in d, "MSStream" in d, "msLaunchUri" in s, "msSaveBlob" in s]) >= 3 && !J0()
}

function Bh() {
  var d = window,
    s = navigator;
  return Ca(["webkitPersistentStorage" in s, "webkitTemporaryStorage" in s, (s.vendor || "").indexOf("Google") === 0, "webkitResolveLocalFileSystemURL" in d, "BatteryManager" in d, "webkitMediaStream" in d, "webkitSpeechGrammar" in d]) >= 5
}

function Co() {
  var d = window,
    s = navigator;
  return Ca(["ApplePayError" in d, "CSSPrimitiveValue" in d, "Counter" in d, s.vendor.indexOf("Apple") === 0, "RGBColor" in d, "WebKitMediaKeys" in d]) >= 4
}

function _m() {
  var d = window,
    s = d.HTMLElement,
    r = d.Document;
  return Ca(["safari" in d, !("ongestureend" in d), !("TouchEvent" in d), !("orientation" in d), s && !("autocapitalize" in s.prototype), r && "pointerLockElement" in r.prototype]) >= 4
}

function Oh() {
  var d = window;
  return wve(d.print) && String(d.browser) === "[object WebPageNamespace]"
}

function Q0() {
  var d, s, r = window;
  return Ca(["buildID" in navigator, "MozAppearance" in ((s = (d = document.documentElement) === null || d === void 0 ? void 0 : d.style) !== null && s !== void 0 ? s : {}), "onmozfullscreenchange" in r, "mozInnerScreenX" in r, "CSSMozDocumentRule" in r, "CanvasCaptureMediaStream" in r]) >= 4
}

function Mve() {
  var d = window;
  return Ca([!("MediaSettingsRange" in d), "RTCEncodedAudioFrame" in d, "" + d.Intl == "[object Intl]", "" + d.Reflect == "[object Reflect]"]) >= 3
}

function Ive() {
  var d = window,
    s = d.URLPattern;
  return Ca(["union" in Set.prototype, "Iterator" in d, s && "hasRegExpGroups" in s.prototype, "RGB8" in WebGLRenderingContext.prototype]) >= 3
}

function Cve() {
  var d = window;
  return Ca(["DOMRectList" in d, "RTCPeerConnectionIceEvent" in d, "SVGGeometryElement" in d, "ontransitioncancel" in d]) >= 3
}

function qh() {
  var d = window,
    s = navigator,
    r = d.CSS,
    x = d.HTMLButtonElement;
  return Ca([!("getStorageUpdates" in s), x && "popover" in x.prototype, "CSSCounterStyleRule" in d, r.supports("font-size-adjust: ex-height 0.5"), r.supports("text-transform: full-width")]) >= 4
}

function Ave() {
  if (navigator.platform === "iPad") return !0;
  var d = screen,
    s = d.width / d.height;
  return Ca(["MediaSource" in window, !!Element.prototype.webkitRequestFullscreen, s > .65 && s < 1.53]) >= 2
}

function zve() {
  var d = document;
  return d.fullscreenElement || d.msFullscreenElement || d.mozFullScreenElement || d.webkitFullscreenElement || null
}

function Eve() {
  var d = document;
  return (d.exitFullscreen || d.msExitFullscreen || d.mozCancelFullScreen || d.webkitExitFullscreen).call(d)
}

function mm() {
  var d = Bh(),
    s = Q0(),
    r = window,
    x = navigator,
    A = "connection";
  return d ? Ca([!("SharedWorker" in r), x[A] && "ontypechange" in x[A], !("sinkId" in new Audio)]) >= 2 : s ? Ca(["onorientationchange" in r, "orientation" in r, /android/i.test(x.appVersion)]) >= 2 : !1
}

function Lve() {
  var d = navigator,
    s = window,
    r = Audio.prototype,
    x = s.visualViewport;
  return Ca(["srLatency" in r, "srChannelCount" in r, "devicePosture" in d, x && "segments" in x, "getTextInformation" in Image.prototype]) >= 3
}

function Dve() {
  return Fve() ? -4 : Rve()
}

function Rve() {
  var d = window,
    s = d.OfflineAudioContext || d.webkitOfflineAudioContext;
  if (!s) return -2;
  if (jve()) return -1;
  var r = 4500,
    x = 5e3,
    A = new s(1, x, 44100),
    E = A.createOscillator();
  E.type = "triangle", E.frequency.value = 1e4;
  var k = A.createDynamicsCompressor();
  k.threshold.value = -50, k.knee.value = 40, k.ratio.value = 12, k.attack.value = 0, k.release.value = .25, E.connect(k), k.connect(A.destination), E.start(0);
  var l = Bve(A),
    j = l[0],
    W = l[1],
    $ = ih(j.then(function(J) {
      return Ove(J.getChannelData(0).subarray(r))
    }, function(J) {
      if (J.name === "timeout" || J.name === "suspended") return -3;
      throw J
    }));
  return function() {
    return W(), $
  }
}

function jve() {
  return Co() && !_m() && !Cve()
}

function Fve() {
  return Co() && qh() && Oh() || Bh() && Lve() && Ive()
}

function Bve(d) {
  var s = 3,
    r = 500,
    x = 500,
    A = 5e3,
    E = function() {},
    k = new Promise(function(l, j) {
      var W = !1,
        $ = 0,
        J = 0;
      d.oncomplete = function(fe) {
        return l(fe.renderedBuffer)
      };
      var ce = function() {
          setTimeout(function() {
            return j(Bv("timeout"))
          }, Math.min(x, J + A - Date.now()))
        },
        ge = function() {
          try {
            var fe = d.startRendering();
            switch (Y0(fe) && ih(fe), d.state) {
              case "running":
                J = Date.now(), W && ce();
                break;
              case "suspended":
                document.hidden || $++, W && $ >= s ? j(Bv("suspended")) : setTimeout(ge, r);
                break
            }
          } catch (Z) {
            j(Z)
          }
        };
      ge(), E = function() {
        W || (W = !0, J > 0 && ce())
      }
    });
  return [k, E]
}

function Ove(d) {
  for (var s = 0, r = 0; r < d.length; ++r) s += Math.abs(d[r]);
  return s
}

function Bv(d) {
  var s = new Error(d);
  return s.name = d, s
}

function ey(d, s, r) {
  var x, A, E;
  return r === void 0 && (r = 50), No(this, void 0, void 0, function() {
    var k, l;
    return Vo(this, function(j) {
      switch (j.label) {
        case 0:
          k = document, j.label = 1;
        case 1:
          return k.body ? [3, 3] : [4, Sp(r)];
        case 2:
          return j.sent(), [3, 1];
        case 3:
          l = k.createElement("iframe"), j.label = 4;
        case 4:
          return j.trys.push([4, , 10, 11]), [4, new Promise(function(W, $) {
            var J = !1,
              ce = function() {
                J = !0, W()
              },
              ge = function(de) {
                J = !0, $(de)
              };
            l.onload = ce, l.onerror = ge;
            var fe = l.style;
            fe.setProperty("display", "block", "important"), fe.position = "absolute", fe.top = "0", fe.left = "0", fe.visibility = "hidden", s && "srcdoc" in l ? l.srcdoc = s : l.src = "about:blank", k.body.appendChild(l);
            var Z = function() {
              var de, Fe;
              J || (((Fe = (de = l.contentWindow) === null || de === void 0 ? void 0 : de.document) === null || Fe === void 0 ? void 0 : Fe.readyState) === "complete" ? ce() : setTimeout(Z, 10))
            };
            Z()
          })];
        case 5:
          j.sent(), j.label = 6;
        case 6:
          return !((A = (x = l.contentWindow) === null || x === void 0 ? void 0 : x.document) === null || A === void 0) && A.body ? [3, 8] : [4, Sp(r)];
        case 7:
          return j.sent(), [3, 6];
        case 8:
          return [4, d(l, l.contentWindow)];
        case 9:
          return [2, j.sent()];
        case 10:
          return (E = l.parentNode) === null || E === void 0 || E.removeChild(l), [7];
        case 11:
          return [2]
      }
    })
  })
}

function qve(d) {
  for (var s = fve(d), r = s[0], x = s[1], A = document.createElement(r ?? "div"), E = 0, k = Object.keys(x); E < k.length; E++) {
    var l = k[E],
      j = x[l].join(" ");
    l === "style" ? Nve(A.style, j) : A.setAttribute(l, j)
  }
  return A
}

function Nve(d, s) {
  for (var r = 0, x = s.split(";"); r < x.length; r++) {
    var A = x[r],
      E = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(A);
    if (E) {
      var k = E[1],
        l = E[2],
        j = E[4];
      d.setProperty(k, l, j || "")
    }
  }
}

function Vve() {
  for (var d = window;;) {
    var s = d.parent;
    if (!s || s === d) return !1;
    try {
      if (s.location.origin !== d.location.origin) return !0
    } catch (r) {
      if (r instanceof Error && r.name === "SecurityError") return !0;
      throw r
    }
    d = s
  }
}
var Uve = "mmMwWLliI0O&1",
  Zve = "48px",
  Pc = ["monospace", "sans-serif", "serif"],
  Ov = ["sans-serif-thin", "ARNO PRO", "Agency FB", "Arabic Typesetting", "Arial Unicode MS", "AvantGarde Bk BT", "BankGothic Md BT", "Batang", "Bitstream Vera Sans Mono", "Calibri", "Century", "Century Gothic", "Clarendon", "EUROSTILE", "Franklin Gothic", "Futura Bk BT", "Futura Md BT", "GOTHAM", "Gill Sans", "HELV", "Haettenschweiler", "Helvetica Neue", "Humanst521 BT", "Leelawadee", "Letter Gothic", "Levenim MT", "Lucida Bright", "Lucida Sans", "Menlo", "MS Mincho", "MS Outlook", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MYRIAD PRO", "Marlett", "Meiryo UI", "Microsoft Uighur", "Minion Pro", "Monotype Corsiva", "PMingLiU", "Pristina", "SCRIPTINA", "Segoe UI Light", "Serifa", "SimHei", "Small Fonts", "Staccato222 BT", "TRAJAN PRO", "Univers CE 55 Medium", "Vrinda", "ZWAdobeF"];

function Gve() {
  var d = this;
  return ey(function(s, r) {
    var x = r.document;
    return No(d, void 0, void 0, function() {
      var A, E, k, l, j, W, $, J, ce, ge, fe, Z;
      return Vo(this, function(de) {
        for (A = x.body, A.style.fontSize = Zve, E = x.createElement("div"), E.style.setProperty("visibility", "hidden", "important"), k = {}, l = {}, j = function(Fe) {
            var Re = x.createElement("span"),
              Pe = Re.style;
            return Pe.position = "absolute", Pe.top = "0", Pe.left = "0", Pe.fontFamily = Fe, Re.textContent = Uve, E.appendChild(Re), Re
          }, W = function(Fe, Re) {
            return j("'".concat(Fe, "',").concat(Re))
          }, $ = function() {
            return Pc.map(j)
          }, J = function() {
            for (var Fe = {}, Re = function(Ve) {
                Fe[Ve] = Pc.map(function(ve) {
                  return W(Ve, ve)
                })
              }, Pe = 0, Ge = Ov; Pe < Ge.length; Pe++) {
              var et = Ge[Pe];
              Re(et)
            }
            return Fe
          }, ce = function(Fe) {
            return Pc.some(function(Re, Pe) {
              return Fe[Pe].offsetWidth !== k[Re] || Fe[Pe].offsetHeight !== l[Re]
            })
          }, ge = $(), fe = J(), A.appendChild(E), Z = 0; Z < Pc.length; Z++) k[Pc[Z]] = ge[Z].offsetWidth, l[Pc[Z]] = ge[Z].offsetHeight;
        return [2, Ov.filter(function(Fe) {
          return ce(fe[Fe])
        })]
      })
    })
  })
}

function $ve() {
  var d = navigator.plugins;
  if (d) {
    for (var s = [], r = 0; r < d.length; ++r) {
      var x = d[r];
      if (x) {
        for (var A = [], E = 0; E < x.length; ++E) {
          var k = x[E];
          A.push({
            type: k.type,
            suffixes: k.suffixes
          })
        }
        s.push({
          name: x.name,
          description: x.description,
          mimeTypes: A
        })
      }
    }
    return s
  }
}

function Wve() {
  return Hve(t0e())
}

function Hve(d) {
  var s, r = !1,
    x, A, E = Xve(),
    k = E[0],
    l = E[1];
  return Yve(k, l) ? (r = Kve(l), d ? x = A = "skipped" : (s = Jve(k, l), x = s[0], A = s[1])) : x = A = "unsupported", {
    winding: r,
    geometry: x,
    text: A
  }
}

function Xve() {
  var d = document.createElement("canvas");
  return d.width = 1, d.height = 1, [d, d.getContext("2d")]
}

function Yve(d, s) {
  return !!(s && d.toDataURL)
}

function Kve(d) {
  return d.rect(0, 0, 10, 10), d.rect(2, 2, 6, 6), !d.isPointInPath(5, 5, "evenodd")
}

function Jve(d, s) {
  Qve(d, s);
  var r = Qf(d),
    x = Qf(d);
  if (r !== x) return ["unstable", "unstable"];
  e0e(d, s);
  var A = Qf(d);
  return [A, r]
}

function Qve(d, s) {
  d.width = 240, d.height = 60, s.textBaseline = "alphabetic", s.fillStyle = "#f60", s.fillRect(100, 1, 62, 20), s.fillStyle = "#069", s.font = '11pt "Times New Roman"';
  var r = "Cwm fjordbank gly ".concat("ğŸ˜ƒ");
  s.fillText(r, 2, 15), s.fillStyle = "rgba(102, 204, 0, 0.2)", s.font = "18pt Arial", s.fillText(r, 4, 45)
}

function e0e(d, s) {
  d.width = 122, d.height = 110, s.globalCompositeOperation = "multiply";
  for (var r = 0, x = [
      ["#f2f", 40, 40],
      ["#2ff", 80, 40],
      ["#ff2", 60, 80]
    ]; r < x.length; r++) {
    var A = x[r],
      E = A[0],
      k = A[1],
      l = A[2];
    s.fillStyle = E, s.beginPath(), s.arc(k, l, 40, 0, Math.PI * 2, !0), s.closePath(), s.fill()
  }
  s.fillStyle = "#f9c", s.arc(60, 60, 60, 0, Math.PI * 2, !0), s.arc(60, 60, 20, 0, Math.PI * 2, !0), s.fill("evenodd")
}

function Qf(d) {
  return d.toDataURL()
}

function t0e() {
  return Co() && qh() && Oh()
}

function r0e() {
  var d = navigator,
    s = 0,
    r;
  d.maxTouchPoints !== void 0 ? s = fm(d.maxTouchPoints) : d.msMaxTouchPoints !== void 0 && (s = d.msMaxTouchPoints);
  try {
    document.createEvent("TouchEvent"), r = !0
  } catch {
    r = !1
  }
  var x = "ontouchstart" in window;
  return {
    maxTouchPoints: s,
    touchEvent: r,
    touchStart: x
  }
}

function n0e() {
  return navigator.oscpu
}

function i0e() {
  var d = navigator,
    s = [],
    r = d.language || d.userLanguage || d.browserLanguage || d.systemLanguage;
  if (r !== void 0 && s.push([r]), Array.isArray(d.languages)) Bh() && Mve() || s.push(d.languages);
  else if (typeof d.languages == "string") {
    var x = d.languages;
    x && s.push(x.split(","))
  }
  return s
}

function a0e() {
  return window.screen.colorDepth
}

function o0e() {
  return hs(So(navigator.deviceMemory), void 0)
}

function s0e() {
  if (!(Co() && qh() && Oh())) return l0e()
}

function l0e() {
  var d = screen,
    s = function(x) {
      return hs(fm(x), null)
    },
    r = [s(d.width), s(d.height)];
  return r.sort().reverse(), r
}
var c0e = 2500,
  u0e = 10,
  pp, e_;

function h0e() {
  if (e_ === void 0) {
    var d = function() {
      var s = y_();
      x_(s) ? e_ = setTimeout(d, c0e) : (pp = s, e_ = void 0)
    };
    d()
  }
}

function d0e() {
  var d = this;
  return h0e(),
    function() {
      return No(d, void 0, void 0, function() {
        var s;
        return Vo(this, function(r) {
          switch (r.label) {
            case 0:
              return s = y_(), x_(s) ? pp ? [2, H0([], pp, !0)] : zve() ? [4, Eve()] : [3, 2] : [3, 2];
            case 1:
              r.sent(), s = y_(), r.label = 2;
            case 2:
              return x_(s) || (pp = s), [2, s]
          }
        })
      })
    }
}

function p0e() {
  var d = this;
  if (Co() && qh() && Oh()) return function() {
    return Promise.resolve(void 0)
  };
  var s = d0e();
  return function() {
    return No(d, void 0, void 0, function() {
      var r, x;
      return Vo(this, function(A) {
        switch (A.label) {
          case 0:
            return [4, s()];
          case 1:
            return r = A.sent(), x = function(E) {
              return E === null ? null : K0(E, u0e)
            }, [2, [x(r[0]), x(r[1]), x(r[2]), x(r[3])]]
        }
      })
    })
  }
}

function y_() {
  var d = screen;
  return [hs(So(d.availTop), null), hs(So(d.width) - So(d.availWidth) - hs(So(d.availLeft), 0), null), hs(So(d.height) - So(d.availHeight) - hs(So(d.availTop), 0), null), hs(So(d.availLeft), null)]
}

function x_(d) {
  for (var s = 0; s < 4; ++s)
    if (d[s]) return !1;
  return !0
}

function f0e() {
  return hs(fm(navigator.hardwareConcurrency), void 0)
}

function _0e() {
  var d, s = (d = window.Intl) === null || d === void 0 ? void 0 : d.DateTimeFormat;
  if (s) {
    var r = new s().resolvedOptions().timeZone;
    if (r) return r
  }
  var x = -m0e();
  return "UTC".concat(x >= 0 ? "+" : "").concat(x)
}

function m0e() {
  var d = new Date().getFullYear();
  return Math.max(So(new Date(d, 0, 1).getTimezoneOffset()), So(new Date(d, 6, 1).getTimezoneOffset()))
}

function g0e() {
  try {
    return !!window.sessionStorage
  } catch {
    return !0
  }
}

function v0e() {
  try {
    return !!window.localStorage
  } catch {
    return !0
  }
}

function y0e() {
  if (!(J0() || Sve())) try {
    return !!window.indexedDB
  } catch {
    return !0
  }
}

function x0e() {
  return !!window.openDatabase
}

function b0e() {
  return navigator.cpuClass
}

function w0e() {
  var d = navigator.platform;
  return d === "MacIntel" && Co() && !_m() ? Ave() ? "iPad" : "iPhone" : d
}

function k0e() {
  return navigator.vendor || ""
}

function T0e() {
  for (var d = [], s = 0, r = ["chrome", "safari", "__crWeb", "__gCrWeb", "yandex", "__yb", "__ybro", "__firefox__", "__edgeTrackingPreventionStatistics", "webkit", "oprt", "samsungAr", "ucweb", "UCShellJava", "puffinDevice"]; s < r.length; s++) {
    var x = r[s],
      A = window[x];
    A && typeof A == "object" && d.push(x)
  }
  return d.sort()
}

function P0e() {
  var d = document;
  try {
    d.cookie = "cookietest=1; SameSite=Strict;";
    var s = d.cookie.indexOf("cookietest=") !== -1;
    return d.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", s
  } catch {
    return !1
  }
}

function S0e() {
  var d = atob;
  return {
    abpIndo: ["#Iklan-Melayang", "#Kolom-Iklan-728", "#SidebarIklan-wrapper", '[title="ALIENBOLA" i]', d("I0JveC1CYW5uZXItYWRz")],
    abpvn: [".quangcao", "#mobileCatfish", d("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
    adBlockFinland: [".mainostila", d("LnNwb25zb3JpdA=="), ".ylamainos", d("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"), d("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")],
    adBlockPersian: ["#navbar_notice_50", ".kadr", 'TABLE[width="140px"]', "#divAgahi", d("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")],
    adBlockWarningRemoval: ["#adblock-honeypot", ".adblocker-root", ".wp_adblock_detect", d("LmhlYWRlci1ibG9ja2VkLWFk"), d("I2FkX2Jsb2NrZXI=")],
    adGuardAnnoyances: [".hs-sosyal", "#cookieconsentdiv", 'div[class^="app_gdpr"]', ".as-oil", '[data-cypress="soft-push-notification-modal"]'],
    adGuardBase: [".BetterJsPopOverlay", d("I2FkXzMwMFgyNTA="), d("I2Jhbm5lcmZsb2F0MjI="), d("I2NhbXBhaWduLWJhbm5lcg=="), d("I0FkLUNvbnRlbnQ=")],
    adGuardChinese: [d("LlppX2FkX2FfSA=="), d("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"), "#widget-quan", d("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"), d("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")],
    adGuardFrench: ["#pavePub", d("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"), ".mobile_adhesion", ".widgetadv", d("LmFkc19iYW4=")],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: ["#kauli_yad_1", d("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="), d("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="), d("LmFkZ29vZ2xl"), d("Ll9faXNib29zdFJldHVybkFk")],
    adGuardMobile: [d("YW1wLWF1dG8tYWRz"), d("LmFtcF9hZA=="), 'amp-embed[type="24smi"]', "#mgid_iframe1", d("I2FkX2ludmlld19hcmVh")],
    adGuardRussian: [d("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="), d("LnJlY2xhbWE="), 'div[id^="smi2adblock"]', d("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"), "#psyduckpockeball"],
    adGuardSocial: [d("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="), d("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="), ".etsy-tweet", "#inlineShare", ".popup-social"],
    adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
    adGuardTrackingProtection: ["#qoo-counter", d("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="), d("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="), d("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="), "#top100counter"],
    adGuardTurkish: ["#backkapat", d("I3Jla2xhbWk="), d("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="), d("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"), d("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")],
    bulgarian: [d("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
    easyList: [".yb-floorad", d("LndpZGdldF9wb19hZHNfd2lkZ2V0"), d("LnRyYWZmaWNqdW5reS1hZA=="), ".textad_headline", d("LnNwb25zb3JlZC10ZXh0LWxpbmtz")],
    easyListChina: [d("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="), d("LmZyb250cGFnZUFkdk0="), "#taotaole", "#aafoot.top_box", ".cfa_popup"],
    easyListCookie: [".ezmob-footer", ".cc-CookieWarning", "[data-cookie-number]", d("LmF3LWNvb2tpZS1iYW5uZXI="), ".sygnal24-gdpr-modal-wrap"],
    easyListCzechSlovak: ["#onlajny-stickers", d("I3Jla2xhbW5pLWJveA=="), d("LnJla2xhbWEtbWVnYWJvYXJk"), ".sklik", d("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")],
    easyListDutch: [d("I2FkdmVydGVudGll"), d("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="), ".adstekst", d("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="), "#semilo-lrectangle"],
    easyListGermany: ["#SSpotIMPopSlider", d("LnNwb25zb3JsaW5rZ3J1ZW4="), d("I3dlcmJ1bmdza3k="), d("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"), d("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")],
    easyListItaly: [d("LmJveF9hZHZfYW5udW5jaQ=="), ".sb-box-pubbliredazionale", d("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"), d("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"), d("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")],
    easyListLithuania: [d("LnJla2xhbW9zX3RhcnBhcw=="), d("LnJla2xhbW9zX251b3JvZG9z"), d("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"), d("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"), d("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")],
    estonian: [d("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [".open.pushModal", "#issuem-leaky-paywall-articles-zero-remaining-nag", "#sovrn_container", 'div[class$="-hide"][zoompage-fontsize][style="display: block;"]', ".BlockNag__Card"],
    fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
    frellwitSwedish: [d("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="), d("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="), "article.category-samarbete", d("ZGl2LmhvbGlkQWRz"), "ul.adsmodern"],
    greekAdBlock: [d("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"), d("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="), d("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"), "DIV.agores300", "TABLE.advright"],
    hungarian: ["#cemp_doboz", ".optimonk-iframe-container", d("LmFkX19tYWlu"), d("W2NsYXNzKj0iR29vZ2xlQWRzIl0="), "#hirdetesek_box"],
    iDontCareAboutCookies: ['.alert-info[data-block-track*="CookieNotice"]', ".ModuleTemplateCookieIndicator", ".o--cookies--container", "#cookies-policy-sticky", "#stickyCookieBar"],
    icelandicAbp: [d("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
    latvian: [d("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="), d("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")],
    listKr: [d("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="), d("I2xpdmVyZUFkV3JhcHBlcg=="), d("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="), d("aW5zLmZhc3R2aWV3LWFk"), ".revenue_unit_item.dable"],
    listeAr: [d("LmdlbWluaUxCMUFk"), ".right-and-left-sponsers", d("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="), d("YVtocmVmKj0iYm9vcmFxLm9yZyJd"), d("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")],
    listeFr: [d("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="), d("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="), d("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="), ".site-pub-interstitiel", 'div[id^="crt-"][data-criteo-id]'],
    officialPolish: ["#ceneo-placeholder-ceneo-12", d("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"), d("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="), d("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="), d("ZGl2I3NrYXBpZWNfYWQ=")],
    ro: [d("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"), d("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"), d("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="), d("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"), 'a[href^="/url/"]'],
    ruAd: [d("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"), d("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="), d("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="), "#pgeldiz", ".yandex-rtb-block"],
    thaiAds: ["a[href*=macau-uta-popup]", d("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="), d("LmFkczMwMHM="), ".bumq", ".img-kosana"],
    webAnnoyancesUltralist: ["#mod-social-share-2", "#social-tools", d("LmN0cGwtZnVsbGJhbm5lcg=="), ".zergnet-recommend", ".yt.btn-link.btn-md.btn"]
  }
}

function M0e(d) {
  var s = d === void 0 ? {} : d,
    r = s.debug;
  return No(this, void 0, void 0, function() {
    var x, A, E, k, l, j;
    return Vo(this, function(W) {
      switch (W.label) {
        case 0:
          return I0e() ? (x = S0e(), A = Object.keys(x), E = (j = []).concat.apply(j, A.map(function($) {
            return x[$]
          })), [4, C0e(E)]) : [2, void 0];
        case 1:
          return k = W.sent(), r && A0e(x, k), l = A.filter(function($) {
            var J = x[$],
              ce = Ca(J.map(function(ge) {
                return k[ge]
              }));
            return ce > J.length * .6
          }), l.sort(), [2, l]
      }
    })
  })
}

function I0e() {
  return Co() || mm()
}

function C0e(d) {
  var s;
  return No(this, void 0, void 0, function() {
    var r, x, A, E, j, k, l, j;
    return Vo(this, function(W) {
      switch (W.label) {
        case 0:
          for (r = document, x = r.createElement("div"), A = new Array(d.length), E = {}, qv(x), j = 0; j < d.length; ++j) k = qve(d[j]), k.tagName === "DIALOG" && k.show(), l = r.createElement("div"), qv(l), l.appendChild(k), x.appendChild(l), A[j] = k;
          W.label = 1;
        case 1:
          return r.body ? [3, 3] : [4, Sp(50)];
        case 2:
          return W.sent(), [3, 1];
        case 3:
          r.body.appendChild(x);
          try {
            for (j = 0; j < d.length; ++j) A[j].offsetParent || (E[d[j]] = !0)
          } finally {
            (s = x.parentNode) === null || s === void 0 || s.removeChild(x)
          }
          return [2, E]
      }
    })
  })
}

function qv(d) {
  d.style.setProperty("visibility", "hidden", "important"), d.style.setProperty("display", "block", "important")
}

function A0e(d, s) {
  for (var r = "DOM blockers debug:\n```", x = 0, A = Object.keys(d); x < A.length; x++) {
    var E = A[x];
    r += `
`.concat(E, ":");
    for (var k = 0, l = d[E]; k < l.length; k++) {
      var j = l[k];
      r += `
  `.concat(s[j] ? "ğŸš«" : "â¡ï¸", " ").concat(j)
    }
  }
  console.log("".concat(r, "\n```"))
}

function z0e() {
  for (var d = 0, s = ["rec2020", "p3", "srgb"]; d < s.length; d++) {
    var r = s[d];
    if (matchMedia("(color-gamut: ".concat(r, ")")).matches) return r
  }
}

function E0e() {
  if (Nv("inverted")) return !0;
  if (Nv("none")) return !1
}

function Nv(d) {
  return matchMedia("(inverted-colors: ".concat(d, ")")).matches
}

function L0e() {
  if (Vv("active")) return !0;
  if (Vv("none")) return !1
}

function Vv(d) {
  return matchMedia("(forced-colors: ".concat(d, ")")).matches
}
var D0e = 100;

function R0e() {
  if (matchMedia("(min-monochrome: 0)").matches) {
    for (var d = 0; d <= D0e; ++d)
      if (matchMedia("(max-monochrome: ".concat(d, ")")).matches) return d;
    throw new Error("Too high value")
  }
}

function j0e() {
  if (Sc("no-preference")) return 0;
  if (Sc("high") || Sc("more")) return 1;
  if (Sc("low") || Sc("less")) return -1;
  if (Sc("forced")) return 10
}

function Sc(d) {
  return matchMedia("(prefers-contrast: ".concat(d, ")")).matches
}

function F0e() {
  if (Uv("reduce")) return !0;
  if (Uv("no-preference")) return !1
}

function Uv(d) {
  return matchMedia("(prefers-reduced-motion: ".concat(d, ")")).matches
}

function B0e() {
  if (Zv("reduce")) return !0;
  if (Zv("no-preference")) return !1
}

function Zv(d) {
  return matchMedia("(prefers-reduced-transparency: ".concat(d, ")")).matches
}

function O0e() {
  if (Gv("high")) return !0;
  if (Gv("standard")) return !1
}

function Gv(d) {
  return matchMedia("(dynamic-range: ".concat(d, ")")).matches
}
var ti = Math,
  Ma = function() {
    return 0
  };

function q0e() {
  var d = ti.acos || Ma,
    s = ti.acosh || Ma,
    r = ti.asin || Ma,
    x = ti.asinh || Ma,
    A = ti.atanh || Ma,
    E = ti.atan || Ma,
    k = ti.sin || Ma,
    l = ti.sinh || Ma,
    j = ti.cos || Ma,
    W = ti.cosh || Ma,
    $ = ti.tan || Ma,
    J = ti.tanh || Ma,
    ce = ti.exp || Ma,
    ge = ti.expm1 || Ma,
    fe = ti.log1p || Ma,
    Z = function(Me) {
      return ti.pow(ti.PI, Me)
    },
    de = function(Me) {
      return ti.log(Me + ti.sqrt(Me * Me - 1))
    },
    Fe = function(Me) {
      return ti.log(Me + ti.sqrt(Me * Me + 1))
    },
    Re = function(Me) {
      return ti.log((1 + Me) / (1 - Me)) / 2
    },
    Pe = function(Me) {
      return ti.exp(Me) - 1 / ti.exp(Me) / 2
    },
    Ge = function(Me) {
      return (ti.exp(Me) + 1 / ti.exp(Me)) / 2
    },
    et = function(Me) {
      return ti.exp(Me) - 1
    },
    Ve = function(Me) {
      return (ti.exp(2 * Me) - 1) / (ti.exp(2 * Me) + 1)
    },
    ve = function(Me) {
      return ti.log(1 + Me)
    };
  return {
    acos: d(.12312423423423424),
    acosh: s(1e308),
    acoshPf: de(1e154),
    asin: r(.12312423423423424),
    asinh: x(1),
    asinhPf: Fe(1),
    atanh: A(.5),
    atanhPf: Re(.5),
    atan: E(.5),
    sin: k(-1e300),
    sinh: l(1),
    sinhPf: Pe(1),
    cos: j(10.000000000123),
    cosh: W(1),
    coshPf: Ge(1),
    tan: $(-1e300),
    tanh: J(1),
    tanhPf: Ve(1),
    exp: ce(1),
    expm1: ge(1),
    expm1Pf: et(1),
    log1p: fe(10),
    log1pPf: ve(10),
    powPI: Z(-100)
  }
}
var N0e = "mmMwWLliI0fiflO&1",
  t_ = {
    default: [],
    apple: [{
      font: "-apple-system-body"
    }],
    serif: [{
      fontFamily: "serif"
    }],
    sans: [{
      fontFamily: "sans-serif"
    }],
    mono: [{
      fontFamily: "monospace"
    }],
    min: [{
      fontSize: "1px"
    }],
    system: [{
      fontFamily: "system-ui"
    }]
  };

function V0e() {
  return U0e(function(d, s) {
    for (var r = {}, x = {}, A = 0, E = Object.keys(t_); A < E.length; A++) {
      var k = E[A],
        l = t_[k],
        j = l[0],
        W = j === void 0 ? {} : j,
        $ = l[1],
        J = $ === void 0 ? N0e : $,
        ce = d.createElement("span");
      ce.textContent = J, ce.style.whiteSpace = "nowrap";
      for (var ge = 0, fe = Object.keys(W); ge < fe.length; ge++) {
        var Z = fe[ge],
          de = W[Z];
        de !== void 0 && (ce.style[Z] = de)
      }
      r[k] = ce, s.append(d.createElement("br"), ce)
    }
    for (var Fe = 0, Re = Object.keys(t_); Fe < Re.length; Fe++) {
      var k = Re[Fe];
      x[k] = r[k].getBoundingClientRect().width
    }
    return x
  })
}

function U0e(d, s) {
  return s === void 0 && (s = 4e3), ey(function(r, x) {
    var A = x.document,
      E = A.body,
      k = E.style;
    k.width = "".concat(s, "px"), k.webkitTextSizeAdjust = k.textSizeAdjust = "none", Bh() ? E.style.zoom = "".concat(1 / x.devicePixelRatio) : Co() && (E.style.zoom = "reset");
    var l = A.createElement("div");
    return l.textContent = H0([], Array(s / 20 << 0), !0).map(function() {
      return "word"
    }).join(" "), E.appendChild(l), d(A, E)
  }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
}

function Z0e() {
  return navigator.pdfViewerEnabled
}

function G0e() {
  var d = new Float32Array(1),
    s = new Uint8Array(d.buffer);
  return d[0] = 1 / 0, d[0] = d[0] - d[0], s[3]
}

function $0e() {
  var d = window.ApplePaySession;
  if (typeof(d == null ? void 0 : d.canMakePayments) != "function") return -1;
  if (W0e()) return -3;
  try {
    return d.canMakePayments() ? 1 : 0
  } catch (s) {
    return H0e(s)
  }
}
var W0e = Vve;

function H0e(d) {
  if (d instanceof Error && d.name === "InvalidAccessError" && /\bfrom\b.*\binsecure\b/i.test(d.message)) return -2;
  throw d
}

function X0e() {
  var d, s = document.createElement("a"),
    r = (d = s.attributionSourceId) !== null && d !== void 0 ? d : s.attributionsourceid;
  return r === void 0 ? void 0 : String(r)
}
var ty = -1,
  ry = -2,
  Y0e = new Set([10752, 2849, 2884, 2885, 2886, 2928, 2929, 2930, 2931, 2932, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2978, 3024, 3042, 3088, 3089, 3106, 3107, 32773, 32777, 32777, 32823, 32824, 32936, 32937, 32938, 32939, 32968, 32969, 32970, 32971, 3317, 33170, 3333, 3379, 3386, 33901, 33902, 34016, 34024, 34076, 3408, 3410, 3411, 3412, 3413, 3414, 3415, 34467, 34816, 34817, 34818, 34819, 34877, 34921, 34930, 35660, 35661, 35724, 35738, 35739, 36003, 36004, 36005, 36347, 36348, 36349, 37440, 37441, 37443, 7936, 7937, 7938]),
  K0e = new Set([34047, 35723, 36063, 34852, 34853, 34854, 34229, 36392, 36795, 38449]),
  J0e = ["FRAGMENT_SHADER", "VERTEX_SHADER"],
  Q0e = ["LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT", "LOW_INT", "MEDIUM_INT", "HIGH_INT"],
  ny = "WEBGL_debug_renderer_info",
  eye = "WEBGL_polygon_mode";

function tye(d) {
  var s, r, x, A, E, k, l = d.cache,
    j = iy(l);
  if (!j) return ty;
  if (!oy(j)) return ry;
  var W = ay() ? null : j.getExtension(ny);
  return {
    version: ((s = j.getParameter(j.VERSION)) === null || s === void 0 ? void 0 : s.toString()) || "",
    vendor: ((r = j.getParameter(j.VENDOR)) === null || r === void 0 ? void 0 : r.toString()) || "",
    vendorUnmasked: W ? (x = j.getParameter(W.UNMASKED_VENDOR_WEBGL)) === null || x === void 0 ? void 0 : x.toString() : "",
    renderer: ((A = j.getParameter(j.RENDERER)) === null || A === void 0 ? void 0 : A.toString()) || "",
    rendererUnmasked: W ? (E = j.getParameter(W.UNMASKED_RENDERER_WEBGL)) === null || E === void 0 ? void 0 : E.toString() : "",
    shadingLanguageVersion: ((k = j.getParameter(j.SHADING_LANGUAGE_VERSION)) === null || k === void 0 ? void 0 : k.toString()) || ""
  }
}

function rye(d) {
  var s = d.cache,
    r = iy(s);
  if (!r) return ty;
  if (!oy(r)) return ry;
  var x = r.getSupportedExtensions(),
    A = r.getContextAttributes(),
    E = [],
    k = [],
    l = [],
    j = [],
    W = [];
  if (A)
    for (var $ = 0, J = Object.keys(A); $ < J.length; $++) {
      var ce = J[$];
      k.push("".concat(ce, "=").concat(A[ce]))
    }
  for (var ge = $v(r), fe = 0, Z = ge; fe < Z.length; fe++) {
    var de = Z[fe],
      Fe = r[de];
    l.push("".concat(de, "=").concat(Fe).concat(Y0e.has(Fe) ? "=".concat(r.getParameter(Fe)) : ""))
  }
  if (x)
    for (var Re = 0, Pe = x; Re < Pe.length; Re++) {
      var Ge = Pe[Re];
      if (!(Ge === ny && ay() || Ge === eye && aye())) {
        var et = r.getExtension(Ge);
        if (!et) {
          E.push(Ge);
          continue
        }
        for (var Ve = 0, ve = $v(et); Ve < ve.length; Ve++) {
          var de = ve[Ve],
            Fe = et[de];
          j.push("".concat(de, "=").concat(Fe).concat(K0e.has(Fe) ? "=".concat(r.getParameter(Fe)) : ""))
        }
      }
    }
  for (var Me = 0, Ye = J0e; Me < Ye.length; Me++)
    for (var Ce = Ye[Me], Oe = 0, ut = Q0e; Oe < ut.length; Oe++) {
      var Ue = ut[Oe],
        Ke = nye(r, Ce, Ue);
      W.push("".concat(Ce, ".").concat(Ue, "=").concat(Ke.join(",")))
    }
  return j.sort(), l.sort(), {
    contextAttributes: k,
    parameters: l,
    shaderPrecisions: W,
    extensions: x,
    extensionParameters: j,
    unsupportedExtensions: E
  }
}

function iy(d) {
  if (d.webgl) return d.webgl.context;
  var s = document.createElement("canvas"),
    r;
  s.addEventListener("webglCreateContextError", function() {
    return r = void 0
  });
  for (var x = 0, A = ["webgl", "experimental-webgl"]; x < A.length; x++) {
    var E = A[x];
    try {
      r = s.getContext(E)
    } catch {}
    if (r) break
  }
  return d.webgl = {
    context: r
  }, r
}

function nye(d, s, r) {
  var x = d.getShaderPrecisionFormat(d[s], d[r]);
  return x ? [x.rangeMin, x.rangeMax, x.precision] : []
}

function $v(d) {
  var s = Object.keys(d.__proto__);
  return s.filter(iye)
}

function iye(d) {
  return typeof d == "string" && !d.match(/[^A-Z0-9_x]/)
}

function ay() {
  return Q0()
}

function aye() {
  return Bh() || Co()
}

function oy(d) {
  return typeof d.getParameter == "function"
}

function oye() {
  var d = mm() || Co();
  if (!d) return -2;
  if (!window.AudioContext) return -1;
  var s = new AudioContext().baseLatency;
  return s == null ? -1 : isFinite(s) ? s : -3
}

function sye() {
  if (!window.Intl) return -1;
  var d = window.Intl.DateTimeFormat;
  if (!d) return -2;
  var s = d().resolvedOptions().locale;
  return !s && s !== "" ? -3 : s
}
var lye = {
  fonts: Gve,
  domBlockers: M0e,
  fontPreferences: V0e,
  audio: Dve,
  screenFrame: p0e,
  canvas: Wve,
  osCpu: n0e,
  languages: i0e,
  colorDepth: a0e,
  deviceMemory: o0e,
  screenResolution: s0e,
  hardwareConcurrency: f0e,
  timezone: _0e,
  sessionStorage: g0e,
  localStorage: v0e,
  indexedDB: y0e,
  openDatabase: x0e,
  cpuClass: b0e,
  platform: w0e,
  plugins: $ve,
  touchSupport: r0e,
  vendor: k0e,
  vendorFlavors: T0e,
  cookiesEnabled: P0e,
  colorGamut: z0e,
  invertedColors: E0e,
  forcedColors: L0e,
  monochrome: R0e,
  contrast: j0e,
  reducedMotion: F0e,
  reducedTransparency: B0e,
  hdr: O0e,
  math: q0e,
  pdfViewerEnabled: Z0e,
  architecture: G0e,
  applePay: $0e,
  privateClickMeasurement: X0e,
  audioBaseLatency: oye,
  dateTimeLocale: sye,
  webGlBasics: tye,
  webGlExtensions: rye
};

function cye(d) {
  return Pve(lye, d, [])
}
var uye = "$ if upgrade to Pro: https://fpjs.dev/pro";

function hye(d) {
  var s = dye(d),
    r = pye(s);
  return {
    score: s,
    comment: uye.replace(/\$/g, "".concat(r))
  }
}

function dye(d) {
  if (mm()) return .4;
  if (Co()) return _m() && !(qh() && Oh()) ? .5 : .3;
  var s = "value" in d.platform ? d.platform.value : "";
  return /^Win/.test(s) ? .6 : /^Mac/.test(s) ? .5 : .7
}

function pye(d) {
  return K0(.99 + .01 * d, 1e-4)
}

function fye(d) {
  for (var s = "", r = 0, x = Object.keys(d).sort(); r < x.length; r++) {
    var A = x[r],
      E = d[A],
      k = "error" in E ? "error" : JSON.stringify(E.value);
    s += "".concat(s ? "|" : "").concat(A.replace(/([:|\\])/g, "\\$1"), ":").concat(k)
  }
  return s
}

function sy(d) {
  return JSON.stringify(d, function(s, r) {
    return r instanceof Error ? bve(r) : r
  }, 2)
}

function ly(d) {
  return xve(fye(d))
}

function _ye(d) {
  var s, r = hye(d);
  return {
    get visitorId() {
      return s === void 0 && (s = ly(this.components)), s
    },
    set visitorId(x) {
      s = x
    },
    confidence: r,
    components: d,
    version: X0
  }
}

function mye(d) {
  return d === void 0 && (d = 50), hve(d, d * 2)
}

function gye(d, s) {
  var r = Date.now();
  return {
    get: function(x) {
      return No(this, void 0, void 0, function() {
        var A, E, k;
        return Vo(this, function(l) {
          switch (l.label) {
            case 0:
              return A = Date.now(), [4, d()];
            case 1:
              return E = l.sent(), k = _ye(E), (s || x != null && x.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(k.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(A - r, `
visitorId: `).concat(k.visitorId, `
components: `).concat(sy(E), "\n```")), [2, k]
          }
        })
      })
    }
  }
}

function vye() {
  if (!(window.__fpjs_d_m || Math.random() >= .001)) try {
    var d = new XMLHttpRequest;
    d.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(X0, "/npm-monitoring"), !0), d.send()
  } catch (s) {
    console.error(s)
  }
}

function yye(d) {
  var s;
  return d === void 0 && (d = {}), No(this, void 0, void 0, function() {
    var r, x, A;
    return Vo(this, function(E) {
      switch (E.label) {
        case 0:
          return (!((s = d.monitoring) !== null && s !== void 0) || s) && vye(), r = d.delayFallback, x = d.debug, [4, mye(r)];
        case 1:
          return E.sent(), A = cye({
            cache: {},
            debug: x
          }), [2, gye(A, x)]
      }
    })
  })
}
var cy = {
  load: yye,
  hashComponents: ly,
  componentsToDebugString: sy
};
let r_ = null,
  Mp;
async function xye() {
  return r_ || (r_ = cy.load()), r_
}
async function gm() {
  return Mp || bye().then(d => d.visitorId)
}
async function bye() {
  const s = await (await xye()).get(),
    {
      languages: r,
      dateTimeLocale: x,
      ...A
    } = s.components;
  return Mp = cy.hashComponents(A), {
    visitorId: Mp,
    components: A
  }
}
var wye = $r('<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>');

function Pl(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = wye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}

function fp(d) {
  const s = document.createElement("img");
  return s.src = d, new Promise((r, x) => {
    s.addEventListener("load", () => {
      r(s)
    }), s.addEventListener("error", A => {
      x(A)
    })
  })
}

function uy(d) {
  const s = document.createElement("canvas");
  s.width = d.naturalWidth, s.height = d.naturalHeight;
  const r = s.getContext("2d");
  return r == null || r.drawImage(d, 0, 0), s
}
var kye = se('<button type="button"></button>'),
  Tye = se('<div class="overlay pointer-events-auto svelte-rxq6cp"><canvas></canvas> <div class="overlay-border svelte-rxq6cp"></div> <!></div>'),
  Pye = se('<div><!> <p class="text-base font-medium">Drop an image or click the button below to select a file</p> <input type="file" accept="image/*" class="hidden" id="auto-paint-file"/> <label for="auto-paint-file" class="btn btn-primary btn-sm">Upload image</label></div>'),
  Sye = se("<option> </option>"),
  Mye = se('<span class="loading loading-spinner loading-sm"></span> Processing', 1),
  Iye = se('<button class="btn btn-primary"><!></button>'),
  Cye = se('<span class="loading loading-spinner loading-sm"></span> Sending', 1),
  Aye = se('<button class="btn btn-primary"><!></button>'),
  zye = se('<div class="rounded-box bg-success/10 text-success px-3 py-2 text-sm"> </div>'),
  Eye = se('<div class="mt-4 grid gap-4 md:grid-cols-2"><div class="space-y-2"><div class="rounded-box bg-base-200/60 p-3 text-sm"><p class="font-semibold"> </p> <p class="text-base-content/70"> </p></div> <div class="flex items-center gap-2"><label class="text-base-content/70 text-sm">Opacity</label> <input type="range" min="20" max="100"/></div> <div class="space-y-1"><label class="flex items-center gap-2 text-sm font-medium"><input type="checkbox" class="checkbox checkbox-primary checkbox-sm"/> <span>Dithering (Floyd-Steinberg)</span></label> <p class="text-base-content/70 text-xs">Makes color transitions smoother.</p></div> <div class="space-y-1"><label class="flex items-center gap-2 text-sm font-medium"><input type="checkbox" class="checkbox checkbox-primary checkbox-sm"/> <span>Paint transparent pixels</span></label> <p class="text-base-content/70 text-xs">Clears pixels using palette index 0.</p></div> <div class="space-y-1"><label class="flex flex-col gap-1 text-sm font-medium">Color metric <select class="select select-bordered select-sm w-full max-w-xs"></select></label></div></div> <div class="space-y-2 text-sm"><p class="text-base-content/70">1. Set image position by draging it.<br/> 2. Click on <strong>Generate Preview</strong> to convert the colors.<br/> 3. Confirm to paint the canvas.</p> <button class="btn btn-sm btn-outline">Change image</button> <div class="flex flex-wrap gap-2"><button class="btn btn-sm btn-outline">Flip horizontal</button> <button class="btn btn-sm btn-outline">Flip vertical</button></div> <label class="flex items-center gap-2 text-sm font-medium"><span class="whitespace-nowrap">Paint as user ID:</span> <input class="input input-bordered input-xs min-w-0 flex-1" type="number" placeholder="User ID"/></label></div></div> <div class="mt-4 flex flex-wrap items-center gap-3"><!> <button class="btn btn-ghost">Cancelar</button> <!></div>', 1),
  Lye = se(`<div class="pointer-events-none absolute inset-0 z-40 select-none"><!></div> <div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-2xl sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 border-t p-4 shadow-xl"><div class="flex items-center justify-between gap-2"><div><h2 class="flex items-center gap-2 text-lg font-semibold"><!> Auto Painter</h2> <p class="text-base-content/70 text-sm">Drag the image to the desired position. Use the anchors to change it's size.</p></div> <button class="btn btn-circle btn-sm" title="Fechar"><!></button></div> <!></div></div>`, 1);

function Dye(d, s) {
  var Qe;
  Qr(s, !1);
  const r = 2e3,
    x = 256,
    A = "admin-auto-painter-opacity",
    E = "admin-auto-painter-dithering",
    k = "admin-auto-painter-transparent";
  let l = sr(s, "map", 8),
    j = sr(s, "tileSize", 8),
    W = sr(s, "tileZoom", 8),
    $ = sr(s, "season", 8),
    J = sr(s, "refreshPixelArt", 8),
    ce = sr(s, "onclose", 8),
    ge = ea(new ja(j())),
    fe = ea(((Qe = Rt.data) == null ? void 0 : Qe.id) ?? 0),
    Z = ea("upload"),
    de = ea(!1),
    Fe = ea(!1),
    Re = ea(!1),
    Pe = ea(null),
    Ge = ea(""),
    et = ea(null),
    Ve = ea(null),
    ve = ea(null),
    Me = ea({
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }),
    Ye = [],
    Ce = ea(null),
    Oe = ea(null),
    ut = ea(1),
    Ue = ea(!1),
    Ke = ea(!1),
    St = ea("lab");
  const Ft = [{
    value: "lab",
    label: "Perceptual (CIELAB Î”E94)"
  }, {
    value: "compuphase",
    label: "Weighted RGB (CompuPhase)"
  }];
  let Jt = ea(!1),
    Mt = null;
  const ct = ["nw", "n", "ne", "e", "se", "s", "sw", "w"],
    wt = new Set(["nw", "ne", "se", "sw"]);

  function ft(oe) {
    return wt.has(oe)
  }

  function $t(oe, De, Je) {
    return Math.min(Math.max(oe, De), Je)
  }

  function Et(oe) {
    const De = Math.max(oe.north, oe.south),
      Je = Math.min(oe.north, oe.south),
      Tt = Math.min(oe.west, oe.east),
      Dt = Math.max(oe.west, oe.east);
    return {
      north: $t(De, -85, 85),
      south: $t(Je, -85, 85),
      west: $t(Tt, -180, 180),
      east: $t(Dt, -180, 180)
    }
  }

  function Qt(oe) {
    G(et, Et(oe)), G(de, !1), G(Ce, null), Ye = [], G(Me, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }), vr(), Kt(), dr()
  }

  function vr() {
    if (!g(et)) {
      G(ve, null);
      return
    }
    const [oe, De] = g(ge).latLonToPixels(g(et).north, g(et).west, W()), [Je, Tt] = g(ge).latLonToPixels(g(et).south, g(et).east, W()), Dt = Math.min(oe, Je), _t = Math.max(oe, Je), zt = Math.min(De, Tt), Yt = Math.max(De, Tt), $e = Math.max(1, Math.ceil(_t - Dt)), Ct = Math.max(1, Math.ceil(Yt - zt));
    G(ve, {
      px0: Dt,
      py0: zt,
      width: $e,
      height: Ct
    })
  }

  function Kt() {
    if (!g(et)) {
      G(Ve, null);
      return
    }
    const oe = l().project({
        lat: g(et).north,
        lng: g(et).west
      }),
      De = l().project({
        lat: g(et).south,
        lng: g(et).east
      }),
      Je = Math.min(oe.x, De.x),
      Tt = Math.min(oe.y, De.y),
      Dt = Math.abs(De.x - oe.x),
      _t = Math.abs(De.y - oe.y);
    G(Ve, {
      left: Je,
      top: Tt,
      width: Dt,
      height: _t
    })
  }

  function Bt() {
    G(Z, "upload"), G(Pe, null), G(Ge, ""), G(et, null), G(ve, null), G(Ve, null), G(de, !1), Ye = [], G(Ce, null), G(Me, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    })
  }

  function it() {
    if (!g(Pe)) return;
    const oe = l().getCenter(),
      [De, Je] = g(ge).latLonToPixels(oe.lat, oe.lng, W()),
      Tt = Math.min(1, x / g(Pe).width),
      Dt = Math.max(8, Math.round(g(Pe).width * Tt)),
      _t = Math.max(8, Math.round(g(Pe).height * Tt)),
      zt = De - Dt / 2,
      Yt = De + Dt / 2,
      $e = Je - _t / 2,
      Ct = Je + _t / 2,
      [ir, Fr] = g(ge).pixelsToLatLon(zt, $e, W()),
      [br, nt] = g(ge).pixelsToLatLon(Yt, Ct, W());
    Qt({
      north: ir,
      south: br,
      west: Fr,
      east: nt
    }), dr()
  }
  async function He(oe) {
    try {
      Bt();
      const De = URL.createObjectURL(oe),
        Je = await fp(De);
      URL.revokeObjectURL(De), G(Pe, uy(Je)), G(Ge, oe.name), G(Z, "place"), it()
    } catch (De) {
      console.error(De), rr.error("Failed to load image. Try again.")
    }
  }

  function Ot(oe) {
    var Tt;
    const De = oe.target,
      Je = (Tt = De.files) == null ? void 0 : Tt[0];
    Je && He(Je), De.value = ""
  }

  function Gt(oe) {
    oe.preventDefault(), G(Jt, !0)
  }

  function kt(oe) {
    oe.preventDefault(), G(Jt, !1)
  }

  function nr(oe) {
    var Je, Tt;
    oe.preventDefault(), G(Jt, !1);
    const De = (Tt = (Je = oe.dataTransfer) == null ? void 0 : Je.files) == null ? void 0 : Tt[0];
    De && He(De)
  }

  function It(oe) {
    const De = l().getCanvas().getBoundingClientRect(),
      Je = [oe.clientX - De.left, oe.clientY - De.top],
      Tt = l().unproject(Je);
    return {
      lat: Tt.lat,
      lon: Tt.lng
    }
  }

  function mt(oe, De, Je) {
    if (!g(Pe)) return De;
    const Tt = g(Pe).width / Math.max(g(Pe).height, 1);
    if (!isFinite(Tt) || Tt <= 0) return De;
    const Dt = oe.includes("n") ? Je.south : Je.north,
      _t = oe.includes("w") ? Je.east : Je.west,
      zt = oe.includes("n") ? De.north : De.south,
      Yt = oe.includes("w") ? De.west : De.east,
      [$e, Ct] = g(ge).latLonToPixels(Dt, _t, W()),
      [ir, Fr] = g(ge).latLonToPixels(zt, Yt, W());
    let br = ir - $e,
      nt = Fr - Ct,
      cr = Math.sign(br) || (oe.includes("w") ? -1 : 1),
      ar = Math.sign(nt) || (oe.includes("n") ? -1 : 1),
      Ar = Math.abs(br),
      qr = Math.abs(nt);
    if (Ar === 0 && qr === 0) return De;
    const Gr = qr * Tt,
      Mr = Ar / Tt;
    Gr > Ar ? Ar = Gr : qr = Mr;
    const Sn = $e + cr * Ar,
      Vr = Ct + ar * qr,
      [Le, tt] = g(ge).pixelsToLatLon(Sn, Vr, W());
    return oe.includes("n") ? De.north = Le : De.south = Le, oe.includes("w") ? De.west = tt : De.east = tt, De
  }

  function yt(oe) {
    if (!g(et)) return;
    oe.preventDefault();
    const {
      lat: De,
      lon: Je
    } = It(oe);
    Mt = {
      type: "move",
      startLat: De,
      startLon: Je,
      startBounds: {
        ...g(et)
      }
    }, st()
  }

  function bt(oe, De) {
    g(et) && (oe.preventDefault(), oe.stopPropagation(), Mt = {
      type: "resize",
      handle: De,
      startBounds: {
        ...g(et)
      }
    }, st())
  }

  function Lt(oe) {
    l().scrollZoom.isEnabled() && (oe.preventDefault(), l().getCanvasContainer().dispatchEvent(new WheelEvent("wheel", {
      deltaX: oe.deltaX,
      deltaY: oe.deltaY,
      deltaZ: oe.deltaZ,
      deltaMode: oe.deltaMode,
      clientX: oe.clientX,
      clientY: oe.clientY,
      screenX: oe.screenX,
      screenY: oe.screenY,
      ctrlKey: oe.ctrlKey,
      shiftKey: oe.shiftKey,
      altKey: oe.altKey,
      metaKey: oe.metaKey,
      bubbles: !0,
      cancelable: !0
    })))
  }

  function st() {
    l().dragPan.disable(), window.addEventListener("pointermove", gr), window.addEventListener("pointerup", lr)
  }

  function lr() {
    window.removeEventListener("pointermove", gr), window.removeEventListener("pointerup", lr), l().dragPan.enable(), Mt = null
  }

  function gr(oe) {
    if (!Mt || !Mt.startBounds) return;
    const {
      startBounds: De
    } = Mt;
    if (Mt.type === "move") {
      const {
        lat: zt,
        lon: Yt
      } = It(oe), $e = zt - Mt.startLat, Ct = Yt - Mt.startLon;
      Qt({
        north: De.north + $e,
        south: De.south + $e,
        west: De.west + Ct,
        east: De.east + Ct
      });
      return
    }
    const {
      handle: Je
    } = Mt, {
      lat: Tt,
      lon: Dt
    } = It(oe);
    let _t = {
      ...De
    };
    Je.includes("n") && (_t.north = Tt), Je.includes("s") && (_t.south = Tt), Je.includes("w") && (_t.west = Dt), Je.includes("e") && (_t.east = Dt), ft(Je) && (_t = mt(Je, _t, De)), Qt(_t)
  }

  function dr() {
    if (!g(Oe) || !g(ve) || !g(Pe) || g(de)) return;
    Ht().drawImage(g(Pe), 0, 0, g(ve).width, g(ve).height)
  }

  function pr(oe, De) {
    if (!g(Pe)) return;
    const Je = document.createElement("canvas");
    Je.width = g(Pe).width, Je.height = g(Pe).height;
    const Tt = Je.getContext("2d");
    if (!Tt) throw new Error("Canvas context not available");
    Tt.imageSmoothingEnabled = !1;
    const Dt = oe ? -1 : 1,
      _t = De ? -1 : 1,
      zt = oe ? g(Pe).width : 0,
      Yt = De ? g(Pe).height : 0;
    if (Tt.setTransform(Dt, 0, 0, _t, zt, Yt), Tt.drawImage(g(Pe), 0, 0), G(Pe, Je), g(de)) {
      ue();
      return
    }
    dr()
  }

  function Ht() {
    if (!g(Oe) || !g(ve)) throw new Error("Canvas not ready");
    _v(Oe, g(Oe).width = g(ve).width), _v(Oe, g(Oe).height = g(ve).height);
    const oe = g(Oe).getContext("2d", {
      willReadFrequently: !0
    });
    if (!oe) throw new Error("Canvas context not available");
    return oe.imageSmoothingEnabled = !1, oe.clearRect(0, 0, g(Oe).width, g(Oe).height), oe
  }

  function Sr() {
    if (!g(Oe) || !g(ve) || !g(Ce) || !g(de)) return;
    Ht().putImageData(g(Ce), 0, 0)
  }
  async function Rr() {
    if (!(!g(ve) || !g(Pe))) {
      if (g(ve).width > r || g(ve).height > r) {
        rr.error(`The selected area is too big (${g(ve).width}Ã—${g(ve).height}).`);
        return
      }
      G(Fe, !0);
      try {
        const oe = Vt();
        if (!oe || oe.pixels.length === 0) {
          rr.error("Faile to convert into valid game_pixels");
          return
        }
        G(Ce, oe.imageData), Ye = oe.pixels, G(Me, oe.stats), G(de, !0), Sr()
      } catch (oe) {
        console.error(oe), rr.error("Failed to generate preview.")
      } finally {
        G(Fe, !1)
      }
    }
  }

  function Vt() {
    if (!g(ve) || !g(Pe)) return;
    const oe = document.createElement("canvas");
    oe.width = g(ve).width, oe.height = g(ve).height;
    const De = oe.getContext("2d", {
      willReadFrequently: !0
    });
    if (!De) throw new Error("Context is null.");
    De.imageSmoothingEnabled = !1, De.drawImage(g(Pe), 0, 0, g(ve).width, g(ve).height);
    const Je = g(ve).width,
      Tt = g(ve).height,
      Dt = De.getImageData(0, 0, Je, Tt),
      _t = Dt.data,
      zt = [],
      Yt = new Set,
      $e = g(Ue);
    let Ct = null,
      ir = null;
    if ($e) {
      const Fr = Je * 3;
      Ct = new Float32Array(Fr), ir = new Float32Array(Fr)
    }
    for (let Fr = 0; Fr < Tt; Fr++) {
      if ($e && Ct && ir) {
        const br = Ct;
        Ct = ir, ir = br, ir.fill(0)
      }
      for (let br = 0; br < Je; br++) {
        const nt = (Fr * Je + br) * 4;
        if (_t[nt + 3] < 16) {
          if (_t[nt + 3] = 0, !g(Ke)) continue;
          const fr = 0,
            Wt = kp(fr);
          _t[nt] = Wt.r, _t[nt + 1] = Wt.g, _t[nt + 2] = Wt.b;
          const yr = g(ve).px0 + br + .5,
            tn = g(ve).py0 + Fr + .5,
            {
              tile: Kr,
              pixel: Br
            } = g(ge).pixelsToTileLocal(yr, tn),
            Cr = {
              tile: [Kr[0], Kr[1]],
              pixel: [Br[0], Br[1]],
              season: $(),
              colorIdx: fr,
              color: Wt
            },
            Yr = `${Kr[0]}:${Kr[1]}`;
          Yt.add(Yr), zt.push(Cr);
          continue
        }
        let ar = _t[nt],
          Ar = _t[nt + 1],
          qr = _t[nt + 2];
        if ($e && Ct) {
          const fr = br * 3;
          ar = $t(Math.round(ar + Ct[fr]), 0, 255), Ar = $t(Math.round(Ar + Ct[fr + 1]), 0, 255), qr = $t(Math.round(qr + Ct[fr + 2]), 0, 255)
        }
        const Gr = m0({
            r: ar,
            g: Ar,
            b: qr
          }, g(St)),
          Mr = kp(Gr);
        if (_t[nt] = Mr.r, _t[nt + 1] = Mr.g, _t[nt + 2] = Mr.b, _t[nt + 3] = Mr.a, $e && Ct && ir) {
          const fr = ar - Mr.r,
            Wt = Ar - Mr.g,
            yr = qr - Mr.b,
            tn = (Kr, Br, Cr) => {
              Kr[Br] += fr * Cr, Kr[Br + 1] += Wt * Cr, Kr[Br + 2] += yr * Cr
            };
          if (br + 1 < Je) {
            const Kr = (br + 1) * 3;
            tn(Ct, Kr, 7 / 16)
          }
          if (Fr + 1 < Tt) {
            if (br > 0) {
              const Br = (br - 1) * 3;
              tn(ir, Br, 3 / 16)
            }
            const Kr = br * 3;
            if (tn(ir, Kr, 5 / 16), br + 1 < Je) {
              const Br = (br + 1) * 3;
              tn(ir, Br, 1 / 16)
            }
          }
        }
        const Sn = g(ve).px0 + br + .5,
          Vr = g(ve).py0 + Fr + .5,
          {
            tile: Le,
            pixel: tt
          } = g(ge).pixelsToTileLocal(Sn, Vr),
          qt = {
            tile: [Le[0], Le[1]],
            pixel: [tt[0], tt[1]],
            season: $(),
            colorIdx: Gr,
            color: Mr
          },
          Ut = `${Le[0]}:${Le[1]}`;
        Yt.add(Ut), zt.push(qt)
      }
    }
    return {
      pixels: zt,
      imageData: Dt,
      stats: {
        pixels: zt.length,
        width: Je,
        height: Tt,
        tiles: Yt.size
      }
    }
  }
  async function Tr() {
    if (!(!g(de) || Ye.length === 0)) {
      G(Re, !0);
      try {
        gi.droppletAndPlop.play();
        const oe = await gm(),
          De = Ye.map(({
            color: Je,
            ...Tt
          }) => Tt);
        await pn.adminAutoPainterPaint(De, oe, g(fe)), await J_(Ye), J()(), Rt.refresh(), rr.success("Art painted successfully."), Xt()
      } catch (oe) {
        console.error(oe), rr.error(oe.message ?? "Failed to paint art.")
      } finally {
        G(Re, !1)
      }
    }
  }

  function Xt() {
    Bt(), ce()()
  }

  function ue() {
    G(de, !1), G(Ce, null), Ye = [], G(Me, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }), dr()
  }
  Wi(() => {
    const oe = () => Kt();
    return l().on("move", oe), l().on("zoom", oe), l().on("resize", oe), () => {
      l().off("move", oe), l().off("zoom", oe), l().off("resize", oe)
    }
  }), qb(() => {
    Bt()
  }), Yf(() => Yb(j()), () => {
    G(ge, new ja(j()))
  }), Yf(() => (g(Oe), g(ve), g(Pe), g(de), g(Z)), () => {
    g(Oe) && g(ve) && g(Pe) && !g(de) && g(Z) === "place" && dr()
  }), Yf(() => (g(Oe), g(ve), g(Ce), g(de)), () => {
    g(Oe) && g(ve) && g(Ce) && g(de) && Sr()
  }), Xb(), em();
  var N = Lye();
  Pn("keydown", Vs, oe => {
    oe.key === "Escape" && Xt()
  }), Pn("dragover", Vs, h2(Gt)), Pn("drop", Vs, nr), Pn("dragleave", Vs, kt);
  var q = Pt(N),
    X = S(q);
  {
    var te = oe => {
      var De = Tye(),
        Je = S(De);
      let Tt;
      oo(Je, zt => G(Oe, zt), () => g(Oe));
      var Dt = L(Je, 2),
        _t = L(Dt, 2);
      li(_t, 1, () => ct, zt => zt, (zt, Yt) => {
        var $e = kye();
        ze(Ct => {
          Or($e, 1, `handle handle-${g(Yt)}`, "svelte-rxq6cp"), or($e, "aria-label", Ct)
        }, [() => (g(Yt), ma(() => `Redimensionar (${g(Yt).toUpperCase()})`))]), Pn("pointerdown", $e, Ct => bt(Ct, g(Yt))), O(zt, $e)
      }), P(De), ze(() => {
        Io(De, (g(Ve), g(ut), ma(() => `left:${g(Ve).left}px;top:${g(Ve).top}px;width:${g(Ve).width}px;height:${g(Ve).height}px;opacity:${g(ut)};`))), Tt = Or(Je, 1, "h-full w-full svelte-rxq6cp", null, Tt, {
          pixelated: g(de)
        })
      }), Pn("pointerdown", Je, yt), Pn("pointerdown", Dt, yt), Pn("wheel", De, Lt), O(oe, De)
    };
    we(X, oe => {
      g(et) && g(Ve) && oe(te)
    })
  }
  P(q);
  var le = L(q, 2),
    xe = S(le),
    je = S(xe),
    Ie = S(je),
    qe = S(Ie),
    rt = S(qe);
  Pl(rt, {
    class: "size-5"
  }), bn(), P(qe), bn(2), P(Ie);
  var Xe = L(Ie, 2),
    he = S(Xe);
  ms(he, {
    class: "size-4"
  }), P(Xe), P(je);
  var Q = L(je, 2);
  {
    var Ze = oe => {
        var De = Pye(),
          Je = S(De);
        y1(Je, {
          class: "text-base-content/70 size-10"
        });
        var Tt = L(Je, 4);
        bn(2), P(De), ze(() => Or(De, 1, `rounded-box mt-4 flex flex-col items-center justify-center gap-3 border border-dashed p-6 text-center transition ${g(Jt)?"border-primary bg-primary/10":"border-base-300"}`, "svelte-rxq6cp")), Pn("change", Tt, Ot), O(oe, De)
      },
      vt = oe => {
        var De = Ir(),
          Je = Pt(De);
        {
          var Tt = Dt => {
            var _t = Eye(),
              zt = Pt(_t),
              Yt = S(zt),
              $e = S(Yt),
              Ct = S($e),
              ir = S(Ct, !0);
            P(Ct);
            var Fr = L(Ct, 2),
              br = S(Fr);
            P(Fr), P($e);
            var nt = L($e, 2),
              cr = S(nt);
            or(cr, "for", A);
            var ar = L(cr, 2);
            sa(ar), or(ar, "id", A), P(nt);
            var Ar = L(nt, 2),
              qr = S(Ar);
            or(qr, "for", E);
            var Gr = S(qr);
            sa(Gr), or(Gr, "id", E), bn(2), P(qr), bn(2), P(Ar);
            var Mr = L(Ar, 2),
              Sn = S(Mr);
            or(Sn, "for", k);
            var Vr = S(Sn);
            sa(Vr), or(Vr, "id", k), bn(2), P(Sn), bn(2), P(Mr);
            var Le = L(Mr, 2),
              tt = S(Le),
              qt = L(S(tt));
            ze(() => {
              g(St), Kb(() => {
                g(de)
              })
            }), li(qt, 5, () => Ft, Bc, (En, Mn) => {
              var qn = Sye(),
                Gn = S(qn, !0);
              P(qn);
              var Jn = {};
              ze(() => {
                ee(Gn, (g(Mn), ma(() => g(Mn).label))), Jn !== (Jn = (g(Mn), ma(() => g(Mn).value))) && (qn.value = (qn.__value = (g(Mn), ma(() => g(Mn).value))) ?? "")
              }), O(En, qn)
            }), P(qt), P(tt), P(Le), P(Yt);
            var Ut = L(Yt, 2),
              fr = L(S(Ut), 2),
              Wt = L(fr, 2),
              yr = S(Wt),
              tn = L(yr, 2);
            P(Wt);
            var Kr = L(Wt, 2),
              Br = L(S(Kr), 2);
            sa(Br), P(Kr), P(Ut), P(zt);
            var Cr = L(zt, 2),
              Yr = S(Cr);
            {
              var Ln = En => {
                  var Mn = Iye(),
                    qn = S(Mn);
                  {
                    var Gn = Zn => {
                        var ri = Mye();
                        bn(), O(Zn, ri)
                      },
                      Jn = Zn => {
                        var ri = vi("Generate Preview");
                        O(Zn, ri)
                      };
                    we(qn, Zn => {
                      g(Fe) ? Zn(Gn) : Zn(Jn, !1)
                    })
                  }
                  P(Mn), ze(() => Mn.disabled = g(Fe)), Pn("click", Mn, Rr), O(En, Mn)
                },
                In = En => {
                  var Mn = Aye(),
                    qn = S(Mn);
                  {
                    var Gn = Zn => {
                        var ri = Cye();
                        bn(), O(Zn, ri)
                      },
                      Jn = Zn => {
                        var ri = vi("Confirm painting");
                        O(Zn, ri)
                      };
                    we(qn, Zn => {
                      g(Re) ? Zn(Gn) : Zn(Jn, !1)
                    })
                  }
                  P(Mn), ze(() => Mn.disabled = g(Re)), Pn("click", Mn, Tr), O(En, Mn)
                };
              we(Yr, En => {
                g(de) ? En(In, !1) : En(Ln)
              })
            }
            var Wr = L(Yr, 2),
              jr = L(Wr, 2);
            {
              var wn = En => {
                var Mn = zye(),
                  qn = S(Mn);
                P(Mn), ze(Gn => ee(qn, `Ready to paint ${Gn??""} pixels.`), [() => (g(Me), ma(() => g(Me).pixels.toLocaleString()))]), O(En, Mn)
              };
              we(jr, En => {
                g(de) && En(wn)
              })
            }
            P(Cr), ze(() => {
              ee(ir, g(Ge)), ee(br, `Target size: ${g(ve),ma(()=>g(ve).width)??""} Ã— ${g(ve),ma(()=>g(ve).height)??""} pixels`), K_(ar, g(ut) * 100)
            }), Pn("input", ar, En => {
              const Mn = En.target;
              G(ut, Number(Mn.value) / 100)
            }), wp(Gr, () => g(Ue), En => G(Ue, En)), Pn("change", Gr, () => {
              g(de) && ue()
            }), wp(Vr, () => g(Ke), En => G(Ke, En)), Pn("change", Vr, () => {
              g(de) && ue()
            }), r1(qt, () => g(St), En => G(St, En)), Pn("change", qt, () => {
              g(de) && ue()
            }), Pn("click", fr, () => G(Z, "upload")), Pn("click", yr, () => pr(!0, !1)), Pn("click", tn, () => pr(!1, !0)), Oc(Br, () => g(fe), En => G(fe, En)), Pn("click", Wr, Xt), O(Dt, _t)
          };
          we(Je, Dt => {
            g(et) && g(ve) && Dt(Tt)
          }, !0)
        }
        O(oe, De)
      };
    we(Q, oe => {
      g(Z) === "upload" ? oe(Ze) : oe(vt, !1)
    })
  }
  P(xe), P(le), Pn("click", Xe, Xt), O(d, N), en()
}
const _p = Pi({
  shouldReload: !0
});
var Rye = se('<dialog class="modal" closeby="any"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function jye(d, s) {
  Qr(s, !0);
  let r = sr(s, "ref", 15),
    x = We(!1),
    A = We(Pi(s.description)),
    E = We(void 0);
  var k = Rye(),
    l = S(k),
    j = S(l),
    W = S(j, !0);
  P(j);
  var $ = L(j, 2),
    J = S($),
    ce = S(J);
  {
    let Re = xt(() => R0());
    g0(ce, {
      class: "h-24 rounded-lg",
      get placeholder() {
        return g(Re)
      },
      max: 512,
      get value() {
        return g(A)
      },
      set value(Pe) {
        G(A, Pe, !0)
      },
      get validate() {
        return g(E)
      },
      set validate(Pe) {
        G(E, Pe, !0)
      }
    })
  }
  P(J);
  var ge = L(J, 2),
    fe = S(ge);
  fe.__click = () => {
    var Re;
    (Re = r()) == null || Re.close()
  };
  var Z = S(fe, !0);
  P(fe);
  var de = L(fe, 2),
    Fe = S(de, !0);
  P(de), P(ge), P($), P(l), bn(2), P(k), oo(k, Re => r(Re), () => r()), ze((Re, Pe, Ge) => {
    ee(W, Re), fe.disabled = g(x), ee(Z, Pe), de.disabled = g(x), ee(Fe, Ge)
  }, [() => S1(), () => Nc(), () => Cne()]), Pn("submit", $, async () => {
    var Re, Pe, Ge;
    try {
      if (!((Re = g(E)) != null && Re())) return;
      G(x, !0), s.description !== g(A) && await pn.updateAllianceDescription(g(A)), await ((Pe = s.onsuccess) == null ? void 0 : Pe.call(s, g(A))), (Ge = r()) == null || Ge.close()
    } catch (et) {
      rr.error(et.message)
    } finally {
      G(x, !1)
    }
  }), O(d, k), en()
}
Yn(["click"]);
var Fye = se('<span class="loading loading-spinner loading-md center-absolute absolute"></span>'),
  Bye = se('<dialog class="modal" closedby="any"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Oye(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = We(""),
    A = We(!1);
  const E = xt(() => xi.url.origin + `/join?id=${g(x)}`);
  rn(() => {
    r() && pn.getAllianceInvites().then(Ve => {
      G(x, Ve[0], !0)
    }).catch(Ve => {
      rr.error(Ve.message)
    })
  });
  var k = Bye(),
    l = S(k),
    j = L(S(l), 2),
    W = S(j, !0);
  P(j);
  var $ = L(j, 2),
    J = S($, !0);
  P($);
  var ce = L($, 2),
    ge = S(ce);
  let fe;
  var Z = S(ge);
  sa(Z);
  var de = L(Z, 2),
    Fe = S(de);
  let Re;
  Fe.__click = () => {
    navigator.clipboard.writeText(g(E).toString()), G(A, !0), setTimeout(() => {
      G(A, !1)
    }, 1e3)
  };
  var Pe = S(Fe, !0);
  P(Fe), P(de), P(ge);
  var Ge = L(ge, 2);
  {
    var et = Ve => {
      var ve = Fye();
      O(Ve, ve)
    };
    we(Ge, Ve => {
      g(x) || Ve(et)
    })
  }
  P(ce), P(l), bn(2), P(k), Li(k, () => Ve => {
    rn(() => {
      r() ? Ve.show() : Ve.close()
    })
  }), ze((Ve, ve, Me, Ye) => {
    ee(W, Ve), ee(J, ve), fe = Or(ge, 1, "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5", null, fe, {
      invisible: !g(x)
    }), K_(Z, Me), Re = Or(Fe, 1, "btn btn-primary", null, Re, {
      "btn-success": g(A)
    }), ee(Pe, Ye)
  }, [() => XE(), () => YX(), () => g(E).toString(), () => g(A) ? sm() : d_()]), Pn("close", k, () => r(!1)), O(d, k), en()
}
Yn(["click"]);
var qye = $r('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>');

function b_(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = qye();
  Dr(x, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    ...r
  })), O(d, x)
}
var Nye = se('<span class="text-success">(Verified)</span>'),
  Vye = se('<a target="_blank" rel="noreferer" aria-label="Discord"><!></a>'),
  Uye = se("<button><!></button>"),
  Zye = se('<span class="tooltip h-4"><div class="tooltip-content"><span> </span> <!></div> <!></span>');

function Nh(d, s) {
  Qr(s, !0);
  const r = !!s.id;
  var x = Zye(),
    A = S(x),
    E = S(A),
    k = S(E);
  P(E);
  var l = L(E, 2);
  {
    var j = ce => {
      var ge = Nye();
      O(ce, ge)
    };
    we(l, ce => {
      r && ce(j)
    })
  }
  P(A);
  var W = L(A, 2);
  {
    var $ = ce => {
        var ge = Vye(),
          fe = S(ge);
        b_(fe, {
          class: "size-4 opacity-70"
        }), P(ge), ze(Z => or(ge, "href", Z), [() => `https://discord.com/users/${encodeURIComponent(s.id)}`]), O(ce, ge)
      },
      J = ce => {
        var ge = Uye();
        ge.__click = async () => {
          await navigator.clipboard.writeText(s.username), rr.info(tie())
        };
        var fe = S(ge);
        b_(fe, {
          class: "size-4 opacity-70"
        }), P(ge), O(ce, ge)
      };
    we(W, ce => {
      r ? ce($) : ce(J, !1)
    })
  }
  P(x), ze(() => ee(k, `Discord: ${s.username??""}`)), O(d, x), en()
}
Yn(["click"]);
var Gye = se('<input type="radio" class="tab max-[380px]:px-3"/>'),
  $ye = se('<div class="tabs tabs-border w-max font-medium"></div>');

function vm(d, s) {
  Qr(s, !0);
  const r = [];
  let x = sr(s, "value", 15, "today"),
    A = [{
      value: "today",
      label: qp()
    }, {
      value: "week",
      label: qie()
    }, {
      value: "month",
      label: e7()
    }, {
      value: "all-time",
      label: jw()
    }];
  var E = $ye();
  li(E, 21, () => A, k => k.value, (k, l) => {
    var j = Gye();
    sa(j);
    var W;
    ze(() => {
      or(j, "aria-label", g(l).label), W !== (W = g(l).value) && (j.value = (j.__value = g(l).value) ?? "")
    }), Q_(r, [], j, () => (g(l).value, x()), x), O(k, j)
  }), P(E), O(d, E), en()
}
const Wye = typeof window < "u" ? window : void 0;

function Hye(d) {
  let s = d.activeElement;
  for (; s != null && s.shadowRoot;) {
    const r = s.shadowRoot.activeElement;
    if (r === s) break;
    s = r
  }
  return s
}
var Ec, uh, l0;
let Xye = (l0 = class {
  constructor(s = {}) {
    yn(this, Ec);
    yn(this, uh);
    const {
      window: r = Wye,
      document: x = r == null ? void 0 : r.document
    } = s;
    r !== void 0 && (_a(this, Ec, x), _a(this, uh, h0(A => {
      const E = xp(r, "focusin", A),
        k = xp(r, "focusout", A);
      return () => {
        E(), k()
      }
    })))
  }
  get current() {
    var s;
    return (s = tr(this, uh)) == null || s.call(this), tr(this, Ec) ? Hye(tr(this, Ec)) : null
  }
}, Ec = new WeakMap, uh = new WeakMap, l0);
new Xye;

function Yye(d) {
  return typeof d == "function"
}

function Kye(d, s) {
  if (Yye(d)) {
    const x = d();
    return x === void 0 ? s : x
  }
  return d === void 0 ? s : d
}

function Jye(d, s) {
  let r = We(null);
  const x = xt(() => Kye(s, 250));

  function A(...E) {
    if (g(r)) g(r).timeout && clearTimeout(g(r).timeout);
    else {
      let k, l;
      const j = new Promise((W, $) => {
        k = W, l = $
      });
      G(r, {
        timeout: null,
        runner: null,
        promise: j,
        resolve: k,
        reject: l
      }, !0)
    }
    return g(r).runner = async () => {
      if (!g(r)) return;
      const k = g(r);
      G(r, null);
      try {
        k.resolve(await d.apply(this, E))
      } catch (l) {
        k.reject(l)
      }
    }, g(r).timeout = setTimeout(g(r).runner, g(x)), g(r).promise
  }
  return A.cancel = async () => {
    (!g(r) || g(r).timeout === null) && (await new Promise(E => setTimeout(E, 0)), !g(r) || g(r).timeout === null) || (clearTimeout(g(r).timeout), g(r).reject("Cancelled"), G(r, null))
  }, A.runScheduledNow = async () => {
    var E, k;
    (!g(r) || !g(r).timeout) && (await new Promise(l => setTimeout(l, 0)), !g(r) || !g(r).timeout) || (clearTimeout(g(r).timeout), g(r).timeout = null, await ((k = (E = g(r)).runner) == null ? void 0 : k.call(E)))
  }, Object.defineProperty(A, "pending", {
    enumerable: !0,
    get() {
      var E;
      return !!((E = g(r)) != null && E.timeout)
    }
  }), A
}

function Qye(d, s) {
  switch (d) {
    case "post":
      rn(s);
      break;
    case "pre":
      X_(s);
      break
  }
}

function hy(d, s, r, x = {}) {
  const {
    lazy: A = !1
  } = x;
  let E = !A,
    k = Array.isArray(d) ? [] : void 0;
  Qye(s, () => {
    const l = Array.isArray(d) ? d.map(W => W()) : d();
    if (!E) {
      E = !0, k = l;
      return
    }
    const j = ma(() => r(l, k));
    return k = l, j
  })
}

function fs(d, s, r) {
  hy(d, "post", s, r)
}

function exe(d, s, r) {
  hy(d, "pre", s, r)
}
fs.pre = exe;

function txe() {}
var bl, qs;
class rxe {
  constructor(s, r = 250) {
    yn(this, bl, We());
    yn(this, qs);
    G(tr(this, bl), s(), !0), this.cancel = this.cancel.bind(this), this.setImmediately = this.setImmediately.bind(this), this.updateImmediately = this.updateImmediately.bind(this), _a(this, qs, Jye(() => {
      G(tr(this, bl), s(), !0)
    }, r)), fs(s, () => {
      tr(this, qs).call(this).catch(txe)
    })
  }
  get current() {
    return g(tr(this, bl))
  }
  get pending() {
    return tr(this, qs).pending
  }
  cancel() {
    tr(this, qs).cancel()
  }
  updateImmediately() {
    return tr(this, qs).runScheduledNow()
  }
  setImmediately(s) {
    this.cancel(), G(tr(this, bl), s, !0)
  }
}
bl = new WeakMap, qs = new WeakMap;
var nxe = se('<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>'),
  ixe = se('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  axe = se('<span class="font-flag tooltip ml-0.5"> </span>'),
  oxe = se("<button><!></button>"),
  sxe = se('<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>'),
  lxe = se('<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>'),
  cxe = se('<div><!> <div class="mt-4"><!></div></div>');

function uxe(d, s) {
  Qr(s, !0);
  let r = sr(s, "reload", 15),
    x = We(!0),
    A = We([]),
    E = We(0),
    k = We("today"),
    l = {};
  r(j);

  function j() {
    const Z = g(k);
    pn.allianceLeaderboard(Z).then(de => {
      G(A, de), l = {
        [Z]: de
      }, G(x, !1)
    }).catch(de => {
      rr.error(de.message)
    })
  }
  fs(() => [g(k)], () => {
    const Z = g(k),
      de = l[Z];
    if (de) {
      G(A, de), G(x, !1);
      return
    }
    G(x, !0), pn.allianceLeaderboard(Z).then(Fe => {
      G(A, Fe), l[Z] = Fe, G(x, !1)
    }).catch(Fe => {
      rr.error(Fe.message)
    })
  });
  var W = cxe(),
    $ = S(W);
  vm($, {
    get value() {
      return g(k)
    },
    set value(Z) {
      G(k, Z, !0)
    }
  });
  var J = L($, 2),
    ce = S(J);
  {
    var ge = Z => {
        var de = nxe();
        O(Z, de)
      },
      fe = Z => {
        var de = Ir(),
          Fe = Pt(de);
        {
          var Re = Ge => {
              var et = ixe(),
                Ve = S(et),
                ve = L(Ve);
              {
                var Me = Ce => {
                    var Oe = vi();
                    ze(ut => ee(Oe, ut), [() => qp().toLowerCase()]), O(Ce, Oe)
                  },
                  Ye = Ce => {
                    var Oe = Ir(),
                      ut = Pt(Oe);
                    {
                      var Ue = St => {
                          var Ft = vi();
                          ze(Jt => ee(Ft, Jt), [() => hm()]), O(St, Ft)
                        },
                        Ke = St => {
                          var Ft = Ir(),
                            Jt = Pt(Ft);
                          {
                            var Mt = ct => {
                              var wt = vi();
                              ze(ft => ee(wt, ft), [() => um()]), O(ct, wt)
                            };
                            we(Jt, ct => {
                              g(k) === "month" && ct(Mt)
                            }, !0)
                          }
                          O(St, Ft)
                        };
                      we(ut, St => {
                        g(k) === "week" ? St(Ue) : St(Ke, !1)
                      }, !0)
                    }
                    O(Ce, Oe)
                  };
                we(ve, Ce => {
                  g(k) === "today" ? Ce(Me) : Ce(Ye, !1)
                })
              }
              P(et), ze(Ce => ee(Ve, `${Ce??""} `), [() => cm()]), O(Ge, et)
            },
            Pe = Ge => {
              var et = lxe(),
                Ve = S(et),
                ve = S(Ve),
                Me = L(S(ve)),
                Ye = S(Me, !0);
              P(Me);
              var Ce = L(Me),
                Oe = S(Ce, !0);
              P(Ce), P(ve), P(Ve);
              var ut = L(Ve);
              li(ut, 31, () => g(A), Ue => Ue.userId, (Ue, Ke, St) => {
                const Ft = xt(() => {
                  var yt;
                  return ((yt = Rt.data) == null ? void 0 : yt.id) === g(Ke).userId
                });
                var Jt = sxe();
                let Mt;
                var ct = S(Jt),
                  wt = S(ct, !0);
                P(ct);
                var ft = L(ct),
                  $t = S(ft),
                  Et = S($t);
                Fa(Et, {
                  class: "size-10 border",
                  get userId() {
                    return g(Ke).userId
                  },
                  get pictureUrl() {
                    return g(Ke).picture
                  }
                });
                var Qt = L(Et, 2),
                  vr = S(Qt),
                  Kt = L(vr),
                  Bt = S(Kt);
                P(Kt), P(Qt);
                var it = L(Qt, 2);
                {
                  var He = yt => {
                    const bt = xt(() => qo(g(Ke).equippedFlag));
                    var Lt = axe(),
                      st = S(Lt, !0);
                    P(Lt), ze(() => {
                      or(Lt, "data-tip", g(bt).name), ee(st, g(bt).flag)
                    }), O(yt, Lt)
                  };
                  we(it, yt => {
                    g(Ke).equippedFlag && yt(He)
                  })
                }
                var Ot = L(it, 2);
                {
                  var Gt = yt => {
                    Nh(yt, {
                      get username() {
                        return g(Ke).discord
                      },
                      get id() {
                        return g(Ke).discordId
                      }
                    })
                  };
                  we(Ot, yt => {
                    g(Ke).discord && yt(Gt)
                  })
                }
                P($t), P(ft);
                var kt = L(ft),
                  nr = S(kt),
                  It = L(nr);
                {
                  var mt = yt => {
                    var bt = oxe();
                    let Lt;
                    bt.__click = () => {
                      s.onlastpixelclick({
                        lat: g(Ke).lastLatitude ?? 0,
                        lng: g(Ke).lastLongitude ?? 0
                      })
                    };
                    var st = S(bt);
                    wl(st, {
                      class: "size-4"
                    }), P(bt), ze(lr => {
                      Lt = Or(bt, 1, "btn btn-sm btn-ghost absolute -right-2 top-1/2 !-translate-y-1/2 sm:right-4", null, Lt, {
                        tooltip: g(E) > 640
                      }), or(bt, "data-tip", lr)
                    }, [() => U1()]), O(yt, bt)
                  };
                  we(It, yt => {
                    g(Ke).lastLatitude && g(Ke).lastLongitude && yt(mt)
                  })
                }
                P(kt), P(Jt), ze((yt, bt) => {
                  var Lt;
                  Mt = Or(Jt, 1, "", null, Mt, {
                    "bg-base-200": g(Ft)
                  }), ee(wt, g(St) + 1), Or(Qt, 1, `font-semibold ${yt??""} flex gap-1`), ee(vr, `${(g(Ft)?((Lt=Rt.data)==null?void 0:Lt.name)??g(Ke).name:g(Ke).name)??""} `), ee(Bt, `#${g(Ke).userId??""}`), ee(nr, `${bt??""} `)
                }, [() => ta(g(Ke).userId), () => g(Ke).pixelsPainted.toLocaleString("en-US")]), vl(Jt, () => yl, () => ({
                  duration: 200
                })), O(Ue, Jt)
              }), P(ut), P(et), ze((Ue, Ke) => {
                ee(Ye, Ue), ee(Oe, Ke)
              }, [() => nm(), () => tm()]), O(Ge, et)
            };
          we(Fe, Ge => {
            g(A).length === 0 ? Ge(Re) : Ge(Pe, !1)
          }, !0)
        }
        O(Z, de)
      };
    we(ce, Z => {
      g(x) ? Z(ge) : Z(fe, !1)
    })
  }
  P(J), P(W), Fh("innerWidth", Z => G(E, Z, !0)), O(d, W), en()
}
Yn(["click"]);
var hxe = $r('<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>');

function ym(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = hxe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var dxe = se('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>'),
  pxe = se('<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>', 1),
  fxe = se('<li><button class="btn btn-ghost text-base-content/80"> </button></li>'),
  _xe = se('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>'),
  mxe = se('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  gxe = se('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>'),
  vxe = se('<div class="text-base-content/80 mt-4 flex justify-center"> </div>'),
  yxe = se('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  xxe = se('<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>');

function bxe(d, s) {
  Qr(s, !0);
  let r = Pi({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    }),
    x = Pi({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    });
  var A = xxe(),
    E = S(A),
    k = S(E);
  k.__click = () => s.onclickback();
  var l = S(k);
  w0(l, {
    class: "size-5"
  }), P(k);
  var j = L(k, 2),
    W = S(j, !0);
  P(j), P(E);
  var $ = L(E, 2),
    J = S($);
  sa(J);
  var ce = L(J, 2),
    ge = S(ce),
    fe = S(ge);
  li(fe, 21, () => r.data, Ye => Ye.id, (Ye, Ce, Oe) => {
    const ut = xt(() => {
      var He;
      return ((He = Rt.data) == null ? void 0 : He.id) === g(Ce).id
    });
    var Ue = _xe(),
      Ke = S(Ue),
      St = S(Ke),
      Ft = S(St);
    Fa(Ft, {
      class: "size-10 border",
      get userId() {
        return g(Ce).id
      },
      get pictureUrl() {
        return g(Ce).picture
      }
    });
    var Jt = L(Ft, 2),
      Mt = S(Jt);
    P(Jt);
    var ct = L(Jt, 2);
    {
      var wt = He => {
        var Ot = dxe();
        O(He, Ot)
      };
      we(ct, He => {
        g(Ce).role === "admin" && He(wt)
      })
    }
    P(St), P(Ke);
    var ft = L(Ke),
      $t = S(ft),
      Et = S($t),
      Qt = S(Et);
    ym(Qt, {
      class: "size-4"
    }), P(Et);
    var vr = L(Et, 2),
      Kt = S(vr);
    {
      var Bt = He => {
          var Ot = pxe(),
            Gt = Pt(Ot),
            kt = S(Gt);
          kt.__click = async () => {
            try {
              g(Ce).loading = !0, await pn.giveAllianceAdmin(g(Ce).id), g(Ce).role = "admin"
            } catch {
              rr.error(VA())
            } finally {
              g(Ce).loading = !1
            }
          };
          var nr = S(kt, !0);
          P(kt), P(Gt);
          var It = L(Gt, 2),
            mt = S(It);
          mt.__click = async () => {
            try {
              g(Ce).loading = !0, await pn.banAllianceUser(g(Ce).id), r.data = r.data.filter(bt => bt.id !== g(Ce).id)
            } catch {
              rr.error(x6())
            } finally {
              g(Ce).loading = !1
            }
          };
          var yt = S(mt, !0);
          P(mt), P(It), ze((bt, Lt) => {
            kt.disabled = g(Ce).loading, ee(nr, bt), mt.disabled = g(Ce).loading, ee(yt, Lt)
          }, [() => CA(), () => E0()]), O(He, Ot)
        },
        it = He => {
          var Ot = fxe(),
            Gt = S(Ot);
          Gt.disabled = !0;
          var kt = S(Gt, !0);
          P(Gt), P(Ot), ze(nr => ee(kt, nr), [() => kF()]), O(He, Ot)
        };
      we(Kt, He => {
        g(Ce).role === "member" ? He(Bt) : He(it, !1)
      })
    }
    P(vr), P($t), P(ft), P(Ue), ze(He => {
      var Ot;
      Or(Jt, 1, `font-semibold ${He??""}`), ee(Mt, `${(g(ut)?((Ot=Rt.data)==null?void 0:Ot.name)??g(Ce).name:g(Ce).name)??""} #${g(Ce).id??""}`)
    }, [() => ta(g(Ce).id)]), O(Ye, Ue)
  }), P(fe), P(ge);
  var Z = L(ge, 2);
  {
    var de = Ye => {
      var Ce = Ir(),
        Oe = Pt(Ce);
      kl(Oe, () => r.page, ut => {
        var Ue = mxe();
        Li(Ue, () => Ke => {
          const St = new IntersectionObserver(Ft => {
            Ft[0].isIntersecting && !r.loading && (r.loading = !0, pn.getAllianceMembers(r.page).then(Jt => {
              r.data = [...r.data, ...Jt.data], r.hasNextPage = Jt.hasNext, r.page++
            }).catch(Jt => {
              rr.error(Jt.message)
            }).finally(() => {
              r.loading = !1
            }))
          });
          return St.observe(Ke), () => {
            St.disconnect()
          }
        }), O(ut, Ue)
      }), O(Ye, Ce)
    };
    we(Z, Ye => {
      r.hasNextPage && Ye(de)
    })
  }
  P(ce);
  var Fe = L(ce, 2),
    Re = L(Fe, 2),
    Pe = S(Re),
    Ge = S(Pe);
  li(Ge, 21, () => x.data, Ye => Ye.id, (Ye, Ce, Oe) => {
    var ut = gxe(),
      Ue = S(ut),
      Ke = S(Ue),
      St = S(Ke);
    Fa(St, {
      class: "size-10 border",
      get userId() {
        return g(Ce).id
      },
      get pictureUrl() {
        return g(Ce).picture
      }
    });
    var Ft = L(St, 2),
      Jt = S(Ft);
    P(Ft), P(Ke), P(Ue);
    var Mt = L(Ue),
      ct = S(Mt);
    ct.__click = () => {
      pn.unbanAllianceUser(g(Ce).id).then(() => {
        x.data = x.data.filter(ft => ft.id !== g(Ce).id)
      }).catch(ft => rr.error(ft.message)).finally(() => {
        g(Ce).loading = !1
      })
    };
    var wt = S(ct, !0);
    P(ct), P(Mt), P(ut), ze((ft, $t) => {
      Or(Ft, 1, `font-semibold ${ft??""}`), ee(Jt, `${g(Ce).name??""} #${g(Ce).id??""}`), ct.disabled = g(Ce).loading, ee(wt, $t)
    }, [() => ta(g(Ce).id), () => Z1()]), O(Ye, ut)
  }), P(Ge), P(Pe);
  var et = L(Pe, 2);
  {
    var Ve = Ye => {
      var Ce = vxe(),
        Oe = S(Ce, !0);
      P(Ce), ze(ut => ee(Oe, ut), [() => jF()]), O(Ye, Ce)
    };
    we(et, Ye => {
      !x.hasNextPage && x.data.length === 0 && Ye(Ve)
    })
  }
  var ve = L(et, 2);
  {
    var Me = Ye => {
      var Ce = Ir(),
        Oe = Pt(Ce);
      kl(Oe, () => x.page, ut => {
        var Ue = yxe();
        Li(Ue, () => Ke => {
          const St = new IntersectionObserver(Ft => {
            Ft[0].isIntersecting && !x.loading && (x.loading = !0, pn.getAllianceBannedMembers(x.page).then(Jt => {
              x.data = [...x.data, ...Jt.data], x.hasNextPage = Jt.hasNext, x.page++
            }).catch(Jt => {
              rr.error(Jt.message)
            }).finally(() => {
              x.loading = !1
            }))
          });
          return St.observe(Ke), () => {
            St.disconnect()
          }
        }), O(ut, Ue)
      }), O(Ye, Ce)
    };
    we(ve, Ye => {
      x.hasNextPage && Ye(Me)
    })
  }
  P(Re), P($), P(A), ze((Ye, Ce, Oe) => {
    ee(W, Ye), or(J, "aria-label", Ce), or(Fe, "aria-label", Oe)
  }, [() => b0(), () => G1(), () => im()]), O(d, A), en()
}
Yn(["click"]);
var wxe = se('<span class="label"> </span>'),
  kxe = se('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>'),
  Txe = se('<p class="text-error ml-3 text-sm"> </p>'),
  Pxe = se('<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>');

function w_(d, s) {
  Qr(s, !0);
  let r = sr(s, "value", 15),
    x = sr(s, "validate", 15),
    A = We("");
  const E = xt(() => {
    var Fe;
    return ((Fe = r()) == null ? void 0 : Fe.length) ?? 0
  });
  x(k);

  function k() {
    return s.min !== void 0 && g(E) < s.min ? (G(A, g(E) === 0 ? "Required" : `Min. characters: ${s.min}`, !0), !1) : s.max !== void 0 && g(E) > s.max ? (G(A, `Max. characters: ${s.max}`), !1) : !0
  }
  rn(() => {
    var Fe;
    s.max !== void 0 && g(E) > s.max && r((Fe = r()) == null ? void 0 : Fe.substring(0, s.max))
  });
  var l = Pxe(),
    j = S(l);
  let W;
  var $ = S(j);
  {
    var J = Fe => {
      var Re = wxe(),
        Pe = S(Re, !0);
      P(Re), ze(() => ee(Pe, s.label)), O(Fe, Re)
    };
    we($, Fe => {
      s.label && Fe(J)
    })
  }
  var ce = L($, 2);
  sa(ce);
  var ge = L(ce, 2);
  {
    var fe = Fe => {
      var Re = kxe(),
        Pe = S(Re, !0);
      P(Re), ze(() => ee(Pe, s.max - g(E))), O(Fe, Re)
    };
    we(ge, Fe => {
      s.max !== void 0 && Fe(fe)
    })
  }
  P(j);
  var Z = L(j, 2);
  {
    var de = Fe => {
      var Re = Txe(),
        Pe = S(Re, !0);
      P(Re), ze(() => ee(Pe, g(A))), O(Fe, Re)
    };
    we(Z, Fe => {
      g(A) && Fe(de)
    })
  }
  P(l), ze(() => {
    W = Or(j, 1, "input w-full", null, W, {
      "input-error": !!g(A)
    }), or(ce, "placeholder", s.placeholder), or(ce, "maxlength", s.max)
  }), Oc(ce, r), O(d, l), en()
}
var Sxe = se('<dialog class="modal" closedby="any"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Mxe(d, s) {
  Qr(s, !0);
  let r = sr(s, "ref", 15),
    x = We(!1),
    A = We(""),
    E = We(void 0);
  var k = Sxe(),
    l = S(k),
    j = S(l),
    W = S(j, !0);
  P(j);
  var $ = L(j, 2),
    J = S($),
    ce = S(J);
  {
    let Re = xt(() => m_()),
      Pe = xt(() => Xw());
    w_(ce, {
      get label() {
        return g(Re)
      },
      get placeholder() {
        return g(Pe)
      },
      min: 1,
      max: 16,
      get value() {
        return g(A)
      },
      set value(Ge) {
        G(A, Ge, !0)
      },
      get validate() {
        return g(E)
      },
      set validate(Ge) {
        G(E, Ge, !0)
      }
    })
  }
  P(J);
  var ge = L(J, 2),
    fe = S(ge);
  fe.__click = () => {
    var Re;
    (Re = r()) == null || Re.close()
  };
  var Z = S(fe, !0);
  P(fe);
  var de = L(fe, 2),
    Fe = S(de, !0);
  P(de), P(ge), P($), P(l), bn(2), P(k), oo(k, Re => r(Re), () => r()), ze((Re, Pe, Ge) => {
    ee(W, Re), fe.disabled = g(x), ee(Z, Pe), de.disabled = g(x), ee(Fe, Ge)
  }, [() => t4(), () => Nc(), () => VS()]), Pn("submit", $, async () => {
    var Re, Pe;
    try {
      if (!((Re = g(E)) != null && Re())) return;
      G(x, !0);
      const {
        id: Ge
      } = await pn.createAlliance(g(A));
      await s.onsuccess(Ge), (Pe = r()) == null || Pe.close()
    } catch (Ge) {
      rr.error(Ge.message)
    } finally {
      G(x, !1)
    }
  }), O(d, k), en()
}
Yn(["click"]);
var Ixe = $r('<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');

function Cxe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Ixe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var Axe = $r('<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>');

function zxe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Axe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var Exe = $r('<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>');

function Lxe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Exe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var Dxe = $r('<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>');

function Np(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Dxe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}

function Rxe(d, s = "_blank") {
  return d.replaceAll(/https?:\/\/[^\s]+/g, r => `<a href="${r}"${s?` target="${s}"`:""}>${r}</a>`)
}
var jxe = se('<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>'),
  Fxe = se('<div class="tooltip"><button class="btn"><!></button></div>'),
  Bxe = se('<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>'),
  Oxe = se('<section class="text-base-content/80 highlight-link"><!> <!></section>'),
  qxe = se('<span class="font-semibold"> </span>'),
  Nxe = se('<button class="text-primary font-semibold underline"> </button>'),
  Vxe = se('<span class="text-primary underline"> </span>'),
  Uxe = se('<span class="text-primary underline"> </span>'),
  Zxe = se('<button class="text-base-content/80 p-1"><!></button>'),
  Gxe = se('<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>'),
  $xe = se('<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>', 1),
  Wxe = se('<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>', 1),
  Hxe = se('<div class="h-full"><!></div>');

function Xxe(d, s) {
  Qr(s, !0);
  let r = We(void 0),
    x = We(!0),
    A = We(void 0),
    E = We(!1),
    k = We(void 0),
    l = We(!1),
    j = We(!1),
    W = We(() => {});
  fs(() => s.open, () => {
    s.open && _p.shouldReload && $()
  }), Wi(() => {
    const Z = setInterval(() => {
      _p.shouldReload = !0
    }, 1e4);
    return () => {
      clearTimeout(Z)
    }
  });
  async function $() {
    try {
      G(r, await pn.getAlliance(), !0), g(r) && g(W)(), G(x, !1), _p.shouldReload = !1
    } catch (Z) {
      rr.error(Z.message)
    }
  }
  var J = Hxe(),
    ce = S(J);
  {
    var ge = Z => {
        var de = jxe();
        O(Z, de)
      },
      fe = Z => {
        var de = Ir(),
          Fe = Pt(de);
        {
          var Re = Ge => {
              bxe(Ge, {
                onclickback: () => G(j, !1)
              })
            },
            Pe = Ge => {
              var et = Ir(),
                Ve = Pt(et);
              {
                var ve = Ye => {
                    var Ce = $xe(),
                      Oe = Pt(Ce),
                      ut = S(Oe),
                      Ue = S(ut, !0);
                    P(ut);
                    var Ke = L(ut, 2),
                      St = S(Ke),
                      Ft = S(St),
                      Jt = S(Ft);
                    ym(Jt, {
                      class: "size-4"
                    }), P(Ft);
                    var Mt = L(Ft, 2),
                      ct = S(Mt),
                      wt = S(ct);
                    wt.__click = async () => {
                      try {
                        G(E, !0), await pn.leaveAlliance(), G(x, !0), await $()
                      } catch (Xt) {
                        rr.error(Xt.message)
                      } finally {
                        G(E, !1)
                      }
                    };
                    var ft = S(wt, !0);
                    P(wt), P(ct), P(Mt), P(St);
                    var $t = L(St, 2);
                    {
                      var Et = Xt => {
                        var ue = Fxe(),
                          N = S(ue);
                        N.__click = () => {
                          G(l, !0)
                        };
                        var q = S(N);
                        Lxe(q, {
                          class: "size-4"
                        }), P(N), P(ue), ze(X => or(ue, "data-tip", X), [() => jE()]), O(Xt, ue)
                      };
                      we($t, Xt => {
                        g(r).role == "admin" && Xt(Et)
                      })
                    }
                    P(Ke), P(Oe);
                    var Qt = L(Oe, 2);
                    {
                      var vr = Xt => {
                        var ue = Oxe(),
                          N = S(ue);
                        Fp(N, () => Rxe(g(r).description || R0()));
                        var q = L(N, 2);
                        {
                          var X = te => {
                            var le = Bxe();
                            le.__click = () => {
                              var je;
                              (je = g(k)) == null || je.show()
                            };
                            var xe = S(le);
                            p_(xe, {
                              class: "size-4"
                            }), P(le), O(te, le)
                          };
                          we(q, te => {
                            g(r).role === "admin" && te(X)
                          })
                        }
                        P(ue), O(Xt, ue)
                      };
                      we(Qt, Xt => {
                        (g(r).description || g(r).role === "admin") && Xt(vr)
                      })
                    }
                    var Kt = L(Qt, 2),
                      Bt = S(Kt),
                      it = S(Bt);
                    Pl(it, {
                      class: "inline size-4"
                    });
                    var He = L(it, 2),
                      Ot = S(He),
                      Gt = L(Ot),
                      kt = S(Gt, !0);
                    P(Gt), P(He), P(Bt);
                    var nr = L(Bt, 2),
                      It = S(nr);
                    Np(It, {
                      class: "inline size-4"
                    });
                    var mt = L(It, 2),
                      yt = S(mt),
                      bt = L(yt);
                    {
                      var Lt = Xt => {
                          var ue = qxe(),
                            N = S(ue, !0);
                          P(ue), ze(q => ee(N, q), [() => g(r).members.toLocaleString("en-US")]), O(Xt, ue)
                        },
                        st = Xt => {
                          var ue = Nxe();
                          ue.__click = () => G(j, !0);
                          var N = S(ue, !0);
                          P(ue), ze(q => ee(N, q), [() => g(r).members.toLocaleString("en-US")]), O(Xt, ue)
                        };
                      we(bt, Xt => {
                        g(r).role === "member" ? Xt(Lt) : Xt(st, !1)
                      })
                    }
                    P(mt), P(nr);
                    var lr = L(nr, 2);
                    {
                      var gr = Xt => {
                        var ue = Gxe(),
                          N = S(ue);
                        Cxe(N, {
                          class: "inline size-4"
                        });
                        var q = L(N, 2),
                          X = S(q),
                          te = L(X);
                        te.__click = () => {
                          var rt;
                          (rt = g(r)) != null && rt.hq ? s.onhqclick({
                            lat: g(r).hq.latitude,
                            lng: g(r).hq.longitude
                          }) : s.onhqchange()
                        };
                        var le = S(te);
                        {
                          var xe = rt => {
                              var Xe = Vxe(),
                                he = S(Xe);
                              P(Xe), ze((Q, Ze) => ee(he, `${Q??""}, ${Ze??""}`), [() => g(r).hq.latitude.toFixed(3), () => g(r).hq.longitude.toFixed(3)]), O(rt, Xe)
                            },
                            je = rt => {
                              var Xe = Uxe(),
                                he = S(Xe, !0);
                              P(Xe), ze(Q => ee(he, Q), [() => Pq()]), O(rt, Xe)
                            };
                          we(le, rt => {
                            g(r).hq ? rt(xe) : rt(je, !1)
                          })
                        }
                        P(te), P(q);
                        var Ie = L(q, 2);
                        {
                          var qe = rt => {
                            var Xe = Zxe();
                            Xe.__click = function(...Q) {
                              var Ze;
                              (Ze = s.onhqchange) == null || Ze.apply(this, Q)
                            };
                            var he = S(Xe);
                            p_(he, {
                              class: "text-base-content/50 size-4"
                            }), P(Xe), O(rt, Xe)
                          };
                          we(Ie, rt => {
                            g(r).role === "admin" && rt(qe)
                          })
                        }
                        P(ue), ze(rt => ee(X, `${rt??""}: `), [() => tz()]), O(Xt, ue)
                      };
                      we(lr, Xt => {
                        (g(r).hq || g(r).role === "admin") && Xt(gr)
                      })
                    }
                    P(Kt);
                    var dr = L(Kt, 2),
                      pr = S(dr),
                      Ht = S(pr, !0);
                    P(pr);
                    var Sr = L(pr, 2),
                      Rr = S(Sr);
                    uxe(Rr, {
                      get allianceId() {
                        return g(r).id
                      },
                      get onlastpixelclick() {
                        return s.onlastpixelclick
                      },
                      get reload() {
                        return g(W)
                      },
                      set reload(Xt) {
                        G(W, Xt, !0)
                      }
                    }), P(Sr), P(dr);
                    var Vt = L(dr, 2);
                    jye(Vt, {
                      get description() {
                        return g(r).description
                      },
                      onsuccess: async Xt => {
                        g(r) && (g(r).description = Xt)
                      },
                      get ref() {
                        return g(k)
                      },
                      set ref(Xt) {
                        G(k, Xt, !0)
                      }
                    });
                    var Tr = L(Vt, 2);
                    Oye(Tr, {
                      get open() {
                        return g(l)
                      },
                      set open(Xt) {
                        G(l, Xt, !0)
                      }
                    }), ze((Xt, ue, N, q, X) => {
                      ee(Ue, g(r).name), wt.disabled = g(E), ee(ft, Xt), ee(Ot, `${ue??""}: `), ee(kt, N), ee(yt, `${q??""}: `), ee(Ht, X)
                    }, [() => DL(), () => tm(), () => g(r).pixelsPainted.toLocaleString("en-US"), () => b0(), () => am()]), O(Ye, Ce)
                  },
                  Me = Ye => {
                    var Ce = Wxe(),
                      Oe = Pt(Ce),
                      ut = S(Oe),
                      Ue = S(ut);
                    P(ut);
                    var Ke = L(ut, 2),
                      St = S(Ke);
                    zxe(St, {
                      class: "size-5"
                    });
                    var Ft = L(St, 1, !0);
                    P(Ke);
                    var Jt = L(Ke, 2),
                      Mt = S(Jt),
                      ct = S(Mt, !0);
                    P(Mt), P(Jt);
                    var wt = L(Jt, 2);
                    wt.__click = () => {
                      var Qt;
                      (Qt = g(A)) == null || Qt.show()
                    };
                    var ft = S(wt);
                    p0(ft, {
                      class: "size-6"
                    });
                    var $t = L(ft);
                    P(wt), P(Oe);
                    var Et = L(Oe, 2);
                    Mxe(Et, {
                      onsuccess: $,
                      get ref() {
                        return g(A)
                      },
                      set ref(Qt) {
                        G(A, Qt, !0)
                      }
                    }), ze((Qt, vr, Kt, Bt) => {
                      ee(Ue, `${Qt??""}:`), ee(Ft, vr), ee(ct, Kt), ee($t, ` ${Bt??""}`)
                    }, [() => QO(), () => nA(), () => P2(), () => f4()]), O(Ye, Ce)
                  };
                we(Ve, Ye => {
                  g(r) ? Ye(ve) : Ye(Me, !1)
                }, !0)
              }
              O(Ge, et)
            };
          we(Fe, Ge => {
            g(j) ? Ge(Re) : Ge(Pe, !1)
          }, !0)
        }
        O(Z, de)
      };
    we(ce, Z => {
      g(x) ? Z(ge) : Z(fe, !1)
    })
  }
  P(J), O(d, J), en()
}
Yn(["click"]);
var Yxe = $r('<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>');

function Vp(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Yxe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var Kxe = se('<dialog class="modal" closedby="any"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Jxe(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15);
  var x = Kxe(),
    A = S(x),
    E = L(S(A), 2),
    k = S(E);
  Vp(k, {
    class: "size-5 max-sm:size-6"
  });
  var l = L(k, 2),
    j = S(l, !0);
  P(l), P(E);
  var W = L(E, 2),
    $ = S(W);
  Xxe($, {
    get open() {
      return r()
    },
    get onhqchange() {
      return s.onhqchange
    },
    get onhqclick() {
      return s.onhqclick
    },
    get onlastpixelclick() {
      return s.onlastpixelclick
    }
  }), P(W), P(A), bn(2), P(x), Li(x, () => J => {
    rn(() => {
      r() ? (J.show(), xi.url.searchParams.get("alliance") && (xi.url.searchParams.delete("alliance"), bp(xi.url.toString()))) : J.close()
    })
  }), ze(J => ee(j, J), [() => Bp()]), Pn("close", x, () => r(!1)), oa(2, W, () => Ka, () => ({
    duration: 300
  })), O(d, x), en()
}

function Qxe(d, s, r) {
  return new Promise((x, A) => {
    d.once("render", () => {
      const E = d.getCanvas().toDataURL(),
        k = document.createElement("img");
      k.src = E, k.onload = () => {
        const l = document.createElement("canvas");
        l.width = k.width, l.height = k.height;
        const j = l.getContext("2d");
        if (j) {
          j.drawImage(k, 0, 0);
          const [W, $, J, ce] = j.getImageData(s, r, 1, 1).data;
          x([W, $, J, ce])
        } else A(new Error("Could not get 2d context from canvas"));
        k.remove(), l.remove()
      }
    }), d.triggerRepaint()
  })
}

function Ip(d, s) {
  return new Promise((r, x) => {
    d.once("render", () => {
      const A = d.getCanvas();
      let E = A;
      if (s != null && s.maxWidth || s != null && s.maxHeight) {
        const k = A.width,
          l = A.height,
          j = (s == null ? void 0 : s.maxWidth) ?? k,
          W = (s == null ? void 0 : s.maxHeight) ?? l;
        E = document.createElement("canvas");
        const $ = Math.min(j / k, W / l);
        E.width = Math.floor(k * $), E.height = Math.floor(l * $);
        const J = E.getContext("2d");
        J && J.drawImage(A, 0, 0, E.width, E.height)
      }
      try {
        E.toBlob(k => {
          k && r(k)
        }, (s == null ? void 0 : s.type) ?? "image/png", (s == null ? void 0 : s.quality) ?? 1)
      } catch (k) {
        x(k)
      } finally {
        E !== A && E.remove()
      }
    })
  })
}
var ebe = $r('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>');

function tbe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = ebe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var rbe = $r('<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>');

function dy(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = rbe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
const _l = {
  hour: 3600 * 1e3,
  min: 60 * 1e3,
  sec: 1e3
};

function py(d) {
  const s = Math.floor(d / _l.hour);
  d -= s * _l.hour;
  const r = Math.floor(d / _l.min);
  d -= r * _l.min;
  const A = Math.floor(d / _l.sec).toString().padStart(2, "0");
  return s > 0 ? `${s}:${r.toString().padStart(2,"0")}:${A}` : `${r}:${A}`
}

function nbe(d) {
  const s = d.getFullYear(),
    r = String(d.getMonth() + 1).padStart(2, "0"),
    x = String(d.getDate()).padStart(2, "0"),
    A = String(d.getHours()).padStart(2, "0"),
    E = String(d.getMinutes()).padStart(2, "0"),
    k = String(d.getSeconds()).padStart(2, "0");
  return `${s}-${r}-${x} ${A}:${E}:${k}`
}
var ibe = se('<div class="text-base-content/80 mt-2 text-xs"><span class="font-semibold"> </span> </div>'),
  abe = se('<img class="border-base-content/20 border" alt="Screenshot"/>'),
  obe = se('<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>'),
  sbe = se('<div><h3 class="mb-1 mt-4 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>'),
  lbe = se('<dialog class="modal" closedby="any"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function cbe(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = We(!1),
    A = We(null),
    E = We("");
  const k = xt(() => {
    const Ve = new URL(s.url.toString()),
      ve = Ve.searchParams.get("lat"),
      Me = Ve.searchParams.get("lng");
    if (ve && Me) return {
      lat: parseFloat(ve),
      lng: parseFloat(Me)
    }
  });
  rn(() => {
    r() ? (s.hideHover(), setTimeout(async () => {
      Ip(s.map).then(Ve => {
        G(A, Ve, !0), G(E, URL.createObjectURL(g(A)), !0)
      }).finally(() => {
        s.showHover()
      })
    }, 500)) : g(E) && (URL.revokeObjectURL(g(E)), G(A, null), G(E, ""))
  });
  var l = lbe(),
    j = S(l),
    W = L(S(j), 2),
    $ = S(W);
  dy($, {
    class: "size-5"
  });
  var J = L($);
  P(W);
  var ce = L(W, 2),
    ge = S(ce);
  sa(ge);
  var fe = L(ge, 2),
    Z = S(fe);
  let de;
  Z.__click = () => {
    navigator.clipboard.writeText(s.url.toString()), G(x, !0), setTimeout(() => {
      G(x, !1)
    }, 1e3)
  };
  var Fe = S(Z, !0);
  P(Z), P(fe), P(ce);
  var Re = L(ce, 2);
  {
    var Pe = Ve => {
      var ve = ibe(),
        Me = S(ve),
        Ye = S(Me);
      P(Me);
      var Ce = L(Me);
      P(ve), ze(Oe => {
        ee(Ye, `${Oe??""}:`), ee(Ce, ` ${g(k).lat??""}, ${g(k).lng??""}`)
      }, [() => D0()]), O(Ve, ve)
    };
    we(Re, Ve => {
      g(k) && Ve(Pe)
    })
  }
  var Ge = L(Re, 2);
  {
    var et = Ve => {
      const ve = xt(() => {
        var $t;
        return ($t = s.map) == null ? void 0 : $t.getCanvas()
      });
      var Me = sbe(),
        Ye = S(Me),
        Ce = S(Ye);
      tbe(Ce, {
        class: "inline size-5"
      });
      var Oe = L(Ce);
      P(Ye);
      var ut = L(Ye, 2);
      {
        var Ue = $t => {
            var Et = abe();
            ze(() => {
              or(Et, "src", g(E)), or(Et, "width", g(ve).width), or(Et, "height", g(ve).height)
            }), O($t, Et)
          },
          Ke = $t => {
            var Et = obe();
            ze(() => Io(Et, `aspect-ratio: ${g(ve).width/g(ve).height}`)), O($t, Et)
          };
        we(ut, $t => {
          g(E) ? $t(Ue) : $t(Ke, !1)
        })
      }
      var St = L(ut, 2),
        Ft = S(St);
      Ft.__click = async () => {
        g(A) && (await navigator.clipboard.write([new ClipboardItem({
          "image/png": g(A)
        })]), rr.info(P8()))
      };
      var Jt = S(Ft);
      om(Jt, {
        class: "size-5"
      });
      var Mt = L(Jt);
      P(Ft);
      var ct = L(Ft, 2),
        wt = S(ct);
      rm(wt, {
        class: "size-5"
      });
      var ft = L(wt);
      P(ct), P(St), P(Me), ze(($t, Et, Qt, vr) => {
        ee(Oe, ` ${$t??""}`), ee(Mt, ` ${Et??""}`), or(ct, "href", g(E)), or(ct, "download", `wplace_${Qt??""}.png`), ee(ft, ` ${vr??""}`)
      }, [() => d8(), () => d_(), () => nbe(new Date).replaceAll(" ", "_").replaceAll(":", "-"), () => wI()]), oa(2, Me, () => Ka, () => ({
        duration: 300
      })), O(Ve, Me)
    };
    we(Ge, Ve => {
      r() && Ve(et)
    })
  }
  P(j), bn(2), P(l), Li(l, () => Ve => {
    rn(() => {
      r() ? Ve.show() : Ve.close()
    })
  }), ze((Ve, ve, Me) => {
    ee(J, ` ${Ve??""}`), K_(ge, ve), de = Or(Z, 1, "btn btn-primary", null, de, {
      "btn-success": g(x)
    }), ee(Fe, Me)
  }, [() => RY(), () => s.url.toString(), () => g(x) ? sm() : d_()]), Pn("close", l, () => r(!1)), O(d, l), en()
}
Yn(["click"]);
const fy = [{
  id: 1,
  name: Zpe(),
  reward: nfe(),
  image: "/img/frame.png",
  chance: .03,
  rarity: "legendary",
  color: "border-sky-400"
}, {
  id: 2,
  name: mfe(),
  reward: Cfe(),
  image: "/img/coal.png",
  chance: .04,
  rarity: "epic",
  color: "border-purple-400"
}, {
  id: 3,
  name: Vfe(),
  reward: t_e(),
  image: "/img/2_presents.png",
  chance: .05,
  rarity: "epic",
  color: "border-slate-400"
}, {
  id: 4,
  name: f_e(),
  reward: z0({
    amount: 300
  }),
  image: "/img/Paint_Charges.png",
  chance: .09,
  rarity: "rare",
  color: "border-red-400"
}, {
  id: 5,
  name: M_e(),
  reward: A0({
    amount: 30
  }),
  image: "/img/auto_recharge.png",
  chance: .09,
  rarity: "rare",
  color: "border-amber-400"
}, {
  id: 6,
  name: kc(),
  reward: `10,000 ${kc()}`,
  image: "/img/10k.png",
  chance: .06,
  rarity: "rare",
  color: "border-sky-300"
}, {
  id: 7,
  name: kc(),
  reward: `5,000 ${kc()}`,
  image: "/img/5k.png",
  chance: .15,
  rarity: "common",
  color: "border-green-400"
}, {
  id: 8,
  name: kc(),
  reward: `1,000 ${kc()}`,
  image: "/img/1k.png",
  chance: .45,
  rarity: "common",
  color: "border-pink-400"
}, {
  id: 9,
  name: M1(),
  reward: q_e(),
  image: "/img/flag.png",
  chance: .03,
  rarity: "legendary",
  color: "border-sky-400"
}];

function ube(d) {
  return fy.find(s => s.id === d)
}
var hbe = se('<div class="flex items-center justify-center py-16"><span class="loading loading-spinner loading-lg text-primary"></span></div>'),
  dbe = se('<div class="flex flex-col items-center justify-center gap-2 px-4 py-16"><p class="text-base-content/80 text-center text-sm">Nenhum item configurado para este evento de Natal ainda.</p></div>'),
  pbe = se('<div class="pointer-events-none absolute inset-0 animate-pulse rounded-xl ring-4 ring-amber-300 ring-offset-2 ring-offset-amber-100"></div>'),
  fbe = se('<div><div><img class="absolute inset-0 h-full w-full object-cover"/> <!></div> <div class="flex h-[60px] flex-col items-center justify-center text-center"><p class="w-[100px] truncate text-xs font-semibold"> </p> <p class="text-base-content/70 w-[100px] truncate text-[11px]"> </p></div></div>'),
  _be = se('<div class="mt-4 flex flex-col items-center gap-3"><p class="text-base-content/90 text-center text-sm"> </p> <div class="bg-base-200 flex items-center gap-3 rounded-xl border border-amber-300/70 px-4 py-3 shadow-md"><div><img class="absolute inset-0 h-full w-full object-cover"/></div> <div><p class="text-sm font-semibold"> </p> <p class="text-base-content/70 text-xs"> </p></div></div></div>'),
  mbe = se('<span class="loading loading-spinner loading-xs"></span>'),
  gbe = se('<button class="btn btn-primary"><!></button>'),
  vbe = se('<span class="loading loading-spinner loading-xs"></span> ', 1),
  ybe = se('<button class="btn btn-primary"><!></button>'),
  xbe = se(`<div class="flex flex-col gap-4 px-6 pb-6"><div class="relative mx-auto mt-4 w-full"><div class="pointer-events-none absolute left-1/2 top-0 z-20 h-full w-1 -translate-x-1/2
           				border-x border-yellow-500/80 bg-yellow-400
           				shadow-[0_0_15px_rgba(250,204,21,1)]"></div> <div class="border-base-content/10 bg-base-200/60 overflow-hidden rounded-xl border backdrop-blur-sm"><div class="flex select-none items-center py-4 will-change-transform"></div></div></div> <!> <div class="mt-2 flex items-center justify-between gap-3"><div class="text-base-content/60 text-xs"><!></div> <div class="flex gap-2"><button class="btn btn-soft" type="button"> </button> <!></div></div></div>`),
  bbe = se('<dialog class="modal"><div class="modal-box max-h-11/12 w-11/12 max-w-3xl overflow-hidden p-0"><div class="flex items-center gap-3 px-6 pb-2 pt-6"><div class="flex items-center justify-center rounded-full bg-white/10 p-2"><span class="text-3xl">ğŸ</span></div> <div><h3 class="text-2xl font-bold"> </h3> <p class="text-sm opacity-90"> </p></div> <form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2 z-10">âœ•</button></form></div> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function _y(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = We(!0),
    A = We(!1),
    E = We(!1),
    k = We(0),
    l = We(Pi([])),
    j = We(!1),
    W = We(0),
    $ = We(null),
    J = We(!1);
  const ce = 120,
    ge = 16,
    fe = ce + ge;
  let Z = We(0),
    de = We(Pi([]));
  rn(() => {
    G(de, g(l).length ? Array(10).fill(null).flatMap(() => g(l)) : [], !0)
  }), rn(() => {
    r() ? Fe() : Re()
  });
  async function Fe() {
    if (r()) {
      G(x, !0);
      try {
        const wt = await pn.getChristmasCase();
        G(l, fy, !0), G(k, wt.presents ?? 0, !0), G(W, 0), G($, null), G(J, !1)
      } catch (wt) {
        console.error(wt), rr.error(wt.message ?? "Erro ao carregar evento de Natal.")
      } finally {
        G(x, !1)
      }
    }
  }

  function Re() {
    G(j, !1), G(W, 0), G($, null), G(J, !1), G(A, !1), G(E, !1)
  }

  function Pe(wt) {
    return g(l).find(ft => ft.id === wt) ?? ube(wt)
  }
  async function Ge() {
    if (!(g(A) || g(j) || g(k) <= 0)) {
      if (!g(l).length) {
        rr.error("Nenhum item configurado.");
        return
      }
      G(A, !0), gi.cristmasRoulette1.play();
      try {
        const {
          rewardItemId: wt,
          remainingPresents: ft
        } = await pn.postChristmasCaseOpen();
        if (G(k, ft, !0), !Pe(wt)) throw new Error("Item de recompensa invÃ¡lido.");
        const Et = g(l).findIndex(It => It.id === wt);
        if (Et === -1) throw new Error("Item nÃ£o encontrado na lista.");
        if (!g(de).length) throw new Error("Lista estendida nÃ£o inicializada.");
        const Qt = Math.floor(g(de).length / g(l).length),
          Kt = Math.floor(Qt * .7) * g(l).length + Et,
          Bt = .03,
          it = ce * Bt,
          He = ce * (1 - Bt),
          Ot = Math.random() * (He - it) + it,
          Gt = Kt * fe + ge / 2 + Ot,
          kt = g(Z) / 2,
          nr = -(Gt - kt);
        G(W, 0), G(j, !0), G(J, !1), G($, null), requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            G(W, nr)
          })
        }), setTimeout(() => {
          G(j, !1), G($, wt, !0), G(J, !0)
        }, 3200)
      } catch (wt) {
        console.error(wt), rr.error(wt.message ?? "Erro ao abrir presente."), G(j, !1)
      } finally {
        G(A, !1)
      }
    }
  }
  async function et() {
    !g($) || g(E) || (G(E, !0), G(W, 0), G($, null), G(J, !1), await Rt.refresh(), g($) == 3 && G(k, g(k) + 2), rr.success(Q_e()), G(E, !1))
  }
  var Ve = bbe(),
    ve = S(Ve),
    Me = S(ve),
    Ye = L(S(Me), 2),
    Ce = S(Ye),
    Oe = S(Ce, !0);
  P(Ce);
  var ut = L(Ce, 2),
    Ue = S(ut, !0);
  P(ut), P(Ye), bn(2), P(Me);
  var Ke = L(Me, 2);
  {
    var St = wt => {
        var ft = hbe();
        O(wt, ft)
      },
      Ft = wt => {
        var ft = Ir(),
          $t = Pt(ft);
        {
          var Et = vr => {
              var Kt = dbe();
              O(vr, Kt)
            },
            Qt = vr => {
              var Kt = xbe(),
                Bt = S(Kt),
                it = L(S(Bt), 2),
                He = S(it);
              li(He, 21, () => g(de), Bc, (pr, Ht) => {
                var Sr = fbe();
                let Rr;
                var Vt = S(Sr),
                  Tr = S(Vt),
                  Xt = L(Tr, 2);
                {
                  var ue = xe => {
                    var je = pbe();
                    O(xe, je)
                  };
                  we(Xt, xe => {
                    g($) === g(Ht).id && g(J) && xe(ue)
                  })
                }
                P(Vt);
                var N = L(Vt, 2),
                  q = S(N),
                  X = S(q, !0);
                P(q);
                var te = L(q, 2),
                  le = S(te, !0);
                P(te), P(N), P(Sr), ze(() => {
                  Rr = Or(Sr, 1, "bg-base-100 mx-2 flex h-[170px] w-[120px] shrink-0 flex-col items-center justify-between gap-2 rounded-xl border px-2 py-3 shadow-sm transition-transform svelte-eff8k6", null, Rr, {
                    selected: g($) === g(Ht).id && g(J)
                  }), Or(Vt, 1, `relative h-20 w-20 overflow-hidden rounded-xl border-2 ${g(Ht).color}`, "svelte-eff8k6"), or(Tr, "src", g(Ht).image), or(Tr, "alt", g(Ht).name), ee(X, g(Ht).name), ee(le, g(Ht).reward)
                }), O(pr, Sr)
              }), P(He), P(it), P(Bt);
              var Ot = L(Bt, 2);
              {
                var Gt = pr => {
                  var Ht = Ir(),
                    Sr = Pt(Ht);
                  kl(Sr, () => g($), Rr => {
                    const Vt = xt(() => Pe(g($)));
                    var Tr = Ir(),
                      Xt = Pt(Tr);
                    {
                      var ue = N => {
                        var q = _be(),
                          X = S(q),
                          te = S(X, !0);
                        P(X);
                        var le = L(X, 2),
                          xe = S(le),
                          je = S(xe);
                        P(xe);
                        var Ie = L(xe, 2),
                          qe = S(Ie),
                          rt = S(qe, !0);
                        P(qe);
                        var Xe = L(qe, 2),
                          he = S(Xe, !0);
                        P(Xe), P(Ie), P(le), P(q), ze(Q => {
                          ee(te, Q), Or(xe, 1, `relative h-14 w-14 overflow-hidden rounded-xl border-2 ${g(Vt).color}`, "svelte-eff8k6"), or(je, "src", g(Vt).image), or(je, "alt", g(Vt).name), ee(rt, g(Vt).name), ee(he, g(Vt).reward)
                        }, [() => Pme()]), oa(1, le, () => $1, () => ({
                          y: 10,
                          duration: 200
                        })), oa(1, q, () => Ka, () => ({
                          duration: 200
                        })), O(N, q)
                      };
                      we(Xt, N => {
                        g(Vt) && N(ue)
                      })
                    }
                    O(Rr, Tr)
                  }), O(pr, Ht)
                };
                we(Ot, pr => {
                  g(J) && g($) && pr(Gt)
                })
              }
              var kt = L(Ot, 2),
                nr = S(kt),
                It = S(nr);
              {
                var mt = pr => {
                    var Ht = vi();
                    ze(Sr => ee(Ht, Sr), [() => cge({
                      count: g(k)
                    })]), O(pr, Ht)
                  },
                  yt = pr => {
                    var Ht = vi();
                    ze(Sr => ee(Ht, Sr), [() => Av()]), O(pr, Ht)
                  };
                we(It, pr => {
                  g(k) > 0 ? pr(mt) : pr(yt, !1)
                })
              }
              P(nr);
              var bt = L(nr, 2),
                Lt = S(bt);
              Lt.__click = () => {
                r(!1)
              };
              var st = S(Lt, !0);
              P(Lt);
              var lr = L(Lt, 2);
              {
                var gr = pr => {
                    var Ht = gbe();
                    Ht.__click = et;
                    var Sr = S(Ht);
                    {
                      var Rr = Tr => {
                          var Xt = mbe();
                          O(Tr, Xt)
                        },
                        Vt = Tr => {
                          var Xt = vi();
                          ze(ue => ee(Xt, ue), [() => L0()]), O(Tr, Xt)
                        };
                      we(Sr, Tr => {
                        g(E) ? Tr(Rr) : Tr(Vt, !1)
                      })
                    }
                    P(Ht), ze(() => Ht.disabled = g(E)), O(pr, Ht)
                  },
                  dr = pr => {
                    var Ht = ybe();
                    Ht.__click = Ge;
                    var Sr = S(Ht);
                    {
                      var Rr = Tr => {
                          var Xt = vbe(),
                            ue = L(Pt(Xt));
                          ze(N => ee(ue, ` ${N??""}`), [() => Yme()]), O(Tr, Xt)
                        },
                        Vt = Tr => {
                          var Xt = Ir(),
                            ue = Pt(Xt);
                          {
                            var N = X => {
                                var te = vi();
                                ze(le => ee(te, le), [() => Av()]), O(X, te)
                              },
                              q = X => {
                                var te = vi();
                                ze(le => ee(te, `${le??""} (${g(k)??""})`), [() => U0()]), O(X, te)
                              };
                            we(ue, X => {
                              g(k) <= 0 ? X(N) : X(q, !1)
                            }, !0)
                          }
                          O(Tr, Xt)
                        };
                      we(Sr, Tr => {
                        g(A) || g(j) ? Tr(Rr) : Tr(Vt, !1)
                      })
                    }
                    P(Ht), ze(() => Ht.disabled = g(A) || g(j) || g(k) <= 0), O(pr, Ht)
                  };
                we(lr, pr => {
                  g(J) && g($) ? pr(gr) : pr(dr, !1)
                })
              }
              P(bt), P(kt), P(Kt), ze(pr => {
                Io(He, `transform: translateX(${g(W)}px); transition: ${g(j)?"transform 3.2s cubic-bezier(0.15, 0.85, 0.35, 1.0)":"none"};`), ee(st, pr)
              }, [() => Ja()]), u2(it, "clientWidth", pr => G(Z, pr)), O(vr, Kt)
            };
          we($t, vr => {
            g(l).length ? vr(Qt, !1) : vr(Et)
          }, !0)
        }
        O(wt, ft)
      };
    we(Ke, wt => {
      g(x) ? wt(St) : wt(Ft, !1)
    })
  }
  P(ve);
  var Jt = L(ve, 2),
    Mt = S(Jt),
    ct = S(Mt, !0);
  P(Mt), P(Jt), P(Ve), Li(Ve, () => wt => {
    rn(() => {
      r() ? wt.show() : wt.close()
    })
  }), ze((wt, ft, $t) => {
    ee(Oe, wt), ee(Ue, ft), ee(ct, $t)
  }, [() => V0(), () => dme(), () => Ja()]), Pn("close", Ve, () => r(!1)), O(d, Ve), en()
}
Yn(["click"]);
const wbe = "" + new URL("../assets/christmas-map-2.CRfo7ex_.gif", import.meta.url).href,
  kbe = "" + new URL("../assets/christmas-map-3.CJ2nZvAv.gif", import.meta.url).href,
  Tbe = "" + new URL("../assets/christmas-map.DtoqUc9H.gif", import.meta.url).href,
  n_ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEQAAABHCAYAAAC+h+EcAAAGBUlEQVR4AezaoZMjRRTH8dkVp+AMlqIQSBSKf4AChcRgqcKDQZ5E4alCYDBIFBT/AAqFRFDUCQzmOHVm6U9XXuqldzKbyfQkK4aa377u16+73/tOJ5PkuB22/w4IbEAOcAzDBmQD0hBoutsJ2YA0BJrudkI2IA2BprudkA1IQ6DpbifkkQG5K/lkle51rzVPyEOF3n312rcD/fj+L9UWFOYUc71rLSB3Pzx9a/j3zXeqSnkKPRAQ77379kBlvFq+0hZXTL20j6kG9P6zBpA7ID56+mSf66tnXwSYehKciACxD7rfqFCBJWtmlXCgiul73fZdbqgw8pqvf/bx8N93P1WXgr5++fnwyW8f1n77B6Q4JWI/ffH3ACxFrPW0jRfbHUqvEyKxAxgSp4DxxvM/S/7D/qRMQREofle07l6xHsdu3N66XdQLyOBYR0ZAaLfJK5J/V4jmPQFlnAya8/OLV0OIL9bX7q1uQPKxziBywqApLHy///FXNKsNGBEDhjnWDq0JQxLdgFislYKyjHtfYCneT4ABQ/HiFc/qa4sNBey1wPQAUl/DcVdz4vF0UVj4WcWyIWDEgMXmtbTFU8QHlOj3tEuB1A9XkZDkKfqRuLvsPUHBMaZw4icxMRZxLImLsbCxtrnFV29KsYuvJUD2MDwqJU65MNnlo60w4s+xYsiJ4hejUNK2prZ5rZwc+xc/KFSa51/nArmLD1c+O9heUiRBipMSd1KMwti2uBxjnGJ+zNEPGbcHaZO9qbQXQTkHyP5klM3rBQrp7JLS3D8qv3z+ct82oLCw2gTKk2ffcA9OiQZ/iC8EhH0o3xg56Je5Z0OZC+QejLL5/pKQjkQjefb74Z9apHZInDZLimRDxrKsmWUvivhedg6QAxgelWNJSNJTw8uCvAeMKeZG0dHP1rxYw5oxZo9o97ZzgNzbewyKzxOKcNRN8B7QCoR8t8Udk3XMt2aGcix+qX8REJtnKGB4UnhiKMI4KSrkpQEGf5bT0Mp4XucSUBYDkXSGot9KUU4FZRhx9PmMkdgsAK0HMgsK8NpjeiiXsTnZdzvk3nT7ZurIRiKeFqQAUhAp2hMAhJDttFnjJFY/BEC0rRft2C/67JiPf45mn5ApKO3GHqMgUBTexujnsQwFgJA4oNlQAGAp/EvsbCASnoLivUJCbfJ8UwKFxNjDSclr5LaYUAtiKreYM2VnA7GYhE/duE3Y/CmBQvYIKMdgTK1z7thZQGwm4Qwlt41fWvansu/NTsXMv84GYqsWCt+Y5p6SufFAyGVs77m+RUBsJhEJafscwY7plCLF0Nj88MV7lL59SQ76PbQYiCRyQj5D8I1pqtipsbyWzyr6ASLvzb9UXYDMSULhrcz3Rkrax+RN1hgIpE3mkfZSrQYkH+1jSSqC8njbb9dZC0TksBqQfLRjs1NthvJr+SeIdp5xav09+qsBkZy7SV7v+g8pv5Qi9oP0T6J8a4GwNq0KxAZ0ChRf2E4FZ821dBEgkj8GxakAwziJvaYuBkSRCo5TEEdfn984hV/7Grodhstuq3gQnArSjwzAcGL0xbCnKuadGn8s7qInJJIAIQRCKMbPsXMBHtvjKkAiGSCiPWanvgqMxffwXRXIKQW0XwUeeGn4pnvKskdj5gKpPyP2Op5HsxoZ8MvZiLu6HoBUY079MxeIdd2FPRhwyMAcHXu5jPlbGABk7faX15wURmPPARILSSB08H8QRcBSGy8Xv5j5fXZsvZ4wrL8EiPmhm/juEo41rCeTdUEIlb6bUkyfqxeQmk3c0fYbah0884+1yPQGAhBkqJt6ArnxewX1Oi0BIlULACVX32ZPIDKTLGl30w5w93XHEuwNJPaoyacjHv5ZFggqk+p6xa5+rQVE4oqoAobjFHmc7uLr3DKHLeYy15pAcgX1c0t2tG0gfNlLMNqQi/QvBaQWsyu2tgHI2o05DVRjrvEHkEvtq9CDkwJCqCRhvJjrXpcEEpVWKEAUBwih0r3+dQ0gqn5UECQUuhaQ2P/R2Q1Ic0s2IBuQhkDT3U7IBqQh0HS3E7IBaQg03f8BAAD//wKRUiMAAAAGSURBVAMAb6AxvAjVKU4AAAAASUVORK5CYII=";
var Pbe = se("<div><!></div>");

function Ku(d, s) {
  Qr(s, !0);
  let r = Lr(s, ["$$slots", "$$events", "$$legacy", "children"]);
  var x = Pbe();
  Dr(x, () => ({
    ...r,
    class: `bg-base-200/50 border-base-content/10 rounded-lg border p-4 ${s.class??""}`
  }));
  var A = S(x);
  Ei(A, () => s.children), P(x), O(d, x), en()
}
var Sbe = $r('<svg><path d="M480-80q-75 0-140.5-28.5t-114-77q-48.5-48.5-77-114T120-440q0-75 28.5-140.5t77-114q48.5-48.5 114-77T480-800q75 0 140.5 28.5t114 77q48.5 48.5 77 114T840-440q0 75-28.5 140.5t-77 114q-48.5 48.5-114 77T480-80Zm0-360Zm112 168 56-56-128-128v-184h-80v216l152 152ZM224-866l56 56-170 170-56-56 170-170Zm512 0 170 170-56 56-170-170 56-56ZM480-160q117 0 198.5-81.5T760-440q0-117-81.5-198.5T480-720q-117 0-198.5 81.5T200-440q0 117 81.5 198.5T480-160Z"></path></svg>');

function Mbe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Sbe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var Ibe = $r('<svg><path d="M200-80q-33 0-56.5-23.5T120-160v-560q0-33 23.5-56.5T200-800h40v-80h80v80h320v-80h80v80h40q33 0 56.5 23.5T840-720v560q0 33-23.5 56.5T760-80H200Zm0-80h560v-400H200v400Zm0-480h560v-80H200v80Zm0 0v-80 80Z"></path></svg>');

function Cbe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Ibe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var Abe = $r('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm457-560 21-89-71-59 94-8 36-84 36 84 94 8-71 59 21 89-80-47-80 47ZM480-481Z"></path></svg>');

function Wv(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Abe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var zbe = se('<div class="bg-accent/10 rounded-lg p-2 max-sm:hidden"><!></div> <div><p class="text-base-content/80 text-sm font-semibold uppercase tracking-wide"> </p> <p class="text-foreground text-base font-bold"> </p> <p class="text-base-content/80 text-xs">00:00 AM (UTC)</p></div>', 1),
  Ebe = se('<div class="bg-warning/10 rounded-lg p-2 max-sm:hidden"><!></div> <div><p class="text-base-content/80 text-sm font-semibold uppercase tracking-wide"> </p> <p class="text-foreground text-base font-bold"> </p> <p class="text-base-content/80 text-xs">00:00 AM (UTC)</p></div>', 1),
  Lbe = se("<p> </p>"),
  Dbe = se('<h3 class="flex items-center gap-1 text-lg font-semibold"><img alt="Christmas present" class="pixelated inline size-7"/> <span class="mt-0.5"> </span></h3> <div class="text-base-content/80 mt-3 text-sm"> <span class="font-semibold"> </span></div> <div class="text-base-content/80 mt-0 text-sm"> <span class="font-semibold"> </span></div> <div class="text-base-content/70 mt-2 text-xs"> </div> <div class="bg-base-300 relative mt-3 h-3 w-full overflow-hidden rounded-full"><div class="bg-primary h-3 rounded-full transition-all"></div></div> <div class="text-base-content/80 mt-1 text-right text-xs"> </div>', 1),
  Rbe = se('<div class="relative"><img class="aspect-square rounded-lg border-0" alt="Christmas village 1"/> <button class="btn btn-primary btn-sm absolute bottom-1 right-1"><!> </button></div> <div class="relative"><img class="aspect-square rounded-lg border-0" alt="Christmas village 2"/> <button class="btn btn-primary btn-sm absolute bottom-1 right-1"><!> </button></div> <div class="relative"><img class="aspect-square rounded-lg border-0" alt="Christmas village 3"/> <button class="btn btn-primary btn-sm absolute bottom-1 right-1"><!> </button></div>', 1),
  jbe = se('<dialog class="modal"><div class="modal-box max-h-11/12 max-w-3xl max-sm:px-4"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2 z-10">âœ•</button></form> <div class="relative space-y-6"><div class="text-center"><div class="mb-2 flex items-center justify-center gap-2"><!> <div class="badge max-sm:badge-sm font-semibold"> </div> <!></div> <h1 class="text-primary font-pixel flex items-center justify-center gap-3 text-3xl md:text-4xl"><img alt="Christmas present" class="pixelated inline size-10 animate-pulse sm:size-12"/> <img alt="Christmas present" class="pixelated inline size-10 animate-pulse sm:size-12"/></h1></div></div> <div class="mt-6 grid grid-cols-2 gap-4"><!> <!></div> <!> <!> <section class="mt-4"><h3 class="text-lg font-semibold"> </h3> <!></section> <div class="mx-auto mt-4 flex flex-col gap-3"><button class="btn btn-primary w-full"> </button></div> <div class="mx-auto mt-3 flex flex-col gap-3"><form method="dialog"><button class="btn w-full"> </button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form> <!></dialog>');

function Fbe(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = We(0),
    A = We(500),
    E = We(0);

  function k() {
    G(E, g(E) + 1), G(A, g(A) + Math.round(g(A) * 1.25))
  }

  function l() {
    for (G(E, 0), G(A, 500); g(x) >= g(A);) k()
  }
  let j = We(!1);
  rn(() => {
    r() && (async () => {
      try {
        G(x, await pn.getUserPixelsPaintedToday(), !0), l()
      } catch (Bt) {
        G(x, 0), console.error("Failed to fetch paintedToday", Bt)
      }
    })()
  });
  var W = jbe(),
    $ = S(W),
    J = L(S($), 2),
    ce = S(J),
    ge = S(ce),
    fe = S(ge);
  Wv(fe, {
    class: "text-primary size-5 animate-pulse sm:size-6"
  });
  var Z = L(fe, 2),
    de = S(Z, !0);
  P(Z);
  var Fe = L(Z, 2);
  Wv(Fe, {
    class: "text-primary size-5 animate-pulse sm:size-6"
  }), P(ge);
  var Re = L(ge, 2),
    Pe = S(Re),
    Ge = L(Pe),
    et = L(Ge);
  P(Re), P(ce), P(J);
  var Ve = L(J, 2),
    ve = S(Ve);
  Ku(ve, {
    class: "flex items-start gap-3",
    children: (Bt, it) => {
      var He = zbe(),
        Ot = Pt(He),
        Gt = S(Ot);
      Cbe(Gt, {
        class: "text-accent size-5"
      }), P(Ot);
      var kt = L(Ot, 2),
        nr = S(kt),
        It = S(nr, !0);
      P(nr);
      var mt = L(nr, 2),
        yt = S(mt, !0);
      P(mt), bn(2), P(kt), ze((bt, Lt) => {
        ee(It, bt), ee(yt, Lt)
      }, [() => Bue(), () => Vle()]), O(Bt, He)
    },
    $$slots: {
      default: !0
    }
  });
  var Me = L(ve, 2);
  Ku(Me, {
    class: "flex items-start gap-3",
    children: (Bt, it) => {
      var He = Ebe(),
        Ot = Pt(He),
        Gt = S(Ot);
      Mbe(Gt, {
        class: "text-warning size-5"
      }), P(Ot);
      var kt = L(Ot, 2),
        nr = S(kt),
        It = S(nr, !0);
      P(nr);
      var mt = L(nr, 2),
        yt = S(mt, !0);
      P(mt), bn(2), P(kt), ze((bt, Lt) => {
        ee(It, bt), ee(yt, Lt)
      }, [() => W1(), () => tce()]), O(Bt, He)
    },
    $$slots: {
      default: !0
    }
  }), P(Ve);
  var Ye = L(Ve, 2);
  Ku(Ye, {
    class: "prose mt-4 max-w-none text-base",
    children: (Bt, it) => {
      var He = Lbe(),
        Ot = S(He, !0);
      P(He), ze(Gt => ee(Ot, Gt), [() => fce()]), O(Bt, He)
    },
    $$slots: {
      default: !0
    }
  });
  var Ce = L(Ye, 2);
  {
    var Oe = Bt => {
      Ku(Bt, {
        class: "mt-4",
        children: (it, He) => {
          var Ot = Dbe(),
            Gt = Pt(Ot),
            kt = S(Gt),
            nr = L(kt, 2),
            It = S(nr, !0);
          P(nr), P(Gt);
          var mt = L(Gt, 2),
            yt = S(mt),
            bt = L(yt),
            Lt = S(bt, !0);
          P(bt), P(mt);
          var st = L(mt, 2),
            lr = S(st),
            gr = L(lr),
            dr = S(gr, !0);
          P(gr), P(st);
          var pr = L(st, 2),
            Ht = S(pr, !0);
          P(pr);
          var Sr = L(pr, 2),
            Rr = S(Sr);
          P(Sr);
          var Vt = L(Sr, 2),
            Tr = S(Vt);
          P(Vt), ze((Xt, ue, N, q, X, te) => {
            or(kt, "src", n_), ee(It, Xt), ee(yt, `${ue??""} `), ee(Lt, g(x)), ee(lr, `${N??""} `), ee(dr, g(E)), ee(Ht, q), Io(Rr, X), ee(Tr, `${g(x)??""}/${g(A)??""}
					${te??""}`)
          }, [() => Mce(), () => qce(), () => Qce(), () => due(), () => `width: ${Math.min(100,g(A)?g(x)/g(A)*100:0)}%`, () => xl().toLowerCase()]), O(it, Ot)
        },
        $$slots: {
          default: !0
        }
      })
    };
    we(Ce, Bt => {
      Rt.data && Bt(Oe)
    })
  }
  var ut = L(Ce, 2),
    Ue = S(ut),
    Ke = S(Ue, !0);
  P(Ue);
  var St = L(Ue, 2);
  Ku(St, {
    class: "mt-1.5 grid grid-cols-3 gap-2",
    children: (Bt, it) => {
      var He = Rbe(),
        Ot = Pt(He),
        Gt = S(Ot),
        kt = L(Gt, 2);
      kt.__click = () => {
        s.goToLocation(79.99504621849721, -92.13126009697265), r(!1)
      };
      var nr = S(kt);
      wl(nr, {
        class: "size-3.5"
      });
      var It = L(nr);
      P(kt), P(Ot);
      var mt = L(Ot, 2),
        yt = S(mt),
        bt = L(yt, 2);
      bt.__click = () => {
        s.goToLocation(80.55882361187525, -73.54256869072267), r(!1)
      };
      var Lt = S(bt);
      wl(Lt, {
        class: "size-3.5"
      });
      var st = L(Lt);
      P(bt), P(mt);
      var lr = L(mt, 2),
        gr = S(lr),
        dr = L(gr, 2);
      dr.__click = () => {
        s.goToLocation(79.61390464162159, 23.183700840527322), r(!1)
      };
      var pr = S(dr);
      wl(pr, {
        class: "size-3.5"
      });
      var Ht = L(pr);
      P(dr), P(lr), ze((Sr, Rr, Vt) => {
        or(Gt, "src", Tbe), ee(It, ` ${Sr??""}`), or(yt, "src", wbe), ee(st, ` ${Rr??""}`), or(gr, "src", kbe), ee(Ht, ` ${Vt??""}`)
      }, [() => lp(), () => lp(), () => lp()]), O(Bt, He)
    },
    $$slots: {
      default: !0
    }
  }), P(ut);
  var Ft = L(ut, 2),
    Jt = S(Ft);
  Jt.__click = () => G(j, !0);
  var Mt = S(Jt, !0);
  P(Jt), P(Ft);
  var ct = L(Ft, 2),
    wt = S(ct),
    ft = S(wt),
    $t = S(ft, !0);
  P(ft), P(wt), P(ct), P($);
  var Et = L($, 2),
    Qt = S(Et),
    vr = S(Qt, !0);
  P(Qt), P(Et);
  var Kt = L(Et, 2);
  _y(Kt, {
    get open() {
      return g(j)
    },
    set open(Bt) {
      G(j, Bt, !0)
    }
  }), P(W), Li(W, () => Bt => {
    rn(() => {
      r() ? Bt.showModal() : Bt.close()
    })
  }), ze((Bt, it, He, Ot, Gt, kt) => {
    ee(de, Bt), or(Pe, "src", n_), ee(Ge, ` ${it??""} `), or(et, "src", n_), ee(Ke, He), ee(Mt, Ot), ee($t, Gt), ee(vr, kt)
  }, [() => ile(), () => V0(), () => Pue(), () => U0(), () => Ja(), () => Ja()]), Pn("close", W, () => r(!1)), O(d, W), en()
}
Yn(["click"]);
var Bbe = $r('<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>');

function Obe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Bbe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var qbe = se('<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>'),
  Nbe = se('<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p> <p class="text-base-content/80 mt-0.5 text-sm"> <a class="link" href="/terms/code-of-conduct" target="_blank"> </a>.</p></div></div>');

function my(d, s) {
  Qr(s, !1);
  const r = [YM(), xB(), $B(), IO(), J4(), nU(), FZ()];
  em();
  var x = Nbe(),
    A = S(x),
    E = S(A);
  Obe(E, {
    class: "size-5"
  });
  var k = L(E, 2),
    l = S(k),
    j = L(l),
    W = S(j, !0);
  P(j), P(k), P(A);
  var $ = L(A, 2),
    J = S($);
  li(J, 5, () => r, Bc, (Re, Pe) => {
    var Ge = qbe(),
      et = S(Ge, !0);
    P(Ge), ze(() => ee(et, g(Pe))), O(Re, Ge)
  }), P(J);
  var ce = L(J, 2),
    ge = S(ce, !0);
  P(ce);
  var fe = L(ce, 2),
    Z = S(fe),
    de = L(Z),
    Fe = S(de, !0);
  P(de), bn(), P(fe), P($), P(x), ze((Re, Pe, Ge, et, Ve) => {
    ee(l, `${Re??""} `), ee(W, Pe), ee(ge, Ge), ee(Z, `${et??""} `), ee(Fe, Ve)
  }, [() => SH(), () => B8(), () => Mie(), () => ZC(), () => K2()]), O(d, x), en()
}
var Vbe = se('<dialog class="modal" closedby="any"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>');

function Ube(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15);
  var x = Vbe(),
    A = S(x),
    E = S(A),
    k = S(E),
    l = S(k),
    j = S(l, !0);
  P(l);
  var W = L(l, 2);
  k0(W, {
    hasText: !0,
    size: "medium"
  }), P(k), P(E);
  var $ = L(E, 2),
    J = S($);
  my(J, {}), P($);
  var ce = L($, 2),
    ge = S(ce);
  ge.__click = () => {
    xi.url.searchParams.delete("new-user"), bp(xi.url.toString())
  };
  var fe = S(ge, !0);
  P(ge), P(ce), P(A), P(x), Li(x, () => Z => {
    rn(() => {
      r() ? Z.show() : Z.close()
    })
  }), ze((Z, de) => {
    ee(j, Z), ee(fe, de)
  }, [() => Qie(), () => vre()]), Pn("close", x, () => r(!1)), O(d, x), en()
}
Yn(["click"]);

function Zbe() {
  const d = navigator.userAgent,
    s = navigator.vendor;
  return /Chrome/.test(d) && /Google Inc/.test(s) ? "Chrome" : /Safari/.test(d) && /Apple Computer/.test(s) ? "Safari" : /Firefox/.test(d) ? "Firefox" : /Edge/.test(d) ? "Edge" : /Opera|OPR/.test(d) ? "Opera" : "Unknown"
}
var Gbe = $r('<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>');

function $be(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Gbe();
  Dr(x, () => ({
    viewBox: "0 0 512 512",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...r
  })), O(d, x)
}
var Wbe = $r('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z"></path></svg>');

function k_(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Wbe();
  Dr(x, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var Hbe = $r('<svg><path d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>');

function Xbe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Hbe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    preserveAspectRatio: "xMidYMid",
    viewBox: "0 0 260 260",
    ...r
  })), O(d, x)
}
var Ybe = $r('<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>');

function Cp(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Ybe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var Kbe = $r(`<svg><path d="M12.75 2c.39 0 .708.316.75.704a5.735 5.735 0 0 0 
  4.112 4.751c.257.077.523.127.801.149.394.028.713.35.713.744v2.289a.75.75 
  0 0 1-.826.746 8.89 8.89 0 0 1-3.546-1.239v6.43a5.465 5.465 0 
  1 1-5.465-5.465c.388 0 .765.042 1.128.122a.75.75 0 0 
  1 .593.732v2.289a.75.75 0 0 1-.979.715 1.549 1.549 0 0 
  0-.482-.077 1.962 1.962 0 1 0 1.962 1.962V2.75a.75.75 0 0 1 
  .75-.75h1.239Z"></path></svg>`);

function Jbe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Kbe();
  Dr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "Tiktok",
    ...r
  })), O(d, x)
}
var Qbe = $r(`<svg><path d="M23.498 6.186a2.986 2.986 0 0 0-2.103-2.115C19.505 
    3.5 12 3.5 12 3.5s-7.505 0-9.395.571a2.986 2.986 0 0 0-2.103 
    2.115C0 8.082 0 12 0 12s0 3.918.502 5.814a2.986 2.986 0 0 0 
    2.103 2.115C4.495 20.5 12 20.5 12 20.5s7.505 0 9.395-.571a2.986 
    2.986 0 0 0 2.103-2.115C24 15.918 24 12 24 12s0-3.918-.502-5.814zM9.75 
    15.021v-6.042L15.5 12l-5.75 3.021z"></path></svg>`);

function e1e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Qbe();
  Dr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "YouTube",
    ...r
  })), O(d, x)
}
var t1e = se(' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>', 1),
  r1e = se('<span class="link cursor-auto">chrome://settings/system</span>.', 1),
  n1e = se('<span class="link cursor-auto">edge://settings/system/manageSystem</span>.', 1),
  i1e = se(' <kbd class="kbd kbd-sm h-fit px-3"> </kbd> <!>', 1),
  a1e = se('<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a href="https://discord.gg/wplacelive" target="_blank" class="text-nowrap"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank" class="text-nowrap"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank" class="text-nowrap"><!> <span class="link">Instagram</span></a> <span class="mx-0.5">|</span> <a href="https://www.youtube.com/@WplaceLive" target="_blank" class="text-nowrap"><!> <span class="link">Youtube</span></a> <span class="mx-0.5">|</span> <a href="https://www.tiktok.com/@wplace5" target="_blank" class="text-nowrap"><!> <span class="link">Tiktok</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm max-sm:pb-4"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span> Â· <a class="link" target="_blank"> </a> Â· <a class="link" target="_blank"> </a> Â· <a class="link" target="_blank"> </a> Â· <a class="link" href="https://forms.gle/EVG7A1ZoSyJWAjX96" target="_blank"> </a> Â· <a class="link" href="https://forms.gle/uinGA5Gj4SpPYa2R6" target="_blank"> </a></section></div>'),
  o1e = se('<dialog class="modal" closedby="any"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function s1e(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15);
  const x = Zbe();
  var A = o1e(),
    E = S(A),
    k = L(S(E), 2);
  {
    var l = J => {
      var ce = a1e(),
        ge = S(ce),
        fe = S(ge);
      k0(fe, {
        hasText: !0,
        size: "medium"
      });
      var Z = L(fe, 2),
        de = S(Z),
        Fe = L(de, 4);
      bn(), P(Z);
      var Re = L(Z, 2),
        Pe = S(Re),
        Ge = S(Pe),
        et = S(Ge);
      k_(et, {
        class: "text-base-content mr-0.5 inline size-4"
      }), bn(2), P(Ge);
      var Ve = L(Ge, 4),
        ve = S(Ve);
      $be(ve, {
        class: "size-4.5 mr-0.5 inline"
      }), bn(2), P(Ve);
      var Me = L(Ve, 4),
        Ye = S(Me);
      Xbe(Ye, {
        class: "mr-0.5 inline size-3.5"
      }), bn(2), P(Me);
      var Ce = L(Me, 4),
        Oe = S(Ce);
      e1e(Oe, {
        class: "mr-0.5 inline size-3.5"
      }), bn(2), P(Ce);
      var ut = L(Ce, 4),
        Ue = S(ut);
      Jbe(Ue, {
        class: "mr-0.5 inline size-3.5"
      }), bn(2), P(ut), P(Pe), P(Re), P(ge);
      var Ke = L(ge, 2),
        St = S(Ke),
        Ft = S(St, !0);
      P(St);
      var Jt = L(St, 2);
      P(Ke);
      var Mt = L(Ke, 2),
        ct = S(Mt),
        wt = S(ct, !0);
      P(ct);
      var ft = L(ct, 2),
        $t = S(ft),
        Et = L($t),
        Qt = S(Et);
      Cp(Qt, {
        class: "size-5"
      }), P(Et);
      var vr = L(Et);
      P(ft);
      var Kt = L(ft, 2),
        Bt = S(Kt),
        it = L(Bt),
        He = S(it, !0);
      P(it);
      var Ot = L(it);
      P(Kt), P(Mt);
      var Gt = L(Mt, 2),
        kt = S(Gt),
        nr = S(kt, !0);
      P(kt);
      var It = L(kt, 2),
        mt = S(It);
      {
        var yt = N => {
            var q = t1e(),
              X = Pt(q);
            bn(), ze(te => ee(X, `${te??""}: `), [() => zC()]), O(N, q)
          },
          bt = N => {
            var q = i1e(),
              X = Pt(q),
              te = L(X),
              le = S(te, !0);
            P(te);
            var xe = L(te),
              je = L(xe);
            {
              var Ie = rt => {
                  var Xe = r1e();
                  bn(), O(rt, Xe)
                },
                qe = rt => {
                  var Xe = Ir(),
                    he = Pt(Xe);
                  {
                    var Q = Ze => {
                      var vt = n1e();
                      bn(), O(Ze, vt)
                    };
                    we(he, Ze => {
                      x === "Edge" && Ze(Q)
                    }, !0)
                  }
                  O(rt, Xe)
                };
              we(je, rt => {
                x === "Chrome" ? rt(Ie) : rt(qe, !1)
              })
            }
            ze((rt, Xe, he) => {
              ee(X, `${rt??""} `), ee(le, Xe), ee(xe, ` ${he??""} `)
            }, [() => fie(), () => Vne(), () => lL()]), O(N, q)
          };
        we(mt, N => {
          x !== "Chrome" && x !== "Edge" ? N(yt) : N(bt, !1)
        })
      }
      P(It), P(Gt);
      var Lt = L(Gt, 2),
        st = S(Lt);
      my(st, {}), P(Lt);
      var lr = L(Lt, 4),
        gr = L(S(lr), 2),
        dr = S(gr, !0);
      P(gr);
      var pr = L(gr, 2),
        Ht = S(pr, !0);
      P(pr);
      var Sr = L(pr, 2),
        Rr = S(Sr, !0);
      P(Sr);
      var Vt = L(Sr, 2),
        Tr = S(Vt, !0);
      P(Vt);
      var Xt = L(Vt, 2),
        ue = S(Xt, !0);
      P(Xt), P(lr), P(ce), ze((N, q, X, te, le, xe, je, Ie, qe, rt, Xe, he, Q, Ze, vt, Qe, oe) => {
        ee(de, `${N??""} `), ee(Fe, ` Â©
						${q??""} `), ee(Ft, X), or(Jt, "src", $i.language === "pt" ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9" : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"), ee(wt, te), ee($t, `${le??""} `), ee(vr, ` ${xe??""}`), ee(Bt, `${je??""} `), ee(He, Ie), ee(Ot, ` ${qe??""}`), ee(nr, rt), or(gr, "href", Xe), ee(dr, he), or(pr, "href", `${xi.url.origin??""}/terms/privacy`), ee(Ht, Q), or(Sr, "href", Ze), ee(Rr, vt), ee(Tr, Qe), ee(ue, oe)
      }, [() => YZ(), () => wN(), () => HN(), () => Qz(), () => dae(), () => cN(), () => qz(), () => LK(), () => E5(), () => rj(), H1, () => UJ(), () => cG(), T0, () => O0(), () => gJ(), () => Ok()]), oa(2, ce, () => Ka, () => ({
        duration: 300
      })), O(J, ce)
    };
    we(k, J => {
      r() && J(l)
    })
  }
  P(E);
  var j = L(E, 2),
    W = S(j),
    $ = S(W, !0);
  P(W), P(j), P(A), Li(A, () => J => {
    rn(() => {
      r() ? J.show() : J.close()
    })
  }), ze(J => ee($, J), [() => Ja()]), Pn("close", A, () => r(!1)), O(d, A), en()
}

function l1e(d) {
  return d !== null && typeof d == "object"
}
const c1e = ["string", "number", "bigint", "boolean"];

function T_(d) {
  return d == null || c1e.includes(typeof d) ? !0 : Array.isArray(d) ? d.every(s => T_(s)) : typeof d == "object" ? Object.getPrototypeOf(d) === Object.prototype : !1
}
const P_ = Symbol("box"),
  u1e = Symbol("is-writable");

function Un(d, s) {
  const r = xt(d);
  return s ? {
    [P_]: !0,
    [u1e]: !0,
    get current() {
      return g(r)
    },
    set current(x) {
      s(x)
    }
  } : {
    [P_]: !0,
    get current() {
      return d()
    }
  }
}

function h1e(d) {
  return l1e(d) && P_ in d
}

function d1e(...d) {
  return function(s) {
    var r;
    for (const x of d)
      if (x) {
        if (s.defaultPrevented) return;
        typeof x == "function" ? x.call(this, s) : (r = x.current) == null || r.call(this, s)
      }
  }
}
var Hv = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
  p1e = /\n/g,
  f1e = /^\s*/,
  _1e = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
  m1e = /^:\s*/,
  g1e = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
  v1e = /^[;\s]*/,
  y1e = /^\s+|\s+$/g,
  x1e = `
`,
  Xv = "/",
  Yv = "*",
  ml = "",
  b1e = "comment",
  w1e = "declaration";

function k1e(d, s) {
  if (typeof d != "string") throw new TypeError("First argument must be a string");
  if (!d) return [];
  s = s || {};
  var r = 1,
    x = 1;

  function A(fe) {
    var Z = fe.match(p1e);
    Z && (r += Z.length);
    var de = fe.lastIndexOf(x1e);
    x = ~de ? fe.length - de : x + fe.length
  }

  function E() {
    var fe = {
      line: r,
      column: x
    };
    return function(Z) {
      return Z.position = new k(fe), W(), Z
    }
  }

  function k(fe) {
    this.start = fe, this.end = {
      line: r,
      column: x
    }, this.source = s.source
  }
  k.prototype.content = d;

  function l(fe) {
    var Z = new Error(s.source + ":" + r + ":" + x + ": " + fe);
    if (Z.reason = fe, Z.filename = s.source, Z.line = r, Z.column = x, Z.source = d, !s.silent) throw Z
  }

  function j(fe) {
    var Z = fe.exec(d);
    if (Z) {
      var de = Z[0];
      return A(de), d = d.slice(de.length), Z
    }
  }

  function W() {
    j(f1e)
  }

  function $(fe) {
    var Z;
    for (fe = fe || []; Z = J();) Z !== !1 && fe.push(Z);
    return fe
  }

  function J() {
    var fe = E();
    if (!(Xv != d.charAt(0) || Yv != d.charAt(1))) {
      for (var Z = 2; ml != d.charAt(Z) && (Yv != d.charAt(Z) || Xv != d.charAt(Z + 1));) ++Z;
      if (Z += 2, ml === d.charAt(Z - 1)) return l("End of comment missing");
      var de = d.slice(2, Z - 2);
      return x += 2, A(de), d = d.slice(Z), x += 2, fe({
        type: b1e,
        comment: de
      })
    }
  }

  function ce() {
    var fe = E(),
      Z = j(_1e);
    if (Z) {
      if (J(), !j(m1e)) return l("property missing ':'");
      var de = j(g1e),
        Fe = fe({
          type: w1e,
          property: Kv(Z[0].replace(Hv, ml)),
          value: de ? Kv(de[0].replace(Hv, ml)) : ml
        });
      return j(v1e), Fe
    }
  }

  function ge() {
    var fe = [];
    $(fe);
    for (var Z; Z = ce();) Z !== !1 && (fe.push(Z), $(fe));
    return fe
  }
  return W(), ge()
}

function Kv(d) {
  return d ? d.replace(y1e, ml) : ml
}

function T1e(d, s) {
  let r = null;
  if (!d || typeof d != "string") return r;
  const x = k1e(d),
    A = typeof s == "function";
  return x.forEach(E => {
    if (E.type !== "declaration") return;
    const {
      property: k,
      value: l
    } = E;
    A ? s(k, l, E) : l && (r = r || {}, r[k] = l)
  }), r
}
const P1e = /\d/,
  S1e = ["-", "_", "/", "."];

function M1e(d = "") {
  if (!P1e.test(d)) return d !== d.toLowerCase()
}

function I1e(d) {
  const s = [];
  let r = "",
    x, A;
  for (const E of d) {
    const k = S1e.includes(E);
    if (k === !0) {
      s.push(r), r = "", x = void 0;
      continue
    }
    const l = M1e(E);
    if (A === !1) {
      if (x === !1 && l === !0) {
        s.push(r), r = E, x = l;
        continue
      }
      if (x === !0 && l === !1 && r.length > 1) {
        const j = r.at(-1);
        s.push(r.slice(0, Math.max(0, r.length - 1))), r = j + E, x = l;
        continue
      }
    }
    r += E, x = l, A = k
  }
  return s.push(r), s
}

function gy(d) {
  return d ? I1e(d).map(s => A1e(s)).join("") : ""
}

function C1e(d) {
  return z1e(gy(d || ""))
}

function A1e(d) {
  return d ? d[0].toUpperCase() + d.slice(1) : ""
}

function z1e(d) {
  return d ? d[0].toLowerCase() + d.slice(1) : ""
}

function ap(d) {
  if (!d) return {};
  const s = {};

  function r(x, A) {
    if (x.startsWith("-moz-") || x.startsWith("-webkit-") || x.startsWith("-ms-") || x.startsWith("-o-")) {
      s[gy(x)] = A;
      return
    }
    if (x.startsWith("--")) {
      s[x] = A;
      return
    }
    s[C1e(x)] = A
  }
  return T1e(d, r), s
}

function E1e(...d) {
  return (...s) => {
    for (const r of d) typeof r == "function" && r(...s)
  }
}

function L1e(d, s) {
  const r = RegExp(d, "g");
  return x => {
    if (typeof x != "string") throw new TypeError(`expected an argument of type string, but got ${typeof x}`);
    return x.match(r) ? x.replace(r, s) : x
  }
}
const D1e = L1e(/[A-Z]/, d => `-${d.toLowerCase()}`);

function R1e(d) {
  if (!d || typeof d != "object" || Array.isArray(d)) throw new TypeError(`expected an argument of type object, but got ${typeof d}`);
  return Object.keys(d).map(s => `${D1e(s)}: ${d[s]};`).join(`
`)
}

function vy(d = {}) {
  return R1e(d).replace(`
`, " ")
}
const j1e = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"],
  F1e = new Set(j1e);

function B1e(d) {
  return F1e.has(d)
}

function gs(...d) {
  const s = {
    ...d[0]
  };
  for (let r = 1; r < d.length; r++) {
    const x = d[r];
    if (x) {
      for (const A of Object.keys(x)) {
        const E = s[A],
          k = x[A],
          l = typeof E == "function",
          j = typeof k == "function";
        if (l && B1e(A)) {
          const W = E,
            $ = k;
          s[A] = d1e(W, $)
        } else if (l && j) s[A] = E1e(E, k);
        else if (A === "class") {
          const W = T_(E),
            $ = T_(k);
          W && $ ? s[A] = sp(E, k) : W ? s[A] = sp(E) : $ && (s[A] = sp(k))
        } else if (A === "style") {
          const W = typeof E == "object",
            $ = typeof k == "object",
            J = typeof E == "string",
            ce = typeof k == "string";
          if (W && $) s[A] = {
            ...E,
            ...k
          };
          else if (W && ce) {
            const ge = ap(k);
            s[A] = {
              ...E,
              ...ge
            }
          } else if (J && $) {
            const ge = ap(E);
            s[A] = {
              ...ge,
              ...k
            }
          } else if (J && ce) {
            const ge = ap(E),
              fe = ap(k);
            s[A] = {
              ...ge,
              ...fe
            }
          } else W ? s[A] = E : $ ? s[A] = k : J ? s[A] = E : ce && (s[A] = k)
        } else s[A] = k !== void 0 ? k : E
      }
      for (const A of Object.getOwnPropertySymbols(x)) {
        const E = s[A],
          k = x[A];
        s[A] = k !== void 0 ? k : E
      }
    }
  }
  return typeof s.style == "object" && (s.style = vy(s.style).replaceAll(`
`, " ")), s.hidden === !1 && (s.hidden = void 0, delete s.hidden), s.disabled === !1 && (s.disabled = void 0, delete s.disabled), s
}
const yy = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
vy(yy);
const O1e = typeof window < "u" ? window : void 0;

function q1e(d) {
  let s = d.activeElement;
  for (; s != null && s.shadowRoot;) {
    const r = s.shadowRoot.activeElement;
    if (r === s) break;
    s = r
  }
  return s
}
var Lc, hh;
class N1e {
  constructor(s = {}) {
    yn(this, Lc);
    yn(this, hh);
    const {
      window: r = O1e,
      document: x = r == null ? void 0 : r.document
    } = s;
    r !== void 0 && (_a(this, Lc, x), _a(this, hh, h0(A => {
      const E = xp(r, "focusin", A),
        k = xp(r, "focusout", A);
      return () => {
        E(), k()
      }
    })))
  }
  get current() {
    var s;
    return (s = tr(this, hh)) == null || s.call(this), tr(this, Lc) ? q1e(tr(this, Lc)) : null
  }
}
Lc = new WeakMap, hh = new WeakMap;
new N1e;
var dh, ps;
class xm {
  constructor(s) {
    yn(this, dh);
    yn(this, ps);
    _a(this, dh, s), _a(this, ps, Symbol(s))
  }
  get key() {
    return tr(this, ps)
  }
  exists() {
    return Jb(tr(this, ps))
  }
  get() {
    const s = mv(tr(this, ps));
    if (s === void 0) throw new Error(`Context "${tr(this,dh)}" not found`);
    return s
  }
  getOr(s) {
    const r = mv(tr(this, ps));
    return r === void 0 ? s : r
  }
  set(s) {
    return Qb(tr(this, ps), s)
  }
}
dh = new WeakMap, ps = new WeakMap;

function V1e(d, s) {
  switch (d) {
    case "post":
      rn(s);
      break;
    case "pre":
      X_(s);
      break
  }
}

function xy(d, s, r, x = {}) {
  const {
    lazy: A = !1
  } = x;
  let E = !A,
    k = Array.isArray(d) ? [] : void 0;
  V1e(s, () => {
    const l = Array.isArray(d) ? d.map(W => W()) : d();
    if (!E) {
      E = !0, k = l;
      return
    }
    const j = ma(() => r(l, k));
    return k = l, j
  })
}

function Fc(d, s, r) {
  xy(d, "post", s, r)
}

function U1e(d, s, r) {
  xy(d, "pre", s, r)
}
Fc.pre = U1e;

function Z1e(d, s) {
  return setTimeout(s, d)
}

function Mc(d) {
  Y_().then(d)
}

function vs(d, s) {
  return {
    [l2()]: r => h1e(d) ? (d.current = r, ma(() => s == null ? void 0 : s(r)), () => {
      "isConnected" in r && r.isConnected || (d.current = null, s == null || s(null))
    }) : (d(r), ma(() => s == null ? void 0 : s(r)), () => {
      "isConnected" in r && r.isConnected || (d(null), s == null || s(null))
    })
  }
}

function S_(d) {
  return d ? "true" : "false"
}

function Jv(d) {
  return d ? "" : void 0
}
var Dc, ph;
class G1e {
  constructor(s) {
    yn(this, Dc);
    yn(this, ph);
    vn(this, "attrs");
    _a(this, Dc, s.getVariant ? s.getVariant() : null), _a(this, ph, tr(this, Dc) ? `data-${tr(this,Dc)}-` : `data-${s.component}-`), this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(s.parts.map(r => [r, this.getAttr(r)]))
  }
  getAttr(s, r) {
    return r ? `data-${r}-${s}` : `${tr(this,ph)}${s}`
  }
  selector(s, r) {
    return `[${this.getAttr(s,r)}]`
  }
}
Dc = new WeakMap, ph = new WeakMap;

function $1e(d) {
  const s = new G1e(d);
  return {
    ...s.attrs,
    selector: s.selector,
    getAttr: s.getAttr
  }
}
const W1e = "ArrowDown",
  H1e = "ArrowLeft",
  X1e = "ArrowRight",
  Y1e = "ArrowUp",
  K1e = "End",
  J1e = "Enter",
  Q1e = "Home",
  e2e = "p",
  t2e = "n",
  r2e = "j",
  n2e = "k",
  i2e = "h",
  a2e = "l";

function M_() {}

function ys(d, s) {
  return `bits-${d}`
}

function o2e(d) {
  if (!d) return null;
  for (const s of d.childNodes)
    if (s.nodeType !== Node.COMMENT_NODE) return s;
  return null
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = {
  current: 0
});

function s2e(d = "bits") {
  return globalThis.bitsIdCounter.current++, `${d}-${globalThis.bitsIdCounter.current}`
}

function l2e(d, s) {
  let r = d.nextElementSibling;
  for (; r;) {
    if (r.matches(s)) return r;
    r = r.nextElementSibling
  }
}

function c2e(d, s) {
  let r = d.previousElementSibling;
  for (; r;) {
    if (r.matches(s)) return r;
    r = r.previousElementSibling
  }
}

function by(d) {
  if (typeof CSS < "u" && typeof CSS.escape == "function") return CSS.escape(d);
  const s = d.length;
  let r = -1,
    x, A = "";
  const E = d.charCodeAt(0);
  if (s === 1 && E === 45) return "\\" + d;
  for (; ++r < s;) {
    if (x = d.charCodeAt(r), x === 0) {
      A += "ï¿½";
      continue
    }
    if (x >= 1 && x <= 31 || x === 127 || r === 0 && x >= 48 && x <= 57 || r === 1 && x >= 48 && x <= 57 && E === 45) {
      A += "\\" + x.toString(16) + " ";
      continue
    }
    if (x >= 128 || x === 45 || x === 95 || x >= 48 && x <= 57 || x >= 65 && x <= 90 || x >= 97 && x <= 122) {
      A += d.charAt(r);
      continue
    }
    A += "\\" + d.charAt(r)
  }
  return A
}
const gl = "data-value",
  Ba = $1e({
    component: "command",
    parts: ["root", "list", "input", "separator", "loading", "empty", "group", "group-items", "group-heading", "item", "viewport", "input-label"]
  }),
  Ic = Ba.selector("group"),
  i_ = Ba.selector("group-items"),
  Qv = Ba.selector("group-heading"),
  wy = Ba.selector("item"),
  a_ = `${Ba.selector("item")}:not([aria-disabled="true"])`,
  Sl = new xm("Command.Root"),
  u2e = new xm("Command.List"),
  ah = new xm("Command.Group"),
  e0 = {
    search: "",
    value: "",
    filtered: {
      count: 0,
      items: new Map,
      groups: new Set
    }
  };
var Rc, jc, fh, _h, mh, gh, vh, yh, Zr, ky, mp, C_, gp, vp, yp, Bs, Ty, Py, A_, Qu, z_, E_, Sy, eh, L_, D_, My, th, rh, xh;
const Tm = class Tm {
  constructor(s) {
    yn(this, Zr);
    vn(this, "opts");
    vn(this, "attachment");
    yn(this, Rc, !1);
    yn(this, jc, !0);
    vn(this, "sortAfterTick", !1);
    vn(this, "sortAndFilterAfterTick", !1);
    vn(this, "allItems", new Set);
    vn(this, "allGroups", new Map);
    vn(this, "allIds", new Map);
    yn(this, fh, We(0));
    yn(this, _h, We(null));
    yn(this, mh, We(null));
    yn(this, gh, We(null));
    yn(this, vh, We(e0));
    yn(this, yh, We(Pi(e0)));
    yn(this, xh, xt(() => ({
      id: this.opts.id.current,
      role: "application",
      [Ba.root]: "",
      tabindex: -1,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = s, this.attachment = vs(this.opts.ref);
    const r = {
      ...this._commandState,
      value: this.opts.value.current ?? ""
    };
    this._commandState = r, this.commandState = r, this.onkeydown = this.onkeydown.bind(this)
  }
  static create(s) {
    return Sl.set(new Tm(s))
  }
  get key() {
    return g(tr(this, fh))
  }
  set key(s) {
    G(tr(this, fh), s, !0)
  }
  get viewportNode() {
    return g(tr(this, _h))
  }
  set viewportNode(s) {
    G(tr(this, _h), s, !0)
  }
  get inputNode() {
    return g(tr(this, mh))
  }
  set inputNode(s) {
    G(tr(this, mh), s, !0)
  }
  get labelNode() {
    return g(tr(this, gh))
  }
  set labelNode(s) {
    G(tr(this, gh), s, !0)
  }
  get commandState() {
    return g(tr(this, vh))
  }
  set commandState(s) {
    G(tr(this, vh), s)
  }
  get _commandState() {
    return g(tr(this, yh))
  }
  set _commandState(s) {
    G(tr(this, yh), s, !0)
  }
  setState(s, r, x) {
    Object.is(this._commandState[s], r) || (this._commandState[s] = r, s === "search" ? (on(this, Zr, yp).call(this), on(this, Zr, gp).call(this)) : s === "value" && (x || on(this, Zr, Ty).call(this)), on(this, Zr, mp).call(this))
  }
  setValue(s, r) {
    s !== this.opts.value.current && s === "" && Mc(() => {
      this.key++
    }), this.setState("value", s, r), this.opts.value.current = s
  }
  getValidItems() {
    const s = this.opts.ref.current;
    return s ? Array.from(s.querySelectorAll(a_)).filter(x => !!x) : []
  }
  getVisibleItems() {
    const s = this.opts.ref.current;
    return s ? Array.from(s.querySelectorAll(wy)).filter(x => !!x) : []
  }
  get itemsGrid() {
    var l, j, W, $;
    if (!this.isGrid) return [];
    const s = this.opts.columns.current ?? 1,
      r = this.getVisibleItems(),
      x = [
        []
      ];
    let A = (l = r[0]) == null ? void 0 : l.getAttribute("data-group"),
      E = 0,
      k = 0;
    for (let J = 0; J < r.length; J++) {
      const ce = r[J],
        ge = ce == null ? void 0 : ce.getAttribute("data-group");
      A !== ge ? (A = ge, E = 1, k++, x.push([{
        index: J,
        firstRowOfGroup: !0,
        ref: ce
      }])) : (E++, E > s && (k++, E = 1, x.push([])), ($ = x[k]) == null || $.push({
        index: J,
        firstRowOfGroup: ((W = (j = x[k]) == null ? void 0 : j[0]) == null ? void 0 : W.firstRowOfGroup) ?? J === 0,
        ref: ce
      }))
    }
    return x
  }
  updateSelectedToIndex(s) {
    const r = this.getValidItems()[s];
    r && this.setValue(r.getAttribute(gl) ?? "")
  }
  updateSelectedByItem(s) {
    const r = on(this, Zr, Bs).call(this),
      x = this.getValidItems(),
      A = x.findIndex(k => k === r);
    let E = x[A + s];
    this.opts.loop.current && (E = A + s < 0 ? x[x.length - 1] : A + s === x.length ? x[0] : x[A + s]), E && this.setValue(E.getAttribute(gl) ?? "")
  }
  updateSelectedByGroup(s) {
    const r = on(this, Zr, Bs).call(this);
    let x = r == null ? void 0 : r.closest(Ic),
      A;
    for (; x && !A;) x = s > 0 ? l2e(x, Ic) : c2e(x, Ic), A = x == null ? void 0 : x.querySelector(a_);
    A ? this.setValue(A.getAttribute(gl) ?? "") : this.updateSelectedByItem(s)
  }
  registerValue(s, r) {
    var x;
    return s && s === ((x = this.allIds.get(s)) == null ? void 0 : x.value) || this.allIds.set(s, {
      value: s,
      keywords: r
    }), this._commandState.filtered.items.set(s, on(this, Zr, C_).call(this, s, r)), this.sortAfterTick || (this.sortAfterTick = !0, Mc(() => {
      on(this, Zr, gp).call(this), this.sortAfterTick = !1
    })), () => {
      this.allIds.delete(s)
    }
  }
  registerItem(s, r) {
    return this.allItems.add(s), r && (this.allGroups.has(r) ? this.allGroups.get(r).add(s) : this.allGroups.set(r, new Set([s]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, Mc(() => {
      on(this, Zr, yp).call(this), on(this, Zr, gp).call(this), this.sortAndFilterAfterTick = !1
    })), on(this, Zr, mp).call(this), () => {
      const x = on(this, Zr, Bs).call(this);
      this.allItems.delete(s), this.commandState.filtered.items.delete(s), on(this, Zr, yp).call(this), (x == null ? void 0 : x.getAttribute("id")) === s && on(this, Zr, vp).call(this), on(this, Zr, mp).call(this)
    }
  }
  registerGroup(s) {
    return this.allGroups.has(s) || this.allGroups.set(s, new Set), () => {
      this.allIds.delete(s), this.allGroups.delete(s)
    }
  }
  get isGrid() {
    return this.opts.columns.current !== null
  }
  onkeydown(s) {
    const r = this.opts.vimBindings.current && s.ctrlKey;
    switch (s.key) {
      case t2e:
      case r2e: {
        r && (this.isGrid ? on(this, Zr, z_).call(this, s) : on(this, Zr, Qu).call(this, s));
        break
      }
      case a2e: {
        r && this.isGrid && on(this, Zr, Qu).call(this, s);
        break
      }
      case W1e:
        this.isGrid ? on(this, Zr, z_).call(this, s) : on(this, Zr, Qu).call(this, s);
        break;
      case X1e:
        if (!this.isGrid) break;
        on(this, Zr, Qu).call(this, s);
        break;
      case e2e:
      case n2e: {
        r && (this.isGrid ? on(this, Zr, D_).call(this, s) : on(this, Zr, rh).call(this, s));
        break
      }
      case i2e: {
        r && this.isGrid && on(this, Zr, rh).call(this, s);
        break
      }
      case Y1e:
        this.isGrid ? on(this, Zr, D_).call(this, s) : on(this, Zr, rh).call(this, s);
        break;
      case H1e:
        if (!this.isGrid) break;
        on(this, Zr, rh).call(this, s);
        break;
      case Q1e:
        s.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case K1e:
        s.preventDefault(), on(this, Zr, A_).call(this);
        break;
      case J1e:
        if (!s.isComposing && s.keyCode !== 229) {
          s.preventDefault();
          const x = on(this, Zr, Bs).call(this);
          x && (x == null || x.click())
        }
    }
  }
  get props() {
    return g(tr(this, xh))
  }
  set props(s) {
    G(tr(this, xh), s)
  }
};
Rc = new WeakMap, jc = new WeakMap, fh = new WeakMap, _h = new WeakMap, mh = new WeakMap, gh = new WeakMap, vh = new WeakMap, yh = new WeakMap, Zr = new WeakSet, ky = function() {
  return s2(this._commandState)
}, mp = function() {
  tr(this, Rc) || (_a(this, Rc, !0), Mc(() => {
    var x, A;
    _a(this, Rc, !1);
    const s = on(this, Zr, ky).call(this);
    !Object.is(this.commandState, s) && (this.commandState = s, (A = (x = this.opts.onStateChange) == null ? void 0 : x.current) == null || A.call(x, s))
  }))
}, C_ = function(s, r) {
  const x = this.opts.filter.current ?? Ay;
  return s ? x(s, this._commandState.search, r) : 0
}, gp = function() {
  var k;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    (!this._commandState.value || !tr(this, jc)) && on(this, Zr, vp).call(this);
    return
  }
  const s = this._commandState.filtered.items,
    r = [];
  for (const l of this._commandState.filtered.groups) {
    const j = this.allGroups.get(l);
    let W = 0;
    if (!j) {
      r.push([l, W]);
      continue
    }
    for (const $ of j) {
      const J = s.get($);
      W = Math.max(J ?? 0, W)
    }
    r.push([l, W])
  }
  const x = this.viewportNode,
    A = this.getValidItems().sort((l, j) => {
      const W = l.getAttribute("data-value"),
        $ = j.getAttribute("data-value"),
        J = s.get(W) ?? 0;
      return (s.get($) ?? 0) - J
    });
  for (const l of A) {
    const j = l.closest(i_);
    if (j) {
      const W = l.parentElement === j ? l : l.closest(`${i_} > *`);
      W && j.appendChild(W)
    } else {
      const W = l.parentElement === x ? l : l.closest(`${i_} > *`);
      W && (x == null || x.appendChild(W))
    }
  }
  const E = r.sort((l, j) => j[1] - l[1]);
  for (const l of E) {
    const j = x == null ? void 0 : x.querySelector(`${Ic}[${gl}="${by(l[0])}"]`);
    (k = j == null ? void 0 : j.parentElement) == null || k.appendChild(j)
  }
  on(this, Zr, vp).call(this)
}, vp = function() {
  Mc(() => {
    const s = this.getValidItems().find(A => A.getAttribute("aria-disabled") !== "true"),
      r = s == null ? void 0 : s.getAttribute(gl),
      x = tr(this, jc) && this.opts.disableInitialScroll.current;
    this.setValue(r ?? "", x), _a(this, jc, !1)
  })
}, yp = function() {
  var r, x;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    this._commandState.filtered.count = this.allItems.size;
    return
  }
  this._commandState.filtered.groups = new Set;
  let s = 0;
  for (const A of this.allItems) {
    const E = ((r = this.allIds.get(A)) == null ? void 0 : r.value) ?? "",
      k = ((x = this.allIds.get(A)) == null ? void 0 : x.keywords) ?? [],
      l = on(this, Zr, C_).call(this, E, k);
    this._commandState.filtered.items.set(A, l), l > 0 && s++
  }
  for (const [A, E] of this.allGroups)
    for (const k of E) {
      const l = this._commandState.filtered.items.get(k);
      if (l && l > 0) {
        this._commandState.filtered.groups.add(A);
        break
      }
    }
  this._commandState.filtered.count = s
}, Bs = function() {
  const s = this.opts.ref.current;
  if (!s) return;
  const r = s.querySelector(`${a_}[data-selected]`);
  if (r) return r
}, Ty = function() {
  Mc(() => {
    var x, A, E, k, l;
    const s = on(this, Zr, Bs).call(this);
    if (!s) return;
    const r = (x = s.parentElement) == null ? void 0 : x.parentElement;
    if (r) {
      if (this.isGrid) {
        const j = on(this, Zr, Py).call(this, s);
        if (s.scrollIntoView({
            block: "nearest"
          }), j) {
          const W = (A = s == null ? void 0 : s.closest(Ic)) == null ? void 0 : A.querySelector(Qv);
          W == null || W.scrollIntoView({
            block: "nearest"
          });
          return
        }
      } else {
        const j = o2e(r);
        if (j && ((E = j.dataset) == null ? void 0 : E.value) === ((k = s.dataset) == null ? void 0 : k.value)) {
          const W = (l = s == null ? void 0 : s.closest(Ic)) == null ? void 0 : l.querySelector(Qv);
          W == null || W.scrollIntoView({
            block: "nearest"
          });
          return
        }
      }
      s.scrollIntoView({
        block: "nearest"
      })
    }
  })
}, Py = function(s) {
  const r = this.itemsGrid;
  if (r.length === 0) return !1;
  for (let x = 0; x < r.length; x++) {
    const A = r[x];
    if (A !== void 0)
      for (let E = 0; E < A.length; E++) {
        const k = A[E];
        if (!(k === void 0 || k.ref !== s)) return k.firstRowOfGroup
      }
  }
  return !1
}, A_ = function() {
  return this.updateSelectedToIndex(this.getValidItems().length - 1)
}, Qu = function(s) {
  s.preventDefault(), s.metaKey ? on(this, Zr, A_).call(this) : s.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1)
}, z_ = function(s) {
  this.opts.columns.current !== null && (s.preventDefault(), s.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(on(this, Zr, Sy).call(this, s)))
}, E_ = function(s, r) {
  if (r.length === 0) return null;
  for (let x = 0; x < r.length; x++) {
    const A = r[x];
    if (A !== void 0)
      for (let E = 0; E < A.length; E++) {
        const k = A[E];
        if (!(k === void 0 || k.ref !== s)) return {
          columnIndex: E,
          rowIndex: x
        }
      }
  }
  return null
}, Sy = function(s) {
  const r = this.itemsGrid,
    x = on(this, Zr, Bs).call(this);
  if (!x) return 0;
  const A = on(this, Zr, E_).call(this, x, r);
  if (!A) return 0;
  let E = null;
  const k = s.altKey ? 1 : 0;
  if (s.altKey && A.rowIndex === r.length - 2 && !this.opts.loop.current) E = on(this, Zr, eh).call(this, {
    start: r.length - 1,
    end: r.length,
    expectedColumnIndex: A.columnIndex,
    grid: r
  });
  else if (A.rowIndex === r.length - 1) {
    if (!this.opts.loop.current) return 0;
    E = on(this, Zr, eh).call(this, {
      start: 0 + k,
      end: A.rowIndex,
      expectedColumnIndex: A.columnIndex,
      grid: r
    })
  } else E = on(this, Zr, eh).call(this, {
    start: A.rowIndex + 1 + k,
    end: r.length,
    expectedColumnIndex: A.columnIndex,
    grid: r
  }), E === null && this.opts.loop.current && (E = on(this, Zr, eh).call(this, {
    start: 0,
    end: A.rowIndex,
    expectedColumnIndex: A.columnIndex,
    grid: r
  }));
  return on(this, Zr, L_).call(this, x, E)
}, eh = function({
  start: s,
  end: r,
  grid: x,
  expectedColumnIndex: A
}) {
  var k;
  let E = null;
  for (let l = s; l < r; l++) {
    const j = x[l];
    if (E = ((k = j[A]) == null ? void 0 : k.ref) ?? null, E !== null && op(E)) {
      E = null;
      continue
    }
    if (E === null)
      for (let W = j.length - 1; W >= 0; W--) {
        const $ = j[j.length - 1];
        if (!($ === void 0 || op($.ref))) {
          E = $.ref;
          break
        }
      }
    break
  }
  return E
}, L_ = function(s, r) {
  if (r === null) return 0;
  const x = this.getValidItems(),
    A = x.findIndex(k => k === s);
  return x.findIndex(k => k === r) - A
}, D_ = function(s) {
  this.opts.columns.current !== null && (s.preventDefault(), s.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(on(this, Zr, My).call(this, s)))
}, My = function(s) {
  const r = this.itemsGrid,
    x = on(this, Zr, Bs).call(this);
  if (x === void 0) return 0;
  const A = on(this, Zr, E_).call(this, x, r);
  if (A === null) return 0;
  let E = null;
  const k = s.altKey ? 1 : 0;
  if (s.altKey && A.rowIndex === 1 && this.opts.loop.current === !1) E = on(this, Zr, th).call(this, {
    start: 0,
    end: 0,
    expectedColumnIndex: A.columnIndex,
    grid: r
  });
  else if (A.rowIndex === 0) {
    if (this.opts.loop.current === !1) return 0;
    E = on(this, Zr, th).call(this, {
      start: r.length - 1 - k,
      end: A.rowIndex + 1,
      expectedColumnIndex: A.columnIndex,
      grid: r
    })
  } else E = on(this, Zr, th).call(this, {
    start: A.rowIndex - 1 - k,
    end: 0,
    expectedColumnIndex: A.columnIndex,
    grid: r
  }), E === null && this.opts.loop.current && (E = on(this, Zr, th).call(this, {
    start: r.length - 1,
    end: A.rowIndex + 1,
    expectedColumnIndex: A.columnIndex,
    grid: r
  }));
  return on(this, Zr, L_).call(this, x, E)
}, th = function({
  start: s,
  end: r,
  grid: x,
  expectedColumnIndex: A
}) {
  var k;
  let E = null;
  for (let l = s; l >= r; l--) {
    const j = x[l];
    if (j !== void 0) {
      if (E = ((k = j[A]) == null ? void 0 : k.ref) ?? null, E !== null && op(E)) {
        E = null;
        continue
      }
      if (E === null)
        for (let W = j.length - 1; W >= 0; W--) {
          const $ = j[j.length - 1];
          if (!($ === void 0 || op($.ref))) {
            E = $.ref;
            break
          }
        }
      break
    }
  }
  return E
}, rh = function(s) {
  s.preventDefault(), s.metaKey ? this.updateSelectedToIndex(0) : s.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1)
}, xh = new WeakMap;
let I_ = Tm;

function op(d) {
  return d.getAttribute("aria-disabled") === "true"
}
var bh, wh, kh;
const Pm = class Pm {
  constructor(s, r) {
    vn(this, "opts");
    vn(this, "root");
    vn(this, "attachment");
    yn(this, bh, xt(() => this.root._commandState.filtered.count === 0 && tr(this, wh) === !1 || this.opts.forceMount.current));
    yn(this, wh, !0);
    yn(this, kh, xt(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [Ba.empty]: "",
      ...this.attachment
    })));
    this.opts = s, this.root = r, this.attachment = vs(this.opts.ref), X_(() => {
      _a(this, wh, !1)
    })
  }
  static create(s) {
    return new Pm(s, Sl.get())
  }
  get shouldRender() {
    return g(tr(this, bh))
  }
  set shouldRender(s) {
    G(tr(this, bh), s)
  }
  get props() {
    return g(tr(this, kh))
  }
  set props(s) {
    G(tr(this, kh), s)
  }
};
bh = new WeakMap, wh = new WeakMap, kh = new WeakMap;
let R_ = Pm;
var Th, Ph, Sh, Mh;
const Sm = class Sm {
  constructor(s, r) {
    vn(this, "opts");
    vn(this, "root");
    vn(this, "attachment");
    yn(this, Th, xt(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue)));
    yn(this, Ph, We(null));
    yn(this, Sh, We(""));
    yn(this, Mh, xt(() => ({
      id: this.opts.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : !0,
      "data-value": this.trueValue,
      [Ba.group]: "",
      ...this.attachment
    })));
    this.opts = s, this.root = r, this.attachment = vs(this.opts.ref), this.trueValue = s.value.current ?? s.id.current, Fc(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), rn(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)))
  }
  static create(s) {
    return ah.set(new Sm(s, Sl.get()))
  }
  get shouldRender() {
    return g(tr(this, Th))
  }
  set shouldRender(s) {
    G(tr(this, Th), s)
  }
  get headingNode() {
    return g(tr(this, Ph))
  }
  set headingNode(s) {
    G(tr(this, Ph), s, !0)
  }
  get trueValue() {
    return g(tr(this, Sh))
  }
  set trueValue(s) {
    G(tr(this, Sh), s, !0)
  }
  get props() {
    return g(tr(this, Mh))
  }
  set props(s) {
    G(tr(this, Mh), s)
  }
};
Th = new WeakMap, Ph = new WeakMap, Sh = new WeakMap, Mh = new WeakMap;
let j_ = Sm;
var Ih;
const Mm = class Mm {
  constructor(s, r) {
    vn(this, "opts");
    vn(this, "group");
    vn(this, "attachment");
    yn(this, Ih, xt(() => ({
      id: this.opts.id.current,
      [Ba["group-heading"]]: "",
      ...this.attachment
    })));
    this.opts = s, this.group = r, this.attachment = vs(this.opts.ref, x => this.group.headingNode = x)
  }
  static create(s) {
    return new Mm(s, ah.get())
  }
  get props() {
    return g(tr(this, Ih))
  }
  set props(s) {
    G(tr(this, Ih), s)
  }
};
Ih = new WeakMap;
let F_ = Mm;
var Ch;
const Im = class Im {
  constructor(s, r) {
    vn(this, "opts");
    vn(this, "group");
    vn(this, "attachment");
    yn(this, Ch, xt(() => {
      var s;
      return {
        id: this.opts.id.current,
        role: "group",
        [Ba["group-items"]]: "",
        "aria-labelledby": ((s = this.group.headingNode) == null ? void 0 : s.id) ?? void 0,
        ...this.attachment
      }
    }));
    this.opts = s, this.group = r, this.attachment = vs(this.opts.ref)
  }
  static create(s) {
    return new Im(s, ah.get())
  }
  get props() {
    return g(tr(this, Ch))
  }
  set props(s) {
    G(tr(this, Ch), s)
  }
};
Ch = new WeakMap;
let B_ = Im;
var Lp, Ah;
const Cm = class Cm {
  constructor(s, r) {
    vn(this, "opts");
    vn(this, "root");
    vn(this, "attachment");
    yn(this, Lp, xt(() => {
      var r;
      const s = (r = this.root.viewportNode) == null ? void 0 : r.querySelector(`${wy}[${gl}="${by(this.root.opts.value.current)}"]`);
      if (s != null) return s.getAttribute("id") ?? void 0
    }));
    yn(this, Ah, xt(() => {
      var s, r;
      return {
        id: this.opts.id.current,
        type: "text",
        [Ba.input]: "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": S_(!0),
        "aria-controls": ((s = this.root.viewportNode) == null ? void 0 : s.id) ?? void 0,
        "aria-labelledby": ((r = this.root.labelNode) == null ? void 0 : r.id) ?? void 0,
        "aria-activedescendant": g(tr(this, Lp)),
        ...this.attachment
      }
    }));
    this.opts = s, this.root = r, this.attachment = vs(this.opts.ref, x => this.root.inputNode = x), Fc(() => this.opts.ref.current, () => {
      const x = this.opts.ref.current;
      x && this.opts.autofocus.current && Z1e(10, () => x.focus())
    }), Fc(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current)
    })
  }
  static create(s) {
    return new Cm(s, Sl.get())
  }
  get props() {
    return g(tr(this, Ah))
  }
  set props(s) {
    G(tr(this, Ah), s)
  }
};
Lp = new WeakMap, Ah = new WeakMap;
let O_ = Cm;
var Ns, Dp, zh, Eh, Lh, Tl, Iy, N_, Dh;
const Am = class Am {
  constructor(s, r) {
    yn(this, Tl);
    vn(this, "opts");
    vn(this, "root");
    vn(this, "attachment");
    yn(this, Ns, null);
    yn(this, Dp, xt(() => {
      var s;
      return this.opts.forceMount.current || ((s = tr(this, Ns)) == null ? void 0 : s.opts.forceMount.current) === !0
    }));
    yn(this, zh, xt(() => {
      if (this.opts.ref.current, g(tr(this, Dp)) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search) return !0;
      const s = this.root.commandState.filtered.items.get(this.trueValue);
      return s === void 0 ? !1 : s > 0
    }));
    yn(this, Eh, xt(() => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
    yn(this, Lh, We(""));
    yn(this, Dh, xt(() => {
      var s;
      return {
        id: this.opts.id.current,
        "aria-disabled": S_(this.opts.disabled.current),
        "aria-selected": S_(this.isSelected),
        "data-disabled": Jv(this.opts.disabled.current),
        "data-selected": Jv(this.isSelected),
        "data-value": this.trueValue,
        "data-group": (s = tr(this, Ns)) == null ? void 0 : s.trueValue,
        [Ba.item]: "",
        role: "option",
        onpointermove: this.onpointermove,
        onclick: this.onclick,
        ...this.attachment
      }
    }));
    this.opts = s, this.root = r, _a(this, Ns, ah.getOr(null)), this.trueValue = s.value.current, this.attachment = vs(this.opts.ref), Fc([() => this.trueValue, () => {
      var x;
      return (x = tr(this, Ns)) == null ? void 0 : x.trueValue
    }, () => this.opts.forceMount.current], () => {
      var x;
      if (!(this.opts.forceMount.current || !this.trueValue)) return this.root.registerItem(this.trueValue, (x = tr(this, Ns)) == null ? void 0 : x.trueValue)
    }), Fc([() => this.opts.value.current, () => this.opts.ref.current], () => {
      var x, A;
      this.opts.value.current ? this.trueValue = this.opts.value.current : (x = this.opts.ref.current) != null && x.textContent && (this.trueValue = this.opts.ref.current.textContent.trim()), this.trueValue && (this.root.registerValue(this.trueValue, s.keywords.current.map(E => E.trim())), (A = this.opts.ref.current) == null || A.setAttribute(gl, this.trueValue))
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this)
  }
  static create(s) {
    const r = ah.getOr(null);
    return new Am({
      ...s,
      group: r
    }, Sl.get())
  }
  get shouldRender() {
    return g(tr(this, zh))
  }
  set shouldRender(s) {
    G(tr(this, zh), s)
  }
  get isSelected() {
    return g(tr(this, Eh))
  }
  set isSelected(s) {
    G(tr(this, Eh), s)
  }
  get trueValue() {
    return g(tr(this, Lh))
  }
  set trueValue(s) {
    G(tr(this, Lh), s, !0)
  }
  onpointermove(s) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || on(this, Tl, N_).call(this)
  }
  onclick(s) {
    this.opts.disabled.current || on(this, Tl, Iy).call(this)
  }
  get props() {
    return g(tr(this, Dh))
  }
  set props(s) {
    G(tr(this, Dh), s)
  }
};
Ns = new WeakMap, Dp = new WeakMap, zh = new WeakMap, Eh = new WeakMap, Lh = new WeakMap, Tl = new WeakSet, Iy = function() {
  var s;
  this.opts.disabled.current || (on(this, Tl, N_).call(this), (s = this.opts.onSelect) == null || s.current())
}, N_ = function() {
  this.opts.disabled.current || this.root.setValue(this.trueValue, !0)
}, Dh = new WeakMap;
let q_ = Am;
var Rh;
const zm = class zm {
  constructor(s, r) {
    vn(this, "opts");
    vn(this, "root");
    vn(this, "attachment");
    yn(this, Rh, xt(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-label": this.opts.ariaLabel.current,
      [Ba.list]: "",
      ...this.attachment
    })));
    this.opts = s, this.root = r, this.attachment = vs(this.opts.ref)
  }
  static create(s) {
    return u2e.set(new zm(s, Sl.get()))
  }
  get props() {
    return g(tr(this, Rh))
  }
  set props(s) {
    G(tr(this, Rh), s)
  }
};
Rh = new WeakMap;
let V_ = zm;
var jh;
const Em = class Em {
  constructor(s, r) {
    vn(this, "opts");
    vn(this, "root");
    vn(this, "attachment");
    yn(this, jh, xt(() => {
      var s;
      return {
        id: this.opts.id.current,
        [Ba["input-label"]]: "",
        for: (s = this.opts.for) == null ? void 0 : s.current,
        style: yy,
        ...this.attachment
      }
    }));
    this.opts = s, this.root = r, this.attachment = vs(this.opts.ref, x => this.root.labelNode = x)
  }
  static create(s) {
    return new Em(s, Sl.get())
  }
  get props() {
    return g(tr(this, jh))
  }
  set props(s) {
    G(tr(this, jh), s)
  }
};
jh = new WeakMap;
let U_ = Em;
var h2e = se("<label><!></label>");

function d2e(d, s) {
  const r = _s();
  Qr(s, !0);
  let x = sr(s, "id", 19, () => ys(r)),
    A = sr(s, "ref", 15, null),
    E = Lr(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
  const k = U_.create({
      id: Un(() => x()),
      ref: Un(() => A(), $ => A($))
    }),
    l = xt(() => gs(E, k.props));
  var j = h2e();
  Dr(j, () => ({
    ...g(l)
  }));
  var W = S(j);
  Ei(W, () => s.children ?? Qa), P(j), O(d, j), en()
}
var p2e = se("<!> <!>", 1),
  f2e = se("<div><!> <!></div>");

function _2e(d, s) {
  const r = _s();
  Qr(s, !0);
  const x = Ue => {
    d2e(Ue, {
      children: (Ke, St) => {
        bn();
        var Ft = vi();
        ze(() => ee(Ft, ce())), O(Ke, Ft)
      },
      $$slots: {
        default: !0
      }
    })
  };
  let A = sr(s, "id", 19, () => ys(r)),
    E = sr(s, "ref", 15, null),
    k = sr(s, "value", 15, ""),
    l = sr(s, "onValueChange", 3, M_),
    j = sr(s, "onStateChange", 3, M_),
    W = sr(s, "loop", 3, !1),
    $ = sr(s, "shouldFilter", 3, !0),
    J = sr(s, "filter", 3, Ay),
    ce = sr(s, "label", 3, ""),
    ge = sr(s, "vimBindings", 3, !0),
    fe = sr(s, "disablePointerSelection", 3, !1),
    Z = sr(s, "disableInitialScroll", 3, !1),
    de = sr(s, "columns", 3, null),
    Fe = Lr(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "onValueChange", "onStateChange", "loop", "shouldFilter", "filter", "label", "vimBindings", "disablePointerSelection", "disableInitialScroll", "columns", "children", "child"]);
  const Re = I_.create({
      id: Un(() => A()),
      ref: Un(() => E(), Ue => E(Ue)),
      filter: Un(() => J()),
      shouldFilter: Un(() => $()),
      loop: Un(() => W()),
      value: Un(() => k(), Ue => {
        k() !== Ue && (k(Ue), l()(Ue))
      }),
      vimBindings: Un(() => ge()),
      disablePointerSelection: Un(() => fe()),
      disableInitialScroll: Un(() => Z()),
      onStateChange: Un(() => j()),
      columns: Un(() => de())
    }),
    Pe = Ue => Re.updateSelectedToIndex(Ue),
    Ge = Ue => Re.updateSelectedByGroup(Ue),
    et = Ue => Re.updateSelectedByItem(Ue),
    Ve = () => Re.getValidItems(),
    ve = xt(() => gs(Fe, Re.props));
  var Me = {
      updateSelectedToIndex: Pe,
      updateSelectedByGroup: Ge,
      updateSelectedByItem: et,
      getValidItems: Ve
    },
    Ye = Ir(),
    Ce = Pt(Ye);
  {
    var Oe = Ue => {
        var Ke = p2e(),
          St = Pt(Ke);
        x(St);
        var Ft = L(St, 2);
        Ei(Ft, () => s.child, () => ({
          props: g(ve)
        })), O(Ue, Ke)
      },
      ut = Ue => {
        var Ke = f2e();
        Dr(Ke, () => ({
          ...g(ve)
        }));
        var St = S(Ke);
        x(St);
        var Ft = L(St, 2);
        Ei(Ft, () => s.children ?? Qa), P(Ke), O(Ue, Ke)
      };
    we(Ce, Ue => {
      s.child ? Ue(Oe) : Ue(ut, !1)
    })
  }
  return O(d, Ye), en(Me)
}
var m2e = se("<div><!></div>");

function g2e(d, s) {
  const r = _s();
  Qr(s, !0);
  let x = sr(s, "id", 19, () => ys(r)),
    A = sr(s, "ref", 15, null),
    E = sr(s, "forceMount", 3, !1),
    k = Lr(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child", "forceMount"]);
  const l = R_.create({
      id: Un(() => x()),
      ref: Un(() => A(), ce => A(ce)),
      forceMount: Un(() => E())
    }),
    j = xt(() => gs(l.props, k));
  var W = Ir(),
    $ = Pt(W);
  {
    var J = ce => {
      var ge = Ir(),
        fe = Pt(ge);
      {
        var Z = Fe => {
            var Re = Ir(),
              Pe = Pt(Re);
            Ei(Pe, () => s.child, () => ({
              props: g(j)
            })), O(Fe, Re)
          },
          de = Fe => {
            var Re = m2e();
            Dr(Re, () => ({
              ...g(j)
            }));
            var Pe = S(Re);
            Ei(Pe, () => s.children ?? Qa), P(Re), O(Fe, Re)
          };
        we(fe, Fe => {
          s.child ? Fe(Z) : Fe(de, !1)
        })
      }
      O(ce, ge)
    };
    we($, ce => {
      l.shouldRender && ce(J)
    })
  }
  O(d, W), en()
}
var v2e = se("<div><!></div>");

function y2e(d, s) {
  const r = _s();
  Qr(s, !0);
  let x = sr(s, "id", 19, () => ys(r)),
    A = sr(s, "ref", 15, null),
    E = sr(s, "value", 3, ""),
    k = sr(s, "forceMount", 3, !1),
    l = Lr(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "forceMount", "children", "child"]);
  const j = j_.create({
      id: Un(() => x()),
      ref: Un(() => A(), fe => A(fe)),
      forceMount: Un(() => k()),
      value: Un(() => E())
    }),
    W = xt(() => gs(l, j.props));
  var $ = Ir(),
    J = Pt($);
  {
    var ce = fe => {
        var Z = Ir(),
          de = Pt(Z);
        Ei(de, () => s.child, () => ({
          props: g(W)
        })), O(fe, Z)
      },
      ge = fe => {
        var Z = v2e();
        Dr(Z, () => ({
          ...g(W)
        }));
        var de = S(Z);
        Ei(de, () => s.children ?? Qa), P(Z), O(fe, Z)
      };
    we(J, fe => {
      s.child ? fe(ce) : fe(ge, !1)
    })
  }
  O(d, $), en()
}
var x2e = se("<div><!></div>");

function b2e(d, s) {
  const r = _s();
  Qr(s, !0);
  let x = sr(s, "id", 19, () => ys(r)),
    A = sr(s, "ref", 15, null),
    E = Lr(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const k = F_.create({
      id: Un(() => x()),
      ref: Un(() => A(), ce => A(ce))
    }),
    l = xt(() => gs(E, k.props));
  var j = Ir(),
    W = Pt(j);
  {
    var $ = ce => {
        var ge = Ir(),
          fe = Pt(ge);
        Ei(fe, () => s.child, () => ({
          props: g(l)
        })), O(ce, ge)
      },
      J = ce => {
        var ge = x2e();
        Dr(ge, () => ({
          ...g(l)
        }));
        var fe = S(ge);
        Ei(fe, () => s.children ?? Qa), P(ge), O(ce, ge)
      };
    we(W, ce => {
      s.child ? ce($) : ce(J, !1)
    })
  }
  O(d, j), en()
}
var w2e = se("<div><!></div>"),
  k2e = se('<div style="display: contents;"><!></div>');

function T2e(d, s) {
  const r = _s();
  Qr(s, !0);
  let x = sr(s, "id", 19, () => ys(r)),
    A = sr(s, "ref", 15, null),
    E = Lr(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const k = B_.create({
      id: Un(() => x()),
      ref: Un(() => A(), ce => A(ce))
    }),
    l = xt(() => gs(E, k.props));
  var j = k2e(),
    W = S(j);
  {
    var $ = ce => {
        var ge = Ir(),
          fe = Pt(ge);
        Ei(fe, () => s.child, () => ({
          props: g(l)
        })), O(ce, ge)
      },
      J = ce => {
        var ge = w2e();
        Dr(ge, () => ({
          ...g(l)
        }));
        var fe = S(ge);
        Ei(fe, () => s.children ?? Qa), P(ge), O(ce, ge)
      };
    we(W, ce => {
      s.child ? ce($) : ce(J, !1)
    })
  }
  P(j), O(d, j), en()
}
var P2e = se("<input/>");

function S2e(d, s) {
  const r = _s();
  Qr(s, !0);
  let x = sr(s, "value", 15, ""),
    A = sr(s, "autofocus", 3, !1),
    E = sr(s, "id", 19, () => ys(r)),
    k = sr(s, "ref", 15, null),
    l = Lr(s, ["$$slots", "$$events", "$$legacy", "value", "autofocus", "id", "ref", "child"]);
  const j = O_.create({
      id: Un(() => E()),
      ref: Un(() => k(), fe => k(fe)),
      value: Un(() => x(), fe => {
        x(fe)
      }),
      autofocus: Un(() => A() ?? !1)
    }),
    W = xt(() => gs(l, j.props));
  var $ = Ir(),
    J = Pt($);
  {
    var ce = fe => {
        var Z = Ir(),
          de = Pt(Z);
        Ei(de, () => s.child, () => ({
          props: g(W)
        })), O(fe, Z)
      },
      ge = fe => {
        var Z = P2e();
        Dr(Z, () => ({
          ...g(W)
        }), void 0, void 0, void 0, void 0, !0), Oc(Z, x), O(fe, Z)
      };
    we(J, fe => {
      s.child ? fe(ce) : fe(ge, !1)
    })
  }
  O(d, $), en()
}
var M2e = se("<div><!></div>"),
  I2e = se('<div style="display: contents;" data-item-wrapper=""><!></div>');

function C2e(d, s) {
  const r = _s();
  Qr(s, !0);
  let x = sr(s, "id", 19, () => ys(r)),
    A = sr(s, "ref", 15, null),
    E = sr(s, "value", 3, ""),
    k = sr(s, "disabled", 3, !1),
    l = sr(s, "onSelect", 3, M_),
    j = sr(s, "forceMount", 3, !1),
    W = sr(s, "keywords", 19, () => []),
    $ = Lr(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "disabled", "children", "child", "onSelect", "forceMount", "keywords"]);
  const J = q_.create({
      id: Un(() => x()),
      ref: Un(() => A(), Z => A(Z)),
      value: Un(() => E()),
      disabled: Un(() => k()),
      onSelect: Un(() => l()),
      forceMount: Un(() => j()),
      keywords: Un(() => W())
    }),
    ce = xt(() => gs($, J.props));
  var ge = Ir(),
    fe = Pt(ge);
  kl(fe, () => J.root.key, Z => {
    var de = I2e(),
      Fe = S(de);
    {
      var Re = Pe => {
        var Ge = Ir(),
          et = Pt(Ge);
        {
          var Ve = Me => {
              var Ye = Ir(),
                Ce = Pt(Ye);
              Ei(Ce, () => s.child, () => ({
                props: g(ce)
              })), O(Me, Ye)
            },
            ve = Me => {
              var Ye = M2e();
              Dr(Ye, () => ({
                ...g(ce)
              }));
              var Ce = S(Ye);
              Ei(Ce, () => s.children ?? Qa), P(Ye), O(Me, Ye)
            };
          we(et, Me => {
            s.child ? Me(Ve) : Me(ve, !1)
          })
        }
        O(Pe, Ge)
      };
      we(Fe, Pe => {
        J.shouldRender && Pe(Re)
      })
    }
    P(de), ze(() => or(de, "data-value", J.trueValue)), O(Z, de)
  }), O(d, ge), en()
}
var A2e = se("<div><!></div>");

function z2e(d, s) {
  const r = _s();
  Qr(s, !0);
  let x = sr(s, "id", 19, () => ys(r)),
    A = sr(s, "ref", 15, null),
    E = Lr(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "aria-label"]);
  const k = V_.create({
      id: Un(() => x()),
      ref: Un(() => A(), $ => A($)),
      ariaLabel: Un(() => s["aria-label"] ?? "Suggestions...")
    }),
    l = xt(() => gs(E, k.props));
  var j = Ir(),
    W = Pt(j);
  kl(W, () => k.root._commandState.search === "", $ => {
    var J = Ir(),
      ce = Pt(J);
    {
      var ge = Z => {
          var de = Ir(),
            Fe = Pt(de);
          Ei(Fe, () => s.child, () => ({
            props: g(l)
          })), O(Z, de)
        },
        fe = Z => {
          var de = A2e();
          Dr(de, () => ({
            ...g(l)
          }));
          var Fe = S(de);
          Ei(Fe, () => s.children ?? Qa), P(de), O(Z, de)
        };
      we(ce, Z => {
        s.child ? Z(ge) : Z(fe, !1)
      })
    }
    O($, J)
  }), O(d, j), en()
}
const t0 = 1,
  E2e = .9,
  L2e = .8,
  D2e = .17,
  o_ = .1,
  s_ = .999,
  R2e = .9999,
  j2e = .99,
  F2e = /[\\/_+.#"@[({&]/,
  B2e = /[\\/_+.#"@[({&]/g,
  O2e = /[\s-]/,
  Cy = /[\s-]/g;

function Z_(d, s, r, x, A, E, k) {
  if (E === s.length) return A === d.length ? t0 : j2e;
  const l = `${A},${E}`;
  if (k[l] !== void 0) return k[l];
  const j = x.charAt(E);
  let W = r.indexOf(j, A),
    $ = 0,
    J, ce, ge, fe;
  for (; W >= 0;) J = Z_(d, s, r, x, W + 1, E + 1, k), J > $ && (W === A ? J *= t0 : F2e.test(d.charAt(W - 1)) ? (J *= L2e, ge = d.slice(A, W - 1).match(B2e), ge && A > 0 && (J *= s_ ** ge.length)) : O2e.test(d.charAt(W - 1)) ? (J *= E2e, fe = d.slice(A, W - 1).match(Cy), fe && A > 0 && (J *= s_ ** fe.length)) : (J *= D2e, A > 0 && (J *= s_ ** (W - A))), d.charAt(W) !== s.charAt(E) && (J *= R2e)), (J < o_ && r.charAt(W - 1) === x.charAt(E + 1) || x.charAt(E + 1) === x.charAt(E) && r.charAt(W - 1) !== x.charAt(E)) && (ce = Z_(d, s, r, x, W + 1, E + 2, k), ce * o_ > J && (J = ce * o_)), J > $ && ($ = J), W = r.indexOf(j, W + 1);
  return k[l] = $, $
}

function r0(d) {
  return d.toLowerCase().replace(Cy, " ")
}

function Ay(d, s, r) {
  return d = r && r.length > 0 ? `${`${d} ${r==null?void 0:r.join(" ")}`}` : d, Z_(d, s, r0(d), r0(s), 0, 0, {})
}

function Vc(...d) {
  return V1(sp(d))
}

function q2e(d, s) {
  Qr(s, !0);
  let r = sr(s, "ref", 15, null),
    x = sr(s, "value", 15, ""),
    A = Lr(s, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
  var E = Ir(),
    k = Pt(E);
  {
    let l = xt(() => Vc("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", s.class));
    ka(k, () => _2e, (j, W) => {
      W(j, qc({
        "data-slot": "command",
        get class() {
          return g(l)
        }
      }, () => A, {
        get value() {
          return x()
        },
        set value($) {
          x($)
        },
        get ref() {
          return r()
        },
        set ref($) {
          r($)
        }
      }))
    })
  }
  O(d, E), en()
}

function N2e(d, s) {
  Qr(s, !0);
  let r = sr(s, "ref", 15, null),
    x = Lr(s, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var A = Ir(),
    E = Pt(A);
  {
    let k = xt(() => Vc("py-6 text-center text-sm", s.class));
    ka(E, () => g2e, (l, j) => {
      j(l, qc({
        "data-slot": "command-empty",
        get class() {
          return g(k)
        }
      }, () => x, {
        get ref() {
          return r()
        },
        set ref(W) {
          r(W)
        }
      }))
    })
  }
  O(d, A), en()
}
var V2e = se("<!> <!>", 1);

function U2e(d, s) {
  Qr(s, !0);
  let r = sr(s, "ref", 15, null),
    x = Lr(s, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "heading", "value"]);
  var A = Ir(),
    E = Pt(A);
  {
    let k = xt(() => Vc("text-foreground overflow-hidden p-1", s.class)),
      l = xt(() => s.value ?? s.heading ?? `----${s2e()}`);
    ka(E, () => y2e, (j, W) => {
      W(j, qc({
        "data-slot": "command-group",
        get class() {
          return g(k)
        },
        get value() {
          return g(l)
        }
      }, () => x, {
        get ref() {
          return r()
        },
        set ref($) {
          r($)
        },
        children: ($, J) => {
          var ce = V2e(),
            ge = Pt(ce);
          {
            var fe = de => {
              var Fe = Ir(),
                Re = Pt(Fe);
              ka(Re, () => b2e, (Pe, Ge) => {
                Ge(Pe, {
                  class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                  children: (et, Ve) => {
                    bn();
                    var ve = vi();
                    ze(() => ee(ve, s.heading)), O(et, ve)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), O(de, Fe)
            };
            we(ge, de => {
              s.heading && de(fe)
            })
          }
          var Z = L(ge, 2);
          ka(Z, () => T2e, (de, Fe) => {
            Fe(de, {
              get children() {
                return s.children
              }
            })
          }), O($, ce)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  O(d, A), en()
}

function Z2e(d, s) {
  Qr(s, !0);
  let r = sr(s, "ref", 15, null),
    x = Lr(s, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var A = Ir(),
    E = Pt(A);
  {
    let k = xt(() => Vc("aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", s.class));
    ka(E, () => C2e, (l, j) => {
      j(l, qc({
        "data-slot": "command-item",
        get class() {
          return g(k)
        }
      }, () => x, {
        get ref() {
          return r()
        },
        set ref(W) {
          r(W)
        }
      }))
    })
  }
  O(d, A), en()
}
var G2e = se('<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>');

function $2e(d, s) {
  Qr(s, !0);
  let r = sr(s, "ref", 15, null),
    x = sr(s, "value", 15, ""),
    A = Lr(s, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var E = G2e(),
    k = S(E);
  _1(k, {
    class: "size-5 opacity-50"
  });
  var l = L(k, 2);
  {
    let j = xt(() => Vc("placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", s.class));
    ka(l, () => S2e, (W, $) => {
      $(W, qc({
        "data-slot": "command-input",
        get class() {
          return g(j)
        }
      }, () => A, {
        get ref() {
          return r()
        },
        set ref(J) {
          r(J)
        },
        get value() {
          return x()
        },
        set value(J) {
          x(J)
        }
      }))
    })
  }
  P(E), O(d, E), en()
}

function W2e(d, s) {
  Qr(s, !0);
  let r = sr(s, "ref", 15, null),
    x = Lr(s, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var A = Ir(),
    E = Pt(A);
  {
    let k = xt(() => Vc("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", s.class));
    ka(E, () => z2e, (l, j) => {
      j(l, qc({
        "data-slot": "command-list",
        get class() {
          return g(k)
        }
      }, () => x, {
        get ref() {
          return r()
        },
        set ref(W) {
          r(W)
        }
      }))
    })
  }
  O(d, A), en()
}
var H2e = $r('<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>');

function X2e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = H2e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var Y2e = se("<span> </span> <!>", 1),
  K2e = se('<span class="font-flag ml-0.5"> </span> ', 1),
  J2e = se('<span class="flex gap-1.5"><span class="font-flag"> </span> </span>'),
  Q2e = se("<!> <!>", 1),
  ewe = se("<!> <!>", 1),
  twe = se('<button class="btn btn-xs btn-circle btn-ghost"><!></button>'),
  rwe = se('<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>');

function n0(d, s) {
  Qr(s, !0);
  let r = sr(s, "countryId", 15, 0),
    x = sr(s, "dropdownDirection", 3, "right"),
    A = We(null),
    E = We(null),
    k = We("");

  function l() {
    Y_().then(() => {
      var Pe;
      (Pe = document.activeElement) == null || Pe.blur(), G(k, "")
    })
  }
  var j = rwe(),
    W = S(j),
    $ = S(W),
    J = S($);
  {
    var ce = Pe => {
        var Ge = Y2e(),
          et = Pt(Ge),
          Ve = S(et, !0);
        P(et);
        var ve = L(et, 2);
        X2e(ve, {
          class: "size-3.5"
        }), ze(Me => ee(Ve, Me), [() => lm()]), O(Pe, Ge)
      },
      ge = Pe => {
        const Ge = xt(() => qo(r()));
        var et = K2e(),
          Ve = Pt(et),
          ve = S(Ve, !0);
        P(Ve);
        var Me = L(Ve);
        ze(() => {
          ee(ve, g(Ge).flag), ee(Me, ` ${g(Ge).name??""}`)
        }), O(Pe, et)
      };
    we(J, Pe => {
      r() === 0 ? Pe(ce) : Pe(ge, !1)
    })
  }
  P($);
  var fe = L($, 2);
  let Z;
  var de = S(fe);
  ka(de, () => q2e, (Pe, Ge) => {
    Ge(Pe, {
      children: (et, Ve) => {
        var ve = ewe(),
          Me = Pt(ve);
        ka(Me, () => $2e, (Ce, Oe) => {
          Oe(Ce, {
            placeholder: "Country",
            get ref() {
              return g(A)
            },
            set ref(ut) {
              G(A, ut)
            },
            get value() {
              return g(k)
            },
            set value(ut) {
              G(k, ut, !0)
            }
          })
        });
        var Ye = L(Me, 2);
        ka(Ye, () => W2e, (Ce, Oe) => {
          Oe(Ce, {
            children: (ut, Ue) => {
              var Ke = Q2e(),
                St = Pt(Ke);
              ka(St, () => N2e, (Jt, Mt) => {
                Mt(Jt, {
                  children: (ct, wt) => {
                    bn();
                    var ft = vi();
                    ze($t => ee(ft, $t), [() => XF()]), O(ct, ft)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              });
              var Ft = L(St, 2);
              ka(Ft, () => U2e, (Jt, Mt) => {
                Mt(Jt, {
                  children: (ct, wt) => {
                    var ft = Ir(),
                      $t = Pt(ft);
                    li($t, 17, () => Ia.countries, Et => Et.id, (Et, Qt) => {
                      var vr = Ir(),
                        Kt = Pt(vr);
                      ka(Kt, () => Z2e, (Bt, it) => {
                        it(Bt, {
                          get value() {
                            return g(Qt).name
                          },
                          onSelect: () => {
                            r(g(Qt).id), l()
                          },
                          children: (He, Ot) => {
                            var Gt = J2e(),
                              kt = S(Gt),
                              nr = S(kt, !0);
                            P(kt);
                            var It = L(kt);
                            P(Gt), ze(() => {
                              ee(nr, g(Qt).flag), ee(It, ` ${g(Qt).name??""}`)
                            }), O(He, Gt)
                          },
                          $$slots: {
                            default: !0
                          }
                        })
                      }), O(Et, vr)
                    }), O(ct, ft)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), O(ut, Ke)
            },
            $$slots: {
              default: !0
            }
          })
        }), O(et, ve)
      },
      $$slots: {
        default: !0
      }
    })
  }), P(fe), P(W);
  var Fe = L(W, 2);
  {
    var Re = Pe => {
      var Ge = twe();
      Ge.__click = () => {
        r(0)
      };
      var et = S(Ge);
      ms(et, {
        class: "size-3.5"
      }), P(Ge), O(Pe, Ge)
    };
    we(Fe, Pe => {
      r() != 0 && Pe(Re)
    })
  }
  P(j), oo(j, Pe => G(E, Pe), () => g(E)), ze(() => Z = Or(fe, 1, "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm", null, Z, {
    "right-1": x() === "left"
  })), Pn("focus", $, () => {
    g(A).focus()
  }), O(d, j), en()
}
Yn(["click"]);
var nwe = $r('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>');

function zy(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = nwe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var iwe = $r('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>'),
  awe = $r('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function oh(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Ir(),
    A = Pt(x);
  {
    var E = l => {
        var j = iwe();
        Dr(j, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), O(l, j)
      },
      k = l => {
        var j = awe();
        Dr(j, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), O(l, j)
      };
    we(A, l => {
      s.filled ? l(E) : l(k, !1)
    })
  }
  O(d, x)
}
var owe = se('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  swe = se('<div class="mb-2"><!></div>'),
  lwe = se('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  cwe = se('<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>'),
  uwe = se('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>'),
  hwe = se('<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  dwe = se('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>'),
  pwe = se('<span class="font-flag tooltip ml-0.5"> </span>'),
  fwe = se("<span> </span>"),
  _we = se('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  mwe = se('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  gwe = se('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  vwe = se('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  ywe = se('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  xwe = se('<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>', 1);

function bwe(d, s) {
  Qr(s, !0);
  const r = [];
  let x = We(1e3);
  const A = xt(() => g(x) <= 640);
  let E = We("today"),
    k = {
      regions: {
        label: gW(),
        icon: wl
      },
      countries: {
        label: gS(),
        icon: zy
      },
      players: {
        label: B0(),
        icon: Np
      },
      alliances: {
        label: P0(),
        icon: Vp
      }
    },
    l = We("regions"),
    j = We(0),
    W = Pi({
      players: {},
      alliances: {},
      regions: {},
      countries: {}
    }),
    $ = xt(() => {
      var ve, Me, Ye;
      return g(l) === "regions" ? (Me = (ve = W[g(l)][g(j)]) == null ? void 0 : ve[g(E)]) == null ? void 0 : Me.entries : (Ye = W[g(l)][g(E)]) == null ? void 0 : Ye.entries
    });
  const J = 5 * 1e3;
  rn(() => {
    var Ce;
    if (!s.open) return;
    const ve = g(E),
      Me = g(l),
      Ye = g(j);
    Me === "players" && (!W[Me][ve] || Date.now() - W[Me][ve].time > J) ? pn.leaderboardPlayers(ve).then(Oe => {
      W[Me][ve] = {
        time: Date.now(),
        entries: Oe
      }
    }).catch(Oe => rr.error(Oe.message)) : Me === "alliances" && (!W[Me][ve] || Date.now() - W[Me][ve].time > J) ? pn.leaderboardAlliances(ve).then(Oe => {
      W[Me][ve] = {
        time: Date.now(),
        entries: Oe
      }
    }).catch(Oe => rr.error(Oe.message)) : Me === "countries" && (!W[Me][ve] || Date.now() - W[Me][ve].time > J) ? pn.leaderboardCountries(ve).then(Oe => {
      W[Me][ve] = {
        time: Date.now(),
        entries: Oe
      }
    }).catch(Oe => rr.error(Oe.message)) : Me === "regions" && (!((Ce = W[Me][Ye]) != null && Ce[ve]) || Date.now() - W[Me][Ye][ve].time > J) && pn.leaderboardRegions(ve, Ye).then(Oe => {
      W[Me][Ye] || (W[Me][Ye] = {}), W[Me][Ye][ve] = {
        time: Date.now(),
        entries: Oe
      }
    }).catch(Oe => rr.error(Oe.message))
  });
  var ce = xwe(),
    ge = Pt(ce);
  li(ge, 21, () => Object.entries(k), ([ve, {
    label: Me,
    icon: Ye
  }]) => ve, (ve, Me) => {
    var Ye = xt(() => u0(g(Me), 2));
    let Ce = () => g(Ye)[0],
      Oe = () => g(Ye)[1].label,
      ut = () => g(Ye)[1].icon;
    const Ue = xt(ut);
    var Ke = owe(),
      St = S(Ke);
    sa(St);
    var Ft, Jt = L(St, 2);
    ka(Jt, () => g(Ue), (ct, wt) => {
      wt(ct, {
        get this() {
          return ut()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var Mt = L(Jt);
    P(Ke), ze(() => {
      or(St, "aria-label", Oe()), Ft !== (Ft = Ce()) && (St.value = (St.__value = Ce()) ?? ""), ee(Mt, ` ${Oe()??""}`)
    }), Q_(r, [], St, () => (Ce(), g(l)), ct => G(l, ct)), O(ve, Ke)
  }), P(ge);
  var fe = L(ge, 2),
    Z = S(fe);
  vm(Z, {
    get value() {
      return g(E)
    },
    set value(ve) {
      G(E, ve, !0)
    }
  });
  var de = L(Z, 2);
  {
    var Fe = ve => {
      n0(ve, {
        dropdownDirection: "left",
        get countryId() {
          return g(j)
        },
        set countryId(Me) {
          G(j, Me, !0)
        }
      })
    };
    we(de, ve => {
      g(l) === "regions" && !g(A) && ve(Fe)
    })
  }
  P(fe);
  var Re = L(fe, 2);
  {
    var Pe = ve => {
      var Me = swe(),
        Ye = S(Me);
      n0(Ye, {
        get countryId() {
          return g(j)
        },
        set countryId(Ce) {
          G(j, Ce, !0)
        }
      }), P(Me), O(ve, Me)
    };
    we(Re, ve => {
      g(l) === "regions" && g(A) && ve(Pe)
    })
  }
  var Ge = L(Re, 2);
  {
    var et = ve => {
        var Me = lwe(),
          Ye = S(Me),
          Ce = L(Ye);
        {
          var Oe = Ue => {
              var Ke = vi();
              ze(St => ee(Ke, St), [() => qp().toLowerCase()]), O(Ue, Ke)
            },
            ut = Ue => {
              var Ke = Ir(),
                St = Pt(Ke);
              {
                var Ft = Mt => {
                    var ct = vi();
                    ze(wt => ee(ct, wt), [() => hm()]), O(Mt, ct)
                  },
                  Jt = Mt => {
                    var ct = Ir(),
                      wt = Pt(ct);
                    {
                      var ft = $t => {
                        var Et = vi();
                        ze(Qt => ee(Et, Qt), [() => um()]), O($t, Et)
                      };
                      we(wt, $t => {
                        g(E) === "month" && $t(ft)
                      }, !0)
                    }
                    O(Mt, ct)
                  };
                we(St, Mt => {
                  g(E) === "week" ? Mt(Ft) : Mt(Jt, !1)
                }, !0)
              }
              O(Ue, Ke)
            };
          we(Ce, Ue => {
            g(E) === "today" ? Ue(Oe) : Ue(ut, !1)
          })
        }
        P(Me), ze(Ue => ee(Ye, `${Ue??""} `), [() => cm()]), O(ve, Me)
      },
      Ve = ve => {
        var Me = Ir(),
          Ye = Pt(Me);
        {
          var Ce = ut => {
              var Ue = Ir(),
                Ke = Pt(Ue);
              {
                var St = Jt => {
                    const Mt = xt(() => g($));
                    var ct = uwe(),
                      wt = S(ct),
                      ft = S(wt),
                      $t = L(S(ft)),
                      Et = S($t, !0);
                    P($t);
                    var Qt = L($t),
                      vr = S(Qt),
                      Kt = L(vr, 2),
                      Bt = L(Kt),
                      it = S(Bt);
                    oh(it, {
                      class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                    }), P(Bt), P(Qt), bn(), P(ft), P(wt);
                    var He = L(wt);
                    li(He, 31, () => g(Mt), Ot => Ot.id, (Ot, Gt, kt) => {
                      const nr = xt(() => qo(g(Gt).countryId));
                      var It = cwe(),
                        mt = S(It),
                        yt = S(mt, !0);
                      P(mt);
                      var bt = L(mt),
                        Lt = S(bt),
                        st = S(Lt, !0);
                      P(Lt);
                      var lr = L(Lt, 2),
                        gr = S(lr),
                        dr = L(gr),
                        pr = S(dr);
                      P(dr), P(lr), P(bt);
                      var Ht = L(bt),
                        Sr = S(Ht, !0);
                      P(Ht);
                      var Rr = L(Ht),
                        Vt = S(Rr);
                      Vt.__click = () => {
                        s.onvisitclick({
                          lat: g(Gt).lastLatitude,
                          lng: g(Gt).lastLongitude
                        })
                      };
                      var Tr = S(Vt, !0);
                      P(Vt), P(Rr), P(It), ze((Xt, ue, N) => {
                        ee(yt, g(kt) + 1), or(Lt, "data-tip", g(nr).name), ee(st, g(nr).flag), Or(lr, 1, `font-semibold ${Xt??""}`), ee(gr, `${g(Gt).name??""} `), ee(pr, `#${g(Gt).number??""}`), ee(Sr, ue), ee(Tr, N)
                      }, [() => ta(g(Gt).cityId), () => g(Gt).pixelsPainted.toLocaleString("en-US"), () => lp()]), vl(It, () => yl, () => ({
                        duration: 200
                      })), O(Ot, It)
                    }), P(He), P(ct), ze((Ot, Gt, kt, nr) => {
                      ee(Et, Ot), ee(vr, `${Gt??""} `), ee(Kt, `${kt??""} `), or(Bt, "data-tip", nr)
                    }, [() => iW(), () => xl(), () => Ac().toLowerCase(), () => dZ()]), O(Jt, ct)
                  },
                  Ft = Jt => {
                    var Mt = Ir(),
                      ct = Pt(Mt);
                    {
                      var wt = $t => {
                          var Et = dwe(),
                            Qt = S(Et),
                            vr = S(Qt),
                            Kt = L(S(vr)),
                            Bt = S(Kt, !0);
                          P(Kt);
                          var it = L(Kt),
                            He = S(it),
                            Ot = L(He, 2),
                            Gt = L(Ot),
                            kt = S(Gt);
                          oh(kt, {
                            class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                          }), P(Gt), P(it), P(vr), P(Qt);
                          var nr = L(Qt);
                          li(nr, 31, () => g($), It => It.id, (It, mt, yt) => {
                            const bt = xt(() => qo(g(mt).id) ?? {
                              name: `Pais ID: ${g(mt).id}`,
                              flag: "ğŸ³ï¸",
                              code: "XX"
                            });
                            var Lt = hwe(),
                              st = S(Lt),
                              lr = S(st, !0);
                            P(st);
                            var gr = L(st),
                              dr = S(gr),
                              pr = S(dr, !0);
                            P(dr);
                            var Ht = L(dr, 2),
                              Sr = S(Ht, !0);
                            P(Ht), P(gr);
                            var Rr = L(gr),
                              Vt = S(Rr, !0);
                            P(Rr), P(Lt), ze((Tr, Xt) => {
                              ee(lr, g(yt) + 1), or(dr, "data-tip", g(bt).name), ee(pr, g(bt).flag), Or(Ht, 1, `font-semibold ${Tr??""}`), ee(Sr, g(bt).name), ee(Vt, Xt)
                            }, [() => ta(g(mt).id), () => g(mt).pixelsPainted.toLocaleString("en-US")]), vl(Lt, () => yl, () => ({
                              duration: 200
                            })), O(It, Lt)
                          }), P(nr), P(Et), ze((It, mt, yt, bt) => {
                            ee(Bt, It), ee(He, `${mt??""} `), ee(Ot, `${yt??""} `), or(Gt, "data-tip", bt)
                          }, [() => lm(), () => xl(), () => Ac().toLowerCase(), () => QU()]), O($t, Et)
                        },
                        ft = $t => {
                          var Et = Ir(),
                            Qt = Pt(Et);
                          {
                            var vr = Bt => {
                                const it = xt(() => g($));
                                var He = mwe(),
                                  Ot = S(He),
                                  Gt = S(Ot),
                                  kt = L(S(Gt)),
                                  nr = S(kt, !0);
                                P(kt);
                                var It = L(kt),
                                  mt = S(It),
                                  yt = L(mt, 2, !0);
                                P(It), P(Gt), P(Ot);
                                var bt = L(Ot);
                                li(bt, 31, () => g(it), Lt => Lt.id, (Lt, st, lr) => {
                                  const gr = xt(() => {
                                    var he;
                                    return ((he = Rt.data) == null ? void 0 : he.id) === g(st).id
                                  });
                                  var dr = _we();
                                  let pr;
                                  var Ht = S(dr),
                                    Sr = S(Ht, !0);
                                  P(Ht);
                                  var Rr = L(Ht),
                                    Vt = S(Rr),
                                    Tr = S(Vt);
                                  Fa(Tr, {
                                    class: "size-8 border sm:size-10",
                                    get userId() {
                                      return g(st).id
                                    },
                                    get pictureUrl() {
                                      return g(st).picture
                                    },
                                    get borderUrl() {
                                      return g(st).frameUrl
                                    }
                                  });
                                  var Xt = L(Tr, 2),
                                    ue = S(Xt),
                                    N = S(ue),
                                    q = L(N),
                                    X = S(q);
                                  P(q), P(ue);
                                  var te = L(ue, 2);
                                  {
                                    var le = he => {
                                      const Q = xt(() => qo(g(st).equippedFlag));
                                      var Ze = Ir(),
                                        vt = Pt(Ze);
                                      {
                                        var Qe = oe => {
                                          var De = pwe(),
                                            Je = S(De, !0);
                                          P(De), ze(() => {
                                            or(De, "data-tip", g(Q).name), ee(Je, g(Q).flag)
                                          }), O(oe, De)
                                        };
                                        we(vt, oe => {
                                          g(Q) && oe(Qe)
                                        })
                                      }
                                      O(he, Ze)
                                    };
                                    we(te, he => {
                                      g(st).equippedFlag && he(le)
                                    })
                                  }
                                  var xe = L(te, 2);
                                  {
                                    var je = he => {
                                      Nh(he, {
                                        get username() {
                                          return g(st).discord
                                        },
                                        get id() {
                                          return g(st).discordId
                                        }
                                      })
                                    };
                                    we(xe, he => {
                                      g(st).discord && he(je)
                                    })
                                  }
                                  var Ie = L(xe, 2);
                                  {
                                    var qe = he => {
                                      var Q = fwe(),
                                        Ze = S(Q, !0);
                                      P(Q), ze((vt, Qe) => {
                                        Or(Q, 1, `badge badge-sm ml-0.5 border-0 ${vt??""} ${Qe??""}`), ee(Ze, g(st).allianceName)
                                      }, [() => jp(g(st).allianceId), () => ta(g(st).allianceId)]), O(he, Q)
                                    };
                                    we(Ie, he => {
                                      "allianceName" in g(st) && g(st).allianceName && he(qe)
                                    })
                                  }
                                  P(Xt), P(Vt), P(Rr);
                                  var rt = L(Rr),
                                    Xe = S(rt, !0);
                                  P(rt), P(dr), ze((he, Q) => {
                                    pr = Or(dr, 1, "", null, pr, {
                                      "bg-base-200": g(gr)
                                    }), ee(Sr, g(lr) + 1), Or(ue, 1, `font-semibold max-sm:ml-2 ${he??""} flex gap-1`), ee(N, `${g(st).name??""} `), ee(X, `#${g(st).id??""}`), ee(Xe, Q)
                                  }, [() => ta(g(st).id), () => g(st).pixelsPainted.toLocaleString("en-US")]), vl(dr, () => yl, () => ({
                                    duration: 200
                                  })), O(Lt, dr)
                                }), P(bt), P(He), ze((Lt, st, lr) => {
                                  ee(nr, Lt), ee(mt, `${st??""} `), ee(yt, lr)
                                }, [() => nm(), () => xl(), () => Ac().toLowerCase()]), O(Bt, He)
                              },
                              Kt = Bt => {
                                var it = Ir(),
                                  He = Pt(it);
                                {
                                  var Ot = Gt => {
                                    var kt = vwe(),
                                      nr = S(kt),
                                      It = S(nr),
                                      mt = L(S(It)),
                                      yt = S(mt, !0);
                                    P(mt);
                                    var bt = L(mt),
                                      Lt = S(bt),
                                      st = L(Lt, 2, !0);
                                    P(bt), P(It), P(nr);
                                    var lr = L(nr);
                                    li(lr, 31, () => g($), gr => gr.id, (gr, dr, pr) => {
                                      const Ht = xt(() => {
                                        var te;
                                        return ((te = Rt.data) == null ? void 0 : te.allianceId) === g(dr).id
                                      });
                                      var Sr = gwe();
                                      let Rr;
                                      var Vt = S(Sr),
                                        Tr = S(Vt, !0);
                                      P(Vt);
                                      var Xt = L(Vt),
                                        ue = S(Xt),
                                        N = S(ue, !0);
                                      P(ue), P(Xt);
                                      var q = L(Xt),
                                        X = S(q, !0);
                                      P(q), P(Sr), ze((te, le) => {
                                        Rr = Or(Sr, 1, "", null, Rr, {
                                          "bg-base-200": g(Ht)
                                        }), ee(Tr, g(pr) + 1), Or(ue, 1, `font-semibold ${te??""}`), ee(N, g(dr).name), ee(X, le)
                                      }, [() => ta(g(dr).id), () => g(dr).pixelsPainted.toLocaleString("en-US")]), vl(Sr, () => yl, () => ({
                                        duration: 200
                                      })), O(gr, Sr)
                                    }), P(lr), P(kt), ze((gr, dr, pr) => {
                                      ee(yt, gr), ee(Lt, `${dr??""} `), ee(st, pr)
                                    }, [() => Bp(), () => xl(), () => Ac().toLowerCase()]), O(Gt, kt)
                                  };
                                  we(He, Gt => {
                                    g(l) === "alliances" && Gt(Ot)
                                  }, !0)
                                }
                                O(Bt, it)
                              };
                            we(Qt, Bt => {
                              g(l) === "players" ? Bt(vr) : Bt(Kt, !1)
                            }, !0)
                          }
                          O($t, Et)
                        };
                      we(ct, $t => {
                        g(l) === "countries" ? $t(wt) : $t(ft, !1)
                      }, !0)
                    }
                    O(Jt, Mt)
                  };
                we(Ke, Jt => {
                  g(l) === "regions" ? Jt(St) : Jt(Ft, !1)
                })
              }
              O(ut, Ue)
            },
            Oe = ut => {
              var Ue = ywe();
              O(ut, Ue)
            };
          we(Ye, ut => {
            g($) ? ut(Ce) : ut(Oe, !1)
          }, !0)
        }
        O(ve, Me)
      };
    we(Ge, ve => {
      g($) && g($).length === 0 ? ve(et) : ve(Ve, !1)
    })
  }
  Fh("innerWidth", ve => G(x, ve, !0)), O(d, ce), en()
}
Yn(["click"]);
var wwe = $r('<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>');

function Ey(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = wwe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var kwe = se('<dialog class="modal" closedby="any"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Twe(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15);
  var x = kwe(),
    A = S(x),
    E = L(S(A), 2),
    k = S(E);
  Ey(k, {
    class: "size-6"
  });
  var l = L(k, 2),
    j = S(l, !0);
  P(l), P(E);
  var W = L(E, 2),
    $ = S(W);
  bwe($, {
    get onvisitclick() {
      return s.onvisitclick
    },
    get open() {
      return r()
    }
  }), P(W), P(A), bn(2), P(x), Li(x, () => J => {
    rn(() => {
      r() ? J.show() : J.close()
    })
  }), ze(J => ee(j, J), [() => am()]), Pn("close", x, () => r(!1)), O(d, x), en()
}
var Pwe = se("<div><!></div>"),
  Swe = se('<dialog class="modal" closedby="any"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Mwe(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15);
  var x = Swe(),
    A = S(x),
    E = L(S(A), 2);
  {
    var k = l => {
      var j = Pwe(),
        W = S(j);
      Y1(W, {}), P(j), oa(2, j, () => Ka, () => ({
        duration: 300
      })), O(l, j)
    };
    we(E, l => {
      r() && l(k)
    })
  }
  P(A), bn(2), P(x), Li(x, () => l => {
    rn(() => {
      r() ? l.show() : l.close()
    })
  }), Pn("close", x, () => r(!1)), O(d, x), en()
}
var Iwe = se("<p>You don't have charges to paint. <br/> </p>");

function Cwe(d, s) {
  Qr(s, !1), em();
  var r = Iwe(),
    x = L(S(r), 2);
  P(r), ze(A => ee(x, ` Next charge in ${A??""}`), [() => py(Rt.cooldown ?? 0)]), O(d, r), en()
}
var Awe = se('<form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form>'),
  zwe = se('<form method="dialog" class="modal-backdrop"><button> </button></form>'),
  Ewe = se('<dialog closedby="any"><div><!> <!></div> <!></dialog>');

function bm(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = sr(s, "hasBackdrop", 3, !0),
    A = sr(s, "hasCloseButton", 3, !0);
  var E = Ewe(),
    k = S(E),
    l = S(k);
  {
    var j = ce => {
      var ge = Awe();
      O(ce, ge)
    };
    we(l, ce => {
      A() && ce(j)
    })
  }
  var W = L(l, 2);
  Ei(W, () => s.children ?? Qa), P(k);
  var $ = L(k, 2);
  {
    var J = ce => {
      var ge = zwe(),
        fe = S(ge),
        Z = S(fe, !0);
      P(fe), P(ge), ze(de => ee(Z, de), [() => Ja()]), O(ce, ge)
    };
    we($, ce => {
      x() && ce(J)
    })
  }
  P(E), Li(E, () => ce => {
    rn(() => {
      r() ? ce.show() : ce.close()
    })
  }), ze(() => {
    Or(E, 1, `modal ${s.dialogClass??""}`), Or(k, 1, `modal-box ${s.modalBoxClass??""}`)
  }), Pn("close", E, () => r(!1)), O(d, E), en()
}
var Lwe = se('<div class="flex h-full flex-col gap-4"><span class="text-xl font-semibold"> </span> <span><!></span> <button class="btn btn-primary mx-auto w-max px-10"> </button></div>');

function Dwe(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = sr(s, "buttonText", 3, "OK");
  bm(d, {
    dialogClass: "!bg-black/80",
    modalBoxClass: "max-h-11/12",
    get open() {
      return r()
    },
    set open(A) {
      r(A)
    },
    children: (A, E) => {
      var k = Lwe(),
        l = S(k),
        j = S(l, !0);
      P(l);
      var W = L(l, 2),
        $ = S(W);
      Ei($, () => s.message), P(W);
      var J = L(W, 2);
      J.__click = () => {
        r(!1)
      };
      var ce = S(J, !0);
      P(J), P(k), ze(() => {
        ee(j, s.title), ee(ce, x())
      }), O(A, k)
    },
    $$slots: {
      default: !0
    }
  }), en()
}
Yn(["click"]);

function Rwe(d) {
  const s = new Date;
  return d.getDate() === s.getDate() && d.getMonth() === s.getMonth() && d.getFullYear() === s.getFullYear() ? d.toLocaleTimeString(void 0, {
    timeStyle: "short"
  }) : d.toLocaleDateString(void 0, {
    dateStyle: "medium"
  })
}
var jwe = se('<span class="size-2 rounded-full bg-red-400"></span>'),
  Fwe = se('<button class="hover:bg-base-content/10 flex gap-3 px-6 py-3"><div class="bg-primary/30 flex size-10 min-h-10 min-w-10 items-center justify-center rounded-full"><!></div> <div class="grow text-sm"><div class="flex items-baseline justify-between"><h3 class="font-semibold"> </h3> <div class="text-base-content/80 flex items-center gap-1.5 text-xs"><span> </span> <!></div></div> <p class="mt-0.5 text-left"> </p></div></button>');

function Bwe(d, s) {
  Qr(s, !0);
  let r = sr(s, "read", 15);
  var x = Fwe();
  x.__click = () => {
    r(!0), s.onclick()
  };
  var A = S(x),
    E = S(A);
  Ei(E, () => s.icon), P(A);
  var k = L(A, 2),
    l = S(k),
    j = S(l),
    W = S(j, !0);
  P(j);
  var $ = L(j, 2),
    J = S($),
    ce = S(J, !0);
  P(J);
  var ge = L(J, 2);
  {
    var fe = Fe => {
      var Re = jwe();
      O(Fe, Re)
    };
    we(ge, Fe => {
      r() || Fe(fe)
    })
  }
  P($), P(l);
  var Z = L(l, 2),
    de = S(Z, !0);
  P(Z), P(k), P(x), ze(Fe => {
    ee(W, s.title), ee(ce, Fe), ee(de, s.message)
  }, [() => Rwe(s.createdAt)]), O(d, x), en()
}
Yn(["click"]);
var Owe = $r('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h168q13-36 43.5-58t68.5-22q38 0 68.5 22t43.5 58h168q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm80-80h280v-80H280v80Zm0-160h400v-80H280v80Zm0-160h400v-80H280v80Zm200-190q13 0 21.5-8.5T510-820q0-13-8.5-21.5T480-850q-13 0-21.5 8.5T450-820q0 13 8.5 21.5T480-790ZM200-200v-560 560Z"></path></svg>');

function qwe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Owe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var Nwe = se('<button class="btn btn-sm btn-ghost"> </button>'),
  Vwe = se('<p class="text-base-content/80 mt-4 text-center text-sm"> </p>'),
  Uwe = se("<!> <!>", 1),
  Zwe = se('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  Gwe = se('<div class="flex items-center justify-between gap-2 px-6"><h3 class="text-xl font-bold"> </h3> <!></div> <section class="mt-4"><!> <!></section>', 1),
  $we = se("<p> </p>"),
  Wwe = se("<!> <!>", 1);

function Hwe(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = We(!1),
    A = We(void 0),
    E = We(void 0),
    k = We(!1);
  var l = Wwe(),
    j = Pt(l);
  bm(j, {
    modalBoxClass: "h-11/12 max-h-11/12 px-0",
    get open() {
      return r()
    },
    set open($) {
      r($)
    },
    children: ($, J) => {
      var ce = Gwe(),
        ge = Pt(ce),
        fe = S(ge),
        Z = S(fe, !0);
      P(fe);
      var de = L(fe, 2);
      {
        var Fe = ve => {
          var Me = Nwe();
          Me.__click = async () => {
            if (pn.postNotificationMarkReadAll(), Rt.notificiationCount = 0, g(A))
              for (const Ce of g(A)) Ce.read = !0
          };
          var Ye = S(Me, !0);
          P(Me), ze(Ce => ee(Ye, Ce), [() => _j()]), O(ve, Me)
        };
        we(de, ve => {
          Rt.notificiationCount !== 0 && ve(Fe)
        })
      }
      P(ge);
      var Re = L(ge, 2),
        Pe = S(Re);
      {
        var Ge = ve => {
          var Me = Uwe(),
            Ye = Pt(Me);
          li(Ye, 17, () => g(A), ut => ut.id, (ut, Ue, Ke) => {
            var St = Ir(),
              Ft = Pt(St);
            {
              var Jt = Mt => {
                {
                  const ct = Et => {
                    qwe(Et, {
                      class: "size-5"
                    })
                  };
                  let wt = xt(() => Pv()),
                    ft = xt(() => Sv()),
                    $t = xt(() => new Date(g(Ue).createdAt));
                  Bwe(Mt, {
                    get title() {
                      return g(wt)
                    },
                    get message() {
                      return g(ft)
                    },
                    get createdAt() {
                      return g($t)
                    },
                    onclick: () => {
                      G(k, !0)
                    },
                    get read() {
                      return g(Ue).read
                    },
                    set read(Et) {
                      g(Ue).read = Et
                    },
                    icon: ct,
                    $$slots: {
                      icon: !0
                    }
                  })
                }
              };
              we(Ft, Mt => {
                g(Ue).type === "report_feedback" && Mt(Jt)
              })
            }
            O(ut, St)
          });
          var Ce = L(Ye, 2);
          {
            var Oe = ut => {
              var Ue = Vwe(),
                Ke = S(Ue, !0);
              P(Ue), ze(St => ee(Ke, St), [() => v9()]), O(ut, Ue)
            };
            we(Ce, ut => {
              g(A).length === 0 && !g(x) && ut(Oe)
            })
          }
          O(ve, Me)
        };
        we(Pe, ve => {
          g(A) && ve(Ge)
        })
      }
      var et = L(Pe, 2);
      {
        var Ve = ve => {
          var Me = Zwe();
          Li(Me, () => Ye => {
            const Ce = new IntersectionObserver(Oe => {
              Oe[0].isIntersecting && !g(x) && (G(x, !0), pn.getNotificationPage(g(E)).then(ut => {
                G(A, [...g(A) ?? [], ...ut.notifications], !0), G(E, ut.nextCursor, !0);
                const Ue = ut.notifications.filter(Ke => !Ke.read).map(Ke => Ke.id);
                Ue.length > 0 && (pn.postNotificationMarkRead(Ue), Rt.notificiationCount && (Rt.notificiationCount = Math.max(0, Ue.length - Ue.length)))
              }).catch(ut => {
                rr.error(ut.message)
              }).finally(() => {
                G(x, !1)
              }))
            });
            return Ce.observe(Ye), () => {
              Ce.disconnect()
            }
          }), O(ve, Me)
        };
        we(et, ve => {
          r() && (g(A) === void 0 || g(E) !== void 0) && ve(Ve)
        })
      }
      P(Re), ze(ve => ee(Z, ve), [() => j0()]), O($, ce)
    },
    $$slots: {
      default: !0
    }
  });
  var W = L(j, 2);
  {
    const $ = ce => {
      var ge = $we(),
        fe = S(ge);
      P(ge), ze((Z, de) => ee(fe, `${Z??""} ${de??""}`), [() => Sv(), () => eH()]), O(ce, ge)
    };
    let J = xt(() => Pv());
    Dwe(W, {
      get title() {
        return g(J)
      },
      get open() {
        return g(k)
      },
      set open(ce) {
        G(k, ce, !0)
      },
      message: $,
      $$slots: {
        message: !0
      }
    })
  }
  O(d, l), en()
}
Yn(["click"]);
var Xwe = se("<canvas></canvas>");

function Ly(d, s) {
  Qr(s, !0);
  let r = sr(s, "width", 15, 0),
    x = Lr(s, ["$$slots", "$$events", "$$legacy", "value", "fontSize", "color", "weight", "mono", "width"]),
    A = xt(() => Math.ceil(s.fontSize)),
    E = We(null);
  const k = window.devicePixelRatio ?? 1,
    l = '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
    j = '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  rn(() => {
    const $ = g(E).getContext("2d");
    $.textBaseline = "top", $.font = `${s.weight??"normal"} ${s.fontSize}px ${s.mono?j:l}`, $.fillStyle = s.color ?? "#394e6a", $.setTransform(k, 0, 0, k, 0, 0), $.clearRect(0, 0, r(), g(A)), $.fillText(s.value, 0, 0);
    const J = $.measureText(s.value);
    r(Math.ceil(J.actualBoundingBoxRight)), G(A, J.actualBoundingBoxDescent)
  });
  var W = Xwe();
  Dr(W, () => ({
    width: r() * k,
    height: g(A) * k,
    style: `width: ${r()??""}px; height: ${g(A)??""}px`,
    ...x
  })), oo(W, $ => G(E, $), () => g(E)), O(d, W), en()
}
var Ywe = se('<span class="w-7 text-xs"> </span>'),
  Kwe = se('<span class="flex items-center gap-1 sm:mt-px"><span><!></span> <!></span>'),
  Jwe = se('<span class="loading loading-spinner center-absolute absolute"></span>'),
  Qwe = se('<button><div class="flex items-center gap-1.5"><!> <div class="flex items-center gap-2 whitespace-nowrap"> <!></div></div> <!></button>');

function Dy(d, s) {
  Qr(s, !0);
  let r = Lr(s, ["$$slots", "$$events", "$$legacy", "loading", "charges", "maxWidth"]),
    x = We(0),
    A = We(null),
    E = We(void 0);
  fs(() => [s.loading, s.maxWidth], () => {
    G(E, void 0), requestAnimationFrame(() => {
      const Z = g(A).offsetWidth;
      !s.loading && s.maxWidth !== void 0 && Z + 20 > s.maxWidth ? G(E, 16 * (s.maxWidth / Z) * .8) : G(E, void 0)
    })
  });
  var k = Qwe();
  Dr(k, () => ({
    ...r,
    class: `btn btn-primary btn-lg sm:btn-xl relative ${s.class??""}`,
    style: `max-width: ${s.maxWidth?`${s.maxWidth}px`:"none"}
	${g(E)?`;font-size: ${g(E)}px`:""}`
  }));
  var l = S(k),
    j = S(l);
  Pl(j, {
    class: "size-6"
  });
  var W = L(j, 2),
    $ = S(W),
    J = L($);
  {
    var ce = Z => {
      const de = xt(() => `${Math.floor(s.charges)}/${Rt.data.charges.max}`);
      var Fe = Kwe(),
        Re = S(Fe),
        Pe = S(Re);
      {
        let Ve = xt(() => g(E) ?? 16),
          ve = xt(() => s.disabled ? "#394e6a33" : "#ffffff");
        Ly(Pe, {
          weight: 600,
          get fontSize() {
            return g(Ve)
          },
          get value() {
            return g(de)
          },
          get color() {
            return g(ve)
          },
          get width() {
            return g(x)
          },
          set width(Me) {
            G(x, Me, !0)
          }
        })
      }
      P(Re);
      var Ge = L(Re, 2);
      {
        var et = Ve => {
          var ve = Ywe(),
            Me = S(ve);
          P(ve), ze(Ye => ee(Me, `(${Ye??""})`), [() => py(Rt.cooldown)]), O(Ve, ve)
        };
        we(Ge, Ve => {
          s.charges < Rt.data.charges.max && Rt.cooldown !== void 0 && Ve(et)
        })
      }
      P(Fe), ze(Ve => Io(Re, `width: ${Ve??""}px`), [() => (Math.floor(g(x) / 5) + 1) * 5]), O(Z, Fe)
    };
    we(J, Z => {
      s.charges !== void 0 && Rt.data && Z(ce)
    })
  }
  P(W), P(l), oo(l, Z => G(A, Z), () => g(A));
  var ge = L(l, 2);
  {
    var fe = Z => {
      var de = Jwe();
      O(Z, de)
    };
    we(ge, Z => {
      s.loading && Z(fe)
    })
  }
  P(k), ze(Z => ee($, `${Z??""} `), [() => F0()]), O(d, k), en()
}
const e5e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII=",
  t5e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC",
  r5e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC",
  n5e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
class i5e {
  constructor(s) {
    vn(this, "gm");
    vn(this, "opacity", 1);
    vn(this, "id", `paint-preview-${Math.random()}`);
    vn(this, "tiles", new Map);
    this.input = s, this.gm = new ja(this.input.tileSize)
  }
  place([s, r], x) {
    const {
      tile: A,
      pixel: E
    } = this.gm.latLonToTileAndPixel(s, r, this.input.tileZoom), k = this.getTileKey(A[0], A[1]);
    let l = this.tiles.get(k);
    if (!l) {
      const j = this.gm.tileBoundsLatLon(A[0], A[1], this.input.tileZoom),
        W = dm(j, !0),
        $ = new a5e({
          coordinates: W,
          id: `${this.id}-${k}`,
          layerPaint: {
            "raster-opacity": this.opacity,
            "raster-resampling": "nearest"
          },
          tileSize: this.input.tileSize,
          beforeLayerId: this.input.beforeLayerId
        });
      $.addTo(this.input.map), this.tiles.set(k, $), l = $
    }
    l.place(E[0], this.input.tileSize - E[1] - 1, x)
  }
  clear() {
    const s = this.input.map;
    for (const r of this.tiles.values()) r.removeFrom(s), r.removeDOM();
    this.tiles.clear()
  }
  clearAndPlace(s, r) {
    this.clear(), this.place(s, r)
  }
  remove([s, r]) {
    const {
      tile: x,
      pixel: A
    } = this.gm.latLonToTileAndPixel(s, r, this.input.tileZoom), E = this.getTileKey(x[0], x[1]), k = this.tiles.get(E);
    k && k.remove(A[0], this.input.tileSize - A[1] - 1)
  }
  setCanvasOpacity(s) {
    this.opacity = s;
    for (const r of this.tiles.values()) r.setOpacity(s)
  }
  getTileKey(s, r) {
    return `${s},${r}`
  }
}
class a5e {
  constructor(s) {
    vn(this, "canvas");
    vn(this, "maps", new Set);
    this.input = s;
    const r = this.input.tileSize;
    this.canvas = document.createElement("canvas"), this.canvas.width = r, this.canvas.height = r
  }
  place(s, r, x) {
    var k;
    const A = ((k = Ia.colors) == null ? void 0 : k[x]) ?? Ia.colors[0],
      E = this.canvas.getContext("2d");
    if (E) {
      const l = E.createImageData(1, 1),
        [j, W, $] = A.rgb,
        J = x === 0 ? 0 : 255;
      l.data[0] = j, l.data[1] = W, l.data[2] = $, l.data[3] = J, E.putImageData(l, s, r)
    }
  }
  remove(s, r) {
    const x = this.canvas.getContext("2d");
    x && x.clearRect(s, r, 1, 1)
  }
  addTo(s) {
    const r = this.input.id;
    s.getSource(r) || s.addSource(r, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), s.getLayer(r) || (s.addLayer({
      id: r,
      type: "raster",
      source: r,
      paint: this.input.layerPaint
    }), this.input.beforeLayerId && s.moveLayer(r, this.input.beforeLayerId)), this.maps.add(s)
  }
  removeFrom(s) {
    const {
      id: r
    } = this.input;
    s.getLayer(r) && s.removeLayer(r), s.getSource(r) && s.removeSource(r), this.maps.delete(s)
  }
  removeDOM() {
    this.canvas.remove()
  }
  setOpacity(s) {
    for (const r of this.maps.values()) r.setPaintProperty(this.input.id, "raster-opacity", s)
  }
}
var o5e = $r('<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>');

function s5e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = o5e();
  Dr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...r
  })), O(d, x)
}
var l5e = $r('<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>');

function c5e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = l5e();
  Dr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...r
  })), O(d, x)
}
var u5e = se("<div><!></div>");

function Cc(d, s) {
  Qr(s, !0);
  var r = u5e(),
    x = S(r);
  Ei(x, () => s.children ?? Qa), P(r), ze(() => Or(r, 1, `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${s.class??""}`)), O(d, r), en()
}
var h5e = se('<div class="confetti svelte-av71ki"></div>'),
  d5e = se("<div></div>");

function wm(d, s) {
  Qr(s, !0);
  const r = sr(s, "size", 3, 10),
    x = sr(s, "x", 19, () => [-.5, .5]),
    A = sr(s, "y", 19, () => [.25, 1]),
    E = sr(s, "duration", 3, 2e3),
    k = sr(s, "infinite", 3, !1),
    l = sr(s, "delay", 19, () => [0, 50]),
    j = sr(s, "colorRange", 19, () => [0, 360]),
    W = sr(s, "colorArray", 19, () => []),
    $ = sr(s, "amount", 3, 50),
    J = sr(s, "iterationCount", 3, 1),
    ce = sr(s, "fallDistance", 3, "100px"),
    ge = sr(s, "rounded", 3, !1),
    fe = sr(s, "cone", 3, !1),
    Z = sr(s, "noGravity", 3, !1),
    de = sr(s, "xSpread", 3, .15),
    Fe = sr(s, "destroyOnComplete", 3, !0),
    Re = sr(s, "disableForReducedMotion", 3, !1);
  let Pe = We(!1);
  Wi(() => {
    !Fe() || k() || typeof J() == "string" || setTimeout(() => G(Pe, !0), (E() + l()[1]) * J())
  });

  function Ge(Ye, Ce) {
    return Math.random() * (Ce - Ye) + Ye
  }

  function et() {
    return W().length ? W()[Math.round(Math.random() * (W().length - 1))] : `hsl(${Math.round(Ge(j()[0],j()[1]))}, 75%, 50%)`
  }
  var Ve = Ir(),
    ve = Pt(Ve);
  {
    var Me = Ye => {
      var Ce = d5e();
      let Oe;
      li(Ce, 21, () => ({
        length: $()
      }), Bc, (ut, Ue) => {
        var Ke = h5e();
        ze((St, Ft, Jt, Mt, ct, wt, ft, $t, Et, Qt, vr) => Io(Ke, `
        --color: ${St??""};
        --skew: ${Ft??""}deg,${Jt??""}deg;
        --rotation-xyz: ${Mt??""}, ${ct??""}, ${wt??""};
        --rotation-deg: ${ft??""}deg;
        --translate-y-multiplier: ${$t??""};
        --translate-x-multiplier: ${Et??""};
        --scale: ${Qt??""};
        --transition-delay: ${vr??""}ms;
        --transition-duration: ${k()?`calc(${E()}ms * var(--scale))`:`${E()}ms`};`), [et, () => Ge(-45, 45), () => Ge(-45, 45), () => Ge(-10, 10), () => Ge(-10, 10), () => Ge(-10, 10), () => Ge(0, 360), () => Ge(A()[0], A()[1]), () => Ge(x()[0], x()[1]), () => .1 * Ge(2, 10), () => Ge(l()[0], l()[1])]), O(ut, Ke)
      }), P(Ce), ze(() => {
        Oe = Or(Ce, 1, "confetti-holder svelte-av71ki", null, Oe, {
          rounded: ge(),
          cone: fe(),
          "no-gravity": Z(),
          "reduced-motion": Re()
        }), Io(Ce, `
    --fall-distance: ${ce()??""};
    --size: ${r()??""}px;
    --x-spread: ${1-de()};
    --transition-iteration-count: ${(k()?"infinite":J())??""};`)
      }), O(Ye, Ce)
    };
    we(ve, Ye => {
      g(Pe) || Ye(Me)
    })
  }
  O(d, Ve), en()
}
var p5e = se('<span class="loading loading-spinner center-absolute absolute"></span>'),
  f5e = se('<!> <span class="text-sm">Droplets</span>', 1),
  _5e = se('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1),
  m5e = se('<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>'),
  g5e = se('<dialog class="modal bg-black/80!" closedby="any"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function v5e(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15);
  const x = xt(() => Ia.colors[s.colorIdx]),
    A = xt(() => {
      var ge;
      return ((ge = Rt.data) == null ? void 0 : ge.droplets) ?? 0
    });
  let E = We(!1);
  const k = xt(() => (g(E), Rt.hasColor(s.colorIdx))),
    l = 100,
    j = Ia.products[l];
  var W = g5e(),
    $ = S(W),
    J = L(S($), 2);
  {
    var ce = ge => {
      var fe = m5e(),
        Z = S(fe),
        de = S(Z),
        Fe = S(de);
      Cp(Fe, {
        class: "size-6"
      });
      var Re = L(Fe, 4),
        Pe = S(Re);
      f0(Pe, {
        get value() {
          return g(A)
        }
      }), P(Re), P(de), bn(2), P(Z);
      var Ge = L(Z, 2),
        et = S(Ge),
        Ve = S(et);
      P(et);
      var ve = L(et, 2),
        Me = S(ve, !0);
      P(ve);
      var Ye = L(ve, 2),
        Ce = S(Ye);
      let Oe;
      var ut = S(Ce);
      ut.__click = async () => {
        try {
          G(E, !0), await pn.purchase({
            id: l,
            amount: 1,
            variant: s.colorIdx
          }), await Rt.refresh(), gi.notification1.play()
        } catch (ct) {
          rr.error(ct.message)
        } finally {
          G(E, !1)
        }
      };
      var Ue = S(ut);
      {
        var Ke = ct => {
          var wt = p5e();
          O(ct, wt)
        };
        we(Ue, ct => {
          g(E) && ct(Ke)
        })
      }
      var St = L(Ue, 2);
      {
        var Ft = ct => {
            var wt = f5e(),
              ft = Pt(wt);
            Rp(ft, {
              class: "size-5"
            });
            var $t = L(ft);
            bn(), ze(Et => ee($t, ` ${Et??""} `), [() => j.price.toLocaleString("en-US")]), O(ct, wt)
          },
          Jt = ct => {
            var wt = _5e(),
              ft = Pt(wt);
            Cp(ft, {
              class: "size-5"
            });
            var $t = L(ft, 2),
              Et = S($t);
            wm(Et, {}), P($t), O(ct, wt)
          };
        we(St, ct => {
          g(k) ? ct(Jt, !1) : ct(Ft)
        })
      }
      P(ut), P(Ce);
      var Mt = L(Ce, 2);
      Mt.__click = () => r(!1), P(Ye), P(Ge), P(fe), ze(ct => {
        Io(Ve, `background: rgb(${g(x).rgb[0]} ${g(x).rgb[1]} ${g(x).rgb[2]})`), or(Ve, "aria-label", g(x).name), ee(Me, g(x).name), or(Ce, "data-tip", ct), Oe = Or(Ce, 1, "", null, Oe, {
          tooltip: !g(k) && g(A) < j.price
        }), ut.disabled = g(A) < j.price || g(E) || g(k)
      }, [() => Op()]), O(ge, fe)
    };
    we(J, ge => {
      Rt.data && ge(ce)
    })
  }
  P($), bn(2), P(W), Li(W, () => ge => {
    rn(() => {
      r() ? ge.show() : ge.close()
    })
  }), Pn("close", W, () => r(!1)), O(d, W), en()
}
Yn(["click"]);
var y5e = $r('<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>');

function i0(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = y5e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var x5e = $r('<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>');

function Ry(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = x5e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var b5e = $r('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>'),
  w5e = $r('<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>');

function jy(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Ir(),
    A = Pt(x);
  {
    var E = l => {
        var j = b5e();
        Dr(j, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), O(l, j)
      },
      k = l => {
        var j = w5e();
        Dr(j, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), O(l, j)
      };
    we(A, l => {
      s.filled ? l(E) : l(k, !1)
    })
  }
  O(d, x)
}
var k5e = $r('<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>');

function G_(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = k5e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var T5e = $r('<svg><path d="M396-200q-97 0-166.5-63T160-420q0-94 69.5-157T396-640h252L544-744l56-56 200 200-200 200-56-56 104-104H396q-63 0-109.5 40T240-420q0 60 46.5 100T396-280h284v80H396Z"></path></svg>');

function P5e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = T5e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var S5e = $r('<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>');

function Fy(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = S5e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var M5e = $r('<svg><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"></path></svg>');

function I5e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = M5e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var C5e = se("<!> ", 1),
  A5e = se("<!> ", 1),
  z5e = se("<!> ", 1),
  E5e = se('<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ', 1),
  L5e = se("<!> ", 1),
  D5e = se('<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>', 1),
  R5e = se("<div><button><!></button></div>"),
  j5e = se('<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1.5"><h2 class="sm:min-w-38 select-none text-xl"> <!></h2> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip max-sm:hidden"><button title="Toggle art opacity"><!></button></div> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">Ctrl+Z</kbd></div> <button title="Undo"><!></button></div> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">Ctrl+Y</kbd></div> <button title="Redo"><!></button></div></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>', 1);

function F5e(d, s) {
  var Sn, Vr;
  Qr(s, !0);
  let r = sr(s, "screenLocked", 15),
    x = sr(s, "opaquePixelArt", 15);
  const A = xt(() => new ja(s.tileSize));
  let E = We(1),
    k = We("pencil");
  const l = new Map,
    j = new Map;
  let W = We(0),
    $ = We(!1),
    J = We(!0),
    ce = xt(() => Rt.charges ?? 0),
    ge = xt(() => g(ce) - g(W)),
    fe = We(!1),
    Z = !1,
    de = We(!1);
  const Fe = xt(() => g(k) === "pencil"),
    Re = xt(() => g(k) === "eraser"),
    Pe = xt(() => g(k) === "colorpicker");
  let Ge = We(!1),
    et = We(0),
    Ve = We(void 0),
    ve = We(void 0);
  const Me = [1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42, 12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49, 23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52, 61, 62, 63, 58, 59, 60, 0].map(Le => ({
      ...Ia.colors[Le],
      idx: Le,
      label: xv[Le]()
    })),
    Ye = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0].map(Le => ({
      ...Ia.colors[Le],
      idx: Le,
      label: xv[Le]()
    }));
  let Ce = We(!1);
  const Oe = xt(() => g(Ce) ? Me : Ye),
    ut = "show-all-colors";
  Wi(() => {
    G(Ce, localStorage.getItem(ut) === "true")
  }), rn(() => {
    localStorage.setItem(ut, g(Ce) ? "true" : "false")
  });
  const Ue = "selected-color";
  Wi(() => {
    const Le = Number(localStorage.getItem(Ue));
    !isNaN(Le) && Le < Ia.colors.length && Le > 0 && G(E, Le, !0)
  }), rn(() => {
    localStorage.setItem(Ue, g(E).toString())
  });
  const Ke = new i5e({
    map: s.map,
    tileSize: s.tileSize,
    tileZoom: s.tileZoom,
    beforeLayerId: s.hoverLayerId
  });
  rn(() => {
    const Le = x() ? 1 : 0;
    Ke.setCanvasOpacity(Le)
  }), rn(() => {
    x() ? u_() : ft([...l.values()])
  });
  let St = !1;
  Wi(() => {
    Fo(s.map.getCenter(), s.map.getZoom());
    const Le = s.map.on("click", Wr => {
      var wn;
      s.zoom < s.tileZoom + 2 && ((wn = Rt.data) == null ? void 0 : wn.role) === "user" && s.map.easeTo({
        center: Wr.lngLat,
        zoom: 17
      });
      const jr = [Wr.lngLat.lat, Wr.lngLat.lng];
      g(Fe) ? (Jt([jr], g(E)), kt.finishAction()) : g(Re) ? (Mt([jr]), kt.finishAction()) : g(Pe) && ct(jr, Wr.point), G(fe, !0)
    });

    function tt(Wr, jr) {
      const wn = g(A).latLonToPixels(Wr.lat, Wr.lng, s.tileZoom),
        En = jr ? g(A).latLonToPixels(jr.lat, jr.lng, s.tileZoom) : wn;
      return b1(wn, En).map(qn => g(A).pixelsToLatLon(qn[0] + .5, qn[1] + .5, s.tileZoom))
    }

    function qt(Wr, jr) {
      const wn = tt(Wr, jr);
      g(Fe) ? Jt(wn, g(E)) : g(Re) && Mt(wn), G(fe, !0)
    }
    let Ut;

    function fr(Wr) {
      const jr = s.map.unproject([Wr.clientX, Wr.clientY]);
      if (g(de)) {
        const wn = tt(jr, Ut);
        Mt(wn)
      }(St || Z) && qt(jr, Ut), Ut = jr
    }
    window.addEventListener("mousemove", fr);
    let Wt = !1;
    const yr = s.map.on("touchstart", Wr => {
        if (Wr.points.length == 2) {
          r(!1), vr(), Wt = !0, setTimeout(() => Wt = !1, 150);
          return
        }
        r() && setTimeout(() => {
          !Wt && qt(Wr.lngLat)
        }, 150), Ut = Wr.lngLat
      }),
      tn = s.map.on("touchend", () => {
        kt.finishAction()
      }),
      Kr = s.map.on("touchmove", Wr => {
        r() && qt(Wr.lngLat, Ut), Ut = Wr.lngLat
      }),
      Br = Wr => {
        Wr.code === "Space" && (St || Ut && qt(Ut), St = !0, Wr.preventDefault())
      };
    document.addEventListener("keydown", Br);
    const Cr = Wr => {
      Wr.code === "Space" && (St = !1, Ft = !1, kt.finishAction(), g(W) === 0 && g(Re) && G(k, "pencil"))
    };
    document.addEventListener("keyup", Cr);

    function Yr(Wr) {
      if (Wr.button === 2) {
        G(de, !0);
        const wn = s.map.unproject([Wr.clientX, Wr.clientY]);
        Mt([
          [wn.lat, wn.lng]
        ])
      }
    }
    document.addEventListener("mousedown", Yr);

    function Ln(Wr) {
      Wr.button === 2 && G(de, !1)
    }
    document.addEventListener("mouseup", Ln);
    const In = Wr => {
      switch (Wr.code) {
        case "KeyE":
          g(W) > 0 && (g(Re) ? G(k, "pencil") : G(k, "eraser"));
          return;
        case "KeyI":
          G(k, "colorpicker");
          return
      }
    };
    return document.addEventListener("keypress", In), () => {
      Kr.unsubscribe(), yr.unsubscribe(), tn.unsubscribe(), Le.unsubscribe(), document.removeEventListener("mousemove", fr), document.removeEventListener("keydown", Br), document.removeEventListener("keyup", Cr), document.removeEventListener("keypress", In), document.removeEventListener("mousedown", Yr), document.removeEventListener("mouseup", Ln), $t()
    }
  });
  let Ft = !1;

  function Jt(Le, tt, qt = !0) {
    let Ut = !1;
    const fr = tt === 0;
    for (let Wt of Le) {
      const [yr, tn] = Wt, Kr = kp(tt), {
        tile: Br,
        pixel: Cr
      } = g(A).latLonToTileAndPixel(yr, tn, s.tileZoom), Yr = {
        color: Kr,
        tile: Br,
        pixel: Cr,
        season: s.season,
        colorIdx: tt
      }, Ln = Jf(Yr), In = l.get(Ln), Wr = g(ce) - l.size;
      if (!In && Wr < 1) {
        if (Ft && (St || r())) continue;
        Ft = !0, rr.info(LB());
        continue
      }
      if (!(In && In.colorIdx === tt) && (gi.plop.play(), Ut || s.hidePixelHover(), l.set(Ln, Yr), Ke.place(Wt, tt), s.crosshair.place(Wt), Ut = !0, fr && j.set(Ln, Yr), qt)) {
        const jr = {
            type: "paint",
            latLons: [Wt],
            colorIdx: tt
          },
          wn = In ? {
            type: "paint",
            latLons: [Wt],
            colorIdx: In.colorIdx
          } : {
            type: "erase",
            latLons: [Wt]
          };
        kt.saveAction(jr, wn)
      }
    }
    G(W, l.size, !0), Ut && !x() ? ft([...l.values()]) : Ut && x() && fr && ft([...j.values()])
  }

  function Mt(Le, tt = !0) {
    let qt = !1,
      Ut = !1;
    for (let fr of Le) {
      const [Wt, yr] = fr, {
        tile: tn,
        pixel: Kr
      } = g(A).latLonToTileAndPixel(Wt, yr, s.tileZoom), Br = Jf({
        tile: tn,
        pixel: Kr,
        season: s.season
      }), Cr = l.get(Br);
      Cr && (gi.plop.play(), s.hidePixelHover(), l.delete(Br), j.delete(Br), Ke.remove([Wt, yr]), s.crosshair.remove(fr), qt = !0, Cr.colorIdx === 0 && (Ut = !0), tt && kt.saveAction({
        type: "erase",
        latLons: [fr]
      }, {
        type: "paint",
        latLons: [fr],
        colorIdx: Cr.colorIdx
      })), l.size === 0 && !(St || Z || r()) && G(k, "pencil")
    }
    G(W, l.size, !0), qt && !x() ? ft([...l.values()]) : qt && x() && Ut && ft([...j.values()])
  }

  function ct(Le, tt) {
    const {
      tile: qt,
      pixel: Ut
    } = g(A).latLonToTileAndPixel(Le[0], Le[1], s.tileZoom), fr = Jf({
      tile: qt,
      pixel: Ut,
      season: s.season
    }), Wt = l.get(fr);
    if (Wt) {
      Kt(Wt.colorIdx), requestAnimationFrame(() => {
        var Br;
        (Br = document.getElementById(`color-${Wt.colorIdx}`)) == null || Br.focus()
      });
      return
    }
    const yr = window.devicePixelRatio,
      tn = Math.floor(tt.x * yr),
      Kr = Math.floor(tt.y * yr);
    s.hidePixelHover(), Qxe(s.map, tn, Kr).then(([Br, Cr, Yr]) => {
      const Ln = m0({
        r: Br,
        g: Cr,
        b: Yr
      });
      Kt(Ln), requestAnimationFrame(() => {
        var In;
        (In = document.getElementById(`color-${Ln}`)) == null || In.focus()
      })
    })
  }
  fs(() => g(E), () => {
    s.clickedLatLon && !g(fe) && (g(E) === void 0 && G(E, 1), Jt([s.clickedLatLon], g(E)))
  }), rn(() => {
    const Le = g(J) ? .8 : 0;
    s.crosshair.setCanvasOpacity(Le)
  });
  let wt = We(16.5);
  rn(() => {
    if (g(Ve) && g(ve) && s.clickedLatLon) {
      const Le = s.map.getZoom();
      if (Le < g(wt)) {
        const [tt, qt] = s.clickedLatLon, Ut = g(A).latLonToPixelBoundsLatLon(tt, qt, s.tileZoom), fr = pm(Ut), Wt = g(Ve) - g(ve).clientHeight, yr = g(Ve) / 2 - Wt / 2;
        s.map.flyTo({
          center: {
            lat: fr[0],
            lng: fr[1]
          },
          zoom: 17.5,
          offset: Le > 11 ? [0, -yr] : [0, 0]
        })
      }
      G(wt, s.tileZoom, !0)
    }
  }), Wi(() => {
    const Le = () => {
      !document.hidden && (x() ? ft([...j.values()]) : ft([...l.values()]))
    };
    return document.addEventListener("visibilitychange", Le), () => document.removeEventListener("visibilitychange", Le)
  }), rn(() => {
    switch (g(k)) {
      case "pencil":
        s.map.getCanvas().style.cursor = `url('${r5e}') 8 8, default`, s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", .4);
        return;
      case "colorpicker":
        s.map.getCanvas().style.cursor = `url('${e5e}') 0 16, default`, s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", 0);
        return;
      case "eraser":
        s.map.getCanvas().style.cursor = `url('${t5e}') 2 14, default`, s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", .4);
        return
    }
  }), rn(() => {
    r() ? Qt() : vr()
  });
  async function ft(Le) {
    await f1(Le), s.refreshPixelArt()
  }
  async function $t() {
    await u_(), Ke.clear(), s.refreshPixelArt(), s.crosshair.clear()
  }
  async function Et() {
    await $t(), vr(), s.map.getCanvas().style.cursor = "default", s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", .4), kt.clear(), s.onclose()
  }

  function Qt() {
    s.map.dragPan.disable(), s.map.touchZoomRotate.disable(), document.documentElement.style.overscrollBehavior = "none"
  }

  function vr() {
    s.map.dragPan.enable(), s.map.touchZoomRotate.enable(), document.documentElement.style.overscrollBehavior = ""
  }

  function Kt(Le) {
    return Le >= 32 && G(Ce, !0), Rt.hasColor(Le) ? (gi.smallDropplet.play(), G(E, Le, !0), G(k, "pencil"), !0) : (gi.smallDropplet.play(), G(Ge, !0), G(et, Le, !0), !1)
  }
  n1(Le => {
    Le.type === "leave" && g(W) > 0 && Le.cancel()
  });
  const Bt = "show-paint-more-than-one-pixel-msg";
  let it = We(!1);
  Wi(() => {
    var Le;
    G(it, !localStorage.getItem(Bt) && (((Le = Rt.data) == null ? void 0 : Le.pixelsPainted) ?? 0) < 100, !0)
  }), rn(() => {
    g(W) > 1 && (G(it, !1), localStorage.setItem(Bt, "false"))
  });
  const He = "lp";
  Wi(() => {
    var tt;
    const Le = localStorage.getItem(He);
    if (Le) try {
      const qt = JSON.parse(atob(Le)),
        Ut = (qt == null ? void 0 : qt.time) ?? 0,
        fr = 60 * 1e3;
      (qt == null ? void 0 : qt.userId) !== ((tt = Rt.data) == null ? void 0 : tt.id) && Date.now() - Ut < 30 * fr && !d2 && (rr.error(a9()), Et())
    } catch (qt) {
      console.error(qt)
    }
  });

  function Ot() {
    var tt;
    const Le = btoa(JSON.stringify({
      userId: (tt = Rt.data) == null ? void 0 : tt.id,
      time: Date.now()
    }));
    localStorage.setItem(He, Le)
  }
  class Gt {
    constructor() {
      vn(this, "history", []);
      vn(this, "actionInProgress", !1);
      vn(this, "historyIdx", -1);
      yn(this, Sn, We(!1));
      yn(this, Vr, We(!1))
    }
    get canUndo() {
      return g(tr(this, Sn))
    }
    set canUndo(tt) {
      G(tr(this, Sn), tt, !0)
    }
    get canRedo() {
      return g(tr(this, Vr))
    }
    set canRedo(tt) {
      G(tr(this, Vr), tt, !0)
    }
    undo() {
      if (this.historyIdx < 0) return;
      const tt = this.history[this.historyIdx];
      if (tt) {
        const qt = this.mergeActions(tt.undo);
        for (const Ut of qt) this.applyAction(Ut)
      }
      this.historyIdx--, this.refreshCanUndoRedo()
    }
    redo() {
      if (this.historyIdx >= this.history.length - 1) return;
      this.historyIdx++;
      const tt = this.history[this.historyIdx];
      if (tt) {
        const qt = this.mergeActions(tt.redo);
        for (const Ut of qt) this.applyAction(Ut)
      }
      this.refreshCanUndoRedo()
    }
    saveAction(tt, qt) {
      this.actionInProgress || (this.historyIdx < this.history.length - 1 && (this.history = this.history.slice(0, this.historyIdx + 1)), this.actionInProgress = !0, this.historyIdx++, this.history.push({
        redo: [],
        undo: []
      }));
      const Ut = this.history[this.historyIdx];
      Ut && (Ut.redo.push(tt), Ut.undo.push(qt))
    }
    finishAction() {
      this.actionInProgress = !1, this.refreshCanUndoRedo()
    }
    clear() {
      this.history = [], this.actionInProgress = !1, this.historyIdx = -1, this.refreshCanUndoRedo()
    }
    mergeActions(tt) {
      const qt = {
          type: "erase",
          latLons: []
        },
        Ut = new Map;
      for (const Wt of tt)
        if (Wt.type === "erase") qt.latLons.push(...Wt.latLons);
        else {
          const yr = Ut.get(Wt.colorIdx);
          yr ? yr.latLons.push(...Wt.latLons) : Ut.set(Wt.colorIdx, {
            type: "paint",
            colorIdx: Wt.colorIdx,
            latLons: [...Wt.latLons]
          })
        } const fr = [];
      if (qt.latLons.length > 0 && fr.push(qt), Ut.size > 0)
        for (const Wt of Ut.values()) fr.push(Wt);
      return fr
    }
    applyAction(tt) {
      switch (tt.type) {
        case "paint":
          Jt(tt.latLons, tt.colorIdx, !1);
          break;
        case "erase":
          Mt(tt.latLons, !1);
          break
      }
    }
    refreshCanUndoRedo() {
      this.canUndo = this.historyIdx >= 0, this.canRedo = this.historyIdx < this.history.length - 1
    }
  }
  Sn = new WeakMap, Vr = new WeakMap;
  const kt = new Gt;
  var nr = j5e();
  Pn("keypress", Vs, Le => {
    switch (Le.code) {
      case "KeyZ":
        (Le.ctrlKey || Le.metaKey) && (Le.shiftKey ? kt.redo() : kt.undo());
        break;
      case "KeyY":
        (Le.ctrlKey || Le.metaKey) && kt.redo()
    }
  });
  var It = Pt(nr),
    mt = S(It);
  {
    var yt = Le => {
        Cc(Le, {
          children: (tt, qt) => {
            var Ut = C5e(),
              fr = Pt(Ut);
            Ry(fr, {
              class: "inline size-5"
            });
            var Wt = L(fr);
            ze(yr => ee(Wt, ` ${yr??""}`), [() => OH()]), O(tt, Ut)
          },
          $$slots: {
            default: !0
          }
        })
      },
      bt = Le => {
        var tt = Ir(),
          qt = Pt(tt);
        {
          var Ut = Wt => {
              Cc(Wt, {
                class: "not-touchscreen:hidden",
                children: (yr, tn) => {
                  var Kr = A5e(),
                    Br = Pt(Kr);
                  h_(Br, {
                    class: "inline size-5"
                  });
                  var Cr = L(Br);
                  ze(Yr => ee(Cr, ` ${Yr??""}`), [() => JH()]), O(yr, Kr)
                },
                $$slots: {
                  default: !0
                }
              })
            },
            fr = Wt => {
              var yr = Ir(),
                tn = Pt(yr);
              {
                var Kr = Cr => {
                    Cc(Cr, {
                      class: "not-touchscreen:hidden",
                      children: (Yr, Ln) => {
                        var In = z5e(),
                          Wr = Pt(In);
                        i0(Wr, {
                          class: "inline size-5"
                        });
                        var jr = L(Wr, 1, !0);
                        ze(wn => ee(jr, wn), [() => IU()]), O(Yr, In)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  },
                  Br = Cr => {
                    var Yr = Ir(),
                      Ln = Pt(Yr);
                    {
                      var In = jr => {
                          Cc(jr, {
                            class: "touchscreen:hidden",
                            children: (wn, En) => {
                              var Mn = E5e(),
                                qn = Pt(Mn);
                              Fy(qn, {
                                class: "inline size-5"
                              });
                              var Gn = L(qn),
                                Jn = S(Gn, !0);
                              P(Gn);
                              var Zn = L(Gn, 2),
                                ri = S(Zn),
                                la = L(ri),
                                Hi = S(la, !0);
                              P(la), P(Zn);
                              var Oa = L(Zn);
                              ze((qa, Aa, za, Ea) => {
                                ee(Jn, qa), ee(ri, `${Aa??""} `), ee(Hi, za), ee(Oa, ` ${Ea??""}`)
                              }, [() => XT(), () => RN(), () => B2(), () => Fee()]), O(wn, Mn)
                            },
                            $$slots: {
                              default: !0
                            }
                          })
                        },
                        Wr = jr => {
                          var wn = Ir(),
                            En = Pt(wn);
                          {
                            var Mn = qn => {
                              Cc(qn, {
                                class: "bg-warning text-warning-content animate-bounce",
                                children: (Gn, Jn) => {
                                  var Zn = L5e(),
                                    ri = Pt(Zn);
                                  Pl(ri, {
                                    class: "inline size-5"
                                  });
                                  var la = L(ri);
                                  ze(Hi => ee(la, ` ${Hi??""}`), [() => Yee()]), O(Gn, Zn)
                                },
                                $$slots: {
                                  default: !0
                                }
                              })
                            };
                            we(En, qn => {
                              g(it) && qn(Mn)
                            }, !0)
                          }
                          O(jr, wn)
                        };
                      we(Ln, jr => {
                        g(Fe) && g(W) === 0 ? jr(In) : jr(Wr, !1)
                      }, !0)
                    }
                    O(Cr, Yr)
                  };
                we(tn, Cr => {
                  g(Pe) ? Cr(Kr) : Cr(Br, !1)
                }, !0)
              }
              O(Wt, yr)
            };
          we(qt, Wt => {
            g(Re) ? Wt(Ut) : Wt(fr, !1)
          }, !0)
        }
        O(Le, tt)
      };
    we(mt, Le => {
      g(Re) && g(W) === 0 ? Le(yt) : Le(bt, !1)
    })
  }
  var Lt = L(mt, 2),
    st = S(Lt);
  st.__click = () => G(J, !g(J));
  var lr = S(st);
  {
    var gr = Le => {
        s5e(Le, {
          class: "size-4"
        })
      },
      dr = Le => {
        c5e(Le, {
          class: "size-4"
        })
      };
    we(lr, Le => {
      g(J) ? Le(gr) : Le(dr, !1)
    })
  }
  P(st);
  var pr = L(st, 2),
    Ht = S(pr),
    Sr = S(Ht),
    Rr = L(Sr);
  Ly(Rr, {
    class: "inline",
    fontSize: 14,
    get value() {
      return `(${g(W)??""})`
    },
    mono: !0
  }), P(Ht);
  var Vt = L(Ht, 2),
    Tr = S(Vt),
    Xt = S(Tr);
  bn(), P(Tr);
  var ue = L(Tr, 2);
  ue.__click = () => {
    G(k, "colorpicker")
  };
  var N = S(ue);
  i0(N, {
    class: "size-4.5"
  }), P(ue), P(Vt);
  var q = L(Vt, 2),
    X = S(q);
  let te;
  X.__click = () => {
    x(!x())
  };
  var le = S(X);
  {
    let Le = xt(() => !x());
    jy(le, {
      class: "size-4.5",
      get filled() {
        return g(Le)
      }
    })
  }
  P(X), P(q);
  var xe = L(q, 2),
    je = S(xe),
    Ie = S(je);
  bn(), P(je);
  var qe = L(je, 2);
  let rt;
  qe.__click = () => {
    kt.undo()
  };
  var Xe = S(qe);
  I5e(Xe, {
    class: "size-4.5"
  }), P(qe), P(xe);
  var he = L(xe, 2),
    Q = S(he),
    Ze = S(Q);
  bn(), P(Q);
  var vt = L(Q, 2);
  let Qe;
  vt.__click = () => {
    kt.redo()
  };
  var oe = S(vt);
  P5e(oe, {
    class: "size-4.5"
  }), P(vt), P(he), P(pr);
  var De = L(pr, 2);
  De.__click = () => {
    gi.smallPlop.play(), Et()
  };
  var Je = S(De);
  ms(Je, {
    class: "size-4"
  }), P(De), P(Lt);
  var Tt = L(Lt, 2),
    Dt = S(Tt);
  li(Dt, 23, () => g(Oe), Le => Le.idx, (Le, tt, qt) => {
    const Ut = xt(() => {
        const [Yr, Ln, In] = g(tt).rgb;
        return {
          r: Yr,
          g: Ln,
          b: In
        }
      }),
      fr = xt(() => g(E) === g(tt).idx && g(Fe)),
      Wt = xt(() => g(tt).idx === 0),
      yr = xt(() => Rt.hasColor(g(tt).idx));
    var tn = R5e(),
      Kr = S(tn);
    Kr.__click = () => {
      Kt(g(tt).idx)
    };
    var Br = S(Kr);
    {
      var Cr = Yr => {
        var Ln = D5e(),
          In = Pt(Ln);
        G_(In, {
          class: "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6"
        });
        var Wr = L(In, 2),
          jr = S(Wr);
        G_(jr, {
          class: "text-base-content/80 size-4"
        }), P(Wr), O(Yr, Ln)
      };
      we(Br, Yr => {
        g(yr) || Yr(Cr)
      })
    }
    P(Kr), P(tn), ze(() => {
      Or(tn, 1, Us({
        tooltip: !0,
        "max-sm:h-6": g(Ce),
        "max-sm:before:translate-x-1/4": g(qt) % 8 === 0 && g(tt).label.length > 7,
        "max-sm:before:-translate-x-1/4": (g(qt) - 7) % 8 === 0 && g(tt).label.length > 7,
        "max-xl:before:translate-x-1/4": g(qt) % 16 === 0 && g(tt).label.length > 7,
        "max-xl:before:-translate-x-1/4": (g(qt) - 15) % 16 === 0 && g(tt).label.length > 7,
        "xl:before:translate-x-1/4": g(Ce) && g(qt) % 32 === 0 && g(tt).label.length > 7,
        "xl:before:-translate-x-1/4": g(Ce) && (g(qt) - 31) % 32 === 0 && g(tt).label.length > 7
      })), or(tn, "data-tip", g(tt).label), Or(Kr, 1, Us({
        "btn relative aspect-square w-full rounded-xl": !0,
        "border-primary ring-primary ring-2": g(fr),
        "border-base-300": !g(fr) && g(Wt),
        "border-base-content/20": !g(fr) && !g(Wt),
        "max-sm:h-6 max-sm:rounded-md": g(Ce)
      })), Io(Kr, g(Wt) ? `background-image: url(${n5e}); background-size: cover; image-rendering: pixelated;` : `background: rgb(${g(Ut).r} ${g(Ut).g} ${g(Ut).b})`), or(Kr, "aria-label", g(tt).label), or(Kr, "id", `color-${g(tt).idx??""}`)
    }), Pn("focus", Kr, () => {
      g(yr) && (G(E, g(tt).idx, !0), G(k, "pencil"))
    }), O(Le, tn)
  }), P(Dt), P(Tt);
  var _t = L(Tt, 2),
    zt = S(_t);
  zt.__click = () => {
    G(Ce, !g(Ce))
  };
  var Yt = S(zt);
  {
    var $e = Le => {
        m1(Le, {
          class: "size-5"
        })
      },
      Ct = Le => {
        g1(Le, {
          class: "size-5"
        })
      };
    we(Yt, Le => {
      g(Ce) ? Le($e) : Le(Ct, !1)
    })
  }
  P(zt);
  var ir = L(zt, 2),
    Fr = S(ir);
  {
    let Le = xt(() => g(W) > 100 ? "animate-pulse" : ""),
      tt = xt(() => g(W) === 0 || g($) || g(ge) < 0);
    Dy(Fr, {
      get class() {
        return g(Le)
      },
      get charges() {
        return g(ge)
      },
      get disabled() {
        return g(tt)
      },
      get loading() {
        return g($)
      },
      onclick: async () => {
        gi.droppletAndPlop.play();
        const qt = [...l.values()];
        G($, !0);
        try {
          const Ut = await gm();
          await pn.paint(qt, Ut), await J_(qt), Ot(), Rt.refresh(), _p.shouldReload = !0, await Et()
        } catch (Ut) {
          rr.error(`${Ut.message}`, {
            duration: 7e3
          })
        } finally {
          G($, !1)
        }
      }
    })
  }
  P(ir);
  var br = L(ir, 2),
    nt = S(br),
    cr = S(nt),
    ar = S(cr);
  bn(), P(cr);
  var Ar = L(cr, 2);
  let qr;
  Ar.__click = () => {
    G(k, g(k) === "eraser" ? "pencil" : "eraser", !0)
  };
  var Gr = S(Ar);
  h_(Gr, {
    class: "size-5",
    get filled() {
      return g(Re)
    }
  }), P(Ar), P(nt), P(br), P(_t), P(It), oo(It, Le => G(ve, Le), () => g(ve));
  var Mr = L(It, 2);
  v5e(Mr, {
    get colorIdx() {
      return g(et)
    },
    get open() {
      return g(Ge)
    },
    set open(Le) {
      G(Ge, Le, !0)
    }
  }), ze((Le, tt, qt, Ut, fr, Wt) => {
    ee(Sr, `${Le??""} `), ee(Xt, `${tt??""} `), Or(ue, 1, Us({
      "btn btn-circle btn-sm": !0,
      "btn-ghost": !g(Pe),
      "btn-primary": g(Pe)
    })), or(q, "data-tip", qt), te = Or(X, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, te, {
      "text-primary": !x()
    }), ee(Ie, `${Ut??""} `), rt = Or(qe, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, rt, {
      "opacity-50": !kt.canUndo
    }), qe.disabled = !kt.canUndo, ee(Ze, `${fr??""} `), Qe = Or(vt, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, Qe, {
      "opacity-50": !kt.canRedo
    }), vt.disabled = !kt.canRedo, Or(Dt, 1, Us({
      "md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
      "xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": g(Ce),
      "gap-1": !g(Ce)
    })), ee(ar, `${Wt??""} `), qr = Or(Ar, 1, "btn btn-lg btn-square sm:btn-xl shadow-md", null, qr, {
      "btn-primary": g(Re)
    }), Ar.disabled = g(W) === 0
  }, [() => yV(), () => lP(), () => N0(), () => zre(), () => L$(), () => x1()]), Fh("innerHeight", Le => G(Ve, Le, !0)), O(d, nr), en()
}
Yn(["click"]);
var B5e = se('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><p class="whitespace-pre-wrap"><!></p> <div class="mt-4"><!></div> <div class="mt-2 flex justify-end gap-2"><button class="btn btn-soft tooltip" type="button"> </button> <div class="tooltip tooltip-top"><div class="tooltip-content translate-x-[-30%] p-2"> </div> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog>');

function O5e(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = We(!1),
    A = We(""),
    E = We(0),
    k = We(!1);
  rn(() => {
    r() && (async () => {
      try {
        G(x, !0);
        const Me = await pn.getUserLastAppeal();
        if (Me === null) {
          G(k, !1), G(E, 0);
          return
        }
        const Ye = new Date(Me),
          Ce = 1440 * 60 * 1e3;
        Date.now() - Ye.getTime() < 90 * Ce ? (G(k, !0), G(E, Math.ceil((Ye.getTime() + 90 * Ce - Date.now()) / Ce), !0)) : G(E, 0)
      } catch (Me) {
        rr.error(Me.message)
      } finally {
        G(x, !1)
      }
    })()
  });
  var l = B5e(),
    j = S(l),
    W = L(S(j), 2),
    $ = S(W, !0);
  P(W);
  var J = L(W, 2),
    ce = S(J),
    ge = S(ce);
  Fp(ge, () => i3()), P(ce);
  var fe = L(ce, 2),
    Z = S(fe);
  {
    let Me = xt(() => g3()),
      Ye = xt(() => A3()),
      Ce = xt(() => g(x) || g(k));
    g0(Z, {
      get label() {
        return g(Me)
      },
      get placeholder() {
        return g(Ye)
      },
      min: 1,
      max: 2056,
      class: "h-32",
      get disabled() {
        return g(Ce)
      },
      get value() {
        return g(A)
      },
      set value(Oe) {
        G(A, Oe, !0)
      }
    })
  }
  P(fe);
  var de = L(fe, 2),
    Fe = S(de);
  Fe.__click = () => {
    r(!1)
  };
  var Re = S(Fe, !0);
  P(Fe);
  var Pe = L(Fe, 2),
    Ge = S(Pe),
    et = S(Ge, !0);
  P(Ge);
  var Ve = L(Ge, 2),
    ve = S(Ve, !0);
  P(Ve), P(Pe), P(de), P(J), P(j), P(l), Li(l, () => Me => {
    rn(() => {
      r() ? Me.show() : Me.close()
    })
  }), ze((Me, Ye, Ce, Oe) => {
    ee($, Me), Fe.disabled = g(x), ee(Re, Ye), ee(et, Ce), Ve.disabled = g(x) || g(k) || g(A).length <= 1, ee(ve, Oe)
  }, [() => s.userData.banned ? K1() : hee(), () => Ja(), () => g(k) ? G5({
    days: g(E)
  }) : "", () => iJ()]), Pn("close", l, () => r(!1)), Pn("submit", J, async () => {
    try {
      G(x, !0), await pn.submitBanAppeal(g(A)), rr.success(U3()), r(!1)
    } catch (Me) {
      rr.error(Me.message, {
        duration: 5e3
      })
    } finally {
      G(x, !1)
    }
  }), O(d, l), en()
}
Yn(["click"]);
var q5e = se("<span> </span>");

function a0(d, s) {
  Qr(s, !0);
  var r = q5e(),
    x = S(r, !0);
  P(r), ze(() => {
    Or(r, 1, `size-4 items-center justify-center rounded-full bg-red-500 font-semibold text-red-50 ${s.count<10?"text-xs":"text-[10px]"} ${s.class??""}`), ee(x, s.count < 10 ? s.count : "9+")
  }), O(d, r), en()
}
var N5e = se('<p class="text-error mt-1 text-sm"> </p>'),
  V5e = se('<span class="loading loading-spinner center-absolute absolute"></span>'),
  U5e = se('<dialog class="modal bg-black/80!"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex items-center gap-2"><!> <h3 class="text-lg font-bold"> </h3></div> <p class="mt-4"><b> </b> </p> <p class="mt-2"> </p> <div class="rounded-box border-base-content/20 mt-6 w-full border py-1.5 text-center"> </div> <input class="input input-bordered mt-2 w-full" type="text"/> <!> <div class="mt-6 flex justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-error relative"> <!></button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function Z5e(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = We(""),
    A = We(null),
    E = We(!1),
    k = xt(() => {
      var Mt;
      return ((Mt = Rt.data) == null ? void 0 : Mt.name) ?? ""
    });
  rn(() => {
    r() || (G(x, ""), G(A, null))
  });
  var l = U5e(),
    j = S(l),
    W = L(S(j), 2),
    $ = S(W);
  I1($, {
    class: "text-error size-5"
  });
  var J = L($, 2),
    ce = S(J, !0);
  P(J), P(W);
  var ge = L(W, 2),
    fe = S(ge),
    Z = S(fe, !0);
  P(fe);
  var de = L(fe);
  P(ge);
  var Fe = L(ge, 2),
    Re = S(Fe);
  P(Fe);
  var Pe = L(Fe, 2),
    Ge = S(Pe, !0);
  P(Pe);
  var et = L(Pe, 2);
  sa(et);
  var Ve = L(et, 2);
  {
    var ve = Mt => {
      var ct = N5e(),
        wt = S(ct, !0);
      P(ct), ze(() => ee(wt, g(A))), O(Mt, ct)
    };
    we(Ve, Mt => {
      g(A) && Mt(ve)
    })
  }
  var Me = L(Ve, 2),
    Ye = S(Me);
  Ye.__click = () => {
    r(!1)
  };
  var Ce = S(Ye, !0);
  P(Ye);
  var Oe = L(Ye, 2);
  Oe.__click = async () => {
    if (g(x) !== g(k)) {
      G(A, a1(), !0);
      return
    }
    try {
      G(E, !0), await pn.deleteMe(g(k)), rr.warning(uw()), await Rt.logout(), r(!1)
    } catch (Mt) {
      rr.error(Mt.message)
    } finally {
      G(E, !1)
    }
  };
  var ut = S(Oe),
    Ue = L(ut);
  {
    var Ke = Mt => {
      var ct = V5e();
      O(Mt, ct)
    };
    we(Ue, Mt => {
      g(E) && Mt(Ke)
    })
  }
  P(Oe), P(Me), P(j);
  var St = L(j, 2),
    Ft = S(St),
    Jt = S(Ft, !0);
  P(Ft), P(St), P(l), Li(l, () => Mt => {
    rn(() => {
      r() ? Mt.show() : Mt.close()
    })
  }), ze((Mt, ct, wt, ft, $t, Et, Qt, vr, Kt) => {
    ee(ce, Mt), ee(Z, ct), ee(de, ` ${wt??""}`), ee(Re, `${ft??""} ${$t??""}`), ee(Ge, g(k)), or(et, "placeholder", Et), ee(Ce, Qt), Oe.disabled = g(E), ee(ut, `${vr??""} `), ee(Jt, Kt)
  }, [() => __(), () => rk(), () => OQ(), () => rQ(), () => $te(), () => are(), () => Nc(), () => __(), () => Ja()]), Pn("close", l, () => r(!1)), Oc(et, () => g(x), Mt => G(x, Mt)), O(d, l), en()
}
Yn(["click"]);
var G5e = se('<p class="text-base-content/80 text-sm"> </p>'),
  $5e = se('<span class="loading loading-spinner center-absolute absolute"></span>'),
  W5e = se('<h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <!> <div class="mt-4 flex justify-end gap-2"><form method="dialog"><button class="btn btn-soft"> </button></form> <button> <!></button></div>', 1);

function H5e(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = sr(s, "type", 3, "confirmation"),
    A = sr(s, "buttonText", 19, () => S0()),
    E = We(!1);
  bm(d, {
    dialogClass: "!bg-black/80",
    get open() {
      return r()
    },
    set open(k) {
      r(k)
    },
    children: (k, l) => {
      var j = W5e(),
        W = Pt(j),
        $ = S(W, !0);
      P(W);
      var J = L(W, 2),
        ce = S(J, !0);
      P(J);
      var ge = L(J, 2);
      {
        var fe = Me => {
          var Ye = G5e(),
            Ce = S(Ye, !0);
          P(Ye), ze(() => ee(Ce, s.subDescription)), O(Me, Ye)
        };
        we(ge, Me => {
          s.subDescription && Me(fe)
        })
      }
      var Z = L(ge, 2),
        de = S(Z),
        Fe = S(de),
        Re = S(Fe, !0);
      P(Fe), P(de);
      var Pe = L(de, 2);
      let Ge;
      Pe.__click = async () => {
        try {
          G(E, !0), r(await s.onConfirm())
        } finally {
          G(E, !1)
        }
      };
      var et = S(Pe),
        Ve = L(et);
      {
        var ve = Me => {
          var Ye = $5e();
          O(Me, Ye)
        };
        we(Ve, Me => {
          g(E) && Me(ve)
        })
      }
      P(Pe), P(Z), ze(Me => {
        ee($, s.title), ee(ce, s.description), ee(Re, Me), Ge = Or(Pe, 1, "btn relative", null, Ge, {
          "btn-error": x() === "warning",
          "btn-primary": x() === "confirmation"
        }), Pe.disabled = g(E), ee(et, `${A()??""} `)
      }, [() => Nc()]), O(k, j)
    },
    $$slots: {
      default: !0
    }
  }), en()
}
Yn(["click"]);

function X5e(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15);
  {
    let x = xt(() => v0()),
      A = xt(() => UR()),
      E = xt(() => pH());
    H5e(d, {
      type: "warning",
      get title() {
        return g(x)
      },
      get description() {
        return g(A)
      },
      get subDescription() {
        return g(E)
      },
      onConfirm: async () => {
        try {
          return await pn.deleteSessions(), rr.success(C1()), await Rt.logout(), !0
        } catch {
          return rr.error(A1()), !1
        }
      },
      get open() {
        return r()
      },
      set open(k) {
        r(k)
      }
    })
  }
  en()
}
var Y5e = se('<div class="mt-1 flex w-full justify-center"><span class="badge badge-primary badge-sm"> </span></div>'),
  K5e = se('<div class="mt-1 flex w-full justify-center"><span class="badge badge-primary badge-sm"> </span></div>'),
  J5e = se('<button type="button"><div class="flex flex-1 flex-col items-center justify-center gap-1"><div class="relative"><div class="relative flex size-16 items-center justify-center overflow-hidden rounded-full"><img class="pointer-events-none absolute inset-0 rounded-full object-cover"/></div></div></div> <div class="mt-1 flex w-full flex-col items-center text-center"><span class="line-clamp-1 w-full text-xs font-medium"> </span> <span class="text-base-content/70 mt-0.5 w-full text-[11px]"> </span></div> <!></button>'),
  Q5e = se('<div class="flex gap-2"><div class="bg-base-200 aspect-square rounded-lg p-4"><div class="relative"><!></div></div> <div class="bg-base-200 flex flex-col items-center justify-center gap-4 rounded-lg p-2"><div class="relative"><!></div> <div class="relative"><!></div></div></div>'),
  e3e = se('<span class="loading loading-spinner"></span>'),
  t3e = se('<dialog class="modal"><div class="modal-box max-h-11/12 max-w-2xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="text-lg font-bold"> </h3> <p class="text-base-content/80 mb-3 text-sm"> </p> <div class="grid grow grid-cols-1 gap-4 sm:grid-cols-[1fr_auto]"><section class="overflow-y-auto"><h4 class="text-base-content/80 mb-2 text-sm font-semibold"> </h4> <div class="grid grid-cols-2 gap-3 sm:grid-cols-3"><button type="button"><div class="flex flex-1 flex-col items-center justify-center gap-1"><div class="text-base-content/60 border-base-content/60 flex size-16 items-center justify-center rounded-full border text-xs font-semibold"> </div></div> <div class="mt-1 flex w-full flex-col items-center text-center"><span class="line-clamp-1 w-full text-xs font-medium"> </span> <span class="text-base-content/70 mt-0.5 w-full text-[11px]"> </span></div> <!></button> <!></div> <h4 class="text-base-content/80 mb-2 mt-4 text-sm font-semibold"> </h4> <span class="text-base-content/70 text-xs"> </span> <p class="sm:pt-10"></p></section> <section class="flex flex-col justify-between"><div><h4 class="text-base-content/80 mb-2 text-sm font-semibold"> </h4> <!></div> <div class="mt-4 flex justify-end"><button type="button" class="btn mr-2"> </button> <button type="button" class="btn btn-primary"><!></button></div></section></div></div></dialog>');

function r3e(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = We(Pi([]));
  const A = Pi(Rt.data);
  let E = We(!1),
    k = We(null);
  rn(() => {
    A && A.equippedFrameId !== void 0 && g(k) === null && G(k, A.equippedFrameId || 0, !0)
  });

  function l(mt) {
    g(E) || G(k, mt, !0)
  }
  async function j() {
    if (!(g(E) || g(k) === null)) {
      G(E, !0);
      try {
        await pn.postEquipUserFrame(g(k)), await Rt.refresh(), rr.success(Kue())
      } catch {
        rr.error(uhe())
      } finally {
        G(E, !1)
      }
    }
  }

  function W(mt) {
    if (mt === null || mt === 0) return !1;
    const yt = g(x).find(bt => bt.id === mt);
    return yt ? !!yt.value && yt.value > 0 : !1
  }
  Wi(async () => {
    try {
      G(x, await pn.getUserFrames(), !0), G(k, A.equippedFrameId || 0, !0)
    } catch {
      rr.error(J1())
    }
  });
  var $ = t3e(),
    J = S($),
    ce = S(J),
    ge = S(ce);
  ge.__click = () => {
    r(!1)
  }, P(ce);
  var fe = L(ce, 2),
    Z = S(fe, !0);
  P(fe);
  var de = L(fe, 2),
    Fe = S(de, !0);
  P(de);
  var Re = L(de, 2),
    Pe = S(Re),
    Ge = S(Pe),
    et = S(Ge, !0);
  P(Ge);
  var Ve = L(Ge, 2),
    ve = S(Ve);
  ve.__click = () => l(0);
  var Me = S(ve),
    Ye = S(Me),
    Ce = S(Ye, !0);
  P(Ye), P(Me);
  var Oe = L(Me, 2),
    ut = S(Oe),
    Ue = S(ut, !0);
  P(ut);
  var Ke = L(ut, 2),
    St = S(Ke, !0);
  P(Ke), P(Oe);
  var Ft = L(Oe, 2);
  {
    var Jt = mt => {
      var yt = Y5e(),
        bt = S(yt),
        Lt = S(bt, !0);
      P(bt), P(yt), ze(st => ee(Lt, st), [() => Cv()]), O(mt, yt)
    };
    we(Ft, mt => {
      g(k) === 0 && mt(Jt)
    })
  }
  P(ve);
  var Mt = L(ve, 2);
  li(Mt, 17, () => g(x), mt => mt.id, (mt, yt) => {
    var bt = J5e();
    bt.__click = () => l(g(yt).id);
    var Lt = S(bt),
      st = S(Lt),
      lr = S(st),
      gr = S(lr);
    P(lr), P(st), P(Lt);
    var dr = L(Lt, 2),
      pr = S(dr),
      Ht = S(pr, !0);
    P(pr);
    var Sr = L(pr, 2),
      Rr = S(Sr, !0);
    P(Sr), P(dr);
    var Vt = L(dr, 2);
    {
      var Tr = Xt => {
        var ue = K5e(),
          N = S(ue),
          q = S(N, !0);
        P(N), P(ue), ze(X => ee(q, X), [() => Cv()]), O(Xt, ue)
      };
      we(Vt, Xt => {
        g(k) === g(yt).id && Xt(Tr)
      })
    }
    P(bt), ze(() => {
      Or(bt, 1, `bg-base-200/80 hover:bg-base-300 group flex h-40 flex-col items-center justify-between rounded-lg p-3 text-xs
									transition disabled:opacity-50
									${g(k)===g(yt).id?" border-primary bg-primary/10":""}`), bt.disabled = g(E), or(gr, "src", g(yt).imageUrl), or(gr, "alt", g(yt).name), ee(Ht, g(yt).name), ee(Rr, g(yt).description)
    }), O(mt, bt)
  }), P(Ve);
  var ct = L(Ve, 2),
    wt = S(ct, !0);
  P(ct);
  var ft = L(ct, 2),
    $t = S(ft, !0);
  P(ft), bn(2), P(Pe);
  var Et = L(Pe, 2),
    Qt = S(Et),
    vr = S(Qt),
    Kt = S(vr, !0);
  P(vr);
  var Bt = L(vr, 2);
  kl(Bt, () => g(k), mt => {
    const yt = xt(() => g(x).find(Rr => Rr.id === g(k)));
    var bt = Q5e(),
      Lt = S(bt),
      st = S(Lt),
      lr = S(st);
    {
      let Rr = xt(() => {
        var Vt;
        return (Vt = g(yt)) == null ? void 0 : Vt.imageUrl
      });
      Fa(lr, {
        class: "size-20",
        get userId() {
          return A.id
        },
        get pictureUrl() {
          return A.picture
        },
        get borderUrl() {
          return g(Rr)
        }
      })
    }
    P(st), P(Lt);
    var gr = L(Lt, 2),
      dr = S(gr),
      pr = S(dr);
    {
      let Rr = xt(() => {
        var Vt;
        return (Vt = g(yt)) == null ? void 0 : Vt.imageUrl
      });
      Fa(pr, {
        class: "size-10",
        get userId() {
          return A.id
        },
        get pictureUrl() {
          return A.picture
        },
        get borderUrl() {
          return g(Rr)
        }
      })
    }
    P(dr);
    var Ht = L(dr, 2),
      Sr = S(Ht);
    {
      let Rr = xt(() => {
        var Vt;
        return (Vt = g(yt)) == null ? void 0 : Vt.imageUrl
      });
      Fa(Sr, {
        class: "size-5",
        get userId() {
          return A.id
        },
        get pictureUrl() {
          return A.picture
        },
        get borderUrl() {
          return g(Rr)
        }
      })
    }
    P(Ht), P(gr), P(bt), O(mt, bt)
  }), P(Qt);
  var it = L(Qt, 2),
    He = S(it);
  He.__click = () => {
    r(!1)
  };
  var Ot = S(He, !0);
  P(He);
  var Gt = L(He, 2);
  Gt.__click = j;
  var kt = S(Gt);
  {
    var nr = mt => {
        var yt = e3e();
        O(mt, yt)
      },
      It = mt => {
        var yt = Ir(),
          bt = Pt(yt);
        {
          var Lt = lr => {
              var gr = vi();
              ze(dr => ee(gr, dr), [() => ape()]), O(lr, gr)
            },
            st = lr => {
              var gr = vi();
              ze(dr => ee(gr, dr), [() => y0()]), O(lr, gr)
            };
          we(bt, lr => {
            W(g(k)) ? lr(Lt) : lr(st, !1)
          }, !0)
        }
        O(mt, yt)
      };
    we(kt, mt => {
      g(E) ? mt(nr) : mt(It, !1)
    })
  }
  P(Gt), P(it), P(Et), P(Re), P(J), P($), Li($, () => mt => {
    rn(() => {
      r() ? mt.showModal() : mt.close()
    })
  }), ze((mt, yt, bt, Lt, st, lr, gr, dr, pr, Ht) => {
    ee(Z, mt), ee(Fe, yt), ee(et, bt), Or(ve, 1, `bg-base-200/80 hover:bg-base-300 group flex h-40 flex-col items-center justify-between rounded-lg p-3 text-xs
								transition disabled:opacity-50
								${g(k)===0?" border-primary bg-primary/10":""}`), ve.disabled = g(E), ee(Ce, Lt), ee(Ue, st), ee(St, lr), ee(wt, gr), ee($t, dr), ee(Kt, pr), He.disabled = g(E), ee(Ot, Ht), Gt.disabled = g(E) || g(k) === null
  }, [() => khe(), () => jhe(), () => Xhe(), () => vpe(), () => zpe(), () => lde(), () => Lde(), () => $de(), () => w1(), () => Nc()]), Pn("close", $, () => r(!1)), O(d, $), en()
}
Yn(["click"]);
var n3e = se('<img alt="Frame equipado" class="h-30 w-30 pointer-events-none absolute inset-0 select-none"/>'),
  i3e = se('<span class="center-absolute loading loading-spinner absolute"></span>'),
  a3e = se('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  o3e = se('<span class="center-absolute loading loading-spinner absolute"></span>'),
  s3e = se('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  l3e = se('<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>'),
  c3e = se('<a class="btn border-0 bg-[#5865F2] text-white"><!> </a>'),
  u3e = se('<button class="btn btn-error btn-soft"><!> </button>'),
  h3e = se('<dialog class="modal" closedby="any"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative flex w-max items-center gap-2"><div class="relative w-max"><!> <!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <button type="button" class="tooltip btn btn-circle btn-soft tooltip-bottom absolute -bottom-1 -left-1 before:translate-x-1/3"><span class="text-lg">ğŸ¨</span></button></div> <!></div> <div class="flex w-full flex-col gap-3"><div class="tooltip tooltip-bottom"><!></div> <!> <label class="label whitespace-pre-line text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="col mt-4 flex flex-wrap justify-between gap-2"><div class="dropdown dropdown-top max-sm:dropdown-top col ml-1 mt-4 flex gap-2"><button tabindex="0" class="btn btn-sm btn-soft"> </button> <ul class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 font-medium shadow-sm"><li><button type="button" class="text-error py-2"> </button></li> <li><button type="button" class="text-error py-2"> </button></li></ul></div> <div class="col mt-4 flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <!> <!> <!>', 1);

function d3e(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = We(Pi(s.userData.name)),
    A = We(Pi(s.userData.discord)),
    E = We(Pi(s.userData.showLastPixel)),
    k = We(!1),
    l = We(void 0),
    j = We(!1),
    W = We(!1);
  const $ = o1("2025-09_discord_linking");
  let J = We(!!s.userData.discordId),
    ce = We(!1),
    ge = We(void 0),
    fe = We(void 0);
  rn(() => {
    G(x, s.userData.name, !0), G(E, s.userData.showLastPixel, !0)
  }), rn(() => {
    r() && !g(l) && pn.getMyProfilePictures().then(Vt => {
      G(l, Vt, !0)
    }).catch(Vt => {
      rr.error(Vt.message)
    })
  });
  let Z = We(!1);
  async function de(Vt) {
    try {
      G(Z, !0), await pn.changeProfilePicture(Vt), await Rt.refresh()
    } finally {
      G(Z, !1)
    }
  }
  var Fe = h3e(),
    Re = Pt(Fe),
    Pe = S(Re),
    Ge = L(S(Pe), 2),
    et = S(Ge, !0);
  P(Ge);
  var Ve = L(Ge, 2),
    ve = S(Ve),
    Me = S(ve),
    Ye = S(Me),
    Ce = S(Ye),
    Oe = S(Ce);
  Fa(Oe, {
    class: "h-30 w-30 relative",
    get userId() {
      return s.userData.id
    },
    get pictureUrl() {
      return s.userData.picture
    }
  });
  var ut = L(Oe, 2);
  {
    var Ue = Vt => {
      var Tr = n3e();
      ze(() => or(Tr, "src", s.userData.equippedFrameUrl)), O(Vt, Tr)
    };
    we(ut, Vt => {
      s.userData.equippedFrameUrl && Vt(Ue)
    })
  }
  var Ke = L(ut, 2),
    St = S(Ke);
  p0(St, {
    class: "size-5"
  }), P(Ke), P(Ce);
  var Ft = L(Ce, 2);
  Ft.__click = () => {
    G(ce, !0)
  }, P(Ye);
  var Jt = L(Ye, 2);
  {
    var Mt = Vt => {
      var Tr = l3e(),
        Xt = S(Tr),
        ue = S(Xt, !0);
      P(Xt);
      var N = L(Xt, 2),
        q = S(N);
      {
        var X = le => {
          var xe = a3e();
          xe.__click = () => {
            de()
          };
          var je = S(xe);
          Fa(je, {
            class: "size-10 border",
            get userId() {
              return s.userData.id
            }
          });
          var Ie = L(je, 2);
          {
            var qe = rt => {
              var Xe = i3e();
              O(rt, Xe)
            };
            we(Ie, rt => {
              g(Z) && rt(qe)
            })
          }
          P(xe), ze(() => xe.disabled = g(Z)), O(le, xe)
        };
        we(q, le => {
          s.userData.picture && le(X)
        })
      }
      var te = L(q, 2);
      li(te, 17, () => g(l), le => le.id, (le, xe) => {
        var je = Ir(),
          Ie = Pt(je);
        {
          var qe = rt => {
            var Xe = s3e();
            Xe.__click = () => {
              de(g(xe).id)
            };
            var he = S(Xe);
            Fa(he, {
              class: "size-10 border",
              get userId() {
                return s.userData.id
              },
              get pictureUrl() {
                return g(xe).url
              }
            });
            var Q = L(he, 2);
            {
              var Ze = vt => {
                var Qe = o3e();
                O(vt, Qe)
              };
              we(Q, vt => {
                g(Z) && vt(Ze)
              })
            }
            P(Xe), ze(() => Xe.disabled = g(Z)), O(rt, Xe)
          };
          we(Ie, rt => {
            s.userData.picture !== g(xe).url && rt(qe)
          })
        }
        O(le, je)
      }), P(N), P(Tr), ze(le => ee(ue, le), [() => hT()]), O(Vt, Tr)
    };
    we(Jt, Vt => {
      var Tr;
      (Tr = g(l)) != null && Tr.length && Vt(Mt)
    })
  }
  P(Me);
  var ct = L(Me, 2),
    wt = S(ct),
    ft = S(wt);
  {
    let Vt = xt(() => m_()),
      Tr = xt(() => m_());
    w_(ft, {
      get label() {
        return g(Vt)
      },
      get placeholder() {
        return g(Tr)
      },
      min: 1,
      max: 16,
      get value() {
        return g(x)
      },
      set value(Xt) {
        G(x, Xt, !0)
      },
      get validate() {
        return g(ge)
      },
      set validate(Xt) {
        G(ge, Xt, !0)
      }
    })
  }
  P(wt);
  var $t = L(wt, 2);
  {
    var Et = Vt => {
        var Tr = Ir(),
          Xt = Pt(Tr);
        {
          var ue = q => {
              var X = c3e(),
                te = S(X);
              k_(te, {
                class: "size-4.5"
              });
              var le = L(te);
              P(X), ze((xe, je) => {
                or(X, "href", xe), ee(le, ` ${je??""}`)
              }, [() => s1("/discord/authorize"), () => yD()]), O(q, X)
            },
            N = q => {
              var X = u3e();
              X.__click = async () => {
                try {
                  G(k, !0), await pn.unlinkDiscord(), Rt.refresh(), rr.success(nne()), G(J, !1)
                } catch (xe) {
                  rr.error(xe.message, {
                    duration: 5e3
                  })
                } finally {
                  G(k, !1)
                }
              };
              var te = S(X);
              k_(te, {
                class: "size-4.5"
              });
              var le = L(te);
              P(X), ze(xe => {
                X.disabled = g(k), ee(le, ` ${xe??""}`)
              }, [() => {
                var xe;
                return Zre({
                  username: ((xe = s.userData) == null ? void 0 : xe.discord) ?? ""
                })
              }]), O(q, X)
            };
          we(Xt, q => {
            g(J) ? q(N, !1) : q(ue)
          })
        }
        O(Vt, Tr)
      },
      Qt = Vt => {
        {
          let Tr = xt(() => TM());
          w_(Vt, {
            label: "Discord",
            get placeholder() {
              return g(Tr)
            },
            max: 32,
            get value() {
              return g(A)
            },
            set value(Xt) {
              G(A, Xt, !0)
            },
            get validate() {
              return g(fe)
            },
            set validate(Xt) {
              G(fe, Xt, !0)
            }
          })
        }
      };
    we($t, Vt => {
      $ ? Vt(Et) : Vt(Qt, !1)
    })
  }
  var vr = L($t, 2),
    Kt = S(vr);
  sa(Kt);
  var Bt = L(Kt);
  P(vr), P(ct), P(ve);
  var it = L(ve, 2),
    He = S(it),
    Ot = S(He),
    Gt = S(Ot, !0);
  P(Ot);
  var kt = L(Ot, 2),
    nr = S(kt),
    It = S(nr);
  It.__click = () => {
    G(W, !0)
  };
  var mt = S(It, !0);
  P(It), P(nr);
  var yt = L(nr, 2),
    bt = S(yt);
  bt.__click = () => {
    G(j, !0)
  };
  var Lt = S(bt, !0);
  P(bt), P(yt), P(kt), P(He);
  var st = L(He, 2),
    lr = S(st);
  lr.__click = () => {
    r(!1)
  };
  var gr = S(lr, !0);
  P(lr);
  var dr = L(lr, 2),
    pr = S(dr, !0);
  P(dr), P(st), P(it), P(Ve), P(Pe), P(Re), Li(Re, () => Vt => {
    rn(() => {
      r() ? Vt.showModal() : Vt.close()
    })
  });
  var Ht = L(Re, 2);
  Z5e(Ht, {
    get open() {
      return g(j)
    },
    set open(Vt) {
      G(j, Vt, !0)
    }
  });
  var Sr = L(Ht, 2);
  X5e(Sr, {
    get open() {
      return g(W)
    },
    set open(Vt) {
      G(W, Vt, !0)
    }
  });
  var Rr = L(Sr, 2);
  r3e(Rr, {
    get open() {
      return g(ce)
    },
    set open(Vt) {
      G(ce, Vt, !0)
    }
  }), ze((Vt, Tr, Xt, ue, N, q, X, te, le, xe) => {
    ee(et, Vt), or(Ke, "data-tip", Tr), or(Ft, "data-tip", Xt), or(wt, "data-tip", ue), ee(Bt, ` ${N??""}`), ee(Gt, q), ee(mt, X), ee(Lt, te), lr.disabled = g(k), ee(gr, le), dr.disabled = g(k), ee(pr, xe)
  }, [() => RI(), () => k1(), () => gle(), () => uF(), () => HY(), () => p7(), () => v0(), () => __(), () => Ja(), () => y0()]), Pn("close", Re, () => r(!1)), Pn("submit", Ve, async () => {
    var Vt;
    try {
      if (!((Vt = g(ge)) != null && Vt())) return;
      G(k, !0), await pn.updateMe({
        name: g(x),
        showLastPixel: g(E)
      }), Rt.refresh(), rr.success(RG()), r(!1)
    } catch (Tr) {
      rr.error(Tr.message, {
        duration: 5e3
      })
    } finally {
      G(k, !1)
    }
  }), wp(Kt, () => g(E), Vt => G(E, Vt)), O(d, Fe), en()
}
Yn(["click"]);
var p3e = $r('<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>');

function f3e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = p3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var _3e = $r('<svg><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Zm-10-270Z"></path></svg>');

function m3e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = _3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var g3e = $r('<svg><path d="M480-360q50 0 85-35t35-85q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 50 35 85t85 35Zm0 80q-83 0-141.5-58.5T280-480q0-83 58.5-141.5T480-680q83 0 141.5 58.5T680-480q0 83-58.5 141.5T480-280ZM200-440H40v-80h160v80Zm720 0H760v-80h160v80ZM440-760v-160h80v160h-80Zm0 720v-160h80v160h-80ZM256-650l-101-97 57-59 96 100-52 56Zm492 496-97-101 53-55 101 97-57 59Zm-98-550 97-101 59 57-100 96-56-52ZM154-212l101-97 55 53-97 101-59-57Zm326-268Z"></path></svg>');

function v3e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = g3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var y3e = $r('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>');

function o0(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = y3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var x3e = $r('<svg><path d="M160-200v-80h80v-280q0-83 50-147.5T420-792v-28q0-25 17.5-42.5T480-880q25 0 42.5 17.5T540-820v28q80 20 130 84.5T720-560v280h80v80H160Zm320-300Zm0 420q-33 0-56.5-23.5T400-160h160q0 33-23.5 56.5T480-80ZM320-280h320v-280q0-66-47-113t-113-47q-66 0-113 47t-47 113v280Z"></path></svg>');

function b3e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = x3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var w3e = $r('<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>');

function k3e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = w3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var T3e = $r('<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>');

function P3e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = T3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    viewBox: "0 0 216 216",
    ...r
  }), void 0, void 0, void 0, "svelte-14mu38d"), O(d, x)
}
var S3e = $r('<svg><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240ZM330-120 120-330v-300l210-210h300l210 210v300L630-120H330Zm34-80h232l164-164v-232L596-760H364L200-596v232l164 164Zm116-280Z"></path></svg>');

function $_(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = S3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var M3e = $r('<svg><path d="M480-440q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0-80q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0 440q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-400Zm0-315-240 90v189q0 54 15 105t41 96q42-21 88-33t96-12q50 0 96 12t88 33q26-45 41-96t15-105v-189l-240-90Zm0 515q-36 0-70 8t-65 22q29 30 63 52t72 34q38-12 72-34t63-52q-31-14-65-22t-70-8Z"></path></svg>');

function l_(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = M3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var I3e = $r('<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px"><path d="M240-350q-20 0-35-15t-15-35q0-21 15-35.5t35-14.5q21 0 35.5 14.5T290-400q0 20-14.5 35T240-350Zm0-320q-20 0-35-15t-15-35q0-21 15-35.5t35-14.5q21 0 35.5 14.5T290-720q0 20-14.5 35T240-670Zm120 480q-20 0-35-15t-15-35q0-21 15-35.5t35-14.5q21 0 35.5 14.5T410-240q0 20-14.5 35T360-190Zm0-320q-20 0-35-15t-15-35q0-21 15-35.5t35-14.5q21 0 35.5 14.5T410-560q0 20-14.5 35T360-510Zm120 160q-20 0-35-15t-15-35q0-21 15-35.5t35-14.5q21 0 35.5 14.5T530-400q0 20-14.5 35T480-350Zm0-320q-20 0-35-15t-15-35q0-21 15-35.5t35-14.5q21 0 35.5 14.5T530-720q0 20-14.5 35T480-670Zm120 480q-20 0-35-15t-15-35q0-21 15-35.5t35-14.5q21 0 35.5 14.5T650-240q0 20-14.5 35T600-190Zm0-320q-20 0-35-15t-15-35q0-21 15-35.5t35-14.5q21 0 35.5 14.5T650-560q0 20-14.5 35T600-510Zm120 160q-20 0-35-15t-15-35q0-21 15-35.5t35-14.5q21 0 35.5 14.5T770-400q0 20-14.5 35T720-350Zm0-320q-20 0-35-15t-15-35q0-21 15-35.5t35-14.5q21 0 35.5 14.5T770-720q0 20-14.5 35T720-670Z"></path></svg>');

function C3e(d, s) {
  var r = I3e();
  O(d, r)
}
var A3e = $r('<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>');

function z3e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = A3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var E3e = $r('<svg><path d="M480-320q75 0 127.5-52.5T660-500q0-75-52.5-127.5T480-680q-75 0-127.5 52.5T300-500q0 75 52.5 127.5T480-320Zm0-72q-45 0-76.5-31.5T372-500q0-45 31.5-76.5T480-608q45 0 76.5 31.5T588-500q0 45-31.5 76.5T480-392Zm0 192q-146 0-266-81.5T40-500q54-137 174-218.5T480-800q146 0 266 81.5T920-500q-54 137-174 218.5T480-200Zm0-300Zm0 220q113 0 207.5-59.5T832-500q-50-101-144.5-160.5T480-720q-113 0-207.5 59.5T128-500q50 101 144.5 160.5T480-280Z"></path></svg>');

function L3e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = E3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var D3e = $r('<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>');

function By(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = D3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var R3e = $r('<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>');

function j3e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = R3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var F3e = $r('<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>');

function B3e(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = F3e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var O3e = se('<img alt="Frame equipado" class="pointer-events-none absolute inset-0 -bottom-1 -right-1 select-none"/>'),
  q3e = se('<span class="tooltip font-flag ml-0.5"> </span>'),
  N3e = se('<div class="mt-1"><!></div>'),
  V3e = se('<p class="w-full"> <!></p>'),
  U3e = se('<p class="w-full"><!></p>'),
  Z3e = se('<div class=" flex items-center gap-2"><!> <!> <button class="btn btn-error btn-sm"><!> </button></div>'),
  G3e = se('<span class="center-absolute loading loading-spinner loading-xs absolute"></span>'),
  $3e = se("<li><button><!> </button></li>"),
  W3e = se('<div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div>'),
  H3e = se('<button class="btn btn-sm btn-circle tooltip"><!></button>'),
  X3e = se('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>'),
  Y3e = se('<a class="btn w-full" target="_blank"><!> </a>'),
  K3e = se('<a class="btn w-full" target="_blank"><!> </a>'),
  J3e = se('<a class="btn w-full" target="_blank"><!> </a>'),
  Q3e = se('<form class="w-full" method="POST"><button class="btn w-full"><!> </button></form> <a class="btn w-full" target="_blank"><!> </a>', 1),
  eke = se('<div class="dropdown"><div tabindex="0" role="button"><!> <!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="-1"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><!> <div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle tooltip"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 max-h-[50svh] w-max flex-nowrap overflow-y-auto rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div> <!> <div class="tooltip"><button><!></button></div> <!> <button class="btn btn-sm btn-circle tooltip relative before:-left-1/2"><!> <!></button></div></div>  <!> <!> <!> <!> <a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> </a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> </a> <!> <button class="btn"><!> </button></section></div></div> <!>', 1);

function tke(d, s) {
  var fe;
  Qr(s, !0);
  let r = We(!1),
    x = We(!1),
    A = We(!0);

  function E() {
    var Z;
    (Z = document.activeElement) == null || Z.blur()
  }
  const k = [{
    label: "ğŸ‡ºğŸ‡¸ English",
    key: "en"
  }, {
    label: "ğŸ‡§ğŸ‡· PortuguÃªs",
    key: "pt"
  }, ...(fe = s.user.data) != null && fe.role && s.user.data.role !== "user" ? [{
    label: "ğŸ‡¨ğŸ‡³ ä¸­æ–‡",
    key: "ch"
  }, {
    label: "ğŸ‡©ğŸ‡ª Deutsch",
    key: "de"
  }, {
    label: "ğŸ‡ªğŸ‡¸ EspaÃ±ol",
    key: "es"
  }, {
    label: "ğŸ‡«ğŸ‡· FranÃ§ais",
    key: "fr"
  }, {
    label: "ğŸ‡®ğŸ‡¹ Italiano",
    key: "it"
  }, {
    label: "ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª",
    key: "jp"
  }, {
    label: "ğŸ‡µğŸ‡± Polski",
    key: "pl"
  }, {
    label: "ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹",
    key: "ru"
  }, {
    label: "ğŸ‡ºğŸ‡¦ Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°",
    key: "uk"
  }, {
    label: "ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t",
    key: "vi"
  }] : []];
  let l = We(""),
    j = We(void 0);
  const W = xt(() => !!s.user.timeoutUntil);
  let $ = We("");
  Wi(async () => {
    if (s.user.data || await s.user.refresh(), s.user.hasAnyPermission(Fi.dashboard.summary)) {
      G($, `${xi.url.origin}/dashboard/summary`);
      return
    }
    if (s.user.hasAnyPermission(Fi.dashboard.team)) {
      G($, `${xi.url.origin}/dashboard/team`);
      return
    }
    if (s.user.hasAnyPermission(Fi.dashboard.users)) {
      G($, `${xi.url.origin}/dashboard/users`);
      return
    }
    if (s.user.hasAnyPermission(Fi.dashboard.permissions)) {
      G($, `${xi.url.origin}/dashboard/permissions`);
      return
    }
    if (s.user.hasAnyPermission(Fi.dashboard.alliances)) {
      G($, `${xi.url.origin}/dashboard/alliances`);
      return
    }
    if (s.user.hasAnyPermission(Fi.dashboard.auditLogs)) {
      G($, `${xi.url.origin}/dashboard/audit-logs`);
      return
    }
    if (s.user.hasAnyPermission(Fi.dashboard.banWaves)) {
      G($, `${xi.url.origin}/dashboard/ban-waves`);
      return
    }
  });
  var J = Ir(),
    ce = Pt(J);
  {
    var ge = Z => {
      var de = eke(),
        Fe = Pt(de),
        Re = S(Fe);
      let Pe;
      var Ge = S(Re);
      _0(Ge, {
        get userId() {
          return s.user.data.id
        },
        get level() {
          return s.user.data.level
        },
        get pictureUrl() {
          return s.user.data.picture
        }
      });
      var et = L(Ge, 2);
      {
        var Ve = Le => {
          a0(Le, {
            class: "absolute -right-0.5 -top-0.5",
            get count() {
              return s.user.notificiationCount
            }
          })
        };
        we(et, Le => {
          s.user.notificiationCount && Le(Ve)
        })
      }
      P(Re);
      var ve = L(Re, 2),
        Me = S(ve);
      Me.__click = E;
      var Ye = S(Me);
      ms(Ye, {
        class: "size-5"
      }), P(Me);
      var Ce = L(Me, 2),
        Oe = S(Ce),
        ut = S(Oe);
      Fa(ut, {
        get userId() {
          return s.user.data.id
        },
        get pictureUrl() {
          return s.user.data.picture
        },
        get isSuspended() {
          return g(W)
        }
      });
      var Ue = L(ut, 2);
      {
        var Ke = Le => {
          var tt = O3e();
          ze(() => or(tt, "src", s.user.data.equippedFrameUrl)), O(Le, tt)
        };
        we(Ue, Le => {
          s.user.data.equippedFrameUrl && Le(Ke)
        })
      }
      var St = L(Ue, 2);
      St.__click = () => {
        G(r, !0)
      };
      var Ft = S(St);
      p_(Ft, {
        class: "size-4"
      }), P(St), P(Oe);
      var Jt = L(Oe, 2),
        Mt = S(Jt),
        ct = S(Mt),
        wt = S(ct, !0);
      P(ct);
      var ft = L(ct, 2),
        $t = S(ft);
      P(ft);
      var Et = L(ft, 2);
      {
        var Qt = Le => {
          const tt = xt(() => qo(s.user.data.equippedFlag));
          var qt = q3e(),
            Ut = S(qt, !0);
          P(qt), ze(() => {
            or(qt, "data-tip", g(tt).name), ee(Ut, g(tt).flag)
          }), O(Le, qt)
        };
        we(Et, Le => {
          s.user.data.equippedFlag && Le(Qt)
        })
      }
      var vr = L(Et, 2);
      {
        var Kt = Le => {
          var tt = N3e(),
            qt = S(tt);
          Nh(qt, {
            get username() {
              return s.user.data.discord
            },
            get id() {
              return s.user.data.discordId
            }
          }), P(tt), O(Le, tt)
        };
        we(vr, Le => {
          s.user.data.discord && Le(Kt)
        })
      }
      P(Mt);
      var Bt = L(Mt, 2),
        it = S(Bt);
      Pl(it, {
        class: "inline size-4"
      });
      var He = L(it, 2),
        Ot = S(He),
        Gt = L(Ot),
        kt = S(Gt, !0);
      P(Gt), P(He), P(Bt);
      var nr = L(Bt, 2),
        It = S(nr);
      f3e(It, {
        class: "inline size-4"
      });
      var mt = L(It, 2),
        yt = S(mt),
        bt = S(yt);
      P(yt);
      var Lt = L(yt),
        st = L(Lt),
        lr = S(st);
      oh(lr, {
        class: "mb-0.5 inline size-4 opacity-50"
      }), P(st), P(mt), P(nr), P(Jt), P(Ce);
      var gr = L(Ce, 2),
        dr = S(gr);
      {
        var pr = Le => {
          var tt = Z3e(),
            qt = S(tt);
          $_(qt, {
            class: "size-6 text-red-500"
          });
          var Ut = L(qt, 2);
          {
            var fr = Br => {
                var Cr = V3e(),
                  Yr = S(Cr),
                  Ln = L(Yr);
                {
                  var In = jr => {
                      var wn = vi();
                      ze(En => ee(wn, `(${En??""})`), [() => kv({
                        reason: c1()
                      })]), O(jr, wn)
                    },
                    Wr = jr => {
                      var wn = Ir(),
                        En = Pt(wn);
                      {
                        var Mn = qn => {
                          var Gn = vi();
                          ze(Jn => ee(Gn, `(${Jn??""})`), [() => kv({
                            reason: u1()
                          })]), O(qn, Gn)
                        };
                        we(En, qn => {
                          s.user.data.suspensionReason === "multi-accounting" && qn(Mn)
                        }, !0)
                      }
                      O(jr, wn)
                    };
                  we(Ln, jr => {
                    s.user.data.suspensionReason === "bot" ? jr(In) : jr(Wr, !1)
                  })
                }
                P(Cr), ze(jr => ee(Yr, `${jr??""} `), [() => Kae()]), O(Br, Cr)
              },
              Wt = Br => {
                var Cr = Ir(),
                  Yr = Pt(Cr);
                {
                  var Ln = In => {
                    var Wr = U3e(),
                      jr = S(Wr);
                    Fp(jr, () => l1({
                      until: `<span class="text-secondary font-medium text-nowrap">${s.user.timeoutUntil.toLocaleString()}</span>`
                    })), P(Wr), O(In, Wr)
                  };
                  we(Yr, In => {
                    s.user.timeoutUntil && In(Ln)
                  }, !0)
                }
                O(Br, Cr)
              };
            we(Ut, Br => {
              s.user.data.timeoutUntil && new Date(s.user.data.timeoutUntil).getTime() >= Date.now() + 31536e6 ? Br(fr) : Br(Wt, !1)
            })
          }
          var yr = L(Ut, 2);
          yr.__click = Br => {
            var Cr;
            (Cr = s.onbanappeal) == null || Cr.call(s)
          };
          var tn = S(yr);
          $_(tn, {
            class: "size-5 text-red-500"
          });
          var Kr = L(tn, 1, !0);
          P(yr), P(tt), ze(Br => ee(Kr, Br), [() => Tee()]), O(Le, tt)
        };
        we(dr, Le => {
          g(W) && Le(pr)
        })
      }
      var Ht = L(dr, 2),
        Sr = S(Ht),
        Rr = S(Sr, !0);
      P(Sr);
      var Vt = L(Sr, 2),
        Tr = S(Vt),
        Xt = S(Tr),
        ue = S(Xt);
      z3e(ue, {
        class: "size-4"
      }), P(Xt);
      var N = L(Xt, 2);
      li(N, 21, () => k, Bc, (Le, tt) => {
        const qt = xt(() => g(l) === g(tt).key),
          Ut = xt(() => X1() === g(tt).key);
        var fr = $3e(),
          Wt = S(fr);
        let yr;
        Wt.__click = () => {
          localStorage.setItem(P1, g(tt).key), G(l, g(tt).key, !0), location.reload()
        };
        var tn = S(Wt);
        {
          var Kr = Cr => {
            var Yr = G3e();
            O(Cr, Yr)
          };
          we(tn, Cr => {
            g(qt) && Cr(Kr)
          })
        }
        var Br = L(tn);
        P(Wt), P(fr), ze(() => {
          yr = Or(Wt, 1, "font-flag relative font-medium", null, yr, {
            "bg-base-200": g(qt),
            "bg-base-300": g(Ut)
          }), ee(Br, ` ${g(tt).label??""}`)
        }), O(Le, fr)
      }), P(N), P(Tr);
      var q = L(Tr, 2),
        X = S(q);
      X.__click = () => {
        $i.muted = !$i.muted
      };
      var te = S(X);
      {
        var le = Le => {
            j3e(Le, {
              class: "size-4"
            })
          },
          xe = Le => {
            B3e(Le, {
              class: "size-4"
            })
          };
        we(te, Le => {
          $i.muted ? Le(le) : Le(xe, !1)
        })
      }
      P(X), P(q);
      var je = L(q, 2);
      {
        var Ie = Le => {
          var tt = W3e(),
            qt = S(tt);
          qt.__click = () => {
            $i.theme = $i.theme === "dark" ? "custom-winter" : "dark"
          };
          var Ut = S(qt);
          {
            var fr = yr => {
                v3e(yr, {
                  class: "size-4"
                })
              },
              Wt = yr => {
                m3e(yr, {
                  class: "size-4"
                })
              };
            we(Ut, yr => {
              $i.theme === "dark" ? yr(fr) : yr(Wt, !1)
            })
          }
          P(qt), P(tt), ze(yr => or(tt, "data-tip", yr), [() => $i.theme === "dark" ? WL() : M4()]), O(Le, tt)
        };
        we(je, Le => {
          s.user.hasPermission(Fi.ui.themeDarkMode) && Le(Ie)
        })
      }
      var qe = L(je, 2),
        rt = S(qe);
      let Xe;
      rt.__click = () => {
        $i.snowflakesEnabled = !$i.snowflakesEnabled
      };
      var he = S(rt);
      C3e(he), P(rt), P(qe);
      var Q = L(qe, 2);
      {
        var Ze = Le => {
          var tt = H3e();
          tt.__click = () => {
            var Wt;
            G(A, !g(A)), (Wt = s.ontogglepixelarts) == null || Wt.call(s, g(A))
          };
          var qt = S(tt);
          {
            var Ut = Wt => {
                L3e(Wt, {
                  class: "size-4"
                })
              },
              fr = Wt => {
                By(Wt, {
                  class: "size-4"
                })
              };
            we(qt, Wt => {
              g(A) ? Wt(fr, !1) : Wt(Ut)
            })
          }
          P(tt), ze(Wt => or(tt, "data-tip", Wt), [() => g(A) == !1 ? sK() : fz()]), O(Le, tt)
        };
        we(Q, Le => {
          s.user.hasPermission(Fi.ui.tooglePixelArt) && Le(Ze)
        })
      }
      var vt = L(Q, 2);
      vt.__click = function(...Le) {
        var tt;
        (tt = s.onnotificationclick) == null || tt.apply(this, Le)
      };
      var Qe = S(vt);
      b3e(Qe, {
        class: "size-4"
      });
      var oe = L(Qe, 2);
      {
        var De = Le => {
          a0(Le, {
            class: "absolute -right-1 -top-1",
            get count() {
              return s.user.notificiationCount
            }
          })
        };
        we(oe, Le => {
          s.user.notificiationCount && Le(De)
        })
      }
      P(vt), P(Vt), P(Ht);
      var Je = L(Ht, 2);
      {
        var Tt = Le => {
          var tt = X3e();
          tt.__click = async () => {
            var fr;
            try {
              const Wt = await ((fr = g(j)) == null ? void 0 : fr.prompt());
              (Wt == null ? void 0 : Wt.outcome) === "accepted" && G(j, void 0)
            } catch (Wt) {
              rr.error(GP({
                error: Wt.message
              }))
            }
          };
          var qt = S(tt);
          rm(qt, {
            class: "size-5"
          });
          var Ut = L(qt);
          P(tt), ze(fr => ee(Ut, ` ${fr??""}`), [() => kE()]), O(Le, tt)
        };
        we(Je, Le => {
          g(j) && Le(Tt)
        })
      }
      var Dt = L(Je, 2);
      {
        var _t = Le => {
          var tt = Y3e(),
            qt = S(tt);
          l_(qt, {
            class: "size-5"
          });
          var Ut = L(qt);
          P(tt), ze(fr => {
            or(tt, "href", g($)), ee(Ut, ` ${fr??""}`)
          }, [() => e2()]), O(Le, tt)
        };
        we(Dt, Le => {
          s.user.hasAnyPermission(Fi.dashboard) && Le(_t)
        })
      }
      var zt = L(Dt, 2);
      {
        var Yt = Le => {
          var tt = K3e(),
            qt = S(tt);
          l_(qt, {
            class: "size-5"
          });
          var Ut = L(qt);
          P(tt), ze(fr => {
            or(tt, "href", `${xi.url.origin??""}/tickets`), ee(Ut, ` ${fr??""}`)
          }, [() => JQ()]), O(Le, tt)
        };
        we(zt, Le => {
          s.user.hasAnyPermission(Fi.tickets) && Le(Yt)
        })
      }
      var $e = L(zt, 2);
      {
        var Ct = Le => {
          var tt = J3e(),
            qt = S(tt);
          l_(qt, {
            class: "size-5"
          });
          var Ut = L(qt);
          P(tt), ze(fr => {
            or(tt, "href", `${xi.url.origin??""}/appeals`), ee(Ut, ` ${fr??""}`)
          }, [() => Q1()]), O(Le, tt)
        };
        we($e, Le => {
          s.user.hasAnyPermission(Fi.appeals) && Le(Ct)
        })
      }
      var ir = L($e, 2),
        Fr = S(ir);
      b_(Fr, {
        class: "size-5"
      });
      var br = L(Fr);
      P(ir);
      var nt = L(ir, 2),
        cr = S(nt);
      P3e(cr, {
        class: "size-5"
      });
      var ar = L(cr);
      P(nt);
      var Ar = L(nt, 2);
      {
        var qr = Le => {
          var tt = Q3e(),
            qt = Pt(tt),
            Ut = S(qt),
            fr = S(Ut);
          k3e(fr, {
            class: "size-5"
          });
          var Wt = L(fr);
          P(Ut), P(qt);
          var yr = L(qt, 2),
            tn = S(yr);
          oh(tn, {
            class: "size-5"
          });
          var Kr = L(tn);
          P(yr), ze((Br, Cr, Yr) => {
            or(qt, "action", `${i1}/payment/create-portal-session`), ee(Wt, ` ${Br??""}`), or(yr, "href", Cr), ee(Kr, ` ${Yr??""}`)
          }, [() => L1(), T0, () => O0()]), O(Le, tt)
        };
        we(Ar, Le => {
          var tt;
          (tt = s.user.data) != null && tt.isCustomer && Le(qr)
        })
      }
      var Gr = L(Ar, 2);
      Gr.__click = async () => {
        var Le;
        try {
          G(x, !0), await s.user.logout(), E(), rr.warning(AR(), {
            icon: o0
          }), (Le = s.onlogout) == null || Le.call(s)
        } catch {
          rr.error(iS())
        } finally {
          G(x, !1)
        }
      };
      var Mr = S(Gr);
      o0(Mr, {
        class: "size-5"
      });
      var Sn = L(Mr);
      P(Gr), P(gr), P(ve), P(Fe);
      var Vr = L(Fe, 2);
      d3e(Vr, {
        get userData() {
          return s.user.data
        },
        get open() {
          return g(r)
        },
        set open(Le) {
          G(r, Le, !0)
        }
      }), ze((Le, tt, qt, Ut, fr, Wt, yr, tn, Kr, Br, Cr, Yr, Ln, In, Wr) => {
        Pe = Or(Re, 1, "btn relative size-12 p-0 shadow-md", null, Pe, {
          "bg-red-500": g(W)
        }), or(Re, "title", Le), or(ct, "title", s.user.data.name), ee(wt, s.user.data.name), Or(ft, 1, tt), ee($t, `#${s.user.data.id??""}`), ee(Ot, `${qt??""}: `), ee(kt, Ut), ee(bt, `Level ${fr??""}`), ee(Lt, ` (${Wt??""}%) `), or(st, "data-tip", yr), ee(Rr, tn), or(Xt, "data-tip", Kr), or(q, "data-tip", Br), or(qe, "data-tip", Cr), Xe = Or(rt, 1, "btn btn-sm btn-circle", null, Xe, {
          "btn-primary": $i.snowflakesEnabled
        }), or(vt, "data-tip", Yr), ee(br, ` ${Ln??""}`), ee(ar, ` ${In??""}`), Gr.disabled = g(x), ee(Sn, ` ${Wr??""}`)
      }, [() => xK(), () => Us(ta(s.user.data.id)), () => tm(), () => s.user.data.pixelsPainted.toLocaleString("en-US"), () => Math.floor(s.user.data.level), () => Math.floor(s.user.data.level % 1 * 100), () => Ij(), () => Nj(), () => Jk(), () => $i.muted ? mne() : S7(), () => $i.snowflakesEnabled ? Dge() : Wge(), () => j0(), () => z1(), () => v1(), () => E1()]), Pn("focus", Re, () => {
        G(j, window.pwaInstallPrompt, !0)
      }), O(Z, de)
    };
    we(ce, Z => {
      s.user.data && s.user.charges !== void 0 && Z(ge)
    })
  }
  O(d, J), en()
}
Yn(["click"]);
var rke = se('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  nke = se('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  ike = se('<span class="font-flag tooltip ml-0.5"> </span>'),
  ake = se("<span> </span>"),
  oke = se('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  ske = se('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  lke = se('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  cke = se('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  uke = se('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  hke = se('<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>', 1);

function dke(d, s) {
  Qr(s, !0);
  const r = [];
  let x = We("today"),
    A = {
      players: {
        label: B0(),
        icon: Np
      },
      alliances: {
        label: P0(),
        icon: Vp
      }
    },
    E = We("players"),
    k = Pi({
      players: {},
      alliances: {}
    });
  const l = xt(() => k[g(E)][g(x)]);
  rn(() => {
    if (g(l)) return;
    const Z = g(x),
      de = g(E);
    de === "players" ? pn.leaderboardRegionPlayers(s.regionId, Z).then(Fe => {
      k[de][Z] = Fe
    }).catch(Fe => {
      rr.error(Fe.message)
    }) : de === "alliances" && pn.leaderboardRegionAlliances(s.regionId, Z).then(Fe => {
      k[de][Z] = Fe
    }).catch(Fe => {
      rr.error(Fe.message)
    })
  });
  var j = hke(),
    W = Pt(j);
  li(W, 21, () => Object.entries(A), ([Z, {
    label: de,
    icon: Fe
  }]) => Z, (Z, de) => {
    var Fe = xt(() => u0(g(de), 2));
    let Re = () => g(Fe)[0],
      Pe = () => g(Fe)[1].label,
      Ge = () => g(Fe)[1].icon;
    const et = xt(Ge);
    var Ve = rke(),
      ve = S(Ve);
    sa(ve);
    var Me, Ye = L(ve, 2);
    ka(Ye, () => g(et), (Oe, ut) => {
      ut(Oe, {
        get this() {
          return Ge()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var Ce = L(Ye);
    P(Ve), ze(() => {
      or(ve, "aria-label", Pe()), Me !== (Me = Re()) && (ve.value = (ve.__value = Re()) ?? ""), ee(Ce, ` ${Pe()??""}`)
    }), Q_(r, [], ve, () => (Re(), g(E)), Oe => G(E, Oe)), O(Z, Ve)
  }), P(W);
  var $ = L(W, 2),
    J = S($);
  vm(J, {
    get value() {
      return g(x)
    },
    set value(Z) {
      G(x, Z, !0)
    }
  }), P($);
  var ce = L($, 2);
  {
    var ge = Z => {
        var de = nke(),
          Fe = S(de),
          Re = L(Fe);
        {
          var Pe = et => {
              var Ve = vi();
              ze(ve => ee(Ve, ve), [() => qp().toLowerCase()]), O(et, Ve)
            },
            Ge = et => {
              var Ve = Ir(),
                ve = Pt(Ve);
              {
                var Me = Ce => {
                    var Oe = vi();
                    ze(ut => ee(Oe, ut), [() => hm()]), O(Ce, Oe)
                  },
                  Ye = Ce => {
                    var Oe = Ir(),
                      ut = Pt(Oe);
                    {
                      var Ue = Ke => {
                        var St = vi();
                        ze(Ft => ee(St, Ft), [() => um()]), O(Ke, St)
                      };
                      we(ut, Ke => {
                        g(x) === "month" && Ke(Ue)
                      }, !0)
                    }
                    O(Ce, Oe)
                  };
                we(ve, Ce => {
                  g(x) === "week" ? Ce(Me) : Ce(Ye, !1)
                }, !0)
              }
              O(et, Ve)
            };
          we(Re, et => {
            g(x) === "today" ? et(Pe) : et(Ge, !1)
          })
        }
        P(de), ze(et => ee(Fe, `${et??""} `), [() => cm()]), O(Z, de)
      },
      fe = Z => {
        var de = Ir(),
          Fe = Pt(de);
        {
          var Re = Ge => {
              var et = Ir(),
                Ve = Pt(et);
              {
                var ve = Ye => {
                    const Ce = xt(() => g(l));
                    var Oe = ske(),
                      ut = S(Oe),
                      Ue = S(ut),
                      Ke = L(S(Ue)),
                      St = S(Ke, !0);
                    P(Ke);
                    var Ft = L(Ke),
                      Jt = S(Ft),
                      Mt = L(Jt, 2, !0);
                    P(Ft), P(Ue), P(ut);
                    var ct = L(ut);
                    li(ct, 31, () => g(Ce), wt => wt.id, (wt, ft, $t) => {
                      const Et = xt(() => {
                        var Ht;
                        return ((Ht = Rt.data) == null ? void 0 : Ht.id) === g(ft).id
                      });
                      var Qt = oke();
                      let vr;
                      var Kt = S(Qt),
                        Bt = S(Kt, !0);
                      P(Kt);
                      var it = L(Kt),
                        He = S(it),
                        Ot = S(He);
                      Fa(Ot, {
                        class: "size-10 border",
                        get userId() {
                          return g(ft).id
                        },
                        get pictureUrl() {
                          return g(ft).picture
                        },
                        get borderUrl() {
                          return g(ft).frameUrl
                        }
                      });
                      var Gt = L(Ot, 2),
                        kt = S(Gt),
                        nr = S(kt),
                        It = L(nr),
                        mt = S(It);
                      P(It), P(kt);
                      var yt = L(kt, 2);
                      {
                        var bt = Ht => {
                          const Sr = xt(() => qo(g(ft).equippedFlag));
                          var Rr = ike(),
                            Vt = S(Rr, !0);
                          P(Rr), ze(() => {
                            or(Rr, "data-tip", g(Sr).name), ee(Vt, g(Sr).flag)
                          }), O(Ht, Rr)
                        };
                        we(yt, Ht => {
                          "equippedFlag" in g(ft) && g(ft).equippedFlag && Ht(bt)
                        })
                      }
                      var Lt = L(yt, 2);
                      {
                        var st = Ht => {
                          Nh(Ht, {
                            get username() {
                              return g(ft).discord
                            },
                            get id() {
                              return g(ft).discordId
                            }
                          })
                        };
                        we(Lt, Ht => {
                          g(ft).discord && Ht(st)
                        })
                      }
                      var lr = L(Lt, 2);
                      {
                        var gr = Ht => {
                          var Sr = ake(),
                            Rr = S(Sr, !0);
                          P(Sr), ze((Vt, Tr) => {
                            Or(Sr, 1, `badge badge-sm ml-0.5 border-0 ${Vt??""} ${Tr??""}`), ee(Rr, g(ft).allianceName)
                          }, [() => jp(g(ft).allianceId), () => ta(g(ft).allianceId)]), O(Ht, Sr)
                        };
                        we(lr, Ht => {
                          "allianceName" in g(ft) && g(ft).allianceName && Ht(gr)
                        })
                      }
                      P(Gt), P(He), P(it);
                      var dr = L(it),
                        pr = S(dr, !0);
                      P(dr), P(Qt), ze((Ht, Sr) => {
                        vr = Or(Qt, 1, "", null, vr, {
                          "bg-base-200": g(Et)
                        }), ee(Bt, g($t) + 1), Or(kt, 1, `font-semibold max-sm:ml-2 ${Ht??""} flex gap-1`), ee(nr, `${g(ft).name??""} `), ee(mt, `#${g(ft).id??""}`), ee(pr, Sr)
                      }, [() => ta(g(ft).id), () => g(ft).pixelsPainted.toLocaleString("en-US")]), vl(Qt, () => yl, () => ({
                        duration: 200
                      })), O(wt, Qt)
                    }), P(ct), P(Oe), ze((wt, ft, $t) => {
                      ee(St, wt), ee(Jt, `${ft??""} `), ee(Mt, $t)
                    }, [() => nm(), () => xl(), () => Ac().toLowerCase()]), O(Ye, Oe)
                  },
                  Me = Ye => {
                    var Ce = Ir(),
                      Oe = Pt(Ce);
                    {
                      var ut = Ue => {
                        var Ke = cke(),
                          St = S(Ke),
                          Ft = S(St),
                          Jt = L(S(Ft)),
                          Mt = S(Jt, !0);
                        P(Jt);
                        var ct = L(Jt),
                          wt = S(ct),
                          ft = L(wt, 2, !0);
                        P(ct), P(Ft), P(St);
                        var $t = L(St);
                        li($t, 31, () => g(l), Et => Et.id, (Et, Qt, vr) => {
                          const Kt = xt(() => {
                            var yt;
                            return ((yt = Rt.data) == null ? void 0 : yt.allianceId) === g(Qt).id
                          });
                          var Bt = lke();
                          let it;
                          var He = S(Bt),
                            Ot = S(He, !0);
                          P(He);
                          var Gt = L(He),
                            kt = S(Gt),
                            nr = S(kt, !0);
                          P(kt), P(Gt);
                          var It = L(Gt),
                            mt = S(It, !0);
                          P(It), P(Bt), ze((yt, bt) => {
                            it = Or(Bt, 1, "", null, it, {
                              "bg-base-200": g(Kt)
                            }), ee(Ot, g(vr) + 1), Or(kt, 1, `font-semibold ${yt??""}`), ee(nr, g(Qt).name), ee(mt, bt)
                          }, [() => ta(g(Qt).id), () => g(Qt).pixelsPainted.toLocaleString("en-US")]), vl(Bt, () => yl, () => ({
                            duration: 200
                          })), O(Et, Bt)
                        }), P($t), P(Ke), ze((Et, Qt, vr) => {
                          ee(Mt, Et), ee(wt, `${Qt??""} `), ee(ft, vr)
                        }, [() => Bp(), () => xl(), () => Ac().toLowerCase()]), O(Ue, Ke)
                      };
                      we(Oe, Ue => {
                        g(E) === "alliances" && Ue(ut)
                      }, !0)
                    }
                    O(Ye, Ce)
                  };
                we(Ve, Ye => {
                  g(E) === "players" ? Ye(ve) : Ye(Me, !1)
                })
              }
              O(Ge, et)
            },
            Pe = Ge => {
              var et = uke();
              O(Ge, et)
            };
          we(Fe, Ge => {
            g(l) ? Ge(Re) : Ge(Pe, !1)
          }, !0)
        }
        O(Z, de)
      };
    we(ce, Z => {
      g(l) && g(l).length === 0 ? Z(ge) : Z(fe, !1)
    })
  }
  O(d, j), en()
}
var pke = se('<div class="mt-5"><!></div>'),
  fke = se('<dialog class="modal" closedby="any"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function _ke(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15);
  const x = xt(() => qo(s.region.countryId));
  var A = fke(),
    E = S(A),
    k = L(S(E), 2),
    l = S(k),
    j = S(l, !0);
  P(l);
  var W = L(l, 2),
    $ = S(W, !0);
  P(W);
  var J = L(W, 2),
    ce = S(J);
  P(J), P(k);
  var ge = L(k, 2);
  {
    var fe = Z => {
      var de = pke(),
        Fe = S(de);
      dke(Fe, {
        get regionId() {
          return s.region.id
        }
      }), P(de), oa(2, de, () => Ka, () => ({
        duration: 300
      })), O(Z, de)
    };
    we(ge, Z => {
      r() && Z(fe)
    })
  }
  P(E), bn(2), P(A), Li(A, () => Z => {
    rn(() => {
      r() ? Z.show() : Z.close()
    })
  }), ze(Z => {
    Or(k, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${Z??""}`), or(l, "data-tip", g(x).name), ee(j, g(x).flag), ee($, s.region.name), ee(ce, `#${s.region.number??""}`)
  }, [() => ta(s.region.cityId)]), Pn("close", A, () => r(!1)), O(d, A), en()
}

function mke(d) {
  switch (d) {
    case "en":
    case "pt":
    case "es":
    case "fr":
    case "de":
    case "it":
    case "pl":
    case "ru":
    case "uk":
    case "vi":
      return d;
    case "jp":
      return "ja";
    case "ch":
      return "zh";
    default:
      return ""
  }
}
async function gke(d) {
  const s = mke(Se());
  let r = `https://geocoding.wplace.live/v1/autocomplete?text=${encodeURIComponent(d)}${s!=="en"?`&lang=${s}`:""}`;
  const x = await fetch(r);
  if (!x.ok) {
    const A = await x.text();
    throw console.error(`Geocoding API error: ${A}`), new Error(h1())
  }
  return x.json()
}
var vke = se('<div class="text-base-content/80 absolute right-3 top-1/2 z-10 -translate-y-1/2 sm:right-6"><button class="btn btn-ghost btn-sm btn-circle hidden group-hover:flex"><!></button></div>'),
  yke = se('<div class="group relative"><button class="hover:bg-base-200 active:bg-base-200 flex w-full gap-3 px-3 py-2 sm:px-6"><!> <div class="sm:pr-8"><h3 class="text-left font-semibold"> </h3> <div class="text-base-content/80 text-left text-sm"> </div></div></button> <!></div>');

function c_(d, s) {
  Qr(s, !0);
  const r = (l, j) => {
    let W = () => j == null ? void 0 : j().name,
      $ = () => j == null ? void 0 : j().label,
      J = () => j == null ? void 0 : j().onclick;
    var ce = yke(),
      ge = S(ce);
    ge.__click = function(...Ve) {
      var ve;
      (ve = J()) == null || ve.apply(this, Ve)
    };
    var fe = S(ge);
    wl(fe, {
      class: "text-base-content/80 mt-0.5 size-6 min-w-6"
    });
    var Z = L(fe, 2),
      de = S(Z),
      Fe = S(de, !0);
    P(de);
    var Re = L(de, 2),
      Pe = S(Re, !0);
    P(Re), P(Z), P(ge);
    var Ge = L(ge, 2);
    {
      var et = Ve => {
        var ve = vke(),
          Me = S(ve);
        Me.__click = function(...Ce) {
          var Oe;
          (Oe = s.onremove) == null || Oe.apply(this, Ce)
        };
        var Ye = S(Me);
        ms(Ye, {
          class: "size-4"
        }), P(Me), P(ve), O(Ve, ve)
      };
      we(Ge, Ve => {
        s.onremove && Ve(et)
      })
    }
    P(ce), ze(() => {
      ee(Fe, W()), ee(Pe, $())
    }), O(l, ce)
  };
  var x = Ir(),
    A = Pt(x);
  {
    var E = l => {
        r(l, () => ({
          name: s.location.name,
          label: s.location.label,
          onclick: s.onclick
        }))
      },
      k = l => {
        var j = Ir(),
          W = Pt(j);
        {
          var $ = ce => {
              {
                let ge = xt(() => ({
                  name: s.location.name,
                  label: lm(),
                  onclick: s.onclick
                }));
                r(ce, () => g(ge))
              }
            },
            J = ce => {
              var ge = Ir(),
                fe = Pt(ge);
              {
                var Z = de => {
                  {
                    let Fe = xt(() => ({
                      name: `${s.location.pos.lat.toFixed(4)}, ${s.location.pos.lng.toFixed(4)}`,
                      label: D0(),
                      onclick: s.onclick
                    }));
                    r(de, () => g(Fe))
                  }
                };
                we(fe, de => {
                  s.location.type === "coordinates" && de(Z)
                }, !0)
              }
              O(ce, ge)
            };
          we(W, ce => {
            s.location.type === "country" ? ce($) : ce(J, !1)
          }, !0)
        }
        O(l, j)
      };
    we(A, l => {
      s.location.type === "place" ? l(E) : l(k, !1)
    })
  }
  O(d, x), en()
}
Yn(["click"]);
var xke = $r('<svg><path d="m336-280 144-144 144 144 56-56-144-144 144-144-56-56-144 144-144-144-56 56 144 144-144 144 56 56ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function bke(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = xke();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var wke = $r('<svg><path d="M300-240q25 0 42.5-17.5T360-300q0-25-17.5-42.5T300-360q-25 0-42.5 17.5T240-300q0 25 17.5 42.5T300-240Zm0-360q25 0 42.5-17.5T360-660q0-25-17.5-42.5T300-720q-25 0-42.5 17.5T240-660q0 25 17.5 42.5T300-600Zm180 180q25 0 42.5-17.5T540-480q0-25-17.5-42.5T480-540q-25 0-42.5 17.5T420-480q0 25 17.5 42.5T480-420Zm180 180q25 0 42.5-17.5T720-300q0-25-17.5-42.5T660-360q-25 0-42.5 17.5T600-300q0 25 17.5 42.5T660-240Zm0-360q25 0 42.5-17.5T720-660q0-25-17.5-42.5T660-720q-25 0-42.5 17.5T600-660q0 25 17.5 42.5T660-600ZM200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm0-560v560-560Z"></path></svg>');

function kke(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = wke();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var Tke = se('<button type="button" class="absolute right-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button>'),
  Pke = se('<p class="text-base-content/80 pt-4 text-center text-sm"> </p>'),
  Ske = se("<!> <!>", 1),
  Mke = se('<p class="text-base-content/80 pt-6 text-center text-sm"> </p>'),
  Ike = se('<div class="mb-2 flex items-center justify-between px-4 sm:px-7"><h3 class="text-sm font-semibold"> </h3> <button class="btn btn-sm btn-ghost btn-circle tooltip tooltip-bottom before:-translate-x-1/3"><!></button></div> <!> <!>', 1),
  Cke = se('<dialog class="modal duration-0"><div class="modal-box sm:max-h-11/12 sm:h-11/12 flex flex-col p-0 max-sm:h-full max-sm:w-full max-sm:max-w-full max-sm:rounded-none"><section class="px-3 pt-3 sm:px-6 sm:pt-6"><form class="relative h-max"><input class="input placeholder:text-base-content/80 input-no-cancel-button w-full pl-10 pr-9" type="search"/> <button type="button" class="absolute left-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button> <!></form></section> <section class="grow overflow-y-auto overflow-x-hidden pb-3 pt-4 sm:pb-6"><!></section></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Ake(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = We(""),
    A = We(!1),
    E = We(!1);
  const k = new rxe(() => g(x), 400);
  let l = We(null),
    j = We(void 0),
    W = We([]);
  const $ = /^([+-]?([1-8]?\d(\.\d+)?|90(\.0+)?))\s*,\s*([+-]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?))$/,
    J = xt(() => {
      const Ue = $.exec(g(x));
      if (Ue) {
        const Ke = parseFloat(Ue[1]),
          St = parseFloat(Ue[5]);
        return {
          type: "coordinates",
          id: `coords-${Ke}-${St}`,
          pos: {
            lat: Ke,
            lng: St
          },
          zoom: s.tileZoom + 2
        }
      }
    }),
    ce = "recent-locations";
  Wi(() => {
    const Ue = localStorage.getItem(ce);
    if (Ue) try {
      G(W, JSON.parse(Ue))
    } catch (Ke) {
      console.error("Failed to parse recent locations from localStorage", Ke)
    }
  }), rn(() => {
    k.current && gke(k.current).then(Ue => {
      G(j, Ue.features.map(Ke => {
        if (Ke.properties.layer === "country") return {
          type: "country",
          id: Ke.properties.id,
          name: Ke.properties.name,
          bbox: Ke.bbox,
          coordinates: Ke.geometry.type === "Point" ? {
            lat: Ke.geometry.coordinates[1],
            lng: Ke.geometry.coordinates[0]
          } : void 0
        };
        const St = Ke.properties.label.replace(Ke.properties.name + ",", "").trim();
        return {
          type: "place",
          id: Ke.properties.id,
          name: Ke.properties.name,
          label: St,
          bbox: Ke.bbox,
          coordinates: Ke.geometry.type === "Point" ? {
            lat: Ke.geometry.coordinates[1],
            lng: Ke.geometry.coordinates[0]
          } : void 0
        }
      })), g(A) && g(j).length > 0 && fe(g(j)[0])
    })
  }), rn(() => {
    g(x) || G(j, void 0)
  }), rn(() => {
    r() ? setTimeout(() => {
      g(l).focus()
    }, 50) : (G(x, ""), G(A, !1), G(j, void 0))
  });
  async function ge() {
    const {
      tile: Ue,
      pixel: Ke
    } = await pn.getRandomTile(s.season), St = new ja(s.tileSize), Ft = Ue.x * s.tileSize + Ke.x, Jt = Ue.y * s.tileSize + Ke.y, [Mt, ct] = St.pixelsToLatLon(Ft, Jt, s.tileZoom), wt = {
      lat: Mt,
      lng: ct
    }, ft = s.tileZoom + 2;
    s.map.flyTo({
      zoom: ft,
      center: wt
    }), Z({
      type: "coordinates",
      id: `coords-${Mt}-${ct}`,
      pos: wt,
      zoom: ft
    })
  }

  function fe(Ue) {
    Ue.type === "coordinates" ? s.map.flyTo({
      zoom: Ue.zoom,
      center: Ue.pos
    }) : Ue.bbox ? s.map.fitBounds([
      [Ue.bbox[0], Ue.bbox[1]],
      [Ue.bbox[2], Ue.bbox[3]]
    ], {
      padding: 40,
      duration: 1e3
    }) : Ue.coordinates && s.map.flyTo({
      zoom: 16,
      center: Ue.coordinates,
      duration: 1e3
    }), r(!1), G(j, void 0), Z(Ue)
  }

  function Z(Ue) {
    G(W, g(W).filter(St => St.id !== Ue.id)), g(W).unshift(Ue);
    const Ke = 15;
    g(W).length > Ke && G(W, g(W).slice(0, Ke)), G(W, [...g(W)]), localStorage.setItem(ce, JSON.stringify(g(W)))
  }
  var de = Cke(),
    Fe = S(de),
    Re = S(Fe),
    Pe = S(Re),
    Ge = S(Pe);
  sa(Ge), oo(Ge, Ue => G(l, Ue), () => g(l));
  var et = L(Ge, 2);
  et.__click = () => r(!1);
  var Ve = S(et);
  w0(Ve, {
    class: "size-5"
  }), P(et);
  var ve = L(et, 2);
  {
    var Me = Ue => {
      var Ke = Tke();
      Ke.__click = () => G(x, "");
      var St = S(Ke);
      bke(St, {
        class: "size-4.5"
      }), P(Ke), O(Ue, Ke)
    };
    we(ve, Ue => {
      g(x) && Ue(Me)
    })
  }
  P(Pe), P(Re);
  var Ye = L(Re, 2),
    Ce = S(Ye);
  {
    var Oe = Ue => {
        c_(Ue, {
          get location() {
            return g(J)
          },
          onclick: () => fe(g(J))
        })
      },
      ut = Ue => {
        var Ke = Ir(),
          St = Pt(Ke);
        {
          var Ft = Mt => {
              var ct = Ske(),
                wt = Pt(ct);
              li(wt, 17, () => g(j), Et => Et.id, (Et, Qt) => {
                c_(Et, {
                  get location() {
                    return g(Qt)
                  },
                  onclick: () => fe(g(Qt))
                })
              });
              var ft = L(wt, 2);
              {
                var $t = Et => {
                  var Qt = Pke(),
                    vr = S(Qt, !0);
                  P(Qt), ze(Kt => ee(vr, Kt), [() => U9()]), O(Et, Qt)
                };
                we(ft, Et => {
                  g(j).length === 0 && Et($t)
                })
              }
              O(Mt, ct)
            },
            Jt = Mt => {
              var ct = Ike(),
                wt = Pt(ct),
                ft = S(wt),
                $t = S(ft, !0);
              P(ft);
              var Et = L(ft, 2);
              Et.__click = async () => {
                try {
                  await ge(), r(!1)
                } catch (it) {
                  rr.error(it.message)
                } finally {
                  G(E, !1)
                }
              };
              var Qt = S(Et);
              kke(Qt, {
                class: "size-5"
              }), P(Et), P(wt);
              var vr = L(wt, 2);
              li(vr, 17, () => g(W), it => it.id, (it, He) => {
                c_(it, {
                  get location() {
                    return g(He)
                  },
                  onclick: () => {
                    fe(g(He))
                  },
                  onremove: () => {
                    G(W, g(W).filter(Ot => Ot.id !== g(He).id)), localStorage.setItem(ce, JSON.stringify(g(W)))
                  }
                })
              });
              var Kt = L(vr, 2);
              {
                var Bt = it => {
                  var He = Mke(),
                    Ot = S(He, !0);
                  P(He), ze(Gt => ee(Ot, Gt), [() => rO()]), O(it, He)
                };
                we(Kt, it => {
                  g(W).length === 0 && it(Bt)
                })
              }
              ze((it, He) => {
                ee($t, it), or(Et, "data-tip", He), Et.disabled = g(E)
              }, [() => s$(), () => HG()]), O(Mt, ct)
            };
          we(St, Mt => {
            g(j) ? Mt(Ft) : Mt(Jt, !1)
          }, !0)
        }
        O(Ue, Ke)
      };
    we(Ce, Ue => {
      g(J) ? Ue(Oe) : Ue(ut, !1)
    })
  }
  P(Ye), P(Fe), bn(2), P(de), Li(de, () => Ue => {
    rn(() => {
      r() ? Ue.showModal() : Ue.close()
    })
  }), ze(Ue => or(Ge, "placeholder", Ue), [() => x0()]), Pn("close", de, () => r(!1)), Pn("submit", Pe, () => {
    var Ue;
    g(J) ? fe(g(J)) : k.pending ? G(A, !0) : (Ue = g(j)) != null && Ue.length && fe(g(j)[0])
  }), Oc(Ge, () => g(x), Ue => G(x, Ue)), O(d, de), en()
}
Yn(["click"]);
var zke = $r('<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>');

function W_(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = zke();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var Eke = $r('<svg><path fill="currentColor" d="M9 14c1.381 0 2.631-.56 3.536-1.465C13.44 11.631 14 10.381 14 9s-.56-2.631-1.464-3.535C11.631 4.56 10.381 4 9 4s-2.631.56-3.536 1.465C4.56 6.369 4 7.619 4 9s.56 2.631 1.464 3.535A5 5 0 0 0 9 14m0 7c3.518 0 6-1 6-2c0-2-2.354-4-6-4c-3.75 0-6 2-6 4c0 1 2.25 2 6 2m12-9h-2v-2a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2"></path></svg>');

function Lke(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Eke();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...r
  })), O(d, x)
}
var Dke = $r('<svg><circle cx="12" cy="12" r="8" fill="none" stroke="currentColor" stroke-width="2"></circle><circle cx="12" cy="12" r="3" fill="currentColor"></circle></svg>');

function Rke(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Dke();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...r
  })), O(d, x)
}
var jke = $r('<svg><path fill="currentColor" d="m15 21l-6-2.1l-4.65 1.8q-.5.2-.925-.112T3 19.75v-14q0-.325.188-.575T3.7 4.8L9 3l6 2.1l4.65-1.8q.5-.2.925.113T21 4.25v14q0 .325-.187.575t-.513.375zm-1-2.45V6.85l-4-1.4v11.7zm2 0l3-1V5.7l-3 1.15zM5 18.3l3-1.15V5.45l-3 1zM16 6.85v11.7zm-8-1.4v11.7z"></path></svg>');

function Fke(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = jke();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...r
  })), O(d, x)
}
var Bke = $r('<svg><rect x="6" y="6" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" rx="2"></rect><rect x="10" y="10" width="4" height="4" fill="currentColor" rx="1"></rect></svg>');

function Oke(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Bke();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...r
  })), O(d, x)
}
var qke = se("<!> <!>", 1),
  Nke = se('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  Vke = se('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  Uke = se('<div class="mt-3 flex justify-center svelte-15blegn"><span class="loading loading-spinner svelte-15blegn"></span></div>'),
  Zke = se('<div class="mt-3 flex justify-center svelte-15blegn"><p class="text-base-content/80 text-sm svelte-15blegn">No one has painted in this area yet.</p></div>'),
  Gke = se('<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom svelte-15blegn" data-tip="Timeout selected players"><!></button>'),
  $ke = se('<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Ban selected players"><!></button>'),
  Wke = se('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  Hke = se('<button class="btn btn-xs btn-circle btn-soft btn-primary tooltip tooltip-bottom mr-1 svelte-15blegn" data-tip="Paint selected pixels with transparent color"><!></button>'),
  Xke = se('<div class="size-5 svelte-15blegn"></div> <div class="text-base-content/80 ml-0.5 svelte-15blegn">Not painted</div>', 1),
  Yke = se("<span> </span>"),
  Kke = se('<span class="badge badge-sm badge-error ml-0.5 border-0 svelte-15blegn">DELETED</span>'),
  Jke = se('<span class="tooltip svelte-15blegn"><!></span>'),
  Qke = se('<span class="tooltip svelte-15blegn"><!></span>'),
  eTe = se('<!> <div class="ml-0.5 flex flex-wrap items-center gap-1 svelte-15blegn"><span><span class="svelte-15blegn"> </span> <span class="svelte-15blegn"> </span></span> <!> <!> <div class="ml-0.5 flex items-center svelte-15blegn"><!></div></div>', 1),
  tTe = se('<span class="text-primary ml-1 text-xs svelte-15blegn"> </span>'),
  rTe = se('<tr><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox pointer-event-none svelte-15blegn"/></th><td class="flex items-center gap-1 svelte-15blegn"><!></td><td class="text-center svelte-15blegn"> <!></td></tr>'),
  nTe = se('<div class="max-h-[27vh] overflow-y-auto overflow-x-hidden svelte-15blegn"><table class="table max-w-full svelte-15blegn"><thead class="svelte-15blegn"><tr class="svelte-15blegn"><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox svelte-15blegn"/></th><th class="svelte-15blegn">Player <button class="btn btn-xs btn-circle btn-ghost tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Copy selected players IDs"><!></button> <!> <!></th><th class="text-center svelte-15blegn"><!> Pixels Painted</th></tr></thead><tbody class="svelte-15blegn"></tbody></table></div>'),
  iTe = se('<div class="pointer-events-none w-full select-none svelte-15blegn"><div class="pointer-events-auto rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t sm:mb-3 sm:shadow-xl svelte-15blegn"><div class="p-3 svelte-15blegn"><div class="flex cursor-grab flex-wrap items-center justify-between gap-1 active:cursor-grabbing svelte-15blegn"><h2 class="flex items-center gap-1 pl-1 text-lg svelte-15blegn"><div class="bg-base-content/20 flex size-6 items-center justify-center rounded-full svelte-15blegn"><!></div> <span class="ml-0.5 svelte-15blegn">Selected area</span> <span class="text-base-content/80 ml-0.5 text-sm svelte-15blegn"> </span></h2> <div class="flex items-center gap-1 svelte-15blegn"><div class="flex items-center gap-0 svelte-15blegn"><button class="btn btn-xs btn-soft text-base-content/80 flex items-center gap-1 whitespace-nowrap rounded-br-none rounded-tr-none pr-1 text-xs svelte-15blegn"><!> <input type="checkbox" class="checkbox checkbox-xs svelte-15blegn"/></button> <button class="btn btn-xs tooltip tooltip-bottom btn-soft rounded-bl-none rounded-tl-none svelte-15blegn"><!></button></div> <button><!></button> <button><!></button> <button><!></button> <button class="btn btn-circle btn-sm svelte-15blegn"><!></button></div></div> <div class="pb-3 svelte-15blegn"><!></div></div></div></div>');

function aTe(d, s) {
  Qr(s, !0);
  let r = Pi([]),
    x = We(Pi([])),
    A = We(!1),
    E = We(!1),
    k = We(!1),
    l = We(!1),
    j = We(!1),
    W, $, J, ce, ge, fe = We(void 0),
    Z = Pi({
      x: 0,
      y: 0
    }),
    de, Fe;
  const Re = 15e6,
    Pe = new Pp,
    Ge = new Map;
  let et = We(0);
  const Ve = xt(() => {
      g(et);
      const he = new Map;
      for (const Q of Ge.values()) he.set(Q.userId, (he.get(Q.userId) ?? 0) + 1);
      return he
    }),
    ve = xt(() => {
      g(et), Pe.size;
      let he = 0;
      for (const Q of Ge.values()) Pe.has(Q.userId) || (he += 1);
      return he
    }),
    Me = xt(() => {
      g(et);
      const he = g(ve);
      return Pe.size === 0 && he === 0 ? "none" : Pe.size === g(x).length && he === 0 ? "all" : "some"
    }),
    Ye = xt(() => {
      g(et);
      let he = 0;
      for (const Q of Pe.values()) Q.id !== 0 && (he += Q.painted.latitudes.length);
      for (const Q of Ge.values()) Pe.has(Q.userId) || (he += 1);
      return he
    }),
    Ce = xt(() => g(Ke) * 2 + 1);
  let Oe = We("area-select"),
    ut = We(!1);
  const Ue = 15;
  let Ke = We(Ue);
  const St = 0,
    Ft = 4096,
    Jt = "select-area-info:brush-radius",
    Mt = new Pp,
    ct = new Map,
    wt = [],
    ft = () => g(Oe) === "brush-circle" || g(Oe) === "brush-square";
  let $t, Et = !1,
    Qt = !1;

  function vr() {
    Et && (Et = !1, $t = void 0)
  }

  function Kt() {
    if (wt.length > 0) return;
    const he = [s.map.dragPan, s.map.scrollZoom, s.map.boxZoom, s.map.keyboard, s.map.doubleClickZoom, s.map.touchZoomRotate].filter(Boolean);
    for (const Q of he) {
      const Ze = Q.isEnabled ? Q.isEnabled() !== !1 : !0;
      Q.disable && Q.disable(), wt.push({
        handler: Q,
        wasEnabled: Ze
      })
    }
  }

  function Bt() {
    if (wt.length !== 0) {
      for (const {
          handler: he,
          wasEnabled: Q
        }
        of wt) Q && he.enable && he.enable();
      wt.length = 0
    }
  }

  function it() {
    var Ze, vt;
    if (!de) return;
    const {
      handle: he,
      pointerId: Q
    } = de;
    (Ze = he.hasPointerCapture) != null && Ze.call(he, Q) && ((vt = he.releasePointerCapture) == null || vt.call(he, Q)), de = void 0, Fe !== void 0 && (document.body.style.userSelect = Fe, Fe = void 0), He()
  }

  function He() {
    var zt, Yt;
    if (!g(fe)) return;
    const he = (Yt = (zt = s.map).getContainer) == null ? void 0 : Yt.call(zt);
    if (!he) return;
    const Q = he.getBoundingClientRect(),
      Ze = g(fe).getBoundingClientRect(),
      vt = Ze.left - Z.x,
      Qe = Ze.top - Z.y,
      oe = Q.left - vt,
      De = Q.right - vt - Ze.width,
      Je = Q.top - Qe,
      Tt = Q.bottom - Qe - Ze.height;
    let Dt = Z.x,
      _t = Z.y;
    De >= oe ? (Dt < oe && (Dt = oe), Dt > De && (Dt = De)) : Dt = oe, Tt >= Je ? (_t < Je && (_t = Je), _t > Tt && (_t = Tt)) : _t = Je, Dt !== Z.x && (Z.x = Dt), _t !== Z.y && (Z.y = _t)
  }

  function Ot(he) {
    var Je, Tt, Dt;
    if (de || he.pointerType === "mouse" && he.button !== 0) return;
    const Q = he.target;
    if (Q && Q.closest('button, input, textarea, select, a, [role="button"]')) return;
    const Ze = he.currentTarget;
    if (!Ze) return;
    const vt = g(fe);
    if (!vt) return;
    const Qe = (Tt = (Je = s.map).getContainer) == null ? void 0 : Tt.call(Je);
    if (!Qe) return;
    const oe = Qe.getBoundingClientRect(),
      De = vt.getBoundingClientRect();
    de = {
      pointerId: he.pointerId,
      handle: Ze,
      startX: he.clientX,
      startY: he.clientY,
      startPosX: Z.x,
      startPosY: Z.y,
      baseLeft: De.left - Z.x,
      baseTop: De.top - Z.y,
      containerRect: oe,
      panelWidth: De.width,
      panelHeight: De.height
    }, Fe === void 0 && (Fe = document.body.style.userSelect), document.body.style.userSelect = "none", (Dt = Ze.setPointerCapture) == null || Dt.call(Ze, he.pointerId), he.preventDefault(), he.stopPropagation()
  }
  Wi(() => {
    const he = window.localStorage.getItem(Jt);
    if (he !== null) {
      const Ct = Number(he);
      if (!Number.isNaN(Ct)) {
        const ir = Math.min(Ft, Math.max(St, Math.trunc(Ct)));
        G(Ke, ir, !0)
      }
    }
    gi.droppletAndPlop.play(), W = bt();
    const Q = async Ct => {
      if (g(Oe) === "user-picker") {
        await pr(Ct, "select");
        return
      }
      if (ft()) {
        const ir = Ct.originalEvent;
        N(Ct, "add", {
          silent: !!(ir != null && ir.altKey)
        });
        return
      }
      if (r.length >= 2) {
        s.onclose();
        return
      }
      if (r.push(Ct.lngLat), Lt(), gi.plop.play(), r.length === 2) try {
        G(A, !0), G(x, await kt(r[0], r[1]), !0)
      } finally {
        G(A, !1)
      }
    }, Ze = async Ct => {
      var Fr, br;
      if (g(Oe) === "user-picker") {
        (Fr = Ct.preventDefault) == null || Fr.call(Ct);
        const nt = Ct.originalEvent;
        nt == null || nt.preventDefault();
        try {
          await pr(Ct, "deselect")
        } catch (cr) {
          console.error(cr)
        }
        return
      }
      if (!ft()) return;
      (br = Ct.preventDefault) == null || br.call(Ct);
      const ir = Ct.originalEvent;
      ir == null || ir.preventDefault(), N(Ct, "remove")
    }, vt = Ct => {
      if (!ft()) return;
      const ir = Ct.originalEvent;
      if (!ir || !ir.altKey) return;
      const Fr = ir.button === 2 ? "remove" : "add";
      ir.preventDefault(), Kt(), $t = Fr, Et = !0, N(Ct, Fr, {
        silent: !0
      })
    }, Qe = () => {
      vr()
    }, oe = s.map.on("click", Q), De = s.map.on("contextmenu", Ze), Je = s.map.on("mousedown", vt), Tt = s.map.on("mouseup", Qe), Dt = Ct => {
      const ir = de;
      if (!ir || Ct.pointerId !== ir.pointerId) return;
      const Fr = Ct.clientX - ir.startX,
        br = Ct.clientY - ir.startY;
      let nt = ir.startPosX + Fr,
        cr = ir.startPosY + br;
      const ar = ir.containerRect.left - ir.baseLeft,
        Ar = ir.containerRect.right - ir.baseLeft - ir.panelWidth,
        qr = ir.containerRect.top - ir.baseTop,
        Gr = ir.containerRect.bottom - ir.baseTop - ir.panelHeight;
      Ar >= ar ? (nt < ar && (nt = ar), nt > Ar && (nt = Ar)) : nt = ar, Gr >= qr ? (cr < qr && (cr = qr), cr > Gr && (cr = Gr)) : cr = qr, Z.x !== nt && (Z.x = nt), Z.y !== cr && (Z.y = cr)
    }, _t = Ct => {
      const ir = de;
      !ir || Ct.pointerId !== ir.pointerId || it()
    };
    window.addEventListener("pointermove", Dt), window.addEventListener("pointerup", _t), window.addEventListener("pointercancel", _t), window.addEventListener("resize", He);
    const zt = Ct => {
        if (Ct.altKey && (Ct.key === "r" || Ct.key === "R")) {
          G(Ke, Ue), Ct.preventDefault(), st();
          return
        }
        Ct.key === "Alt" && (Qt || (Qt = !0, ft() && Kt()))
      },
      Yt = Ct => {
        Ct.key === "Alt" && (Qt = !1, vr(), Bt())
      },
      $e = () => {
        it(), !(!Qt && !Et) && (Qt = !1, vr(), Bt())
      };
    return window.addEventListener("keydown", zt), window.addEventListener("keyup", Yt), window.addEventListener("blur", $e), () => {
      var ir, Fr;
      oe.unsubscribe(), De.unsubscribe(), Je.unsubscribe(), Tt.unsubscribe(), window.removeEventListener("pointermove", Dt), window.removeEventListener("pointerup", _t), window.removeEventListener("pointercancel", _t), window.removeEventListener("resize", He), window.removeEventListener("keydown", zt), window.removeEventListener("keyup", Yt), window.removeEventListener("blur", $e), it(), vr(), Bt(), Qt = !1, s.crosshair.clear();
      const Ct = (Fr = (ir = s.map).getCanvas) == null ? void 0 : Fr.call(ir);
      Ct && (Ct.style.cursor = ""), W == null || W(), W = void 0
    }
  });

  function Gt() {
    it(), g(E) || (W == null || W(), W = void 0, G(Oe, "area-select"), vr(), Bt(), Qt = !1, Z.x = 0, Z.y = 0, Ge.clear(), G(et, g(et) + 1), Mt.clear(), ct.clear(), s.crosshair.clear(), s.onclose())
  }
  async function kt(he, Q) {
    const Ze = new ja(s.tileSize),
      [vt, Qe] = Ze.latLonToPixelsFloor(he.lat, he.lng, s.pixelArtZoom),
      [oe, De] = Ze.latLonToPixelsFloor(Q.lat, Q.lng, s.pixelArtZoom),
      [Je, Tt] = [Math.min(vt, oe), Math.min(Qe, De)],
      [Dt, _t] = [Math.max(vt, oe), Math.max(Qe, De)],
      zt = Dt - Je,
      Yt = _t - Tt;
    if (zt * Yt > Re) return rr.error(`The selected area is too big. Please select an area smaller than ${Re.toLocaleString()} pixels.`), [];
    const Ct = Math.floor(Je / s.tileSize),
      ir = Math.floor(Tt / s.tileSize),
      Fr = Math.floor(Dt / s.tileSize),
      br = Math.floor(_t / s.tileSize),
      nt = Fr - Ct + 1,
      cr = br - ir + 1,
      ar = new Array(cr).fill(0).flatMap((Vr, Le) => new Array(nt).fill(0).map(async (tt, qt) => {
        const Ut = Ct + qt,
          fr = ir + Le;
        let Wt = 0,
          yr = 0,
          tn = s.tileSize - 1,
          Kr = s.tileSize - 1;
        fr === ir && (yr = Tt % s.tileSize), Ut === Ct && (Wt = Je % s.tileSize), fr === br && (Kr = _t % s.tileSize), Ut === Fr && (tn = Dt % s.tileSize);
        const In = [Ut, fr],
          Wr = [Wt, yr],
          jr = [tn, Kr];
        return {
          response: await pn.getPixelAreaInfo({
            season: s.season,
            tile: In,
            p0: Wr,
            p1: jr
          }),
          tile: In,
          p0: Wr,
          p1: jr
        }
      })),
      Ar = await Promise.all(ar);
    Mt.clear(), ct.clear();
    const qr = new Map;
    for (const {
        response: Vr,
        p0: Le,
        p1: tt,
        tile: qt
      }
      of Ar) {
      const [Ut, fr] = qt, [Wt, yr] = Le, [tn, Kr] = tt, Br = tn - Wt + 1, Cr = Kr - yr + 1;
      for (let Yr = 0; Yr < Cr; Yr++)
        for (let Ln = 0; Ln < Br; Ln++) {
          const In = Yr * Br + Ln,
            Wr = Vr.paintedBy[In];
          let jr = qr.get(Wr);
          jr || (jr = {
            latitudes: [],
            longitudes: [],
            tileXs: [],
            tileYs: [],
            pixelXs: [],
            pixelYs: [],
            globalPx: [],
            globalPy: [],
            minLat: 1 / 0,
            maxLat: -1 / 0,
            minLon: 1 / 0,
            maxLon: -1 / 0
          }, qr.set(Wr, jr));
          const wn = Wt + Ln,
            En = yr + Yr,
            Mn = Ut * s.tileSize + (wn + .5),
            qn = fr * s.tileSize + (En + .5),
            [Gn, Jn] = Ze.pixelsToLatLon(Mn, qn, s.pixelArtZoom);
          if (jr.latitudes.push(Gn), jr.longitudes.push(Jn), jr.tileXs.push(Ut), jr.tileYs.push(fr), jr.pixelXs.push(wn), jr.pixelYs.push(En), jr.globalPx.push(Mn), jr.globalPy.push(qn), Gn < jr.minLat && (jr.minLat = Gn), Gn > jr.maxLat && (jr.maxLat = Gn), Jn < jr.minLon && (jr.minLon = Jn), Jn > jr.maxLon && (jr.maxLon = Jn), Wr !== 0) {
            const Zn = `${Ut}:${fr}:${wn}:${En}`,
              ri = {
                key: Zn,
                userId: Wr,
                lat: Gn,
                lon: Jn,
                tile: [Ut, fr],
                pixel: [wn, En],
                globalPx: Mn,
                globalPy: qn
              };
            Mt.set(Zn, ri);
            const la = `${Ut}:${fr}`;
            let Hi = ct.get(la);
            Hi || (Hi = [], ct.set(la, Hi)), Hi.push(ri)
          }
        }
    }
    const {
      users: Gr
    } = await pn.getMultipleUsersInfoById([...qr.keys()]), Mr = d1(Gr, Vr => Vr.id), Sn = [...qr.entries()].map(([Vr, Le]) => ({
      ...Mr[Vr] ?? {
        id: Vr,
        name: "Player",
        deleted: !0
      },
      painted: Le
    }));
    return Sn.sort((Vr, Le) => Vr.id === 0 ? 1 : Le.id === 0 ? -1 : Le.painted.latitudes.length - Vr.painted.latitudes.length), Sn
  }
  async function nr({
    preserveSelection: he = !1
  } = {}) {
    if (r.length < 2) return;
    const Q = he ? new Set([...Pe.keys()]) : void 0,
      Ze = he ? [...Ge.keys()] : void 0;
    try {
      G(A, !0);
      const vt = await kt(r[0], r[1]);
      if (G(x, vt, !0), Pe.clear(), Ge.clear(), G(et, g(et) + 1), s.crosshair.clear(), he && (Q != null && Q.size)) {
        for (const Qe of vt) Q.has(Qe.id) && Pe.set(Qe.id, Qe);
        for (const Qe of Pe.values())
          for (let oe = 0; oe < Qe.painted.latitudes.length; oe++) s.crosshair.place([Qe.painted.latitudes[oe], Qe.painted.longitudes[oe]])
      }
      if (he && (Ze != null && Ze.length)) {
        let Qe = !1;
        for (const oe of Ze) {
          const De = Mt.get(oe);
          De && (Ge.set(oe, De), Qe = !0)
        }
        Qe && G(et, g(et) + 1)
      }
      for (const Qe of Ge.values()) s.crosshair.place([Qe.lat, Qe.lon])
    } finally {
      G(A, !1)
    }
  }

  function It(he) {
    let Q = !1;
    for (const Ze of he)(Vt(Ze) || Ze.id === 0) && (Q = !0);
    Q && gi.plop.play()
  }

  function mt(he) {
    for (let Q = 0; Q < he.latitudes.length; Q++) s.crosshair.remove([he.latitudes[Q], he.longitudes[Q]])
  }

  function yt(he) {
    if (!he) {
      ge = void 0;
      return
    }
    if (r.length >= 2 && g(Oe) === "area-select") {
      ge = void 0;
      return
    }
    ge = he
  }
  rn(() => {
    r.length < 2 && g(Oe) !== "area-select" && G(Oe, "area-select");
    const he = s.map.getCanvas();
    if (!he) return;
    const Q = g(Oe) === "user-picker" || g(Oe) === "brush-circle" || g(Oe) === "brush-square";
    he.style.cursor = Q ? "crosshair" : "", st()
  }), rn(() => {
    const he = ft();
    he || vr(), Qt && (he ? Kt() : Bt())
  }), rn(() => {
    g(Ke), st()
  }), rn(() => {
    typeof window < "u" && window.localStorage.setItem(Jt, String(Math.trunc(g(Ke))))
  }), rn(() => {
    r.length, r.length < 2 ? (Z.x !== 0 && (Z.x = 0), Z.y !== 0 && (Z.y = 0)) : He(), Lt(), lr()
  });

  function bt() {
    const he = s.map.getContainer(),
      Q = document.createElement("div");
    Q.classList.add("selection-rectangle"), Q.style.position = "absolute", Q.style.pointerEvents = "none", Q.style.display = "none", Q.style.zIndex = "6", he.appendChild(Q);
    const Ze = document.createElement("div");
    Ze.classList.add("selection-brush"), Ze.style.position = "absolute", Ze.style.pointerEvents = "none", Ze.style.display = "none", Ze.style.zIndex = "7", he.appendChild(Ze);
    const vt = dr(he, "horizontal"),
      Qe = dr(he, "vertical");
    ce = {
      horizontal: vt,
      vertical: Qe
    }, J = Ze;
    const oe = _t => {
        yt({
          x: _t.point.x,
          y: _t.point.y
        }), Lt(), lr(), st();
        const zt = _t.originalEvent;
        if (!zt) {
          Et && vr();
          return
        }
        if (!Et && zt.altKey && ft()) {
          let Yt = !1;
          if (zt.buttons & 1 ? (Kt(), $t = "add", Et = !0, Yt = !0) : zt.buttons & 2 && (Kt(), $t = "remove", Et = !0, Yt = !0), Yt && $t) {
            N(_t, $t, {
              silent: !0
            });
            return
          }
        }
        if (Et && $t) {
          if (!zt.altKey || zt.buttons === 0) {
            vr();
            return
          }
          N(_t, $t, {
            silent: !0
          })
        }
      },
      De = _t => {
        const zt = he.getBoundingClientRect();
        yt({
          x: _t.clientX - zt.left,
          y: _t.clientY - zt.top
        }), Lt(), lr(), st()
      },
      Je = () => {
        ge = void 0, vr(), Lt(), lr(), st()
      },
      Tt = () => {
        He(), Lt(), lr(), st()
      },
      Dt = _t => {
        if (!ft()) return;
        if (!(_t.altKey || Qt)) {
          Et && (vr(), Bt());
          return
        }
        Qt = !0, Kt(), _t.preventDefault(), _t.stopPropagation(), typeof _t.stopImmediatePropagation == "function" && _t.stopImmediatePropagation();
        const zt = _t.deltaY < 0 ? 1 : -1,
          Yt = (_t.shiftKey ? 10 : 1) * zt,
          $e = Math.min(Ft, Math.max(St, g(Ke) + Yt));
        $e !== g(Ke) && (G(Ke, $e, !0), st())
      };
    return s.map.on("mousemove", oe), he.addEventListener("pointermove", De), he.addEventListener("mouseleave", Je), s.map.on("move", Tt), s.map.on("resize", Tt), he.addEventListener("wheel", Dt, {
      passive: !1
    }), $ = Q, Lt(), lr(), st(), () => {
      s.map.off("mousemove", oe), s.map.off("move", Tt), s.map.off("resize", Tt), he.removeEventListener("pointermove", De), he.removeEventListener("mouseleave", Je), he.removeEventListener("wheel", Dt), Q.remove(), $ = void 0, ge = void 0, ce == null || ce.horizontal.remove(), ce == null || ce.vertical.remove(), ce = void 0, J == null || J.remove(), J = void 0
    }
  }

  function Lt() {
    const he = $;
    if (!he) return;
    const Q = new ja(s.tileSize);
    let Ze, vt, Qe, oe;
    if (r.length >= 2) {
      const Fr = r.map(br => Q.latLonToPixelsFloor(br.lat, br.lng, s.pixelArtZoom));
      Ze = Math.min(...Fr.map(([br]) => br)), vt = Math.max(...Fr.map(([br]) => br)) + 1, Qe = Math.min(...Fr.map(([, br]) => br)), oe = Math.max(...Fr.map(([, br]) => br)) + 1
    } else if (r.length === 1 && ge) {
      const [Fr, br] = Q.latLonToPixelsFloor(r[0].lat, r[0].lng, s.pixelArtZoom), nt = s.map.unproject([ge.x, ge.y]), [cr, ar] = Q.latLonToPixelsFloor(nt.lat, nt.lng, s.pixelArtZoom);
      Ze = Math.min(Fr, cr), vt = Math.max(Fr, cr) + 1, Qe = Math.min(br, ar), oe = Math.max(br, ar) + 1
    } else {
      he.style.display = "none";
      return
    }
    const [De, Je] = Q.pixelsToLatLon(Ze, Qe, s.pixelArtZoom), [Tt, Dt] = Q.pixelsToLatLon(vt, oe, s.pixelArtZoom), _t = s.map.project([Je, De]), zt = s.map.project([Dt, Tt]);
    let Yt = Math.min(_t.x, zt.x),
      $e = Math.max(_t.x, zt.x),
      Ct = Math.min(_t.y, zt.y),
      ir = Math.max(_t.y, zt.y);
    $e - Yt < 1 && ($e = Yt + 1), ir - Ct < 1 && (ir = Ct + 1), he.style.display = "block", he.style.left = `${Yt}px`, he.style.top = `${Ct}px`, he.style.width = `${$e-Yt}px`, he.style.height = `${ir-Ct}px`
  }

  function st() {
    const he = J;
    if (!he) return;
    if (!(g(Oe) === "brush-circle" || g(Oe) === "brush-square") || !ge) {
      he.style.display = "none";
      return
    }
    const Q = new ja(s.tileSize),
      Ze = s.map.unproject([ge.x, ge.y]),
      [vt, Qe] = Q.latLonToPixels(Ze.lat, Ze.lng, s.pixelArtZoom),
      oe = g(Ke) + .5,
      [De, Je] = Q.pixelsToLatLon(vt - oe, Qe - oe, s.pixelArtZoom),
      [Tt, Dt] = Q.pixelsToLatLon(vt + oe, Qe + oe, s.pixelArtZoom),
      _t = s.map.project([Je, De]),
      zt = s.map.project([Dt, Tt]),
      Yt = Math.min(_t.x, zt.x),
      $e = Math.max(_t.x, zt.x),
      Ct = Math.min(_t.y, zt.y),
      ir = Math.max(_t.y, zt.y);
    he.style.display = "block", he.style.left = `${Yt}px`, he.style.top = `${Ct}px`, he.style.width = `${Math.max($e-Yt,2)}px`, he.style.height = `${Math.max(ir-Ct,2)}px`, he.style.borderRadius = g(Oe) === "brush-circle" ? "100%" : "4px", he.dataset.radius = String(g(Ke))
  }

  function lr() {
    const he = ce;
    if (he) {
      if (!ge || r.length >= 2) {
        gr();
        return
      }
      he.horizontal.style.display = "block", he.horizontal.style.top = `${ge.y}px`, he.horizontal.style.transform = "translateY(-0.5px)", he.vertical.style.display = "block", he.vertical.style.left = `${ge.x}px`, he.vertical.style.transform = "translateX(-0.5px)"
    }
  }

  function gr() {
    ce && (ce.horizontal.style.display = "none", ce.vertical.style.display = "none")
  }

  function dr(he, Q) {
    const Ze = document.createElement("div");
    return Ze.style.position = "absolute", Ze.style.pointerEvents = "none", Ze.style.zIndex = "5", Ze.style.display = "none", Ze.style.mixBlendMode = "difference", Ze.style.backgroundColor = "rgba(255, 255, 255, 0.9)", Q === "horizontal" ? (Ze.style.left = "0", Ze.style.right = "0", Ze.style.height = "1px") : (Ze.style.top = "0", Ze.style.bottom = "0", Ze.style.width = "1px"), he.appendChild(Ze), Ze
  }
  async function pr(he, Q = "select") {
    var Ze;
    if (!g(ut)) {
      if (g(A)) {
        rr.info("Wait until the selected area finishes loading.");
        return
      }
      if (r.length < 2) {
        rr.info("Select an area first to use the user picker.");
        return
      }
      G(ut, !0);
      try {
        const vt = new ja(s.tileSize),
          {
            tile: Qe,
            pixel: oe
          } = vt.latLonToTileAndPixel(he.lngLat.lat, he.lngLat.lng, s.pixelArtZoom),
          {
            paintedBy: De
          } = await pn.getPixelInfo({
            season: s.season,
            tile: Qe,
            pixel: oe,
            role: (Ze = Rt.data) == null ? void 0 : Ze.role
          });
        if (!De || De.id === 0) {
          rr.info("That pixel is not painted by any player.");
          return
        }
        const Je = g(x).find(Dt => Dt.id === De.id);
        if (!Je) {
          rr.info("Selected pixel is outside the selected area.");
          return
        }
        if (Q === "deselect") {
          if (!Pe.has(Je.id)) {
            Rr(Je.id) ? (gi.plop.play(), rr.success(`${Je.name} deselected`)) : rr.info("That player is not selected.");
            return
          }
          Pe.delete(Je.id), mt(Je.painted), Rr(Je.id, {
            skipCrosshair: !0
          }), gi.plop.play(), rr.success(`${Je.name} deselected`);
          return
        }
        if (Pe.has(Je.id)) {
          rr.info("Player already selected.");
          return
        }
        Pe.set(Je.id, Je), (Vt(Je) || Je.id === 0) && gi.plop.play(), rr.success(`${Je.name} selected`)
      } catch (vt) {
        rr.error(vt.message)
      } finally {
        G(ut, !1)
      }
    }
  }

  function Ht(he, {
    skipCrosshair: Q = !1
  } = {}) {
    return Ge.has(he.key) ? !1 : (Ge.set(he.key, he), Q || s.crosshair.place([he.lat, he.lon]), !0)
  }

  function Sr(he, {
    skipCrosshair: Q = !1
  } = {}) {
    const Ze = Ge.get(he);
    return Ze ? (Ge.delete(he), Q || s.crosshair.remove([Ze.lat, Ze.lon]), !0) : !1
  }

  function Rr(he, {
    skipCrosshair: Q = !1
  } = {}) {
    const Ze = [];
    for (const [Qe, oe] of Ge.entries()) oe.userId === he && Ze.push(Qe);
    let vt = !1;
    for (const Qe of Ze) Sr(Qe, {
      skipCrosshair: Q
    }) && (vt = !0);
    return vt && G(et, g(et) + 1), vt
  }

  function Vt(he, {
    skipCrosshair: Q = !1
  } = {}) {
    if (he.id === 0) return !1;
    const Ze = he.painted;
    let vt = !1;
    for (let Qe = 0; Qe < Ze.latitudes.length; Qe++) {
      const oe = Ze.tileXs[Qe],
        De = Ze.tileYs[Qe],
        Je = Ze.pixelXs[Qe],
        Tt = Ze.pixelYs[Qe],
        Dt = `${oe}:${De}:${Je}:${Tt}`;
      let _t = Mt.get(Dt);
      if (!_t) {
        _t = {
          key: Dt,
          userId: he.id,
          lat: Ze.latitudes[Qe],
          lon: Ze.longitudes[Qe],
          tile: [oe, De],
          pixel: [Je, Tt],
          globalPx: Ze.globalPx[Qe],
          globalPy: Ze.globalPy[Qe]
        }, Mt.set(Dt, _t);
        const zt = `${oe}:${De}`;
        let Yt = ct.get(zt);
        Yt || (Yt = [], ct.set(zt, Yt)), Yt.push(_t)
      }
      Ht(_t, {
        skipCrosshair: Q
      }) && (vt = !0)
    }
    return vt && G(et, g(et) + 1), vt
  }

  function Tr(he) {
    return g(x).find(Q => Q.id === he)
  }

  function Xt(he, {
    silent: Q = !1
  } = {}) {
    let Ze = !1;
    for (const [vt, Qe] of he) {
      if (Pe.has(vt)) continue;
      const oe = Tr(vt);
      if (!oe) continue;
      const De = oe.painted.latitudes.length;
      (g(Ve).get(vt) ?? 0) + Qe >= De && (Pe.set(vt, oe), Ze = !0)
    }
    Ze && !Q && gi.plop.play()
  }

  function ue(he, Q) {
    if (Mt.size === 0) return [];
    const Ze = new ja(s.tileSize),
      [vt, Qe] = Ze.latLonToPixels(he, Q, s.pixelArtZoom),
      oe = g(Ke) + .5,
      De = vt - oe,
      Je = vt + oe,
      Tt = Qe - oe,
      Dt = Qe + oe,
      _t = Math.floor(De / s.tileSize),
      zt = Math.floor(Je / s.tileSize),
      Yt = Math.floor(Tt / s.tileSize),
      $e = Math.floor(Dt / s.tileSize),
      Ct = [];
    for (let ir = _t; ir <= zt; ir++)
      for (let Fr = Yt; Fr <= $e; Fr++) {
        const br = `${ir}:${Fr}`,
          nt = ct.get(br);
        if (nt)
          for (const cr of nt) {
            const ar = cr.globalPx - vt,
              Ar = cr.globalPy - Qe;
            if (g(Oe) === "brush-circle") {
              if (ar * ar + Ar * Ar > oe * oe) continue
            } else if (Math.abs(ar) > oe || Math.abs(Ar) > oe) continue;
            Ct.push(cr)
          }
      }
    return Ct
  }

  function N(he, Q, {
    silent: Ze = !1
  } = {}) {
    if (g(A)) return Ze || rr.info("Wait until the selected area finishes loading."), !1;
    if (r.length < 2) return Ze || rr.info("Select an area first to use the brush tool."), !1;
    const vt = ue(he.lngLat.lat, he.lngLat.lng);
    if (vt.length === 0) {
      if (!Ze) {
        const De = Q === "add" ? "No painted pixels found within the brush." : "No selected pixels to remove within the brush.";
        rr.info(De)
      }
      return !1
    }
    let Qe = !1;
    const oe = new Map;
    if (Q === "add")
      for (const De of vt) Pe.has(De.userId) || Ge.has(De.key) || Ht(De) && (Qe = !0, oe.set(De.userId, (oe.get(De.userId) ?? 0) + 1));
    else
      for (const De of vt) Sr(De.key) && (Qe = !0, Pe.has(De.userId) && Pe.delete(De.userId));
    return Qe ? (Q === "add" && oe.size > 0 && Xt(oe, {
      silent: Ze
    }), G(et, g(et) + 1), Ze || gi.plop.play(), !0) : (!Ze && Q === "add" && rr.info("All pixels inside the brush are already selected."), !1)
  }
  async function q() {
    const he = s.map.getCanvas();
    if (!he) return rr.error("Unable to access map canvas."), !1;
    const Q = he.getBoundingClientRect();
    if (!Q.width || !Q.height) return rr.error("Map is not visible to capture."), !1;
    let Ze = 1 / 0,
      vt = -1 / 0,
      Qe = 1 / 0,
      oe = -1 / 0;
    for (const Le of r) {
      const {
        lat: tt,
        lng: qt
      } = Le;
      tt < Ze && (Ze = tt), tt > vt && (vt = tt), qt < Qe && (Qe = qt), qt > oe && (oe = qt)
    }
    if (!isFinite(Ze) || !isFinite(vt) || !isFinite(Qe) || !isFinite(oe)) return rr.error("Unable to determine selected area."), !1;
    const De = s.map.project([Qe, vt]),
      Je = s.map.project([oe, Ze]);
    if (!Number.isFinite(De.x) || !Number.isFinite(De.y) || !Number.isFinite(Je.x) || !Number.isFinite(Je.y)) return rr.error("Unable to project selected area on the map."), !1;
    let Tt = Math.min(De.x, Je.x),
      Dt = Math.max(De.x, Je.x),
      _t = Math.min(De.y, Je.y),
      zt = Math.max(De.y, Je.y);
    Tt = Math.max(0, Tt), _t = Math.max(0, _t), Dt = Math.min(Q.width, Dt), zt = Math.min(Q.height, zt);
    const Yt = Dt - Tt,
      $e = zt - _t;
    if (Yt <= 0 || $e <= 0) return rr.error("Selected area is outside the current map view."), !1;
    const Ct = he.width / Q.width,
      ir = he.height / Q.height,
      Fr = Math.floor(Tt * Ct),
      br = Math.floor(_t * ir),
      nt = Math.max(1, Math.ceil(Dt * Ct) - Fr),
      cr = Math.max(1, Math.ceil(zt * ir) - br),
      ar = await Ip(s.map);
    let Ar;
    if ("createImageBitmap" in window) Ar = await createImageBitmap(ar);
    else {
      const Le = URL.createObjectURL(ar);
      Ar = await new Promise((tt, qt) => {
        const Ut = new Image;
        Ut.crossOrigin = "anonymous", Ut.onload = () => tt(Ut), Ut.onerror = () => qt(new Error("Failed to decode map image.")), Ut.src = Le
      }), URL.revokeObjectURL(Le)
    }
    const qr = document.createElement("canvas");
    qr.width = nt, qr.height = cr;
    const Gr = qr.getContext("2d");
    if (!Gr) return "close" in Ar && Ar.close(), rr.error("Unable to create drawing context."), !1;
    Gr.drawImage(Ar, Fr, br, nt, cr, 0, 0, nt, cr), "close" in Ar && Ar.close();
    const Mr = await new Promise((Le, tt) => {
        qr.toBlob(qt => {
          qt ? Le(qt) : tt(new Error("Failed to prepare download."))
        }, "image/png")
      }),
      Sn = URL.createObjectURL(Mr),
      Vr = document.createElement("a");
    return Vr.href = Sn, Vr.download = `selected-map-${nt}x${cr}.png`, document.body.appendChild(Vr), Vr.click(), document.body.removeChild(Vr), URL.revokeObjectURL(Sn), !0
  }
  async function X() {
    if (!(g(l) || g(A))) {
      if (r.length < 2) {
        rr.info(g(j) ? "Select an area first to save the map view." : "Select an area first to save pixel art.");
        return
      }
      G(l, !0);
      try {
        switch (g(j)) {
          case !0:
            if (g(j)) {
              await q() && rr.success("Selected map view saved");
              return
            }
          case !1:
            const he = new ja(s.tileSize);
            let Q = 1 / 0,
              Ze = -1 / 0,
              vt = 1 / 0,
              Qe = -1 / 0;
            for (let nt = 0; nt < r.length; nt++) {
              const cr = r[nt],
                ar = he.latLonToPixelsFloor(cr.lat, cr.lng, s.pixelArtZoom),
                Ar = ar[0],
                qr = ar[1];
              Ar < Q && (Q = Ar), Ar > Ze && (Ze = Ar), qr < vt && (vt = qr), qr > Qe && (Qe = qr)
            }
            if (!isFinite(Q) || !isFinite(Ze) || !isFinite(vt) || !isFinite(Qe)) {
              rr.error("Unable to determine selected area.");
              return
            }
            const oe = Ze + 1,
              De = Qe + 1,
              Je = oe - Q,
              Tt = De - vt;
            if (Je <= 0 || Tt <= 0) {
              rr.error("Selected area has no size.");
              return
            }
            const Dt = document.createElement("canvas");
            Dt.width = Je, Dt.height = Tt;
            const _t = Dt.getContext("2d");
            if (!_t) {
              rr.error("Unable to create drawing context.");
              return
            }
            const zt = Math.floor(Q / s.tileSize),
              Yt = Math.floor((oe - 1) / s.tileSize),
              $e = Math.floor(vt / s.tileSize),
              Ct = Math.floor((De - 1) / s.tileSize);
            for (let nt = $e; nt <= Ct; nt++)
              for (let cr = zt; cr <= Yt; cr++) {
                const ar = cr * s.tileSize,
                  Ar = nt * s.tileSize,
                  qr = Math.max(Q, ar),
                  Gr = Math.max(vt, Ar),
                  Mr = Math.min(oe, ar + s.tileSize),
                  Sn = Math.min(De, Ar + s.tileSize),
                  Vr = Mr - qr,
                  Le = Sn - Gr;
                if (Vr <= 0 || Le <= 0) continue;
                const tt = await fetch(`${d0}/s${s.season}/tiles/${cr}/${nt}.png`);
                if (!tt.ok) throw new Error("Failed to load tile image.");
                const qt = await tt.blob();
                if ("createImageBitmap" in window) {
                  const Ut = await createImageBitmap(qt);
                  _t.drawImage(Ut, qr - ar, Gr - Ar, Vr, Le, qr - Q, Gr - vt, Vr, Le), Ut.close && Ut.close()
                } else {
                  const Ut = URL.createObjectURL(qt),
                    fr = await new Promise((Wt, yr) => {
                      const tn = new Image;
                      tn.crossOrigin = "anonymous", tn.onload = () => Wt(tn), tn.onerror = () => yr(new Error("Failed to decode tile image.")), tn.src = Ut
                    });
                  _t.drawImage(fr, qr - ar, Gr - Ar, Vr, Le, qr - Q, Gr - vt, Vr, Le), URL.revokeObjectURL(Ut)
                }
              }
            const ir = await new Promise((nt, cr) => {
                Dt.toBlob(ar => {
                  ar ? nt(ar) : cr(new Error("Failed to prepare download."))
                }, "image/png")
              }),
              Fr = URL.createObjectURL(ir),
              br = document.createElement("a");
            br.href = Fr, br.download = `selected-area-${Je}x${Tt}.png`, document.body.appendChild(br), br.click(), document.body.removeChild(br), URL.revokeObjectURL(Fr), rr.success("Selected area image saved")
        }
      } catch (he) {
        rr.error(he.message)
      } finally {
        G(l, !1)
      }
    }
  }
  async function te() {
    if (g(k) || g(A)) return;
    const he = new Map;
    for (const Q of Pe.values()) {
      if (Q.id === 0) continue;
      const {
        tileXs: Ze,
        tileYs: vt,
        pixelXs: Qe,
        pixelYs: oe
      } = Q.painted;
      for (let De = 0; De < Ze.length; De++) {
        const Je = [Ze[De], vt[De]],
          Tt = [Qe[De], oe[De]],
          Dt = {
            tile: Je,
            pixel: Tt,
            season: s.season
          },
          _t = `${Je[0]}:${Je[1]}:${Tt[0]}:${Tt[1]}`;
        he.set(_t, Dt)
      }
    }
    for (const Q of Ge.values()) Pe.has(Q.userId) || he.has(Q.key) || he.set(Q.key, {
      tile: Q.tile,
      pixel: Q.pixel,
      season: s.season
    });
    if (he.size === 0) {
      rr.info("Select painted pixels to clear with transparent color");
      return
    }
    G(k, !0);
    try {
      gi.droppletAndPlop.play();
      const Q = await gm(),
        Ze = [];
      for (const oe of he.values()) Ze.push({
        ...oe,
        colorIdx: 0
      });
      await pn.selectAreaClear(Ze, Q);
      const vt = kp(0),
        Qe = Ze.map(({
          tile: oe,
          pixel: De,
          season: Je
        }) => ({
          tile: oe,
          pixel: De,
          season: Je,
          color: vt
        }));
      await J_(Qe), rr.success("Painted selected pixels with transparent color"), await nr()
    } catch (Q) {
      rr.error(Q.message)
    } finally {
      G(k, !1)
    }
  }
  const le = he => ({
    id: he.id,
    name: he.name,
    picture: he.picture,
    allianceId: he.allianceId ?? void 0,
    allianceName: he.allianceName ?? void 0,
    timedOut: he.timedOut,
    banned: he.banned,
    deleted: he.deleted
  });

  function xe() {
    const he = new Map;
    for (const Q of Pe.values()) Q.id !== 0 && he.set(Q.id, Q);
    if (Ge.size > 0) {
      let Q;
      for (const Ze of Ge.values()) {
        const vt = Ze.userId;
        if (vt === 0 || he.has(vt)) continue;
        if (!Q) {
          Q = new Map;
          for (const oe of g(x)) Q.set(oe.id, oe)
        }
        const Qe = Q.get(vt);
        Qe && he.set(Qe.id, Qe)
      }
    }
    return [...he.values()]
  }
  async function je(he, Q) {
    try {
      G(E, !0);
      const Ze = he.filter(_t => _t.id !== 0);
      if (Ze.length === 0) {
        rr.info("Select at least one player");
        return
      }
      let vt = 1 / 0,
        Qe = -1 / 0,
        oe = 1 / 0,
        De = -1 / 0;
      if (r.length >= 2)
        for (const _t of r) {
          const {
            lat: zt,
            lng: Yt
          } = _t;
          !isFinite(zt) || !isFinite(Yt) || (zt < vt && (vt = zt), zt > Qe && (Qe = zt), Yt < oe && (oe = Yt), Yt > De && (De = Yt))
        }
      vt === Qe && (vt -= 1e-6, Qe += 1e-6), oe === De && (oe -= 1e-6, De += 1e-6), s.map.stop();
      const Je = s.map.getCanvas(),
        Tt = Math.max(48, Math.min(Je.width, Je.height) * .08);
      s.map.fitBounds([
        [Math.min(oe, De), Math.min(vt, Qe)],
        [Math.max(oe, De), Math.max(vt, Qe)]
      ], {
        padding: Tt,
        duration: 0
      });
      const Dt = (async () => await Ip(s.map, {
        maxHeight: 1080,
        maxWidth: 1080,
        quality: .8,
        type: "image/jpeg"
      }))();
      s.onmodaction({
        action: Q,
        targets: Ze.map(le),
        image: Dt,
        latLon: [(vt + Qe) / 2, (oe + De) / 2],
        zoom: s.map.getZoom(),
        onSuccess: async () => {
          await nr({
            preserveSelection: !0
          })
        }
      })
    } catch (Ze) {
      rr.error(Ze.message)
    } finally {
      G(E, !1)
    }
  }
  var Ie = Ir();
  Pn("keydown", Vs, he => he.code === "Escape" && Gt());
  var qe = Pt(Ie);
  {
    var rt = he => {
        Cc(he, {
          class: "bg-warning animate-bounce",
          children: (Q, Ze) => {
            var vt = qke(),
              Qe = Pt(vt);
            W_(Qe, {
              class: "inline size-5"
            });
            var oe = L(Qe, 2);
            {
              var De = Tt => {
                  var Dt = vi();
                  ze(_t => ee(Dt, _t), [() => hX()]), O(Tt, Dt)
                },
                Je = Tt => {
                  var Dt = Ir(),
                    _t = Pt(Dt);
                  {
                    var zt = Yt => {
                      var $e = vi();
                      ze(Ct => ee($e, Ct), [() => TX()]), O(Yt, $e)
                    };
                    we(_t, Yt => {
                      r.length === 1 && Yt(zt)
                    }, !0)
                  }
                  O(Tt, Dt)
                };
              we(oe, Tt => {
                r.length === 0 ? Tt(De) : Tt(Je, !1)
              })
            }
            O(Q, vt)
          },
          $$slots: {
            default: !0
          }
        })
      },
      Xe = he => {
        var Q = iTe();
        let Ze;
        var vt = S(Q),
          Qe = S(vt),
          oe = S(Qe);
        oe.__pointerdown = Ot, Io(oe, "", {}, {
          "touch-action": "none"
        });
        var De = S(oe),
          Je = S(De),
          Tt = S(Je);
        W_(Tt, {
          class: "size-4"
        }), P(Je);
        var Dt = L(Je, 4),
          _t = S(Dt);
        P(Dt), P(De);
        var zt = L(De, 2),
          Yt = S(zt),
          $e = S(Yt);
        $e.__click = () => {
          G(j, g(j) !== !0)
        };
        var Ct = S($e);
        Fke(Ct, {
          class: "h-4 w-4"
        });
        var ir = L(Ct, 2);
        sa(ir), P($e);
        var Fr = L($e, 2);
        Fr.__click = X;
        var br = S(Fr);
        {
          var nt = Cr => {
              var Yr = Nke();
              O(Cr, Yr)
            },
            cr = Cr => {
              rm(Cr, {
                class: "size-4"
              })
            };
          we(br, Cr => {
            g(l) ? Cr(nt) : Cr(cr, !1)
          })
        }
        P(Fr), P(Yt);
        var ar = L(Yt, 2);
        let Ar;
        ar.__click = () => {
          if (g(Oe) === "brush-circle") {
            G(Oe, "area-select");
            return
          }
          if (g(A)) {
            rr.info("Wait until the selected area finishes loading.");
            return
          }
          if (r.length < 2) {
            rr.info("Select an area first to use the brush tools.");
            return
          }
          G(Oe, "brush-circle")
        };
        var qr = S(ar);
        Rke(qr, {
          class: "size-4"
        }), P(ar);
        var Gr = L(ar, 2);
        let Mr;
        Gr.__click = () => {
          if (g(Oe) === "brush-square") {
            G(Oe, "area-select");
            return
          }
          if (g(A)) {
            rr.info("Wait until the selected area finishes loading.");
            return
          }
          if (r.length < 2) {
            rr.info("Select an area first to use the brush tools.");
            return
          }
          G(Oe, "brush-square")
        };
        var Sn = S(Gr);
        Oke(Sn, {
          class: "size-4"
        }), P(Gr);
        var Vr = L(Gr, 2);
        let Le;
        Vr.__click = () => {
          if (g(Oe) === "user-picker") {
            G(Oe, "area-select");
            return
          }
          if (g(A)) {
            rr.info("Wait until the selected area finishes loading.");
            return
          }
          if (r.length < 2) {
            rr.info("Select an area first to use the user picker.");
            return
          }
          G(Oe, "user-picker")
        };
        var tt = S(Vr);
        {
          var qt = Cr => {
              var Yr = Vke();
              O(Cr, Yr)
            },
            Ut = Cr => {
              Lke(Cr, {
                class: "size-4"
              })
            };
          we(tt, Cr => {
            g(ut) ? Cr(qt) : Cr(Ut, !1)
          })
        }
        P(Vr);
        var fr = L(Vr, 2);
        fr.__click = Gt;
        var Wt = S(fr);
        ms(Wt, {
          class: "size-4"
        }), P(fr), P(zt), P(oe);
        var yr = L(oe, 2),
          tn = S(yr);
        {
          var Kr = Cr => {
              var Yr = Uke();
              O(Cr, Yr)
            },
            Br = Cr => {
              var Yr = Ir(),
                Ln = Pt(Yr);
              {
                var In = jr => {
                    var wn = Zke();
                    O(jr, wn)
                  },
                  Wr = jr => {
                    var wn = nTe(),
                      En = S(wn),
                      Mn = S(En),
                      qn = S(Mn),
                      Gn = S(qn),
                      Jn = S(Gn);
                    sa(Jn), Jn.__click = At => {
                      if (g(Me) === "none") {
                        Ge.clear(), G(et, g(et) + 1), s.crosshair.clear();
                        const Zt = [];
                        for (const gn of g(x)) Pe.has(gn.id) || (Pe.set(gn.id, gn), Zt.push(gn));
                        Zt.length && It(Zt);
                        return
                      }
                      Pe.clear(), Ge.clear(), G(et, g(et) + 1), s.crosshair.clear()
                    }, P(Gn);
                    var Zn = L(Gn),
                      ri = L(S(Zn));
                    ri.__click = () => {
                      navigator.clipboard.writeText([...Pe.keys()].filter(At => At !== 0).join(", ")), rr.success("Player IDs copied to clipboard")
                    };
                    var la = S(ri);
                    om(la, {
                      class: "size-3"
                    }), P(ri);
                    var Hi = L(ri, 2);
                    {
                      var Oa = At => {
                        var Zt = Gke();
                        Zt.__click = () => {
                          const Nr = xe();
                          je(Nr, "timeout")
                        };
                        var gn = S(Zt);
                        nh(gn, {
                          class: "size-4"
                        }), P(Zt), ze(() => Zt.disabled = g(E)), O(At, Zt)
                      };
                      we(Hi, At => {
                        Rt.hasPermission(Fi.tools.selectArea.timeout) && At(Oa)
                      })
                    }
                    var qa = L(Hi, 2);
                    {
                      var Aa = At => {
                        var Zt = $ke();
                        Zt.__click = () => {
                          const Nr = xe();
                          je(Nr, "ban")
                        };
                        var gn = S(Zt);
                        Tp(gn, {
                          class: "size-4"
                        }), P(Zt), ze(() => Zt.disabled = g(E)), O(At, Zt)
                      };
                      we(qa, At => {
                        Rt.hasPermission(Fi.tools.selectArea.ban) && At(Aa)
                      })
                    }
                    P(Zn);
                    var za = L(Zn),
                      Ea = S(za);
                    {
                      var eo = At => {
                        var Zt = Hke();
                        Zt.__click = te;
                        var gn = S(Zt);
                        {
                          var Nr = Fn => {
                              var Rn = Wke();
                              O(Fn, Rn)
                            },
                            un = Fn => {
                              h_(Fn, {
                                class: "size-4"
                              })
                            };
                          we(gn, Fn => {
                            g(k) ? Fn(Nr) : Fn(un, !1)
                          })
                        }
                        P(Zt), ze(() => Zt.disabled = g(k) || g(A) || Pe.size === 0 && g(ve) === 0), O(At, Zt)
                      };
                      we(Ea, At => {
                        Rt.hasPermission(Fi.tools.selectArea.clear) && At(eo)
                      })
                    }
                    bn(), P(za), P(qn), P(Mn);
                    var dt = L(Mn);
                    li(dt, 23, () => g(x), At => At.id, (At, Zt, gn, Nr) => {
                      const un = xt(() => Pe.has(g(Zt).id)),
                        Fn = xt(() => g(Ve).get(g(Zt).id) ?? 0),
                        Rn = xt(() => g(un) || g(Fn) > 0);
                      var Xn = rTe();
                      let zr;
                      Xn.__click = () => {
                        g(un) ? (Pe.delete(g(Zt).id), mt(g(Zt).painted), Rr(g(Zt).id, {
                          skipCrosshair: !0
                        })) : (Rr(g(Zt).id, {
                          skipCrosshair: !0
                        }), Pe.set(g(Zt).id, g(Zt)), (Vt(g(Zt)) || g(Zt).id === 0) && gi.plop.play())
                      };
                      var mr = S(Xn),
                        nn = S(mr);
                      sa(nn), P(mr);
                      var sn = L(mr),
                        Kn = S(sn);
                      {
                        var kn = _n => {
                            var Vn = Xke();
                            bn(2), O(_n, Vn)
                          },
                          Cn = _n => {
                            var Vn = eTe(),
                              ci = Pt(Vn);
                            Fa(ci, {
                              class: "size-5 border-0",
                              get userId() {
                                return g(Zt).id
                              },
                              get pictureUrl() {
                                return g(Zt).picture
                              }
                            });
                            var an = L(ci, 2),
                              Si = S(an),
                              ln = S(Si),
                              dn = S(ln, !0);
                            P(ln);
                            var Na = L(ln, 2),
                              An = S(Na);
                            P(Na), P(Si);
                            var Bi = L(Si, 2);
                            {
                              var Di = ii => {
                                var ui = Yke(),
                                  Xi = S(ui, !0);
                                P(ui), ze((ai, ca) => {
                                  Or(ui, 1, `badge badge-sm ml-0.5 border-0 ${ai??""} ${ca??""}`, "svelte-15blegn"), ee(Xi, g(Zt).allianceName)
                                }, [() => jp(g(Zt).allianceId), () => ta(g(Zt).allianceId)]), O(ii, ui)
                              };
                              we(Bi, ii => {
                                g(Zt).allianceId && ii(Di)
                              })
                            }
                            var La = L(Bi, 2);
                            {
                              var Da = ii => {
                                var ui = Kke();
                                O(ii, ui)
                              };
                              we(La, ii => {
                                g(Zt).deleted && ii(Da)
                              })
                            }
                            var ga = L(La, 2),
                              va = S(ga);
                            {
                              var to = ii => {
                                  var ui = Jke(),
                                    Xi = S(ui);
                                  Tp(Xi, {
                                    class: "text-error size-4"
                                  }), P(ui), ze(ai => or(ui, "data-tip", ai), [() => im()]), O(ii, ui)
                                },
                                so = ii => {
                                  var ui = Ir(),
                                    Xi = Pt(ui);
                                  {
                                    var ai = ca => {
                                      var lo = Qke(),
                                        co = S(lo);
                                      nh(co, {
                                        class: "text-error size-4"
                                      }), P(lo), ze(On => or(lo, "data-tip", On), [() => I0()]), O(ca, lo)
                                    };
                                    we(Xi, ca => {
                                      g(Zt).timedOut && ca(ai)
                                    }, !0)
                                  }
                                  O(ii, ui)
                                };
                              we(va, ii => {
                                g(Zt).banned ? ii(to) : ii(so, !1)
                              })
                            }
                            P(ga), P(an), ze(ii => {
                              Or(Si, 1, `font-medium ${ii??""} flex gap-1.5`, "svelte-15blegn"), ee(dn, g(Zt).name), ee(An, `#${g(Zt).id??""}`)
                            }, [() => ta(g(Zt).id)]), O(_n, Vn)
                          };
                        we(Kn, _n => {
                          g(Zt).id === 0 ? _n(kn) : _n(Cn, !1)
                        })
                      }
                      P(sn);
                      var $n = L(sn),
                        bi = S($n),
                        Nn = L(bi);
                      {
                        var fn = _n => {
                          var Vn = tTe(),
                            ci = S(Vn);
                          P(Vn), ze(an => ee(ci, `(${an??""} selected)`), [() => g(Fn).toLocaleString()]), O(_n, Vn)
                        };
                        we(Nn, _n => {
                          !g(un) && g(Fn) > 0 && _n(fn)
                        })
                      }
                      P($n), P(Xn), ze(_n => {
                        zr = Or(Xn, 1, "hover:bg-base-300 cursor-pointer svelte-15blegn", null, zr, {
                          "bg-base-200": g(Rn)
                        }), gv(nn, g(un)), nn.indeterminate = !g(un) && g(Fn) > 0, ee(bi, `${_n??""} `)
                      }, [() => g(Zt).painted.latitudes.length.toLocaleString()]), O(At, Xn)
                    }), P(dt), P(En), P(wn), ze(() => {
                      gv(Jn, g(Me) !== "none"), Jn.indeterminate = g(Me) === "some"
                    }), O(jr, wn)
                  };
                we(Ln, jr => {
                  g(x).length === 0 ? jr(In) : jr(Wr, !1)
                }, !0)
              }
              O(Cr, Yr)
            };
          we(tn, Cr => {
            g(A) ? Cr(Kr) : Cr(Br, !1)
          })
        }
        P(yr), P(Qe), P(vt), P(Q), oo(Q, Cr => G(fe, Cr), () => g(fe)), ze((Cr, Yr) => {
          Ze = Io(Q, "", Ze, {
            transform: `translate3d(${Z.x}px, ${Z.y}px, 0)`,
            "will-change": "transform"
          }), ee(_t, `(Pixels: ${Cr??""})`), or(ir, "aria-label", `${Yr??""} toggle`), or(Fr, "data-tip", g(j) ? "Save selected map view" : "Save selected pixel art"), Fr.disabled = g(l) || g(A), Ar = Or(ar, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, Ar, {
            "btn-soft": g(Oe) !== "brush-circle",
            "btn-primary": g(Oe) === "brush-circle"
          }), or(ar, "data-tip", `Circle brush (Alt + scroll to resize) Â· Size: ${g(Ce)}`), or(ar, "aria-label", g(Oe) === "brush-circle" ? "Disable circle brush tool" : `Enable circle brush tool (size ${g(Ce)})`), or(ar, "aria-pressed", g(Oe) === "brush-circle"), Mr = Or(Gr, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, Mr, {
            "btn-soft": g(Oe) !== "brush-square",
            "btn-primary": g(Oe) === "brush-square"
          }), or(Gr, "data-tip", `Square brush (Alt + scroll to resize) Â· Size: ${g(Ce)}`), or(Gr, "aria-label", g(Oe) === "brush-square" ? "Disable square brush tool" : `Enable square brush tool (size ${g(Ce)})`), or(Gr, "aria-pressed", g(Oe) === "brush-square"), Le = Or(Vr, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, Le, {
            "btn-soft": g(Oe) !== "user-picker",
            "btn-primary": g(Oe) === "user-picker"
          }), or(Vr, "data-tip", g(Oe) === "user-picker" ? "User picker enabled. Click pixels to select their painter." : "Enable the user picker to select a player by clicking a pixel."), or(Vr, "aria-label", g(Oe) === "user-picker" ? "Disable user picker tool" : "Enable user picker tool"), or(Vr, "aria-pressed", g(Oe) === "user-picker")
        }, [() => g(Ye).toLocaleString(), () => Woe()]), wp(ir, () => g(j), Cr => G(j, Cr)), oa(3, vt, () => cp, () => ({
          duration: 100
        })), O(he, Q)
      };
    we(qe, he => {
      r.length < 2 ? he(rt) : he(Xe, !1)
    })
  }
  O(d, Ie), en()
}
Yn(["pointerdown", "click"]);
var oTe = $r('<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>');

function Oy(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = oTe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var sTe = $r('<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>');

function lTe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = sTe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var cTe = $r('<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>'),
  uTe = $r('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>');

function hTe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Ir(),
    A = Pt(x);
  {
    var E = l => {
        var j = cTe();
        Dr(j, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), O(l, j)
      },
      k = l => {
        var j = uTe();
        Dr(j, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), O(l, j)
      };
    we(A, l => {
      s.filled ? l(E) : l(k, !1)
    })
  }
  O(d, x)
}
var dTe = se('<a target="_blank"><button class="btn btn-xs py-3"><!></button></a>'),
  pTe = se('<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button> <!>', 1),
  fTe = se('<div class="skeleton h-5 w-16"></div>'),
  _Te = se('<div class="skeleton mt-1 h-5 w-32"></div>'),
  mTe = se('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><div class="bg-base-content/20 flex size-5 items-center justify-center rounded-full text-sm">ğŸ„</div></div> <div class="flex flex-wrap items-center gap-1"><span class="flex gap-1.5 font-medium text-orange-500"><span>Christmas</span></span></div></div>'),
  gTe = se('<img alt="Frame equipado" class="pointer-events-none absolute inset-0 h-6 w-6 select-none"/>'),
  vTe = se('<span class="font-flag tooltip ml-0.5"> </span>'),
  yTe = se("<button><!></button>"),
  xTe = se("<span> </span> <!>", 1),
  bTe = se('<span class="tooltip"><!></span>'),
  wTe = se('<span class="tooltip"><!></span>'),
  kTe = se("<li><button><!> </button></li>"),
  TTe = se("<li><button><!> </button></li>"),
  PTe = se("<li><button><!> </button></li>"),
  STe = se('<li><button class="text-error font-medium"><!> </button></li>'),
  MTe = se('<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left ml-1"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 shadow-sm"></ul></div>'),
  ITe = se('<div class="flex items-center gap-1"><span> </span> <div class="relative ml-0.5 h-5 w-6"><div class="ml-0.5"><!></div> <!></div> <div class="flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!> <!> <!> <!> <!></div> <!></div>'),
  CTe = se('<button class="btn btn-primary"><!> </button>'),
  ATe = se("<!> ", 1),
  zTe = se("<!> ", 1),
  ETe = se('<button class="btn btn-primary"><!></button>'),
  LTe = se("<button><!> </button>"),
  DTe = se('<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><!> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>');

function RTe(d, s) {
  Qr(s, !0);
  let r = We(void 0);
  const x = xt(() => new ja(s.tileSize));
  let A = We(void 0),
    E = We(void 0),
    k = We(!1),
    l = We(!1);
  const j = xt(() => {
      var it, He, Ot;
      return !!((He = (it = g(r)) == null ? void 0 : it.paintedBy) != null && He.id) && ((Ot = Rt.data) == null ? void 0 : Ot.id) === g(r).paintedBy.id
    }),
    W = xt(() => {
      const [it, He] = s.latLon ?? [0, 0];
      return `https://wplace.eralyon.net/?lat=${it}&lng=${He}&zoom=${s.zoom}`
    }),
    $ = xt(() => {
      const [it, He] = s.latLon ?? [0, 0], Ot = g(x).latLonToPixelBoundsLatLon(it, He, s.pixelArtZoom), Gt = pm(Ot), {
        tile: kt,
        pixel: nr
      } = g(x).latLonToTileAndPixel(it, He, s.pixelArtZoom), It = g(x).latLonToRegionAndPixel(it, He, s.pixelArtZoom);
      return {
        lat: it,
        lon: He,
        bounds: Ot,
        center: Gt,
        tile: kt,
        pixel: nr,
        regionPixel: It.pixel
      }
    });
  rn(() => {
    gi.plop.play(), s.crosshair.clearAndPlace(s.latLon)
  });
  let J = 0;
  const ce = ({
    pixel: it,
    tile: He,
    season: Ot
  }) => `s${Ot}:p(${it[0]},${it[1]}):t(${He[0]},${He[1]})`;
  let ge;
  fs(() => [g($), s.season], () => {
    const it = {
      ...g($),
      season: s.season
    };
    s.christmasTreeId !== void 0 && (it.christmasTreeId = s.christmasTreeId);
    const He = ce(it);
    if (G(r, s.pixelInfoCache.get(He), !0), g(r) !== void 0) return;
    s.pixelInfoCache.size === 0 && (J = 0), J++, J > 6 ? (clearTimeout(ge), ge = setTimeout(async () => fe(it), 500)) : fe(it)
  });
  async function fe(it) {
    var Gt;
    const He = await pn.getPixelInfo({
      ...it,
      role: (Gt = Rt.data) == null ? void 0 : Gt.role,
      christmasTreeId: s.christmasTreeId
    });
    if (He.paintedBy !== void 0) {
      const kt = ce(it);
      s.pixelInfoCache.set(kt, He)
    }
    const Ot = ce({
      ...g($),
      season: s.season
    });
    return G(r, s.pixelInfoCache.get(Ot), !0), He
  }
  Wi(() => () => {
    s.crosshair.clear(), gi.smallPlop.play()
  });
  const Z = xt(() => {
    const it = [];
    return Rt.hasPermission(Fi.tools.selectPixel.ban) && it.push("ban-user"), Rt.hasPermission(Fi.tools.selectPixel.timeout) && it.push("timeout-user"), !g(j) && Rt.data && it.push("report-user"), it
  });

  function de(it) {
    const He = (async () => await Ip(s.map, {
      maxHeight: 1080,
      maxWidth: 1080,
      quality: .8,
      type: "image/jpeg"
    }))();
    s.onclickmodaction(g(r), He, s.latLon, it)
  }
  async function Fe() {
    try {
      await pn.claimEventPixel(s.christmasTreeId), await fe({
        ...g($),
        season: s.season
      }), await pn.getChristmasLocations(), await Rt.refresh()
    } catch (it) {
      rr.error(it.message)
    }
  }
  var Re = DTe();
  Pn("keypress", Vs, it => {
    it.key === "Escape" && s.onclose()
  });
  var Pe = S(Re),
    Ge = S(Pe),
    et = S(Ge);
  et.__click = () => {
    if (g(A) && g(E)) {
      const it = g(A) - g(E).clientHeight,
        He = g(A) / 2 - it / 2;
      s.map.flyTo({
        center: {
          lat: g($).center[0],
          lng: g($).center[1]
        },
        zoom: 17.5,
        offset: [0, -He]
      })
    }
  };
  var Ve = S(et);
  wl(Ve, {
    class: "fill-primary size-5"
  }), P(et);
  var ve = L(et, 2),
    Me = S(ve),
    Ye = S(Me);
  P(Me);
  var Ce = L(Me, 2);
  {
    var Oe = it => {
        const He = xt(() => g(r).region),
          Ot = xt(() => qo(g(He).countryId));
        var Gt = pTe(),
          kt = Pt(Gt);
        kt.__click = () => s.onclickregion(g(He));
        var nr = S(kt),
          It = S(nr, !0);
        P(nr);
        var mt = L(nr, 2),
          yt = S(mt, !0);
        P(mt);
        var bt = L(mt, 2),
          Lt = S(bt);
        P(bt), P(kt);
        var st = L(kt, 2);
        {
          var lr = gr => {
            var dr = dTe(),
              pr = S(dr),
              Ht = S(pr);
            zy(Ht, {
              class: "h-4 w-4"
            }), P(pr), P(dr), ze(() => or(dr, "href", g(W))), O(gr, dr)
          };
          we(st, gr => {
            var dr;
            ((dr = Rt.data) == null ? void 0 : dr.role) !== "user" && Rt.hasPermission(Fi.tools.selectPixel.archive) && gr(lr)
          })
        }
        ze(gr => {
          Or(kt, 1, `btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${gr??""}`), or(nr, "data-tip", g(Ot).name), ee(It, g(Ot).flag), ee(yt, g(He).name), ee(Lt, `#${g(He).number??""}`)
        }, [() => ta(g(He).cityId)]), O(it, Gt)
      },
      ut = it => {
        var He = fTe();
        O(it, He)
      };
    we(Ce, it => {
      var He;
      (He = g(r)) != null && He.region ? it(Oe) : it(ut, !1)
    })
  }
  P(ve), P(Ge);
  var Ue = L(Ge, 2);
  Ue.__click = function(...it) {
    var He;
    (He = s.onclose) == null || He.apply(this, it)
  };
  var Ke = S(Ue);
  ms(Ke, {
    class: "size-4"
  }), P(Ue), P(Pe);
  var St = L(Pe, 2),
    Ft = S(St);
  {
    var Jt = it => {
        var He = _Te();
        O(it, He)
      },
      Mt = it => {
        var He = Ir(),
          Ot = Pt(He);
        {
          var Gt = nr => {
              var It = vi();
              ze(mt => ee(It, mt), [() => dq()]), O(nr, It)
            },
            kt = nr => {
              var It = Ir(),
                mt = Pt(It);
              {
                var yt = Lt => {
                    var st = mTe(),
                      lr = S(st),
                      gr = S(lr);
                    P(lr), bn(4), P(st), ze(dr => ee(gr, `${dr??""}:`), [() => L6()]), O(Lt, st)
                  },
                  bt = Lt => {
                    const st = xt(() => g(r).paintedBy);
                    var lr = ITe(),
                      gr = S(lr),
                      dr = S(gr);
                    P(gr);
                    var pr = L(gr, 2),
                      Ht = S(pr),
                      Sr = S(Ht);
                    Fa(Sr, {
                      class: "size-5 border-0",
                      get userId() {
                        return g(st).id
                      },
                      get pictureUrl() {
                        return g(st).picture
                      }
                    }), P(Ht);
                    var Rr = L(Ht, 2);
                    {
                      var Vt = oe => {
                        var De = gTe();
                        ze(() => or(De, "src", g(st).equippedFrameUrl)), O(oe, De)
                      };
                      we(Rr, oe => {
                        g(st).equippedFrameUrl && oe(Vt)
                      })
                    }
                    P(pr);
                    var Tr = L(pr, 2),
                      Xt = S(Tr),
                      ue = S(Xt),
                      N = S(ue, !0);
                    P(ue);
                    var q = L(ue, 2),
                      X = S(q);
                    P(q), P(Xt);
                    var te = L(Xt, 2);
                    {
                      var le = oe => {
                        const De = xt(() => qo(g(st).equippedFlag));
                        var Je = vTe(),
                          Tt = S(Je, !0);
                        P(Je), ze(() => {
                          or(Je, "data-tip", g(De).name), ee(Tt, g(De).flag)
                        }), O(oe, Je)
                      };
                      we(te, oe => {
                        g(st).equippedFlag && oe(le)
                      })
                    }
                    var xe = L(te, 2);
                    {
                      var je = oe => {
                        Nh(oe, {
                          get username() {
                            return g(st).discord
                          },
                          get id() {
                            return g(st).discordId
                          }
                        })
                      };
                      we(xe, oe => {
                        g(st).discord && oe(je)
                      })
                    }
                    var Ie = L(xe, 2);
                    {
                      var qe = oe => {
                        M0(oe, {
                          get role() {
                            return g(st).role
                          },
                          big: !1
                        })
                      };
                      we(Ie, oe => {
                        g(st).role && g(st).role !== "user" && oe(qe)
                      })
                    }
                    var rt = L(Ie, 2);
                    {
                      var Xe = oe => {
                        var De = xTe(),
                          Je = Pt(De),
                          Tt = S(Je, !0);
                        P(Je);
                        var Dt = L(Je, 2);
                        {
                          var _t = zt => {
                            var Yt = yTe();
                            Yt.__click = () => {
                              navigator.clipboard.writeText(g(st).allianceId.toString()), rr.success(sm())
                            };
                            var $e = S(Yt);
                            om($e, {
                              class: "size-3"
                            }), P(Yt), ze((Ct, ir) => {
                              Or(Yt, 1, Ct), or(Yt, "title", ir)
                            }, [() => Us(ta(g(st).allianceId)), () => t2({
                              allianceId: g(st).allianceId
                            })]), O(zt, Yt)
                          };
                          we(Dt, zt => {
                            var Yt, $e, Ct;
                            (((Yt = Rt.data) == null ? void 0 : Yt.role) === "admin" || (($e = Rt.data) == null ? void 0 : $e.role) === "moderator" || ((Ct = Rt.data) == null ? void 0 : Ct.role) === "global_moderator") && zt(_t)
                          })
                        }
                        ze((zt, Yt) => {
                          Or(Je, 1, `badge badge-sm ml-0.5 border-0 ${zt??""} ${Yt??""}`), ee(Tt, g(st).allianceName)
                        }, [() => jp(g(st).allianceId), () => ta(g(st).allianceId)]), O(oe, De)
                      };
                      we(rt, oe => {
                        g(st).allianceId && oe(Xe)
                      })
                    }
                    var he = L(rt, 2);
                    {
                      var Q = oe => {
                          var De = bTe(),
                            Je = S(De);
                          Tp(Je, {
                            class: "text-error size-4"
                          }), P(De), ze(Tt => or(De, "data-tip", Tt), [() => im()]), O(oe, De)
                        },
                        Ze = oe => {
                          var De = Ir(),
                            Je = Pt(De);
                          {
                            var Tt = Dt => {
                              var _t = wTe(),
                                zt = S(_t);
                              nh(zt, {
                                class: "text-error size-4"
                              }), P(_t), ze(Yt => or(_t, "data-tip", Yt), [() => I0()]), O(Dt, _t)
                            };
                            we(Je, Dt => {
                              g(r).paintedBy.timedOut && Dt(Tt)
                            }, !0)
                          }
                          O(oe, De)
                        };
                      we(he, oe => {
                        g(r).paintedBy.banned ? oe(Q) : oe(Ze, !1)
                      })
                    }
                    P(Tr);
                    var vt = L(Tr, 2);
                    {
                      var Qe = oe => {
                        var De = MTe(),
                          Je = S(De),
                          Tt = S(Je);
                        ym(Tt, {
                          class: "size-4"
                        }), P(Je);
                        var Dt = L(Je, 2);
                        li(Dt, 21, () => g(Z), Bc, (_t, zt) => {
                          var Yt = Ir(),
                            $e = Pt(Yt);
                          {
                            var Ct = Fr => {
                                var br = kTe(),
                                  nt = S(br);
                                let cr;
                                nt.__click = () => {
                                  de("report-user")
                                };
                                var ar = S(nt);
                                $_(ar, {
                                  class: "size-5"
                                });
                                var Ar = L(ar);
                                P(nt), P(br), ze(qr => {
                                  cr = Or(nt, 1, "py-2 font-medium text-red-300", null, cr, {
                                    "cursor-not-allowed": g(j)
                                  }), ee(Ar, ` ${qr??""}`)
                                }, [() => D1()]), O(Fr, br)
                              },
                              ir = Fr => {
                                var br = Ir(),
                                  nt = Pt(br);
                                {
                                  var cr = Ar => {
                                      var qr = TTe(),
                                        Gr = S(qr);
                                      let Mr;
                                      Gr.__click = () => {
                                        de("timeout")
                                      };
                                      var Sn = S(Gr);
                                      nh(Sn, {
                                        class: "size-5"
                                      });
                                      var Vr = L(Sn);
                                      P(Gr), P(qr), ze(Le => {
                                        Mr = Or(Gr, 1, "text-warning font-medium", null, Mr, {
                                          "cursor-not-allowed": g(j)
                                        }), ee(Vr, ` ${Le??""}`)
                                      }, [() => R1()]), O(Ar, qr)
                                    },
                                    ar = Ar => {
                                      var qr = Ir(),
                                        Gr = Pt(qr);
                                      {
                                        var Mr = Vr => {
                                            var Le = PTe(),
                                              tt = S(Le);
                                            let qt;
                                            tt.__click = () => {
                                              de("ban")
                                            };
                                            var Ut = S(tt);
                                            Tp(Ut, {
                                              class: "size-5"
                                            });
                                            var fr = L(Ut);
                                            P(tt), P(Le), ze(Wt => {
                                              qt = Or(tt, 1, "text-error font-medium", null, qt, {
                                                "cursor-not-allowed": g(j)
                                              }), ee(fr, ` ${Wt??""}`)
                                            }, [() => j1()]), O(Vr, Le)
                                          },
                                          Sn = Vr => {
                                            var Le = Ir(),
                                              tt = Pt(Le);
                                            {
                                              var qt = Ut => {
                                                var fr = STe(),
                                                  Wt = S(fr);
                                                Wt.__click = async () => {
                                                  G(l, !0);
                                                  try {
                                                    await pn.banAllianceUser(g(st).id), await fe({
                                                      ...g($),
                                                      season: s.season
                                                    })
                                                  } catch (Kr) {
                                                    rr.error(Kr.message)
                                                  } finally {
                                                    G(l, !1)
                                                  }
                                                };
                                                var yr = S(Wt);
                                                lTe(yr, {
                                                  class: "size-5"
                                                });
                                                var tn = L(yr);
                                                P(Wt), P(fr), ze(Kr => ee(tn, ` ${Kr??""}`), [() => E0()]), O(Ut, fr)
                                              };
                                              we(tt, Ut => {
                                                g(zt) === "ban-alliance" && Ut(qt)
                                              }, !0)
                                            }
                                            O(Vr, Le)
                                          };
                                        we(Gr, Vr => {
                                          g(zt) === "ban-user" ? Vr(Mr) : Vr(Sn, !1)
                                        }, !0)
                                      }
                                      O(Ar, qr)
                                    };
                                  we(nt, Ar => {
                                    g(zt) === "timeout-user" ? Ar(cr) : Ar(ar, !1)
                                  }, !0)
                                }
                                O(Fr, br)
                              };
                            we($e, Fr => {
                              g(zt) === "report-user" ? Fr(Ct) : Fr(ir, !1)
                            })
                          }
                          O(_t, Yt)
                        }), P(Dt), P(De), O(oe, De)
                      };
                      we(vt, oe => {
                        g(Z).length > 0 && oe(Qe)
                      })
                    }
                    P(lr), ze((oe, De) => {
                      var Je;
                      ee(dr, `${oe??""}:`), Or(Xt, 1, `font-medium ${De??""} flex gap-1.5`), ee(N, ((Je = Rt.data) == null ? void 0 : Je.id) === g(st).id ? Rt.data.name : g(st).name), ee(X, `#${g(st).id??""}`)
                    }, [() => ZV(), () => ta(g(st).id)]), O(Lt, lr)
                  };
                we(mt, Lt => {
                  g(r).paintedBy.event ? Lt(yt) : Lt(bt, !1)
                }, !0)
              }
              O(nr, It)
            };
          we(Ot, nr => {
            g(r).paintedBy.id === 0 ? nr(Gt) : nr(kt, !1)
          }, !0)
        }
        O(it, He)
      };
    we(Ft, it => {
      g(r) === void 0 ? it(Jt) : it(Mt, !1)
    })
  }
  P(St);
  var ct = L(St, 2),
    wt = S(ct);
  {
    var ft = it => {
        var He = CTe();
        He.__click = () => s.onclickpaint(s.latLon);
        var Ot = S(He);
        Pl(Ot, {
          class: "size-4.5"
        });
        var Gt = L(Ot);
        P(He), ze(kt => {
          He.disabled = Rt.loading, ee(Gt, ` ${kt??""}`)
        }, [() => F0()]), O(it, He)
      },
      $t = it => {
        var He = Ir(),
          Ot = Pt(He);
        {
          var Gt = kt => {
            var nr = ETe();
            nr.__click = () => Fe();
            var It = S(nr);
            {
              var mt = bt => {
                  var Lt = ATe(),
                    st = Pt(Lt);
                  r2(st, {
                    class: "size-4.5"
                  });
                  var lr = L(st);
                  ze(gr => ee(lr, ` ${gr??""}`), [() => jT()]), O(bt, Lt)
                },
                yt = bt => {
                  var Lt = zTe(),
                    st = Pt(Lt);
                  Oy(st, {
                    class: "size-4.5"
                  });
                  var lr = L(st);
                  ze(gr => ee(lr, ` ${gr??""}`), [() => L0()]), O(bt, Lt)
                };
              we(It, bt => {
                g(r).paintedBy.claimed ? bt(mt) : bt(yt, !1)
              })
            }
            P(nr), ze(() => nr.disabled = Rt.loading || g(r).paintedBy.claimed), O(kt, nr)
          };
          we(Ot, kt => {
            Rt.data && g(r).paintedBy.eventClaimNumber && kt(Gt)
          }, !0)
        }
        O(it, He)
      };
    we(wt, it => {
      var He;
      (He = g(r)) != null && He.paintedBy.event ? it($t, !1) : it(ft)
    })
  }
  var Et = L(wt, 2);
  {
    var Qt = it => {
      const He = xt(() => Rt.data.favoriteLocations.find(mt => Math.abs(mt.latitude - g($).center[0]) < 5e-5 && Math.abs(mt.longitude - g($).center[1]) < 5e-5)),
        Ot = xt(() => !g(He) && Rt.data.favoriteLocations.length >= Rt.data.maxFavoriteLocations);
      var Gt = LTe();
      let kt;
      Gt.__click = async () => {
        try {
          G(k, !0), g(He) ? (await pn.deleteFavoriteLocation(g(He).id), rr.warning(GD())) : (await pn.favoriteLocation(g($).center), rr.success(ED())), gi.smallPlop.play(), Rt.refresh()
        } catch (mt) {
          rr.error(mt.message)
        } finally {
          G(k, !1)
        }
      };
      var nr = S(Gt);
      {
        let mt = xt(() => !!g(He));
        hTe(nr, {
          class: "size-4.5",
          get filled() {
            return g(mt)
          }
        })
      }
      var It = L(nr);
      P(Gt), ze(mt => {
        kt = Or(Gt, 1, "btn btn-primary btn-soft", null, kt, {
          "text-yellow-400": !!g(He)
        }), Gt.disabled = g(k) || g(Ot), ee(It, ` ${mt??""}`)
      }, [() => g(Ot) ? oD() : $6()]), O(it, Gt)
    };
    we(Et, it => {
      Rt.data && it(Qt)
    })
  }
  var vr = L(Et, 2);
  vr.__click = () => s.onclickshare(cve(xi.url, {
    pos: {
      lat: g($).center[0],
      lng: g($).center[1]
    },
    zoom: s.zoom
  }));
  var Kt = S(vr);
  dy(Kt, {
    class: "size-4.5"
  });
  var Bt = L(Kt);
  P(vr), P(ct), P(Re), oo(Re, it => G(E, it), () => g(E)), ze(it => {
    ee(Ye, `Pixel: ${g($).regionPixel[0]??""}, ${g($).regionPixel[1]??""}`), ee(Bt, ` ${it??""}`)
  }, [() => wY()]), Fh("innerHeight", it => G(A, it, !0)), O(d, Re), en()
}
Yn(["click"]);

function jTe(d) {
  var x;
  const s = document.createElement("div");
  (x = d.parentElement) == null || x.insertBefore(s, d.nextSibling);
  const r = new IntersectionObserver(A => {
    A[0].isIntersecting ? d.classList.remove("stuck") : d.classList.add("stuck")
  }, {
    threshold: 0,
    rootMargin: "0px"
  });
  return r.observe(s), () => {
    s.remove(), r.disconnect()
  }
}
var H_;
(d => {
  function s() {
    let r, x;
    return {
      promise: new Promise((E, k) => {
        r = E, x = k
      }),
      resolve: r,
      reject: x
    }
  }
  d.withResolvers = s
})(H_ || (H_ = {}));
var FTe = $r('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>'),
  BTe = $r('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>');

function OTe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Ir(),
    A = Pt(x);
  {
    var E = l => {
        var j = FTe();
        Dr(j, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), O(l, j)
      },
      k = l => {
        var j = BTe();
        Dr(j, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), O(l, j)
      };
    we(A, l => {
      s.filled ? l(E) : l(k, !1)
    })
  }
  O(d, x)
}
var qTe = se("<p><!></p>"),
  NTe = se('<span class="loading loading-spinner center-absolute absolute"></span>'),
  VTe = se('<span class="text-sm"> </span>'),
  UTe = se(' <span class="text-sm">Droplets</span>', 1),
  ZTe = se('<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <!></button>'),
  GTe = se('<span class="loading loading-spinner center-absolute absolute"></span>'),
  $Te = se('<!> <span class="text-sm"> </span>', 1),
  WTe = se('<span class="text-sm"> </span>'),
  HTe = se('<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>'),
  XTe = se('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <h3 class="mt-2 text-center text-xl font-bold"> <!></h3> <!> <div><!></div></div>'),
  YTe = se('<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>');

function KTe(d, s) {
  Qr(s, !0);
  const r = (Ve, ve = Qa, Me = Qa) => {
      const Ye = xt(() => {
          var Kt;
          return (((Kt = Rt.data) == null ? void 0 : Kt.droplets) ?? 0) >= l.price
        }),
        Ce = xt(() => g(W) === ve().id),
        Oe = xt(() => x.has(ve().id));
      var ut = XTe(),
        Ue = S(ut),
        Ke = S(Ue, !0);
      P(Ue);
      var St = L(Ue, 2),
        Ft = S(St),
        Jt = L(Ft);
      {
        var Mt = Kt => {
          var Bt = qTe(),
            it = S(Bt);
          oh(it, {
            class: "text-base-content/60 inline size-4.5 pb-0.5"
          }), P(Bt), ze(He => {
            Or(Bt, 1, Us({
              "tooltip inline": !0,
              "lg:before:-translate-x-1/3": (Me() + 1) % 4 === 0,
              "lg:before:translate-x-1/3": Me() % 4 === 0,
              "before:-translate-x-1/3": (Me() + 1) % 2 === 0,
              "before:translate-x-1/3": Me() % 2 === 0
            })), or(Bt, "data-tip", He)
          }, [() => _O()]), O(Kt, Bt)
        };
        we(Jt, Kt => {
          g(Oe) && Kt(Mt)
        })
      }
      P(St);
      var ct = L(St, 2);
      {
        var wt = Kt => {
          wm(Kt, {})
        };
        we(ct, Kt => {
          ve().id === g($) && Kt(wt)
        })
      }
      var ft = L(ct, 2);
      let $t;
      var Et = S(ft);
      {
        var Qt = Kt => {
            var Bt = ZTe();
            Bt.__click = async () => {
              if (!(g(Oe) && !await s.promptUserConfirmation(ve().label))) try {
                const It = ve().id;
                G(W, It, !0), await pn.purchase({
                  id: k,
                  amount: 1,
                  variant: It
                }), Rt.refresh(), gi.notification1.play();
                const mt = E.find(yt => yt.id === It);
                mt && (mt.owned = !0), G($, It, !0)
              } catch (It) {
                rr.error(It.message)
              } finally {
                G(W, void 0)
              }
            };
            var it = S(Bt);
            {
              var He = It => {
                var mt = NTe();
                O(It, mt)
              };
              we(it, It => {
                g(Ce) && It(He)
              })
            }
            var Ot = L(it, 2);
            Rp(Ot, {
              class: "size-4"
            });
            var Gt = L(Ot, 2);
            {
              var kt = It => {
                  var mt = VTe(),
                    yt = S(mt, !0);
                  P(mt), ze(bt => ee(yt, bt), [() => Gse()]), O(It, mt)
                },
                nr = It => {
                  var mt = UTe(),
                    yt = Pt(mt);
                  bn(), ze(bt => ee(yt, `${bt??""} `), [() => l.price.toLocaleString("en-US")]), O(It, mt)
                };
              we(Gt, It => {
                var mt;
                (mt = Rt.data) != null && mt.freeFlag ? It(kt) : It(nr, !1)
              })
            }
            P(Bt), ze(() => {
              var It;
              return Bt.disabled = !g(Ye) && ((It = Rt.data) == null ? void 0 : It.freeFlag) == !1 || g(Ce)
            }), O(Kt, Bt)
          },
          vr = Kt => {
            const Bt = xt(() => {
              var bt;
              return ((bt = Rt.data) == null ? void 0 : bt.equippedFlag) === ve().id
            });
            var it = HTe();
            let He;
            it.__click = async () => {
              try {
                G(W, ve().id, !0);
                const bt = g(Bt) ? 0 : ve().id;
                await pn.equipFlag(bt), Rt.data && (Rt.data.equippedFlag = bt), Rt.refresh()
              } catch (bt) {
                rr.error(bt.message)
              } finally {
                G(W, void 0)
              }
            };
            var Ot = S(it),
              Gt = S(Ot, !0);
            P(Ot);
            var kt = L(Ot, 2);
            {
              var nr = bt => {
                var Lt = GTe();
                O(bt, Lt)
              };
              we(kt, bt => {
                g(Ce) && bt(nr)
              })
            }
            var It = L(kt, 2);
            {
              var mt = bt => {
                  var Lt = $Te(),
                    st = Pt(Lt);
                  ms(st, {
                    class: "size-4"
                  });
                  var lr = L(st, 2),
                    gr = S(lr, !0);
                  P(lr), ze(dr => ee(gr, dr), [() => s6()]), O(bt, Lt)
                },
                yt = bt => {
                  var Lt = WTe(),
                    st = S(Lt, !0);
                  P(Lt), ze(lr => ee(st, lr), [() => HI()]), O(bt, Lt)
                };
              we(It, bt => {
                g(Bt) ? bt(mt) : bt(yt, !1)
              })
            }
            P(it), ze(bt => {
              He = Or(it, 1, "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10", null, He, {
                "btn-warning": g(Bt)
              }), it.disabled = g(Ce), ee(Gt, bt)
            }, [() => cI()]), O(Kt, it)
          };
        we(Et, Kt => {
          ve().owned ? Kt(vr, !1) : Kt(Qt)
        })
      }
      P(ft), P(ut), ze(Kt => {
        var Bt;
        ee(Ke, ve().flag), ee(Ft, `${ve().label??""} `), $t = Or(ft, 1, "mt-3", null, $t, {
          tooltip: !g(Ye) && !ve().owned && ((Bt = Rt.data) == null ? void 0 : Bt.freeFlag) == !1
        }), or(ft, "data-tip", Kt)
      }, [() => Op()]), O(Ve, ut)
    },
    x = new Set([8, 30, 32, 84, 96, 125, 143, 146, 150, 192, 200, 236, 240, 251]),
    A = Ia.countries.map(Ve => {
      var ve, Me;
      return {
        ...Ve,
        owned: Rt.flagsBitmap.get(Ve.id),
        label: ((Me = (ve = F1)[Ve.code]) == null ? void 0 : Me.call(ve)) ?? Ve.name
      }
    });
  A.sort((Ve, ve) => Number(ve.owned) - Number(Ve.owned));
  const E = Pi(A),
    k = 110,
    l = Ia.products[k];
  let j = We(!1),
    W = We(void 0),
    $ = We(void 0);
  var J = YTe(),
    ce = S(J),
    ge = S(ce);
  OTe(ge, {
    class: "size-5.5",
    filled: !0
  });
  var fe = L(ge, 2),
    Z = S(fe, !0);
  P(fe), P(ce);
  var de = L(ce, 2),
    Fe = S(de, !0);
  P(de);
  var Re = L(de, 2);
  li(Re, 23, () => E, Ve => Ve.id, (Ve, ve, Me) => {
    var Ye = Ir(),
      Ce = Pt(Ye);
    {
      var Oe = ut => {
        r(ut, () => g(ve), () => g(Me))
      };
      we(Ce, ut => {
        (g(Me) < 8 || g(j)) && ut(Oe)
      })
    }
    O(Ve, Ye)
  }), P(Re);
  var Pe = L(Re, 2),
    Ge = S(Pe);
  Ge.__click = () => {
    G(j, !g(j))
  };
  var et = S(Ge, !0);
  P(Ge), P(Pe), P(J), ze((Ve, ve, Me) => {
    ee(Z, Ve), ee(Fe, ve), ee(et, Me)
  }, [() => Ese(), () => FM(), () => g(j) ? ose() : yse()]), O(d, J), en()
}
Yn(["click"]);
var JTe = se('<p class="mt-1 text-center text-sm"> </p>'),
  QTe = se('<button class="text-base-content/80 absolute left-full top-1/2 ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>'),
  ePe = se('<span class="loading loading-spinner center-absolute absolute"></span>'),
  tPe = se('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>');

function s0(d, s) {
  Qr(s, !0);
  let r = sr(s, "amount", 15, 1);
  const x = xt(() => r() * s.unitPrice),
    A = xt(() => Math.floor(s.userDroplets / s.unitPrice));
  let E = We(!1);
  rn(() => {
    r() < 0 && r(0)
  });
  var k = tPe(),
    l = S(k),
    j = S(l);
  Ei(j, () => s.icon ?? Qa), P(l);
  var W = L(l, 2),
    $ = S(W, !0);
  P(W);
  var J = L(W, 2);
  {
    var ce = Ce => {
      var Oe = JTe(),
        ut = S(Oe, !0);
      P(Oe), ze(() => ee(ut, s.subtitle)), O(Ce, Oe)
    };
    we(J, Ce => {
      s.subtitle && Ce(ce)
    })
  }
  var ge = L(J, 2),
    fe = S(ge);
  fe.__click = () => {
    yv(r, -1)
  };
  var Z = L(fe, 2);
  sa(Z);
  var de = L(Z, 2);
  de.__click = () => {
    yv(r)
  };
  var Fe = L(de, 2);
  {
    var Re = Ce => {
      var Oe = QTe();
      Oe.__click = () => {
        r(g(A))
      }, O(Ce, Oe)
    };
    we(Fe, Ce => {
      r() < g(A) && Ce(Re)
    })
  }
  P(ge);
  var Pe = L(ge, 2);
  let Ge;
  var et = S(Pe);
  et.__click = async () => {
    try {
      G(E, !0), await pn.purchase({
        id: s.productId,
        amount: r()
      }), gi.notification1.play(), s.onpurchasecompleted(r())
    } catch (Ce) {
      rr.error(Ce.message)
    } finally {
      G(E, !1)
    }
  };
  var Ve = S(et);
  {
    var ve = Ce => {
      var Oe = ePe();
      O(Ce, Oe)
    };
    we(Ve, Ce => {
      g(E) && Ce(ve)
    })
  }
  var Me = L(Ve, 2);
  Rp(Me, {
    class: "size-4"
  });
  var Ye = L(Me);
  bn(), P(et), P(Pe), P(k), ze((Ce, Oe, ut) => {
    ee($, Ce), de.disabled = r() >= g(A), or(Pe, "data-tip", Oe), Ge = Or(Pe, 1, "", null, Ge, {
      tooltip: s.userDroplets < g(x)
    }), et.disabled = s.userDroplets < g(x) || g(E) || !r(), ee(Ye, ` ${ut??""} `)
  }, [() => s.title(r()), () => Op(), () => g(x).toLocaleString("en-US")]), Oc(Z, r), O(d, k), en()
}
Yn(["click"]);
var rPe = $r('<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>');

function nPe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = rPe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var iPe = $r('<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>');

function qy(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = iPe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var aPe = $r('<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>');

function oPe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = aPe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var sPe = $r('<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>');

function lPe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = sPe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var cPe = se('<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost">âœ•</button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>'),
  uPe = se('<span class="center-absolute absolute"><!></span>'),
  hPe = se('<dialog class="modal" closedby="any"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><h3 class="mb-2 text-lg font-bold"> </h3> <p class="text-sm opacity-80"><!></p> <div class="mt-5 flex justify-end gap-2"><button class="btn btn-ghost"> </button> <button class="btn btn-primary"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function dPe(d, s) {
  Qr(s, !0);
  let r = sr(s, "open", 15),
    x = We(null),
    A = We(Pi({
      name: bv(),
      prev: 1e3,
      new: 1e5
    }));
  const E = {
      id: 70,
      product: Ia.products[70]
    },
    k = {
      id: 80,
      product: Ia.products[80]
    },
    l = {
      product: Ia.products[120]
    };
  let j = We(null),
    W = We(null),
    $ = We("");
  async function J(st) {
    return g(j).showModal(), G(W, H_.withResolvers(), !0), G($, st, !0), g(W).promise
  }
  var ce = hPe(),
    ge = Pt(ce),
    fe = S(ge),
    Z = S(fe);
  {
    var de = st => {
      var lr = cPe(),
        gr = S(lr),
        dr = S(gr),
        pr = S(dr);
      qy(pr, {
        class: "size-8"
      });
      var Ht = L(pr, 2),
        Sr = S(Ht, !0);
      P(Ht);
      var Rr = L(Ht, 2),
        Vt = S(Rr);
      {
        let ar = xt(() => {
          var Ar;
          return ((Ar = Rt.data) == null ? void 0 : Ar.droplets) ?? 0
        });
        f0(Vt, {
          get value() {
            return g(ar)
          }
        })
      }
      P(Rr), bn(2), P(dr), P(gr), Li(gr, () => jTe);
      var Tr = L(gr, 2),
        Xt = S(Tr),
        ue = S(Xt),
        N = S(ue);
      nPe(N, {
        class: "size-5.5",
        filled: !0
      });
      var q = L(N, 2),
        X = S(q, !0);
      P(q), P(ue);
      var te = L(ue, 2),
        le = S(te, !0);
      P(te);
      var xe = L(te, 2),
        je = S(xe);
      {
        const ar = qr => {
          lPe(qr, {
            class: "text-primary size-26"
          })
        };
        let Ar = xt(() => K8());
        s0(je, {
          get productId() {
            return E.id
          },
          title: qr => A0({
            amount: E.product.items[0].amount * qr
          }),
          get subtitle() {
            return g(Ar)
          },
          get unitPrice() {
            return E.product.price
          },
          get userDroplets() {
            return Rt.data.droplets
          },
          onpurchasecompleted: async qr => {
            var Sn, Vr, Le, tt;
            const Gr = (Vr = (Sn = Rt.data) == null ? void 0 : Sn.charges) == null ? void 0 : Vr.max;
            await Rt.refresh();
            const Mr = (tt = (Le = Rt.data) == null ? void 0 : Le.charges) == null ? void 0 : tt.max;
            Gr !== void 0 && Mr !== void 0 && (G(A, {
              name: bv(),
              prev: Gr,
              new: Mr
            }, !0), g(x).show())
          },
          icon: ar,
          $$slots: {
            icon: !0
          }
        })
      }
      var Ie = L(je, 2);
      {
        const ar = qr => {
          Ry(qr, {
            class: "text-primary my-3 size-20"
          })
        };
        let Ar = xt(() => x$());
        s0(Ie, {
          get productId() {
            return k.id
          },
          title: qr => z0({
            amount: k.product.items[0].amount * qr
          }),
          get subtitle() {
            return g(Ar)
          },
          get unitPrice() {
            return k.product.price
          },
          get userDroplets() {
            return Rt.data.droplets
          },
          onpurchasecompleted: async qr => {
            var Mr, Sn, Vr;
            const Gr = (Sn = (Mr = Rt.data) == null ? void 0 : Mr.charges) == null ? void 0 : Sn.count;
            await Rt.refresh(), Gr !== void 0 && (G(A, {
              name: B1(),
              prev: Math.floor(Gr),
              new: Math.floor(Gr + k.product.items[0].amount * qr)
            }, !0), (Vr = g(x)) == null || Vr.show())
          },
          icon: ar,
          $$slots: {
            icon: !0
          }
        })
      }
      P(xe), P(Xt);
      var qe = L(Xt, 2),
        rt = S(qe),
        Xe = S(rt);
      Np(Xe, {
        class: "size-5.5",
        filled: !0
      });
      var he = L(Xe, 2),
        Q = S(he, !0);
      P(he), P(rt);
      var Ze = L(rt, 2),
        vt = S(Ze),
        Qe = S(vt),
        oe = S(Qe),
        De = S(oe),
        Je = S(De);
      _0(Je, {
        get userId() {
          return Rt.data.id
        },
        get level() {
          return Rt.data.level
        },
        get pictureUrl() {
          return Rt.data.picture
        }
      }), P(De), P(oe), P(Qe);
      var Tt = L(Qe, 2),
        Dt = S(Tt, !0);
      P(Tt);
      var _t = L(Tt, 2),
        zt = S(_t, !0);
      P(_t);
      var Yt = L(_t, 2);
      let $e;
      var Ct = S(Yt),
        ir = S(Ct),
        Fr = S(ir);
      Rp(Fr, {
        class: "size-4"
      });
      var br = L(Fr);
      bn(), P(ir), P(Ct), P(Yt), P(vt), P(Ze), P(qe);
      var nt = L(qe, 2),
        cr = S(nt);
      KTe(cr, {
        promptUserConfirmation: J
      }), P(nt), P(Tr), P(lr), ze((ar, Ar, qr, Gr, Mr, Sn, Vr, Le) => {
        ee(Sr, ar), ee(X, Ar), ee(le, qr), ee(Q, Gr), ee(Dt, Mr), ee(zt, Sn), or(Yt, "data-tip", Vr), $e = Or(Yt, 1, "", null, $e, {
          tooltip: Rt.data.droplets < l.product.price
        }), ir.disabled = Rt.data.droplets < l.product.price, ee(br, ` ${Le??""} `)
      }, [() => q0(), () => bL(), () => mA(), () => wG(), () => O1(), () => kw(), () => Op(), () => l.product.price.toLocaleString("en-US")]), oa(2, lr, () => Ka), O(st, lr)
    };
    we(Z, st => {
      Rt.data && r() && st(de)
    })
  }
  P(fe);
  var Fe = L(fe, 2),
    Re = S(Fe),
    Pe = S(Re, !0);
  P(Re), P(Fe), P(ge), Li(ge, () => st => {
    rn(() => {
      r() ? st.show() : st.close()
    })
  });
  var Ge = L(ge, 2),
    et = S(Ge),
    Ve = S(et),
    ve = S(Ve),
    Me = S(ve, !0);
  P(ve);
  var Ye = L(ve, 2),
    Ce = S(Ye),
    Oe = S(Ce),
    ut = L(Oe),
    Ue = S(ut);
  P(ut), P(Ce);
  var Ke = L(Ce, 2),
    St = S(Ke);
  oPe(St, {
    class: "size-5"
  }), P(Ke);
  var Ft = L(Ke, 2),
    Jt = S(Ft, !0);
  P(Ft), P(Ye);
  var Mt = L(Ye, 2),
    ct = S(Mt),
    wt = S(ct),
    ft = L(wt);
  kl(ft, () => g(A).new, st => {
    var lr = uPe(),
      gr = S(lr);
    wm(gr, {}), P(lr), O(st, lr)
  }), P(ct), P(Mt), P(Ve), P(et);
  var $t = L(et, 2),
    Et = S($t),
    Qt = S(Et, !0);
  P(Et), P($t), P(Ge), oo(Ge, st => G(x, st), () => g(x));
  var vr = L(Ge, 2),
    Kt = S(vr),
    Bt = S(Kt),
    it = S(Bt, !0);
  P(Bt);
  var He = L(Bt, 2),
    Ot = S(He);
  Fp(Ot, () => aC({
    country: g($)
  })), P(He);
  var Gt = L(He, 2),
    kt = S(Gt);
  kt.__click = () => {
    var st;
    (st = g(W)) == null || st.resolve(!1), g(j).close()
  };
  var nr = S(kt, !0);
  P(kt);
  var It = L(kt, 2);
  It.__click = () => {
    var st;
    (st = g(W)) == null || st.resolve(!0), g(j).close()
  };
  var mt = S(It, !0);
  P(It), P(Gt), P(Kt);
  var yt = L(Kt, 2),
    bt = S(yt),
    Lt = S(bt, !0);
  P(bt), P(yt), P(vr), oo(vr, st => G(j, st), () => g(j)), ze((st, lr, gr, dr, pr, Ht, Sr) => {
    ee(Pe, st), ee(Me, g(A).name), ee(Oe, `${g(A).prev??""} `), ee(Ue, `(+${g(A).new-g(A).prev})`), ee(Jt, g(A).new), ee(wt, `${lr??""} `), ee(Qt, gr), ee(it, dr), ee(nr, pr), ee(mt, Ht), ee(Lt, Sr)
  }, [() => Ja(), () => Ja(), () => Ja(), () => vC(), () => Nc(), () => S0(), () => Ja()]), Pn("close", ge, () => r(!1)), O(d, ce), en()
}
Yn(["click"]);
var pPe = $r('<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>');

function fPe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = pPe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var _Pe = $r('<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>');

function mPe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = _Pe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var gPe = $r('<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>');

function vPe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = gPe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var yPe = $r('<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>');

function xPe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = yPe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}
var bPe = $r('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>');

function wPe(d, s) {
  let r = Lr(s, ["$$slots", "$$events", "$$legacy"]);
  var x = bPe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), O(d, x)
}

function kPe(d, s, r) {
  return d < s ? s : d > r ? r : d
}

function TPe(d, s) {
  const r = 10 ** s;
  return Math.round(d * r) / r
}
var PPe = se('<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!" class="svelte-1uha8ag"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!" class="svelte-1uha8ag"/> <meta name="robots" content="index, follow, max-image-preview:large" class="svelte-1uha8ag"/> <meta name="color-scheme" content="light only" class="svelte-1uha8ag"/>', 1),
  SPe = se("<button><!></button>"),
  MPe = se('<div class="relative svelte-1uha8ag"><!> <span class="center-absolute absolute text-[10px] text-red-400 svelte-1uha8ag">?</span></div>'),
  IPe = se('<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md svelte-1uha8ag"><!></button>'),
  CPe = se('<button class="btn btn-primary shadow-xl svelte-1uha8ag"> </button>'),
  APe = se('<div class="absolute -left-2 top-0 -translate-x-full translate-y-1/2 select-none svelte-1uha8ag"><!></div>'),
  zPe = se('<div class="relative svelte-1uha8ag"><!> <!></div>'),
  EPe = se('<button class="btn btn-square shadow-md svelte-1uha8ag"><!></button> <button class="btn btn-square relative shadow-md svelte-1uha8ag"><!></button>', 1),
  LPe = se('<button title="Auto painter" class="btn btn-square shadow-md svelte-1uha8ag"><!></button>'),
  DPe = se('<div class="flex flex-col items-center gap-3 svelte-1uha8ag"><!> <button class="btn btn-square relative shadow-md svelte-1uha8ag"><!></button> <button class="btn btn-square shadow-md svelte-1uha8ag"><!></button> <!></div>'),
  RPe = se('<div class="flex flex-col gap-3 svelte-1uha8ag"><button><!></button></div>'),
  jPe = se('<button class="btn btn-sm btn-circle svelte-1uha8ag"><!></button>'),
  FPe = se('<div class="tooltip tooltip-right svelte-1uha8ag"><div class="tooltip-content svelte-1uha8ag">Select Area <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md svelte-1uha8ag">C</kbd></div> <button class="btn btn-sm btn-circle svelte-1uha8ag" title="Select area"><!></button></div>'),
  BPe = se('<button class="btn btn-sm btn-circle svelte-1uha8ag"><!></button>'),
  OPe = se('<button class="btn btn-sm btn-circle not-pwa:hidden svelte-1uha8ag"><!></button>'),
  qPe = se('<div class="btn btn-sm btn-error w-max cursor-auto text-nowrap text-xs sm:text-base svelte-1uha8ag"><!> </div>'),
  NPe = se('<button class="btn sm:btn-lg duration text-nowrap text-xs transition-opacity sm:text-base svelte-1uha8ag"><!> </button>'),
  VPe = se('<span class="svelte-1uha8ag"></span>'),
  UPe = se('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg svelte-1uha8ag"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl svelte-1uha8ag"><!></div></div>'),
  ZPe = se('<div class="absolute bottom-0 left-0 z-50 w-full svelte-1uha8ag"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3 svelte-1uha8ag"><!></div></div>'),
  GPe = se('<div class="pointer-events-none absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-lg sm:-translate-x-1/2 md:max-w-xl svelte-1uha8ag"><!></div>'),
  $Pe = se('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 svelte-1uha8ag"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl svelte-1uha8ag"><div class="px-3 pb-2 pt-1 svelte-1uha8ag"><div class="flex items-center justify-between svelte-1uha8ag"><span class="svelte-1uha8ag"><!> </span> <button class="btn btn-circle btn-sm svelte-1uha8ag"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4 svelte-1uha8ag"><button class="btn btn-primary w-46 svelte-1uha8ag"><!></button></div></div></div></div>'),
  WPe = se('<div><div class="snowflake svelte-1uha8ag"><div class="inner svelte-1uha8ag">â†</div></div> <div class="snowflake svelte-1uha8ag"><div class="inner svelte-1uha8ag">â…</div></div> <div class="snowflake svelte-1uha8ag"><div class="inner svelte-1uha8ag">â„</div></div> <div class="snowflake svelte-1uha8ag"><div class="inner svelte-1uha8ag">â†</div></div> <div class="snowflake svelte-1uha8ag"><div class="inner svelte-1uha8ag">â…</div></div> <div class="snowflake svelte-1uha8ag"><div class="inner svelte-1uha8ag">â„</div></div> <div class="snowflake svelte-1uha8ag"><div class="inner svelte-1uha8ag">â†</div></div> <div class="snowflake svelte-1uha8ag"><div class="inner svelte-1uha8ag">â…</div></div> <div class="snowflake svelte-1uha8ag"><div class="inner svelte-1uha8ag">â…</div></div> <div class="snowflake svelte-1uha8ag"><div class="inner svelte-1uha8ag">â†</div></div> <div class="snowflake svelte-1uha8ag"><div class="inner svelte-1uha8ag">â…</div></div> <div class="snowflake svelte-1uha8ag"><div class="inner svelte-1uha8ag">â†</div></div></div> <div class="disable-pinch-zoom relative h-full overflow-hidden svelte-1uha8ag"><div id="map" class="h-screen w-screen cursor-default svelte-1uha8ag"></div> <div><div><!> <!></div></div> <div><!> <div class="flex flex-col gap-1 max-sm:hidden svelte-1uha8ag"><button class="btn btn-sm btn-circle svelte-1uha8ag">+</button> <button class="btn btn-sm btn-circle svelte-1uha8ag">-</button></div> <!> <!> <!> <button class="btn btn-sm btn-circle text-base svelte-1uha8ag">ğŸ„</button></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>', 1);

function t4e(d, s) {
  Qr(s, !0);
  const r = Kf,
    x = p1,
    A = new ja(x),
    E = r - .4,
    k = lve(xi.url),
    l = k.season ?? vv;
  let j = We(0);
  const W = new Map;
  let $ = We(void 0),
    J = We(14.5),
    ce = We(!1);
  const ge = xt(() => {
    var dt;
    return ((dt = Rt.data) == null ? void 0 : dt.id) === 401
  });
  let fe = We(!1),
    Z = We("select-pixel"),
    de = We(Pi(k.select && k.pos ? {
      name: "pixelSelected",
      latLon: [k.pos.lat, k.pos.lng]
    } : {
      name: "mainMenu"
    }));
  Wi(() => {
    Ge().then(Zt => G($, Zt)).catch(Zt => {
      rr.error(cY(), {
        duration: 5e3
      }), console.error("Error setting up map:", Zt)
    });
    let dt = [0, 0];

    function At(Zt) {
      var gn;
      if (g($) && g(J) > r + 1) {
        const {
          lat: Nr,
          lng: un
        } = g($).unproject([Zt.clientX, Zt.clientY]), Fn = A.latLonToPixels(Nr, un, r), Rn = Math.floor(Fn[0]), Xn = Math.floor(Fn[1]);
        if (dt[0] !== Rn || dt[1] !== Xn) {
          const zr = A.latLonToPixelBoundsLatLon(Nr, un, r),
            mr = dm(zr, !0);
          (gn = g($).getSource(ve)) == null || gn.setCoordinates(mr), dt = [Rn, Xn]
        }
      }
    }
    return window.addEventListener("mousemove", At), () => {
      var Zt;
      (Zt = g($)) == null || Zt.remove(), window.removeEventListener("mousemove", At), Pe && clearInterval(Pe), u_()
    }
  }), fs(() => [$i.theme], () => {
    if (g($)) {
      Re = !1;
      const dt = Fe($i.theme);
      g($).setStyle(dt)
    }
  });

  function Fe(dt) {
    return `https://maps.wplace.live/styles/${dt==="custom-winter"?"liberty":"fiord"}`
  }
  let Re = !1,
    Pe;
  async function Ge() {
    let dt = k.pos ? {
      ...k.pos,
      zoom: g(J)
    } : await Yge();
    k.zoom !== void 0 && (dt.zoom = k.zoom), Qge(dt) || (dt = {
      zoom: dt.zoom,
      ...Z0.tokyo
    });
    const At = await new Promise(Fn => {
        const Rn = new Yu.Map({
          style: Fe($i.theme),
          center: dt,
          zoom: dt.zoom,
          container: "map",
          dragRotate: !1,
          doubleClickZoom: !1,
          pitch: 0,
          maxPitch: 0,
          attributionControl: !1
        });
        Rn.touchZoomRotate.disableRotation(), Rn.on("styledata", Xn => {
          Re || ($i.theme === "custom-winter" && (Rn.setLayoutProperty("poi_transit", "visibility", "none"), Rn.setLayoutProperty("poi_r20", "visibility", "none"), Rn.setLayoutProperty("poi_r7", "visibility", "none"), Rn.setLayoutProperty("poi_r1", "visibility", "none"), Rn.setLayoutProperty("building", "visibility", "none"), Rn.setLayoutProperty("building-3d", "visibility", "none"), Rn.setLayoutProperty("landuse_pitch", "visibility", "none"), Rn.setLayoutProperty("landuse_hospital", "visibility", "none"), Rn.setLayoutProperty("landuse_school", "visibility", "none"), Rn.setLayoutProperty("landuse_residential", "visibility", "none"), Rn.setLayoutProperty("waterway_tunnel", "visibility", "none"), Rn.setFilter("water", ["all", ["!=", "brunnel", "tunnel"],
            ["!=", "class", "swimming_pool"]
          ])), Ve(Rn), Oe(), Re = !0)
        }), Rn.on("style.load", () => {
          Fn(Rn)
        })
      }),
      Zt = Ia.refreshIntervalMs;

    function gn() {
      let Fn = g(J) > r + 1.5 ? Zt : 2.5 * Zt;
      try {
        document.visibilityState === "visible" && Ve(At)
      } finally {
        setTimeout(gn, Fn)
      }
    }
    Pe = setTimeout(gn, Zt), At.on("load", () => {
      k.discordLinked && (rr.success(hM()), xi.url.searchParams.delete("discord-linked"), bp(xi.url.toString())), k.twitchMigration && (rr.success(Lte()), xi.url.searchParams.delete("twitch-migration"), bp(xi.url.toString()))
    });
    let Nr = g(J);
    At.on("zoom", () => {
      G(J, At.getZoom(), !0);
      const Fn = TPe(g(J), 1);
      Fn != Nr && (g(ct) && g(ct).setOpacity(wt(Nr)), Nr = Fn)
    });
    let un = "default";
    return At.on("dragstart", () => {
      const Fn = At.getCanvas();
      un = Fn.style.cursor, Fn.style.cursor = "move"
    }), At.on("dragend", () => {
      At.getCanvas().style.cursor = un
    }), At.on("mouseout", () => {
      ut()
    }), At.on("click", async Fn => {
      var nn;
      const Rn = Fn.lngLat.lat,
        Xn = Fn.lngLat.lng,
        zr = [Rn, Xn];
      if (g(de).name === "paintingPixel" || g(de).name === "selectArea") return;
      if (g(de).name === "selectHq") {
        g(de).hq = zr, (nn = g(ft)) == null || nn.clearAndPlace(zr);
        return
      }
      const mr = At.getZoom();
      if (mr < E) {
        rr.info(Bae());
        return
      }
      Fo({
        lat: Rn,
        lng: Xn
      }, mr), G(de, {
        name: "pixelSelected",
        latLon: zr
      }, !0)
    }), At
  }
  const et = "pixel-art-layer";

  function Ve(dt) {
    const At = window.innerWidth,
      Zt = `${d0}/s${vv}/tiles/{x}/{y}.png`;
    if (W.clear(), !dt.style) return;
    dt.getSource(et) ? dt.refreshTiles(et) : dt.addSource(et, {
      type: "raster",
      tiles: [Zt],
      minzoom: r,
      maxzoom: r,
      tileSize: At > 640 ? 550 : 400
    }), dt.getLayer(et) || dt.addLayer({
      id: et,
      type: "raster",
      source: et,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": g(St)
      }
    })
  }
  const ve = "pixel-hover",
    Me = 1e-5,
    Ye = [
      [0, 0],
      [Me, 0],
      [Me, -Me],
      [0, -Me]
    ],
    Ce = .4;
  async function Oe() {
    var dt, At, Zt, gn;
    if (!((dt = g($)) != null && dt.getSource(ve))) {
      const Nr = uy(await fp(Hge));
      (At = g($)) == null || At.addSource(ve, {
        type: "canvas",
        canvas: Nr,
        coordinates: Ye
      })
    }(Zt = g($)) != null && Zt.getLayer(ve) || (gn = g($)) == null || gn.addLayer({
      id: ve,
      type: "raster",
      source: ve,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": Ce
      }
    })
  }

  function ut() {
    var dt, At;
    (At = (dt = g($)) == null ? void 0 : dt.getSource(ve)) == null || At.setCoordinates(Ye)
  }
  let Ue = We(Pi(k.opaque ?? !0)),
    Ke = We(!0),
    St = xt(() => g(Ke) ? g(Ue) ? 1 : .2 : 0);
  rn(() => {
    var dt;
    (dt = g($)) != null && dt.getLayer(et) && g($).setPaintProperty(et, "raster-opacity", g(St))
  });
  let Ft = We(void 0),
    Jt = We(void 0),
    Mt = We(void 0);
  Wi(() => (navigator.permissions.query({
    name: "geolocation"
  }).then(dt => {
    dt.state === "granted" && G(Mt, navigator.geolocation.watchPosition(At => {
      G(Ft, At)
    }, At => {
      G(Jt, At)
    }, {
      enableHighAccuracy: !1,
      maximumAge: 1e3,
      timeout: 6e3
    }), !0)
  }), () => {
    g(Mt) && navigator.geolocation.clearWatch(g(Mt))
  }));
  let ct = We(void 0);
  fs(() => [g(Ft), g($)], () => {
    var dt, At;
    if (g(Ft) && g($)) {
      const Zt = {
          lat: g(Ft).coords.latitude,
          lng: g(Ft).coords.longitude
        },
        gn = wt(g(J));
      if (!g(ct)) {
        const Nr = document.createElement("div");
        Nr.classList.add("maplibregl-user-location-dot"), Nr.classList.add("cursor-auto"), G(ct, new Yu.Marker({
          element: Nr,
          opacity: gn
        }).setLngLat(Zt).addTo(g($)))
      }(At = (dt = g(ct)) == null ? void 0 : dt.setLngLat(Zt)) == null || At.setOpacity(gn)
    }
  });

  function wt(dt) {
    return dt < r ? "1.0" : kPe((dt - r) * .2, .5, 1).toFixed(2)
  }
  let ft = We(void 0);
  rn(() => {
    var dt;
    g($) && ((dt = ma(() => g(ft))) == null || dt.clear(), fp(zv).then(At => {
      G(ft, new Lv({
        id: "select-crosshair",
        map: g($),
        tileSize: x,
        zoom: r,
        img: At,
        markerFn: () => {
          const Zt = new Yu.Marker({
            color: "#0069ff"
          });
          return Zt.addClassName("z-20"), Zt
        }
      }))
    }))
  });
  let $t = We(void 0);
  rn(() => {
    var dt;
    g($) && ((dt = ma(() => g(ft))) == null || dt.clear(), fp(zv).then(At => {
      G($t, new Lv({
        id: "paint-crosshair",
        map: g($),
        tileSize: x,
        zoom: r,
        img: At
      }))
    }))
  });
  const Et = "christmas-2025-popup";
  rn(() => {
    const dt = localStorage.getItem(Et),
      At = Date.now() > new Date("2025-12-26T00:00:00Z").getTime();
    Rt.data && !dt && !At && (G(le, !0), localStorage.setItem(Et, "true"))
  });
  let Qt = We(!1),
    vr = We(Pi(xi.url)),
    Kt = We(Pi({
      cityId: 0,
      countryId: 1,
      id: 0,
      name: "None",
      number: 1
    })),
    Bt = We(!1);
  rn(() => {
    var dt;
    G(Bt, !!((dt = Rt.data) != null && dt.needsPhoneVerification))
  });
  let it = We([]),
    He = xt(() => g(J) < E ? "1.0" : g(J) < E + 2 ? "0.5" : "0.3");
  rn(() => {
    var At;
    const dt = (At = Rt.data) == null ? void 0 : At.favoriteLocations;
    if (dt && g($)) {
      for (const Zt of ma(() => g(it))) Zt.remove();
      G(it, dt.map(Zt => {
        const gn = document.createElement("div");
        gn.classList.add("text-yellow-400"), gn.classList.add("cursor-pointer"), gn.classList.add("z-10"), gn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`;
        const Nr = {
          lat: Zt.latitude,
          lng: Zt.longitude
        };
        return gn.addEventListener("click", Fn => {
          Fn.stopPropagation(), Ot([Zt.latitude, Zt.longitude])
        }), new Yu.Marker({
          element: gn,
          opacity: g(He)
        }).setLngLat(Nr).addTo(g($))
      }))
    }
  }), rn(() => {
    if (g(je) && g(je).length > 0 && g($)) {
      for (const dt of ma(() => g(Ie))) dt.remove();
      G(Ie, g(je).filter(dt => !(dt != null && dt.claimed)).map(dt => {
        const At = document.createElement("div");
        At.classList.add("cursor-pointer", "z-10"), At.innerHTML = `
		<div style="
		  font-size: 24px;
		  filter: drop-shadow(0 0 4px rgba(0,0,0,0.5));
		">
		  ğŸ
		</div>
	  `;
        const Zt = {
          lat: dt.latitude,
          lng: dt.longitude
        };
        return At.addEventListener("click", Nr => {
          Nr.stopPropagation(), Gt([dt.latitude, dt.longitude], dt.id)
        }), new Yu.Marker({
          element: At,
          opacity: qe
        }).setLngLat(Zt).addTo(g($))
      }))
    }
  });

  function Ot(dt) {
    var Zt;
    const At = {
      lat: dt[0],
      lng: dt[1]
    };
    (Zt = g($)) == null || Zt.flyTo({
      center: At,
      zoom: Math.max(g(J), 15)
    }), Fo(At, g(J)), G(de, {
      name: "pixelSelected",
      latLon: [At.lat, At.lng]
    }, !0)
  }

  function Gt(dt, At) {
    var gn;
    const Zt = {
      lat: dt[0],
      lng: dt[1]
    };
    (gn = g($)) == null || gn.flyTo({
      center: Zt,
      zoom: 11
    }), Fo(Zt, g(J)), G(de, {
      name: "pixelSelected",
      latLon: [Zt.lat, Zt.lng],
      christmasTreeId: At
    }, !0)
  }
  rn(() => {
    const dt = g(de).name === "paintingPixel";
    for (const At of g(it)) dt ? At.addClassName("hidden") : (At.removeClassName("hidden"), At.setOpacity(g(He)));
    for (const At of g(Ie)) dt ? At.addClassName("hidden") : (At.removeClassName("hidden"), At.setOpacity(qe))
  });
  let kt = Number.MAX_VALUE;
  rn(() => {
    if (Rt.charges !== void 0 && Rt.data) {
      const dt = Rt.data.charges.max,
        At = Rt.charges;
      kt < dt && At >= dt && gi.notification1.play(), kt = Rt.charges
    }
  });
  let nr = We(!1),
    It = Date.now();
  Wi(() => {
    const dt = sve(),
      At = () => {
        var gn;
        if (!document.hidden && Date.now() - It > 30 * _l.min) {
          if (dt) {
            const un = (gn = g($)) == null ? void 0 : gn.getCenter();
            un && Fo(un, g(J)), window.location.replace(xi.url.origin)
          } else Rt.refresh();
          It = Date.now()
        }
      };
    return document.addEventListener("visibilitychange", At), () => document.removeEventListener("visibilitychange", At)
  }), Wi(() => {
    function dt() {
      pn.online = !0
    }
    window.addEventListener("online", dt);

    function At() {
      pn.online = !1
    }
    return window.addEventListener("offline", At), () => {
      window.removeEventListener("online", dt), window.removeEventListener("offline", At)
    }
  }), rn(() => {
    if (!pn.online) {
      const dt = setInterval(() => {
        pn.health().then(() => {
          pn.online = !0, !Rt.data && !Rt.loading && Rt.refresh()
        })
      }, 5e3);
      return () => {
        clearInterval(dt)
      }
    }
  }), Wi(() => {
    if (!navigator.serviceWorker) {
      setTimeout(() => {
        console.log("Setting up service worker message listener", navigator.serviceWorker), rr.warning(AJ(), {
          duration: 5e3
        })
      });
      return
    }

    function dt(At) {
      At.data.type && g($) && Ve(g($))
    }
    return navigator.serviceWorker.addEventListener("message", dt), () => {
      navigator.serviceWorker.removeEventListener("message", dt)
    }
  });
  let mt = We(!1),
    yt = We("report-user"),
    bt = We(void 0),
    Lt = We(void 0),
    st = We(void 0),
    lr = We(0),
    gr = We(void 0);
  rn(() => {
    g(mt) || (G(gr, void 0), G(Lt, void 0), G(bt, void 0), G(st, void 0))
  });

  function dr() {
    G(de, {
      name: "mainMenu"
    }, !0), ut()
  }
  let pr = !1,
    Ht = We(!1),
    Sr = We(!1),
    Rr = We(!1),
    Vt = We(!1),
    Tr = We(!1),
    Xt = We(!1),
    ue = We(!!k.newUser),
    N = We(!1),
    q = We(!!k.alliance),
    X = We(!1),
    te = We(!1),
    le = We(!1);
  const xe = xt(() => g(Ht) || g(Sr) || g(Rr) || g(Vt) || g(Tr) || g(Xt) || g(ue) || g(N) || g(q) || g(X));
  let je = We(Pi([])),
    Ie = We([]);
  const qe = "1.0";
  Wi(() => {
    async function dt() {
      try {
        const Zt = await pn.getChristmasLocations();
        G(je, (Zt ?? []).slice(0, 3), !0)
      } catch (Zt) {
        console.error("Error fetching Christmas locations:", Zt)
      }
    }
    dt();
    const At = setInterval(dt, 30 * _l.min);
    return () => {
      clearInterval(At)
    }
  });
  var rt = WPe();
  Pn("keydown", Vs, async dt => {
    if (!g(xe) && !(dt.target instanceof HTMLInputElement || dt.target instanceof HTMLTextAreaElement) && !dt.ctrlKey) switch (dt.code) {
      case "KeyC":
        if (!Rt.hasAnyPermission(Fi.tools.selectArea) || g(de).name === "paintingPixel" || dt.repeat) return;
        dr(), await Y_(), G(de, {
          name: "selectArea"
        }, !0);
        break
    }
  }), t1("1uha8ag", dt => {
    var At = PPe();
    bn(6), c0(() => {
      e1.title = "Wplace - Paint the world"
    }), O(dt, At)
  });
  var Xe = Pt(rt);
  let he;
  var Q = L(Xe, 2);
  {
    const dt = zr => {
        var mr = SPe();
        mr.__click = () => {
          G(Ue, !g(Ue))
        };
        var nn = S(mr);
        {
          let sn = xt(() => !g(Ue));
          jy(nn, {
            class: "size-5",
            get filled() {
              return g(sn)
            }
          })
        }
        P(mr), ze(sn => {
          or(mr, "title", sn), Or(mr, 1, Us({
            "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
            "text-base-content/80": g(Ue),
            "btn-primary btn-soft": !g(Ue)
          }), "svelte-1uha8ag")
        }, [() => N0()]), O(zr, mr)
      },
      At = zr => {
        var mr = IPe();
        mr.__click = async () => {
          var kn;
          g(Ft) || G(Ft, await new Promise((Cn, $n) => {
            navigator.geolocation.getCurrentPosition(bi => {
              Cn(bi)
            }, bi => {
              $n(bi)
            })
          })), g(Ft) && (Fo({
            lat: g(Ft).coords.latitude,
            lng: g(Ft).coords.longitude
          }, g(J)), (kn = g($)) == null || kn.flyTo({
            center: {
              lat: g(Ft).coords.latitude,
              lng: g(Ft).coords.longitude
            },
            zoom: 16.5
          }))
        };
        var nn = S(mr);
        {
          var sn = kn => {
              vPe(kn, {
                class: "size-5.5 fill-blue-800"
              })
            },
            Kn = kn => {
              var Cn = MPe(),
                $n = S(Cn);
              mPe($n, {
                class: "size-5.5 fill-red-400"
              }), bn(2), P(Cn), O(kn, Cn)
            };
          we(nn, kn => {
            g(Ft) ? kn(sn) : kn(Kn, !1)
          })
        }
        P(mr), ze(kn => or(mr, "title", kn), [() => O7()]), O(zr, mr)
      };
    var Ze = L(S(Q), 2);
    let Zt;
    var vt = S(Ze);
    let gn;
    var Qe = S(vt);
    {
      var oe = zr => {
          var mr = CPe();
          mr.__click = () => {
            var sn;
            G(Vt, !0), g($) && Fo((sn = g($)) == null ? void 0 : sn.getCenter(), g(J))
          };
          var nn = S(mr, !0);
          P(mr), ze(sn => ee(nn, sn), [() => gR()]), O(zr, mr)
        },
        De = zr => {
          var mr = Ir(),
            nn = Pt(mr);
          {
            var sn = Kn => {
              var kn = zPe(),
                Cn = S(kn);
              {
                var $n = Nn => {
                  var fn = APe(),
                    _n = S(fn);
                  M0(_n, {
                    get role() {
                      return Rt.data.role
                    }
                  }), P(fn), O(Nn, fn)
                };
                we(Cn, Nn => {
                  var fn;
                  (fn = Rt.data) != null && fn.role && Rt.data.role !== "user" && Nn($n)
                })
              }
              var bi = L(Cn, 2);
              tke(bi, {
                get user() {
                  return Rt
                },
                onlogout: () => {
                  G(de, {
                    name: "mainMenu"
                  }, !0)
                },
                onbanappeal: () => {
                  G(Ht, !0)
                },
                onnotificationclick: () => {
                  G(Sr, !0)
                },
                ontogglepixelarts: Nn => {
                  G(Ke, Nn, !0)
                }
              }), P(kn), oa(3, kn, () => Ka, () => ({
                duration: 150
              })), O(Kn, kn)
            };
            we(nn, Kn => {
              Rt.data && g($) && g(de).name !== "paintingPixel" && Kn(sn)
            }, !0)
          }
          O(zr, mr)
        };
      we(Qe, zr => {
        !Rt.loading && !Rt.data ? zr(oe) : zr(De, !1)
      })
    }
    var Je = L(Qe, 2);
    {
      var Tt = zr => {
          var mr = DPe(),
            nn = S(mr);
          {
            var sn = fn => {
              var _n = EPe(),
                Vn = Pt(_n);
              Vn.__click = () => {
                var dn;
                G(Tr, !0);
                const ln = (dn = g($)) == null ? void 0 : dn.getCenter();
                ln && Fo(ln, g(J))
              };
              var ci = S(Vn);
              qy(ci, {
                class: "size-5"
              }), P(Vn);
              var an = L(Vn, 2);
              an.__click = () => {
                G(q, !0)
              };
              var Si = S(an);
              Vp(Si, {
                class: "size-5"
              }), P(an), ze((ln, dn) => {
                or(Vn, "title", ln), or(an, "title", dn)
              }, [() => q0(), () => Bp()]), O(fn, _n)
            };
            we(nn, fn => {
              Rt.data && fn(sn)
            })
          }
          var Kn = L(nn, 2);
          Kn.__click = () => {
            G(Xt, !0)
          };
          var kn = S(Kn);
          Ey(kn, {
            class: "size-5"
          }), P(Kn);
          var Cn = L(Kn, 2);
          Cn.__click = () => {
            G(Rr, !0)
          };
          var $n = S(Cn);
          wPe($n, {
            class: "size-5"
          }), P(Cn);
          var bi = L(Cn, 2);
          {
            var Nn = fn => {
              var _n = LPe();
              _n.__click = () => {
                g($) && G(de, {
                  name: "adminAutoPaint"
                }, !0)
              };
              var Vn = S(_n);
              Pl(Vn, {
                class: "size-5"
              }), P(_n), O(fn, _n)
            };
            we(bi, fn => {
              Rt.hasPermission(Fi.tools.autoPainter) && fn(Nn)
            })
          }
          P(mr), ze((fn, _n) => {
            or(Kn, "title", fn), or(Cn, "title", _n)
          }, [() => am(), () => x0()]), oa(3, mr, () => Ka, () => ({
            duration: 150
          })), O(zr, mr)
        },
        Dt = zr => {
          var mr = Ir(),
            nn = Pt(mr);
          {
            var sn = Kn => {
              var kn = RPe(),
                Cn = S(kn);
              let $n;
              Cn.__click = () => {
                G(ce, !g(ce))
              };
              var bi = S(Cn);
              {
                var Nn = _n => {
                    G_(_n, {
                      class: "size-5"
                    })
                  },
                  fn = _n => {
                    Cp(_n, {
                      class: "size-5"
                    })
                  };
                we(bi, _n => {
                  g(ce) ? _n(Nn) : _n(fn, !1)
                })
              }
              P(Cn), P(kn), ze(_n => {
                or(Cn, "title", _n), $n = Or(Cn, 1, "btn btn-square not-touchscreen:hidden shadow-md svelte-1uha8ag", null, $n, {
                  "btn-primary": g(ce)
                })
              }, [() => g(ce) ? N1() : iR()]), oa(1, kn, () => Ka, () => ({
                delay: 150,
                duration: 150
              })), O(Kn, kn)
            };
            we(nn, Kn => {
              g($) && g(de).name === "paintingPixel" && Kn(sn)
            }, !0)
          }
          O(zr, mr)
        };
      we(Je, zr => {
        g($) && g(de).name !== "paintingPixel" ? zr(Tt) : zr(Dt, !1)
      })
    }
    P(vt), P(Ze);
    var _t = L(Ze, 2);
    let Nr;
    var zt = S(_t);
    {
      var Yt = zr => {
        var mr = jPe();
        mr.__click = () => {
          G(N, !0)
        };
        var nn = S(mr);
        fPe(nn, {
          class: "size-3.5"
        }), P(mr), ze(sn => or(mr, "title", sn), [() => uE()]), O(zr, mr)
      };
      we(zt, zr => {
        g(de).name !== "paintingPixel" && zr(Yt)
      })
    }
    var $e = L(zt, 2),
      Ct = S($e);
    Ct.__click = () => {
      var zr;
      (zr = g($)) == null || zr.zoomIn()
    };
    var ir = L(Ct, 2);
    ir.__click = () => {
      var zr;
      (zr = g($)) == null || zr.zoomOut()
    }, P($e);
    var Fr = L($e, 2);
    {
      var br = zr => {
        var mr = FPe(),
          nn = L(S(mr), 2);
        nn.__click = () => {
          G(de, {
            name: "selectArea"
          }, !0)
        };
        var sn = S(nn);
        W_(sn, {
          class: "size-4"
        }), P(nn), P(mr), O(zr, mr)
      };
      we(Fr, zr => {
        g(de).name !== "paintingPixel" && Rt.hasAnyPermission(Fi.tools.selectArea) && zr(br)
      })
    }
    var nt = L(Fr, 2);
    {
      var cr = zr => {
        var mr = BPe(),
          nn = S(mr);
        By(nn, {
          class: "size-4",
          onclick: () => {
            G(fe, !g(fe))
          }
        }), P(mr), ze(sn => or(mr, "title", sn), [() => Mz()]), O(zr, mr)
      };
      we(nt, zr => {
        g(ge) && zr(cr)
      })
    }
    var ar = L(nt, 2);
    {
      var Ar = zr => {
        var mr = OPe();
        mr.__click = () => {
          window.location.replace(xi.url.origin)
        };
        var nn = S(mr);
        n2(nn, {
          class: "size-3"
        }), P(mr), ze(sn => or(mr, "title", sn), [() => a2()]), O(zr, mr)
      };
      we(ar, zr => {
        g(de).name !== "paintingPixel" && zr(Ar)
      })
    }
    var qr = L(ar, 2);
    qr.__click = () => {
      G(le, !0)
    }, P(_t);
    var Gr = L(_t, 2);
    let un;
    var Mr = S(Gr);
    {
      var Sn = zr => {
        var mr = qPe(),
          nn = S(mr);
        i2(nn, {
          class: "size-5"
        });
        var sn = L(nn);
        P(mr), ze(Kn => ee(sn, ` ${Kn??""}`), [() => Yq()]), oa(1, mr, () => Ka, () => ({
          duration: 1e3
        })), oa(2, mr, () => Ka), O(zr, mr)
      };
      we(Mr, zr => {
        pn.online || zr(Sn)
      })
    }
    var Vr = L(Mr, 2);
    {
      var Le = zr => {
        var mr = NPe();
        mr.__click = () => {
          var Kn;
          (Kn = g($)) == null || Kn.flyTo({
            center: g($).getCenter(),
            zoom: r
          })
        };
        var nn = S(mr);
        xPe(nn, {
          class: "size-5"
        });
        var sn = L(nn);
        P(mr), ze(Kn => ee(sn, ` ${Kn??""}`), [() => woe()]), oa(3, mr, () => Ka, () => ({
          duration: 300
        })), O(zr, mr)
      };
      we(Vr, zr => {
        g(J) < E && zr(Le)
      })
    }
    P(Gr);
    var tt = L(Gr, 2);
    let Fn;
    var qt = S(tt);
    dt(qt), P(tt);
    var Ut = L(tt, 2);
    let Rn;
    var fr = S(Ut);
    {
      var Wt = zr => {
          {
            let mr = xt(() => g(j) - 96 - 32);
            Dy(zr, {
              class: "z-30",
              get maxWidth() {
                return g(mr)
              },
              onclick: () => {
                var nn;
                (nn = Rt.data) != null && nn.needsPhoneVerification ? (G(Bt, !0), rr.warning(Tv())) : Rt.charges !== void 0 && Rt.charges < 1 ? rr.warning(Cwe, {
                  icon: nh
                }) : g($) && Rt.data ? (gi.smallDropplet.play(), G(de, {
                  name: "paintingPixel"
                }, !0)) : (G(Vt, !0), g($) && Fo(g($).getCenter(), g(J)))
              },
              get disabled() {
                return Rt.loading
              },
              get loading() {
                return Rt.loading
              },
              get charges() {
                return Rt.charges
              }
            })
          }
        },
        yr = zr => {
          var mr = VPe();
          O(zr, mr)
        };
      we(fr, zr => {
        g(de).name === "mainMenu" ? zr(Wt) : zr(yr, !1)
      })
    }
    P(Ut);
    var tn = L(Ut, 2);
    let Xn;
    var Kr = S(tn);
    At(Kr), P(tn);
    var Br = L(tn, 2);
    {
      var Cr = zr => {
        var mr = Ir(),
          nn = Pt(mr);
        {
          var sn = kn => {
              var Cn = UPe(),
                $n = S(Cn),
                bi = S($n);
              RTe(bi, {
                get latLon() {
                  return g(de).latLon
                },
                get map() {
                  return g($)
                },
                get crosshair() {
                  return g(ft)
                },
                get pixelInfoCache() {
                  return W
                },
                get season() {
                  return l
                },
                get tileSize() {
                  return x
                },
                get pixelArtZoom() {
                  return r
                },
                get zoom() {
                  return g(J)
                },
                get opaquePixelArt() {
                  return g(Ue)
                },
                onclose: () => G(de, {
                  name: "mainMenu"
                }, !0),
                onclickshare: Nn => {
                  G(vr, Nn, !0), G(Qt, !0)
                },
                onclickpaint: ([Nn, fn]) => {
                  var Vn, ci, an;
                  if (!Rt.data) {
                    G(Vt, !0);
                    return
                  }
                  if ((Vn = Rt.data) != null && Vn.needsPhoneVerification) {
                    G(Bt, !0), rr.warning(Tv());
                    return
                  }
                  if (Rt.charges !== void 0 && Rt.charges < 1) {
                    rr.warning(Pae());
                    return
                  }
                  const _n = pm(A.latLonToPixelBoundsLatLon(Nn, fn, r));
                  (ci = g($)) == null || ci.flyTo({
                    center: {
                      lat: _n[0],
                      lon: _n[1]
                    }
                  }), G(de, {
                    name: "paintingPixel",
                    clickedLatLon: [Nn, fn]
                  }, !0), (an = g(ft)) == null || an.clear()
                },
                onclickregion: Nn => {
                  G(Kt, Nn, !0), G(X, !0)
                },
                onclickmodaction: (Nn, fn, _n, Vn) => {
                  var Si, ln, dn;
                  (Si = g($)) == null || Si.setZoom(Math.max(g(J), r + 3.5));
                  const ci = A.latLonToPixelBoundsLatLon(_n[0], _n[1], r);
                  if ((ln = g($)) == null || ln.setCenter({
                      lat: ci.min[0],
                      lng: (ci.max[1] + ci.min[1]) / 2
                    }), !(Nn != null && Nn.paintedBy)) {
                    rr.error(wv());
                    return
                  }
                  const an = Nn.paintedBy;
                  G(bt, fn, !0), G(Lt, [{
                    id: an.id,
                    name: an.name,
                    picture: an.picture,
                    allianceId: an.allianceId ?? void 0,
                    allianceName: an.allianceName ?? void 0,
                    timedOut: an.timedOut,
                    banned: an.banned
                  }], !0), G(st, _n, !0), G(lr, ((dn = g($)) == null ? void 0 : dn.getZoom()) ?? 0, !0), G(yt, Vn, !0), G(gr, void 0), G(mt, !0), G(Z, "select-pixel")
                },
                get christmasTreeId() {
                  return g(de).christmasTreeId
                }
              }), P($n), P(Cn), oa(3, $n, () => cp, () => ({
                duration: 100
              })), O(kn, Cn)
            },
            Kn = kn => {
              var Cn = Ir(),
                $n = Pt(Cn);
              {
                var bi = fn => {
                    var _n = ZPe(),
                      Vn = S(_n),
                      ci = S(Vn);
                    F5e(ci, {
                      get map() {
                        return g($)
                      },
                      get clickedLatLon() {
                        return g(de).clickedLatLon
                      },
                      get tileSize() {
                        return x
                      },
                      get tileZoom() {
                        return r
                      },
                      get season() {
                        return l
                      },
                      get zoom() {
                        return g(J)
                      },
                      get crosshair() {
                        return g($t)
                      },
                      refreshPixelArt: () => g($) && Ve(g($)),
                      hidePixelHover: ut,
                      hoverLayerId: ve,
                      onclose: () => {
                        G(de, {
                          name: "mainMenu"
                        }, !0), ut()
                      },
                      get screenLocked() {
                        return g(ce)
                      },
                      set screenLocked(an) {
                        G(ce, an, !0)
                      },
                      get opaquePixelArt() {
                        return g(Ue)
                      },
                      set opaquePixelArt(an) {
                        G(Ue, an, !0)
                      }
                    }), P(Vn), P(_n), oa(3, Vn, () => cp, () => ({
                      duration: 100
                    })), O(fn, _n)
                  },
                  Nn = fn => {
                    var _n = Ir(),
                      Vn = Pt(_n);
                    {
                      var ci = Si => {
                          var ln = GPe(),
                            dn = S(ln);
                          aTe(dn, {
                            get map() {
                              return g($)
                            },
                            get tileSize() {
                              return x
                            },
                            get pixelArtZoom() {
                              return Kf
                            },
                            get season() {
                              return l
                            },
                            get crosshair() {
                              return g($t)
                            },
                            onmodaction: Na => {
                              var va;
                              const {
                                targets: An,
                                image: Bi,
                                latLon: Di,
                                zoom: La,
                                action: Da,
                                onSuccess: ga
                              } = Na;
                              if (!An || An.length === 0) {
                                rr.error(wv());
                                return
                              }
                              G(bt, Bi, !0), G(Lt, An, !0), G(st, Di, !0), G(lr, La ?? ((va = g($)) == null ? void 0 : va.getZoom()) ?? 0, !0), G(yt, Da, !0), G(gr, {
                                onSuccess: ga
                              }, !0), G(mt, !0), G(Z, "select-area")
                            },
                            onclose: dr
                          }), P(ln), O(Si, ln)
                        },
                        an = Si => {
                          var ln = Ir(),
                            dn = Pt(ln);
                          {
                            var Na = Bi => {
                                Dye(Bi, {
                                  get map() {
                                    return g($)
                                  },
                                  get tileSize() {
                                    return x
                                  },
                                  get tileZoom() {
                                    return r
                                  },
                                  get season() {
                                    return l
                                  },
                                  refreshPixelArt: () => g($) && Ve(g($)),
                                  onclose: () => {
                                    G(de, {
                                      name: "mainMenu"
                                    }, !0)
                                  }
                                })
                              },
                              An = Bi => {
                                var Di = Ir(),
                                  La = Pt(Di);
                                {
                                  var Da = ga => {
                                    var va = $Pe(),
                                      to = S(va),
                                      so = S(to),
                                      ii = S(so),
                                      ui = S(ii),
                                      Xi = S(ui);
                                    Fy(Xi, {
                                      class: "inline size-4"
                                    });
                                    var ai = L(Xi);
                                    P(ui);
                                    var ca = L(ui, 2);
                                    ca.__click = () => {
                                      G(de, {
                                        name: "mainMenu"
                                      }, !0)
                                    };
                                    var lo = S(ca);
                                    ms(lo, {
                                      class: "size-4"
                                    }), P(ca), P(ii);
                                    var co = L(ii, 2),
                                      On = S(co);
                                    On.__click = async () => {
                                      var Yi;
                                      if (g(de).name === "selectHq") {
                                        const uo = g(de).hq;
                                        if (uo) try {
                                          G(nr, !0), await pn.updateAllianceHeadquarters(uo[0], uo[1]), (Yi = g(ft)) == null || Yi.clear(), G(q, !0), G(de, {
                                            name: "mainMenu"
                                          }, !0)
                                        } catch (Ml) {
                                          rr.error(Ml.message)
                                        } finally {
                                          G(nr, !1)
                                        }
                                      }
                                    };
                                    var xs = S(On);
                                    Oy(xs, {
                                      class: "size-6"
                                    }), P(On), P(co), P(so), P(to), P(va), ze(Yi => {
                                      ee(ai, ` ${Yi??""}`), On.disabled = g(de).hq === void 0 || g(nr)
                                    }, [() => FX()]), oa(3, to, () => cp, () => ({
                                      duration: 100
                                    })), O(ga, va)
                                  };
                                  we(La, ga => {
                                    g(de).name === "selectHq" && ga(Da)
                                  }, !0)
                                }
                                O(Bi, Di)
                              };
                            we(dn, Bi => {
                              g(de).name === "adminAutoPaint" && g($) ? Bi(Na) : Bi(An, !1)
                            }, !0)
                          }
                          O(Si, ln)
                        };
                      we(Vn, Si => {
                        g(de).name === "selectArea" ? Si(ci) : Si(an, !1)
                      }, !0)
                    }
                    O(fn, _n)
                  };
                we($n, fn => {
                  g(de).name === "paintingPixel" && g($t) ? fn(bi) : fn(Nn, !1)
                }, !0)
              }
              O(kn, Cn)
            };
          we(nn, kn => {
            g(de).name === "pixelSelected" && g(ft) ? kn(sn) : kn(Kn, !1)
          })
        }
        O(zr, mr)
      };
      we(Br, zr => {
        g($) && zr(Cr)
      })
    }
    P(Q), ze((zr, mr) => {
      Zt = Or(Ze, 1, "absolute right-2 top-2 z-30 svelte-1uha8ag", null, Zt, {
        hidden: g(fe)
      }), gn = Or(vt, 1, "flex flex-col gap-4 svelte-1uha8ag", null, gn, {
        "items-end": !Rt.data,
        "items-center": Rt.data
      }), Nr = Or(_t, 1, "absolute left-2 top-2 z-30 flex flex-col gap-3 svelte-1uha8ag", null, Nr, {
        hidden: g(fe)
      }), or(Ct, "title", zr), or(ir, "title", mr), un = Or(Gr, 1, "absolute left-1/2 top-2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2 svelte-1uha8ag", null, un, {
        hidden: g(fe)
      }), Fn = Or(tt, 1, "absolute bottom-3 left-3 z-30 svelte-1uha8ag", null, Fn, {
        hidden: g(fe)
      }), Rn = Or(Ut, 1, "absolute bottom-3 left-1/2 z-30 -translate-x-1/2 svelte-1uha8ag", null, Rn, {
        hidden: g(fe)
      }), Xn = Or(tn, 1, "absolute bottom-3 right-3 z-30 svelte-1uha8ag", null, Xn, {
        hidden: g(fe)
      })
    }, [() => Mv(), () => Iv()])
  }
  var Yr = L(Q, 2);
  Mwe(Yr, {
    get open() {
      return g(Vt)
    },
    set open(dt) {
      G(Vt, dt, !0)
    }
  });
  var Ln = L(Yr, 2);
  dPe(Ln, {
    get open() {
      return g(Tr)
    },
    set open(dt) {
      G(Tr, dt, !0)
    }
  });
  var In = L(Ln, 2);
  Ube(In, {
    get open() {
      return g(ue)
    },
    set open(dt) {
      G(ue, dt, !0)
    }
  });
  var Wr = L(In, 2);
  s1e(Wr, {
    get open() {
      return g(N)
    },
    set open(dt) {
      G(N, dt, !0)
    }
  });
  var jr = L(Wr, 2);
  Twe(jr, {
    onvisitclick: dt => {
      var At;
      (At = g($)) == null || At.flyTo({
        center: dt,
        zoom: Kf + 1
      }), Fo(dt, g(J)), tve.push({
        pos: dt,
        zoom: g(J)
      }), G(Xt, !1)
    },
    get open() {
      return g(Xt)
    },
    set open(dt) {
      G(Xt, dt, !0)
    }
  });
  var wn = L(jr, 2);
  _ke(wn, {
    get region() {
      return g(Kt)
    },
    get open() {
      return g(X)
    },
    set open(dt) {
      G(X, dt, !0)
    }
  });
  var En = L(wn, 2);
  T1(En, {
    get open() {
      return $i.dropletsDialogOpen
    },
    set open(dt) {
      $i.dropletsDialogOpen = dt
    }
  });
  var Mn = L(En, 2);
  _y(Mn, {
    get open() {
      return g(te)
    },
    set open(dt) {
      G(te, dt, !0)
    }
  });
  var qn = L(Mn, 2);
  Fbe(qn, {
    goToLocation: (dt, At) => {
      var gn;
      const Zt = {
        lat: dt,
        lng: At
      };
      (gn = g($)) == null || gn.flyTo({
        center: Zt,
        zoom: 11
      })
    },
    get open() {
      return g(le)
    },
    set open(dt) {
      G(le, dt, !0)
    }
  });
  var Gn = L(qn, 2);
  {
    var Jn = dt => {
      Jxe(dt, {
        onhqchange: () => {
          G(de, {
            name: "selectHq"
          }, !0), G(q, !1)
        },
        onhqclick: At => {
          var Zt;
          (Zt = g($)) == null || Zt.flyTo({
            center: At,
            zoom: Math.max(g(J), 15)
          }), G(de, {
            name: "pixelSelected",
            latLon: [At.lat, At.lng]
          }, !0), G(q, !1)
        },
        onlastpixelclick: At => {
          var Zt;
          (Zt = g($)) == null || Zt.flyTo({
            center: At,
            zoom: Math.max(g(J), 15)
          }), G(de, {
            name: "pixelSelected",
            latLon: [At.lat, At.lng]
          }, !0), G(q, !1)
        },
        get open() {
          return g(q)
        },
        set open(At) {
          G(q, At, !0)
        }
      })
    };
    we(Gn, dt => {
      g($) && dt(Jn)
    })
  }
  var Zn = L(Gn, 2);
  {
    var ri = dt => {
      cbe(dt, {
        get url() {
          return g(vr)
        },
        get map() {
          return g($)
        },
        hideHover: () => {
          var At, Zt;
          (At = g($)) == null || At.setPaintProperty(ve, "raster-opacity", 0), (Zt = g(ft)) == null || Zt.setCanvasOpacity(0)
        },
        showHover: () => {
          var At, Zt;
          (At = g($)) == null || At.setPaintProperty(ve, "raster-opacity", Ce), (Zt = g(ft)) == null || Zt.setCanvasOpacity(1)
        },
        get open() {
          return g(Qt)
        },
        set open(At) {
          G(Qt, At, !0)
        }
      })
    };
    we(Zn, dt => {
      g($) && dt(ri)
    })
  }
  var la = L(Zn, 2);
  {
    var Hi = dt => {
      q1(dt, {
        get image() {
          return g(bt)
        },
        get targets() {
          return g(Lt)
        },
        get latLon() {
          return g(st)
        },
        get zoom() {
          return g(lr)
        },
        get action() {
          return g(yt)
        },
        onsuccess: () => {
          var At, Zt;
          (Zt = (At = g(gr)) == null ? void 0 : At.onSuccess) == null || Zt.call(At)
        },
        get origin() {
          return g(Z)
        },
        get open() {
          return g(mt)
        },
        set open(At) {
          G(mt, At, !0)
        }
      })
    };
    we(la, dt => {
      g(Lt) && g(Lt).length > 0 && g(bt) && g(st) && dt(Hi)
    })
  }
  var Oa = L(la, 2);
  {
    var qa = dt => {
      O5e(dt, {
        get userData() {
          return Rt.data
        },
        get open() {
          return g(Ht)
        },
        set open(At) {
          G(Ht, At, !0)
        }
      })
    };
    we(Oa, dt => {
      Rt.data && dt(qa)
    })
  }
  var Aa = L(Oa, 2);
  Hwe(Aa, {
    get open() {
      return g(Sr)
    },
    set open(dt) {
      G(Sr, dt, !0)
    }
  });
  var za = L(Aa, 2);
  {
    var Ea = dt => {
      Ake(dt, {
        get map() {
          return g($)
        },
        get tileSize() {
          return x
        },
        get season() {
          return l
        },
        get tileZoom() {
          return r
        },
        get open() {
          return g(Rr)
        },
        set open(At) {
          G(Rr, At, !0)
        }
      })
    };
    we(za, dt => {
      g($) && dt(Ea)
    })
  }
  var eo = L(za, 2);
  we(eo, dt => {
    g($)
  }), ze((dt, At) => he = Or(Xe, 1, "snowflakes svelte-1uha8ag", null, he, {
    hidden: !$i.snowflakesEnabled
  }), [() => Mv(), () => Iv()]), Fh("innerWidth", dt => G(j, dt, !0)), O(d, rt), en()
}
Yn(["click"]);
export {
  t4e as component
};