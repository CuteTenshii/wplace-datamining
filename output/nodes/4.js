var Iy = Object.defineProperty;
var ig = w => {
  throw TypeError(w)
};
var My = (w, l, g) => l in w ? Iy(w, l, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: g
}) : w[l] = g;
var lr = (w, l, g) => My(w, typeof l != "symbol" ? l + "" : l, g),
  rf = (w, l, g) => l.has(w) || ig("Cannot " + g);
var Je = (w, l, g) => (rf(w, l, "read from private field"), g ? g.call(w) : l.get(w)),
  xr = (w, l, g) => l.has(w) ? ig("Cannot add the same private member more than once") : l instanceof WeakSet ? l.add(w) : l.set(w, g),
  Qn = (w, l, g, C) => (rf(w, l, "write to private field"), C ? C.call(w, g) : l.set(w, g), g),
  Fr = (w, l, g) => (rf(w, l, "access private method"), g);
import "../chunks/Bzak7iHL.js";
import {
  o as zi,
  s as tn
} from "../chunks/C7jYfUbS.js";
import {
  a3 as Ay,
  b8 as ky,
  bq as Ey,
  ba as zy,
  br as Ly,
  b2 as Dy,
  aI as at,
  g as x,
  aJ as le,
  aH as Ln,
  at as rn,
  p as Dr,
  f as Pe,
  d as k,
  r as A,
  s as V,
  u as lt,
  n as vi,
  t as Xe,
  bj as Pn,
  b as H,
  c as Rr,
  y as Hr,
  v as Cr,
  bo as Tu,
  x as Vf,
  z as Go,
  aK as Kt,
  a as It,
  b4 as On,
  aD as Ry,
  aC as ng,
  aE as By,
  aG as Mg,
  bs as Qa,
  au as ma,
  bt as Ag,
  $ as Fy
} from "../chunks/apxRKl0u.js";
import {
  s as ve
} from "../chunks/B9SWw7yZ.js";
import {
  p as At,
  i as Ue,
  r as Yt,
  s as co,
  u as kg
} from "../chunks/DBMZVJyA.js";
import {
  h as Oy
} from "../chunks/CkjmIARx.js";
import {
  r as es,
  e as Gn,
  a as Or,
  f as Eg,
  b as er,
  s as kr,
  d as cc,
  g as wu,
  c as ao
} from "../chunks/DRcRj3o9.js";
import {
  a as Zo,
  k as Cu,
  t as zn
} from "../chunks/D6N4-wGP.js";
import {
  p as fa
} from "../chunks/BGZkg7dW.js";
import {
  S as $n,
  a as ni,
  t as $r,
  u as Et,
  n as hs,
  g as oa,
  c as Ny,
  C as ag,
  o as sg,
  p as jy,
  q as qy,
  r as Vy
} from "../chunks/DJI8mFfT.js";
import {
  c as zg,
  A as pa,
  a as ff,
  g as nf,
  p as Uy,
  b as Zy
} from "../chunks/DHmwaxXs.js";
import {
  g as Lg,
  b as $y
} from "../chunks/Bn1t281Z.js";
import {
  h as Gy
} from "../chunks/Hn5EJR_y.js";
import {
  b as Ds
} from "../chunks/ClbBIaRv.js";
import {
  L as Hy,
  c as mf,
  D as Dg,
  r as Wy,
  t as Xy,
  b as Ky,
  R as Yy
} from "../chunks/DIjF2uQY.js";
import {
  g as Oe,
  l as Jy
} from "../chunks/C5GsJ62f.js";
import {
  c as Uf
} from "../chunks/CTRYyxGQ.js";
import {
  d as Qy,
  f as $o,
  L as Zf,
  c as ex
} from "../chunks/B1TOg-DH.js";
import {
  e as gn,
  i as Od
} from "../chunks/DwmP27Pv.js";
import {
  c as $f,
  a as Gf,
  b as tx
} from "../chunks/DoCKPXSb.js";
import {
  P as ds,
  t as Rg
} from "../chunks/B1v9VrKg.js";
import {
  p as Hf,
  C as Bg,
  T as Fg,
  G as rx
} from "../chunks/Db6MxE6W.js";
import {
  g as Zn,
  a as Wf,
  c as ix,
  b as nx
} from "../chunks/CcNQQeqn.js";
import {
  A as ax
} from "../chunks/nmzNmNhc.js";
import {
  A as Og,
  d as ec,
  D as Ng,
  a as Nd,
  r as sx,
  f as ox,
  I as og,
  e as lx,
  c as cx,
  P as jg,
  b as ux
} from "../chunks/CGg6QPPf.js";
import {
  f as ea,
  s as af
} from "../chunks/BI5KFv7B.js";
import "../chunks/BkCX6Dhl.js";
import {
  i as qg
} from "../chunks/CyN9FrR7.js";
import {
  L as Vg
} from "../chunks/CqJiU75S.js";
import {
  c as _n
} from "../chunks/BJAxREQj.js";
import {
  L as hx,
  T as Ug,
  a as dx
} from "../chunks/CB1sjDQi.js";
import {
  _ as px
} from "../chunks/Dp1pzeXC.js";
import {
  R as fx
} from "../chunks/aCy5SlN5.js";
import {
  W as mx
} from "../chunks/6WWXPsLi.js";
import {
  r as _x
} from "../chunks/Di9sxCf-.js";
const gx = [];

function vx(w, l = !1, g = !1) {
  return wd(w, new Map, "", gx, null, g)
}

function wd(w, l, g, C, D = null, N = !1) {
  if (typeof w == "object" && w !== null) {
    var T = l.get(w);
    if (T !== void 0) return T;
    if (w instanceof Map) return new Map(w);
    if (w instanceof Set) return new Set(w);
    if (Ay(w)) {
      var o = Array(w.length);
      l.set(w, o), D !== null && l.set(D, o);
      for (var G = 0; G < w.length; G += 1) {
        var W = w[G];
        G in w && (o[G] = wd(W, l, g, C, null, N))
      }
      return o
    }
    if (ky(w) === Ey) {
      o = {}, l.set(w, o), D !== null && l.set(D, o);
      for (var ae in w) o[ae] = wd(w[ae], l, g, C, null, N);
      return o
    }
    if (w instanceof Date) return structuredClone(w);
    if (typeof w.toJSON == "function" && !N) return wd(w.toJSON(), l, g, C, w)
  }
  if (w instanceof EventTarget) return w;
  try {
    return structuredClone(w)
  } catch {
    return w
  }
}

function yx() {
  return Symbol(zy)
}

function jd(w, l) {
  Ly(window, ["resize"], () => Dy(() => l(window[w])))
}
const xx = () => "Log in",
  bx = () => "Entrar",
  wx = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? xx() : bx(),
  Tx = () => "Store",
  Cx = () => "Loja",
  Zg = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Tx() : Cx(),
  Sx = () => "Alliance",
  Px = () => "AlianÃ§a",
  qd = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Sx() : Px(),
  Ix = () => "Leaderboard",
  Mx = () => "Ranking",
  Xf = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Ix() : Mx(),
  Ax = () => "Unlock",
  kx = () => "Destravar",
  Ex = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Ax() : kx(),
  zx = () => "Lock",
  Lx = () => "Travar",
  Dx = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? zx() : Lx(),
  Rx = () => "Info",
  Bx = () => "InformaÃ§Ãµes",
  Fx = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Rx() : Bx(),
  Ox = () => "Zoom in",
  Nx = () => "Aumentar zoom",
  jx = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Ox() : Nx(),
  qx = () => "Zoom out",
  Vx = () => "Diminuir zoom",
  Ux = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? qx() : Vx(),
  Zx = () => "Previous location",
  $x = () => "LocalizaÃ§Ã£o anterior",
  Gx = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Zx() : $x(),
  Hx = () => "Offline",
  Wx = () => "Offline",
  Xx = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Hx() : Wx(),
  Kx = () => "Zoom in to see the pixels",
  Yx = () => "Amplie para ver os pixels",
  Jx = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Kx() : Yx(),
  Qx = () => "Phone verification required",
  e1 = () => "VerificaÃ§Ã£o de telefone necessÃ¡ria",
  lg = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Qx() : e1(),
  t1 = () => "My location",
  r1 = () => "Minha localizaÃ§Ã£o",
  i1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? t1() : r1(),
  n1 = () => "You don't have charges to paint. Wait to recharge.",
  a1 = () => "VocÃª nÃ£o possui tinta para pintar. Aguarde para carrega-las.",
  s1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? n1() : a1(),
  o1 = () => "Map powered by:",
  l1 = () => "Mapa fornecido por:",
  c1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? o1() : l1(),
  u1 = () => "OpenMapTiles Data from",
  h1 = () => "OpenMapTiles com dados do",
  d1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? u1() : h1(),
  p1 = () => "Feedback and bugs",
  f1 = () => "Feedback e bugs",
  m1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? p1() : f1(),
  _1 = () => "Overview",
  g1 = () => "VisÃ£o Geral",
  v1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? _1() : g1(),
  y1 = () => "How to paint faster",
  x1 = () => "Como pintar mais rÃ¡pido",
  b1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? y1() : x1(),
  w1 = () => "When painting, click on the button",
  T1 = () => "Quando pintar clique no botÃ£o",
  C1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? w1() : T1(),
  S1 = () => "on the top right corner of the screen. This will lock the screen but it'll also enable painting by moving your finger over the map.",
  P1 = () => "no canto superior direito da tela. Isso bloquearÃ¡ a tela, mas tambÃ©m permitirÃ¡ pintar movendo o dedo sobre o mapa.",
  I1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? S1() : P1(),
  M1 = () => "Hold",
  A1 = () => "Segure",
  k1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? M1() : A1(),
  E1 = () => "SPACE",
  z1 = () => "EspaÃ§o",
  L1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? E1() : z1(),
  D1 = () => "and move your cursor over the map.",
  R1 = () => "e mova seu cursor sobre o mapa.",
  B1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? D1() : R1(),
  F1 = () => "Explore",
  O1 = () => "Explorar",
  N1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? F1() : O1(),
  j1 = () => "Recharge paint charges",
  q1 = () => "Recarga de tinta",
  V1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? j1() : q1(),
  U1 = () => "Items",
  Z1 = () => "Itens",
  $1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? U1() : Z1(),
  G1 = () => "Get more charges",
  H1 = () => "Recarregue tinta para pintar",
  W1 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? G1() : H1(),
  X1 = w => `+${w.amount} Max. Charges`,
  K1 = w => `+${w.amount} Tinta mÃ¡xima`,
  Y1 = (w, l = {}) => (l.locale ?? Oe()) === "en" ? X1(w) : K1(w),
  J1 = () => "Increase your maximum paint charges capacity",
  Q1 = () => "Aumente sua capacidade mÃ¡xima de tinta",
  eb = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? J1() : Q1(),
  tb = () => "Profile picture",
  rb = () => "Imagem de perfil",
  ib = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? tb() : rb(),
  nb = () => "Add a new 16x16 profile picture",
  ab = () => "Adicionar uma nova imagem de perfil 16x16",
  sb = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? nb() : ab(),
  ob = () => "Not enough droplets",
  lb = () => "Droplets insuficientes",
  Vd = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? ob() : lb(),
  cb = () => "Show profile",
  ub = () => "Exibir perfil",
  hb = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? cb() : ub(),
  db = () => "Menu",
  pb = () => "Menu",
  fb = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? db() : pb(),
  mb = w => `Could not install the app: ${w.error}`,
  _b = w => `NÃ£o pode instalar o app: ${w.error}`,
  gb = (w, l = {}) => (l.locale ?? Oe()) === "en" ? mb(w) : _b(w),
  vb = () => "Install App",
  yb = () => "Instalar App",
  xb = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? vb() : yb(),
  bb = () => "Livestreams",
  wb = () => "Livestreams",
  Tb = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? bb() : wb(),
  Cb = () => "Log Out",
  Sb = () => "Log Out",
  Pb = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Cb() : Sb(),
  Ib = () => "Hide UI",
  Mb = () => "Esconder UI",
  Ab = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Ib() : Mb(),
  kb = () => "Change picture:",
  Eb = () => "Change picture:",
  zb = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? kb() : Eb(),
  Lb = () => "Show last painted pixel on alliance",
  Db = () => "Mostrar Ãºltimo pixel pintado na alianÃ§a",
  Rb = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Lb() : Db(),
  Bb = () => "Delete Account",
  Fb = () => "Deletar Conta",
  cg = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Bb() : Fb(),
  Ob = () => "Save",
  Nb = () => "Salvar",
  jb = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Ob() : Nb(),
  qb = () => "Are you absolutely sure?",
  Vb = () => "VocÃª tem certeza absoluta?",
  Ub = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? qb() : Vb(),
  Zb = () => "This will permanently delete your account and all associated data. This action cannot be undone.",
  $b = () => "Isso excluirÃ¡ permanentemente sua conta e todos os dados associados. Esta aÃ§Ã£o nÃ£o pode ser desfeita.",
  Gb = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Zb() : $b(),
  Hb = () => "Profile",
  Wb = () => "Perfil",
  Xb = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Hb() : Wb(),
  Kb = () => "Display your countryâ€™s flag next to your username. Plus, when painting in regions where you own the corresponding flag, you recover 10% of the charges spent.",
  Yb = () => "Exiba a bandeira do seu paÃ­s ao lado do seu nome de usuÃ¡rio. AlÃ©m disso, ao pintar em regiÃµes onde vocÃª possui a bandeira correspondente, vocÃª recupera 10% das tintas gastas.",
  Jb = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Kb() : Yb(),
  Qb = () => "Does not need to be equipped to provide the bonus",
  e2 = () => "NÃ£o precisa estar equipada para obter o bÃ´nus",
  t2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Qb() : e2(),
  r2 = () => "Equipped",
  i2 = () => "Equipado",
  n2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? r2() : i2(),
  a2 = () => "Equip",
  s2 = () => "Equipar",
  o2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? a2() : s2(),
  l2 = () => "Country",
  c2 = () => "PaÃ­s",
  $g = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? l2() : c2(),
  u2 = () => "No country found.",
  h2 = () => "PaÃ­s nÃ£o encontrado.",
  d2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? u2() : h2(),
  p2 = () => "Welcome to",
  f2 = () => "Bem vindo ao",
  m2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? p2() : f2(),
  _2 = () => "Rules",
  g2 = () => "Regras",
  v2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? _2() : g2(),
  y2 = () => "Important",
  x2 = () => "Importante",
  b2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? y2() : x2(),
  w2 = () => "ðŸš« No inappropriate content (+18, hate speech, inappropriate links, highly suggestive material, ...)",
  T2 = () => "ðŸš« ConteÃºdo inapropriado nÃ£o permitido (+18, discurso de Ã³dio, links inapropriados, conteÃºdo altamente sugestivo, ...)",
  C2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? w2() : T2(),
  S2 = () => "ðŸ˜ˆ Do not paint over other artworks using random colors or patterns just to mess things up",
  P2 = () => "ðŸ˜ˆ NÃ£o desenhe por cima de outras artes usando cores ou padrÃµes aleatÃ³rios sÃ³ para bagunÃ§ar",
  I2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? S2() : P2(),
  M2 = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ Do not paint with more than one account",
  A2 = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ NÃ£o desenhe com mais de uma conta",
  k2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? M2() : A2(),
  E2 = () => "ðŸ¤– Use of bots is not allowed",
  z2 = () => "ðŸ¤– Usar bots nÃ£o Ã© permitido",
  L2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? E2() : z2(),
  D2 = () => "ðŸ™… Disclosing other's personal information is not allowed",
  R2 = () => "ðŸ™… Divulgar informaÃ§Ãµes pessoais dos outros nÃ£o Ã© permitido",
  B2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? D2() : R2(),
  F2 = () => "âœ… Painting over other artworks to complement them or create a new drawing is allowed",
  O2 = () => "âœ… Desenhar sobre outras artes para complementar ou criar novas artes Ã© permitido",
  N2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? F2() : O2(),
  j2 = () => "âœ… Griefing political party flags or portraits of politicians is allowed",
  q2 = () => "âœ… Desenhar sobre bandeiras de partidos e retratos de polÃ­ticos Ã© permitido",
  V2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? j2() : q2(),
  U2 = () => "Violations of these rules may lead to suspension of your account or removal of drawings.",
  Z2 = () => "A violaÃ§Ã£o destas regras pode levar Ã  suspensÃ£o da conta ou Ã  remoÃ§Ã£o de desenhos.",
  $2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? U2() : Z2(),
  G2 = () => "Understood",
  H2 = () => "Entendido",
  W2 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? G2() : H2(),
  X2 = () => "Toggle art opacity",
  K2 = () => "Alterar opacidade",
  Gg = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? X2() : K2(),
  Y2 = () => "Paint",
  J2 = () => "Pintar",
  Hg = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Y2() : J2(),
  Q2 = () => "Select a color",
  ew = () => "Selecione uma color",
  tw = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Q2() : ew(),
  rw = () => "Select a pixel to erase",
  iw = () => "Selecione um pixel para apagar",
  nw = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? rw() : iw(),
  aw = () => "Pick a color from the map",
  sw = () => "Escolha uma cor do mapa",
  ow = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? aw() : sw(),
  lw = () => "Click",
  cw = () => "Clique",
  uw = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? lw() : cw(),
  hw = () => "SPACE",
  dw = () => "ESPAÃ‡O",
  pw = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? hw() : dw(),
  fw = () => "or hold",
  mw = () => "ou segure",
  _w = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? fw() : mw(),
  gw = () => "to paint,",
  vw = () => "para pintar",
  yw = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? gw() : vw(),
  xw = () => "You can paint more than 1 pixel",
  bw = () => "VocÃª pode pintar mais de 1 pixel",
  ww = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? xw() : bw(),
  Tw = () => "Paint pixel",
  Cw = () => "Pintar pixel",
  Sw = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Tw() : Cw(),
  Pw = () => "Color Picker",
  Iw = () => "Conta Gotas",
  Mw = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Pw() : Iw(),
  Aw = () => "+2 max. charge/level",
  kw = () => "+2 tinta mÃ¡xima/level",
  Ew = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Aw() : kw(),
  zw = () => "Name",
  Lw = () => "Nome",
  _f = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? zw() : Lw(),
  Dw = () => "Discord Username",
  Rw = () => "UsuÃ¡rio do Discord",
  Bw = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Dw() : Rw(),
  Fw = () => "Max. Charges",
  Ow = () => "Tinta mÃ¡xima",
  ug = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Fw() : Ow(),
  Nw = () => "Paint Charges",
  jw = () => "Tintas",
  qw = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Nw() : jw(),
  Vw = w => `+${w.amount} Paint Charges`,
  Uw = w => `+${w.amount} Tintas`,
  Zw = (w, l = {}) => (l.locale ?? Oe()) === "en" ? Vw(w) : Uw(w),
  $w = () => "Leave alliance",
  Gw = () => "Sair da alianÃ§a",
  Hw = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? $w() : Gw(),
  Ww = () => "Members",
  Xw = () => "Membros",
  Wg = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Ww() : Xw(),
  Kw = () => "Headquarters",
  Yw = () => "Quartel General",
  Jw = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Kw() : Yw(),
  Qw = () => "Not set",
  e5 = () => "NÃ£o configurado",
  t5 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Qw() : e5(),
  r5 = () => "You are not in an alliance",
  i5 = () => "VocÃª nÃ£o estÃ¡ em uma alianÃ§a",
  n5 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? r5() : i5(),
  a5 = () => "Get invited to an alliance",
  s5 = () => "Seja convidado para uma alianÃ§a",
  o5 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? a5() : s5(),
  l5 = () => "OR",
  c5 = () => "OU",
  u5 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? l5() : c5(),
  h5 = () => "Create an alliance",
  d5 = () => "Crie uma alianÃ§a",
  p5 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? h5() : d5(),
  f5 = () => "Invite link",
  m5 = () => "Link de convite",
  _5 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? f5() : m5(),
  g5 = () => "Send the link below to everybody you want to invite to the alliance",
  v5 = () => "Envie o link abaixo para quem vocÃª deseja convidar para a alianÃ§a",
  y5 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? g5() : v5(),
  x5 = () => "Copied",
  b5 = () => "Copiado",
  Kf = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? x5() : b5(),
  w5 = () => "No description",
  T5 = () => "Sem descriÃ§Ã£o",
  Xg = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? w5() : T5(),
  C5 = () => "Invite",
  S5 = () => "Convite",
  P5 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? C5() : S5(),
  I5 = () => "No pixels painted",
  M5 = () => "Nenhum pixel pintado",
  Yf = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? I5() : M5(),
  A5 = () => "Today",
  k5 = () => "Hoje",
  Ud = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? A5() : k5(),
  E5 = () => "Week",
  z5 = () => "Semana",
  L5 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? E5() : z5(),
  D5 = () => "Month",
  R5 = () => "MÃªs",
  B5 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? D5() : R5(),
  F5 = () => "All time",
  O5 = () => "Geral",
  N5 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? F5() : O5(),
  j5 = () => "this week",
  q5 = () => "nesta semana",
  Jf = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? j5() : q5(),
  V5 = () => "this month",
  U5 = () => "neste mÃªs",
  Qf = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? V5() : U5(),
  Z5 = () => "Player",
  $5 = () => "Jogador",
  em = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Z5() : $5(),
  G5 = () => "Last pixel",
  H5 = () => "Ãšltimo pixel",
  W5 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? G5() : H5(),
  X5 = () => "Create alliance",
  K5 = () => "Criar alianÃ§a",
  Y5 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? X5() : K5(),
  J5 = () => "Alliance Name",
  Q5 = () => "Nome da alianÃ§a",
  eT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? J5() : Q5(),
  tT = () => "Create",
  rT = () => "Criar",
  iT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? tT() : rT(),
  nT = () => "Give admin",
  aT = () => "Tornar admin",
  sT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? nT() : aT(),
  oT = () => "Ban from alliance",
  lT = () => "Banir da alianÃ§a",
  Kg = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? oT() : lT(),
  cT = () => "No action",
  uT = () => "Sem opÃ§Ã£o",
  hT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? cT() : uT(),
  dT = () => "Unban",
  pT = () => "Desbanir",
  fT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? dT() : pT(),
  mT = () => "No banned users",
  _T = () => "Sem usuÃ¡rios banidos",
  gT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? mT() : _T(),
  vT = () => "Update",
  yT = () => "Atualizar",
  xT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? vT() : yT(),
  bT = () => "Error giving admin to user",
  wT = () => "Erro ao tornar usuÃ¡rio admin",
  TT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? bT() : wT(),
  CT = () => "Users",
  ST = () => "UsuÃ¡rios",
  PT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? CT() : ST(),
  IT = () => "Banned",
  MT = () => "Banido",
  AT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? IT() : MT(),
  kT = () => "Regions",
  ET = () => "RegiÃµes",
  zT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? kT() : ET(),
  LT = () => "Countries",
  DT = () => "PaÃ­ses",
  RT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? LT() : DT(),
  BT = () => "Players",
  FT = () => "Jogadores",
  Yg = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? BT() : FT(),
  OT = () => "Alliances",
  NT = () => "AlianÃ§as",
  Jg = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? OT() : NT(),
  jT = () => "Region",
  qT = () => "RegiÃ£o",
  VT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? jT() : qT(),
  UT = () => "Pixels",
  ZT = () => "Pixels",
  Jl = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? UT() : ZT(),
  $T = () => "Painted",
  GT = () => "Pintados",
  Ql = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? $T() : GT(),
  HT = () => "Pixels painted inside the region",
  WT = () => "Pixels pintados dentro da regiÃ£o",
  XT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? HT() : WT(),
  KT = () => "Visit",
  YT = () => "Visitar",
  JT = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? KT() : YT(),
  QT = () => "Not painted",
  e3 = () => "NÃ£o pintado",
  t3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? QT() : e3(),
  r3 = () => "Painted by",
  i3 = () => "Pintado por",
  n3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? r3() : i3(),
  a3 = () => "Limit reached",
  s3 = () => "Limite atingido",
  o3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? a3() : s3(),
  l3 = () => "Favorite",
  c3 = () => "Favoritar",
  u3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? l3() : c3(),
  h3 = () => "Share",
  d3 = () => "Compartilhar",
  p3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? h3() : d3(),
  f3 = () => "Share place",
  m3 = () => "Compartilhar local",
  _3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? f3() : m3(),
  g3 = () => "Mute",
  v3 = () => "Mutar",
  y3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? g3() : v3(),
  x3 = () => "Unmute",
  b3 = () => "Desmutar",
  w3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? x3() : b3(),
  T3 = () => "Select the headquarters location",
  C3 = () => "Selecione a localizaÃ§Ã£o do quartel general",
  S3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? T3() : C3(),
  P3 = () => "Pixels painted inside the country",
  I3 = () => "Pixels pintados dentro do paÃ­s",
  M3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? P3() : I3(),
  A3 = () => "Username copied to clipboard",
  k3 = () => "UsuÃ¡rio copiado",
  E3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? A3() : k3(),
  z3 = () => "No more charges",
  L3 = () => "Acabou a tinta",
  D3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? z3() : L3(),
  R3 = () => "You are not allowed to use multiple accounts. Use your main account to paint.",
  B3 = () => "NÃ£o Ã© permitido usar vÃ¡rias contas. Use sua conta principal para pintar.",
  F3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? R3() : B3(),
  O3 = () => "SMS sent to",
  N3 = () => "SMS enviado para",
  j3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? O3() : N3(),
  q3 = () => "Phone successfully verified",
  V3 = () => "Telefone verificado com sucesso",
  U3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? q3() : V3(),
  Z3 = () => "Not a valid phone number",
  $3 = () => "NÃ£o Ã© um nÃºmero vÃ¡lido",
  G3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Z3() : $3(),
  H3 = () => "Location unfavorited",
  W3 = () => "LocalizaÃ§Ã£o desfavoritada",
  X3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? H3() : W3(),
  K3 = () => "Location favorited",
  Y3 = () => "LocalizaÃ§Ã£o favoritada",
  J3 = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? K3() : Y3(),
  Q3 = () => "Giving admin to user",
  eC = () => "Tornar usuÃ¡rio um admin",
  tC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? Q3() : eC(),
  rC = () => "Profile updated",
  iC = () => "Perfil atualizado",
  nC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? rC() : iC(),
  aC = () => "Account successfully deleted",
  sC = () => "Conta deletada com sucesso",
  oC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? aC() : sC(),
  lC = () => "Logged out",
  cC = () => "Logout feito",
  uC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? lC() : cC(),
  hC = () => "Could not logout. Try refreshing the page.",
  dC = () => "NÃ£o foi possÃ­vel sair da conta. Tente recarregar a pÃ¡gina.",
  pC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? hC() : dC(),
  fC = () => "You need to zoom in to select a pixel",
  mC = () => "DÃª zoom para selecionar um pixel",
  _C = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? fC() : mC(),
  gC = () => "Phone verification",
  vC = () => "VerificaÃ§Ã£o de telefone",
  yC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? gC() : vC(),
  xC = () => "Please verify your phone number to continue playing. This helps us keep bots out and ensure a safe, creative experience for everyone.",
  bC = () => "Por favor, verifique com seu telefone para continuar jogando. Isso nos ajuda a filtrar bots e manter um experiÃªncia segura e criativa para todos.",
  wC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? xC() : bC(),
  TC = () => "Send Code",
  CC = () => "Enviar o cÃ³digo",
  SC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? TC() : CC(),
  PC = () => "Input the code",
  IC = () => "Insira o cÃ³digo",
  MC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? PC() : IC(),
  AC = () => "Sent to",
  kC = () => "Enviar para",
  EC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? AC() : kC(),
  zC = () => "Resend Code",
  LC = () => "Reenviar CÃ³digo",
  DC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? zC() : LC(),
  RC = () => "Try another number",
  BC = () => "Tentar outro nÃºmero",
  FC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? RC() : BC(),
  OC = () => "Edit profile",
  NC = () => "Editar perfil",
  jC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? OC() : NC(),
  qC = () => "Image",
  VC = () => "Imagem",
  UC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? qC() : VC(),
  ZC = () => "Download",
  $C = () => "Download",
  GC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? ZC() : $C(),
  HC = () => "Image copied to clipboard",
  WC = () => "Imagem copiada para a Ã¡rea de transferÃªncia",
  XC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? HC() : WC(),
  KC = () => "My map is lagging",
  YC = () => "Meu mapa estÃ¡ travando",
  JC = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? KC() : YC(),
  QC = () => "Verify if",
  eS = () => "Verifique se",
  tS = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? QC() : eS(),
  rS = () => "Use hardware acceleration when available",
  iS = () => "Usar aceleraÃ§Ã£o grÃ¡fica quando disponÃ­vel",
  nS = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? rS() : iS(),
  aS = () => "is enabled on",
  sS = () => "estÃ¡ habilitado em",
  oS = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? aS() : sS(),
  lS = () => "Follow the instructions to enable hardware acceleration",
  cS = () => "Siga a instruÃ§Ã£o para habilitar a aceleraÃ§Ã£o de hardware",
  uS = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? lS() : cS(),
  hS = () => "Moderation",
  dS = () => "ModeraÃ§Ã£o",
  pS = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? hS() : dS(),
  fS = () => "Terms",
  mS = () => "Termos",
  _S = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? fS() : mS(),
  gS = () => "Privacy",
  vS = () => "Privacidade",
  yS = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? gS() : vS(),
  xS = () => "Clear area",
  bS = () => "Limpar Ã¡rea",
  wS = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? xS() : bS(),
  TS = () => "Select the area's first corner",
  CS = () => "Selecione o primeiro canto da Ã¡rea",
  SS = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? TS() : CS(),
  PS = () => "Select the area's opposite corner",
  IS = () => "Selecione o canto oposto da Ã¡rea",
  MS = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? PS() : IS(),
  AS = () => "Admin",
  kS = () => "AdministraÃ§Ã£o",
  ES = (w = {}, l = {}) => (l.locale ?? Oe()) === "en" ? AS() : kS(),
  ks = 2 * Math.PI * 6378137 / 2;
class uc {
  constructor(l = 256) {
    lr(this, "initialResolution");
    this.tileSize = l, this.initialResolution = 2 * ks / this.tileSize
  }
  latLonToMeters(l, g) {
    const C = g / 180 * ks,
      D = Math.log(Math.tan((90 + l) * Math.PI / 360)) / (Math.PI / 180) * ks / 180;
    return [C, D]
  }
  metersToLatLon(l, g) {
    const C = l / ks * 180;
    let D = g / ks * 180;
    return D = 180 / Math.PI * (2 * Math.atan(Math.exp(D * Math.PI / 180)) - Math.PI / 2), [D, C]
  }
  pixelsToMeters(l, g, C) {
    const D = this.resolution(C),
      N = l * D - ks,
      T = ks - g * D;
    return [N, T]
  }
  pixelsToLatLon(l, g, C) {
    const [D, N] = this.pixelsToMeters(l, g, C);
    return this.metersToLatLon(D, N)
  }
  latLonToPixels(l, g, C) {
    const [D, N] = this.latLonToMeters(l, g);
    return this.metersToPixels(D, N, C)
  }
  latLonToPixelsFloor(l, g, C) {
    const [D, N] = this.latLonToPixels(l, g, C);
    return [Math.floor(D), Math.floor(N)]
  }
  metersToPixels(l, g, C) {
    const D = this.resolution(C),
      N = (l + ks) / D,
      T = (ks - g) / D;
    return [N, T]
  }
  latLonToTile(l, g, C) {
    const [D, N] = this.latLonToMeters(l, g);
    return this.metersToTile(D, N, C)
  }
  metersToTile(l, g, C) {
    const [D, N] = this.metersToPixels(l, g, C);
    return this.pixelsToTile(D, N)
  }
  pixelsToTile(l, g) {
    const C = Math.ceil(l / this.tileSize) - 1,
      D = Math.ceil(g / this.tileSize) - 1;
    return [C, D]
  }
  pixelsToTileLocal(l, g) {
    return {
      tile: this.pixelsToTile(l, g),
      pixel: [Math.floor(l) % this.tileSize, Math.floor(g) % this.tileSize]
    }
  }
  tileBounds(l, g, C) {
    const [D, N] = this.pixelsToMeters(l * this.tileSize, g * this.tileSize, C), [T, o] = this.pixelsToMeters((l + 1) * this.tileSize, (g + 1) * this.tileSize, C);
    return {
      min: [D, N],
      max: [T, o]
    }
  }
  tileBoundsLatLon(l, g, C) {
    const D = this.tileBounds(l, g, C);
    return {
      min: this.metersToLatLon(D.min[0], D.min[1]),
      max: this.metersToLatLon(D.max[0], D.max[1])
    }
  }
  resolution(l) {
    return this.initialResolution / 2 ** l
  }
  latLonToTileAndPixel(l, g, C) {
    const [D, N] = this.latLonToMeters(l, g), [T, o] = this.metersToTile(D, N, C), [G, W] = this.metersToPixels(D, N, C);
    return {
      tile: [T, o],
      pixel: [Math.floor(G) % this.tileSize, Math.floor(W) % this.tileSize]
    }
  }
  pixelBounds(l, g, C) {
    return {
      min: this.pixelsToMeters(l, g, C),
      max: this.pixelsToMeters(l + 1, g + 1, C)
    }
  }
  pixelToBoundsLatLon(l, g, C) {
    const D = this.pixelBounds(l, g, C),
      N = .001885,
      T = (D.max[0] - D.min[0]) * N,
      o = (D.max[1] - D.min[1]) * N;
    return D.min[0] -= T, D.max[0] -= T, D.min[1] -= o, D.max[1] -= o, {
      min: this.metersToLatLon(D.min[0], D.min[1]),
      max: this.metersToLatLon(D.max[0], D.max[1])
    }
  }
  latLonToTileBoundsLatLon(l, g, C) {
    const [D, N] = this.latLonToMeters(l, g), [T, o] = this.metersToTile(D, N, C);
    return this.tileBoundsLatLon(T, o, C)
  }
  latLonToPixelBoundsLatLon(l, g, C) {
    const [D, N] = this.latLonToMeters(l, g), [T, o] = this.metersToPixels(D, N, C);
    return this.pixelToBoundsLatLon(Math.floor(T), Math.floor(o), C)
  }
  latLonToRegionAndPixel(l, g, C, D = $n.regionSize) {
    const [N, T] = this.latLonToPixelsFloor(l, g, C), o = this.tileSize * D;
    return {
      region: [Math.floor(N / o), Math.floor(T / o)],
      pixel: [N % o, T % o]
    }
  }
}

function tm(w, l = !0) {
  const {
    min: g,
    max: C
  } = w;
  return l ? [
    [g[1], C[0]],
    [C[1], C[0]],
    [C[1], g[0]],
    [g[1], g[0]]
  ] : [
    [g[0], C[1]],
    [C[0], C[1]],
    [C[0], g[1]],
    [g[0], g[1]]
  ]
}

function rm(w) {
  return [(w.min[0] + w.max[0]) / 2, (w.min[1] + w.max[1]) / 2]
}
const zS = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==",
  hg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";

function LS(w) {
  return Math.floor(Math.random() * w)
}
const gf = 14.5;
async function DS() {
  const w = FS();
  if (w) return w;
  try {
    if ((await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted") {
      const g = await new Promise((C, D) => navigator.geolocation.getCurrentPosition(N => C(N), N => D(N)));
      return {
        lat: g.coords.latitude,
        lng: g.coords.longitude,
        zoom: gf
      }
    }
  } catch (l) {
    console.error(l)
  }
  return {
    ...RS().pos,
    zoom: gf
  }
}

function RS() {
  const w = Object.entries(BS),
    l = LS(w.length),
    [g, C] = w[l];
  return {
    city: g,
    pos: C
  }
}
const BS = {
    tokyo: {
      lat: 35.677545560719665,
      lng: 139.76394445809638
    },
    paris: {
      lat: 48.8537151734952,
      lng: 2.3484026030630787
    },
    newYork: {
      lat: 40.71283173786517,
      lng: -74.00599771376795
    },
    saoPaulo: {
      lat: -23.550584064565356,
      lng: -46.63339720713918
    },
    sydney: {
      lat: -33.86943325619071,
      lng: 151.2083447239608
    }
  },
  Qg = "location";

function Ja(w, l) {
  localStorage.setItem(Qg, JSON.stringify({
    ...w,
    zoom: l
  }))
}

function FS() {
  const w = localStorage.getItem(Qg);
  if (!w) return;
  const l = JSON.parse(w);
  return l.zoom ?? (l.zoom = gf), l
}
var Mu, Au;
class OS {
  constructor() {
    xr(this, Mu, at(-1));
    xr(this, Au, at([]))
  }
  get idx() {
    return x(Je(this, Mu))
  }
  set idx(l) {
    le(Je(this, Mu), l, !0)
  }
  get entries() {
    return x(Je(this, Au))
  }
  set entries(l) {
    le(Je(this, Au), l)
  }
  hasNext() {
    return this.idx < this.entries.length - 1
  }
  goToNext(l) {
    const g = this.idx + 1,
      C = this.entries[g];
    C && (this.idx = g, l.flyTo({
      center: C.pos,
      zoom: C.zoom
    }))
  }
  hasPrev() {
    return this.idx > 0
  }
  goToPrev(l) {
    const g = this.idx - 1,
      C = this.entries[g];
    C && (this.idx = g, l.flyTo({
      center: C.pos,
      zoom: C.zoom
    }))
  }
  isEmpty() {
    return this.entries.length === 0
  }
  push(l) {
    this.idx = this.idx + 1, this.entries = [...this.entries.slice(0, this.idx), l]
  }
}
Mu = new WeakMap, Au = new WeakMap;
const Ho = new OS;

function im(w) {
  return w && w.__esModule && Object.prototype.hasOwnProperty.call(w, "default") ? w.default : w
}
var Td = {
  exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.6.2/LICENSE.txt
 */
var NS = Td.exports,
  dg;

function jS() {
  return dg || (dg = 1, (function(w, l) {
    (function(g, C) {
      w.exports = C()
    })(NS, (function() {
      var g = {},
        C = {};

      function D(T, o, G) {
        if (C[T] = G, T === "index") {
          var W = "var sharedModule = {}; (" + C.shared + ")(sharedModule); (" + C.worker + ")(sharedModule);",
            ae = {};
          return C.shared(ae), C.index(g, ae), typeof window < "u" && g.setWorkerUrl(window.URL.createObjectURL(new Blob([W], {
            type: "text/javascript"
          }))), g
        }
      }
      D("shared", ["exports"], (function(T) {
        function o(i, t, r, a) {
          return new(r || (r = Promise))((function(c, p) {
            function f(S) {
              try {
                v(a.next(S))
              } catch (I) {
                p(I)
              }
            }

            function _(S) {
              try {
                v(a.throw(S))
              } catch (I) {
                p(I)
              }
            }

            function v(S) {
              var I;
              S.done ? c(S.value) : (I = S.value, I instanceof r ? I : new r((function(E) {
                E(I)
              }))).then(f, _)
            }
            v((a = a.apply(i, t || [])).next())
          }))
        }

        function G(i, t) {
          this.x = i, this.y = t
        }

        function W(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
        }
        var ae, _e;
        typeof SuppressedError == "function" && SuppressedError, G.prototype = {
          clone() {
            return new G(this.x, this.y)
          },
          add(i) {
            return this.clone()._add(i)
          },
          sub(i) {
            return this.clone()._sub(i)
          },
          multByPoint(i) {
            return this.clone()._multByPoint(i)
          },
          divByPoint(i) {
            return this.clone()._divByPoint(i)
          },
          mult(i) {
            return this.clone()._mult(i)
          },
          div(i) {
            return this.clone()._div(i)
          },
          rotate(i) {
            return this.clone()._rotate(i)
          },
          rotateAround(i, t) {
            return this.clone()._rotateAround(i, t)
          },
          matMult(i) {
            return this.clone()._matMult(i)
          },
          unit() {
            return this.clone()._unit()
          },
          perp() {
            return this.clone()._perp()
          },
          round() {
            return this.clone()._round()
          },
          mag() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
          },
          equals(i) {
            return this.x === i.x && this.y === i.y
          },
          dist(i) {
            return Math.sqrt(this.distSqr(i))
          },
          distSqr(i) {
            const t = i.x - this.x,
              r = i.y - this.y;
            return t * t + r * r
          },
          angle() {
            return Math.atan2(this.y, this.x)
          },
          angleTo(i) {
            return Math.atan2(this.y - i.y, this.x - i.x)
          },
          angleWith(i) {
            return this.angleWithSep(i.x, i.y)
          },
          angleWithSep(i, t) {
            return Math.atan2(this.x * t - this.y * i, this.x * i + this.y * t)
          },
          _matMult(i) {
            const t = i[2] * this.x + i[3] * this.y;
            return this.x = i[0] * this.x + i[1] * this.y, this.y = t, this
          },
          _add(i) {
            return this.x += i.x, this.y += i.y, this
          },
          _sub(i) {
            return this.x -= i.x, this.y -= i.y, this
          },
          _mult(i) {
            return this.x *= i, this.y *= i, this
          },
          _div(i) {
            return this.x /= i, this.y /= i, this
          },
          _multByPoint(i) {
            return this.x *= i.x, this.y *= i.y, this
          },
          _divByPoint(i) {
            return this.x /= i.x, this.y /= i.y, this
          },
          _unit() {
            return this._div(this.mag()), this
          },
          _perp() {
            const i = this.y;
            return this.y = this.x, this.x = -i, this
          },
          _rotate(i) {
            const t = Math.cos(i),
              r = Math.sin(i),
              a = r * this.x + t * this.y;
            return this.x = t * this.x - r * this.y, this.y = a, this
          },
          _rotateAround(i, t) {
            const r = Math.cos(i),
              a = Math.sin(i),
              c = t.y + a * (this.x - t.x) + r * (this.y - t.y);
            return this.x = t.x + r * (this.x - t.x) - a * (this.y - t.y), this.y = c, this
          },
          _round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
          },
          constructor: G
        }, G.convert = function(i) {
          if (i instanceof G) return i;
          if (Array.isArray(i)) return new G(+i[0], +i[1]);
          if (i.x !== void 0 && i.y !== void 0) return new G(+i.x, +i.y);
          throw new Error("Expected [x, y] or {x, y} point format")
        };
        var xe = (function() {
            if (_e) return ae;

            function i(t, r, a, c) {
              this.cx = 3 * t, this.bx = 3 * (a - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (c - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = a, this.p2y = c
            }
            return _e = 1, ae = i, i.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var a = t, c = 0; c < 8; c++) {
                  var p = this.sampleCurveX(a) - t;
                  if (Math.abs(p) < r) return a;
                  var f = this.sampleCurveDerivativeX(a);
                  if (Math.abs(f) < 1e-6) break;
                  a -= p / f
                }
                var _ = 0,
                  v = 1;
                for (a = t, c = 0; c < 20 && (p = this.sampleCurveX(a), !(Math.abs(p - t) < r)); c++) t > p ? _ = a : v = a, a = .5 * (v - _) + _;
                return a
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, ae
          })(),
          K = W(xe);
        let Ie, Ce;

        function De() {
          return Ie == null && (Ie = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), Ie
        }

        function Be() {
          if (Ce == null && (Ce = !1, De())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", {
              willReadFrequently: !0
            });
            if (t) {
              for (let a = 0; a < 25; a++) {
                const c = 4 * a;
                t.fillStyle = `rgb(${c},${c+1},${c+2})`, t.fillRect(a % 5, Math.floor(a / 5), 1, 1)
              }
              const r = t.getImageData(0, 0, 5, 5).data;
              for (let a = 0; a < 100; a++)
                if (a % 4 != 3 && r[a] !== a) {
                  Ce = !0;
                  break
                }
            }
          }
          return Ce || !1
        }
        var je = 1e-6,
          Le = typeof Float32Array < "u" ? Float32Array : Array;

        function Fe() {
          var i = new Le(9);
          return Le != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[5] = 0, i[6] = 0, i[7] = 0), i[0] = 1, i[4] = 1, i[8] = 1, i
        }

        function mt(i) {
          return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
        }

        function ut() {
          var i = new Le(3);
          return Le != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i
        }

        function Ke(i) {
          return Math.hypot(i[0], i[1], i[2])
        }

        function ct(i, t, r) {
          var a = new Le(3);
          return a[0] = i, a[1] = t, a[2] = r, a
        }

        function tt(i, t, r) {
          return i[0] = t[0] + r[0], i[1] = t[1] + r[1], i[2] = t[2] + r[2], i
        }

        function Re(i, t, r) {
          return i[0] = t[0] * r, i[1] = t[1] * r, i[2] = t[2] * r, i
        }

        function ot(i, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2],
            f = r[0],
            _ = r[1],
            v = r[2];
          return i[0] = c * v - p * _, i[1] = p * f - a * v, i[2] = a * _ - c * f, i
        }
        Math.hypot || (Math.hypot = function() {
          for (var i = 0, t = arguments.length; t--;) i += arguments[t] * arguments[t];
          return Math.sqrt(i)
        });
        var rt, Qe = Ke;

        function Ae(i, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2],
            f = t[3];
          return i[0] = r[0] * a + r[4] * c + r[8] * p + r[12] * f, i[1] = r[1] * a + r[5] * c + r[9] * p + r[13] * f, i[2] = r[2] * a + r[6] * c + r[10] * p + r[14] * f, i[3] = r[3] * a + r[7] * c + r[11] * p + r[15] * f, i
        }

        function gt() {
          var i = new Le(4);
          return Le != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i[3] = 1, i
        }

        function ee(i, t, r, a) {
          var c = .5 * Math.PI / 180;
          t *= c, r *= c, a *= c;
          var p = Math.sin(t),
            f = Math.cos(t),
            _ = Math.sin(r),
            v = Math.cos(r),
            S = Math.sin(a),
            I = Math.cos(a);
          return i[0] = p * v * I - f * _ * S, i[1] = f * _ * I + p * v * S, i[2] = f * v * S - p * _ * I, i[3] = f * v * I + p * _ * S, i
        }

        function te() {
          var i = new Le(2);
          return Le != Float32Array && (i[0] = 0, i[1] = 0), i
        }

        function fe(i, t) {
          var r = new Le(2);
          return r[0] = i, r[1] = t, r
        }
        ut(), rt = new Le(4), Le != Float32Array && (rt[0] = 0, rt[1] = 0, rt[2] = 0, rt[3] = 0), ut(), ct(1, 0, 0), ct(0, 1, 0), gt(), gt(), Fe(), te();
        const ie = 8192;

        function Se(i, t, r) {
          return t * (ie / (i.tileSize * Math.pow(2, r - i.tileID.overscaledZ)))
        }

        function Me(i, t) {
          return (i % t + t) % t
        }

        function nt(i, t, r) {
          return i * (1 - r) + t * r
        }

        function Ye(i) {
          if (i <= 0) return 0;
          if (i >= 1) return 1;
          const t = i * i,
            r = t * i;
          return 4 * (i < .5 ? r : 3 * (i - t) + r - .75)
        }

        function wt(i, t, r, a) {
          const c = new K(i, t, r, a);
          return p => c.solve(p)
        }
        const zt = wt(.25, .1, .25, 1);

        function Nt(i, t, r) {
          return Math.min(r, Math.max(t, i))
        }

        function st(i, t, r) {
          const a = r - t,
            c = ((i - t) % a + a) % a + t;
          return c === t ? r : c
        }

        function Tt(i, ...t) {
          for (const r of t)
            for (const a in r) i[a] = r[a];
          return i
        }
        let Ct = 1;

        function yt(i, t, r) {
          const a = {};
          for (const c in i) a[c] = t.call(this, i[c], c, i);
          return a
        }

        function Mt(i, t, r) {
          const a = {};
          for (const c in i) t.call(this, i[c], c, i) && (a[c] = i[c]);
          return a
        }

        function St(i) {
          return Array.isArray(i) ? i.map(St) : typeof i == "object" && i ? yt(i, St) : i
        }
        const ht = {};

        function Lt(i) {
          ht[i] || (typeof console < "u" && console.warn(i), ht[i] = !0)
        }

        function tr(i, t, r) {
          return (r.y - i.y) * (t.x - i.x) > (t.y - i.y) * (r.x - i.x)
        }

        function Jt(i) {
          return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope
        }
        let dr = null;

        function nr(i) {
          return typeof ImageBitmap < "u" && i instanceof ImageBitmap
        }
        const Bt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";

        function pr(i, t, r, a, c) {
          return o(this, void 0, void 0, (function*() {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const p = new VideoFrame(i, {
              timestamp: 0
            });
            try {
              const f = p == null ? void 0 : p.format;
              if (!f || !f.startsWith("BGR") && !f.startsWith("RGB")) throw new Error(`Unrecognized format ${f}`);
              const _ = f.startsWith("BGR"),
                v = new Uint8ClampedArray(a * c * 4);
              if (yield p.copyTo(v, (function(S, I, E, R, O) {
                  const j = 4 * Math.max(-I, 0),
                    Z = (Math.max(0, E) - E) * R * 4 + j,
                    Y = 4 * R,
                    ne = Math.max(0, I),
                    ke = Math.max(0, E);
                  return {
                    rect: {
                      x: ne,
                      y: ke,
                      width: Math.min(S.width, I + R) - ne,
                      height: Math.min(S.height, E + O) - ke
                    },
                    layout: [{
                      offset: Z,
                      stride: Y
                    }]
                  }
                })(i, t, r, a, c)), _)
                for (let S = 0; S < v.length; S += 4) {
                  const I = v[S];
                  v[S] = v[S + 2], v[S + 2] = I
                }
              return v
            } finally {
              p.close()
            }
          }))
        }
        let gr, Sr;

        function Vr(i, t, r, a) {
          return i.addEventListener(t, r, a), {
            unsubscribe: () => {
              i.removeEventListener(t, r, a)
            }
          }
        }

        function ur(i) {
          return i * Math.PI / 180
        }

        function Pr(i) {
          return i / Math.PI * 180
        }
        const Ir = {
            touchstart: !0,
            touchmove: !0,
            touchmoveWindow: !0,
            touchend: !0,
            touchcancel: !0
          },
          Mr = {
            dblclick: !0,
            click: !0,
            mouseover: !0,
            mouseout: !0,
            mousedown: !0,
            mousemove: !0,
            mousemoveWindow: !0,
            mouseup: !0,
            mouseupWindow: !0,
            contextmenu: !0,
            wheel: !0
          },
          Nr = "AbortError";

        function ce() {
          return new Error(Nr)
        }
        const F = {
          MAX_PARALLEL_IMAGE_REQUESTS: 16,
          MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
          MAX_TILE_CACHE_ZOOM_LEVELS: 5,
          REGISTERED_PROTOCOLS: {},
          WORKER_URL: ""
        };

        function q(i) {
          return F.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))]
        }
        const $ = "global-dispatcher";
        class X extends Error {
          constructor(t, r, a, c) {
            super(`AJAXError: ${r} (${t}): ${a}`), this.status = t, this.statusText = r, this.url = a, this.body = c
          }
        }
        const oe = () => Jt(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href,
          me = function(i, t) {
            if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
              const a = q(i.url);
              if (a) return a(i, t);
              if (Jt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: i,
                targetMapId: $
              }, t)
            }
            if (!(/^file:/.test(r = i.url) || /^file:/.test(oe()) && !/^\w+:/.test(r))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(a, c) {
                return o(this, void 0, void 0, (function*() {
                  const p = new Request(a.url, {
                    method: a.method || "GET",
                    body: a.body,
                    credentials: a.credentials,
                    headers: a.headers,
                    cache: a.cache,
                    referrer: oe(),
                    signal: c.signal
                  });
                  let f, _;
                  a.type !== "json" || p.headers.has("Accept") || p.headers.set("Accept", "application/json");
                  try {
                    f = yield fetch(p)
                  } catch (S) {
                    throw new X(0, S.message, a.url, new Blob)
                  }
                  if (!f.ok) {
                    const S = yield f.blob();
                    throw new X(f.status, f.statusText, a.url, S)
                  }
                  _ = a.type === "arrayBuffer" || a.type === "image" ? f.arrayBuffer() : a.type === "json" ? f.json() : f.text();
                  const v = yield _;
                  if (c.signal.aborted) throw ce();
                  return {
                    data: v,
                    cacheControl: f.headers.get("Cache-Control"),
                    expires: f.headers.get("Expires")
                  }
                }))
              })(i, t);
              if (Jt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: i,
                mustQueue: !0,
                targetMapId: $
              }, t)
            }
            var r;
            return (function(a, c) {
              return new Promise(((p, f) => {
                var _;
                const v = new XMLHttpRequest;
                v.open(a.method || "GET", a.url, !0), a.type !== "arrayBuffer" && a.type !== "image" || (v.responseType = "arraybuffer");
                for (const S in a.headers) v.setRequestHeader(S, a.headers[S]);
                a.type === "json" && (v.responseType = "text", !((_ = a.headers) === null || _ === void 0) && _.Accept || v.setRequestHeader("Accept", "application/json")), v.withCredentials = a.credentials === "include", v.onerror = () => {
                  f(new Error(v.statusText))
                }, v.onload = () => {
                  if (!c.signal.aborted)
                    if ((v.status >= 200 && v.status < 300 || v.status === 0) && v.response !== null) {
                      let S = v.response;
                      if (a.type === "json") try {
                        S = JSON.parse(v.response)
                      } catch (I) {
                        return void f(I)
                      }
                      p({
                        data: S,
                        cacheControl: v.getResponseHeader("Cache-Control"),
                        expires: v.getResponseHeader("Expires")
                      })
                    } else {
                      const S = new Blob([v.response], {
                        type: v.getResponseHeader("Content-Type")
                      });
                      f(new X(v.status, v.statusText, a.url, S))
                    }
                }, c.signal.addEventListener("abort", (() => {
                  v.abort(), f(ce())
                })), v.send(a.body)
              }))
            })(i, t)
          };

        function Ee(i) {
          if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
          const t = new URL(i),
            r = window.location;
          return t.protocol === r.protocol && t.host === r.host
        }

        function Te(i, t, r) {
          r[i] && r[i].indexOf(t) !== -1 || (r[i] = r[i] || [], r[i].push(t))
        }

        function Ze(i, t, r) {
          if (r && r[i]) {
            const a = r[i].indexOf(t);
            a !== -1 && r[i].splice(a, 1)
          }
        }
        class it {
          constructor(t, r = {}) {
            Tt(this, r), this.type = t
          }
        }
        class $e extends it {
          constructor(t, r = {}) {
            super("error", Tt({
              error: t
            }, r))
          }
        }
        class kt {
          on(t, r) {
            return this._listeners = this._listeners || {}, Te(t, r, this._listeners), {
              unsubscribe: () => {
                this.off(t, r)
              }
            }
          }
          off(t, r) {
            return Ze(t, r, this._listeners), Ze(t, r, this._oneTimeListeners), this
          }
          once(t, r) {
            return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, Te(t, r, this._oneTimeListeners), this) : new Promise((a => this.once(t, a)))
          }
          fire(t, r) {
            typeof t == "string" && (t = new it(t, r || {}));
            const a = t.type;
            if (this.listens(a)) {
              t.target = this;
              const c = this._listeners && this._listeners[a] ? this._listeners[a].slice() : [];
              for (const _ of c) _.call(this, t);
              const p = this._oneTimeListeners && this._oneTimeListeners[a] ? this._oneTimeListeners[a].slice() : [];
              for (const _ of p) Ze(a, _, this._oneTimeListeners), _.call(this, t);
              const f = this._eventedParent;
              f && (Tt(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), f.fire(t))
            } else t instanceof $e && console.error(t.error);
            return this
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
          }
          setEventedParent(t, r) {
            return this._eventedParent = t, this._eventedParentData = r, this
          }
        }
        var ye = {
          $version: 8,
          $root: {
            version: {
              required: !0,
              type: "enum",
              values: [8]
            },
            name: {
              type: "string"
            },
            metadata: {
              type: "*"
            },
            center: {
              type: "array",
              value: "number"
            },
            centerAltitude: {
              type: "number"
            },
            zoom: {
              type: "number"
            },
            bearing: {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees"
            },
            pitch: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            roll: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            state: {
              type: "state",
              default: {}
            },
            light: {
              type: "light"
            },
            sky: {
              type: "sky"
            },
            projection: {
              type: "projection"
            },
            terrain: {
              type: "terrain"
            },
            sources: {
              required: !0,
              type: "sources"
            },
            sprite: {
              type: "sprite"
            },
            glyphs: {
              type: "string"
            },
            transition: {
              type: "transition"
            },
            layers: {
              required: !0,
              type: "array",
              value: "layer"
            }
          },
          sources: {
            "*": {
              type: "source"
            }
          },
          source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
          source_vector: {
            type: {
              required: !0,
              type: "enum",
              values: {
                vector: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            attribution: {
              type: "string"
            },
            promoteId: {
              type: "promoteId"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster: {
            type: {
              required: !0,
              type: "enum",
              values: {
                raster: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            attribution: {
              type: "string"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster_dem: {
            type: {
              required: !0,
              type: "enum",
              values: {
                "raster-dem": {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            attribution: {
              type: "string"
            },
            encoding: {
              type: "enum",
              values: {
                terrarium: {},
                mapbox: {},
                custom: {}
              },
              default: "mapbox"
            },
            redFactor: {
              type: "number",
              default: 1
            },
            blueFactor: {
              type: "number",
              default: 1
            },
            greenFactor: {
              type: "number",
              default: 1
            },
            baseShift: {
              type: "number",
              default: 0
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_geojson: {
            type: {
              required: !0,
              type: "enum",
              values: {
                geojson: {}
              }
            },
            data: {
              required: !0,
              type: "*"
            },
            maxzoom: {
              type: "number",
              default: 18
            },
            attribution: {
              type: "string"
            },
            buffer: {
              type: "number",
              default: 128,
              maximum: 512,
              minimum: 0
            },
            filter: {
              type: "*"
            },
            tolerance: {
              type: "number",
              default: .375
            },
            cluster: {
              type: "boolean",
              default: !1
            },
            clusterRadius: {
              type: "number",
              default: 50,
              minimum: 0
            },
            clusterMaxZoom: {
              type: "number"
            },
            clusterMinPoints: {
              type: "number"
            },
            clusterProperties: {
              type: "*"
            },
            lineMetrics: {
              type: "boolean",
              default: !1
            },
            generateId: {
              type: "boolean",
              default: !1
            },
            promoteId: {
              type: "promoteId"
            }
          },
          source_video: {
            type: {
              required: !0,
              type: "enum",
              values: {
                video: {}
              }
            },
            urls: {
              required: !0,
              type: "array",
              value: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          source_image: {
            type: {
              required: !0,
              type: "enum",
              values: {
                image: {}
              }
            },
            url: {
              required: !0,
              type: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          layer: {
            id: {
              type: "string",
              required: !0
            },
            type: {
              type: "enum",
              values: {
                fill: {},
                line: {},
                symbol: {},
                circle: {},
                heatmap: {},
                "fill-extrusion": {},
                raster: {},
                hillshade: {},
                "color-relief": {},
                background: {}
              },
              required: !0
            },
            metadata: {
              type: "*"
            },
            source: {
              type: "string"
            },
            "source-layer": {
              type: "string"
            },
            minzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            maxzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            filter: {
              type: "filter"
            },
            layout: {
              type: "layout"
            },
            paint: {
              type: "paint"
            }
          },
          layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
          layout_background: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_fill: {
            "fill-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_circle: {
            "circle-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_heatmap: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_fill-extrusion": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_line: {
            "line-cap": {
              type: "enum",
              values: {
                butt: {},
                round: {},
                square: {}
              },
              default: "butt",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-join": {
              type: "enum",
              values: {
                bevel: {},
                round: {},
                miter: {}
              },
              default: "miter",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "line-miter-limit": {
              type: "number",
              default: 2,
              requires: [{
                "line-join": "miter"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-round-limit": {
              type: "number",
              default: 1.05,
              requires: [{
                "line-join": "round"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_symbol: {
            "symbol-placement": {
              type: "enum",
              values: {
                point: {},
                line: {},
                "line-center": {}
              },
              default: "point",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-spacing": {
              type: "number",
              default: 250,
              minimum: 1,
              units: "pixels",
              requires: [{
                "symbol-placement": "line"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-avoid-edges": {
              type: "boolean",
              default: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "symbol-z-order": {
              type: "enum",
              values: {
                auto: {},
                "viewport-y": {},
                source: {}
              },
              default: "auto",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "!": "icon-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-optional": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-size": {
              type: "number",
              default: 1,
              minimum: 0,
              units: "factor of the original icon size",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-text-fit": {
              type: "enum",
              values: {
                none: {},
                width: {},
                height: {},
                both: {}
              },
              default: "none",
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-text-fit-padding": {
              type: "array",
              value: "number",
              length: 4,
              default: [0, 0, 0, 0],
              units: "pixels",
              requires: ["icon-image", "text-field", {
                "icon-text-fit": ["both", "width", "height"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-image": {
              type: "resolvedImage",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-padding": {
              type: "padding",
              default: [2],
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-keep-upright": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "icon-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-offset": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                "viewport-glyph": {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-field": {
              type: "formatted",
              default: "",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-font": {
              type: "array",
              value: "string",
              default: ["Open Sans Regular", "Arial Unicode MS Regular"],
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-size": {
              type: "number",
              default: 16,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-width": {
              type: "number",
              default: 10,
              minimum: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-line-height": {
              type: "number",
              default: 1.2,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-letter-spacing": {
              type: "number",
              default: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-justify": {
              type: "enum",
              values: {
                auto: {},
                left: {},
                center: {},
                right: {}
              },
              default: "center",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-radial-offset": {
              type: "number",
              units: "ems",
              default: 0,
              requires: ["text-field"],
              "property-type": "data-driven",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              }
            },
            "text-variable-anchor": {
              type: "array",
              value: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-variable-anchor-offset": {
              type: "variableAnchorOffsetCollection",
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["text-field", {
                "!": "text-variable-anchor"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-angle": {
              type: "number",
              default: 45,
              units: "degrees",
              requires: ["text-field", {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-writing-mode": {
              type: "array",
              value: "enum",
              values: {
                horizontal: {},
                vertical: {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-padding": {
              type: "number",
              default: 2,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-keep-upright": {
              type: "boolean",
              default: !0,
              requires: ["text-field", {
                "text-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-transform": {
              type: "enum",
              values: {
                none: {},
                uppercase: {},
                lowercase: {}
              },
              default: "none",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-offset": {
              type: "array",
              value: "number",
              units: "ems",
              length: 2,
              default: [0, 0],
              requires: ["text-field", {
                "!": "text-radial-offset"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["text-field", {
                "!": "text-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-optional": {
              type: "boolean",
              default: !1,
              requires: ["text-field", "icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_raster: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_hillshade: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_color-relief": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          filter: {
            type: "array",
            value: "*"
          },
          filter_operator: {
            type: "enum",
            values: {
              "==": {},
              "!=": {},
              ">": {},
              ">=": {},
              "<": {},
              "<=": {},
              in: {},
              "!in": {},
              all: {},
              any: {},
              none: {},
              has: {},
              "!has": {}
            }
          },
          geometry_type: {
            type: "enum",
            values: {
              Point: {},
              LineString: {},
              Polygon: {}
            }
          },
          function: {
            expression: {
              type: "expression"
            },
            stops: {
              type: "array",
              value: "function_stop"
            },
            base: {
              type: "number",
              default: 1,
              minimum: 0
            },
            property: {
              type: "string",
              default: "$zoom"
            },
            type: {
              type: "enum",
              values: {
                identity: {},
                exponential: {},
                interval: {},
                categorical: {}
              },
              default: "exponential"
            },
            colorSpace: {
              type: "enum",
              values: {
                rgb: {},
                lab: {},
                hcl: {}
              },
              default: "rgb"
            },
            default: {
              type: "*",
              required: !1
            }
          },
          function_stop: {
            type: "array",
            minimum: 0,
            maximum: 24,
            value: ["number", "color"],
            length: 2
          },
          expression: {
            type: "array",
            value: "*",
            minimum: 1
          },
          light: {
            anchor: {
              type: "enum",
              default: "viewport",
              values: {
                map: {},
                viewport: {}
              },
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              }
            },
            position: {
              type: "array",
              default: [1.15, 210, 30],
              length: 3,
              value: "number",
              "property-type": "data-constant",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            },
            color: {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            intensity: {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          sky: {
            "sky-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#88C6FC",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-ground-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-fog-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "sky-horizon-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "atmosphere-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          terrain: {
            source: {
              type: "string",
              required: !0
            },
            exaggeration: {
              type: "number",
              minimum: 0,
              default: 1
            }
          },
          projection: {
            type: {
              type: "projectionDefinition",
              default: "mercator",
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            }
          },
          paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
          paint_fill: {
            "fill-antialias": {
              type: "boolean",
              default: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-outline-color": {
              type: "color",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }, {
                "fill-antialias": !0
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            }
          },
          "paint_fill-extrusion": {
            "fill-extrusion-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-extrusion-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-extrusion-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "fill-extrusion-height": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-base": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              requires: ["fill-extrusion-height"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-vertical-gradient": {
              type: "boolean",
              default: !0,
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_line: {
            "line-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["line-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-width": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-gap-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-offset": {
              type: "number",
              default: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-dasharray": {
              type: "array",
              value: "number",
              minimum: 0,
              transition: !0,
              units: "line widths",
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "line-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-gradient": {
              type: "color",
              transition: !1,
              requires: [{
                "!": "line-dasharray"
              }, {
                "!": "line-pattern"
              }, {
                source: "geojson",
                has: {
                  lineMetrics: !0
                }
              }],
              expression: {
                interpolated: !0,
                parameters: ["line-progress"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_circle: {
            "circle-radius": {
              type: "number",
              default: 5,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-blur": {
              type: "number",
              default: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["circle-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-scale": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-stroke-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            }
          },
          paint_heatmap: {
            "heatmap-radius": {
              type: "number",
              default: 30,
              minimum: 1,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-weight": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-intensity": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "heatmap-color": {
              type: "color",
              default: ["interpolate", ["linear"],
                ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"
              ],
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["heatmap-density"]
              },
              "property-type": "color-ramp"
            },
            "heatmap-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_symbol: {
            "icon-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["icon-image", "icon-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              overridable: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["text-field", "text-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_raster: {
            "raster-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-hue-rotate": {
              type: "number",
              default: 0,
              period: 360,
              transition: !0,
              units: "degrees",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-min": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-max": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-saturation": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-contrast": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-resampling": {
              type: "enum",
              values: {
                linear: {},
                nearest: {}
              },
              default: "linear",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-fade-duration": {
              type: "number",
              default: 300,
              minimum: 0,
              transition: !1,
              units: "milliseconds",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_hillshade: {
            "hillshade-illumination-direction": {
              type: "numberArray",
              default: 335,
              minimum: 0,
              maximum: 359,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-altitude": {
              type: "numberArray",
              default: 45,
              minimum: 0,
              maximum: 90,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-exaggeration": {
              type: "number",
              default: .5,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-shadow-color": {
              type: "colorArray",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-highlight-color": {
              type: "colorArray",
              default: "#FFFFFF",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-accent-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-method": {
              type: "enum",
              values: {
                standard: {},
                basic: {},
                combined: {},
                igor: {},
                multidirectional: {}
              },
              default: "standard",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          "paint_color-relief": {
            "color-relief-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "color-relief-color": {
              type: "color",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["elevation"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_background: {
            "background-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "background-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "background-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "background-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          transition: {
            duration: {
              type: "number",
              default: 300,
              minimum: 0,
              units: "milliseconds"
            },
            delay: {
              type: "number",
              default: 0,
              minimum: 0,
              units: "milliseconds"
            }
          },
          "property-type": {
            "data-driven": {
              type: "property-type"
            },
            "cross-faded": {
              type: "property-type"
            },
            "cross-faded-data-driven": {
              type: "property-type"
            },
            "color-ramp": {
              type: "property-type"
            },
            "data-constant": {
              type: "property-type"
            },
            constant: {
              type: "property-type"
            }
          },
          promoteId: {
            "*": {
              type: "string"
            }
          }
        };
        const Xt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];

        function Ht(i, t) {
          const r = {};
          for (const a in i) a !== "ref" && (r[a] = i[a]);
          return Xt.forEach((a => {
            a in t && (r[a] = t[a])
          })), r
        }

        function pt(i, t) {
          if (Array.isArray(i)) {
            if (!Array.isArray(t) || i.length !== t.length) return !1;
            for (let r = 0; r < i.length; r++)
              if (!pt(i[r], t[r])) return !1;
            return !0
          }
          if (typeof i == "object" && i !== null && t !== null) {
            if (typeof t != "object" || Object.keys(i).length !== Object.keys(t).length) return !1;
            for (const r in i)
              if (!pt(i[r], t[r])) return !1;
            return !0
          }
          return i === t
        }

        function bt(i, t) {
          i.push(t)
        }

        function ar(i, t, r) {
          bt(r, {
            command: "addSource",
            args: [i, t[i]]
          })
        }

        function jr(i, t, r) {
          bt(t, {
            command: "removeSource",
            args: [i]
          }), r[i] = !0
        }

        function qr(i, t, r, a) {
          jr(i, r, a), ar(i, t, r)
        }

        function Gr(i, t, r) {
          let a;
          for (a in i[r])
            if (Object.prototype.hasOwnProperty.call(i[r], a) && a !== "data" && !pt(i[r][a], t[r][a])) return !1;
          for (a in t[r])
            if (Object.prototype.hasOwnProperty.call(t[r], a) && a !== "data" && !pt(i[r][a], t[r][a])) return !1;
          return !0
        }

        function mr(i, t, r, a, c, p) {
          i = i || {}, t = t || {};
          for (const f in i) Object.prototype.hasOwnProperty.call(i, f) && (pt(i[f], t[f]) || r.push({
            command: p,
            args: [a, f, t[f], c]
          }));
          for (const f in t) Object.prototype.hasOwnProperty.call(t, f) && !Object.prototype.hasOwnProperty.call(i, f) && (pt(i[f], t[f]) || r.push({
            command: p,
            args: [a, f, t[f], c]
          }))
        }

        function Er(i) {
          return i.id
        }

        function ai(i, t) {
          return i[t.id] = t, i
        }
        class ft {
          constructor(t, r, a, c) {
            this.message = (t ? `${t}: ` : "") + a, c && (this.identifier = c), r != null && r.__line__ && (this.line = r.__line__)
          }
        }

        function yi(i, ...t) {
          for (const r of t)
            for (const a in r) i[a] = r[a];
          return i
        }
        class pi extends Error {
          constructor(t, r) {
            super(r), this.message = r, this.key = t
          }
        }
        class In {
          constructor(t, r = []) {
            this.parent = t, this.bindings = {};
            for (const [a, c] of r) this.bindings[a] = c
          }
          concat(t) {
            return new In(this, t)
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`)
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t)
          }
        }
        const Pt = {
            kind: "null"
          },
          We = {
            kind: "number"
          },
          Ot = {
            kind: "string"
          },
          $t = {
            kind: "boolean"
          },
          zr = {
            kind: "color"
          },
          Wr = {
            kind: "projectionDefinition"
          },
          li = {
            kind: "object"
          },
          _r = {
            kind: "value"
          },
          Ti = {
            kind: "collator"
          },
          Pi = {
            kind: "formatted"
          },
          Li = {
            kind: "padding"
          },
          mi = {
            kind: "colorArray"
          },
          Di = {
            kind: "numberArray"
          },
          rr = {
            kind: "resolvedImage"
          },
          bi = {
            kind: "variableAnchorOffsetCollection"
          };

        function Qr(i, t) {
          return {
            kind: "array",
            itemType: i,
            N: t
          }
        }

        function Yr(i) {
          if (i.kind === "array") {
            const t = Yr(i.itemType);
            return typeof i.N == "number" ? `array<${t}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${t}>`
          }
          return i.kind
        }
        const la = [Pt, We, Ot, $t, zr, Wr, Pi, li, Qr(_r), Li, Di, mi, rr, bi];

        function ln(i, t) {
          if (t.kind === "error") return null;
          if (i.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !ln(i.itemType, t.itemType)) && (typeof i.N != "number" || i.N === t.N)) return null
          } else {
            if (i.kind === t.kind) return null;
            if (i.kind === "value") {
              for (const r of la)
                if (!ln(r, t)) return null
            }
          }
          return `Expected ${Yr(i)} but found ${Yr(t)} instead.`
        }

        function ta(i, t) {
          return t.some((r => r.kind === i.kind))
        }

        function Oi(i, t) {
          return t.some((r => r === "null" ? i === null : r === "array" ? Array.isArray(i) : r === "object" ? i && !Array.isArray(i) && typeof i == "object" : r === typeof i))
        }

        function Ki(i, t) {
          return i.kind === "array" && t.kind === "array" ? i.itemType.kind === t.itemType.kind && typeof i.N == "number" : i.kind === t.kind
        }
        const Hn = .96422,
          Wn = .82521,
          Dn = 4 / 29,
          _t = 6 / 29,
          jt = 3 * _t * _t,
          vr = _t * _t * _t,
          _i = Math.PI / 180,
          Ri = 180 / Math.PI;

        function Hi(i) {
          return (i %= 360) < 0 && (i += 360), i
        }

        function Mi([i, t, r, a]) {
          let c, p;
          const f = vn((.2225045 * (i = Tr(i)) + .7168786 * (t = Tr(t)) + .0606169 * (r = Tr(r))) / 1);
          i === t && t === r ? c = p = f : (c = vn((.4360747 * i + .3850649 * t + .1430804 * r) / Hn), p = vn((.0139322 * i + .0971045 * t + .7141733 * r) / Wn));
          const _ = 116 * f - 16;
          return [_ < 0 ? 0 : _, 500 * (c - f), 200 * (f - p), a]
        }

        function Tr(i) {
          return i <= .04045 ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4)
        }

        function vn(i) {
          return i > vr ? Math.pow(i, 1 / 3) : i / jt + Dn
        }

        function Qt([i, t, r, a]) {
          let c = (i + 16) / 116,
            p = isNaN(t) ? c : c + t / 500,
            f = isNaN(r) ? c : c - r / 200;
          return c = 1 * ei(c), p = Hn * ei(p), f = Wn * ei(f), [Gt(3.1338561 * p - 1.6168667 * c - .4906146 * f), Gt(-.9787684 * p + 1.9161415 * c + .033454 * f), Gt(.0719453 * p - .2289914 * c + 1.4052427 * f), a]
        }

        function Gt(i) {
          return (i = i <= .00304 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - .055) < 0 ? 0 : i > 1 ? 1 : i
        }

        function ei(i) {
          return i > _t ? i * i * i : jt * (i - Dn)
        }
        const ri = Object.hasOwn || function(i, t) {
          return Object.prototype.hasOwnProperty.call(i, t)
        };

        function gi(i, t) {
          return ri(i, t) ? i[t] : void 0
        }

        function ui(i) {
          return parseInt(i.padEnd(2, i), 16) / 255
        }

        function fi(i, t) {
          return Ar(t ? i / 100 : i, 0, 1)
        }

        function Ar(i, t, r) {
          return Math.min(Math.max(t, i), r)
        }

        function Bi(i) {
          return !i.some(Number.isNaN)
        }
        const hi = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        };

        function Jr(i, t, r) {
          return i + r * (t - i)
        }

        function ti(i, t, r) {
          return i.map(((a, c) => Jr(a, t[c], r)))
        }
        class br {
          constructor(t, r, a, c = 1, p = !0) {
            this.r = t, this.g = r, this.b = a, this.a = c, p || (this.r *= c, this.g *= c, this.b *= c, c || this.overwriteGetter("rgb", [t, r, a, c]))
          }
          static parse(t) {
            if (t instanceof br) return t;
            if (typeof t != "string") return;
            const r = (function(a) {
              if ((a = a.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const c = gi(hi, a);
              if (c) {
                const [f, _, v] = c;
                return [f / 255, _ / 255, v / 255, 1]
              }
              if (a.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(a)) {
                const f = a.length < 6 ? 1 : 2;
                let _ = 1;
                return [ui(a.slice(_, _ += f)), ui(a.slice(_, _ += f)), ui(a.slice(_, _ += f)), ui(a.slice(_, _ + f) || "ff")]
              }
              if (a.startsWith("rgb")) {
                const f = a.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (f) {
                  const [_, v, S, I, E, R, O, j, Z, Y, ne, ke] = f, pe = [I || " ", O || " ", Y].join("");
                  if (pe === "  " || pe === "  /" || pe === ",," || pe === ",,,") {
                    const be = [S, R, Z].join(""),
                      Ve = be === "%%%" ? 100 : be === "" ? 255 : 0;
                    if (Ve) {
                      const et = [Ar(+v / Ve, 0, 1), Ar(+E / Ve, 0, 1), Ar(+j / Ve, 0, 1), ne ? fi(+ne, ke) : 1];
                      if (Bi(et)) return et
                    }
                  }
                  return
                }
              }
              const p = a.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (p) {
                const [f, _, v, S, I, E, R, O, j] = p, Z = [v || " ", I || " ", R].join("");
                if (Z === "  " || Z === "  /" || Z === ",," || Z === ",,,") {
                  const Y = [+_, Ar(+S, 0, 100), Ar(+E, 0, 100), O ? fi(+O, j) : 1];
                  if (Bi(Y)) return (function([ne, ke, pe, be]) {
                    function Ve(et) {
                      const xt = (et + ne / 30) % 12,
                        Zt = ke * Math.min(pe, 1 - pe);
                      return pe - Zt * Math.max(-1, Math.min(xt - 3, 9 - xt, 1))
                    }
                    return ne = Hi(ne), ke /= 100, pe /= 100, [Ve(0), Ve(8), Ve(4), be]
                  })(Y)
                }
              }
            })(t);
            return r ? new br(...r, !1) : void 0
          }
          get rgb() {
            const {
              r: t,
              g: r,
              b: a,
              a: c
            } = this, p = c || 1 / 0;
            return this.overwriteGetter("rgb", [t / p, r / p, a / p, c])
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [r, a, c, p] = Mi(t), f = Math.sqrt(a * a + c * c);
              return [Math.round(1e4 * f) ? Hi(Math.atan2(c, a) * Ri) : NaN, f, r, p]
            })(this.rgb))
          }
          get lab() {
            return this.overwriteGetter("lab", Mi(this.rgb))
          }
          overwriteGetter(t, r) {
            return Object.defineProperty(this, t, {
              value: r
            }), r
          }
          toString() {
            const [t, r, a, c] = this.rgb;
            return `rgba(${[t,r,a].map((p=>Math.round(255*p))).join(",")},${c})`
          }
          static interpolate(t, r, a, c = "rgb") {
            switch (c) {
              case "rgb": {
                const [p, f, _, v] = ti(t.rgb, r.rgb, a);
                return new br(p, f, _, v, !1)
              }
              case "hcl": {
                const [p, f, _, v] = t.hcl, [S, I, E, R] = r.hcl;
                let O, j;
                if (isNaN(p) || isNaN(S)) isNaN(p) ? isNaN(S) ? O = NaN : (O = S, _ !== 1 && _ !== 0 || (j = I)) : (O = p, E !== 1 && E !== 0 || (j = f));
                else {
                  let pe = S - p;
                  S > p && pe > 180 ? pe -= 360 : S < p && p - S > 180 && (pe += 360), O = p + a * pe
                }
                const [Z, Y, ne, ke] = (function([pe, be, Ve, et]) {
                  return pe = isNaN(pe) ? 0 : pe * _i, Qt([Ve, Math.cos(pe) * be, Math.sin(pe) * be, et])
                })([O, j ?? Jr(f, I, a), Jr(_, E, a), Jr(v, R, a)]);
                return new br(Z, Y, ne, ke, !1)
              }
              case "lab": {
                const [p, f, _, v] = Qt(ti(t.lab, r.lab, a));
                return new br(p, f, _, v, !1)
              }
            }
          }
        }
        br.black = new br(0, 0, 0, 1), br.white = new br(1, 1, 1, 1), br.transparent = new br(0, 0, 0, 0), br.red = new br(1, 0, 0, 1);
        class Yi {
          constructor(t, r, a) {
            this.sensitivity = t ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = a, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
              sensitivity: this.sensitivity,
              usage: "search"
            })
          }
          compare(t, r) {
            return this.collator.compare(t, r)
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
          }
        }
        const Ni = ["bottom", "center", "top"];
        class cn {
          constructor(t, r, a, c, p, f) {
            this.text = t, this.image = r, this.scale = a, this.fontStack = c, this.textColor = p, this.verticalAlign = f
          }
        }
        class Ji {
          constructor(t) {
            this.sections = t
          }
          static fromString(t) {
            return new Ji([new cn(t, null, null, null, null, null)])
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t => t.text.length !== 0 || t.image && t.image.name.length !== 0))
          }
          static factory(t) {
            return t instanceof Ji ? t : Ji.fromString(t)
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t => t.text)).join("")
          }
        }
        class Ui {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Ui) return t;
            if (typeof t == "number") return new Ui([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const r of t)
                if (typeof r != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]]
              }
              return new Ui(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, a) {
            return new Ui(ti(t.values, r.values, a))
          }
        }
        class Qi {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Qi) return t;
            if (typeof t == "number") return new Qi([t]);
            if (Array.isArray(t)) {
              for (const r of t)
                if (typeof r != "number") return;
              return new Qi(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, a) {
            return new Qi(ti(t.values, r.values, a))
          }
        }
        class Ci {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Ci) return t;
            if (typeof t == "string") {
              const a = br.parse(t);
              return a ? new Ci([a]) : void 0
            }
            if (!Array.isArray(t)) return;
            const r = [];
            for (const a of t) {
              if (typeof a != "string") return;
              const c = br.parse(a);
              if (!c) return;
              r.push(c)
            }
            return new Ci(r)
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, a, c = "rgb") {
            const p = [];
            if (t.values.length != r.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${r.values.length}), cannot interpolate.`);
            for (let f = 0; f < t.values.length; f++) p.push(br.interpolate(t.values[f], r.values[f], a, c));
            return new Ci(p)
          }
        }
        class ci extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError"
          }
          toJSON() {
            return this.message
          }
        }
        const Ko = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class un {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof un) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let r = 0; r < t.length; r += 2) {
                const a = t[r],
                  c = t[r + 1];
                if (typeof a != "string" || !Ko.has(a) || !Array.isArray(c) || c.length !== 2 || typeof c[0] != "number" || typeof c[1] != "number") return
              }
              return new un(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, a) {
            const c = t.values,
              p = r.values;
            if (c.length !== p.length) throw new ci(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${r.toString()}`);
            const f = [];
            for (let _ = 0; _ < c.length; _ += 2) {
              if (c[_] !== p[_]) throw new ci(`Cannot interpolate values containing mismatched anchors. from[${_}]: ${c[_]}, to[${_}]: ${p[_]}`);
              f.push(c[_]);
              const [v, S] = c[_ + 1], [I, E] = p[_ + 1];
              f.push([Jr(v, I, a), Jr(S, E, a)])
            }
            return new un(f)
          }
        }
        class Nn {
          constructor(t) {
            this.name = t.name, this.available = t.available
          }
          toString() {
            return this.name
          }
          static fromString(t) {
            return t ? new Nn({
              name: t,
              available: !1
            }) : null
          }
        }
        class hn {
          constructor(t, r, a) {
            this.from = t, this.to = r, this.transition = a
          }
          static interpolate(t, r, a) {
            return new hn(t, r, a)
          }
          static parse(t) {
            return t instanceof hn ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new hn(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new hn(t.from, t.to, t.transition) : typeof t == "string" ? new hn(t, t, 1) : void 0
          }
        }

        function Si(i, t, r, a) {
          return typeof i == "number" && i >= 0 && i <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? a === void 0 || typeof a == "number" && a >= 0 && a <= 1 ? null : `Invalid rgba value [${[i,t,r,a].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof a=="number"?[i,t,r,a]:[i,t,r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }

        function Ua(i) {
          if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof hn || i instanceof br || i instanceof Yi || i instanceof Ji || i instanceof Ui || i instanceof Qi || i instanceof Ci || i instanceof un || i instanceof Nn) return !0;
          if (Array.isArray(i)) {
            for (const t of i)
              if (!Ua(t)) return !1;
            return !0
          }
          if (typeof i == "object") {
            for (const t in i)
              if (!Ua(i[t])) return !1;
            return !0
          }
          return !1
        }

        function wr(i) {
          if (i === null) return Pt;
          if (typeof i == "string") return Ot;
          if (typeof i == "boolean") return $t;
          if (typeof i == "number") return We;
          if (i instanceof br) return zr;
          if (i instanceof hn) return Wr;
          if (i instanceof Yi) return Ti;
          if (i instanceof Ji) return Pi;
          if (i instanceof Ui) return Li;
          if (i instanceof Qi) return Di;
          if (i instanceof Ci) return mi;
          if (i instanceof un) return bi;
          if (i instanceof Nn) return rr;
          if (Array.isArray(i)) {
            const t = i.length;
            let r;
            for (const a of i) {
              const c = wr(a);
              if (r) {
                if (r === c) continue;
                r = _r;
                break
              }
              r = c
            }
            return Qr(r || _r, t)
          }
          return li
        }

        function Ur(i) {
          const t = typeof i;
          return i === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(i) : i instanceof br || i instanceof hn || i instanceof Ji || i instanceof Ui || i instanceof Qi || i instanceof Ci || i instanceof un || i instanceof Nn ? i.toString() : JSON.stringify(i)
        }
        class ga {
          constructor(t, r) {
            this.type = t, this.value = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (!Ua(t[1])) return r.error("invalid value");
            const a = t[1];
            let c = wr(a);
            const p = r.expectedType;
            return c.kind !== "array" || c.N !== 0 || !p || p.kind !== "array" || typeof p.N == "number" && p.N !== 0 || (c = p), new ga(c, a)
          }
          evaluate() {
            return this.value
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        const di = {
          string: Ot,
          number: We,
          boolean: $t,
          object: li
        };
        class ra {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let a, c = 1;
            const p = t[0];
            if (p === "array") {
              let _, v;
              if (t.length > 2) {
                const S = t[1];
                if (typeof S != "string" || !(S in di) || S === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
                _ = di[S], c++
              } else _ = _r;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2);
                v = t[2], c++
              }
              a = Qr(_, v)
            } else {
              if (!di[p]) throw new Error(`Types doesn't contain name = ${p}`);
              a = di[p]
            }
            const f = [];
            for (; c < t.length; c++) {
              const _ = r.parse(t[c], c, _r);
              if (!_) return null;
              f.push(_)
            }
            return new ra(a, f)
          }
          evaluate(t) {
            for (let r = 0; r < this.args.length; r++) {
              const a = this.args[r].evaluate(t);
              if (!ln(this.type, wr(a))) return a;
              if (r === this.args.length - 1) throw new ci(`Expected value to be of type ${Yr(this.type)}, but found ${Yr(wr(a))} instead.`)
            }
            throw new Error
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const Da = {
          "to-boolean": $t,
          "to-color": zr,
          "to-number": We,
          "to-string": Ot
        };
        class Ra {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const a = t[0];
            if (!Da[a]) throw new Error(`Can't parse ${a} as it is not part of the known types`);
            if ((a === "to-boolean" || a === "to-string") && t.length !== 2) return r.error("Expected one argument.");
            const c = Da[a],
              p = [];
            for (let f = 1; f < t.length; f++) {
              const _ = r.parse(t[f], f, _r);
              if (!_) return null;
              p.push(_)
            }
            return new Ra(c, p)
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let r, a;
                for (const c of this.args) {
                  if (r = c.evaluate(t), a = null, r instanceof br) return r;
                  if (typeof r == "string") {
                    const p = t.parseColor(r);
                    if (p) return p
                  } else if (Array.isArray(r) && (a = r.length < 3 || r.length > 4 ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : Si(r[0], r[1], r[2], r[3]), !a)) return new br(r[0] / 255, r[1] / 255, r[2] / 255, r[3])
                }
                throw new ci(a || `Could not parse color from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "padding": {
                let r;
                for (const a of this.args) {
                  r = a.evaluate(t);
                  const c = Ui.parse(r);
                  if (c) return c
                }
                throw new ci(`Could not parse padding from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "numberArray": {
                let r;
                for (const a of this.args) {
                  r = a.evaluate(t);
                  const c = Qi.parse(r);
                  if (c) return c
                }
                throw new ci(`Could not parse numberArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "colorArray": {
                let r;
                for (const a of this.args) {
                  r = a.evaluate(t);
                  const c = Ci.parse(r);
                  if (c) return c
                }
                throw new ci(`Could not parse colorArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "variableAnchorOffsetCollection": {
                let r;
                for (const a of this.args) {
                  r = a.evaluate(t);
                  const c = un.parse(r);
                  if (c) return c
                }
                throw new ci(`Could not parse variableAnchorOffsetCollection from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "number": {
                let r = null;
                for (const a of this.args) {
                  if (r = a.evaluate(t), r === null) return 0;
                  const c = Number(r);
                  if (!isNaN(c)) return c
                }
                throw new ci(`Could not convert ${JSON.stringify(r)} to number.`)
              }
              case "formatted":
                return Ji.fromString(Ur(this.args[0].evaluate(t)));
              case "resolvedImage":
                return Nn.fromString(Ur(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return Ur(this.args[0].evaluate(t))
            }
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const Yo = ["Unknown", "Point", "LineString", "Polygon"];
        class fc {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = new Map, this.availableImages = null, this.canonical = null
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Yo[this.feature.type] : this.feature.type : null
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null
          }
          canonicalID() {
            return this.canonical
          }
          properties() {
            return this.feature && this.feature.properties || {}
          }
          parseColor(t) {
            let r = this._parseColorCache.get(t);
            return r || (r = br.parse(t), this._parseColorCache.set(t, r)), r
          }
        }
        class Rs {
          constructor(t, r, a = [], c, p = new In, f = []) {
            this.registry = t, this.path = a, this.key = a.map((_ => `[${_}]`)).join(""), this.scope = p, this.errors = f, this.expectedType = c, this._isConstant = r
          }
          parse(t, r, a, c, p = {}) {
            return r ? this.concat(r, a, c)._parse(t, p) : this._parse(t, p)
          }
          _parse(t, r) {
            function a(c, p, f) {
              return f === "assert" ? new ra(p, [c]) : f === "coerce" ? new Ra(p, [c]) : c
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const c = t[0];
              if (typeof c != "string") return this.error(`Expression name must be a string, but found ${typeof c} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const p = this.registry[c];
              if (p) {
                let f = p.parse(t, this);
                if (!f) return null;
                if (this.expectedType) {
                  const _ = this.expectedType,
                    v = f.type;
                  if (_.kind !== "string" && _.kind !== "number" && _.kind !== "boolean" && _.kind !== "object" && _.kind !== "array" || v.kind !== "value") {
                    if (_.kind === "projectionDefinition" && ["string", "array"].includes(v.kind) || ["color", "formatted", "resolvedImage"].includes(_.kind) && ["value", "string"].includes(v.kind) || ["padding", "numberArray"].includes(_.kind) && ["value", "number", "array"].includes(v.kind) || _.kind === "colorArray" && ["value", "string", "array"].includes(v.kind) || _.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(v.kind)) f = a(f, _, r.typeAnnotation || "coerce");
                    else if (this.checkSubtype(_, v)) return null
                  } else f = a(f, _, r.typeAnnotation || "assert")
                }
                if (!(f instanceof ga) && f.type.kind !== "resolvedImage" && this._isConstant(f)) {
                  const _ = new fc;
                  try {
                    f = new ga(f.type, f.evaluate(_))
                  } catch (v) {
                    return this.error(v.message), null
                  }
                }
                return f
              }
              return this.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0)
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
          }
          concat(t, r, a) {
            const c = typeof t == "number" ? this.path.concat(t) : this.path,
              p = a ? this.scope.concat(a) : this.scope;
            return new Rs(this.registry, this._isConstant, c, r || null, p, this.errors)
          }
          error(t, ...r) {
            const a = `${this.key}${r.map((c=>`[${c}]`)).join("")}`;
            this.errors.push(new pi(a, t))
          }
          checkSubtype(t, r) {
            const a = ln(t, r);
            return a && this.error(a), a
          }
        }
        class uo {
          constructor(t, r) {
            this.type = r.type, this.bindings = [].concat(t), this.result = r
          }
          evaluate(t) {
            return this.result.evaluate(t)
          }
          eachChild(t) {
            for (const r of this.bindings) t(r[1]);
            t(this.result)
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);
            const a = [];
            for (let p = 1; p < t.length - 1; p += 2) {
              const f = t[p];
              if (typeof f != "string") return r.error(`Expected string, but found ${typeof f} instead.`, p);
              if (/[^a-zA-Z0-9_]/.test(f)) return r.error("Variable names must contain only alphanumeric characters or '_'.", p);
              const _ = r.parse(t[p + 1], p + 1);
              if (!_) return null;
              a.push([f, _])
            }
            const c = r.parse(t[t.length - 1], t.length - 1, r.expectedType, a);
            return c ? new uo(a, c) : null
          }
          outputDefined() {
            return this.result.outputDefined()
          }
        }
        class Jo {
          constructor(t, r) {
            this.type = r.type, this.name = t, this.boundExpression = r
          }
          static parse(t, r) {
            if (t.length !== 2 || typeof t[1] != "string") return r.error("'var' expression requires exactly one string literal argument.");
            const a = t[1];
            return r.scope.has(a) ? new Jo(a, r.scope.get(a)) : r.error(`Unknown variable "${a}". Make sure "${a}" has been bound in an enclosing "let" expression before using it.`, 1)
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t)
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        class Qo {
          constructor(t, r, a) {
            this.type = t, this.index = r, this.input = a
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1, We),
              c = r.parse(t[2], 2, Qr(r.expectedType || _r));
            return a && c ? new Qo(c.type.itemType, a, c) : null
          }
          evaluate(t) {
            const r = this.index.evaluate(t),
              a = this.input.evaluate(t);
            if (r < 0) throw new ci(`Array index out of bounds: ${r} < 0.`);
            if (r >= a.length) throw new ci(`Array index out of bounds: ${r} > ${a.length-1}.`);
            if (r !== Math.floor(r)) throw new ci(`Array index must be an integer, but found ${r} instead.`);
            return a[r]
          }
          eachChild(t) {
            t(this.index), t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class el {
          constructor(t, r) {
            this.type = $t, this.needle = t, this.haystack = r
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1, _r),
              c = r.parse(t[2], 2, _r);
            return a && c ? ta(a.type, [$t, Ot, We, Pt, _r]) ? new el(a, c) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Yr(a.type)} instead`) : null
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              a = this.haystack.evaluate(t);
            if (!a) return !1;
            if (!Oi(r, ["boolean", "string", "number", "null"])) throw new ci(`Expected first argument to be of type boolean, string, number or null, but found ${Yr(wr(r))} instead.`);
            if (!Oi(a, ["string", "array"])) throw new ci(`Expected second argument to be of type array or string, but found ${Yr(wr(a))} instead.`);
            return a.indexOf(r) >= 0
          }
          eachChild(t) {
            t(this.needle), t(this.haystack)
          }
          outputDefined() {
            return !0
          }
        }
        class va {
          constructor(t, r, a) {
            this.type = We, this.needle = t, this.haystack = r, this.fromIndex = a
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1, _r),
              c = r.parse(t[2], 2, _r);
            if (!a || !c) return null;
            if (!ta(a.type, [$t, Ot, We, Pt, _r])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Yr(a.type)} instead`);
            if (t.length === 4) {
              const p = r.parse(t[3], 3, We);
              return p ? new va(a, c, p) : null
            }
            return new va(a, c)
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              a = this.haystack.evaluate(t);
            if (!Oi(r, ["boolean", "string", "number", "null"])) throw new ci(`Expected first argument to be of type boolean, string, number or null, but found ${Yr(wr(r))} instead.`);
            let c;
            if (this.fromIndex && (c = this.fromIndex.evaluate(t)), Oi(a, ["string"])) {
              const p = a.indexOf(r, c);
              return p === -1 ? -1 : [...a.slice(0, p)].length
            }
            if (Oi(a, ["array"])) return a.indexOf(r, c);
            throw new ci(`Expected second argument to be of type array or string, but found ${Yr(wr(a))} instead.`)
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex)
          }
          outputDefined() {
            return !1
          }
        }
        class yn {
          constructor(t, r, a, c, p, f) {
            this.inputType = t, this.type = r, this.input = a, this.cases = c, this.outputs = p, this.otherwise = f
          }
          static parse(t, r) {
            if (t.length < 5) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 1) return r.error("Expected an even number of arguments.");
            let a, c;
            r.expectedType && r.expectedType.kind !== "value" && (c = r.expectedType);
            const p = {},
              f = [];
            for (let S = 2; S < t.length - 1; S += 2) {
              let I = t[S];
              const E = t[S + 1];
              Array.isArray(I) || (I = [I]);
              const R = r.concat(S);
              if (I.length === 0) return R.error("Expected at least one branch label.");
              for (const j of I) {
                if (typeof j != "number" && typeof j != "string") return R.error("Branch labels must be numbers or strings.");
                if (typeof j == "number" && Math.abs(j) > Number.MAX_SAFE_INTEGER) return R.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof j == "number" && Math.floor(j) !== j) return R.error("Numeric branch labels must be integer values.");
                if (a) {
                  if (R.checkSubtype(a, wr(j))) return null
                } else a = wr(j);
                if (p[String(j)] !== void 0) return R.error("Branch labels must be unique.");
                p[String(j)] = f.length
              }
              const O = r.parse(E, S, c);
              if (!O) return null;
              c = c || O.type, f.push(O)
            }
            const _ = r.parse(t[1], 1, _r);
            if (!_) return null;
            const v = r.parse(t[t.length - 1], t.length - 1, c);
            return v ? _.type.kind !== "value" && r.concat(1).checkSubtype(a, _.type) ? null : new yn(a, c, _, p, f, v) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            return (wr(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(t)
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class Bs {
          constructor(t, r, a) {
            this.type = t, this.branches = r, this.otherwise = a
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 0) return r.error("Expected an odd number of arguments.");
            let a;
            r.expectedType && r.expectedType.kind !== "value" && (a = r.expectedType);
            const c = [];
            for (let f = 1; f < t.length - 1; f += 2) {
              const _ = r.parse(t[f], f, $t);
              if (!_) return null;
              const v = r.parse(t[f + 1], f + 1, a);
              if (!v) return null;
              c.push([_, v]), a = a || v.type
            }
            const p = r.parse(t[t.length - 1], t.length - 1, a);
            if (!p) return null;
            if (!a) throw new Error("Can't infer output type");
            return new Bs(a, c, p)
          }
          evaluate(t) {
            for (const [r, a] of this.branches)
              if (r.evaluate(t)) return a.evaluate(t);
            return this.otherwise.evaluate(t)
          }
          eachChild(t) {
            for (const [r, a] of this.branches) t(r), t(a);
            t(this.otherwise)
          }
          outputDefined() {
            return this.branches.every((([t, r]) => r.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class ho {
          constructor(t, r, a, c) {
            this.type = t, this.input = r, this.beginIndex = a, this.endIndex = c
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1, _r),
              c = r.parse(t[2], 2, We);
            if (!a || !c) return null;
            if (!ta(a.type, [Qr(_r), Ot, _r])) return r.error(`Expected first argument to be of type array or string, but found ${Yr(a.type)} instead`);
            if (t.length === 4) {
              const p = r.parse(t[3], 3, We);
              return p ? new ho(a.type, a, c, p) : null
            }
            return new ho(a.type, a, c)
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              a = this.beginIndex.evaluate(t);
            let c;
            if (this.endIndex && (c = this.endIndex.evaluate(t)), Oi(r, ["string"])) return [...r].slice(a, c).join("");
            if (Oi(r, ["array"])) return r.slice(a, c);
            throw new ci(`Expected first argument to be of type array or string, but found ${Yr(wr(r))} instead.`)
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex)
          }
          outputDefined() {
            return !1
          }
        }

        function ps(i, t) {
          const r = i.length - 1;
          let a, c, p = 0,
            f = r,
            _ = 0;
          for (; p <= f;)
            if (_ = Math.floor((p + f) / 2), a = i[_], c = i[_ + 1], a <= t) {
              if (_ === r || t < c) return _;
              p = _ + 1
            } else {
              if (!(a > t)) throw new ci("Input is not a number.");
              f = _ - 1
            } return 0
        }
        class Wi {
          constructor(t, r, a) {
            this.type = t, this.input = r, this.labels = [], this.outputs = [];
            for (const [c, p] of a) this.labels.push(c), this.outputs.push(p)
          }
          static parse(t, r) {
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            const a = r.parse(t[1], 1, We);
            if (!a) return null;
            const c = [];
            let p = null;
            r.expectedType && r.expectedType.kind !== "value" && (p = r.expectedType);
            for (let f = 1; f < t.length; f += 2) {
              const _ = f === 1 ? -1 / 0 : t[f],
                v = t[f + 1],
                S = f,
                I = f + 1;
              if (typeof _ != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', S);
              if (c.length && c[c.length - 1][0] >= _) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', S);
              const E = r.parse(v, I, p);
              if (!E) return null;
              p = p || E.type, c.push([_, E])
            }
            return new Wi(p, a, c)
          }
          evaluate(t) {
            const r = this.labels,
              a = this.outputs;
            if (r.length === 1) return a[0].evaluate(t);
            const c = this.input.evaluate(t);
            if (c <= r[0]) return a[0].evaluate(t);
            const p = r.length;
            return c >= r[p - 1] ? a[p - 1].evaluate(t) : a[ps(r, c)].evaluate(t)
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function fh(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
        }
        var po, mc, Gd = (function() {
            if (mc) return po;

            function i(t, r, a, c) {
              this.cx = 3 * t, this.bx = 3 * (a - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (c - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = a, this.p2y = c
            }
            return mc = 1, po = i, i.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var a = t, c = 0; c < 8; c++) {
                  var p = this.sampleCurveX(a) - t;
                  if (Math.abs(p) < r) return a;
                  var f = this.sampleCurveDerivativeX(a);
                  if (Math.abs(f) < 1e-6) break;
                  a -= p / f
                }
                var _ = 0,
                  v = 1;
                for (a = t, c = 0; c < 20 && (p = this.sampleCurveX(a), !(Math.abs(p - t) < r)); c++) t > p ? _ = a : v = a, a = .5 * (v - _) + _;
                return a
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, po
          })(),
          Fs = fh(Gd);
        class Mn {
          constructor(t, r, a, c, p) {
            this.type = t, this.operator = r, this.interpolation = a, this.input = c, this.labels = [], this.outputs = [];
            for (const [f, _] of p) this.labels.push(f), this.outputs.push(_)
          }
          static interpolationFactor(t, r, a, c) {
            let p = 0;
            if (t.name === "exponential") p = fo(r, t.base, a, c);
            else if (t.name === "linear") p = fo(r, 1, a, c);
            else if (t.name === "cubic-bezier") {
              const f = t.controlPoints;
              p = new Fs(f[0], f[1], f[2], f[3]).solve(fo(r, 1, a, c))
            }
            return p
          }
          static parse(t, r) {
            let [a, c, p, ...f] = t;
            if (!Array.isArray(c) || c.length === 0) return r.error("Expected an interpolation type expression.", 1);
            if (c[0] === "linear") c = {
              name: "linear"
            };
            else if (c[0] === "exponential") {
              const S = c[1];
              if (typeof S != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1);
              c = {
                name: "exponential",
                base: S
              }
            } else {
              if (c[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(c[0])}`, 1, 0);
              {
                const S = c.slice(1);
                if (S.length !== 4 || S.some((I => typeof I != "number" || I < 0 || I > 1))) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                c = {
                  name: "cubic-bezier",
                  controlPoints: S
                }
              }
            }
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            if (p = r.parse(p, 2, We), !p) return null;
            const _ = [];
            let v = null;
            a !== "interpolate-hcl" && a !== "interpolate-lab" || r.expectedType == mi ? r.expectedType && r.expectedType.kind !== "value" && (v = r.expectedType) : v = zr;
            for (let S = 0; S < f.length; S += 2) {
              const I = f[S],
                E = f[S + 1],
                R = S + 3,
                O = S + 4;
              if (typeof I != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', R);
              if (_.length && _[_.length - 1][0] >= I) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', R);
              const j = r.parse(E, O, v);
              if (!j) return null;
              v = v || j.type, _.push([I, j])
            }
            return Ki(v, We) || Ki(v, Wr) || Ki(v, zr) || Ki(v, Li) || Ki(v, Di) || Ki(v, mi) || Ki(v, bi) || Ki(v, Qr(We)) ? new Mn(v, a, c, p, _) : r.error(`Type ${Yr(v)} is not interpolatable.`)
          }
          evaluate(t) {
            const r = this.labels,
              a = this.outputs;
            if (r.length === 1) return a[0].evaluate(t);
            const c = this.input.evaluate(t);
            if (c <= r[0]) return a[0].evaluate(t);
            const p = r.length;
            if (c >= r[p - 1]) return a[p - 1].evaluate(t);
            const f = ps(r, c),
              _ = Mn.interpolationFactor(this.interpolation, c, r[f], r[f + 1]),
              v = a[f].evaluate(t),
              S = a[f + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Jr(v, S, _);
                  case "color":
                    return br.interpolate(v, S, _);
                  case "padding":
                    return Ui.interpolate(v, S, _);
                  case "colorArray":
                    return Ci.interpolate(v, S, _);
                  case "numberArray":
                    return Qi.interpolate(v, S, _);
                  case "variableAnchorOffsetCollection":
                    return un.interpolate(v, S, _);
                  case "array":
                    return ti(v, S, _);
                  case "projectionDefinition":
                    return hn.interpolate(v, S, _)
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return br.interpolate(v, S, _, "hcl");
                  case "colorArray":
                    return Ci.interpolate(v, S, _, "hcl")
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return br.interpolate(v, S, _, "lab");
                  case "colorArray":
                    return Ci.interpolate(v, S, _, "lab")
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function fo(i, t, r, a) {
          const c = a - r,
            p = i - r;
          return c === 0 ? 0 : t === 1 ? p / c : (Math.pow(t, p) - 1) / (Math.pow(t, c) - 1)
        }
        const Ba = {
          color: br.interpolate,
          number: Jr,
          padding: Ui.interpolate,
          numberArray: Qi.interpolate,
          colorArray: Ci.interpolate,
          variableAnchorOffsetCollection: un.interpolate,
          array: ti
        };
        class mo {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let a = null;
            const c = r.expectedType;
            c && c.kind !== "value" && (a = c);
            const p = [];
            for (const _ of t.slice(1)) {
              const v = r.parse(_, 1 + p.length, a, void 0, {
                typeAnnotation: "omit"
              });
              if (!v) return null;
              a = a || v.type, p.push(v)
            }
            if (!a) throw new Error("No output type");
            const f = c && p.some((_ => ln(c, _.type)));
            return new mo(f ? _r : a, p)
          }
          evaluate(t) {
            let r, a = null,
              c = 0;
            for (const p of this.args)
              if (c++, a = p.evaluate(t), a && a instanceof Nn && !a.available && (r || (r = a.name), a = null, c === this.args.length && (a = r)), a !== null) break;
            return a
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }

        function _o(i, t) {
          return i === "==" || i === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
        }

        function go(i, t, r, a) {
          return a.compare(t, r) === 0
        }

        function Rn(i, t, r) {
          const a = i !== "==" && i !== "!=";
          return class ev {
            constructor(p, f, _) {
              this.type = $t, this.lhs = p, this.rhs = f, this.collator = _, this.hasUntypedArgument = p.type.kind === "value" || f.type.kind === "value"
            }
            static parse(p, f) {
              if (p.length !== 3 && p.length !== 4) return f.error("Expected two or three arguments.");
              const _ = p[0];
              let v = f.parse(p[1], 1, _r);
              if (!v) return null;
              if (!_o(_, v.type)) return f.concat(1).error(`"${_}" comparisons are not supported for type '${Yr(v.type)}'.`);
              let S = f.parse(p[2], 2, _r);
              if (!S) return null;
              if (!_o(_, S.type)) return f.concat(2).error(`"${_}" comparisons are not supported for type '${Yr(S.type)}'.`);
              if (v.type.kind !== S.type.kind && v.type.kind !== "value" && S.type.kind !== "value") return f.error(`Cannot compare types '${Yr(v.type)}' and '${Yr(S.type)}'.`);
              a && (v.type.kind === "value" && S.type.kind !== "value" ? v = new ra(S.type, [v]) : v.type.kind !== "value" && S.type.kind === "value" && (S = new ra(v.type, [S])));
              let I = null;
              if (p.length === 4) {
                if (v.type.kind !== "string" && S.type.kind !== "string" && v.type.kind !== "value" && S.type.kind !== "value") return f.error("Cannot use collator to compare non-string types.");
                if (I = f.parse(p[3], 3, Ti), !I) return null
              }
              return new ev(v, S, I)
            }
            evaluate(p) {
              const f = this.lhs.evaluate(p),
                _ = this.rhs.evaluate(p);
              if (a && this.hasUntypedArgument) {
                const v = wr(f),
                  S = wr(_);
                if (v.kind !== S.kind || v.kind !== "string" && v.kind !== "number") throw new ci(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${v.kind}, ${S.kind}) instead.`)
              }
              if (this.collator && !a && this.hasUntypedArgument) {
                const v = wr(f),
                  S = wr(_);
                if (v.kind !== "string" || S.kind !== "string") return t(p, f, _)
              }
              return this.collator ? r(p, f, _, this.collator.evaluate(p)) : t(p, f, _)
            }
            eachChild(p) {
              p(this.lhs), p(this.rhs), this.collator && p(this.collator)
            }
            outputDefined() {
              return !0
            }
          }
        }
        const mh = Rn("==", (function(i, t, r) {
            return t === r
          }), go),
          tl = Rn("!=", (function(i, t, r) {
            return t !== r
          }), (function(i, t, r, a) {
            return !go(0, t, r, a)
          })),
          Hd = Rn("<", (function(i, t, r) {
            return t < r
          }), (function(i, t, r, a) {
            return a.compare(t, r) < 0
          })),
          _c = Rn(">", (function(i, t, r) {
            return t > r
          }), (function(i, t, r, a) {
            return a.compare(t, r) > 0
          })),
          Wd = Rn("<=", (function(i, t, r) {
            return t <= r
          }), (function(i, t, r, a) {
            return a.compare(t, r) <= 0
          })),
          Xd = Rn(">=", (function(i, t, r) {
            return t >= r
          }), (function(i, t, r, a) {
            return a.compare(t, r) >= 0
          }));
        class rl {
          constructor(t, r, a) {
            this.type = Ti, this.locale = a, this.caseSensitive = t, this.diacriticSensitive = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected one argument.");
            const a = t[1];
            if (typeof a != "object" || Array.isArray(a)) return r.error("Collator options argument must be an object.");
            const c = r.parse(a["case-sensitive"] !== void 0 && a["case-sensitive"], 1, $t);
            if (!c) return null;
            const p = r.parse(a["diacritic-sensitive"] !== void 0 && a["diacritic-sensitive"], 1, $t);
            if (!p) return null;
            let f = null;
            return a.locale && (f = r.parse(a.locale, 1, Ot), !f) ? null : new rl(c, p, f)
          }
          evaluate(t) {
            return new Yi(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null)
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale)
          }
          outputDefined() {
            return !1
          }
        }
        class gc {
          constructor(t, r, a, c, p) {
            this.type = Ot, this.number = t, this.locale = r, this.currency = a, this.minFractionDigits = c, this.maxFractionDigits = p
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error("Expected two arguments.");
            const a = r.parse(t[1], 1, We);
            if (!a) return null;
            const c = t[2];
            if (typeof c != "object" || Array.isArray(c)) return r.error("NumberFormat options argument must be an object.");
            let p = null;
            if (c.locale && (p = r.parse(c.locale, 1, Ot), !p)) return null;
            let f = null;
            if (c.currency && (f = r.parse(c.currency, 1, Ot), !f)) return null;
            let _ = null;
            if (c["min-fraction-digits"] && (_ = r.parse(c["min-fraction-digits"], 1, We), !_)) return null;
            let v = null;
            return c["max-fraction-digits"] && (v = r.parse(c["max-fraction-digits"], 1, We), !v) ? null : new gc(a, p, f, _, v)
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
              style: this.currency ? "currency" : "decimal",
              currency: this.currency ? this.currency.evaluate(t) : void 0,
              minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
              maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
            }).format(this.number.evaluate(t))
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits)
          }
          outputDefined() {
            return !1
          }
        }
        class fs {
          constructor(t) {
            this.type = Pi, this.sections = t
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const a = t[1];
            if (!Array.isArray(a) && typeof a == "object") return r.error("First argument must be an image or text section.");
            const c = [];
            let p = !1;
            for (let f = 1; f <= t.length - 1; ++f) {
              const _ = t[f];
              if (p && typeof _ == "object" && !Array.isArray(_)) {
                p = !1;
                let v = null;
                if (_["font-scale"] && (v = r.parse(_["font-scale"], 1, We), !v)) return null;
                let S = null;
                if (_["text-font"] && (S = r.parse(_["text-font"], 1, Qr(Ot)), !S)) return null;
                let I = null;
                if (_["text-color"] && (I = r.parse(_["text-color"], 1, zr), !I)) return null;
                let E = null;
                if (_["vertical-align"]) {
                  if (typeof _["vertical-align"] == "string" && !Ni.includes(_["vertical-align"])) return r.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${_["vertical-align"]}' instead.`);
                  if (E = r.parse(_["vertical-align"], 1, Ot), !E) return null
                }
                const R = c[c.length - 1];
                R.scale = v, R.font = S, R.textColor = I, R.verticalAlign = E
              } else {
                const v = r.parse(t[f], 1, _r);
                if (!v) return null;
                const S = v.type.kind;
                if (S !== "string" && S !== "value" && S !== "null" && S !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                p = !0, c.push({
                  content: v,
                  scale: null,
                  font: null,
                  textColor: null,
                  verticalAlign: null
                })
              }
            }
            return new fs(c)
          }
          evaluate(t) {
            return new Ji(this.sections.map((r => {
              const a = r.content.evaluate(t);
              return wr(a) === rr ? new cn("", a, null, null, null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null) : new cn(Ur(a), null, r.scale ? r.scale.evaluate(t) : null, r.font ? r.font.evaluate(t).join(",") : null, r.textColor ? r.textColor.evaluate(t) : null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null)
            })))
          }
          eachChild(t) {
            for (const r of this.sections) t(r.content), r.scale && t(r.scale), r.font && t(r.font), r.textColor && t(r.textColor), r.verticalAlign && t(r.verticalAlign)
          }
          outputDefined() {
            return !1
          }
        }
        class vc {
          constructor(t) {
            this.type = rr, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected two arguments.");
            const a = r.parse(t[1], 1, Ot);
            return a ? new vc(a) : r.error("No image name provided.")
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              a = Nn.fromString(r);
            return a && t.availableImages && (a.available = t.availableImages.indexOf(r) > -1), a
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class il {
          constructor(t) {
            this.type = We, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1);
            return a ? a.type.kind !== "array" && a.type.kind !== "string" && a.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${Yr(a.type)} instead.`) : new il(a) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            if (typeof r == "string") return [...r].length;
            if (Array.isArray(r)) return r.length;
            throw new ci(`Expected value to be of type string or array, but found ${Yr(wr(r))} instead.`)
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        const ya = 8192;

        function Kd(i, t) {
          const r = (180 + i[0]) / 360,
            a = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360,
            c = Math.pow(2, t.z);
          return [Math.round(r * c * ya), Math.round(a * c * ya)]
        }

        function nl(i, t) {
          const r = Math.pow(2, t.z);
          return [(c = (i[0] / ya + t.x) / r, 360 * c - 180), (a = (i[1] / ya + t.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90)];
          var a, c
        }

        function vo(i, t) {
          i[0] = Math.min(i[0], t[0]), i[1] = Math.min(i[1], t[1]), i[2] = Math.max(i[2], t[0]), i[3] = Math.max(i[3], t[1])
        }

        function yo(i, t) {
          return !(i[0] <= t[0] || i[2] >= t[2] || i[1] <= t[1] || i[3] >= t[3])
        }

        function Yd(i, t, r) {
          const a = i[0] - t[0],
            c = i[1] - t[1],
            p = i[0] - r[0],
            f = i[1] - r[1];
          return a * f - p * c == 0 && a * p <= 0 && c * f <= 0
        }

        function al(i, t, r, a) {
          return (c = [a[0] - r[0], a[1] - r[1]])[0] * (p = [t[0] - i[0], t[1] - i[1]])[1] - c[1] * p[0] != 0 && !(!gh(i, t, r, a) || !gh(r, a, i, t));
          var c, p
        }

        function Jd(i, t, r) {
          for (const a of r)
            for (let c = 0; c < a.length - 1; ++c)
              if (al(i, t, a[c], a[c + 1])) return !0;
          return !1
        }

        function ms(i, t, r = !1) {
          let a = !1;
          for (const _ of t)
            for (let v = 0; v < _.length - 1; v++) {
              if (Yd(i, _[v], _[v + 1])) return r;
              (p = _[v])[1] > (c = i)[1] != (f = _[v + 1])[1] > c[1] && c[0] < (f[0] - p[0]) * (c[1] - p[1]) / (f[1] - p[1]) + p[0] && (a = !a)
            }
          var c, p, f;
          return a
        }

        function _h(i, t) {
          for (const r of t)
            if (ms(i, r)) return !0;
          return !1
        }

        function yc(i, t) {
          for (const r of i)
            if (!ms(r, t)) return !1;
          for (let r = 0; r < i.length - 1; ++r)
            if (Jd(i[r], i[r + 1], t)) return !1;
          return !0
        }

        function Qd(i, t) {
          for (const r of t)
            if (yc(i, r)) return !0;
          return !1
        }

        function gh(i, t, r, a) {
          const c = a[0] - r[0],
            p = a[1] - r[1],
            f = (i[0] - r[0]) * p - c * (i[1] - r[1]),
            _ = (t[0] - r[0]) * p - c * (t[1] - r[1]);
          return f > 0 && _ < 0 || f < 0 && _ > 0
        }

        function xc(i, t, r) {
          const a = [];
          for (let c = 0; c < i.length; c++) {
            const p = [];
            for (let f = 0; f < i[c].length; f++) {
              const _ = Kd(i[c][f], r);
              vo(t, _), p.push(_)
            }
            a.push(p)
          }
          return a
        }

        function vh(i, t, r) {
          const a = [];
          for (let c = 0; c < i.length; c++) {
            const p = xc(i[c], t, r);
            a.push(p)
          }
          return a
        }

        function sl(i, t, r, a) {
          if (i[0] < r[0] || i[0] > r[2]) {
            const c = .5 * a;
            let p = i[0] - r[0] > c ? -a : r[0] - i[0] > c ? a : 0;
            p === 0 && (p = i[0] - r[2] > c ? -a : r[2] - i[0] > c ? a : 0), i[0] += p
          }
          vo(t, i)
        }

        function yh(i, t, r, a) {
          const c = Math.pow(2, a.z) * ya,
            p = [a.x * ya, a.y * ya],
            f = [];
          for (const _ of i)
            for (const v of _) {
              const S = [v.x + p[0], v.y + p[1]];
              sl(S, t, r, c), f.push(S)
            }
          return f
        }

        function xh(i, t, r, a) {
          const c = Math.pow(2, a.z) * ya,
            p = [a.x * ya, a.y * ya],
            f = [];
          for (const v of i) {
            const S = [];
            for (const I of v) {
              const E = [I.x + p[0], I.y + p[1]];
              vo(t, E), S.push(E)
            }
            f.push(S)
          }
          if (t[2] - t[0] <= c / 2) {
            (_ = t)[0] = _[1] = 1 / 0, _[2] = _[3] = -1 / 0;
            for (const v of f)
              for (const S of v) sl(S, t, r, c)
          }
          var _;
          return f
        }
        class _s {
          constructor(t, r) {
            this.type = $t, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Ua(t[1])) {
              const a = t[1];
              if (a.type === "FeatureCollection") {
                const c = [];
                for (const p of a.features) {
                  const {
                    type: f,
                    coordinates: _
                  } = p.geometry;
                  f === "Polygon" && c.push(_), f === "MultiPolygon" && c.push(..._)
                }
                if (c.length) return new _s(a, {
                  type: "MultiPolygon",
                  coordinates: c
                })
              } else if (a.type === "Feature") {
                const c = a.geometry.type;
                if (c === "Polygon" || c === "MultiPolygon") return new _s(a, a.geometry)
              } else if (a.type === "Polygon" || a.type === "MultiPolygon") return new _s(a, a)
            }
            return r.error("'within' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, a) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  p = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = r.canonicalID();
                if (a.type === "Polygon") {
                  const _ = xc(a.coordinates, p, f),
                    v = yh(r.geometry(), c, p, f);
                  if (!yo(c, p)) return !1;
                  for (const S of v)
                    if (!ms(S, _)) return !1
                }
                if (a.type === "MultiPolygon") {
                  const _ = vh(a.coordinates, p, f),
                    v = yh(r.geometry(), c, p, f);
                  if (!yo(c, p)) return !1;
                  for (const S of v)
                    if (!_h(S, _)) return !1
                }
                return !0
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, a) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  p = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = r.canonicalID();
                if (a.type === "Polygon") {
                  const _ = xc(a.coordinates, p, f),
                    v = xh(r.geometry(), c, p, f);
                  if (!yo(c, p)) return !1;
                  for (const S of v)
                    if (!yc(S, _)) return !1
                }
                if (a.type === "MultiPolygon") {
                  const _ = vh(a.coordinates, p, f),
                    v = xh(r.geometry(), c, p, f);
                  if (!yo(c, p)) return !1;
                  for (const S of v)
                    if (!Qd(S, _)) return !1
                }
                return !0
              })(t, this.geometries)
            }
            return !1
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        let bc = class {
          constructor(i = [], t = (r, a) => r < a ? -1 : r > a ? 1 : 0) {
            if (this.data = i, this.length = this.data.length, this.compare = t, this.length > 0)
              for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r)
          }
          push(i) {
            this.data.push(i), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const i = this.data[0],
              t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), i
          }
          peek() {
            return this.data[0]
          }
          _up(i) {
            const {
              data: t,
              compare: r
            } = this, a = t[i];
            for (; i > 0;) {
              const c = i - 1 >> 1,
                p = t[c];
              if (r(a, p) >= 0) break;
              t[i] = p, i = c
            }
            t[i] = a
          }
          _down(i) {
            const {
              data: t,
              compare: r
            } = this, a = this.length >> 1, c = t[i];
            for (; i < a;) {
              let p = 1 + (i << 1);
              const f = p + 1;
              if (f < this.length && r(t[f], t[p]) < 0 && (p = f), r(t[p], c) >= 0) break;
              t[i] = t[p], i = p
            }
            t[i] = c
          }
        };

        function wc(i, t, r = 0, a = i.length - 1, c = ep) {
          for (; a > r;) {
            if (a - r > 600) {
              const v = a - r + 1,
                S = t - r + 1,
                I = Math.log(v),
                E = .5 * Math.exp(2 * I / 3),
                R = .5 * Math.sqrt(I * E * (v - E) / v) * (S - v / 2 < 0 ? -1 : 1);
              wc(i, t, Math.max(r, Math.floor(t - S * E / v + R)), Math.min(a, Math.floor(t + (v - S) * E / v + R)), c)
            }
            const p = i[t];
            let f = r,
              _ = a;
            for (xo(i, r, t), c(i[a], p) > 0 && xo(i, r, a); f < _;) {
              for (xo(i, f, _), f++, _--; c(i[f], p) < 0;) f++;
              for (; c(i[_], p) > 0;) _--
            }
            c(i[r], p) === 0 ? xo(i, r, _) : (_++, xo(i, _, a)), _ <= t && (r = _ + 1), t <= _ && (a = _ - 1)
          }
        }

        function xo(i, t, r) {
          const a = i[t];
          i[t] = i[r], i[r] = a
        }

        function ep(i, t) {
          return i < t ? -1 : i > t ? 1 : 0
        }

        function bo(i, t) {
          if (i.length <= 1) return [i];
          const r = [];
          let a, c;
          for (const p of i) {
            const f = tp(p);
            f !== 0 && (p.area = Math.abs(f), c === void 0 && (c = f < 0), c === f < 0 ? (a && r.push(a), a = [p]) : a.push(p))
          }
          if (a && r.push(a), t > 1)
            for (let p = 0; p < r.length; p++) r[p].length <= t || (wc(r[p], t, 1, r[p].length - 1, bh), r[p] = r[p].slice(0, t));
          return r
        }

        function bh(i, t) {
          return t.area - i.area
        }

        function tp(i) {
          let t = 0;
          for (let r, a, c = 0, p = i.length, f = p - 1; c < p; f = c++) r = i[c], a = i[f], t += (a.x - r.x) * (r.y + a.y);
          return t
        }
        const wh = 1 / 298.257223563,
          Th = wh * (2 - wh),
          Tc = Math.PI / 180;
        class Cc {
          constructor(t) {
            const r = 6378.137 * Tc * 1e3,
              a = Math.cos(t * Tc),
              c = 1 / (1 - Th * (1 - a * a)),
              p = Math.sqrt(c);
            this.kx = r * p * a, this.ky = r * p * c * (1 - Th)
          }
          distance(t, r) {
            const a = this.wrap(t[0] - r[0]) * this.kx,
              c = (t[1] - r[1]) * this.ky;
            return Math.sqrt(a * a + c * c)
          }
          pointOnLine(t, r) {
            let a, c, p, f, _ = 1 / 0;
            for (let v = 0; v < t.length - 1; v++) {
              let S = t[v][0],
                I = t[v][1],
                E = this.wrap(t[v + 1][0] - S) * this.kx,
                R = (t[v + 1][1] - I) * this.ky,
                O = 0;
              E === 0 && R === 0 || (O = (this.wrap(r[0] - S) * this.kx * E + (r[1] - I) * this.ky * R) / (E * E + R * R), O > 1 ? (S = t[v + 1][0], I = t[v + 1][1]) : O > 0 && (S += E / this.kx * O, I += R / this.ky * O)), E = this.wrap(r[0] - S) * this.kx, R = (r[1] - I) * this.ky;
              const j = E * E + R * R;
              j < _ && (_ = j, a = S, c = I, p = v, f = O)
            }
            return {
              point: [a, c],
              index: p,
              t: Math.max(0, Math.min(1, f))
            }
          }
          wrap(t) {
            for (; t < -180;) t += 360;
            for (; t > 180;) t -= 360;
            return t
          }
        }

        function Ch(i, t) {
          return t[0] - i[0]
        }

        function ol(i) {
          return i[1] - i[0] + 1
        }

        function Za(i, t) {
          return i[1] >= i[0] && i[1] < t
        }

        function xi(i, t) {
          if (i[0] > i[1]) return [null, null];
          const r = ol(i);
          if (t) {
            if (r === 2) return [i, null];
            const c = Math.floor(r / 2);
            return [
              [i[0], i[0] + c],
              [i[0] + c, i[1]]
            ]
          }
          if (r === 1) return [i, null];
          const a = Math.floor(r / 2) - 1;
          return [
            [i[0], i[0] + a],
            [i[0] + a + 1, i[1]]
          ]
        }

        function Sc(i, t) {
          if (!Za(t, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let a = t[0]; a <= t[1]; ++a) vo(r, i[a]);
          return r
        }

        function Pc(i) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const r of i)
            for (const a of r) vo(t, a);
          return t
        }

        function Sh(i) {
          return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0
        }

        function Ic(i, t, r) {
          if (!Sh(i) || !Sh(t)) return NaN;
          let a = 0,
            c = 0;
          return i[2] < t[0] && (a = t[0] - i[2]), i[0] > t[2] && (a = i[0] - t[2]), i[1] > t[3] && (c = i[1] - t[3]), i[3] < t[1] && (c = t[1] - i[3]), r.distance([0, 0], [a, c])
        }

        function gs(i, t, r) {
          const a = r.pointOnLine(t, i);
          return r.distance(i, a.point)
        }

        function Mc(i, t, r, a, c) {
          const p = Math.min(gs(i, [r, a], c), gs(t, [r, a], c)),
            f = Math.min(gs(r, [i, t], c), gs(a, [i, t], c));
          return Math.min(p, f)
        }

        function rp(i, t, r, a, c) {
          if (!Za(t, i.length) || !Za(a, r.length)) return 1 / 0;
          let p = 1 / 0;
          for (let f = t[0]; f < t[1]; ++f) {
            const _ = i[f],
              v = i[f + 1];
            for (let S = a[0]; S < a[1]; ++S) {
              const I = r[S],
                E = r[S + 1];
              if (al(_, v, I, E)) return 0;
              p = Math.min(p, Mc(_, v, I, E, c))
            }
          }
          return p
        }

        function ip(i, t, r, a, c) {
          if (!Za(t, i.length) || !Za(a, r.length)) return NaN;
          let p = 1 / 0;
          for (let f = t[0]; f <= t[1]; ++f)
            for (let _ = a[0]; _ <= a[1]; ++_)
              if (p = Math.min(p, c.distance(i[f], r[_])), p === 0) return p;
          return p
        }

        function np(i, t, r) {
          if (ms(i, t, !0)) return 0;
          let a = 1 / 0;
          for (const c of t) {
            const p = c[0],
              f = c[c.length - 1];
            if (p !== f && (a = Math.min(a, gs(i, [f, p], r)), a === 0)) return a;
            const _ = r.pointOnLine(c, i);
            if (a = Math.min(a, r.distance(i, _.point)), a === 0) return a
          }
          return a
        }

        function ap(i, t, r, a) {
          if (!Za(t, i.length)) return NaN;
          for (let p = t[0]; p <= t[1]; ++p)
            if (ms(i[p], r, !0)) return 0;
          let c = 1 / 0;
          for (let p = t[0]; p < t[1]; ++p) {
            const f = i[p],
              _ = i[p + 1];
            for (const v of r)
              for (let S = 0, I = v.length, E = I - 1; S < I; E = S++) {
                const R = v[E],
                  O = v[S];
                if (al(f, _, R, O)) return 0;
                c = Math.min(c, Mc(f, _, R, O, a))
              }
          }
          return c
        }

        function Ph(i, t) {
          for (const r of i)
            for (const a of r)
              if (ms(a, t, !0)) return !0;
          return !1
        }

        function sp(i, t, r, a = 1 / 0) {
          const c = Pc(i),
            p = Pc(t);
          if (a !== 1 / 0 && Ic(c, p, r) >= a) return a;
          if (yo(c, p)) {
            if (Ph(i, t)) return 0
          } else if (Ph(t, i)) return 0;
          let f = 1 / 0;
          for (const _ of i)
            for (let v = 0, S = _.length, I = S - 1; v < S; I = v++) {
              const E = _[I],
                R = _[v];
              for (const O of t)
                for (let j = 0, Z = O.length, Y = Z - 1; j < Z; Y = j++) {
                  const ne = O[Y],
                    ke = O[j];
                  if (al(E, R, ne, ke)) return 0;
                  f = Math.min(f, Mc(E, R, ne, ke, r))
                }
            }
          return f
        }

        function Ih(i, t, r, a, c, p) {
          if (!p) return;
          const f = Ic(Sc(a, p), c, r);
          f < t && i.push([f, p, [0, 0]])
        }

        function ll(i, t, r, a, c, p, f) {
          if (!p || !f) return;
          const _ = Ic(Sc(a, p), Sc(c, f), r);
          _ < t && i.push([_, p, f])
        }

        function cl(i, t, r, a, c = 1 / 0) {
          let p = Math.min(a.distance(i[0], r[0][0]), c);
          if (p === 0) return p;
          const f = new bc([
              [0, [0, i.length - 1],
                [0, 0]
              ]
            ], Ch),
            _ = Pc(r);
          for (; f.length > 0;) {
            const v = f.pop();
            if (v[0] >= p) continue;
            const S = v[1],
              I = t ? 50 : 100;
            if (ol(S) <= I) {
              if (!Za(S, i.length)) return NaN;
              if (t) {
                const E = ap(i, S, r, a);
                if (isNaN(E) || E === 0) return E;
                p = Math.min(p, E)
              } else
                for (let E = S[0]; E <= S[1]; ++E) {
                  const R = np(i[E], r, a);
                  if (p = Math.min(p, R), p === 0) return 0
                }
            } else {
              const E = xi(S, t);
              Ih(f, p, a, i, _, E[0]), Ih(f, p, a, i, _, E[1])
            }
          }
          return p
        }

        function ul(i, t, r, a, c, p = 1 / 0) {
          let f = Math.min(p, c.distance(i[0], r[0]));
          if (f === 0) return f;
          const _ = new bc([
            [0, [0, i.length - 1],
              [0, r.length - 1]
            ]
          ], Ch);
          for (; _.length > 0;) {
            const v = _.pop();
            if (v[0] >= f) continue;
            const S = v[1],
              I = v[2],
              E = t ? 50 : 100,
              R = a ? 50 : 100;
            if (ol(S) <= E && ol(I) <= R) {
              if (!Za(S, i.length) && Za(I, r.length)) return NaN;
              let O;
              if (t && a) O = rp(i, S, r, I, c), f = Math.min(f, O);
              else if (t && !a) {
                const j = i.slice(S[0], S[1] + 1);
                for (let Z = I[0]; Z <= I[1]; ++Z)
                  if (O = gs(r[Z], j, c), f = Math.min(f, O), f === 0) return f
              } else if (!t && a) {
                const j = r.slice(I[0], I[1] + 1);
                for (let Z = S[0]; Z <= S[1]; ++Z)
                  if (O = gs(i[Z], j, c), f = Math.min(f, O), f === 0) return f
              } else O = ip(i, S, r, I, c), f = Math.min(f, O)
            } else {
              const O = xi(S, t),
                j = xi(I, a);
              ll(_, f, c, i, r, O[0], j[0]), ll(_, f, c, i, r, O[0], j[1]), ll(_, f, c, i, r, O[1], j[0]), ll(_, f, c, i, r, O[1], j[1])
            }
          }
          return f
        }

        function Ac(i) {
          return i.type === "MultiPolygon" ? i.coordinates.map((t => ({
            type: "Polygon",
            coordinates: t
          }))) : i.type === "MultiLineString" ? i.coordinates.map((t => ({
            type: "LineString",
            coordinates: t
          }))) : i.type === "MultiPoint" ? i.coordinates.map((t => ({
            type: "Point",
            coordinates: t
          }))) : [i]
        }
        class vs {
          constructor(t, r) {
            this.type = We, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'distance' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Ua(t[1])) {
              const a = t[1];
              if (a.type === "FeatureCollection") return new vs(a, a.features.map((c => Ac(c.geometry))).flat());
              if (a.type === "Feature") return new vs(a, Ac(a.geometry));
              if ("type" in a && "coordinates" in a) return new vs(a, Ac(a))
            }
            return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, a) {
                const c = r.geometry(),
                  p = c.flat().map((v => nl([v.x, v.y], r.canonical)));
                if (c.length === 0) return NaN;
                const f = new Cc(p[0][1]);
                let _ = 1 / 0;
                for (const v of a) {
                  switch (v.type) {
                    case "Point":
                      _ = Math.min(_, ul(p, !1, [v.coordinates], !1, f, _));
                      break;
                    case "LineString":
                      _ = Math.min(_, ul(p, !1, v.coordinates, !0, f, _));
                      break;
                    case "Polygon":
                      _ = Math.min(_, cl(p, !1, v.coordinates, f, _))
                  }
                  if (_ === 0) return _
                }
                return _
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, a) {
                const c = r.geometry(),
                  p = c.flat().map((v => nl([v.x, v.y], r.canonical)));
                if (c.length === 0) return NaN;
                const f = new Cc(p[0][1]);
                let _ = 1 / 0;
                for (const v of a) {
                  switch (v.type) {
                    case "Point":
                      _ = Math.min(_, ul(p, !0, [v.coordinates], !1, f, _));
                      break;
                    case "LineString":
                      _ = Math.min(_, ul(p, !0, v.coordinates, !0, f, _));
                      break;
                    case "Polygon":
                      _ = Math.min(_, cl(p, !0, v.coordinates, f, _))
                  }
                  if (_ === 0) return _
                }
                return _
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(r, a) {
                const c = r.geometry();
                if (c.length === 0 || c[0].length === 0) return NaN;
                const p = bo(c, 0).map((v => v.map((S => S.map((I => nl([I.x, I.y], r.canonical))))))),
                  f = new Cc(p[0][0][0][1]);
                let _ = 1 / 0;
                for (const v of a)
                  for (const S of p) {
                    switch (v.type) {
                      case "Point":
                        _ = Math.min(_, cl([v.coordinates], !1, S, f, _));
                        break;
                      case "LineString":
                        _ = Math.min(_, cl(v.coordinates, !0, S, f, _));
                        break;
                      case "Polygon":
                        _ = Math.min(_, sp(S, v.coordinates, f, _))
                    }
                    if (_ === 0) return _
                  }
                return _
              })(t, this.geometries)
            }
            return NaN
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        class wo {
          constructor(t) {
            this.type = _r, this.key = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const a = t[1];
            return a == null ? r.error("Global state property must be defined.") : typeof a != "string" ? r.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new wo(a)
          }
          evaluate(t) {
            var r;
            const a = (r = t.globals) === null || r === void 0 ? void 0 : r.globalState;
            return a && Object.keys(a).length !== 0 ? gi(a, this.key) : null
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        const Os = {
          "==": mh,
          "!=": tl,
          ">": _c,
          "<": Hd,
          ">=": Xd,
          "<=": Wd,
          array: ra,
          at: Qo,
          boolean: ra,
          case: Bs,
          coalesce: mo,
          collator: rl,
          format: fs,
          image: vc,
          in: el,
          "index-of": va,
          interpolate: Mn,
          "interpolate-hcl": Mn,
          "interpolate-lab": Mn,
          length: il,
          let: uo,
          literal: ga,
          match: yn,
          number: ra,
          "number-format": gc,
          object: ra,
          slice: ho,
          step: Wi,
          string: ra,
          "to-boolean": Ra,
          "to-color": Ra,
          "to-number": Ra,
          "to-string": Ra,
          var: Jo,
          within: _s,
          distance: vs,
          "global-state": wo
        };
        class ca {
          constructor(t, r, a, c) {
            this.name = t, this.type = r, this._evaluate = a, this.args = c
          }
          evaluate(t) {
            return this._evaluate(t, this.args)
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return !1
          }
          static parse(t, r) {
            const a = t[0],
              c = ca.definitions[a];
            if (!c) return r.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const p = Array.isArray(c) ? c[0] : c.type,
              f = Array.isArray(c) ? [
                [c[1], c[2]]
              ] : c.overloads,
              _ = f.filter((([S]) => !Array.isArray(S) || S.length === t.length - 1));
            let v = null;
            for (const [S, I] of _) {
              v = new Rs(r.registry, hl, r.path, null, r.scope);
              const E = [];
              let R = !1;
              for (let O = 1; O < t.length; O++) {
                const j = t[O],
                  Z = Array.isArray(S) ? S[O - 1] : S.type,
                  Y = v.parse(j, 1 + E.length, Z);
                if (!Y) {
                  R = !0;
                  break
                }
                E.push(Y)
              }
              if (!R)
                if (Array.isArray(S) && S.length !== E.length) v.error(`Expected ${S.length} arguments, but found ${E.length} instead.`);
                else {
                  for (let O = 0; O < E.length; O++) {
                    const j = Array.isArray(S) ? S[O] : S.type,
                      Z = E[O];
                    v.concat(O + 1).checkSubtype(j, Z.type)
                  }
                  if (v.errors.length === 0) return new ca(a, p, I, E)
                }
            }
            if (_.length === 1) r.errors.push(...v.errors);
            else {
              const S = (_.length ? _ : f).map((([E]) => {
                  return R = E, Array.isArray(R) ? `(${R.map(Yr).join(", ")})` : `(${Yr(R.type)}...)`;
                  var R
                })).join(" | "),
                I = [];
              for (let E = 1; E < t.length; E++) {
                const R = r.parse(t[E], 1 + I.length);
                if (!R) return null;
                I.push(Yr(R.type))
              }
              r.error(`Expected arguments of type ${S}, but found (${I.join(", ")}) instead.`)
            }
            return null
          }
          static register(t, r) {
            ca.definitions = r;
            for (const a in r) t[a] = ca
          }
        }

        function Mh(i, [t, r, a, c]) {
          t = t.evaluate(i), r = r.evaluate(i), a = a.evaluate(i);
          const p = c ? c.evaluate(i) : 1,
            f = Si(t, r, a, p);
          if (f) throw new ci(f);
          return new br(t / 255, r / 255, a / 255, p, !1)
        }

        function Ah(i, t) {
          return i in t
        }

        function kc(i, t) {
          const r = t[i];
          return r === void 0 ? null : r
        }

        function ys(i) {
          return {
            type: i
          }
        }

        function hl(i) {
          if (i instanceof Jo) return hl(i.boundExpression);
          if (i instanceof ca && i.name === "error" || i instanceof rl || i instanceof _s || i instanceof vs || i instanceof wo) return !1;
          const t = i instanceof Ra || i instanceof ra;
          let r = !0;
          return i.eachChild((a => {
            r = t ? r && hl(a) : r && a instanceof ga
          })), !!r && dl(i) && pl(i, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
        }

        function dl(i) {
          if (i instanceof ca && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof _s || i instanceof vs) return !1;
          let t = !0;
          return i.eachChild((r => {
            t && !dl(r) && (t = !1)
          })), t
        }

        function To(i) {
          if (i instanceof ca && i.name === "feature-state") return !1;
          let t = !0;
          return i.eachChild((r => {
            t && !To(r) && (t = !1)
          })), t
        }

        function pl(i, t) {
          if (i instanceof ca && t.indexOf(i.name) >= 0) return !1;
          let r = !0;
          return i.eachChild((a => {
            r && !pl(a, t) && (r = !1)
          })), r
        }

        function kh(i) {
          return {
            result: "success",
            value: i
          }
        }

        function Ns(i) {
          return {
            result: "error",
            value: i
          }
        }

        function ts(i) {
          return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven"
        }

        function Eh(i) {
          return !!i.expression && i.expression.parameters.indexOf("zoom") > -1
        }

        function Ec(i) {
          return !!i.expression && i.expression.interpolated
        }

        function ii(i) {
          return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i
        }

        function Co(i) {
          return typeof i == "object" && i !== null && !Array.isArray(i) && wr(i) === li
        }

        function op(i) {
          return i
        }

        function zh(i, t) {
          const r = i.stops && typeof i.stops[0][0] == "object",
            a = r || !(r || i.property !== void 0),
            c = i.type || (Ec(t) ? "exponential" : "interval"),
            p = (function(I) {
              switch (I.type) {
                case "color":
                  return br.parse;
                case "padding":
                  return Ui.parse;
                case "numberArray":
                  return Qi.parse;
                case "colorArray":
                  return Ci.parse;
                default:
                  return null
              }
            })(t);
          if (p && ((i = yi({}, i)).stops && (i.stops = i.stops.map((I => [I[0], p(I[1])]))), i.default = p(i.default ? i.default : t.default)), i.colorSpace && (f = i.colorSpace) !== "rgb" && f !== "hcl" && f !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
          var f;
          const _ = (function(I) {
            switch (I) {
              case "exponential":
                return Dh;
              case "interval":
                return lp;
              case "categorical":
                return Lh;
              case "identity":
                return cp;
              default:
                throw new Error(`Unknown function type "${I}"`)
            }
          })(c);
          let v, S;
          if (c === "categorical") {
            v = Object.create(null);
            for (const I of i.stops) v[I[0]] = I[1];
            S = typeof i.stops[0][0]
          }
          if (r) {
            const I = {},
              E = [];
            for (let j = 0; j < i.stops.length; j++) {
              const Z = i.stops[j],
                Y = Z[0].zoom;
              I[Y] === void 0 && (I[Y] = {
                zoom: Y,
                type: i.type,
                property: i.property,
                default: i.default,
                stops: []
              }, E.push(Y)), I[Y].stops.push([Z[0].value, Z[1]])
            }
            const R = [];
            for (const j of E) R.push([I[j].zoom, zh(I[j], t)]);
            const O = {
              name: "linear"
            };
            return {
              kind: "composite",
              interpolationType: O,
              interpolationFactor: Mn.interpolationFactor.bind(void 0, O),
              zoomStops: R.map((j => j[0])),
              evaluate: ({
                zoom: j
              }, Z) => Dh({
                stops: R,
                base: i.base
              }, t, j).evaluate(j, Z)
            }
          }
          if (a) {
            const I = c === "exponential" ? {
              name: "exponential",
              base: i.base !== void 0 ? i.base : 1
            } : null;
            return {
              kind: "camera",
              interpolationType: I,
              interpolationFactor: Mn.interpolationFactor.bind(void 0, I),
              zoomStops: i.stops.map((E => E[0])),
              evaluate: ({
                zoom: E
              }) => _(i, t, E, v, S)
            }
          }
          return {
            kind: "source",
            evaluate(I, E) {
              const R = E && E.properties ? E.properties[i.property] : void 0;
              return R === void 0 ? rs(i.default, t.default) : _(i, t, R, v, S)
            }
          }
        }

        function rs(i, t, r) {
          return i !== void 0 ? i : t !== void 0 ? t : r !== void 0 ? r : void 0
        }

        function Lh(i, t, r, a, c) {
          return rs(typeof r === c ? a[r] : void 0, i.default, t.default)
        }

        function lp(i, t, r) {
          if (ii(r) !== "number") return rs(i.default, t.default);
          const a = i.stops.length;
          if (a === 1 || r <= i.stops[0][0]) return i.stops[0][1];
          if (r >= i.stops[a - 1][0]) return i.stops[a - 1][1];
          const c = ps(i.stops.map((p => p[0])), r);
          return i.stops[c][1]
        }

        function Dh(i, t, r) {
          const a = i.base !== void 0 ? i.base : 1;
          if (ii(r) !== "number") return rs(i.default, t.default);
          const c = i.stops.length;
          if (c === 1 || r <= i.stops[0][0]) return i.stops[0][1];
          if (r >= i.stops[c - 1][0]) return i.stops[c - 1][1];
          const p = ps(i.stops.map((I => I[0])), r),
            f = (function(I, E, R, O) {
              const j = O - R,
                Z = I - R;
              return j === 0 ? 0 : E === 1 ? Z / j : (Math.pow(E, Z) - 1) / (Math.pow(E, j) - 1)
            })(r, a, i.stops[p][0], i.stops[p + 1][0]),
            _ = i.stops[p][1],
            v = i.stops[p + 1][1],
            S = Ba[t.type] || op;
          return typeof _.evaluate == "function" ? {
            evaluate(...I) {
              const E = _.evaluate.apply(void 0, I),
                R = v.evaluate.apply(void 0, I);
              if (E !== void 0 && R !== void 0) return S(E, R, f, i.colorSpace)
            }
          } : S(_, v, f, i.colorSpace)
        }

        function cp(i, t, r) {
          switch (t.type) {
            case "color":
              r = br.parse(r);
              break;
            case "formatted":
              r = Ji.fromString(r.toString());
              break;
            case "resolvedImage":
              r = Nn.fromString(r.toString());
              break;
            case "padding":
              r = Ui.parse(r);
              break;
            case "colorArray":
              r = Ci.parse(r);
              break;
            case "numberArray":
              r = Qi.parse(r);
              break;
            default:
              ii(r) === t.type || t.type === "enum" && t.values[r] || (r = void 0)
          }
          return rs(r, i.default, t.default)
        }
        ca.register(Os, {
          error: [{
              kind: "error"
            },
            [Ot], (i, [t]) => {
              throw new ci(t.evaluate(i))
            }
          ],
          typeof: [Ot, [_r], (i, [t]) => Yr(wr(t.evaluate(i)))],
          "to-rgba": [Qr(We, 4), [zr], (i, [t]) => {
            const [r, a, c, p] = t.evaluate(i).rgb;
            return [255 * r, 255 * a, 255 * c, p]
          }],
          rgb: [zr, [We, We, We], Mh],
          rgba: [zr, [We, We, We, We], Mh],
          has: {
            type: $t,
            overloads: [
              [
                [Ot], (i, [t]) => Ah(t.evaluate(i), i.properties())
              ],
              [
                [Ot, li], (i, [t, r]) => Ah(t.evaluate(i), r.evaluate(i))
              ]
            ]
          },
          get: {
            type: _r,
            overloads: [
              [
                [Ot], (i, [t]) => kc(t.evaluate(i), i.properties())
              ],
              [
                [Ot, li], (i, [t, r]) => kc(t.evaluate(i), r.evaluate(i))
              ]
            ]
          },
          "feature-state": [_r, [Ot], (i, [t]) => kc(t.evaluate(i), i.featureState || {})],
          properties: [li, [], i => i.properties()],
          "geometry-type": [Ot, [], i => i.geometryType()],
          id: [_r, [], i => i.id()],
          zoom: [We, [], i => i.globals.zoom],
          "heatmap-density": [We, [], i => i.globals.heatmapDensity || 0],
          elevation: [We, [], i => i.globals.elevation || 0],
          "line-progress": [We, [], i => i.globals.lineProgress || 0],
          accumulated: [_r, [], i => i.globals.accumulated === void 0 ? null : i.globals.accumulated],
          "+": [We, ys(We), (i, t) => {
            let r = 0;
            for (const a of t) r += a.evaluate(i);
            return r
          }],
          "*": [We, ys(We), (i, t) => {
            let r = 1;
            for (const a of t) r *= a.evaluate(i);
            return r
          }],
          "-": {
            type: We,
            overloads: [
              [
                [We, We], (i, [t, r]) => t.evaluate(i) - r.evaluate(i)
              ],
              [
                [We], (i, [t]) => -t.evaluate(i)
              ]
            ]
          },
          "/": [We, [We, We], (i, [t, r]) => t.evaluate(i) / r.evaluate(i)],
          "%": [We, [We, We], (i, [t, r]) => t.evaluate(i) % r.evaluate(i)],
          ln2: [We, [], () => Math.LN2],
          pi: [We, [], () => Math.PI],
          e: [We, [], () => Math.E],
          "^": [We, [We, We], (i, [t, r]) => Math.pow(t.evaluate(i), r.evaluate(i))],
          sqrt: [We, [We], (i, [t]) => Math.sqrt(t.evaluate(i))],
          log10: [We, [We], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN10],
          ln: [We, [We], (i, [t]) => Math.log(t.evaluate(i))],
          log2: [We, [We], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN2],
          sin: [We, [We], (i, [t]) => Math.sin(t.evaluate(i))],
          cos: [We, [We], (i, [t]) => Math.cos(t.evaluate(i))],
          tan: [We, [We], (i, [t]) => Math.tan(t.evaluate(i))],
          asin: [We, [We], (i, [t]) => Math.asin(t.evaluate(i))],
          acos: [We, [We], (i, [t]) => Math.acos(t.evaluate(i))],
          atan: [We, [We], (i, [t]) => Math.atan(t.evaluate(i))],
          min: [We, ys(We), (i, t) => Math.min(...t.map((r => r.evaluate(i))))],
          max: [We, ys(We), (i, t) => Math.max(...t.map((r => r.evaluate(i))))],
          abs: [We, [We], (i, [t]) => Math.abs(t.evaluate(i))],
          round: [We, [We], (i, [t]) => {
            const r = t.evaluate(i);
            return r < 0 ? -Math.round(-r) : Math.round(r)
          }],
          floor: [We, [We], (i, [t]) => Math.floor(t.evaluate(i))],
          ceil: [We, [We], (i, [t]) => Math.ceil(t.evaluate(i))],
          "filter-==": [$t, [Ot, _r], (i, [t, r]) => i.properties()[t.value] === r.value],
          "filter-id-==": [$t, [_r], (i, [t]) => i.id() === t.value],
          "filter-type-==": [$t, [Ot], (i, [t]) => i.geometryType() === t.value],
          "filter-<": [$t, [Ot, _r], (i, [t, r]) => {
            const a = i.properties()[t.value],
              c = r.value;
            return typeof a == typeof c && a < c
          }],
          "filter-id-<": [$t, [_r], (i, [t]) => {
            const r = i.id(),
              a = t.value;
            return typeof r == typeof a && r < a
          }],
          "filter->": [$t, [Ot, _r], (i, [t, r]) => {
            const a = i.properties()[t.value],
              c = r.value;
            return typeof a == typeof c && a > c
          }],
          "filter-id->": [$t, [_r], (i, [t]) => {
            const r = i.id(),
              a = t.value;
            return typeof r == typeof a && r > a
          }],
          "filter-<=": [$t, [Ot, _r], (i, [t, r]) => {
            const a = i.properties()[t.value],
              c = r.value;
            return typeof a == typeof c && a <= c
          }],
          "filter-id-<=": [$t, [_r], (i, [t]) => {
            const r = i.id(),
              a = t.value;
            return typeof r == typeof a && r <= a
          }],
          "filter->=": [$t, [Ot, _r], (i, [t, r]) => {
            const a = i.properties()[t.value],
              c = r.value;
            return typeof a == typeof c && a >= c
          }],
          "filter-id->=": [$t, [_r], (i, [t]) => {
            const r = i.id(),
              a = t.value;
            return typeof r == typeof a && r >= a
          }],
          "filter-has": [$t, [_r], (i, [t]) => t.value in i.properties()],
          "filter-has-id": [$t, [], i => i.id() !== null && i.id() !== void 0],
          "filter-type-in": [$t, [Qr(Ot)], (i, [t]) => t.value.indexOf(i.geometryType()) >= 0],
          "filter-id-in": [$t, [Qr(_r)], (i, [t]) => t.value.indexOf(i.id()) >= 0],
          "filter-in-small": [$t, [Ot, Qr(_r)], (i, [t, r]) => r.value.indexOf(i.properties()[t.value]) >= 0],
          "filter-in-large": [$t, [Ot, Qr(_r)], (i, [t, r]) => (function(a, c, p, f) {
            for (; p <= f;) {
              const _ = p + f >> 1;
              if (c[_] === a) return !0;
              c[_] > a ? f = _ - 1 : p = _ + 1
            }
            return !1
          })(i.properties()[t.value], r.value, 0, r.value.length - 1)],
          all: {
            type: $t,
            overloads: [
              [
                [$t, $t], (i, [t, r]) => t.evaluate(i) && r.evaluate(i)
              ],
              [ys($t), (i, t) => {
                for (const r of t)
                  if (!r.evaluate(i)) return !1;
                return !0
              }]
            ]
          },
          any: {
            type: $t,
            overloads: [
              [
                [$t, $t], (i, [t, r]) => t.evaluate(i) || r.evaluate(i)
              ],
              [ys($t), (i, t) => {
                for (const r of t)
                  if (r.evaluate(i)) return !0;
                return !1
              }]
            ]
          },
          "!": [$t, [$t], (i, [t]) => !t.evaluate(i)],
          "is-supported-script": [$t, [Ot], (i, [t]) => {
            const r = i.globals && i.globals.isSupportedScript;
            return !r || r(t.evaluate(i))
          }],
          upcase: [Ot, [Ot], (i, [t]) => t.evaluate(i).toUpperCase()],
          downcase: [Ot, [Ot], (i, [t]) => t.evaluate(i).toLowerCase()],
          concat: [Ot, ys(_r), (i, t) => t.map((r => Ur(r.evaluate(i)))).join("")],
          "resolved-locale": [Ot, [Ti], (i, [t]) => t.evaluate(i).resolvedLocale()]
        });
        class zc {
          constructor(t, r) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new fc, this._defaultValue = r ? (function(a) {
              if (a.type === "color" && Co(a.default)) return new br(0, 0, 0, 0);
              switch (a.type) {
                case "color":
                  return br.parse(a.default) || null;
                case "padding":
                  return Ui.parse(a.default) || null;
                case "numberArray":
                  return Qi.parse(a.default) || null;
                case "colorArray":
                  return Ci.parse(a.default) || null;
                case "variableAnchorOffsetCollection":
                  return un.parse(a.default) || null;
                case "projectionDefinition":
                  return hn.parse(a.default) || null;
                default:
                  return a.default === void 0 ? null : a.default
              }
            })(r) : null, this._enumValues = r && r.type === "enum" ? r.values : null
          }
          evaluateWithoutErrorHandling(t, r, a, c, p, f) {
            return this._evaluator.globals = t, this._evaluator.feature = r, this._evaluator.featureState = a, this._evaluator.canonical = c, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = f, this.expression.evaluate(this._evaluator)
          }
          evaluate(t, r, a, c, p, f) {
            this._evaluator.globals = t, this._evaluator.feature = r || null, this._evaluator.featureState = a || null, this._evaluator.canonical = c, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = f || null;
            try {
              const _ = this.expression.evaluate(this._evaluator);
              if (_ == null || typeof _ == "number" && _ != _) return this._defaultValue;
              if (this._enumValues && !(_ in this._enumValues)) throw new ci(`Expected value to be one of ${Object.keys(this._enumValues).map((v=>JSON.stringify(v))).join(", ")}, but found ${JSON.stringify(_)} instead.`);
              return _
            } catch (_) {
              return this._warningHistory[_.message] || (this._warningHistory[_.message] = !0, typeof console < "u" && console.warn(_.message)), this._defaultValue
            }
          }
        }

        function fl(i) {
          return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in Os
        }

        function So(i, t) {
          const r = new Rs(Os, hl, [], t ? (function(c) {
              const p = {
                color: zr,
                string: Ot,
                number: We,
                enum: Ot,
                boolean: $t,
                formatted: Pi,
                padding: Li,
                numberArray: Di,
                colorArray: mi,
                projectionDefinition: Wr,
                resolvedImage: rr,
                variableAnchorOffsetCollection: bi
              };
              return c.type === "array" ? Qr(p[c.value] || _r, c.length) : p[c.type]
            })(t) : void 0),
            a = r.parse(i, void 0, void 0, void 0, t && t.type === "string" ? {
              typeAnnotation: "coerce"
            } : void 0);
          return a ? kh(new zc(a, t)) : Ns(r.errors)
        }
        class Po {
          constructor(t, r) {
            this.kind = t, this._styleExpression = r, this.isStateDependent = t !== "constant" && !To(r.expression), this.globalStateRefs = Ao(r.expression)
          }
          evaluateWithoutErrorHandling(t, r, a, c, p, f) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, r, a, c, p, f)
          }
          evaluate(t, r, a, c, p, f) {
            return this._styleExpression.evaluate(t, r, a, c, p, f)
          }
        }
        class Lc {
          constructor(t, r, a, c) {
            this.kind = t, this.zoomStops = a, this._styleExpression = r, this.isStateDependent = t !== "camera" && !To(r.expression), this.globalStateRefs = Ao(r.expression), this.interpolationType = c
          }
          evaluateWithoutErrorHandling(t, r, a, c, p, f) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, r, a, c, p, f)
          }
          evaluate(t, r, a, c, p, f) {
            return this._styleExpression.evaluate(t, r, a, c, p, f)
          }
          interpolationFactor(t, r, a) {
            return this.interpolationType ? Mn.interpolationFactor(this.interpolationType, t, r, a) : 0
          }
        }

        function Rh(i, t) {
          const r = So(i, t);
          if (r.result === "error") return r;
          const a = r.value.expression,
            c = dl(a);
          if (!c && !ts(t)) return Ns([new pi("", "data expressions not supported")]);
          const p = pl(a, ["zoom"]);
          if (!p && !Eh(t)) return Ns([new pi("", "zoom expressions not supported")]);
          const f = Mo(a);
          return f || p ? f instanceof pi ? Ns([f]) : f instanceof Mn && !Ec(t) ? Ns([new pi("", '"interpolate" expressions cannot be used with this property')]) : kh(f ? new Lc(c ? "camera" : "composite", r.value, f.labels, f instanceof Mn ? f.interpolation : void 0) : new Po(c ? "constant" : "source", r.value)) : Ns([new pi("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
        }
        class Io {
          constructor(t, r) {
            this._parameters = t, this._specification = r, yi(this, zh(this._parameters, this._specification))
          }
          static deserialize(t) {
            return new Io(t._parameters, t._specification)
          }
          static serialize(t) {
            return {
              _parameters: t._parameters,
              _specification: t._specification
            }
          }
        }

        function Mo(i) {
          let t = null;
          if (i instanceof uo) t = Mo(i.result);
          else if (i instanceof mo) {
            for (const r of i.args)
              if (t = Mo(r), t) break
          } else(i instanceof Wi || i instanceof Mn) && i.input instanceof ca && i.input.name === "zoom" && (t = i);
          return t instanceof pi || i.eachChild((r => {
            const a = Mo(r);
            a instanceof pi ? t = a : !t && a ? t = new pi("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && a && t !== a && (t = new pi("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
          })), t
        }

        function Ao(i, t = new Set) {
          return i instanceof wo && t.add(i.key), i.eachChild((r => {
            Ao(r, t)
          })), t
        }

        function ml(i) {
          if (i === !0 || i === !1) return !0;
          if (!Array.isArray(i) || i.length === 0) return !1;
          switch (i[0]) {
            case "has":
              return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
            case "in":
              return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
            case "any":
            case "all":
              for (const t of i.slice(1))
                if (!ml(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0
          }
        }
        const Dc = {
          type: "boolean",
          default: !1,
          transition: !1,
          "property-type": "data-driven",
          expression: {
            interpolated: !1,
            parameters: ["zoom", "feature"]
          }
        };

        function xs(i) {
          if (i == null) return {
            filter: () => !0,
            needGeometry: !1,
            getGlobalStateRefs: () => new Set
          };
          ml(i) || (i = bs(i));
          const t = So(i, Dc);
          if (t.result === "error") throw new Error(t.value.map((r => `${r.key}: ${r.message}`)).join(", "));
          return {
            filter: (r, a, c) => t.value.evaluate(r, a, {}, c),
            needGeometry: _l(i),
            getGlobalStateRefs: () => Ao(t.value.expression)
          }
        }

        function Rc(i, t) {
          return i < t ? -1 : i > t ? 1 : 0
        }

        function _l(i) {
          if (!Array.isArray(i)) return !1;
          if (i[0] === "within" || i[0] === "distance") return !0;
          for (let t = 1; t < i.length; t++)
            if (_l(i[t])) return !0;
          return !1
        }

        function bs(i) {
          if (!i) return !0;
          const t = i[0];
          return i.length <= 1 ? t !== "any" : t === "==" ? Bc(i[1], i[2], "==") : t === "!=" ? gl(Bc(i[1], i[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Bc(i[1], i[2], t) : t === "any" ? (r = i.slice(1), ["any"].concat(r.map(bs))) : t === "all" ? ["all"].concat(i.slice(1).map(bs)) : t === "none" ? ["all"].concat(i.slice(1).map(bs).map(gl)) : t === "in" ? Bh(i[1], i.slice(2)) : t === "!in" ? gl(Bh(i[1], i.slice(2))) : t === "has" ? Fh(i[1]) : t !== "!has" || gl(Fh(i[1]));
          var r
        }

        function Bc(i, t, r) {
          switch (i) {
            case "$type":
              return [`filter-type-${r}`, t];
            case "$id":
              return [`filter-id-${r}`, t];
            default:
              return [`filter-${r}`, i, t]
          }
        }

        function Bh(i, t) {
          if (t.length === 0) return !1;
          switch (i) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some((r => typeof r != typeof t[0])) ? ["filter-in-large", i, ["literal", t.sort(Rc)]] : ["filter-in-small", i, ["literal", t]]
          }
        }

        function Fh(i) {
          switch (i) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", i]
          }
        }

        function gl(i) {
          return ["!", i]
        }

        function Fc(i) {
          const t = typeof i;
          if (t === "number" || t === "boolean" || t === "string" || i == null) return JSON.stringify(i);
          if (Array.isArray(i)) {
            let c = "[";
            for (const p of i) c += `${Fc(p)},`;
            return `${c}]`
          }
          const r = Object.keys(i).sort();
          let a = "{";
          for (let c = 0; c < r.length; c++) a += `${JSON.stringify(r[c])}:${Fc(i[r[c]])},`;
          return `${a}}`
        }

        function up(i) {
          let t = "";
          for (const r of Xt) t += `/${Fc(i[r])}`;
          return t
        }

        function Oc(i) {
          const t = i.value;
          return t ? [new ft(i.key, t, "constants have been deprecated as of v8")] : []
        }

        function Zi(i) {
          return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i
        }

        function Fa(i) {
          if (Array.isArray(i)) return i.map(Fa);
          if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
            const t = {};
            for (const r in i) t[r] = Fa(i[r]);
            return t
          }
          return Zi(i)
        }

        function ua(i) {
          const t = i.key,
            r = i.value,
            a = i.valueSpec || {},
            c = i.objectElementValidators || {},
            p = i.style,
            f = i.styleSpec,
            _ = i.validateSpec;
          let v = [];
          const S = ii(r);
          if (S !== "object") return [new ft(t, r, `object expected, ${S} found`)];
          for (const I in r) {
            const E = I.split(".")[0],
              R = gi(a, E) || a["*"];
            let O;
            if (gi(c, E)) O = c[E];
            else if (gi(a, E)) O = _;
            else if (c["*"]) O = c["*"];
            else {
              if (!a["*"]) {
                v.push(new ft(t, r[I], `unknown property "${I}"`));
                continue
              }
              O = _
            }
            v = v.concat(O({
              key: (t && `${t}.`) + I,
              value: r[I],
              valueSpec: R,
              style: p,
              styleSpec: f,
              object: r,
              objectKey: I,
              validateSpec: _
            }, r))
          }
          for (const I in a) c[I] || a[I].required && a[I].default === void 0 && r[I] === void 0 && v.push(new ft(t, r, `missing required property "${I}"`));
          return v
        }

        function vl(i) {
          const t = i.value,
            r = i.valueSpec,
            a = i.style,
            c = i.styleSpec,
            p = i.key,
            f = i.arrayElementValidator || i.validateSpec;
          if (ii(t) !== "array") return [new ft(p, t, `array expected, ${ii(t)} found`)];
          if (r.length && t.length !== r.length) return [new ft(p, t, `array length ${r.length} expected, length ${t.length} found`)];
          if (r["min-length"] && t.length < r["min-length"]) return [new ft(p, t, `array length at least ${r["min-length"]} expected, length ${t.length} found`)];
          let _ = {
            type: r.value,
            values: r.values
          };
          c.$version < 7 && (_.function = r.function), ii(r.value) === "object" && (_ = r.value);
          let v = [];
          for (let S = 0; S < t.length; S++) v = v.concat(f({
            array: t,
            arrayIndex: S,
            value: t[S],
            valueSpec: _,
            validateSpec: i.validateSpec,
            style: a,
            styleSpec: c,
            key: `${p}[${S}]`
          }));
          return v
        }

        function ko(i) {
          const t = i.key,
            r = i.value,
            a = i.valueSpec;
          let c = ii(r);
          return c === "number" && r != r && (c = "NaN"), c !== "number" ? [new ft(t, r, `number expected, ${c} found`)] : "minimum" in a && r < a.minimum ? [new ft(t, r, `${r} is less than the minimum value ${a.minimum}`)] : "maximum" in a && r > a.maximum ? [new ft(t, r, `${r} is greater than the maximum value ${a.maximum}`)] : []
        }

        function Oh(i) {
          const t = i.valueSpec,
            r = Zi(i.value.type);
          let a, c, p, f = {};
          const _ = r !== "categorical" && i.value.property === void 0,
            v = !_,
            S = ii(i.value.stops) === "array" && ii(i.value.stops[0]) === "array" && ii(i.value.stops[0][0]) === "object",
            I = ua({
              key: i.key,
              value: i.value,
              valueSpec: i.styleSpec.function,
              validateSpec: i.validateSpec,
              style: i.style,
              styleSpec: i.styleSpec,
              objectElementValidators: {
                stops: function(O) {
                  if (r === "identity") return [new ft(O.key, O.value, 'identity function may not have a "stops" property')];
                  let j = [];
                  const Z = O.value;
                  return j = j.concat(vl({
                    key: O.key,
                    value: Z,
                    valueSpec: O.valueSpec,
                    validateSpec: O.validateSpec,
                    style: O.style,
                    styleSpec: O.styleSpec,
                    arrayElementValidator: E
                  })), ii(Z) === "array" && Z.length === 0 && j.push(new ft(O.key, Z, "array must have at least one stop")), j
                },
                default: function(O) {
                  return O.validateSpec({
                    key: O.key,
                    value: O.value,
                    valueSpec: t,
                    validateSpec: O.validateSpec,
                    style: O.style,
                    styleSpec: O.styleSpec
                  })
                }
              }
            });
          return r === "identity" && _ && I.push(new ft(i.key, i.value, 'missing required property "property"')), r === "identity" || i.value.stops || I.push(new ft(i.key, i.value, 'missing required property "stops"')), r === "exponential" && i.valueSpec.expression && !Ec(i.valueSpec) && I.push(new ft(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (v && !ts(i.valueSpec) ? I.push(new ft(i.key, i.value, "property functions not supported")) : _ && !Eh(i.valueSpec) && I.push(new ft(i.key, i.value, "zoom functions not supported"))), r !== "categorical" && !S || i.value.property !== void 0 || I.push(new ft(i.key, i.value, '"property" property is required')), I;

          function E(O) {
            let j = [];
            const Z = O.value,
              Y = O.key;
            if (ii(Z) !== "array") return [new ft(Y, Z, `array expected, ${ii(Z)} found`)];
            if (Z.length !== 2) return [new ft(Y, Z, `array length 2 expected, length ${Z.length} found`)];
            if (S) {
              if (ii(Z[0]) !== "object") return [new ft(Y, Z, `object expected, ${ii(Z[0])} found`)];
              if (Z[0].zoom === void 0) return [new ft(Y, Z, "object stop key must have zoom")];
              if (Z[0].value === void 0) return [new ft(Y, Z, "object stop key must have value")];
              if (p && p > Zi(Z[0].zoom)) return [new ft(Y, Z[0].zoom, "stop zoom values must appear in ascending order")];
              Zi(Z[0].zoom) !== p && (p = Zi(Z[0].zoom), c = void 0, f = {}), j = j.concat(ua({
                key: `${Y}[0]`,
                value: Z[0],
                valueSpec: {
                  zoom: {}
                },
                validateSpec: O.validateSpec,
                style: O.style,
                styleSpec: O.styleSpec,
                objectElementValidators: {
                  zoom: ko,
                  value: R
                }
              }))
            } else j = j.concat(R({
              key: `${Y}[0]`,
              value: Z[0],
              validateSpec: O.validateSpec,
              style: O.style,
              styleSpec: O.styleSpec
            }, Z));
            return fl(Fa(Z[1])) ? j.concat([new ft(`${Y}[1]`, Z[1], "expressions are not allowed in function stops.")]) : j.concat(O.validateSpec({
              key: `${Y}[1]`,
              value: Z[1],
              valueSpec: t,
              validateSpec: O.validateSpec,
              style: O.style,
              styleSpec: O.styleSpec
            }))
          }

          function R(O, j) {
            const Z = ii(O.value),
              Y = Zi(O.value),
              ne = O.value !== null ? O.value : j;
            if (a) {
              if (Z !== a) return [new ft(O.key, ne, `${Z} stop domain type must match previous stop domain type ${a}`)]
            } else a = Z;
            if (Z !== "number" && Z !== "string" && Z !== "boolean") return [new ft(O.key, ne, "stop domain value must be a number, string, or boolean")];
            if (Z !== "number" && r !== "categorical") {
              let ke = `number expected, ${Z} found`;
              return ts(t) && r === void 0 && (ke += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ft(O.key, ne, ke)]
            }
            return r !== "categorical" || Z !== "number" || isFinite(Y) && Math.floor(Y) === Y ? r !== "categorical" && Z === "number" && c !== void 0 && Y < c ? [new ft(O.key, ne, "stop domain values must appear in ascending order")] : (c = Y, r === "categorical" && Y in f ? [new ft(O.key, ne, "stop domain values must be unique")] : (f[Y] = !0, [])) : [new ft(O.key, ne, `integer expected, found ${Y}`)]
          }
        }

        function ws(i) {
          const t = (i.expressionContext === "property" ? Rh : So)(Fa(i.value), i.valueSpec);
          if (t.result === "error") return t.value.map((a => new ft(`${i.key}${a.key}`, i.value, a.message)));
          const r = t.value.expression || t.value._styleExpression.expression;
          if (i.expressionContext === "property" && i.propertyKey === "text-font" && !r.outputDefined()) return [new ft(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (i.expressionContext === "property" && i.propertyType === "layout" && !To(r)) return [new ft(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (i.expressionContext === "filter" && !To(r)) return [new ft(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
          if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
            if (!pl(r, ["zoom", "feature-state"])) return [new ft(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (i.expressionContext === "cluster-initial" && !dl(r)) return [new ft(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
          }
          return []
        }

        function yl(i) {
          const t = i.key,
            r = i.value,
            a = ii(r);
          return a !== "string" ? [new ft(t, r, `color expected, ${a} found`)] : br.parse(String(r)) ? [] : [new ft(t, r, `color expected, "${r}" found`)]
        }

        function $a(i) {
          const t = i.key,
            r = i.value,
            a = i.valueSpec,
            c = [];
          return Array.isArray(a.values) ? a.values.indexOf(Zi(r)) === -1 && c.push(new ft(t, r, `expected one of [${a.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(a.values).indexOf(Zi(r)) === -1 && c.push(new ft(t, r, `expected one of [${Object.keys(a.values).join(", ")}], ${JSON.stringify(r)} found`)), c
        }

        function Nc(i) {
          return ml(Fa(i.value)) ? ws(yi({}, i, {
            expressionContext: "filter",
            valueSpec: {
              value: "boolean"
            }
          })) : Nh(i)
        }

        function Nh(i) {
          const t = i.value,
            r = i.key;
          if (ii(t) !== "array") return [new ft(r, t, `array expected, ${ii(t)} found`)];
          const a = i.styleSpec;
          let c, p = [];
          if (t.length < 1) return [new ft(r, t, "filter array must have at least 1 element")];
          switch (p = p.concat($a({
              key: `${r}[0]`,
              value: t[0],
              valueSpec: a.filter_operator,
              style: i.style,
              styleSpec: i.styleSpec
            })), Zi(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && Zi(t[1]) === "$type" && p.push(new ft(r, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && p.push(new ft(r, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (c = ii(t[1]), c !== "string" && p.push(new ft(`${r}[1]`, t[1], `string expected, ${c} found`)));
              for (let f = 2; f < t.length; f++) c = ii(t[f]), Zi(t[1]) === "$type" ? p = p.concat($a({
                key: `${r}[${f}]`,
                value: t[f],
                valueSpec: a.geometry_type,
                style: i.style,
                styleSpec: i.styleSpec
              })) : c !== "string" && c !== "number" && c !== "boolean" && p.push(new ft(`${r}[${f}]`, t[f], `string, number, or boolean expected, ${c} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let f = 1; f < t.length; f++) p = p.concat(Nh({
                key: `${r}[${f}]`,
                value: t[f],
                style: i.style,
                styleSpec: i.styleSpec
              }));
              break;
            case "has":
            case "!has":
              c = ii(t[1]), t.length !== 2 ? p.push(new ft(r, t, `filter array for "${t[0]}" operator must have 2 elements`)) : c !== "string" && p.push(new ft(`${r}[1]`, t[1], `string expected, ${c} found`))
          }
          return p
        }

        function jh(i, t) {
          const r = i.key,
            a = i.validateSpec,
            c = i.style,
            p = i.styleSpec,
            f = i.value,
            _ = i.objectKey,
            v = p[`${t}_${i.layerType}`];
          if (!v) return [];
          const S = _.match(/^(.*)-transition$/);
          if (t === "paint" && S && v[S[1]] && v[S[1]].transition) return a({
            key: r,
            value: f,
            valueSpec: p.transition,
            style: c,
            styleSpec: p
          });
          const I = i.valueSpec || v[_];
          if (!I) return [new ft(r, f, `unknown property "${_}"`)];
          let E;
          if (ii(f) === "string" && ts(I) && !I.tokens && (E = /^{([^}]+)}$/.exec(f))) return [new ft(r, f, `"${_}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(E[1])} }\`.`)];
          const R = [];
          return i.layerType === "symbol" && (_ === "text-field" && c && !c.glyphs && R.push(new ft(r, f, 'use of "text-field" requires a style "glyphs" property')), _ === "text-font" && Co(Fa(f)) && Zi(f.type) === "identity" && R.push(new ft(r, f, '"text-font" does not support identity functions'))), R.concat(a({
            key: i.key,
            value: f,
            valueSpec: I,
            style: c,
            styleSpec: p,
            expressionContext: "property",
            propertyType: t,
            propertyKey: _
          }))
        }

        function qh(i) {
          return jh(i, "paint")
        }

        function Vh(i) {
          return jh(i, "layout")
        }

        function Uh(i) {
          let t = [];
          const r = i.value,
            a = i.key,
            c = i.style,
            p = i.styleSpec;
          if (ii(r) !== "object") return [new ft(a, r, `object expected, ${ii(r)} found`)];
          r.type || r.ref || t.push(new ft(a, r, 'either "type" or "ref" is required'));
          let f = Zi(r.type);
          const _ = Zi(r.ref);
          if (r.id) {
            const v = Zi(r.id);
            for (let S = 0; S < i.arrayIndex; S++) {
              const I = c.layers[S];
              Zi(I.id) === v && t.push(new ft(a, r.id, `duplicate layer id "${r.id}", previously used at line ${I.id.__line__}`))
            }
          }
          if ("ref" in r) {
            let v;
            ["type", "source", "source-layer", "filter", "layout"].forEach((S => {
              S in r && t.push(new ft(a, r[S], `"${S}" is prohibited for ref layers`))
            })), c.layers.forEach((S => {
              Zi(S.id) === _ && (v = S)
            })), v ? v.ref ? t.push(new ft(a, r.ref, "ref cannot reference another ref layer")) : f = Zi(v.type) : t.push(new ft(a, r.ref, `ref layer "${_}" not found`))
          } else if (f !== "background")
            if (r.source) {
              const v = c.sources && c.sources[r.source],
                S = v && Zi(v.type);
              v ? S === "vector" && f === "raster" ? t.push(new ft(a, r.source, `layer "${r.id}" requires a raster source`)) : S !== "raster-dem" && f === "hillshade" || S !== "raster-dem" && f === "color-relief" ? t.push(new ft(a, r.source, `layer "${r.id}" requires a raster-dem source`)) : S === "raster" && f !== "raster" ? t.push(new ft(a, r.source, `layer "${r.id}" requires a vector source`)) : S !== "vector" || r["source-layer"] ? S === "raster-dem" && f !== "hillshade" && f !== "color-relief" ? t.push(new ft(a, r.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : f !== "line" || !r.paint || !r.paint["line-gradient"] || S === "geojson" && v.lineMetrics || t.push(new ft(a, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new ft(a, r, `layer "${r.id}" must specify a "source-layer"`)) : t.push(new ft(a, r.source, `source "${r.source}" not found`))
            } else t.push(new ft(a, r, 'missing required property "source"'));
          return t = t.concat(ua({
            key: a,
            value: r,
            valueSpec: p.layer,
            style: i.style,
            styleSpec: i.styleSpec,
            validateSpec: i.validateSpec,
            objectElementValidators: {
              "*": () => [],
              type: () => i.validateSpec({
                key: `${a}.type`,
                value: r.type,
                valueSpec: p.layer.type,
                style: i.style,
                styleSpec: i.styleSpec,
                validateSpec: i.validateSpec,
                object: r,
                objectKey: "type"
              }),
              filter: Nc,
              layout: v => ua({
                layer: r,
                key: v.key,
                value: v.value,
                style: v.style,
                styleSpec: v.styleSpec,
                validateSpec: v.validateSpec,
                objectElementValidators: {
                  "*": S => Vh(yi({
                    layerType: f
                  }, S))
                }
              }),
              paint: v => ua({
                layer: r,
                key: v.key,
                value: v.value,
                style: v.style,
                styleSpec: v.styleSpec,
                validateSpec: v.validateSpec,
                objectElementValidators: {
                  "*": S => qh(yi({
                    layerType: f
                  }, S))
                }
              })
            }
          })), t
        }

        function xa(i) {
          const t = i.value,
            r = i.key,
            a = ii(t);
          return a !== "string" ? [new ft(r, t, `string expected, ${a} found`)] : []
        }
        const js = {
          promoteId: function({
            key: i,
            value: t
          }) {
            if (ii(t) === "string") return xa({
              key: i,
              value: t
            });
            {
              const r = [];
              for (const a in t) r.push(...xa({
                key: `${i}.${a}`,
                value: t[a]
              }));
              return r
            }
          }
        };

        function Xn(i) {
          const t = i.value,
            r = i.key,
            a = i.styleSpec,
            c = i.style,
            p = i.validateSpec;
          if (!t.type) return [new ft(r, t, '"type" is required')];
          const f = Zi(t.type);
          let _;
          switch (f) {
            case "vector":
            case "raster":
              return _ = ua({
                key: r,
                value: t,
                valueSpec: a[`source_${f.replace("-","_")}`],
                style: i.style,
                styleSpec: a,
                objectElementValidators: js,
                validateSpec: p
              }), _;
            case "raster-dem":
              return _ = (function(v) {
                var S;
                const I = (S = v.sourceName) !== null && S !== void 0 ? S : "",
                  E = v.value,
                  R = v.styleSpec,
                  O = R.source_raster_dem,
                  j = v.style;
                let Z = [];
                const Y = ii(E);
                if (E === void 0) return Z;
                if (Y !== "object") return Z.push(new ft("source_raster_dem", E, `object expected, ${Y} found`)), Z;
                const ne = Zi(E.encoding) === "custom",
                  ke = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                  pe = v.value.encoding ? `"${v.value.encoding}"` : "Default";
                for (const be in E) !ne && ke.includes(be) ? Z.push(new ft(be, E[be], `In "${I}": "${be}" is only valid when "encoding" is set to "custom". ${pe} encoding found`)) : O[be] ? Z = Z.concat(v.validateSpec({
                  key: be,
                  value: E[be],
                  valueSpec: O[be],
                  validateSpec: v.validateSpec,
                  style: j,
                  styleSpec: R
                })) : Z.push(new ft(be, E[be], `unknown property "${be}"`));
                return Z
              })({
                sourceName: r,
                value: t,
                style: i.style,
                styleSpec: a,
                validateSpec: p
              }), _;
            case "geojson":
              if (_ = ua({
                  key: r,
                  value: t,
                  valueSpec: a.source_geojson,
                  style: c,
                  styleSpec: a,
                  validateSpec: p,
                  objectElementValidators: js
                }), t.cluster)
                for (const v in t.clusterProperties) {
                  const [S, I] = t.clusterProperties[v], E = typeof S == "string" ? [S, ["accumulated"],
                    ["get", v]
                  ] : S;
                  _.push(...ws({
                    key: `${r}.${v}.map`,
                    value: I,
                    expressionContext: "cluster-map"
                  })), _.push(...ws({
                    key: `${r}.${v}.reduce`,
                    value: E,
                    expressionContext: "cluster-reduce"
                  }))
                }
              return _;
            case "video":
              return ua({
                key: r,
                value: t,
                valueSpec: a.source_video,
                style: c,
                validateSpec: p,
                styleSpec: a
              });
            case "image":
              return ua({
                key: r,
                value: t,
                valueSpec: a.source_image,
                style: c,
                validateSpec: p,
                styleSpec: a
              });
            case "canvas":
              return [new ft(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return $a({
                key: `${r}.type`,
                value: t.type,
                valueSpec: {
                  values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                }
              })
          }
        }

        function qs(i) {
          const t = i.value,
            r = i.styleSpec,
            a = r.light,
            c = i.style;
          let p = [];
          const f = ii(t);
          if (t === void 0) return p;
          if (f !== "object") return p = p.concat([new ft("light", t, `object expected, ${f} found`)]), p;
          for (const _ in t) {
            const v = _.match(/^(.*)-transition$/);
            p = p.concat(v && a[v[1]] && a[v[1]].transition ? i.validateSpec({
              key: _,
              value: t[_],
              valueSpec: r.transition,
              validateSpec: i.validateSpec,
              style: c,
              styleSpec: r
            }) : a[_] ? i.validateSpec({
              key: _,
              value: t[_],
              valueSpec: a[_],
              validateSpec: i.validateSpec,
              style: c,
              styleSpec: r
            }) : [new ft(_, t[_], `unknown property "${_}"`)])
          }
          return p
        }

        function jc(i) {
          const t = i.value,
            r = i.styleSpec,
            a = r.sky,
            c = i.style,
            p = ii(t);
          if (t === void 0) return [];
          if (p !== "object") return [new ft("sky", t, `object expected, ${p} found`)];
          let f = [];
          for (const _ in t) f = f.concat(a[_] ? i.validateSpec({
            key: _,
            value: t[_],
            valueSpec: a[_],
            style: c,
            styleSpec: r
          }) : [new ft(_, t[_], `unknown property "${_}"`)]);
          return f
        }

        function Zh(i) {
          const t = i.value,
            r = i.styleSpec,
            a = r.terrain,
            c = i.style;
          let p = [];
          const f = ii(t);
          if (t === void 0) return p;
          if (f !== "object") return p = p.concat([new ft("terrain", t, `object expected, ${f} found`)]), p;
          for (const _ in t) p = p.concat(a[_] ? i.validateSpec({
            key: _,
            value: t[_],
            valueSpec: a[_],
            validateSpec: i.validateSpec,
            style: c,
            styleSpec: r
          }) : [new ft(_, t[_], `unknown property "${_}"`)]);
          return p
        }

        function $h(i) {
          let t = [];
          const r = i.value,
            a = i.key;
          if (Array.isArray(r)) {
            const c = [],
              p = [];
            for (const f in r) r[f].id && c.includes(r[f].id) && t.push(new ft(a, r, `all the sprites' ids must be unique, but ${r[f].id} is duplicated`)), c.push(r[f].id), r[f].url && p.includes(r[f].url) && t.push(new ft(a, r, `all the sprites' URLs must be unique, but ${r[f].url} is duplicated`)), p.push(r[f].url), t = t.concat(ua({
              key: `${a}[${f}]`,
              value: r[f],
              valueSpec: {
                id: {
                  type: "string",
                  required: !0
                },
                url: {
                  type: "string",
                  required: !0
                }
              },
              validateSpec: i.validateSpec
            }));
            return t
          }
          return xa({
            key: a,
            value: r
          })
        }

        function Vs(i) {
          return t = i.value, t && t.constructor === Object ? [] : [new ft(i.key, i.value, `object expected, ${ii(i.value)} found`)];
          var t
        }
        const qc = {
          "*": () => [],
          array: vl,
          boolean: function(i) {
            const t = i.value,
              r = i.key,
              a = ii(t);
            return a !== "boolean" ? [new ft(r, t, `boolean expected, ${a} found`)] : []
          },
          number: ko,
          color: yl,
          constants: Oc,
          enum: $a,
          filter: Nc,
          function: Oh,
          layer: Uh,
          object: ua,
          source: Xn,
          light: qs,
          sky: jc,
          terrain: Zh,
          projection: function(i) {
            const t = i.value,
              r = i.styleSpec,
              a = r.projection,
              c = i.style,
              p = ii(t);
            if (t === void 0) return [];
            if (p !== "object") return [new ft("projection", t, `object expected, ${p} found`)];
            let f = [];
            for (const _ in t) f = f.concat(a[_] ? i.validateSpec({
              key: _,
              value: t[_],
              valueSpec: a[_],
              style: c,
              styleSpec: r
            }) : [new ft(_, t[_], `unknown property "${_}"`)]);
            return f
          },
          projectionDefinition: function(i) {
            const t = i.key;
            let r = i.value;
            r = r instanceof String ? r.valueOf() : r;
            const a = ii(r);
            return a !== "array" || (function(c) {
              return Array.isArray(c) && c.length === 3 && typeof c[0] == "string" && typeof c[1] == "string" && typeof c[2] == "number"
            })(r) || (function(c) {
              return !!["interpolate", "step", "literal"].includes(c[0])
            })(r) ? ["array", "string"].includes(a) ? [] : [new ft(t, r, `projection expected, invalid type "${a}" found`)] : [new ft(t, r, `projection expected, invalid array ${JSON.stringify(r)} found`)]
          },
          string: xa,
          formatted: function(i) {
            return xa(i).length === 0 ? [] : ws(i)
          },
          resolvedImage: function(i) {
            return xa(i).length === 0 ? [] : ws(i)
          },
          padding: function(i) {
            const t = i.key,
              r = i.value;
            if (ii(r) === "array") {
              if (r.length < 1 || r.length > 4) return [new ft(t, r, `padding requires 1 to 4 values; ${r.length} values found`)];
              const a = {
                type: "number"
              };
              let c = [];
              for (let p = 0; p < r.length; p++) c = c.concat(i.validateSpec({
                key: `${t}[${p}]`,
                value: r[p],
                validateSpec: i.validateSpec,
                valueSpec: a
              }));
              return c
            }
            return ko({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          numberArray: function(i) {
            const t = i.key,
              r = i.value;
            if (ii(r) === "array") {
              const a = {
                type: "number"
              };
              if (r.length < 1) return [new ft(t, r, "array length at least 1 expected, length 0 found")];
              let c = [];
              for (let p = 0; p < r.length; p++) c = c.concat(i.validateSpec({
                key: `${t}[${p}]`,
                value: r[p],
                validateSpec: i.validateSpec,
                valueSpec: a
              }));
              return c
            }
            return ko({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          colorArray: function(i) {
            const t = i.key,
              r = i.value;
            if (ii(r) === "array") {
              if (r.length < 1) return [new ft(t, r, "array length at least 1 expected, length 0 found")];
              let a = [];
              for (let c = 0; c < r.length; c++) a = a.concat(yl({
                key: `${t}[${c}]`,
                value: r[c]
              }));
              return a
            }
            return yl({
              key: t,
              value: r
            })
          },
          variableAnchorOffsetCollection: function(i) {
            const t = i.key,
              r = i.value,
              a = ii(r),
              c = i.styleSpec;
            if (a !== "array" || r.length < 1 || r.length % 2 != 0) return [new ft(t, r, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let p = [];
            for (let f = 0; f < r.length; f += 2) p = p.concat($a({
              key: `${t}[${f}]`,
              value: r[f],
              valueSpec: c.layout_symbol["text-anchor"]
            })), p = p.concat(vl({
              key: `${t}[${f+1}]`,
              value: r[f + 1],
              valueSpec: {
                length: 2,
                value: "number"
              },
              validateSpec: i.validateSpec,
              style: i.style,
              styleSpec: c
            }));
            return p
          },
          sprite: $h,
          state: Vs
        };

        function Us(i) {
          const t = i.value,
            r = i.valueSpec,
            a = i.styleSpec;
          return i.validateSpec = Us, r.expression && Co(Zi(t)) ? Oh(i) : r.expression && fl(Fa(t)) ? ws(i) : r.type && qc[r.type] ? qc[r.type](i) : ua(yi({}, i, {
            valueSpec: r.type ? a[r.type] : r
          }))
        }

        function Gh(i) {
          const t = i.value,
            r = i.key,
            a = xa(i);
          return a.length || (t.indexOf("{fontstack}") === -1 && a.push(new ft(r, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && a.push(new ft(r, t, '"glyphs" url must include a "{range}" token'))), a
        }

        function Kn(i, t = ye) {
          let r = [];
          return r = r.concat(Us({
            key: "",
            value: i,
            valueSpec: t.$root,
            styleSpec: t,
            style: i,
            validateSpec: Us,
            objectElementValidators: {
              glyphs: Gh,
              "*": () => []
            }
          })), i.constants && (r = r.concat(Oc({
            key: "constants",
            value: i.constants
          }))), Zs(r)
        }

        function ba(i) {
          return function(t) {
            return i({
              ...t,
              validateSpec: Us
            })
          }
        }

        function Zs(i) {
          return [].concat(i).sort(((t, r) => t.line - r.line))
        }

        function wa(i) {
          return function(...t) {
            return Zs(i.apply(this, t))
          }
        }
        Kn.source = wa(ba(Xn)), Kn.sprite = wa(ba($h)), Kn.glyphs = wa(ba(Gh)), Kn.light = wa(ba(qs)), Kn.sky = wa(ba(jc)), Kn.terrain = wa(ba(Zh)), Kn.state = wa(ba(Vs)), Kn.layer = wa(ba(Uh)), Kn.filter = wa(ba(Nc)), Kn.paintProperty = wa(ba(qh)), Kn.layoutProperty = wa(ba(Vh));
        const $s = Kn,
          hp = $s.light,
          Eo = $s.sky,
          dp = $s.paintProperty,
          pp = $s.layoutProperty;

        function zo(i, t) {
          let r = !1;
          if (t && t.length)
            for (const a of t) i.fire(new $e(new Error(a.message))), r = !0;
          return r
        }
        class Lo {
          constructor(t, r, a) {
            const c = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const f = new Int32Array(this.arrayBuffer);
              t = f[0], this.d = (r = f[1]) + 2 * (a = f[2]);
              for (let v = 0; v < this.d * this.d; v++) {
                const S = f[3 + v],
                  I = f[3 + v + 1];
                c.push(S === I ? null : f.subarray(S, I))
              }
              const _ = f[3 + c.length + 1];
              this.keys = f.subarray(f[3 + c.length], _), this.bboxes = f.subarray(_), this.insert = this._insertReadonly
            } else {
              this.d = r + 2 * a;
              for (let f = 0; f < this.d * this.d; f++) c.push([]);
              this.keys = [], this.bboxes = []
            }
            this.n = r, this.extent = t, this.padding = a, this.scale = r / t, this.uid = 0;
            const p = a / r * t;
            this.min = -p, this.max = t + p
          }
          insert(t, r, a, c, p) {
            this._forEachCell(r, a, c, p, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(r), this.bboxes.push(a), this.bboxes.push(c), this.bboxes.push(p)
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
          }
          _insertCell(t, r, a, c, p, f) {
            this.cells[p].push(f)
          }
          query(t, r, a, c, p) {
            const f = this.min,
              _ = this.max;
            if (t <= f && r <= f && _ <= a && _ <= c && !p) return Array.prototype.slice.call(this.keys);
            {
              const v = [];
              return this._forEachCell(t, r, a, c, this._queryCell, v, {}, p), v
            }
          }
          _queryCell(t, r, a, c, p, f, _, v) {
            const S = this.cells[p];
            if (S !== null) {
              const I = this.keys,
                E = this.bboxes;
              for (let R = 0; R < S.length; R++) {
                const O = S[R];
                if (_[O] === void 0) {
                  const j = 4 * O;
                  (v ? v(E[j + 0], E[j + 1], E[j + 2], E[j + 3]) : t <= E[j + 2] && r <= E[j + 3] && a >= E[j + 0] && c >= E[j + 1]) ? (_[O] = !0, f.push(I[O])) : _[O] = !1
                }
              }
            }
          }
          _forEachCell(t, r, a, c, p, f, _, v) {
            const S = this._convertToCellCoord(t),
              I = this._convertToCellCoord(r),
              E = this._convertToCellCoord(a),
              R = this._convertToCellCoord(c);
            for (let O = S; O <= E; O++)
              for (let j = I; j <= R; j++) {
                const Z = this.d * j + O;
                if ((!v || v(this._convertFromCellCoord(O), this._convertFromCellCoord(j), this._convertFromCellCoord(O + 1), this._convertFromCellCoord(j + 1))) && p.call(this, t, r, a, c, Z, f, _, v)) return
              }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells,
              r = 3 + this.cells.length + 1 + 1;
            let a = 0;
            for (let f = 0; f < this.cells.length; f++) a += this.cells[f].length;
            const c = new Int32Array(r + a + this.keys.length + this.bboxes.length);
            c[0] = this.extent, c[1] = this.n, c[2] = this.padding;
            let p = r;
            for (let f = 0; f < t.length; f++) {
              const _ = t[f];
              c[3 + f] = p, c.set(_, p), p += _.length
            }
            return c[3 + t.length] = p, c.set(this.keys, p), p += this.keys.length, c[3 + t.length + 1] = p, c.set(this.bboxes, p), p += this.bboxes.length, c.buffer
          }
          static serialize(t, r) {
            const a = t.toArrayBuffer();
            return r && r.push(a), {
              buffer: a
            }
          }
          static deserialize(t) {
            return new Lo(t.buffer)
          }
        }
        const Ta = {};

        function Wt(i, t, r = {}) {
          if (Ta[i]) throw new Error(`${i} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", {
            value: i,
            writeable: !1
          }), Ta[i] = {
            klass: t,
            omit: r.omit || [],
            shallow: r.shallow || []
          }
        }
        Wt("Object", Object), Wt("Set", Set), Wt("TransferableGridIndex", Lo), Wt("Color", br), Wt("Error", Error), Wt("AJAXError", X), Wt("ResolvedImage", Nn), Wt("StylePropertyFunction", Io), Wt("StyleExpression", zc, {
          omit: ["_evaluator"]
        }), Wt("ZoomDependentExpression", Lc), Wt("ZoomConstantExpression", Po), Wt("CompoundExpression", ca, {
          omit: ["_evaluate"]
        });
        for (const i in Os) Os[i]._classRegistryKey || Wt(`Expression_${i}`, Os[i]);

        function Vc(i) {
          return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer")
        }

        function xl(i) {
          return i.$name || i.constructor._classRegistryKey
        }

        function Uc(i) {
          return !(function(t) {
            if (t === null || typeof t != "object") return !1;
            const r = xl(t);
            return !(!r || r === "Object")
          })(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || Vc(i) || nr(i) || ArrayBuffer.isView(i) || i instanceof ImageData)
        }

        function Gs(i, t) {
          if (Uc(i)) return (Vc(i) || nr(i)) && t && t.push(i), ArrayBuffer.isView(i) && t && t.push(i.buffer), i instanceof ImageData && t && t.push(i.data.buffer), i;
          if (Array.isArray(i)) {
            const p = [];
            for (const f of i) p.push(Gs(f, t));
            return p
          }
          if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
          const r = xl(i);
          if (!r) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
          if (!Ta[r]) throw new Error(`${r} is not registered.`);
          const {
            klass: a
          } = Ta[r], c = a.serialize ? a.serialize(i, t) : {};
          if (a.serialize) {
            if (t && c === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property")
          } else {
            for (const p in i) {
              if (!i.hasOwnProperty(p) || Ta[r].omit.indexOf(p) >= 0) continue;
              const f = i[p];
              c[p] = Ta[r].shallow.indexOf(p) >= 0 ? f : Gs(f, t)
            }
            i instanceof Error && (c.message = i.message)
          }
          if (c.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return r !== "Object" && (c.$name = r), c
        }

        function Ts(i) {
          if (Uc(i)) return i;
          if (Array.isArray(i)) return i.map(Ts);
          if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
          const t = xl(i) || "Object";
          if (!Ta[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const {
            klass: r
          } = Ta[t];
          if (!r) throw new Error(`can't deserialize unregistered class ${t}`);
          if (r.deserialize) return r.deserialize(i);
          const a = Object.create(r.prototype);
          for (const c of Object.keys(i)) {
            if (c === "$name") continue;
            const p = i[c];
            a[c] = Ta[t].shallow.indexOf(c) >= 0 ? p : Ts(p)
          }
          return a
        }
        class bl {
          constructor() {
            this.first = !0
          }
          update(t, r) {
            const a = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = a, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = a, !0) : (this.lastFloorZoom > a ? (this.lastIntegerZoom = a + 1, this.lastIntegerZoomTime = r) : this.lastFloorZoom < a && (this.lastIntegerZoom = a, this.lastIntegerZoomTime = r), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = a, !0))
          }
        }
        const si = {
          "Latin-1 Supplement": i => i >= 128 && i <= 255,
          "Hangul Jamo": i => i >= 4352 && i <= 4607,
          Khmer: i => i >= 6016 && i <= 6143,
          "General Punctuation": i => i >= 8192 && i <= 8303,
          "Letterlike Symbols": i => i >= 8448 && i <= 8527,
          "Number Forms": i => i >= 8528 && i <= 8591,
          "Miscellaneous Technical": i => i >= 8960 && i <= 9215,
          "Control Pictures": i => i >= 9216 && i <= 9279,
          "Optical Character Recognition": i => i >= 9280 && i <= 9311,
          "Enclosed Alphanumerics": i => i >= 9312 && i <= 9471,
          "Geometric Shapes": i => i >= 9632 && i <= 9727,
          "Miscellaneous Symbols": i => i >= 9728 && i <= 9983,
          "Miscellaneous Symbols and Arrows": i => i >= 11008 && i <= 11263,
          "Ideographic Description Characters": i => i >= 12272 && i <= 12287,
          "CJK Symbols and Punctuation": i => i >= 12288 && i <= 12351,
          Hiragana: i => i >= 12352 && i <= 12447,
          Katakana: i => i >= 12448 && i <= 12543,
          Kanbun: i => i >= 12688 && i <= 12703,
          "CJK Strokes": i => i >= 12736 && i <= 12783,
          "Enclosed CJK Letters and Months": i => i >= 12800 && i <= 13055,
          "CJK Compatibility": i => i >= 13056 && i <= 13311,
          "Yijing Hexagram Symbols": i => i >= 19904 && i <= 19967,
          "CJK Unified Ideographs": i => i >= 19968 && i <= 40959,
          "Hangul Syllables": i => i >= 44032 && i <= 55215,
          "Private Use Area": i => i >= 57344 && i <= 63743,
          "Vertical Forms": i => i >= 65040 && i <= 65055,
          "CJK Compatibility Forms": i => i >= 65072 && i <= 65103,
          "Small Form Variants": i => i >= 65104 && i <= 65135,
          "Halfwidth and Fullwidth Forms": i => i >= 65280 && i <= 65519
        };

        function wl(i) {
          for (const t of i)
            if ($c(t.charCodeAt(0))) return !0;
          return !1
        }

        function fp(i) {
          for (const t of i)
            if (!Hh(t.charCodeAt(0))) return !1;
          return !0
        }

        function Tl(i) {
          const t = i.map((r => {
            try {
              return new RegExp(`\\p{sc=${r}}`, "u").source
            } catch {
              return null
            }
          })).filter((r => r));
          return new RegExp(t.join("|"), "u")
        }
        const mp = Tl(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);

        function Hh(i) {
          return !mp.test(String.fromCodePoint(i))
        }
        const Zc = Tl(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);

        function $c(i) {
          return !(i !== 746 && i !== 747 && (i < 4352 || !(si["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || si["CJK Compatibility"](i) || si["CJK Strokes"](i) || !(!si["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || si["Enclosed CJK Letters and Months"](i) || si["Ideographic Description Characters"](i) || si.Kanbun(i) || si.Katakana(i) && i !== 12540 || !(!si["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!si["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || si["Vertical Forms"](i) || si["Yijing Hexagram Symbols"](i) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(i)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(i)) || Zc.test(String.fromCodePoint(i)))))
        }

        function Wh(i) {
          return !($c(i) || (function(t) {
            return !!(si["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || si["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || si["Letterlike Symbols"](t) || si["Number Forms"](t) || si["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || si["Control Pictures"](t) && t !== 9251 || si["Optical Character Recognition"](t) || si["Enclosed Alphanumerics"](t) || si["Geometric Shapes"](t) || si["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || si["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || si["CJK Symbols and Punctuation"](t) || si.Katakana(t) || si["Private Use Area"](t) || si["CJK Compatibility Forms"](t) || si["Small Form Variants"](t) || si["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
          })(i))
        }
        const Xh = Tl(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);

        function Gc(i) {
          return Xh.test(String.fromCodePoint(i))
        }

        function Kh(i, t) {
          return !(!t && Gc(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || si.Khmer(i))
        }

        function Yh(i) {
          for (const t of i)
            if (Gc(t.charCodeAt(0))) return !0;
          return !1
        }
        const Ca = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {}
          }
          setState(i) {
            this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL
          }
          getState() {
            return {
              pluginStatus: this.pluginStatus,
              pluginURL: this.pluginURL
            }
          }
          setMethods(i) {
            if (Ca.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText, this.loadScriptResolve()
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus
          }
          syncState(i, t) {
            return o(this, void 0, void 0, (function*() {
              if (this.isParsed()) return this.getState();
              if (i.pluginStatus !== "loading") return this.setState(i), i;
              const r = i.pluginURL,
                a = new Promise((p => {
                  this.loadScriptResolve = p
                }));
              t(r);
              const c = new Promise((p => setTimeout((() => p()), this.TIMEOUT)));
              if (yield Promise.race([a, c]), this.isParsed()) {
                const p = {
                  pluginStatus: "loaded",
                  pluginURL: r
                };
                return this.setState(p), p
              }
              throw this.setState({
                pluginStatus: "error",
                pluginURL: ""
              }), new Error(`RTL Text Plugin failed to import scripts from ${r}`)
            }))
          }
        };
        class ji {
          constructor(t, r) {
            this.zoom = t, r ? (this.now = r.now || 0, this.fadeDuration = r.fadeDuration || 0, this.zoomHistory = r.zoomHistory || new bl, this.transition = r.transition || {}, this.globalState = r.globalState || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new bl, this.transition = {}, this.globalState = {})
          }
          isSupportedScript(t) {
            return (function(r, a) {
              for (const c of r)
                if (!Kh(c.charCodeAt(0), a)) return !1;
              return !0
            })(t, Ca.getRTLTextPluginStatus() === "loaded")
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
          }
          getCrossfadeParameters() {
            const t = this.zoom,
              r = t - Math.floor(t),
              a = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? {
              fromScale: 2,
              toScale: 1,
              t: r + (1 - r) * a
            } : {
              fromScale: .5,
              toScale: 1,
              t: 1 - (1 - a) * r
            }
          }
        }
        class Hs {
          constructor(t, r) {
            this.property = t, this.value = r, this.expression = (function(a, c) {
              if (Co(a)) return new Io(a, c);
              if (fl(a)) {
                const p = Rh(a, c);
                if (p.result === "error") throw new Error(p.value.map((f => `${f.key}: ${f.message}`)).join(", "));
                return p.value
              } {
                let p = a;
                return c.type === "color" && typeof a == "string" ? p = br.parse(a) : c.type !== "padding" || typeof a != "number" && !Array.isArray(a) ? c.type !== "numberArray" || typeof a != "number" && !Array.isArray(a) ? c.type !== "colorArray" || typeof a != "string" && !Array.isArray(a) ? c.type === "variableAnchorOffsetCollection" && Array.isArray(a) ? p = un.parse(a) : c.type === "projectionDefinition" && typeof a == "string" && (p = hn.parse(a)) : p = Ci.parse(a) : p = Qi.parse(a) : p = Ui.parse(a), {
                  globalStateRefs: new Set,
                  kind: "constant",
                  evaluate: () => p
                }
              }
            })(r === void 0 ? t.specification.default : r, t.specification)
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite"
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || new Set
          }
          possiblyEvaluate(t, r, a) {
            return this.property.possiblyEvaluate(this, t, r, a)
          }
        }
        class Hc {
          constructor(t) {
            this.property = t, this.value = new Hs(t, void 0)
          }
          transitioned(t, r) {
            return new Wc(this.property, this.value, r, Tt({}, t.transition, this.transition), t.now)
          }
          untransitioned() {
            return new Wc(this.property, this.value, null, {}, 0)
          }
        }
        class Jh {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues)
          }
          getValue(t) {
            return St(this._values[t].value.value)
          }
          setValue(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Hc(this._values[t].property)), this._values[t].value = new Hs(this._values[t].property, r === null ? void 0 : St(r))
          }
          getTransition(t) {
            return St(this._values[t].transition)
          }
          setTransition(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Hc(this._values[t].property)), this._values[t].transition = St(r) || void 0
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const a = this.getValue(r);
              a !== void 0 && (t[r] = a);
              const c = this.getTransition(r);
              c !== void 0 && (t[`${r}-transition`] = c)
            }
            return t
          }
          transitioned(t, r) {
            const a = new Xc(this._properties);
            for (const c of Object.keys(this._values)) a._values[c] = this._values[c].transitioned(t, r._values[c]);
            return a
          }
          untransitioned() {
            const t = new Xc(this._properties);
            for (const r of Object.keys(this._values)) t._values[r] = this._values[r].untransitioned();
            return t
          }
        }
        class Wc {
          constructor(t, r, a, c, p) {
            this.property = t, this.value = r, this.begin = p + c.delay || 0, this.end = this.begin + c.duration || 0, t.specification.transition && (c.delay || c.duration) && (this.prior = a)
          }
          possiblyEvaluate(t, r, a) {
            const c = t.now || 0,
              p = this.value.possiblyEvaluate(t, r, a),
              f = this.prior;
            if (f) {
              if (c > this.end) return this.prior = null, p;
              if (this.value.isDataDriven()) return this.prior = null, p;
              if (c < this.begin) return f.possiblyEvaluate(t, r, a);
              {
                const _ = (c - this.begin) / (this.end - this.begin);
                return this.property.interpolate(f.possiblyEvaluate(t, r, a), p, Ye(_))
              }
            }
            return p
          }
        }
        class Xc {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues)
          }
          possiblyEvaluate(t, r, a) {
            const c = new Cl(this._properties);
            for (const p of Object.keys(this._values)) c._values[p] = this._values[p].possiblyEvaluate(t, r, a);
            return c
          }
          hasTransition() {
            for (const t of Object.keys(this._values))
              if (this._values[t].prior) return !0;
            return !1
          }
        }
        class Qh {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues)
          }
          hasValue(t) {
            return this._values[t].value !== void 0
          }
          getValue(t) {
            return St(this._values[t].value)
          }
          setValue(t, r) {
            this._values[t] = new Hs(this._values[t].property, r === null ? void 0 : St(r))
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const a = this.getValue(r);
              a !== void 0 && (t[r] = a)
            }
            return t
          }
          possiblyEvaluate(t, r, a) {
            const c = new Cl(this._properties);
            for (const p of Object.keys(this._values)) c._values[p] = this._values[p].possiblyEvaluate(t, r, a);
            return c
          }
        }
        class Oa {
          constructor(t, r, a) {
            this.property = t, this.value = r, this.parameters = a
          }
          isConstant() {
            return this.value.kind === "constant"
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t
          }
          evaluate(t, r, a, c) {
            return this.property.evaluate(this.value, this.parameters, t, r, a, c)
          }
        }
        class Cl {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues)
          }
          get(t) {
            return this._values[t]
          }
        }
        class hr {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(r)
          }
          interpolate(t, r, a) {
            const c = Ba[this.specification.type];
            return c ? c(t, r, a) : t
          }
        }
        class Lr {
          constructor(t, r) {
            this.specification = t, this.overrides = r
          }
          possiblyEvaluate(t, r, a, c) {
            return new Oa(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? {
              kind: "constant",
              value: t.expression.evaluate(r, null, {}, a, c)
            } : t.expression, r)
          }
          interpolate(t, r, a) {
            if (t.value.kind !== "constant" || r.value.kind !== "constant") return t;
            if (t.value.value === void 0 || r.value.value === void 0) return new Oa(this, {
              kind: "constant",
              value: void 0
            }, t.parameters);
            const c = Ba[this.specification.type];
            if (c) {
              const p = c(t.value.value, r.value.value, a);
              return new Oa(this, {
                kind: "constant",
                value: p
              }, t.parameters)
            }
            return t
          }
          evaluate(t, r, a, c, p, f) {
            return t.kind === "constant" ? t.value : t.evaluate(r, a, c, p, f)
          }
        }
        class Sl extends Lr {
          possiblyEvaluate(t, r, a, c) {
            if (t.value === void 0) return new Oa(this, {
              kind: "constant",
              value: void 0
            }, r);
            if (t.expression.kind === "constant") {
              const p = t.expression.evaluate(r, null, {}, a, c),
                f = t.property.specification.type === "resolvedImage" && typeof p != "string" ? p.name : p,
                _ = this._calculate(f, f, f, r);
              return new Oa(this, {
                kind: "constant",
                value: _
              }, r)
            }
            if (t.expression.kind === "camera") {
              const p = this._calculate(t.expression.evaluate({
                zoom: r.zoom - 1
              }), t.expression.evaluate({
                zoom: r.zoom
              }), t.expression.evaluate({
                zoom: r.zoom + 1
              }), r);
              return new Oa(this, {
                kind: "constant",
                value: p
              }, r)
            }
            return new Oa(this, t.expression, r)
          }
          evaluate(t, r, a, c, p, f) {
            if (t.kind === "source") {
              const _ = t.evaluate(r, a, c, p, f);
              return this._calculate(_, _, _, r)
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({
              zoom: Math.floor(r.zoom) - 1
            }, a, c), t.evaluate({
              zoom: Math.floor(r.zoom)
            }, a, c), t.evaluate({
              zoom: Math.floor(r.zoom) + 1
            }, a, c), r) : t.value
          }
          _calculate(t, r, a, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: a,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class is {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, a, c) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const p = t.expression.evaluate(r, null, {}, a, c);
                return this._calculate(p, p, p, r)
              }
              return this._calculate(t.expression.evaluate(new ji(Math.floor(r.zoom - 1), r)), t.expression.evaluate(new ji(Math.floor(r.zoom), r)), t.expression.evaluate(new ji(Math.floor(r.zoom + 1), r)), r)
            }
          }
          _calculate(t, r, a, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: a,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class Pl {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, a, c) {
            return !!t.expression.evaluate(r, null, {}, a, c)
          }
          interpolate() {
            return !1
          }
        }
        class jn {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const r in t) {
              const a = t[r];
              a.specification.overridable && this.overridableProperties.push(r);
              const c = this.defaultPropertyValues[r] = new Hs(a, void 0),
                p = this.defaultTransitionablePropertyValues[r] = new Hc(a);
              this.defaultTransitioningPropertyValues[r] = p.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = c.possiblyEvaluate({})
            }
          }
        }
        Wt("DataDrivenProperty", Lr), Wt("DataConstantProperty", hr), Wt("CrossFadedDataDrivenProperty", Sl), Wt("CrossFadedProperty", is), Wt("ColorRampProperty", Pl);
        const ed = "-transition";
        class ha extends kt {
          constructor(t, r) {
            if (super(), this.id = t.id, this.type = t.type, this._featureFilter = {
                filter: () => !0,
                needGeometry: !1,
                getGlobalStateRefs: () => new Set
              }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = xs(t.filter)), r.layout && (this._unevaluatedLayout = new Qh(r.layout)), r.paint)) {
              this._transitionablePaint = new Jh(r.paint);
              for (const a in t.paint) this.setPaintProperty(a, t.paint[a], {
                validate: !1
              });
              for (const a in t.layout) this.setLayoutProperty(a, t.layout[a], {
                validate: !1
              });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Cl(r.paint)
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = xs(t)
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = new Set;
            if (this._unevaluatedLayout)
              for (const r in this._unevaluatedLayout._values) {
                const a = this._unevaluatedLayout._values[r];
                for (const c of a.getGlobalStateRefs()) t.add(c)
              }
            for (const r of this._featureFilter.getGlobalStateRefs()) t.add(r);
            return t
          }
          setLayoutProperty(t, r, a = {}) {
            r != null && this._validate(pp, `layers.${this.id}.layout.${t}`, t, r, a) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, r) : this.visibility = r)
          }
          getPaintProperty(t) {
            return t.endsWith(ed) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
          }
          setPaintProperty(t, r, a = {}) {
            if (r != null && this._validate(dp, `layers.${this.id}.paint.${t}`, t, r, a)) return !1;
            if (t.endsWith(ed)) return this._transitionablePaint.setTransition(t.slice(0, -11), r || void 0), !1;
            {
              const c = this._transitionablePaint._values[t],
                p = c.property.specification["property-type"] === "cross-faded-data-driven",
                f = c.value.isDataDriven(),
                _ = c.value;
              this._transitionablePaint.setValue(t, r), this._handleSpecialPaintPropertyUpdate(t);
              const v = this._transitionablePaint._values[t].value;
              return v.isDataDriven() || f || p || this._handleOverridablePaintPropertyUpdate(t, _, v)
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {}
          _handleOverridablePaintPropertyUpdate(t, r, a) {
            return !1
          }
          isHidden(t) {
            return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition()
          }
          recalculate(t, r) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, r)
          }
          serialize() {
            const t = {
              id: this.id,
              type: this.type,
              source: this.source,
              "source-layer": this.sourceLayer,
              metadata: this.metadata,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              filter: this.filter,
              layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
              paint: this._transitionablePaint && this._transitionablePaint.serialize()
            };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Mt(t, ((r, a) => !(r === void 0 || a === "layout" && !Object.keys(r).length || a === "paint" && !Object.keys(r).length)))
          }
          _validate(t, r, a, c, p = {}) {
            return (!p || p.validate !== !1) && zo(this, t.call($s, {
              key: r,
              layerType: this.type,
              objectKey: a,
              value: c,
              styleSpec: ye,
              style: {
                glyphs: !0,
                sprite: !0
              }
            }))
          }
          is3D() {
            return !1
          }
          isTileClipped() {
            return !1
          }
          hasOffscreenPass() {
            return !1
          }
          resize() {}
          isStateDependent() {
            for (const t in this.paint._values) {
              const r = this.paint.get(t);
              if (r instanceof Oa && ts(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return !0
            }
            return !1
          }
        }
        const _p = {
          Int8: Int8Array,
          Uint8: Uint8Array,
          Int16: Int16Array,
          Uint16: Uint16Array,
          Int32: Int32Array,
          Uint32: Uint32Array,
          Float32: Float32Array
        };
        class Do {
          constructor(t, r) {
            this._structArray = t, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
          }
        }
        class Ai {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0)
          }
          static serialize(t, r) {
            return t._trim(), r && (t.isTransferred = !0, r.push(t.arrayBuffer)), {
              length: t.length,
              arrayBuffer: t.arrayBuffer
            }
          }
          static deserialize(t) {
            const r = Object.create(this.prototype);
            return r.arrayBuffer = t.arrayBuffer, r.length = t.length, r.capacity = t.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
          }
          clear() {
            this.length = 0
          }
          resize(t) {
            this.reserve(t), this.length = t
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const r = this.uint8;
              this._refreshViews(), r && this.uint8.set(r)
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
          }
        }

        function Xi(i, t = 1) {
          let r = 0,
            a = 0;
          return {
            members: i.map((c => {
              const p = _p[c.type].BYTES_PER_ELEMENT,
                f = r = Il(r, Math.max(t, p)),
                _ = c.components || 1;
              return a = Math.max(a, p), r += p * _, {
                name: c.name,
                type: c.type,
                components: _,
                offset: f
              }
            })),
            size: Il(r, Math.max(a, t)),
            alignment: t
          }
        }

        function Il(i, t) {
          return Math.ceil(i / t) * t
        }
        class Ws extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, r)
          }
          emplace(t, r, a) {
            const c = 2 * t;
            return this.int16[c + 0] = r, this.int16[c + 1] = a, t
          }
        }
        Ws.prototype.bytesPerElement = 4, Wt("StructArrayLayout2i4", Ws);
        class Xs extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 3 * t;
            return this.int16[p + 0] = r, this.int16[p + 1] = a, this.int16[p + 2] = c, t
          }
        }
        Xs.prototype.bytesPerElement = 6, Wt("StructArrayLayout3i6", Xs);
        class Kc extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, r, a, c)
          }
          emplace(t, r, a, c, p) {
            const f = 4 * t;
            return this.int16[f + 0] = r, this.int16[f + 1] = a, this.int16[f + 2] = c, this.int16[f + 3] = p, t
          }
        }
        Kc.prototype.bytesPerElement = 8, Wt("StructArrayLayout4i8", Kc);
        class Ks extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, r, a, c, p, f)
          }
          emplace(t, r, a, c, p, f, _) {
            const v = 6 * t;
            return this.int16[v + 0] = r, this.int16[v + 1] = a, this.int16[v + 2] = c, this.int16[v + 3] = p, this.int16[v + 4] = f, this.int16[v + 5] = _, t
          }
        }
        Ks.prototype.bytesPerElement = 12, Wt("StructArrayLayout2i4i12", Ks);
        class Cs extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, r, a, c, p, f)
          }
          emplace(t, r, a, c, p, f, _) {
            const v = 4 * t,
              S = 8 * t;
            return this.int16[v + 0] = r, this.int16[v + 1] = a, this.uint8[S + 4] = c, this.uint8[S + 5] = p, this.uint8[S + 6] = f, this.uint8[S + 7] = _, t
          }
        }
        Cs.prototype.bytesPerElement = 8, Wt("StructArrayLayout2i4ub8", Cs);
        class Ro extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, r)
          }
          emplace(t, r, a) {
            const c = 2 * t;
            return this.float32[c + 0] = r, this.float32[c + 1] = a, t
          }
        }
        Ro.prototype.bytesPerElement = 8, Wt("StructArrayLayout2f8", Ro);
        class Ml extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f, _, v, S, I) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, t, r, a, c, p, f, _, v, S, I)
          }
          emplace(t, r, a, c, p, f, _, v, S, I, E) {
            const R = 10 * t;
            return this.uint16[R + 0] = r, this.uint16[R + 1] = a, this.uint16[R + 2] = c, this.uint16[R + 3] = p, this.uint16[R + 4] = f, this.uint16[R + 5] = _, this.uint16[R + 6] = v, this.uint16[R + 7] = S, this.uint16[R + 8] = I, this.uint16[R + 9] = E, t
          }
        }
        Ml.prototype.bytesPerElement = 20, Wt("StructArrayLayout10ui20", Ml);
        class Ss extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f, _, v, S, I, E, R) {
            const O = this.length;
            return this.resize(O + 1), this.emplace(O, t, r, a, c, p, f, _, v, S, I, E, R)
          }
          emplace(t, r, a, c, p, f, _, v, S, I, E, R, O) {
            const j = 12 * t;
            return this.int16[j + 0] = r, this.int16[j + 1] = a, this.int16[j + 2] = c, this.int16[j + 3] = p, this.uint16[j + 4] = f, this.uint16[j + 5] = _, this.uint16[j + 6] = v, this.uint16[j + 7] = S, this.int16[j + 8] = I, this.int16[j + 9] = E, this.int16[j + 10] = R, this.int16[j + 11] = O, t
          }
        }
        Ss.prototype.bytesPerElement = 24, Wt("StructArrayLayout4i4ui4i24", Ss);
        class Yc extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 3 * t;
            return this.float32[p + 0] = r, this.float32[p + 1] = a, this.float32[p + 2] = c, t
          }
        }
        Yc.prototype.bytesPerElement = 12, Wt("StructArrayLayout3f12", Yc);
        class Jc extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint32[1 * t + 0] = r, t
          }
        }
        Jc.prototype.bytesPerElement = 4, Wt("StructArrayLayout1ul4", Jc);
        class Al extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f, _, v, S) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, t, r, a, c, p, f, _, v, S)
          }
          emplace(t, r, a, c, p, f, _, v, S, I) {
            const E = 10 * t,
              R = 5 * t;
            return this.int16[E + 0] = r, this.int16[E + 1] = a, this.int16[E + 2] = c, this.int16[E + 3] = p, this.int16[E + 4] = f, this.int16[E + 5] = _, this.uint32[R + 3] = v, this.uint16[E + 8] = S, this.uint16[E + 9] = I, t
          }
        }
        Al.prototype.bytesPerElement = 20, Wt("StructArrayLayout6i1ul2ui20", Al);
        class Qc extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, r, a, c, p, f)
          }
          emplace(t, r, a, c, p, f, _) {
            const v = 6 * t;
            return this.int16[v + 0] = r, this.int16[v + 1] = a, this.int16[v + 2] = c, this.int16[v + 3] = p, this.int16[v + 4] = f, this.int16[v + 5] = _, t
          }
        }
        Qc.prototype.bytesPerElement = 12, Wt("StructArrayLayout2i2i2i12", Qc);
        class h extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, r, a, c, p)
          }
          emplace(t, r, a, c, p, f) {
            const _ = 4 * t,
              v = 8 * t;
            return this.float32[_ + 0] = r, this.float32[_ + 1] = a, this.float32[_ + 2] = c, this.int16[v + 6] = p, this.int16[v + 7] = f, t
          }
        }
        h.prototype.bytesPerElement = 16, Wt("StructArrayLayout2f1f2i16", h);
        class e extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, r, a, c, p, f)
          }
          emplace(t, r, a, c, p, f, _) {
            const v = 16 * t,
              S = 4 * t,
              I = 8 * t;
            return this.uint8[v + 0] = r, this.uint8[v + 1] = a, this.float32[S + 1] = c, this.float32[S + 2] = p, this.int16[I + 6] = f, this.int16[I + 7] = _, t
          }
        }
        e.prototype.bytesPerElement = 16, Wt("StructArrayLayout2ub2f2i16", e);
        class n extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 3 * t;
            return this.uint16[p + 0] = r, this.uint16[p + 1] = a, this.uint16[p + 2] = c, t
          }
        }
        n.prototype.bytesPerElement = 6, Wt("StructArrayLayout3ui6", n);
        class s extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f, _, v, S, I, E, R, O, j, Z, Y, ne) {
            const ke = this.length;
            return this.resize(ke + 1), this.emplace(ke, t, r, a, c, p, f, _, v, S, I, E, R, O, j, Z, Y, ne)
          }
          emplace(t, r, a, c, p, f, _, v, S, I, E, R, O, j, Z, Y, ne, ke) {
            const pe = 24 * t,
              be = 12 * t,
              Ve = 48 * t;
            return this.int16[pe + 0] = r, this.int16[pe + 1] = a, this.uint16[pe + 2] = c, this.uint16[pe + 3] = p, this.uint32[be + 2] = f, this.uint32[be + 3] = _, this.uint32[be + 4] = v, this.uint16[pe + 10] = S, this.uint16[pe + 11] = I, this.uint16[pe + 12] = E, this.float32[be + 7] = R, this.float32[be + 8] = O, this.uint8[Ve + 36] = j, this.uint8[Ve + 37] = Z, this.uint8[Ve + 38] = Y, this.uint32[be + 10] = ne, this.int16[pe + 22] = ke, t
          }
        }
        s.prototype.bytesPerElement = 48, Wt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", s);
        class u extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f, _, v, S, I, E, R, O, j, Z, Y, ne, ke, pe, be, Ve, et, xt, Zt, Rt, Vt, fr, qt) {
            const Ut = this.length;
            return this.resize(Ut + 1), this.emplace(Ut, t, r, a, c, p, f, _, v, S, I, E, R, O, j, Z, Y, ne, ke, pe, be, Ve, et, xt, Zt, Rt, Vt, fr, qt)
          }
          emplace(t, r, a, c, p, f, _, v, S, I, E, R, O, j, Z, Y, ne, ke, pe, be, Ve, et, xt, Zt, Rt, Vt, fr, qt, Ut) {
            const dt = 32 * t,
              Br = 16 * t;
            return this.int16[dt + 0] = r, this.int16[dt + 1] = a, this.int16[dt + 2] = c, this.int16[dt + 3] = p, this.int16[dt + 4] = f, this.int16[dt + 5] = _, this.int16[dt + 6] = v, this.int16[dt + 7] = S, this.uint16[dt + 8] = I, this.uint16[dt + 9] = E, this.uint16[dt + 10] = R, this.uint16[dt + 11] = O, this.uint16[dt + 12] = j, this.uint16[dt + 13] = Z, this.uint16[dt + 14] = Y, this.uint16[dt + 15] = ne, this.uint16[dt + 16] = ke, this.uint16[dt + 17] = pe, this.uint16[dt + 18] = be, this.uint16[dt + 19] = Ve, this.uint16[dt + 20] = et, this.uint16[dt + 21] = xt, this.uint16[dt + 22] = Zt, this.uint32[Br + 12] = Rt, this.float32[Br + 13] = Vt, this.float32[Br + 14] = fr, this.uint16[dt + 30] = qt, this.uint16[dt + 31] = Ut, t
          }
        }
        u.prototype.bytesPerElement = 64, Wt("StructArrayLayout8i15ui1ul2f2ui64", u);
        class d extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.float32[1 * t + 0] = r, t
          }
        }
        d.prototype.bytesPerElement = 4, Wt("StructArrayLayout1f4", d);
        class m extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 3 * t;
            return this.uint16[6 * t + 0] = r, this.float32[p + 1] = a, this.float32[p + 2] = c, t
          }
        }
        m.prototype.bytesPerElement = 12, Wt("StructArrayLayout1ui2f12", m);
        class y extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 4 * t;
            return this.uint32[2 * t + 0] = r, this.uint16[p + 2] = a, this.uint16[p + 3] = c, t
          }
        }
        y.prototype.bytesPerElement = 8, Wt("StructArrayLayout1ul2ui8", y);
        class b extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, r)
          }
          emplace(t, r, a) {
            const c = 2 * t;
            return this.uint16[c + 0] = r, this.uint16[c + 1] = a, t
          }
        }
        b.prototype.bytesPerElement = 4, Wt("StructArrayLayout2ui4", b);
        class P extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint16[1 * t + 0] = r, t
          }
        }
        P.prototype.bytesPerElement = 2, Wt("StructArrayLayout1ui2", P);
        class M extends Ai {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, r, a, c)
          }
          emplace(t, r, a, c, p) {
            const f = 4 * t;
            return this.float32[f + 0] = r, this.float32[f + 1] = a, this.float32[f + 2] = c, this.float32[f + 3] = p, t
          }
        }
        M.prototype.bytesPerElement = 16, Wt("StructArrayLayout4f16", M);
        class L extends Do {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get anchorPoint() {
            return new G(this.anchorPointX, this.anchorPointY)
          }
        }
        L.prototype.size = 20;
        class z extends Al {
          get(t) {
            return new L(this, t)
          }
        }
        Wt("CollisionBoxArray", z);
        class B extends Do {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3]
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2]
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4]
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7]
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8]
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36]
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37]
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38]
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22]
          }
        }
        B.prototype.size = 48;
        class U extends s {
          get(t) {
            return new B(this, t)
          }
        }
        Wt("PlacedSymbolArray", U);
        class Q extends Do {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6]
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7]
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13]
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14]
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15]
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16]
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17]
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18]
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19]
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20]
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21]
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22]
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13]
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14]
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30]
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31]
          }
        }
        Q.prototype.size = 64;
        class J extends u {
          get(t) {
            return new Q(this, t)
          }
        }
        Wt("SymbolInstanceArray", J);
        class re extends d {
          getoffsetX(t) {
            return this.float32[1 * t + 0]
          }
        }
        Wt("GlyphOffsetArray", re);
        class se extends Xs {
          getx(t) {
            return this.int16[3 * t + 0]
          }
          gety(t) {
            return this.int16[3 * t + 1]
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2]
          }
        }
        Wt("SymbolLineVertexArray", se);
        class de extends Do {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0]
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1]
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2]
          }
        }
        de.prototype.size = 12;
        class ue extends m {
          get(t) {
            return new de(this, t)
          }
        }
        Wt("TextAnchorOffsetArray", ue);
        class ge extends Do {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3]
          }
        }
        ge.prototype.size = 8;
        class we extends y {
          get(t) {
            return new ge(this, t)
          }
        }
        Wt("FeatureIndexArray", we);
        class he extends Ws {}
        class ze extends Ws {}
        class He extends Ws {}
        class Ne extends Ks {}
        class qe extends Cs {}
        class Ge extends Ro {}
        class Dt extends Ml {}
        class Ft extends Ss {}
        class vt extends Yc {}
        class sr extends Jc {}
        class Kr extends Qc {}
        class wi extends e {}
        class ki extends n {}
        class Ii extends b {}
        const qi = Xi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: $i
          } = qi;
        class Xr {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t
          }
          prepareSegment(t, r, a, c) {
            const p = this.segments[this.segments.length - 1];
            return t > Xr.MAX_VERTEX_ARRAY_LENGTH && Lt(`Max vertices per segment is ${Xr.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Xr.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !p || p.vertexLength + t > Xr.MAX_VERTEX_ARRAY_LENGTH || p.sortKey !== c ? this.createNewSegment(r, a, c) : p
          }
          createNewSegment(t, r, a) {
            const c = {
              vertexOffset: t.length,
              primitiveOffset: r.length,
              vertexLength: 0,
              primitiveLength: 0,
              vaos: {}
            };
            return a !== void 0 && (c.sortKey = a), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(c), c
          }
          getOrCreateLatestSegment(t, r, a) {
            return this.prepareSegment(0, t, r, a)
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0
          }
          get() {
            return this.segments
          }
          destroy() {
            for (const t of this.segments)
              for (const r in t.vaos) t.vaos[r].destroy()
          }
          static simpleSegment(t, r, a, c) {
            return new Xr([{
              vertexOffset: t,
              primitiveOffset: r,
              vertexLength: a,
              primitiveLength: c,
              vaos: {},
              sortKey: 0
            }])
          }
        }

        function Ei(i, t) {
          return 256 * (i = Nt(Math.floor(i), 0, 255)) + Nt(Math.floor(t), 0, 255)
        }
        Xr.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Wt("SegmentVector", Xr);
        const nn = Xi([{
          name: "a_pattern_from",
          components: 4,
          type: "Uint16"
        }, {
          name: "a_pattern_to",
          components: 4,
          type: "Uint16"
        }, {
          name: "a_pixel_ratio_from",
          components: 1,
          type: "Uint16"
        }, {
          name: "a_pixel_ratio_to",
          components: 1,
          type: "Uint16"
        }]);
        var dn, xn, qn, Sa = {
            exports: {}
          },
          ns = {
            exports: {}
          },
          as = {
            exports: {}
          },
          Ys = (function() {
            if (qn) return Sa.exports;
            qn = 1;
            var i = (dn || (dn = 1, ns.exports = function(r, a) {
                var c, p, f, _, v, S, I, E;
                for (p = r.length - (c = 3 & r.length), f = a, v = 3432918353, S = 461845907, E = 0; E < p;) I = 255 & r.charCodeAt(E) | (255 & r.charCodeAt(++E)) << 8 | (255 & r.charCodeAt(++E)) << 16 | (255 & r.charCodeAt(++E)) << 24, ++E, f = 27492 + (65535 & (_ = 5 * (65535 & (f = (f ^= I = (65535 & (I = (I = (65535 & I) * v + (((I >>> 16) * v & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * S + (((I >>> 16) * S & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (_ >>> 16) & 65535) << 16);
                switch (I = 0, c) {
                  case 3:
                    I ^= (255 & r.charCodeAt(E + 2)) << 16;
                  case 2:
                    I ^= (255 & r.charCodeAt(E + 1)) << 8;
                  case 1:
                    f ^= I = (65535 & (I = (I = (65535 & (I ^= 255 & r.charCodeAt(E))) * v + (((I >>> 16) * v & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * S + (((I >>> 16) * S & 65535) << 16) & 4294967295
                }
                return f ^= r.length, f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295, f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295, (f ^= f >>> 16) >>> 0
              }), ns.exports),
              t = (xn || (xn = 1, as.exports = function(r, a) {
                for (var c, p = r.length, f = a ^ p, _ = 0; p >= 4;) c = 1540483477 * (65535 & (c = 255 & r.charCodeAt(_) | (255 & r.charCodeAt(++_)) << 8 | (255 & r.charCodeAt(++_)) << 16 | (255 & r.charCodeAt(++_)) << 24)) + ((1540483477 * (c >>> 16) & 65535) << 16), f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (c = 1540483477 * (65535 & (c ^= c >>> 24)) + ((1540483477 * (c >>> 16) & 65535) << 16)), p -= 4, ++_;
                switch (p) {
                  case 3:
                    f ^= (255 & r.charCodeAt(_ + 2)) << 16;
                  case 2:
                    f ^= (255 & r.charCodeAt(_ + 1)) << 8;
                  case 1:
                    f = 1540483477 * (65535 & (f ^= 255 & r.charCodeAt(_))) + ((1540483477 * (f >>> 16) & 65535) << 16)
                }
                return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16), (f ^= f >>> 15) >>> 0
              }), as.exports);
            return Sa.exports = i, Sa.exports.murmur3 = i, Sa.exports.murmur2 = t, Sa.exports
          })(),
          Js = W(Ys);
        class Ps {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1
          }
          add(t, r, a, c) {
            this.ids.push(Is(t)), this.positions.push(r, a, c)
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const r = Is(t);
            let a = 0,
              c = this.ids.length - 1;
            for (; a < c;) {
              const f = a + c >> 1;
              this.ids[f] >= r ? c = f : a = f + 1
            }
            const p = [];
            for (; this.ids[a] === r;) p.push({
              index: this.positions[3 * a],
              start: this.positions[3 * a + 1],
              end: this.positions[3 * a + 2]
            }), a++;
            return p
          }
          static serialize(t, r) {
            const a = new Float64Array(t.ids),
              c = new Uint32Array(t.positions);
            return Yn(a, c, 0, a.length - 1), r && r.push(a.buffer, c.buffer), {
              ids: a,
              positions: c
            }
          }
          static deserialize(t) {
            const r = new Ps;
            return r.ids = t.ids, r.positions = t.positions, r.indexed = !0, r
          }
        }

        function Is(i) {
          const t = +i;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : Js(String(i))
        }

        function Yn(i, t, r, a) {
          for (; r < a;) {
            const c = i[r + a >> 1];
            let p = r - 1,
              f = a + 1;
            for (;;) {
              do p++; while (i[p] < c);
              do f--; while (i[f] > c);
              if (p >= f) break;
              Pa(i, p, f), Pa(t, 3 * p, 3 * f), Pa(t, 3 * p + 1, 3 * f + 1), Pa(t, 3 * p + 2, 3 * f + 2)
            }
            f - r < a - f ? (Yn(i, t, r, f), r = f + 1) : (Yn(i, t, f + 1, a), a = f)
          }
        }

        function Pa(i, t, r) {
          const a = i[t];
          i[t] = i[r], i[r] = a
        }
        Wt("FeaturePositionMap", Ps);
        class Vn {
          constructor(t, r) {
            this.gl = t.gl, this.location = r
          }
        }
        class ss extends Vn {
          constructor(t, r) {
            super(t, r), this.current = 0
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t))
          }
        }
        class an extends Vn {
          constructor(t, r) {
            super(t, r), this.current = [0, 0, 0, 0]
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
          }
        }
        class pn extends Vn {
          constructor(t, r) {
            super(t, r), this.current = br.transparent
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
          }
        }
        const da = new Float32Array(16);

        function sn(i) {
          return [Ei(255 * i.r, 255 * i.g), Ei(255 * i.b, 255 * i.a)]
        }
        class Bo {
          constructor(t, r, a) {
            this.value = t, this.uniformNames = r.map((c => `u_${c}`)), this.type = a
          }
          setUniform(t, r, a) {
            t.set(a.constantOr(this.value))
          }
          getBinding(t, r, a) {
            return this.type === "color" ? new pn(t, r) : new ss(t, r)
          }
        }
        class Qs {
          constructor(t, r) {
            this.uniformNames = r.map((a => `u_${a}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1
          }
          setConstantPatternPositions(t, r) {
            this.pixelRatioFrom = r.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = r.tlbr, this.patternTo = t.tlbr
          }
          setUniform(t, r, a, c) {
            const p = c === "u_pattern_to" ? this.patternTo : c === "u_pattern_from" ? this.patternFrom : c === "u_pixel_ratio_to" ? this.pixelRatioTo : c === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            p && t.set(p)
          }
          getBinding(t, r, a) {
            return a.substr(0, 9) === "u_pattern" ? new an(t, r) : new ss(t, r)
          }
        }
        class Ga {
          constructor(t, r, a, c) {
            this.expression = t, this.type = a, this.maxValue = 0, this.paintVertexAttributes = r.map((p => ({
              name: `a_${p}`,
              type: "Float32",
              components: a === "color" ? 2 : 1,
              offset: 0
            }))), this.paintVertexArray = new c
          }
          populatePaintArray(t, r, a, c, p) {
            const f = this.paintVertexArray.length,
              _ = this.expression.evaluate(new ji(0), r, {}, c, [], p);
            this.paintVertexArray.resize(t), this._setPaintValue(f, t, _)
          }
          updatePaintArray(t, r, a, c) {
            const p = this.expression.evaluate({
              zoom: 0
            }, a, c);
            this._setPaintValue(t, r, p)
          }
          _setPaintValue(t, r, a) {
            if (this.type === "color") {
              const c = sn(a);
              for (let p = t; p < r; p++) this.paintVertexArray.emplace(p, c[0], c[1])
            } else {
              for (let c = t; c < r; c++) this.paintVertexArray.emplace(c, a);
              this.maxValue = Math.max(this.maxValue, Math.abs(a))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
        }
        class Ia {
          constructor(t, r, a, c, p, f) {
            this.expression = t, this.uniformNames = r.map((_ => `u_${_}_t`)), this.type = a, this.useIntegerZoom = c, this.zoom = p, this.maxValue = 0, this.paintVertexAttributes = r.map((_ => ({
              name: `a_${_}`,
              type: "Float32",
              components: a === "color" ? 4 : 2,
              offset: 0
            }))), this.paintVertexArray = new f
          }
          populatePaintArray(t, r, a, c, p) {
            const f = this.expression.evaluate(new ji(this.zoom), r, {}, c, [], p),
              _ = this.expression.evaluate(new ji(this.zoom + 1), r, {}, c, [], p),
              v = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(v, t, f, _)
          }
          updatePaintArray(t, r, a, c) {
            const p = this.expression.evaluate({
                zoom: this.zoom
              }, a, c),
              f = this.expression.evaluate({
                zoom: this.zoom + 1
              }, a, c);
            this._setPaintValue(t, r, p, f)
          }
          _setPaintValue(t, r, a, c) {
            if (this.type === "color") {
              const p = sn(a),
                f = sn(c);
              for (let _ = t; _ < r; _++) this.paintVertexArray.emplace(_, p[0], p[1], f[0], f[1])
            } else {
              for (let p = t; p < r; p++) this.paintVertexArray.emplace(p, a, c);
              this.maxValue = Math.max(this.maxValue, Math.abs(a), Math.abs(c))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
          setUniform(t, r) {
            const a = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,
              c = Nt(this.expression.interpolationFactor(a, this.zoom, this.zoom + 1), 0, 1);
            t.set(c)
          }
          getBinding(t, r, a) {
            return new ss(t, r)
          }
        }
        class os {
          constructor(t, r, a, c, p, f) {
            this.expression = t, this.type = r, this.useIntegerZoom = a, this.zoom = c, this.layerId = f, this.zoomInPaintVertexArray = new p, this.zoomOutPaintVertexArray = new p
          }
          populatePaintArray(t, r, a) {
            const c = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(c, t, r.patterns && r.patterns[this.layerId], a)
          }
          updatePaintArray(t, r, a, c, p) {
            this._setPaintValues(t, r, a.patterns && a.patterns[this.layerId], p)
          }
          _setPaintValues(t, r, a, c) {
            if (!c || !a) return;
            const {
              min: p,
              mid: f,
              max: _
            } = a, v = c[p], S = c[f], I = c[_];
            if (v && S && I)
              for (let E = t; E < r; E++) this.zoomInPaintVertexArray.emplace(E, S.tl[0], S.tl[1], S.br[0], S.br[1], v.tl[0], v.tl[1], v.br[0], v.br[1], S.pixelRatio, v.pixelRatio), this.zoomOutPaintVertexArray.emplace(E, S.tl[0], S.tl[1], S.br[0], S.br[1], I.tl[0], I.tl[1], I.br[0], I.br[1], S.pixelRatio, I.pixelRatio)
          }
          upload(t) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, nn.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, nn.members, this.expression.isStateDependent))
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
          }
        }
        class td {
          constructor(t, r, a) {
            this.binders = {}, this._buffers = [];
            const c = [];
            for (const p in t.paint._values) {
              if (!a(p)) continue;
              const f = t.paint.get(p);
              if (!(f instanceof Oa && ts(f.property.specification))) continue;
              const _ = rd(p, t.type),
                v = f.value,
                S = f.property.specification.type,
                I = f.property.useIntegerZoom,
                E = f.property.specification["property-type"],
                R = E === "cross-faded" || E === "cross-faded-data-driven";
              if (v.kind === "constant") this.binders[p] = R ? new Qs(v.value, _) : new Bo(v.value, _, S), c.push(`/u_${p}`);
              else if (v.kind === "source" || R) {
                const O = eu(p, S, "source");
                this.binders[p] = R ? new os(v, S, I, r, O, t.id) : new Ga(v, _, S, O), c.push(`/a_${p}`)
              } else {
                const O = eu(p, S, "composite");
                this.binders[p] = new Ia(v, _, S, I, r, O), c.push(`/z_${p}`)
              }
            }
            this.cacheKey = c.sort().join("")
          }
          getMaxValue(t) {
            const r = this.binders[t];
            return r instanceof Ga || r instanceof Ia ? r.maxValue : 0
          }
          populatePaintArrays(t, r, a, c, p) {
            for (const f in this.binders) {
              const _ = this.binders[f];
              (_ instanceof Ga || _ instanceof Ia || _ instanceof os) && _.populatePaintArray(t, r, a, c, p)
            }
          }
          setConstantPatternPositions(t, r) {
            for (const a in this.binders) {
              const c = this.binders[a];
              c instanceof Qs && c.setConstantPatternPositions(t, r)
            }
          }
          updatePaintArrays(t, r, a, c, p) {
            let f = !1;
            for (const _ in t) {
              const v = r.getPositions(_);
              for (const S of v) {
                const I = a.feature(S.index);
                for (const E in this.binders) {
                  const R = this.binders[E];
                  if ((R instanceof Ga || R instanceof Ia || R instanceof os) && R.expression.isStateDependent === !0) {
                    const O = c.paint.get(E);
                    R.expression = O.value, R.updatePaintArray(S.start, S.end, I, t[_], p), f = !0
                  }
                }
              }
            }
            return f
          }
          defines() {
            const t = [];
            for (const r in this.binders) {
              const a = this.binders[r];
              (a instanceof Bo || a instanceof Qs) && t.push(...a.uniformNames.map((c => `#define HAS_UNIFORM_${c}`)))
            }
            return t
          }
          getBinderAttributes() {
            const t = [];
            for (const r in this.binders) {
              const a = this.binders[r];
              if (a instanceof Ga || a instanceof Ia)
                for (let c = 0; c < a.paintVertexAttributes.length; c++) t.push(a.paintVertexAttributes[c].name);
              else if (a instanceof os)
                for (let c = 0; c < nn.members.length; c++) t.push(nn.members[c].name)
            }
            return t
          }
          getBinderUniforms() {
            const t = [];
            for (const r in this.binders) {
              const a = this.binders[r];
              if (a instanceof Bo || a instanceof Qs || a instanceof Ia)
                for (const c of a.uniformNames) t.push(c)
            }
            return t
          }
          getPaintVertexBuffers() {
            return this._buffers
          }
          getUniforms(t, r) {
            const a = [];
            for (const c in this.binders) {
              const p = this.binders[c];
              if (p instanceof Bo || p instanceof Qs || p instanceof Ia) {
                for (const f of p.uniformNames)
                  if (r[f]) {
                    const _ = p.getBinding(t, r[f], f);
                    a.push({
                      name: f,
                      property: c,
                      binding: _
                    })
                  }
              }
            }
            return a
          }
          setUniforms(t, r, a, c) {
            for (const {
                name: p,
                property: f,
                binding: _
              }
              of r) this.binders[f].setUniform(_, c, a.get(f), p)
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const r in this.binders) {
              const a = this.binders[r];
              if (t && a instanceof os) {
                const c = t.fromScale === 2 ? a.zoomInPaintVertexBuffer : a.zoomOutPaintVertexBuffer;
                c && this._buffers.push(c)
              } else(a instanceof Ga || a instanceof Ia) && a.paintVertexBuffer && this._buffers.push(a.paintVertexBuffer)
            }
          }
          upload(t) {
            for (const r in this.binders) {
              const a = this.binders[r];
              (a instanceof Ga || a instanceof Ia || a instanceof os) && a.upload(t)
            }
            this.updatePaintBuffers()
          }
          destroy() {
            for (const t in this.binders) {
              const r = this.binders[t];
              (r instanceof Ga || r instanceof Ia || r instanceof os) && r.destroy()
            }
          }
        }
        class ia {
          constructor(t, r, a = () => !0) {
            this.programConfigurations = {};
            for (const c of t) this.programConfigurations[c.id] = new td(c, r, a);
            this.needsUpload = !1, this._featureMap = new Ps, this._bufferOffset = 0
          }
          populatePaintArrays(t, r, a, c, p, f) {
            for (const _ in this.programConfigurations) this.programConfigurations[_].populatePaintArrays(t, r, c, p, f);
            r.id !== void 0 && this._featureMap.add(r.id, a, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0
          }
          updatePaintArrays(t, r, a, c) {
            for (const p of a) this.needsUpload = this.programConfigurations[p.id].updatePaintArrays(t, this._featureMap, r, p, c) || this.needsUpload
          }
          get(t) {
            return this.programConfigurations[t]
          }
          upload(t) {
            if (this.needsUpload) {
              for (const r in this.programConfigurations) this.programConfigurations[r].upload(t);
              this.needsUpload = !1
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy()
          }
        }

        function rd(i, t) {
          return {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
          } [i] || [i.replace(`${t}-`, "").replace(/-/g, "_")]
        }

        function eu(i, t, r) {
          const a = {
              color: {
                source: Ro,
                composite: M
              },
              number: {
                source: d,
                composite: Ro
              }
            },
            c = (function(p) {
              return {
                "line-pattern": {
                  source: Dt,
                  composite: Dt
                },
                "fill-pattern": {
                  source: Dt,
                  composite: Dt
                },
                "fill-extrusion-pattern": {
                  source: Dt,
                  composite: Dt
                }
              } [p]
            })(i);
          return c && c[r] || a[t][r]
        }
        Wt("ConstantBinder", Bo), Wt("CrossFadedConstantBinder", Qs), Wt("SourceExpressionBinder", Ga), Wt("CrossFadedCompositeBinder", os), Wt("CompositeExpressionBinder", Ia), Wt("ProgramConfiguration", td, {
          omit: ["_buffers"]
        }), Wt("ProgramConfigurationSet", ia);
        const kl = Math.pow(2, 14) - 1,
          El = -kl - 1;

        function ls(i) {
          const t = ie / i.extent,
            r = i.loadGeometry();
          for (let a = 0; a < r.length; a++) {
            const c = r[a];
            for (let p = 0; p < c.length; p++) {
              const f = c[p],
                _ = Math.round(f.x * t),
                v = Math.round(f.y * t);
              f.x = Nt(_, El, kl), f.y = Nt(v, El, kl), (_ < f.x || _ > f.x + 1 || v < f.y || v > f.y + 1) && Lt("Geometry exceeds allowed extent, reduce your vector tile buffer size")
            }
          }
          return r
        }

        function Ha(i, t) {
          return {
            type: i.type,
            id: i.id,
            properties: i.properties,
            geometry: t ? ls(i) : []
          }
        }
        const Tm = -32768;

        function Lv(i, t, r, a, c) {
          i.emplaceBack(Tm + 8 * t + a, Tm + 8 * r + c)
        }
        class gp {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new ze, this.indexArray = new ki, this.segments = new Xr, this.programConfigurations = new ia(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, a) {
            const c = this.layers[0],
              p = [];
            let f = null,
              _ = !1,
              v = c.type === "heatmap";
            if (c.type === "circle") {
              const I = c;
              f = I.layout.get("circle-sort-key"), _ = !f.isConstant(), v = v || I.paint.get("circle-pitch-alignment") === "map"
            }
            const S = v ? r.subdivisionGranularity.circle : 1;
            for (const {
                feature: I,
                id: E,
                index: R,
                sourceLayerIndex: O
              }
              of t) {
              const j = this.layers[0]._featureFilter.needGeometry,
                Z = Ha(I, j);
              if (!this.layers[0]._featureFilter.filter(new ji(this.zoom, {
                  globalState: this.globalState
                }), Z, a)) continue;
              const Y = _ ? f.evaluate(Z, {}, a) : void 0,
                ne = {
                  id: E,
                  properties: I.properties,
                  type: I.type,
                  sourceLayerIndex: O,
                  index: R,
                  geometry: j ? Z.geometry : ls(I),
                  patterns: {},
                  sortKey: Y
                };
              p.push(ne)
            }
            _ && p.sort(((I, E) => I.sortKey - E.sortKey));
            for (const I of p) {
              const {
                geometry: E,
                index: R,
                sourceLayerIndex: O
              } = I, j = t[R].feature;
              this.addFeature(I, E, R, a, S), r.featureIndex.insert(j, E, R, O, this.index)
            }
          }
          update(t, r, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, a)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, $i), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          addFeature(t, r, a, c, p = 1) {
            let f;
            switch (p) {
              case 1:
                f = [0, 7];
                break;
              case 3:
                f = [0, 2, 5, 7];
                break;
              case 5:
                f = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                f = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${p}; valid values are 1, 3, 5, 7.`)
            }
            const _ = f.length;
            for (const v of r)
              for (const S of v) {
                const I = S.x,
                  E = S.y;
                if (I < 0 || I >= ie || E < 0 || E >= ie) continue;
                const R = this.segments.prepareSegment(_ * _, this.layoutVertexArray, this.indexArray, t.sortKey),
                  O = R.vertexLength;
                for (let j = 0; j < _; j++)
                  for (let Z = 0; Z < _; Z++) Lv(this.layoutVertexArray, I, E, f[Z], f[j]);
                for (let j = 0; j < _ - 1; j++)
                  for (let Z = 0; Z < _ - 1; Z++) {
                    const Y = O + j * _ + Z,
                      ne = O + (j + 1) * _ + Z;
                    this.indexArray.emplaceBack(Y, ne + 1, Y + 1), this.indexArray.emplaceBack(Y, ne, ne + 1)
                  }
                R.vertexLength += _ * _, R.primitiveLength += (_ - 1) * (_ - 1) * 2
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, {}, c)
          }
        }

        function Cm(i, t) {
          for (let r = 0; r < i.length; r++)
            if (zl(t, i[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (zl(i, t[r])) return !0;
          return !!vp(i, t)
        }

        function Dv(i, t, r) {
          return !!zl(i, t) || !!yp(t, i, r)
        }

        function Sm(i, t) {
          if (i.length === 1) return Im(t, i[0]);
          for (let r = 0; r < t.length; r++) {
            const a = t[r];
            for (let c = 0; c < a.length; c++)
              if (zl(i, a[c])) return !0
          }
          for (let r = 0; r < i.length; r++)
            if (Im(t, i[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (vp(i, t[r])) return !0;
          return !1
        }

        function Rv(i, t, r) {
          if (i.length > 1) {
            if (vp(i, t)) return !0;
            for (let a = 0; a < t.length; a++)
              if (yp(t[a], i, r)) return !0
          }
          for (let a = 0; a < i.length; a++)
            if (yp(i[a], t, r)) return !0;
          return !1
        }

        function vp(i, t) {
          if (i.length === 0 || t.length === 0) return !1;
          for (let r = 0; r < i.length - 1; r++) {
            const a = i[r],
              c = i[r + 1];
            for (let p = 0; p < t.length - 1; p++)
              if (Bv(a, c, t[p], t[p + 1])) return !0
          }
          return !1
        }

        function Bv(i, t, r, a) {
          return tr(i, r, a) !== tr(t, r, a) && tr(i, t, r) !== tr(i, t, a)
        }

        function yp(i, t, r) {
          const a = r * r;
          if (t.length === 1) return i.distSqr(t[0]) < a;
          for (let c = 1; c < t.length; c++)
            if (Pm(i, t[c - 1], t[c]) < a) return !0;
          return !1
        }

        function Pm(i, t, r) {
          const a = t.distSqr(r);
          if (a === 0) return i.distSqr(t);
          const c = ((i.x - t.x) * (r.x - t.x) + (i.y - t.y) * (r.y - t.y)) / a;
          return i.distSqr(c < 0 ? t : c > 1 ? r : r.sub(t)._mult(c)._add(t))
        }

        function Im(i, t) {
          let r, a, c, p = !1;
          for (let f = 0; f < i.length; f++) {
            r = i[f];
            for (let _ = 0, v = r.length - 1; _ < r.length; v = _++) a = r[_], c = r[v], a.y > t.y != c.y > t.y && t.x < (c.x - a.x) * (t.y - a.y) / (c.y - a.y) + a.x && (p = !p)
          }
          return p
        }

        function zl(i, t) {
          let r = !1;
          for (let a = 0, c = i.length - 1; a < i.length; c = a++) {
            const p = i[a],
              f = i[c];
            p.y > t.y != f.y > t.y && t.x < (f.x - p.x) * (t.y - p.y) / (f.y - p.y) + p.x && (r = !r)
          }
          return r
        }

        function Fv(i, t, r) {
          const a = r[0],
            c = r[2];
          if (i.x < a.x && t.x < a.x || i.x > c.x && t.x > c.x || i.y < a.y && t.y < a.y || i.y > c.y && t.y > c.y) return !1;
          const p = tr(i, t, r[0]);
          return p !== tr(i, t, r[1]) || p !== tr(i, t, r[2]) || p !== tr(i, t, r[3])
        }

        function tu(i, t, r) {
          const a = t.paint.get(i).value;
          return a.kind === "constant" ? a.value : r.programConfigurations.get(t.id).getMaxValue(i)
        }

        function id(i) {
          return Math.sqrt(i[0] * i[0] + i[1] * i[1])
        }

        function nd(i, t, r, a, c) {
          if (!t[0] && !t[1]) return i;
          const p = G.convert(t)._mult(c);
          r === "viewport" && p._rotate(-a);
          const f = [];
          for (let _ = 0; _ < i.length; _++) f.push(i[_].sub(p));
          return f
        }
        let Mm, Am;
        Wt("CircleBucket", gp, {
          omit: ["layers"]
        });
        var Ov = {
          get paint() {
            return Am = Am || new jn({
              "circle-radius": new Lr(ye.paint_circle["circle-radius"]),
              "circle-color": new Lr(ye.paint_circle["circle-color"]),
              "circle-blur": new Lr(ye.paint_circle["circle-blur"]),
              "circle-opacity": new Lr(ye.paint_circle["circle-opacity"]),
              "circle-translate": new hr(ye.paint_circle["circle-translate"]),
              "circle-translate-anchor": new hr(ye.paint_circle["circle-translate-anchor"]),
              "circle-pitch-scale": new hr(ye.paint_circle["circle-pitch-scale"]),
              "circle-pitch-alignment": new hr(ye.paint_circle["circle-pitch-alignment"]),
              "circle-stroke-width": new Lr(ye.paint_circle["circle-stroke-width"]),
              "circle-stroke-color": new Lr(ye.paint_circle["circle-stroke-color"]),
              "circle-stroke-opacity": new Lr(ye.paint_circle["circle-stroke-opacity"])
            })
          },
          get layout() {
            return Mm = Mm || new jn({
              "circle-sort-key": new Lr(ye.layout_circle["circle-sort-key"])
            })
          }
        };
        class Nv extends ha {
          constructor(t) {
            super(t, Ov)
          }
          createBucket(t) {
            return new gp(t)
          }
          queryRadius(t) {
            const r = t;
            return tu("circle-radius", this, r) + tu("circle-stroke-width", this, r) + id(this.paint.get("circle-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: a,
            geometry: c,
            transform: p,
            pixelsToTileUnits: f,
            unwrappedTileID: _,
            getElevation: v
          }) {
            const S = nd(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -p.bearingInRadians, f),
              I = this.paint.get("circle-radius").evaluate(r, a) + this.paint.get("circle-stroke-width").evaluate(r, a),
              E = this.paint.get("circle-pitch-alignment") === "map",
              R = E ? S : (function(j, Z, Y, ne) {
                return j.map((ke => km(ke, Z, Y, ne)))
              })(S, p, _, v),
              O = E ? I * f : I;
            for (const j of c)
              for (const Z of j) {
                const Y = E ? Z : km(Z, p, _, v);
                let ne = O;
                const ke = p.projectTileCoordinates(Z.x, Z.y, _, v).signedDistanceFromCamera;
                if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? ne *= ke / p.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (ne *= p.cameraToCenterDistance / ke), Dv(R, Y, ne)) return !0
              }
            return !1
          }
        }

        function km(i, t, r, a) {
          const c = t.projectTileCoordinates(i.x, i.y, r, a).point;
          return new G((.5 * c.x + .5) * t.width, (.5 * -c.y + .5) * t.height)
        }
        class Em extends gp {}
        let zm;
        Wt("HeatmapBucket", Em, {
          omit: ["layers"]
        });
        var jv = {
          get paint() {
            return zm = zm || new jn({
              "heatmap-radius": new Lr(ye.paint_heatmap["heatmap-radius"]),
              "heatmap-weight": new Lr(ye.paint_heatmap["heatmap-weight"]),
              "heatmap-intensity": new hr(ye.paint_heatmap["heatmap-intensity"]),
              "heatmap-color": new Pl(ye.paint_heatmap["heatmap-color"]),
              "heatmap-opacity": new hr(ye.paint_heatmap["heatmap-opacity"])
            })
          }
        };

        function xp(i, {
          width: t,
          height: r
        }, a, c) {
          if (c) {
            if (c instanceof Uint8ClampedArray) c = new Uint8Array(c.buffer);
            else if (c.length !== t * r * a) throw new RangeError(`mismatched image size. expected: ${c.length} but got: ${t*r*a}`)
          } else c = new Uint8Array(t * r * a);
          return i.width = t, i.height = r, i.data = c, i
        }

        function Lm(i, {
          width: t,
          height: r
        }, a) {
          if (t === i.width && r === i.height) return;
          const c = xp({}, {
            width: t,
            height: r
          }, a);
          bp(i, c, {
            x: 0,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            width: Math.min(i.width, t),
            height: Math.min(i.height, r)
          }, a), i.width = t, i.height = r, i.data = c.data
        }

        function bp(i, t, r, a, c, p) {
          if (c.width === 0 || c.height === 0) return t;
          if (c.width > i.width || c.height > i.height || r.x > i.width - c.width || r.y > i.height - c.height) throw new RangeError("out of range source coordinates for image copy");
          if (c.width > t.width || c.height > t.height || a.x > t.width - c.width || a.y > t.height - c.height) throw new RangeError("out of range destination coordinates for image copy");
          const f = i.data,
            _ = t.data;
          if (f === _) throw new Error("srcData equals dstData, so image is already copied");
          for (let v = 0; v < c.height; v++) {
            const S = ((r.y + v) * i.width + r.x) * p,
              I = ((a.y + v) * t.width + a.x) * p;
            for (let E = 0; E < c.width * p; E++) _[I + E] = f[S + E]
          }
          return t
        }
        class ru {
          constructor(t, r) {
            xp(this, t, 1, r)
          }
          resize(t) {
            Lm(this, t, 1)
          }
          clone() {
            return new ru({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, a, c, p) {
            bp(t, r, a, c, p, 1)
          }
        }
        class na {
          constructor(t, r) {
            xp(this, t, 4, r)
          }
          resize(t) {
            Lm(this, t, 4)
          }
          replace(t, r) {
            r ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
          }
          clone() {
            return new na({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, a, c, p) {
            bp(t, r, a, c, p, 4)
          }
          setPixel(t, r, a) {
            const c = 4 * (t * this.width + r);
            this.data[c + 0] = Math.round(255 * a.r / a.a), this.data[c + 1] = Math.round(255 * a.g / a.a), this.data[c + 2] = Math.round(255 * a.b / a.a), this.data[c + 3] = Math.round(255 * a.a)
          }
        }

        function Dm(i) {
          const t = {},
            r = i.resolution || 256,
            a = i.clips ? i.clips.length : 1,
            c = i.image || new na({
              width: r,
              height: a
            });
          if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`);
          const p = (f, _, v) => {
            t[i.evaluationKey] = v;
            const S = i.expression.evaluate(t);
            c.setPixel(f / 4 / r, _ / 4, S)
          };
          if (i.clips)
            for (let f = 0, _ = 0; f < a; ++f, _ += 4 * r)
              for (let v = 0, S = 0; v < r; v++, S += 4) {
                const I = v / (r - 1),
                  {
                    start: E,
                    end: R
                  } = i.clips[f];
                p(_, S, E * (1 - I) + R * I)
              } else
                for (let f = 0, _ = 0; f < r; f++, _ += 4) p(0, _, f / (r - 1));
          return c
        }
        Wt("AlphaImage", ru), Wt("RGBAImage", na);
        const wp = "big-fb";
        class qv extends ha {
          createBucket(t) {
            return new Em(t)
          }
          constructor(t) {
            super(t, jv), this.heatmapFbos = new Map, this._updateColorRamp()
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp()
          }
          _updateColorRamp() {
            this.colorRamp = Dm({
              expression: this._transitionablePaint._values["heatmap-color"].value.expression,
              evaluationKey: "heatmapDensity",
              image: this.colorRamp
            }), this.colorRampTexture = null
          }
          resize() {
            this.heatmapFbos.has(wp) && this.heatmapFbos.delete(wp)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            return !1
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
          }
        }
        let Rm;
        var Vv = {
          get paint() {
            return Rm = Rm || new jn({
              "hillshade-illumination-direction": new hr(ye.paint_hillshade["hillshade-illumination-direction"]),
              "hillshade-illumination-altitude": new hr(ye.paint_hillshade["hillshade-illumination-altitude"]),
              "hillshade-illumination-anchor": new hr(ye.paint_hillshade["hillshade-illumination-anchor"]),
              "hillshade-exaggeration": new hr(ye.paint_hillshade["hillshade-exaggeration"]),
              "hillshade-shadow-color": new hr(ye.paint_hillshade["hillshade-shadow-color"]),
              "hillshade-highlight-color": new hr(ye.paint_hillshade["hillshade-highlight-color"]),
              "hillshade-accent-color": new hr(ye.paint_hillshade["hillshade-accent-color"]),
              "hillshade-method": new hr(ye.paint_hillshade["hillshade-method"])
            })
          }
        };
        class Uv extends ha {
          constructor(t) {
            super(t, Vv), this.recalculate({
              zoom: 0,
              zoomHistory: {}
            }, void 0)
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values,
              r = this.paint.get("hillshade-illumination-altitude").values,
              a = this.paint.get("hillshade-highlight-color").values,
              c = this.paint.get("hillshade-shadow-color").values;
            const p = Math.max(t.length, r.length, a.length, c.length);
            t = t.concat(Array(p - t.length).fill(t.at(-1))), r = r.concat(Array(p - r.length).fill(r.at(-1))), a = a.concat(Array(p - a.length).fill(a.at(-1))), c = c.concat(Array(p - c.length).fill(c.at(-1)));
            const f = r.map(ur);
            return {
              directionRadians: t.map(ur),
              altitudeRadians: f,
              shadowColor: c,
              highlightColor: a
            }
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
          }
        }
        let Bm;
        var Zv = {
          get paint() {
            return Bm = Bm || new jn({
              "color-relief-opacity": new hr(ye["paint_color-relief"]["color-relief-opacity"]),
              "color-relief-color": new Pl(ye["paint_color-relief"]["color-relief-color"])
            })
          }
        };
        class Tp {
          constructor(t, r, a, c) {
            this.context = t, this.format = a, this.texture = t.gl.createTexture(), this.update(r, c)
          }
          update(t, r, a) {
            const {
              width: c,
              height: p
            } = t, f = !(this.size && this.size[0] === c && this.size[1] === p || a), {
              context: _
            } = this, {
              gl: v
            } = _;
            if (this.useMipmap = !!(r && r.useMipmap), v.bindTexture(v.TEXTURE_2D, this.texture), _.pixelStoreUnpackFlipY.set(!1), _.pixelStoreUnpack.set(1), _.pixelStoreUnpackPremultiplyAlpha.set(this.format === v.RGBA && (!r || r.premultiply !== !1)), f) this.size = [c, p], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || nr(t) ? v.texImage2D(v.TEXTURE_2D, 0, this.format, this.format, v.UNSIGNED_BYTE, t) : v.texImage2D(v.TEXTURE_2D, 0, this.format, c, p, 0, this.format, v.UNSIGNED_BYTE, t.data);
            else {
              const {
                x: S,
                y: I
              } = a || {
                x: 0,
                y: 0
              };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || nr(t) ? v.texSubImage2D(v.TEXTURE_2D, 0, S, I, v.RGBA, v.UNSIGNED_BYTE, t) : v.texSubImage2D(v.TEXTURE_2D, 0, S, I, c, p, v.RGBA, v.UNSIGNED_BYTE, t.data)
            }
            this.useMipmap && this.isSizePowerOfTwo() && v.generateMipmap(v.TEXTURE_2D), _.pixelStoreUnpackFlipY.setDefault(), _.pixelStoreUnpack.setDefault(), _.pixelStoreUnpackPremultiplyAlpha.setDefault()
          }
          bind(t, r, a) {
            const {
              context: c
            } = this, {
              gl: p
            } = c;
            p.bindTexture(p.TEXTURE_2D, this.texture), a !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (a = p.LINEAR), t !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, t), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, a || t), this.filter = t), r !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, r), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, r), this.wrap = r)
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
          }
          destroy() {
            const {
              gl: t
            } = this.context;
            t.deleteTexture(this.texture), this.texture = null
          }
        }
        class Fm {
          constructor(t, r, a, c = 1, p = 1, f = 1, _ = 0) {
            if (this.uid = t, r.height !== r.width) throw new RangeError("DEM tiles must be square");
            if (a && !["mapbox", "terrarium", "custom"].includes(a)) return void Lt(`"${a}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = r.height;
            const v = this.dim = r.height - 2;
            switch (this.data = new Uint32Array(r.data.buffer), a) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = c, this.greenFactor = p, this.blueFactor = f, this.baseShift = _;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4
            }
            for (let S = 0; S < v; S++) this.data[this._idx(-1, S)] = this.data[this._idx(0, S)], this.data[this._idx(v, S)] = this.data[this._idx(v - 1, S)], this.data[this._idx(S, -1)] = this.data[this._idx(S, 0)], this.data[this._idx(S, v)] = this.data[this._idx(S, v - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(v, -1)] = this.data[this._idx(v - 1, 0)], this.data[this._idx(-1, v)] = this.data[this._idx(0, v - 1)], this.data[this._idx(v, v)] = this.data[this._idx(v - 1, v - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let S = 0; S < v; S++)
              for (let I = 0; I < v; I++) {
                const E = this.get(S, I);
                E > this.max && (this.max = E), E < this.min && (this.min = E)
              }
          }
          get(t, r) {
            const a = new Uint8Array(this.data.buffer),
              c = 4 * this._idx(t, r);
            return this.unpack(a[c], a[c + 1], a[c + 2])
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
          }
          _idx(t, r) {
            if (t < -1 || t >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (r + 1) * this.stride + (t + 1)
          }
          unpack(t, r, a) {
            return t * this.redFactor + r * this.greenFactor + a * this.blueFactor - this.baseShift
          }
          pack(t) {
            return Om(t, this.getUnpackVector())
          }
          getPixels() {
            return new na({
              width: this.stride,
              height: this.stride
            }, new Uint8Array(this.data.buffer))
          }
          backfillBorder(t, r, a) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let c = r * this.dim,
              p = r * this.dim + this.dim,
              f = a * this.dim,
              _ = a * this.dim + this.dim;
            switch (r) {
              case -1:
                c = p - 1;
                break;
              case 1:
                p = c + 1
            }
            switch (a) {
              case -1:
                f = _ - 1;
                break;
              case 1:
                _ = f + 1
            }
            const v = -r * this.dim,
              S = -a * this.dim;
            for (let I = f; I < _; I++)
              for (let E = c; E < p; E++) this.data[this._idx(E, I)] = t.data[this._idx(E + v, I + S)]
          }
        }

        function Om(i, t) {
          const r = t[0],
            a = t[1],
            c = t[2],
            p = t[3],
            f = Math.min(r, a, c),
            _ = Math.round((i + p) / f);
          return {
            r: Math.floor(_ * f / r) % 256,
            g: Math.floor(_ * f / a) % 256,
            b: Math.floor(_ * f / c) % 256
          }
        }
        Wt("DEMData", Fm);
        class $v extends ha {
          constructor(t) {
            super(t, Zv)
          }
          _createColorRamp(t) {
            const r = {
                elevationStops: [],
                colorStops: []
              },
              a = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (a instanceof Po && a._styleExpression.expression instanceof Mn) {
              this.colorRampExpression = a;
              const f = a._styleExpression.expression;
              r.elevationStops = f.labels, r.colorStops = [];
              for (const _ of r.elevationStops) r.colorStops.push(f.evaluate({
                globals: {
                  elevation: _
                }
              }))
            }
            if (r.elevationStops.length < 1 && (r.elevationStops = [0], r.colorStops = [br.transparent]), r.elevationStops.length < 2 && (r.elevationStops.push(r.elevationStops[0] + 1), r.colorStops.push(r.colorStops[0])), r.elevationStops.length <= t) return r;
            const c = {
                elevationStops: [],
                colorStops: []
              },
              p = (r.elevationStops.length - 1) / (t - 1);
            for (let f = 0; f < r.elevationStops.length - .5; f += p) c.elevationStops.push(r.elevationStops[Math.round(f)]), c.colorStops.push(r.colorStops[Math.round(f)]);
            return Lt(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), c
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
          }
          getColorRampTextures(t, r, a) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const c = this._createColorRamp(r),
              p = new na({
                width: c.colorStops.length,
                height: 1
              }),
              f = new na({
                width: c.colorStops.length,
                height: 1
              });
            for (let _ = 0; _ < c.elevationStops.length; _++) {
              const v = Om(c.elevationStops[_], a);
              f.setPixel(0, _, new br(v.r / 255, v.g / 255, v.b / 255, 1)), p.setPixel(0, _, c.colorStops[_])
            }
            return this.colorRampTextures = {
              elevationTexture: new Tp(t, f, t.gl.RGBA),
              colorTexture: new Tp(t, p, t.gl.RGBA)
            }, this.colorRampTextures
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures
          }
        }
        const Gv = Xi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: Hv
          } = Gv;

        function Cp(i, t, r) {
          const a = r.patternDependencies;
          let c = !1;
          for (const p of t) {
            const f = p.paint.get(`${i}-pattern`);
            f.isConstant() || (c = !0);
            const _ = f.constantOr(null);
            _ && (c = !0, a[_.to] = !0, a[_.from] = !0)
          }
          return c
        }

        function Sp(i, t, r, a, c) {
          const p = c.patternDependencies;
          for (const f of t) {
            const _ = f.paint.get(`${i}-pattern`).value;
            if (_.kind !== "constant") {
              let v = _.evaluate({
                  zoom: a - 1
                }, r, {}, c.availableImages),
                S = _.evaluate({
                  zoom: a
                }, r, {}, c.availableImages),
                I = _.evaluate({
                  zoom: a + 1
                }, r, {}, c.availableImages);
              v = v && v.name ? v.name : v, S = S && S.name ? S.name : S, I = I && I.name ? I.name : I, p[v] = !0, p[S] = !0, p[I] = !0, r.patterns[f.id] = {
                min: v,
                mid: S,
                max: I
              }
            }
          }
          return r
        }

        function Nm(i, t, r, a, c) {
          let p;
          if (c === (function(f, _, v, S) {
              let I = 0;
              for (let E = _, R = v - S; E < v; E += S) I += (f[R] - f[E]) * (f[E + 1] + f[R + 1]), R = E;
              return I
            })(i, t, r, a) > 0)
            for (let f = t; f < r; f += a) p = Um(f / a | 0, i[f], i[f + 1], p);
          else
            for (let f = r - a; f >= t; f -= a) p = Um(f / a | 0, i[f], i[f + 1], p);
          return p && Ll(p, p.next) && (su(p), p = p.next), p
        }

        function Fo(i, t) {
          if (!i) return i;
          t || (t = i);
          let r, a = i;
          do
            if (r = !1, a.steiner || !Ll(a, a.next) && en(a.prev, a, a.next) !== 0) a = a.next;
            else {
              if (su(a), a = t = a.prev, a === a.next) break;
              r = !0
            } while (r || a !== t);
          return t
        }

        function iu(i, t, r, a, c, p, f) {
          if (!i) return;
          !f && p && (function(v, S, I, E) {
            let R = v;
            do R.z === 0 && (R.z = Pp(R.x, R.y, S, I, E)), R.prevZ = R.prev, R.nextZ = R.next, R = R.next; while (R !== v);
            R.prevZ.nextZ = null, R.prevZ = null, (function(O) {
              let j, Z = 1;
              do {
                let Y, ne = O;
                O = null;
                let ke = null;
                for (j = 0; ne;) {
                  j++;
                  let pe = ne,
                    be = 0;
                  for (let et = 0; et < Z && (be++, pe = pe.nextZ, pe); et++);
                  let Ve = Z;
                  for (; be > 0 || Ve > 0 && pe;) be !== 0 && (Ve === 0 || !pe || ne.z <= pe.z) ? (Y = ne, ne = ne.nextZ, be--) : (Y = pe, pe = pe.nextZ, Ve--), ke ? ke.nextZ = Y : O = Y, Y.prevZ = ke, ke = Y;
                  ne = pe
                }
                ke.nextZ = null, Z *= 2
              } while (j > 1)
            })(R)
          })(i, a, c, p);
          let _ = i;
          for (; i.prev !== i.next;) {
            const v = i.prev,
              S = i.next;
            if (p ? Xv(i, a, c, p) : Wv(i)) t.push(v.i, i.i, S.i), su(i), i = S.next, _ = S.next;
            else if ((i = S) === _) {
              f ? f === 1 ? iu(i = Kv(Fo(i), t), t, r, a, c, p, 2) : f === 2 && Yv(i, t, r, a, c, p) : iu(Fo(i), t, r, a, c, p, 1);
              break
            }
          }
        }

        function Wv(i) {
          const t = i.prev,
            r = i,
            a = i.next;
          if (en(t, r, a) >= 0) return !1;
          const c = t.x,
            p = r.x,
            f = a.x,
            _ = t.y,
            v = r.y,
            S = a.y,
            I = Math.min(c, p, f),
            E = Math.min(_, v, S),
            R = Math.max(c, p, f),
            O = Math.max(_, v, S);
          let j = a.next;
          for (; j !== t;) {
            if (j.x >= I && j.x <= R && j.y >= E && j.y <= O && nu(c, _, p, v, f, S, j.x, j.y) && en(j.prev, j, j.next) >= 0) return !1;
            j = j.next
          }
          return !0
        }

        function Xv(i, t, r, a) {
          const c = i.prev,
            p = i,
            f = i.next;
          if (en(c, p, f) >= 0) return !1;
          const _ = c.x,
            v = p.x,
            S = f.x,
            I = c.y,
            E = p.y,
            R = f.y,
            O = Math.min(_, v, S),
            j = Math.min(I, E, R),
            Z = Math.max(_, v, S),
            Y = Math.max(I, E, R),
            ne = Pp(O, j, t, r, a),
            ke = Pp(Z, Y, t, r, a);
          let pe = i.prevZ,
            be = i.nextZ;
          for (; pe && pe.z >= ne && be && be.z <= ke;) {
            if (pe.x >= O && pe.x <= Z && pe.y >= j && pe.y <= Y && pe !== c && pe !== f && nu(_, I, v, E, S, R, pe.x, pe.y) && en(pe.prev, pe, pe.next) >= 0 || (pe = pe.prevZ, be.x >= O && be.x <= Z && be.y >= j && be.y <= Y && be !== c && be !== f && nu(_, I, v, E, S, R, be.x, be.y) && en(be.prev, be, be.next) >= 0)) return !1;
            be = be.nextZ
          }
          for (; pe && pe.z >= ne;) {
            if (pe.x >= O && pe.x <= Z && pe.y >= j && pe.y <= Y && pe !== c && pe !== f && nu(_, I, v, E, S, R, pe.x, pe.y) && en(pe.prev, pe, pe.next) >= 0) return !1;
            pe = pe.prevZ
          }
          for (; be && be.z <= ke;) {
            if (be.x >= O && be.x <= Z && be.y >= j && be.y <= Y && be !== c && be !== f && nu(_, I, v, E, S, R, be.x, be.y) && en(be.prev, be, be.next) >= 0) return !1;
            be = be.nextZ
          }
          return !0
        }

        function Kv(i, t) {
          let r = i;
          do {
            const a = r.prev,
              c = r.next.next;
            !Ll(a, c) && qm(a, r, r.next, c) && au(a, c) && au(c, a) && (t.push(a.i, r.i, c.i), su(r), su(r.next), r = i = c), r = r.next
          } while (r !== i);
          return Fo(r)
        }

        function Yv(i, t, r, a, c, p) {
          let f = i;
          do {
            let _ = f.next.next;
            for (; _ !== f.prev;) {
              if (f.i !== _.i && r0(f, _)) {
                let v = Vm(f, _);
                return f = Fo(f, f.next), v = Fo(v, v.next), iu(f, t, r, a, c, p, 0), void iu(v, t, r, a, c, p, 0)
              }
              _ = _.next
            }
            f = f.next
          } while (f !== i)
        }

        function Jv(i, t) {
          let r = i.x - t.x;
          return r === 0 && (r = i.y - t.y, r === 0) && (r = (i.next.y - i.y) / (i.next.x - i.x) - (t.next.y - t.y) / (t.next.x - t.x)), r
        }

        function Qv(i, t) {
          const r = (function(c, p) {
            let f = p;
            const _ = c.x,
              v = c.y;
            let S, I = -1 / 0;
            if (Ll(c, f)) return f;
            do {
              if (Ll(c, f.next)) return f.next;
              if (v <= f.y && v >= f.next.y && f.next.y !== f.y) {
                const Z = f.x + (v - f.y) * (f.next.x - f.x) / (f.next.y - f.y);
                if (Z <= _ && Z > I && (I = Z, S = f.x < f.next.x ? f : f.next, Z === _)) return S
              }
              f = f.next
            } while (f !== p);
            if (!S) return null;
            const E = S,
              R = S.x,
              O = S.y;
            let j = 1 / 0;
            f = S;
            do {
              if (_ >= f.x && f.x >= R && _ !== f.x && jm(v < O ? _ : I, v, R, O, v < O ? I : _, v, f.x, f.y)) {
                const Z = Math.abs(v - f.y) / (_ - f.x);
                au(f, c) && (Z < j || Z === j && (f.x > S.x || f.x === S.x && e0(S, f))) && (S = f, j = Z)
              }
              f = f.next
            } while (f !== E);
            return S
          })(i, t);
          if (!r) return t;
          const a = Vm(r, i);
          return Fo(a, a.next), Fo(r, r.next)
        }

        function e0(i, t) {
          return en(i.prev, i, t.prev) < 0 && en(t.next, i, i.next) < 0
        }

        function Pp(i, t, r, a, c) {
          return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - r) * c | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - a) * c | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }

        function t0(i) {
          let t = i,
            r = i;
          do(t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next; while (t !== i);
          return r
        }

        function jm(i, t, r, a, c, p, f, _) {
          return (c - f) * (t - _) >= (i - f) * (p - _) && (i - f) * (a - _) >= (r - f) * (t - _) && (r - f) * (p - _) >= (c - f) * (a - _)
        }

        function nu(i, t, r, a, c, p, f, _) {
          return !(i === f && t === _) && jm(i, t, r, a, c, p, f, _)
        }

        function r0(i, t) {
          return i.next.i !== t.i && i.prev.i !== t.i && !(function(r, a) {
            let c = r;
            do {
              if (c.i !== r.i && c.next.i !== r.i && c.i !== a.i && c.next.i !== a.i && qm(c, c.next, r, a)) return !0;
              c = c.next
            } while (c !== r);
            return !1
          })(i, t) && (au(i, t) && au(t, i) && (function(r, a) {
            let c = r,
              p = !1;
            const f = (r.x + a.x) / 2,
              _ = (r.y + a.y) / 2;
            do c.y > _ != c.next.y > _ && c.next.y !== c.y && f < (c.next.x - c.x) * (_ - c.y) / (c.next.y - c.y) + c.x && (p = !p), c = c.next; while (c !== r);
            return p
          })(i, t) && (en(i.prev, i, t.prev) || en(i, t.prev, t)) || Ll(i, t) && en(i.prev, i, i.next) > 0 && en(t.prev, t, t.next) > 0)
        }

        function en(i, t, r) {
          return (t.y - i.y) * (r.x - t.x) - (t.x - i.x) * (r.y - t.y)
        }

        function Ll(i, t) {
          return i.x === t.x && i.y === t.y
        }

        function qm(i, t, r, a) {
          const c = sd(en(i, t, r)),
            p = sd(en(i, t, a)),
            f = sd(en(r, a, i)),
            _ = sd(en(r, a, t));
          return c !== p && f !== _ || !(c !== 0 || !ad(i, r, t)) || !(p !== 0 || !ad(i, a, t)) || !(f !== 0 || !ad(r, i, a)) || !(_ !== 0 || !ad(r, t, a))
        }

        function ad(i, t, r) {
          return t.x <= Math.max(i.x, r.x) && t.x >= Math.min(i.x, r.x) && t.y <= Math.max(i.y, r.y) && t.y >= Math.min(i.y, r.y)
        }

        function sd(i) {
          return i > 0 ? 1 : i < 0 ? -1 : 0
        }

        function au(i, t) {
          return en(i.prev, i, i.next) < 0 ? en(i, t, i.next) >= 0 && en(i, i.prev, t) >= 0 : en(i, t, i.prev) < 0 || en(i, i.next, t) < 0
        }

        function Vm(i, t) {
          const r = Ip(i.i, i.x, i.y),
            a = Ip(t.i, t.x, t.y),
            c = i.next,
            p = t.prev;
          return i.next = t, t.prev = i, r.next = c, c.prev = r, a.next = r, r.prev = a, p.next = a, a.prev = p, a
        }

        function Um(i, t, r, a) {
          const c = Ip(i, t, r);
          return a ? (c.next = a.next, c.prev = a, a.next.prev = c, a.next = c) : (c.prev = c, c.next = c), c
        }

        function su(i) {
          i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ)
        }

        function Ip(i, t, r) {
          return {
            i,
            x: t,
            y: r,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
          }
        }
        class Dl {
          constructor(t, r) {
            if (r > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = r
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1)
          }
        }
        class od {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle
          }
        }
        od.noSubdivision = new od({
          fill: new Dl(0, 0),
          line: new Dl(0, 0),
          tile: new Dl(0, 0),
          stencil: new Dl(0, 0),
          circle: 1
        }), Wt("SubdivisionGranularityExpression", Dl), Wt("SubdivisionGranularitySetting", od);
        const Rl = -32768,
          ou = 32767;
        class i0 {
          constructor(t, r) {
            this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = t, this._granularityCellSize = ie / t, this._canonical = r
          }
          _getKey(t, r) {
            return (t += 32768) << 16 | r + 32768
          }
          _vertexToIndex(t, r) {
            if (t < -32768 || r < -32768 || t > 32767 || r > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const a = 0 | Math.round(t),
              c = 0 | Math.round(r),
              p = this._getKey(a, c);
            if (this._vertexDictionary.has(p)) return this._vertexDictionary.get(p);
            const f = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(p, f), this._vertexBuffer.push(a, c), f
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(c, p) {
              const f = [];
              for (let _ = 0; _ < p.length; _ += 3) {
                const v = p[_],
                  S = p[_ + 1],
                  I = p[_ + 2],
                  E = c[2 * v],
                  R = c[2 * v + 1];
                (c[2 * S] - E) * (c[2 * I + 1] - R) - (c[2 * S + 1] - R) * (c[2 * I] - E) > 0 ? (f.push(v), f.push(I), f.push(S)) : (f.push(v), f.push(S), f.push(I))
              }
              return f
            })(this._vertexBuffer, t);
            const r = [],
              a = t.length;
            for (let c = 0; c < a; c += 3) {
              const p = [t[c + 0], t[c + 1], t[c + 2]],
                f = [this._vertexBuffer[2 * t[c + 0] + 0], this._vertexBuffer[2 * t[c + 0] + 1], this._vertexBuffer[2 * t[c + 1] + 0], this._vertexBuffer[2 * t[c + 1] + 1], this._vertexBuffer[2 * t[c + 2] + 0], this._vertexBuffer[2 * t[c + 2] + 1]];
              let _ = 1 / 0,
                v = 1 / 0,
                S = -1 / 0,
                I = -1 / 0;
              for (let Z = 0; Z < 3; Z++) {
                const Y = f[2 * Z],
                  ne = f[2 * Z + 1];
                _ = Math.min(_, Y), S = Math.max(S, Y), v = Math.min(v, ne), I = Math.max(I, ne)
              }
              if (_ === S || v === I) continue;
              const E = Math.floor(_ / this._granularityCellSize),
                R = Math.ceil(S / this._granularityCellSize),
                O = Math.floor(v / this._granularityCellSize),
                j = Math.ceil(I / this._granularityCellSize);
              if (E !== R || O !== j)
                for (let Z = O; Z < j; Z++) {
                  const Y = this._scanlineGenerateVertexRingForCellRow(Z, f, p);
                  n0(this._vertexBuffer, Y, r)
                } else r.push(...p)
            }
            return r
          }
          _scanlineGenerateVertexRingForCellRow(t, r, a) {
            const c = t * this._granularityCellSize,
              p = c + this._granularityCellSize,
              f = [];
            for (let _ = 0; _ < 3; _++) {
              const v = r[2 * _],
                S = r[2 * _ + 1],
                I = r[2 * (_ + 1) % 6],
                E = r[(2 * (_ + 1) + 1) % 6],
                R = r[2 * (_ + 2) % 6],
                O = r[(2 * (_ + 2) + 1) % 6],
                j = I - v,
                Z = E - S,
                Y = j === 0,
                ne = Z === 0,
                ke = (c - S) / Z,
                pe = (p - S) / Z,
                be = Math.min(ke, pe),
                Ve = Math.max(ke, pe);
              if (!ne && (be >= 1 || Ve <= 0) || ne && (S < c || S > p)) {
                E >= c && E <= p && f.push(a[(_ + 1) % 3]);
                continue
              }!ne && be > 0 && f.push(this._vertexToIndex(v + j * be, S + Z * be));
              const et = v + j * Math.max(be, 0),
                xt = v + j * Math.min(Ve, 1);
              Y || this._generateIntraEdgeVertices(f, v, S, I, E, et, xt), !ne && Ve < 1 && f.push(this._vertexToIndex(v + j * Ve, S + Z * Ve)), (ne || E >= c && E <= p) && f.push(a[(_ + 1) % 3]), !ne && (E <= c || E >= p) && this._generateInterEdgeVertices(f, v, S, I, E, R, O, xt, c, p)
            }
            return f
          }
          _generateIntraEdgeVertices(t, r, a, c, p, f, _) {
            const v = c - r,
              S = p - a,
              I = S === 0,
              E = I ? Math.min(r, c) : Math.min(f, _),
              R = I ? Math.max(r, c) : Math.max(f, _),
              O = Math.floor(E / this._granularityCellSize) + 1,
              j = Math.ceil(R / this._granularityCellSize) - 1;
            if (I ? r < c : f < _)
              for (let Z = O; Z <= j; Z++) {
                const Y = Z * this._granularityCellSize;
                t.push(this._vertexToIndex(Y, a + S * (Y - r) / v))
              } else
                for (let Z = j; Z >= O; Z--) {
                  const Y = Z * this._granularityCellSize;
                  t.push(this._vertexToIndex(Y, a + S * (Y - r) / v))
                }
          }
          _generateInterEdgeVertices(t, r, a, c, p, f, _, v, S, I) {
            const E = p - a,
              R = f - c,
              O = _ - p,
              j = (S - p) / O,
              Z = (I - p) / O,
              Y = Math.min(j, Z),
              ne = Math.max(j, Z),
              ke = c + R * Y;
            let pe = Math.floor(Math.min(ke, v) / this._granularityCellSize) + 1,
              be = Math.ceil(Math.max(ke, v) / this._granularityCellSize) - 1,
              Ve = v < ke;
            const et = O === 0;
            if (et && (_ === S || _ === I)) return;
            if (et || Y >= 1 || ne <= 0) {
              const Zt = a - _,
                Rt = f + (r - f) * Math.min((S - _) / Zt, (I - _) / Zt);
              pe = Math.floor(Math.min(Rt, v) / this._granularityCellSize) + 1, be = Math.ceil(Math.max(Rt, v) / this._granularityCellSize) - 1, Ve = v < Rt
            }
            const xt = E > 0 ? I : S;
            if (Ve)
              for (let Zt = pe; Zt <= be; Zt++) t.push(this._vertexToIndex(Zt * this._granularityCellSize, xt));
            else
              for (let Zt = be; Zt >= pe; Zt--) t.push(this._vertexToIndex(Zt * this._granularityCellSize, xt))
          }
          _generateOutline(t) {
            const r = [];
            for (const a of t) {
              const c = Oo(a, this._granularity, !0),
                p = this._pointArrayToIndices(c),
                f = [];
              for (let _ = 1; _ < p.length; _++) f.push(p[_ - 1]), f.push(p[_]);
              r.push(f)
            }
            return r
          }
          _handlePoles(t) {
            let r = !1,
              a = !1;
            this._canonical && (this._canonical.y === 0 && (r = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (a = !0)), (r || a) && this._fillPoles(t, r, a)
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let r = 0; r < t.length; r += 2) {
              const a = t[r + 1];
              a === Rl && (t[r + 1] = -32767), a === ou && (t[r + 1] = 32766)
            }
          }
          _generatePoleQuad(t, r, a, c, p, f) {
            c > p != (f === Rl) ? (t.push(r), t.push(a), t.push(this._vertexToIndex(c, f)), t.push(a), t.push(this._vertexToIndex(p, f)), t.push(this._vertexToIndex(c, f))) : (t.push(a), t.push(r), t.push(this._vertexToIndex(c, f)), t.push(this._vertexToIndex(p, f)), t.push(a), t.push(this._vertexToIndex(c, f)))
          }
          _fillPoles(t, r, a) {
            const c = this._vertexBuffer,
              p = ie,
              f = t.length;
            for (let _ = 2; _ < f; _ += 3) {
              const v = t[_ - 2],
                S = t[_ - 1],
                I = t[_],
                E = c[2 * v],
                R = c[2 * v + 1],
                O = c[2 * S],
                j = c[2 * S + 1],
                Z = c[2 * I],
                Y = c[2 * I + 1];
              r && (R === 0 && j === 0 && this._generatePoleQuad(t, v, S, E, O, Rl), j === 0 && Y === 0 && this._generatePoleQuad(t, S, I, O, Z, Rl), Y === 0 && R === 0 && this._generatePoleQuad(t, I, v, Z, E, Rl)), a && (R === p && j === p && this._generatePoleQuad(t, v, S, E, O, ou), j === p && Y === p && this._generatePoleQuad(t, S, I, O, Z, ou), Y === p && R === p && this._generatePoleQuad(t, I, v, Z, E, ou))
            }
          }
          _initializeVertices(t) {
            for (let r = 0; r < t.length; r += 2) this._vertexToIndex(t[r], t[r + 1])
          }
          subdividePolygonInternal(t, r) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const {
              flattened: a,
              holeIndices: c
            } = (function(_) {
              const v = [],
                S = [];
              for (const I of _)
                if (I.length !== 0) {
                  I !== _[0] && v.push(S.length / 2);
                  for (let E = 0; E < I.length; E++) S.push(I[E].x), S.push(I[E].y)
                } return {
                flattened: S,
                holeIndices: v
              }
            })(t);
            let p;
            this._initializeVertices(a);
            try {
              const _ = (function(S, I, E = 2) {
                  const R = I && I.length,
                    O = R ? I[0] * E : S.length;
                  let j = Nm(S, 0, O, E, !0);
                  const Z = [];
                  if (!j || j.next === j.prev) return Z;
                  let Y, ne, ke;
                  if (R && (j = (function(pe, be, Ve, et) {
                      const xt = [];
                      for (let Zt = 0, Rt = be.length; Zt < Rt; Zt++) {
                        const Vt = Nm(pe, be[Zt] * et, Zt < Rt - 1 ? be[Zt + 1] * et : pe.length, et, !1);
                        Vt === Vt.next && (Vt.steiner = !0), xt.push(t0(Vt))
                      }
                      xt.sort(Jv);
                      for (let Zt = 0; Zt < xt.length; Zt++) Ve = Qv(xt[Zt], Ve);
                      return Ve
                    })(S, I, j, E)), S.length > 80 * E) {
                    Y = S[0], ne = S[1];
                    let pe = Y,
                      be = ne;
                    for (let Ve = E; Ve < O; Ve += E) {
                      const et = S[Ve],
                        xt = S[Ve + 1];
                      et < Y && (Y = et), xt < ne && (ne = xt), et > pe && (pe = et), xt > be && (be = xt)
                    }
                    ke = Math.max(pe - Y, be - ne), ke = ke !== 0 ? 32767 / ke : 0
                  }
                  return iu(j, Z, E, Y, ne, ke, 0), Z
                })(a, c),
                v = this._convertIndices(a, _);
              p = this._subdivideTrianglesScanline(v)
            } catch (_) {
              console.error(_)
            }
            let f = [];
            return r && (f = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(p), {
              verticesFlattened: this._vertexBuffer,
              indicesTriangles: p,
              indicesLineList: f
            }
          }
          _convertIndices(t, r) {
            const a = [];
            for (let c = 0; c < r.length; c++) a.push(this._vertexToIndex(t[2 * r[c]], t[2 * r[c] + 1]));
            return a
          }
          _pointArrayToIndices(t) {
            const r = [];
            for (let a = 0; a < t.length; a++) {
              const c = t[a];
              r.push(this._vertexToIndex(c.x, c.y))
            }
            return r
          }
        }

        function Zm(i, t, r, a = !0) {
          return new i0(r, t).subdividePolygonInternal(i, a)
        }

        function Oo(i, t, r = !1) {
          if (!i || i.length < 1) return [];
          if (i.length < 2) return [];
          const a = i[0],
            c = i[i.length - 1],
            p = r && (a.x !== c.x || a.y !== c.y);
          if (t < 2) return p ? [...i, i[0]] : [...i];
          const f = Math.floor(ie / t),
            _ = [];
          _.push(new G(i[0].x, i[0].y));
          const v = i.length,
            S = p ? v : v - 1;
          for (let I = 0; I < S; I++) {
            const E = i[I],
              R = I < v - 1 ? i[I + 1] : i[0],
              O = E.x,
              j = E.y,
              Z = R.x,
              Y = R.y,
              ne = O !== Z,
              ke = j !== Y;
            if (!ne && !ke) continue;
            const pe = Z - O,
              be = Y - j,
              Ve = Math.abs(pe),
              et = Math.abs(be);
            let xt = O,
              Zt = j;
            for (;;) {
              const Vt = pe > 0 ? (Math.floor(xt / f) + 1) * f : (Math.ceil(xt / f) - 1) * f,
                fr = be > 0 ? (Math.floor(Zt / f) + 1) * f : (Math.ceil(Zt / f) - 1) * f,
                qt = Math.abs(xt - Vt),
                Ut = Math.abs(Zt - fr),
                dt = Math.abs(xt - Z),
                Br = Math.abs(Zt - Y),
                Zr = ne ? qt / Ve : Number.POSITIVE_INFINITY,
                yr = ke ? Ut / et : Number.POSITIVE_INFINITY;
              if ((dt <= qt || !ne) && (Br <= Ut || !ke)) break;
              if (Zr < yr && ne || !ke) {
                xt = Vt, Zt += be * Zr;
                const or = new G(xt, Math.round(Zt));
                _[_.length - 1].x === or.x && _[_.length - 1].y === or.y || _.push(or)
              } else {
                xt += pe * yr, Zt = fr;
                const or = new G(Math.round(xt), Zt);
                _[_.length - 1].x === or.x && _[_.length - 1].y === or.y || _.push(or)
              }
            }
            const Rt = new G(Z, Y);
            _[_.length - 1].x === Rt.x && _[_.length - 1].y === Rt.y || _.push(Rt)
          }
          return _
        }

        function n0(i, t, r) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let a = 0,
            c = i[2 * t[0]];
          for (let v = 1; v < t.length; v++) {
            const S = i[2 * t[v]];
            S < c && (c = S, a = v)
          }
          const p = t.length;
          let f = a,
            _ = (f + 1) % p;
          for (;;) {
            const v = f - 1 >= 0 ? f - 1 : p - 1,
              S = (_ + 1) % p,
              I = i[2 * t[v]],
              E = i[2 * t[S]],
              R = i[2 * t[f]],
              O = i[2 * t[f] + 1],
              j = i[2 * t[_] + 1];
            let Z = !1;
            if (I < E) Z = !0;
            else if (I > E) Z = !1;
            else {
              const Y = j - O,
                ne = -(i[2 * t[_]] - R),
                ke = O < j ? 1 : -1;
              ((I - R) * Y + (i[2 * t[v] + 1] - O) * ne) * ke > ((E - R) * Y + (i[2 * t[S] + 1] - O) * ne) * ke && (Z = !0)
            }
            if (Z) {
              const Y = t[v],
                ne = t[f],
                ke = t[_];
              Y !== ne && Y !== ke && ne !== ke && r.push(ke, ne, Y), f--, f < 0 && (f = p - 1)
            } else {
              const Y = t[S],
                ne = t[f],
                ke = t[_];
              Y !== ne && Y !== ke && ne !== ke && r.push(ke, ne, Y), _++, _ >= p && (_ = 0)
            }
            if (v === S) break
          }
        }

        function $m(i, t, r, a, c, p, f, _, v) {
          const S = c.length / 2,
            I = f && _ && v;
          if (S < Xr.MAX_VERTEX_ARRAY_LENGTH) {
            const E = t.prepareSegment(S, r, a),
              R = E.vertexLength;
            for (let Z = 0; Z < p.length; Z += 3) a.emplaceBack(R + p[Z], R + p[Z + 1], R + p[Z + 2]);
            let O, j;
            E.vertexLength += S, E.primitiveLength += p.length / 3, I && (j = f.prepareSegment(S, r, _), O = j.vertexLength, j.vertexLength += S);
            for (let Z = 0; Z < c.length; Z += 2) i(c[Z], c[Z + 1]);
            if (I)
              for (let Z = 0; Z < v.length; Z++) {
                const Y = v[Z];
                for (let ne = 1; ne < Y.length; ne += 2) _.emplaceBack(O + Y[ne - 1], O + Y[ne]);
                j.primitiveLength += Y.length / 2
              }
          } else(function(E, R, O, j, Z, Y) {
            const ne = [];
            for (let et = 0; et < j.length / 2; et++) ne.push(-1);
            const ke = {
              count: 0
            };
            let pe = 0,
              be = E.getOrCreateLatestSegment(R, O),
              Ve = be.vertexLength;
            for (let et = 2; et < Z.length; et += 3) {
              const xt = Z[et - 2],
                Zt = Z[et - 1],
                Rt = Z[et];
              let Vt = ne[xt] < pe,
                fr = ne[Zt] < pe,
                qt = ne[Rt] < pe;
              be.vertexLength + ((Vt ? 1 : 0) + (fr ? 1 : 0) + (qt ? 1 : 0)) > Xr.MAX_VERTEX_ARRAY_LENGTH && (be = E.createNewSegment(R, O), pe = ke.count, Vt = !0, fr = !0, qt = !0, Ve = 0);
              const Ut = lu(ne, j, Y, ke, xt, Vt, be),
                dt = lu(ne, j, Y, ke, Zt, fr, be),
                Br = lu(ne, j, Y, ke, Rt, qt, be);
              O.emplaceBack(Ve + Ut - pe, Ve + dt - pe, Ve + Br - pe), be.primitiveLength++
            }
          })(t, r, a, c, p, i), I && (function(E, R, O, j, Z, Y) {
            const ne = [];
            for (let et = 0; et < j.length / 2; et++) ne.push(-1);
            const ke = {
              count: 0
            };
            let pe = 0,
              be = E.getOrCreateLatestSegment(R, O),
              Ve = be.vertexLength;
            for (let et = 0; et < Z.length; et++) {
              const xt = Z[et];
              for (let Zt = 1; Zt < Z[et].length; Zt += 2) {
                const Rt = xt[Zt - 1],
                  Vt = xt[Zt];
                let fr = ne[Rt] < pe,
                  qt = ne[Vt] < pe;
                be.vertexLength + ((fr ? 1 : 0) + (qt ? 1 : 0)) > Xr.MAX_VERTEX_ARRAY_LENGTH && (be = E.createNewSegment(R, O), pe = ke.count, fr = !0, qt = !0, Ve = 0);
                const Ut = lu(ne, j, Y, ke, Rt, fr, be),
                  dt = lu(ne, j, Y, ke, Vt, qt, be);
                O.emplaceBack(Ve + Ut - pe, Ve + dt - pe), be.primitiveLength++
              }
            }
          })(f, r, _, c, v, i), t.forceNewSegmentOnNextPrepare(), f == null || f.forceNewSegmentOnNextPrepare()
        }

        function lu(i, t, r, a, c, p, f) {
          if (p) {
            const _ = a.count;
            return r(t[2 * c], t[2 * c + 1]), i[c] = a.count, a.count++, f.vertexLength++, _
          }
          return i[c]
        }
        class Mp {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new He, this.indexArray = new ki, this.indexArray2 = new Ii, this.programConfigurations = new ia(t.layers, t.zoom), this.segments = new Xr, this.segments2 = new Xr, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, a) {
            this.hasPattern = Cp("fill", this.layers, r);
            const c = this.layers[0].layout.get("fill-sort-key"),
              p = !c.isConstant(),
              f = [];
            for (const {
                feature: _,
                id: v,
                index: S,
                sourceLayerIndex: I
              }
              of t) {
              const E = this.layers[0]._featureFilter.needGeometry,
                R = Ha(_, E);
              if (!this.layers[0]._featureFilter.filter(new ji(this.zoom, {
                  globalState: this.globalState
                }), R, a)) continue;
              const O = p ? c.evaluate(R, {}, a, r.availableImages) : void 0,
                j = {
                  id: v,
                  properties: _.properties,
                  type: _.type,
                  sourceLayerIndex: I,
                  index: S,
                  geometry: E ? R.geometry : ls(_),
                  patterns: {},
                  sortKey: O
                };
              f.push(j)
            }
            p && f.sort(((_, v) => _.sortKey - v.sortKey));
            for (const _ of f) {
              const {
                geometry: v,
                index: S,
                sourceLayerIndex: I
              } = _;
              if (this.hasPattern) {
                const E = Sp("fill", this.layers, _, this.zoom, r);
                this.patternFeatures.push(E)
              } else this.addFeature(_, v, S, a, {}, r.subdivisionGranularity);
              r.featureIndex.insert(t[S].feature, v, S, I, this.index)
            }
          }
          update(t, r, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, a)
          }
          addFeatures(t, r, a) {
            for (const c of this.patternFeatures) this.addFeature(c, c.geometry, c.index, r, a, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Hv), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy())
          }
          addFeature(t, r, a, c, p, f) {
            for (const _ of bo(r, 500)) {
              const v = Zm(_, c, f.fill.getGranularityForZoomLevel(c.z)),
                S = this.layoutVertexArray;
              $m(((I, E) => {
                S.emplaceBack(I, E)
              }), this.segments, this.layoutVertexArray, this.indexArray, v.verticesFlattened, v.indicesTriangles, this.segments2, this.indexArray2, v.indicesLineList)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, c)
          }
        }
        let Gm, Hm;
        Wt("FillBucket", Mp, {
          omit: ["layers", "patternFeatures"]
        });
        var a0 = {
          get paint() {
            return Hm = Hm || new jn({
              "fill-antialias": new hr(ye.paint_fill["fill-antialias"]),
              "fill-opacity": new Lr(ye.paint_fill["fill-opacity"]),
              "fill-color": new Lr(ye.paint_fill["fill-color"]),
              "fill-outline-color": new Lr(ye.paint_fill["fill-outline-color"]),
              "fill-translate": new hr(ye.paint_fill["fill-translate"]),
              "fill-translate-anchor": new hr(ye.paint_fill["fill-translate-anchor"]),
              "fill-pattern": new Sl(ye.paint_fill["fill-pattern"])
            })
          },
          get layout() {
            return Gm = Gm || new jn({
              "fill-sort-key": new Lr(ye.layout_fill["fill-sort-key"])
            })
          }
        };
        class s0 extends ha {
          constructor(t) {
            super(t, a0)
          }
          recalculate(t, r) {
            super.recalculate(t, r);
            const a = this.paint._values["fill-outline-color"];
            a.value.kind === "constant" && a.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
          }
          createBucket(t) {
            return new Mp(t)
          }
          queryRadius() {
            return id(this.paint.get("fill-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            geometry: r,
            transform: a,
            pixelsToTileUnits: c
          }) {
            return Sm(nd(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -a.bearingInRadians, c), r)
          }
          isTileClipped() {
            return !0
          }
        }
        const o0 = Xi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_normal_ed",
            components: 4,
            type: "Int16"
          }], 4),
          l0 = Xi([{
            name: "a_centroid",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: c0
          } = o0;
        class Bl {
          constructor(t, r, a, c, p) {
            this.properties = {}, this.extent = a, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = c, this._values = p, t.readFields(u0, this, r)
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos,
              a = [];
            let c, p = 1,
              f = 0,
              _ = 0,
              v = 0;
            for (; t.pos < r;) {
              if (f <= 0) {
                const S = t.readVarint();
                p = 7 & S, f = S >> 3
              }
              if (f--, p === 1 || p === 2) _ += t.readSVarint(), v += t.readSVarint(), p === 1 && (c && a.push(c), c = []), c && c.push(new G(_, v));
              else {
                if (p !== 7) throw new Error(`unknown command ${p}`);
                c && c.push(c[0].clone())
              }
            }
            return c && a.push(c), a
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos;
            let a = 1,
              c = 0,
              p = 0,
              f = 0,
              _ = 1 / 0,
              v = -1 / 0,
              S = 1 / 0,
              I = -1 / 0;
            for (; t.pos < r;) {
              if (c <= 0) {
                const E = t.readVarint();
                a = 7 & E, c = E >> 3
              }
              if (c--, a === 1 || a === 2) p += t.readSVarint(), f += t.readSVarint(), p < _ && (_ = p), p > v && (v = p), f < S && (S = f), f > I && (I = f);
              else if (a !== 7) throw new Error(`unknown command ${a}`)
            }
            return [_, S, v, I]
          }
          toGeoJSON(t, r, a) {
            const c = this.extent * Math.pow(2, a),
              p = this.extent * t,
              f = this.extent * r,
              _ = this.loadGeometry();

            function v(R) {
              return [360 * (R.x + p) / c - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (R.y + f) / c) * Math.PI)) - 90]
            }

            function S(R) {
              return R.map(v)
            }
            let I;
            if (this.type === 1) {
              const R = [];
              for (const j of _) R.push(j[0]);
              const O = S(R);
              I = R.length === 1 ? {
                type: "Point",
                coordinates: O[0]
              } : {
                type: "MultiPoint",
                coordinates: O
              }
            } else if (this.type === 2) {
              const R = _.map(S);
              I = R.length === 1 ? {
                type: "LineString",
                coordinates: R[0]
              } : {
                type: "MultiLineString",
                coordinates: R
              }
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const R = (function(j) {
                    const Z = j.length;
                    if (Z <= 1) return [j];
                    const Y = [];
                    let ne, ke;
                    for (let pe = 0; pe < Z; pe++) {
                      const be = h0(j[pe]);
                      be !== 0 && (ke === void 0 && (ke = be < 0), ke === be < 0 ? (ne && Y.push(ne), ne = [j[pe]]) : ne && ne.push(j[pe]))
                    }
                    return ne && Y.push(ne), Y
                  })(_),
                  O = [];
                for (const j of R) O.push(j.map(S));
                I = O.length === 1 ? {
                  type: "Polygon",
                  coordinates: O[0]
                } : {
                  type: "MultiPolygon",
                  coordinates: O
                }
              }
            }
            const E = {
              type: "Feature",
              geometry: I,
              properties: this.properties
            };
            return this.id != null && (E.id = this.id), E
          }
        }

        function u0(i, t, r) {
          i === 1 ? t.id = r.readVarint() : i === 2 ? (function(a, c) {
            const p = a.readVarint() + a.pos;
            for (; a.pos < p;) {
              const f = c._keys[a.readVarint()],
                _ = c._values[a.readVarint()];
              c.properties[f] = _
            }
          })(r, t) : i === 3 ? t.type = r.readVarint() : i === 4 && (t._geometry = r.pos)
        }

        function h0(i) {
          let t = 0;
          for (let r, a, c = 0, p = i.length, f = p - 1; c < p; f = c++) r = i[c], a = i[f], t += (a.x - r.x) * (r.y + a.y);
          return t
        }
        Bl.types = ["Unknown", "Point", "LineString", "Polygon"];
        class Wm {
          constructor(t, r) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(d0, this, r), this.length = this._features.length
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const r = this._pbf.readVarint() + this._pbf.pos;
            return new Bl(this._pbf, r, this.extent, this._keys, this._values)
          }
        }

        function d0(i, t, r) {
          i === 15 ? t.version = r.readVarint() : i === 1 ? t.name = r.readString() : i === 5 ? t.extent = r.readVarint() : i === 2 ? t._features.push(r.pos) : i === 3 ? t._keys.push(r.readString()) : i === 4 && t._values.push((function(a) {
            let c = null;
            const p = a.readVarint() + a.pos;
            for (; a.pos < p;) {
              const f = a.readVarint() >> 3;
              c = f === 1 ? a.readString() : f === 2 ? a.readFloat() : f === 3 ? a.readDouble() : f === 4 ? a.readVarint64() : f === 5 ? a.readVarint() : f === 6 ? a.readSVarint() : f === 7 ? a.readBoolean() : null
            }
            if (c == null) throw new Error("unknown feature value");
            return c
          })(r))
        }
        class Xm {
          constructor(t, r) {
            this.layers = t.readFields(p0, {}, r)
          }
        }

        function p0(i, t, r) {
          if (i === 3) {
            const a = new Wm(r, r.readVarint() + r.pos);
            a.length && (t[a.name] = a)
          }
        }
        const Ap = Math.pow(2, 13);

        function cu(i, t, r, a, c, p, f, _) {
          i.emplaceBack(t, r, 2 * Math.floor(a * Ap) + f, c * Ap * 2, p * Ap * 2, Math.round(_))
        }
        class kp {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Ne, this.centroidVertexArray = new he, this.indexArray = new ki, this.programConfigurations = new ia(t.layers, t.zoom), this.segments = new Xr, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, a) {
            this.features = [], this.hasPattern = Cp("fill-extrusion", this.layers, r);
            for (const {
                feature: c,
                id: p,
                index: f,
                sourceLayerIndex: _
              }
              of t) {
              const v = this.layers[0]._featureFilter.needGeometry,
                S = Ha(c, v);
              if (!this.layers[0]._featureFilter.filter(new ji(this.zoom, {
                  globalState: this.globalState
                }), S, a)) continue;
              const I = {
                id: p,
                sourceLayerIndex: _,
                index: f,
                geometry: v ? S.geometry : ls(c),
                properties: c.properties,
                type: c.type,
                patterns: {}
              };
              this.hasPattern ? this.features.push(Sp("fill-extrusion", this.layers, I, this.zoom, r)) : this.addFeature(I, I.geometry, f, a, {}, r.subdivisionGranularity), r.featureIndex.insert(c, I.geometry, f, _, this.index, !0)
            }
          }
          addFeatures(t, r, a) {
            for (const c of this.features) {
              const {
                geometry: p
              } = c;
              this.addFeature(c, p, c.index, r, a, t.subdivisionGranularity)
            }
          }
          update(t, r, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, a)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, c0), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, l0.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy())
          }
          addFeature(t, r, a, c, p, f) {
            for (const _ of bo(r, 500)) {
              const v = {
                  x: 0,
                  y: 0,
                  sampleCount: 0
                },
                S = this.layoutVertexArray.length;
              this.processPolygon(v, c, t, _, f);
              const I = this.layoutVertexArray.length - S,
                E = Math.floor(v.x / v.sampleCount),
                R = Math.floor(v.y / v.sampleCount);
              for (let O = 0; O < I; O++) this.centroidVertexArray.emplaceBack(E, R)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, c)
          }
          processPolygon(t, r, a, c, p) {
            if (c.length < 1 || Km(c[0])) return;
            for (const E of c) E.length !== 0 && f0(t, E);
            const f = {
                segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
              },
              _ = p.fill.getGranularityForZoomLevel(r.z),
              v = Bl.types[a.type] === "Polygon";
            for (const E of c) {
              if (E.length === 0 || Km(E)) continue;
              const R = Oo(E, _, v);
              this._generateSideFaces(R, f)
            }
            if (!v) return;
            const S = Zm(c, r, _, !1),
              I = this.layoutVertexArray;
            $m(((E, R) => {
              cu(I, E, R, 0, 0, 1, 1, 0)
            }), this.segments, this.layoutVertexArray, this.indexArray, S.verticesFlattened, S.indicesTriangles)
          }
          _generateSideFaces(t, r) {
            let a = 0;
            for (let c = 1; c < t.length; c++) {
              const p = t[c],
                f = t[c - 1];
              if (m0(p, f)) continue;
              r.segment.vertexLength + 4 > Xr.MAX_VERTEX_ARRAY_LENGTH && (r.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const _ = p.sub(f)._perp()._unit(),
                v = f.dist(p);
              a + v > 32768 && (a = 0), cu(this.layoutVertexArray, p.x, p.y, _.x, _.y, 0, 0, a), cu(this.layoutVertexArray, p.x, p.y, _.x, _.y, 0, 1, a), a += v, cu(this.layoutVertexArray, f.x, f.y, _.x, _.y, 0, 0, a), cu(this.layoutVertexArray, f.x, f.y, _.x, _.y, 0, 1, a);
              const S = r.segment.vertexLength;
              this.indexArray.emplaceBack(S, S + 2, S + 1), this.indexArray.emplaceBack(S + 1, S + 2, S + 3), r.segment.vertexLength += 4, r.segment.primitiveLength += 2
            }
          }
        }

        function f0(i, t) {
          for (let r = 0; r < t.length; r++) {
            const a = t[r];
            r === t.length - 1 && t[0].x === a.x && t[0].y === a.y || (i.x += a.x, i.y += a.y, i.sampleCount++)
          }
        }

        function m0(i, t) {
          return i.x === t.x && (i.x < 0 || i.x > ie) || i.y === t.y && (i.y < 0 || i.y > ie)
        }

        function Km(i) {
          return i.every((t => t.x < 0)) || i.every((t => t.x > ie)) || i.every((t => t.y < 0)) || i.every((t => t.y > ie))
        }
        let Ym;
        Wt("FillExtrusionBucket", kp, {
          omit: ["layers", "features"]
        });
        var _0 = {
          get paint() {
            return Ym = Ym || new jn({
              "fill-extrusion-opacity": new hr(ye["paint_fill-extrusion"]["fill-extrusion-opacity"]),
              "fill-extrusion-color": new Lr(ye["paint_fill-extrusion"]["fill-extrusion-color"]),
              "fill-extrusion-translate": new hr(ye["paint_fill-extrusion"]["fill-extrusion-translate"]),
              "fill-extrusion-translate-anchor": new hr(ye["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
              "fill-extrusion-pattern": new Sl(ye["paint_fill-extrusion"]["fill-extrusion-pattern"]),
              "fill-extrusion-height": new Lr(ye["paint_fill-extrusion"]["fill-extrusion-height"]),
              "fill-extrusion-base": new Lr(ye["paint_fill-extrusion"]["fill-extrusion-base"]),
              "fill-extrusion-vertical-gradient": new hr(ye["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
            })
          }
        };
        class g0 extends ha {
          constructor(t) {
            super(t, _0)
          }
          createBucket(t) {
            return new kp(t)
          }
          queryRadius() {
            return id(this.paint.get("fill-extrusion-translate"))
          }
          is3D() {
            return !0
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: a,
            geometry: c,
            transform: p,
            pixelsToTileUnits: f,
            pixelPosMatrix: _
          }) {
            const v = nd(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -p.bearingInRadians, f),
              S = this.paint.get("fill-extrusion-height").evaluate(r, a),
              I = this.paint.get("fill-extrusion-base").evaluate(r, a),
              E = (function(O, j) {
                const Z = [];
                for (const Y of O) {
                  const ne = [Y.x, Y.y, 0, 1];
                  Ae(ne, ne, j), Z.push(new G(ne[0] / ne[3], ne[1] / ne[3]))
                }
                return Z
              })(v, _),
              R = (function(O, j, Z, Y) {
                const ne = [],
                  ke = [],
                  pe = Y[8] * j,
                  be = Y[9] * j,
                  Ve = Y[10] * j,
                  et = Y[11] * j,
                  xt = Y[8] * Z,
                  Zt = Y[9] * Z,
                  Rt = Y[10] * Z,
                  Vt = Y[11] * Z;
                for (const fr of O) {
                  const qt = [],
                    Ut = [];
                  for (const dt of fr) {
                    const Br = dt.x,
                      Zr = dt.y,
                      yr = Y[0] * Br + Y[4] * Zr + Y[12],
                      or = Y[1] * Br + Y[5] * Zr + Y[13],
                      oi = Y[2] * Br + Y[6] * Zr + Y[14],
                      Gi = Y[3] * Br + Y[7] * Zr + Y[15],
                      fn = oi + Ve,
                      Fn = Gi + et,
                      Aa = yr + xt,
                      aa = or + Zt,
                      An = oi + Rt,
                      Vi = Gi + Vt,
                      wn = new G((yr + pe) / Fn, (or + be) / Fn);
                    wn.z = fn / Fn, qt.push(wn);
                    const kn = new G(Aa / Vi, aa / Vi);
                    kn.z = An / Vi, Ut.push(kn)
                  }
                  ne.push(qt), ke.push(Ut)
                }
                return [ne, ke]
              })(c, I, S, _);
            return (function(O, j, Z) {
              let Y = 1 / 0;
              Sm(Z, j) && (Y = Jm(Z, j[0]));
              for (let ne = 0; ne < j.length; ne++) {
                const ke = j[ne],
                  pe = O[ne];
                for (let be = 0; be < ke.length - 1; be++) {
                  const Ve = ke[be],
                    et = [Ve, ke[be + 1], pe[be + 1], pe[be], Ve];
                  Cm(Z, et) && (Y = Math.min(Y, Jm(Z, et)))
                }
              }
              return Y !== 1 / 0 && Y
            })(R[0], R[1], E)
          }
        }

        function uu(i, t) {
          return i.x * t.x + i.y * t.y
        }

        function Jm(i, t) {
          if (i.length === 1) {
            let r = 0;
            const a = t[r++];
            let c;
            for (; !c || a.equals(c);)
              if (c = t[r++], !c) return 1 / 0;
            for (; r < t.length; r++) {
              const p = t[r],
                f = i[0],
                _ = c.sub(a),
                v = p.sub(a),
                S = f.sub(a),
                I = uu(_, _),
                E = uu(_, v),
                R = uu(v, v),
                O = uu(S, _),
                j = uu(S, v),
                Z = I * R - E * E,
                Y = (R * O - E * j) / Z,
                ne = (I * j - E * O) / Z,
                ke = a.z * (1 - Y - ne) + c.z * Y + p.z * ne;
              if (isFinite(ke)) return ke
            }
            return 1 / 0
          } {
            let r = 1 / 0;
            for (const a of t) r = Math.min(r, a.z);
            return r
          }
        }
        const v0 = Xi([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
          }], 4),
          {
            members: y0
          } = v0,
          x0 = Xi([{
            name: "a_uv_x",
            components: 1,
            type: "Float32"
          }, {
            name: "a_split_index",
            components: 1,
            type: "Float32"
          }]),
          {
            members: b0
          } = x0,
          w0 = Math.cos(Math.PI / 180 * 37.5),
          Qm = Math.pow(2, 14) / .5;
        class Ep {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((r => {
              this.gradients[r.id] = {}
            })), this.layoutVertexArray = new qe, this.layoutVertexArray2 = new Ge, this.indexArray = new ki, this.programConfigurations = new ia(t.layers, t.zoom), this.segments = new Xr, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, a) {
            this.hasPattern = Cp("line", this.layers, r);
            const c = this.layers[0].layout.get("line-sort-key"),
              p = !c.isConstant(),
              f = [];
            for (const {
                feature: _,
                id: v,
                index: S,
                sourceLayerIndex: I
              }
              of t) {
              const E = this.layers[0]._featureFilter.needGeometry,
                R = Ha(_, E);
              if (!this.layers[0]._featureFilter.filter(new ji(this.zoom, {
                  globalState: this.globalState
                }), R, a)) continue;
              const O = p ? c.evaluate(R, {}, a) : void 0,
                j = {
                  id: v,
                  properties: _.properties,
                  type: _.type,
                  sourceLayerIndex: I,
                  index: S,
                  geometry: E ? R.geometry : ls(_),
                  patterns: {},
                  sortKey: O
                };
              f.push(j)
            }
            p && f.sort(((_, v) => _.sortKey - v.sortKey));
            for (const _ of f) {
              const {
                geometry: v,
                index: S,
                sourceLayerIndex: I
              } = _;
              if (this.hasPattern) {
                const E = Sp("line", this.layers, _, this.zoom, r);
                this.patternFeatures.push(E)
              } else this.addFeature(_, v, S, a, {}, r.subdivisionGranularity);
              r.featureIndex.insert(t[S].feature, v, S, I, this.index)
            }
          }
          update(t, r, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, a)
          }
          addFeatures(t, r, a) {
            for (const c of this.patternFeatures) this.addFeature(c, c.geometry, c.index, r, a, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, b0)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, y0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return {
              start: +t.properties.mapbox_clip_start,
              end: +t.properties.mapbox_clip_end
            }
          }
          addFeature(t, r, a, c, p, f) {
            const _ = this.layers[0].layout,
              v = _.get("line-join").evaluate(t, {}),
              S = _.get("line-cap"),
              I = _.get("line-miter-limit"),
              E = _.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const R of r) this.addLine(R, t, v, S, I, E, c, f);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, c)
          }
          addLine(t, r, a, c, p, f, _, v) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = Oo(t, _ ? v.line.getGranularityForZoomLevel(_.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let pe = 0; pe < t.length - 1; pe++) this.totalDistance += t[pe].dist(t[pe + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
            }
            const S = Bl.types[r.type] === "Polygon";
            let I = t.length;
            for (; I >= 2 && t[I - 1].equals(t[I - 2]);) I--;
            let E = 0;
            for (; E < I - 1 && t[E].equals(t[E + 1]);) E++;
            if (I < (S ? 3 : 2)) return;
            a === "bevel" && (p = 1.05);
            const R = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
              O = this.segments.prepareSegment(10 * I, this.layoutVertexArray, this.indexArray);
            let j, Z, Y, ne, ke;
            this.e1 = this.e2 = -1, S && (j = t[I - 2], ke = t[E].sub(j)._unit()._perp());
            for (let pe = E; pe < I; pe++) {
              if (Y = pe === I - 1 ? S ? t[E + 1] : void 0 : t[pe + 1], Y && t[pe].equals(Y)) continue;
              ke && (ne = ke), j && (Z = j), j = t[pe], ke = Y ? Y.sub(j)._unit()._perp() : ne, ne = ne || ke;
              let be = ne.add(ke);
              be.x === 0 && be.y === 0 || be._unit();
              const Ve = ne.x * ke.x + ne.y * ke.y,
                et = be.x * ke.x + be.y * ke.y,
                xt = et !== 0 ? 1 / et : 1 / 0,
                Zt = 2 * Math.sqrt(2 - 2 * et),
                Rt = et < w0 && Z && Y,
                Vt = ne.x * ke.y - ne.y * ke.x > 0;
              if (Rt && pe > E) {
                const Ut = j.dist(Z);
                if (Ut > 2 * R) {
                  const dt = j.sub(j.sub(Z)._mult(R / Ut)._round());
                  this.updateDistance(Z, dt), this.addCurrentVertex(dt, ne, 0, 0, O), Z = dt
                }
              }
              const fr = Z && Y;
              let qt = fr ? a : S ? "butt" : c;
              if (fr && qt === "round" && (xt < f ? qt = "miter" : xt <= 2 && (qt = "fakeround")), qt === "miter" && xt > p && (qt = "bevel"), qt === "bevel" && (xt > 2 && (qt = "flipbevel"), xt < p && (qt = "miter")), Z && this.updateDistance(Z, j), qt === "miter") be._mult(xt), this.addCurrentVertex(j, be, 0, 0, O);
              else if (qt === "flipbevel") {
                if (xt > 100) be = ke.mult(-1);
                else {
                  const Ut = xt * ne.add(ke).mag() / ne.sub(ke).mag();
                  be._perp()._mult(Ut * (Vt ? -1 : 1))
                }
                this.addCurrentVertex(j, be, 0, 0, O), this.addCurrentVertex(j, be.mult(-1), 0, 0, O)
              } else if (qt === "bevel" || qt === "fakeround") {
                const Ut = -Math.sqrt(xt * xt - 1),
                  dt = Vt ? Ut : 0,
                  Br = Vt ? 0 : Ut;
                if (Z && this.addCurrentVertex(j, ne, dt, Br, O), qt === "fakeround") {
                  const Zr = Math.round(180 * Zt / Math.PI / 20);
                  for (let yr = 1; yr < Zr; yr++) {
                    let or = yr / Zr;
                    if (or !== .5) {
                      const Gi = or - .5;
                      or += or * Gi * (or - 1) * ((1.0904 + Ve * (Ve * (3.55645 - 1.43519 * Ve) - 3.2452)) * Gi * Gi + (.848013 + Ve * (.215638 * Ve - 1.06021)))
                    }
                    const oi = ke.sub(ne)._mult(or)._add(ne)._unit()._mult(Vt ? -1 : 1);
                    this.addHalfVertex(j, oi.x, oi.y, !1, Vt, 0, O)
                  }
                }
                Y && this.addCurrentVertex(j, ke, -dt, -Br, O)
              } else if (qt === "butt") this.addCurrentVertex(j, be, 0, 0, O);
              else if (qt === "square") {
                const Ut = Z ? 1 : -1;
                this.addCurrentVertex(j, be, Ut, Ut, O)
              } else qt === "round" && (Z && (this.addCurrentVertex(j, ne, 0, 0, O), this.addCurrentVertex(j, ne, 1, 1, O, !0)), Y && (this.addCurrentVertex(j, ke, -1, -1, O, !0), this.addCurrentVertex(j, ke, 0, 0, O)));
              if (Rt && pe < I - 1) {
                const Ut = j.dist(Y);
                if (Ut > 2 * R) {
                  const dt = j.add(Y.sub(j)._mult(R / Ut)._round());
                  this.updateDistance(j, dt), this.addCurrentVertex(dt, ke, 0, 0, O), j = dt
                }
              }
            }
          }
          addCurrentVertex(t, r, a, c, p, f = !1) {
            const _ = r.y * c - r.x,
              v = -r.y - r.x * c;
            this.addHalfVertex(t, r.x + r.y * a, r.y - r.x * a, f, !1, a, p), this.addHalfVertex(t, _, v, f, !0, -c, p), this.distance > Qm / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, r, a, c, p, f))
          }
          addHalfVertex({
            x: t,
            y: r
          }, a, c, p, f, _, v) {
            const S = .5 * (this.lineClips ? this.scaledDistance * (Qm - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (p ? 1 : 0), (r << 1) + (f ? 1 : 0), Math.round(63 * a) + 128, Math.round(63 * c) + 128, 1 + (_ === 0 ? 0 : _ < 0 ? -1 : 1) | (63 & S) << 2, S >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const I = v.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, I, this.e2), v.primitiveLength++), f ? this.e2 = I : this.e1 = I
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
          }
          updateDistance(t, r) {
            this.distance += t.dist(r), this.updateScaledDistance()
          }
        }
        let e_, t_;
        Wt("LineBucket", Ep, {
          omit: ["layers", "patternFeatures"]
        });
        var r_ = {
          get paint() {
            return t_ = t_ || new jn({
              "line-opacity": new Lr(ye.paint_line["line-opacity"]),
              "line-color": new Lr(ye.paint_line["line-color"]),
              "line-translate": new hr(ye.paint_line["line-translate"]),
              "line-translate-anchor": new hr(ye.paint_line["line-translate-anchor"]),
              "line-width": new Lr(ye.paint_line["line-width"]),
              "line-gap-width": new Lr(ye.paint_line["line-gap-width"]),
              "line-offset": new Lr(ye.paint_line["line-offset"]),
              "line-blur": new Lr(ye.paint_line["line-blur"]),
              "line-dasharray": new is(ye.paint_line["line-dasharray"]),
              "line-pattern": new Sl(ye.paint_line["line-pattern"]),
              "line-gradient": new Pl(ye.paint_line["line-gradient"])
            })
          },
          get layout() {
            return e_ = e_ || new jn({
              "line-cap": new hr(ye.layout_line["line-cap"]),
              "line-join": new Lr(ye.layout_line["line-join"]),
              "line-miter-limit": new hr(ye.layout_line["line-miter-limit"]),
              "line-round-limit": new hr(ye.layout_line["line-round-limit"]),
              "line-sort-key": new Lr(ye.layout_line["line-sort-key"])
            })
          }
        };
        class T0 extends Lr {
          possiblyEvaluate(t, r) {
            return r = new ji(Math.floor(r.zoom), {
              now: r.now,
              fadeDuration: r.fadeDuration,
              zoomHistory: r.zoomHistory,
              transition: r.transition
            }), super.possiblyEvaluate(t, r)
          }
          evaluate(t, r, a, c) {
            return r = Tt({}, r, {
              zoom: Math.floor(r.zoom)
            }), super.evaluate(t, r, a, c)
          }
        }
        let ld;
        class C0 extends ha {
          constructor(t) {
            super(t, r_), this.gradientVersion = 0, ld || (ld = new T0(r_.paint.properties["line-width"].specification), ld.useIntegerZoom = !0)
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const r = this.gradientExpression();
              this.stepInterpolant = !!(function(a) {
                return a._styleExpression !== void 0
              })(r) && r._styleExpression.expression instanceof Wi, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression
          }
          recalculate(t, r) {
            super.recalculate(t, r), this.paint._values["line-floorwidth"] = ld.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
          }
          createBucket(t) {
            return new Ep(t)
          }
          queryRadius(t) {
            const r = t,
              a = i_(tu("line-width", this, r), tu("line-gap-width", this, r)),
              c = tu("line-offset", this, r);
            return a / 2 + Math.abs(c) + id(this.paint.get("line-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: a,
            geometry: c,
            transform: p,
            pixelsToTileUnits: f
          }) {
            const _ = nd(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -p.bearingInRadians, f),
              v = f / 2 * i_(this.paint.get("line-width").evaluate(r, a), this.paint.get("line-gap-width").evaluate(r, a)),
              S = this.paint.get("line-offset").evaluate(r, a);
            return S && (c = (function(I, E) {
              const R = [];
              for (let O = 0; O < I.length; O++) {
                const j = I[O],
                  Z = [];
                for (let Y = 0; Y < j.length; Y++) {
                  const ne = j[Y - 1],
                    ke = j[Y],
                    pe = j[Y + 1],
                    be = Y === 0 ? new G(0, 0) : ke.sub(ne)._unit()._perp(),
                    Ve = Y === j.length - 1 ? new G(0, 0) : pe.sub(ke)._unit()._perp(),
                    et = be._add(Ve)._unit(),
                    xt = et.x * Ve.x + et.y * Ve.y;
                  xt !== 0 && et._mult(1 / xt), Z.push(et._mult(E)._add(ke))
                }
                R.push(Z)
              }
              return R
            })(c, S * f)), (function(I, E, R) {
              for (let O = 0; O < E.length; O++) {
                const j = E[O];
                if (I.length >= 3) {
                  for (let Z = 0; Z < j.length; Z++)
                    if (zl(I, j[Z])) return !0
                }
                if (Rv(I, j, R)) return !0
              }
              return !1
            })(_, c, v)
          }
          isTileClipped() {
            return !0
          }
        }

        function i_(i, t) {
          return t > 0 ? t + 2 * i : i
        }
        const S0 = Xi([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
          }], 4),
          P0 = Xi([{
            name: "a_projected_pos",
            components: 3,
            type: "Float32"
          }], 4);
        Xi([{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint32"
        }], 4);
        const I0 = Xi([{
          name: "a_placed",
          components: 2,
          type: "Uint8"
        }, {
          name: "a_shift",
          components: 2,
          type: "Float32"
        }, {
          name: "a_box_real",
          components: 2,
          type: "Int16"
        }]);
        Xi([{
          type: "Int16",
          name: "anchorPointX"
        }, {
          type: "Int16",
          name: "anchorPointY"
        }, {
          type: "Int16",
          name: "x1"
        }, {
          type: "Int16",
          name: "y1"
        }, {
          type: "Int16",
          name: "x2"
        }, {
          type: "Int16",
          name: "y2"
        }, {
          type: "Uint32",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "sourceLayerIndex"
        }, {
          type: "Uint16",
          name: "bucketIndex"
        }]);
        const n_ = Xi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
          }], 4),
          M0 = Xi([{
            name: "a_pos",
            components: 2,
            type: "Float32"
          }, {
            name: "a_radius",
            components: 1,
            type: "Float32"
          }, {
            name: "a_flags",
            components: 2,
            type: "Int16"
          }], 4);

        function A0(i, t, r) {
          return i.sections.forEach((a => {
            a.text = (function(c, p, f) {
              const _ = p.layout.get("text-transform").evaluate(f, {});
              return _ === "uppercase" ? c = c.toLocaleUpperCase() : _ === "lowercase" && (c = c.toLocaleLowerCase()), Ca.applyArabicShaping && (c = Ca.applyArabicShaping(c)), c
            })(a.text, t, r)
          })), i
        }
        Xi([{
          name: "triangle",
          components: 3,
          type: "Uint16"
        }]), Xi([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Uint16",
          name: "glyphStartIndex"
        }, {
          type: "Uint16",
          name: "numGlyphs"
        }, {
          type: "Uint32",
          name: "vertexStartIndex"
        }, {
          type: "Uint32",
          name: "lineStartIndex"
        }, {
          type: "Uint32",
          name: "lineLength"
        }, {
          type: "Uint16",
          name: "segment"
        }, {
          type: "Uint16",
          name: "lowerSize"
        }, {
          type: "Uint16",
          name: "upperSize"
        }, {
          type: "Float32",
          name: "lineOffsetX"
        }, {
          type: "Float32",
          name: "lineOffsetY"
        }, {
          type: "Uint8",
          name: "writingMode"
        }, {
          type: "Uint8",
          name: "placedOrientation"
        }, {
          type: "Uint8",
          name: "hidden"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Int16",
          name: "associatedIconIndex"
        }]), Xi([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Int16",
          name: "rightJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "centerJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "leftJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "placedIconSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedIconSymbolIndex"
        }, {
          type: "Uint16",
          name: "key"
        }, {
          type: "Uint16",
          name: "textBoxStartIndex"
        }, {
          type: "Uint16",
          name: "textBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxEndIndex"
        }, {
          type: "Uint16",
          name: "iconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "iconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "numHorizontalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numVerticalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numIconVertices"
        }, {
          type: "Uint16",
          name: "numVerticalIconVertices"
        }, {
          type: "Uint16",
          name: "useRuntimeCollisionCircles"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Float32",
          name: "textBoxScale"
        }, {
          type: "Float32",
          name: "collisionCircleDiameter"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetStartIndex"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetEndIndex"
        }]), Xi([{
          type: "Float32",
          name: "offsetX"
        }]), Xi([{
          type: "Int16",
          name: "x"
        }, {
          type: "Int16",
          name: "y"
        }, {
          type: "Int16",
          name: "tileUnitDistanceFromAnchor"
        }]), Xi([{
          type: "Uint16",
          name: "textAnchor"
        }, {
          type: "Float32",
          components: 2,
          name: "textOffset"
        }]);
        const hu = {
          "!": "ï¸•",
          "#": "ï¼ƒ",
          $: "ï¼„",
          "%": "ï¼…",
          "&": "ï¼†",
          "(": "ï¸µ",
          ")": "ï¸¶",
          "*": "ï¼Š",
          "+": "ï¼‹",
          ",": "ï¸",
          "-": "ï¸²",
          ".": "ãƒ»",
          "/": "ï¼",
          ":": "ï¸“",
          ";": "ï¸”",
          "<": "ï¸¿",
          "=": "ï¼",
          ">": "ï¹€",
          "?": "ï¸–",
          "@": "ï¼ ",
          "[": "ï¹‡",
          "\\": "ï¼¼",
          "]": "ï¹ˆ",
          "^": "ï¼¾",
          _: "ï¸³",
          "`": "ï½€",
          "{": "ï¸·",
          "|": "â€•",
          "}": "ï¸¸",
          "~": "ï½ž",
          "Â¢": "ï¿ ",
          "Â£": "ï¿¡",
          "Â¥": "ï¿¥",
          "Â¦": "ï¿¤",
          "Â¬": "ï¿¢",
          "Â¯": "ï¿£",
          "â€“": "ï¸²",
          "â€”": "ï¸±",
          "â€˜": "ï¹ƒ",
          "â€™": "ï¹„",
          "â€œ": "ï¹",
          "â€": "ï¹‚",
          "â€¦": "ï¸™",
          "â€§": "ãƒ»",
          "â‚©": "ï¿¦",
          "ã€": "ï¸‘",
          "ã€‚": "ï¸’",
          "ã€ˆ": "ï¸¿",
          "ã€‰": "ï¹€",
          "ã€Š": "ï¸½",
          "ã€‹": "ï¸¾",
          "ã€Œ": "ï¹",
          "ã€": "ï¹‚",
          "ã€Ž": "ï¹ƒ",
          "ã€": "ï¹„",
          "ã€": "ï¸»",
          "ã€‘": "ï¸¼",
          "ã€”": "ï¸¹",
          "ã€•": "ï¸º",
          "ã€–": "ï¸—",
          "ã€—": "ï¸˜",
          "ï¼": "ï¸•",
          "ï¼ˆ": "ï¸µ",
          "ï¼‰": "ï¸¶",
          "ï¼Œ": "ï¸",
          "ï¼": "ï¸²",
          "ï¼Ž": "ãƒ»",
          "ï¼š": "ï¸“",
          "ï¼›": "ï¸”",
          "ï¼œ": "ï¸¿",
          "ï¼ž": "ï¹€",
          "ï¼Ÿ": "ï¸–",
          "ï¼»": "ï¹‡",
          "ï¼½": "ï¹ˆ",
          "ï¼¿": "ï¸³",
          "ï½›": "ï¸·",
          "ï½œ": "â€•",
          "ï½": "ï¸¸",
          "ï½Ÿ": "ï¸µ",
          "ï½ ": "ï¸¶",
          "ï½¡": "ï¸’",
          "ï½¢": "ï¹",
          "ï½£": "ï¹‚"
        };
        var bn = 24;
        const zp = 4294967296,
          a_ = 1 / zp,
          s_ = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class Lp {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length
          }
          readFields(t, r, a = this.length) {
            for (; this.pos < a;) {
              const c = this.readVarint(),
                p = c >> 3,
                f = this.pos;
              this.type = 7 & c, t(p, r, this), this.pos === f && this.skip(c)
            }
            return r
          }
          readMessage(t, r) {
            return this.readFields(t, r, this.readVarint() + this.pos)
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, t
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, t
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * zp;
            return this.pos += 8, t
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * zp;
            return this.pos += 8, t
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, t
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, t
          }
          readVarint(t) {
            const r = this.buf;
            let a, c;
            return c = r[this.pos++], a = 127 & c, c < 128 ? a : (c = r[this.pos++], a |= (127 & c) << 7, c < 128 ? a : (c = r[this.pos++], a |= (127 & c) << 14, c < 128 ? a : (c = r[this.pos++], a |= (127 & c) << 21, c < 128 ? a : (c = r[this.pos], a |= (15 & c) << 28, (function(p, f, _) {
              const v = _.buf;
              let S, I;
              if (I = v[_.pos++], S = (112 & I) >> 4, I < 128 || (I = v[_.pos++], S |= (127 & I) << 3, I < 128) || (I = v[_.pos++], S |= (127 & I) << 10, I < 128) || (I = v[_.pos++], S |= (127 & I) << 17, I < 128) || (I = v[_.pos++], S |= (127 & I) << 24, I < 128) || (I = v[_.pos++], S |= (1 & I) << 31, I < 128)) return Fl(p, S, f);
              throw new Error("Expected varint not more than 10 bytes")
            })(a, t, this)))))
          }
          readVarint64() {
            return this.readVarint(!0)
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2
          }
          readBoolean() {
            return !!this.readVarint()
          }
          readString() {
            const t = this.readVarint() + this.pos,
              r = this.pos;
            return this.pos = t, t - r >= 12 && s_ ? s_.decode(this.buf.subarray(r, t)) : (function(a, c, p) {
              let f = "",
                _ = c;
              for (; _ < p;) {
                const v = a[_];
                let S, I, E, R = null,
                  O = v > 239 ? 4 : v > 223 ? 3 : v > 191 ? 2 : 1;
                if (_ + O > p) break;
                O === 1 ? v < 128 && (R = v) : O === 2 ? (S = a[_ + 1], (192 & S) == 128 && (R = (31 & v) << 6 | 63 & S, R <= 127 && (R = null))) : O === 3 ? (S = a[_ + 1], I = a[_ + 2], (192 & S) == 128 && (192 & I) == 128 && (R = (15 & v) << 12 | (63 & S) << 6 | 63 & I, (R <= 2047 || R >= 55296 && R <= 57343) && (R = null))) : O === 4 && (S = a[_ + 1], I = a[_ + 2], E = a[_ + 3], (192 & S) == 128 && (192 & I) == 128 && (192 & E) == 128 && (R = (15 & v) << 18 | (63 & S) << 12 | (63 & I) << 6 | 63 & E, (R <= 65535 || R >= 1114112) && (R = null))), R === null ? (R = 65533, O = 1) : R > 65535 && (R -= 65536, f += String.fromCharCode(R >>> 10 & 1023 | 55296), R = 56320 | 1023 & R), f += String.fromCharCode(R), _ += O
              }
              return f
            })(this.buf, r, t)
          }
          readBytes() {
            const t = this.readVarint() + this.pos,
              r = this.buf.subarray(this.pos, t);
            return this.pos = t, r
          }
          readPackedVarint(t = [], r) {
            const a = this.readPackedEnd();
            for (; this.pos < a;) t.push(this.readVarint(r));
            return t
          }
          readPackedSVarint(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSVarint());
            return t
          }
          readPackedBoolean(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readBoolean());
            return t
          }
          readPackedFloat(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFloat());
            return t
          }
          readPackedDouble(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readDouble());
            return t
          }
          readPackedFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed32());
            return t
          }
          readPackedSFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed32());
            return t
          }
          readPackedFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed64());
            return t
          }
          readPackedSFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed64());
            return t
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1
          }
          skip(t) {
            const r = 7 & t;
            if (r === 0)
              for (; this.buf[this.pos++] > 127;);
            else if (r === 2) this.pos = this.readVarint() + this.pos;
            else if (r === 5) this.pos += 4;
            else {
              if (r !== 1) throw new Error(`Unimplemented type: ${r}`);
              this.pos += 8
            }
          }
          writeTag(t, r) {
            this.writeVarint(t << 3 | r)
          }
          realloc(t) {
            let r = this.length || 16;
            for (; r < this.pos + t;) r *= 2;
            if (r !== this.length) {
              const a = new Uint8Array(r);
              a.set(this.buf), this.buf = a, this.dataView = new DataView(a.buffer), this.length = r
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * a_), !0), this.pos += 8
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * a_), !0), this.pos += 8
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(r, a) {
              let c, p;
              if (r >= 0 ? (c = r % 4294967296 | 0, p = r / 4294967296 | 0) : (c = ~(-r % 4294967296), p = ~(-r / 4294967296), 4294967295 ^ c ? c = c + 1 | 0 : (c = 0, p = p + 1 | 0)), r >= 18446744073709552e3 || r < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              a.realloc(10), (function(f, _, v) {
                v.buf[v.pos++] = 127 & f | 128, f >>>= 7, v.buf[v.pos++] = 127 & f | 128, f >>>= 7, v.buf[v.pos++] = 127 & f | 128, f >>>= 7, v.buf[v.pos++] = 127 & f | 128, v.buf[v.pos] = 127 & (f >>>= 7)
              })(c, 0, a), (function(f, _) {
                const v = (7 & f) << 4;
                _.buf[_.pos++] |= v | ((f >>>= 3) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f)))))
              })(p, a)
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))))
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t)
          }
          writeBoolean(t) {
            this.writeVarint(+t)
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const r = this.pos;
            this.pos = (function(c, p, f) {
              for (let _, v, S = 0; S < p.length; S++) {
                if (_ = p.charCodeAt(S), _ > 55295 && _ < 57344) {
                  if (!v) {
                    _ > 56319 || S + 1 === p.length ? (c[f++] = 239, c[f++] = 191, c[f++] = 189) : v = _;
                    continue
                  }
                  if (_ < 56320) {
                    c[f++] = 239, c[f++] = 191, c[f++] = 189, v = _;
                    continue
                  }
                  _ = v - 55296 << 10 | _ - 56320 | 65536, v = null
                } else v && (c[f++] = 239, c[f++] = 191, c[f++] = 189, v = null);
                _ < 128 ? c[f++] = _ : (_ < 2048 ? c[f++] = _ >> 6 | 192 : (_ < 65536 ? c[f++] = _ >> 12 | 224 : (c[f++] = _ >> 18 | 240, c[f++] = _ >> 12 & 63 | 128), c[f++] = _ >> 6 & 63 | 128), c[f++] = 63 & _ | 128)
              }
              return f
            })(this.buf, t, this.pos);
            const a = this.pos - r;
            a >= 128 && o_(r, a, this), this.pos = r - 1, this.writeVarint(a), this.pos += a
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8
          }
          writeBytes(t) {
            const r = t.length;
            this.writeVarint(r), this.realloc(r);
            for (let a = 0; a < r; a++) this.buf[this.pos++] = t[a]
          }
          writeRawMessage(t, r) {
            this.pos++;
            const a = this.pos;
            t(r, this);
            const c = this.pos - a;
            c >= 128 && o_(a, c, this), this.pos = a - 1, this.writeVarint(c), this.pos += c
          }
          writeMessage(t, r, a) {
            this.writeTag(t, 2), this.writeRawMessage(r, a)
          }
          writePackedVarint(t, r) {
            r.length && this.writeMessage(t, k0, r)
          }
          writePackedSVarint(t, r) {
            r.length && this.writeMessage(t, E0, r)
          }
          writePackedBoolean(t, r) {
            r.length && this.writeMessage(t, D0, r)
          }
          writePackedFloat(t, r) {
            r.length && this.writeMessage(t, z0, r)
          }
          writePackedDouble(t, r) {
            r.length && this.writeMessage(t, L0, r)
          }
          writePackedFixed32(t, r) {
            r.length && this.writeMessage(t, R0, r)
          }
          writePackedSFixed32(t, r) {
            r.length && this.writeMessage(t, B0, r)
          }
          writePackedFixed64(t, r) {
            r.length && this.writeMessage(t, F0, r)
          }
          writePackedSFixed64(t, r) {
            r.length && this.writeMessage(t, O0, r)
          }
          writeBytesField(t, r) {
            this.writeTag(t, 2), this.writeBytes(r)
          }
          writeFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeFixed32(r)
          }
          writeSFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeSFixed32(r)
          }
          writeFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeFixed64(r)
          }
          writeSFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeSFixed64(r)
          }
          writeVarintField(t, r) {
            this.writeTag(t, 0), this.writeVarint(r)
          }
          writeSVarintField(t, r) {
            this.writeTag(t, 0), this.writeSVarint(r)
          }
          writeStringField(t, r) {
            this.writeTag(t, 2), this.writeString(r)
          }
          writeFloatField(t, r) {
            this.writeTag(t, 5), this.writeFloat(r)
          }
          writeDoubleField(t, r) {
            this.writeTag(t, 1), this.writeDouble(r)
          }
          writeBooleanField(t, r) {
            this.writeVarintField(t, +r)
          }
        }

        function Fl(i, t, r) {
          return r ? 4294967296 * t + (i >>> 0) : 4294967296 * (t >>> 0) + (i >>> 0)
        }

        function o_(i, t, r) {
          const a = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          r.realloc(a);
          for (let c = r.pos - 1; c >= i; c--) r.buf[c + a] = r.buf[c]
        }

        function k0(i, t) {
          for (let r = 0; r < i.length; r++) t.writeVarint(i[r])
        }

        function E0(i, t) {
          for (let r = 0; r < i.length; r++) t.writeSVarint(i[r])
        }

        function z0(i, t) {
          for (let r = 0; r < i.length; r++) t.writeFloat(i[r])
        }

        function L0(i, t) {
          for (let r = 0; r < i.length; r++) t.writeDouble(i[r])
        }

        function D0(i, t) {
          for (let r = 0; r < i.length; r++) t.writeBoolean(i[r])
        }

        function R0(i, t) {
          for (let r = 0; r < i.length; r++) t.writeFixed32(i[r])
        }

        function B0(i, t) {
          for (let r = 0; r < i.length; r++) t.writeSFixed32(i[r])
        }

        function F0(i, t) {
          for (let r = 0; r < i.length; r++) t.writeFixed64(i[r])
        }

        function O0(i, t) {
          for (let r = 0; r < i.length; r++) t.writeSFixed64(i[r])
        }

        function N0(i, t, r) {
          i === 1 && r.readMessage(j0, t)
        }

        function j0(i, t, r) {
          if (i === 3) {
            const {
              id: a,
              bitmap: c,
              width: p,
              height: f,
              left: _,
              top: v,
              advance: S
            } = r.readMessage(q0, {});
            t.push({
              id: a,
              bitmap: new ru({
                width: p + 6,
                height: f + 6
              }, c),
              metrics: {
                width: p,
                height: f,
                left: _,
                top: v,
                advance: S
              }
            })
          }
        }

        function q0(i, t, r) {
          i === 1 ? t.id = r.readVarint() : i === 2 ? t.bitmap = r.readBytes() : i === 3 ? t.width = r.readVarint() : i === 4 ? t.height = r.readVarint() : i === 5 ? t.left = r.readSVarint() : i === 6 ? t.top = r.readSVarint() : i === 7 && (t.advance = r.readVarint())
        }

        function l_(i) {
          let t = 0,
            r = 0;
          for (const f of i) t += f.w * f.h, r = Math.max(r, f.w);
          i.sort(((f, _) => _.h - f.h));
          const a = [{
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(t / .95)), r),
            h: 1 / 0
          }];
          let c = 0,
            p = 0;
          for (const f of i)
            for (let _ = a.length - 1; _ >= 0; _--) {
              const v = a[_];
              if (!(f.w > v.w || f.h > v.h)) {
                if (f.x = v.x, f.y = v.y, p = Math.max(p, f.y + f.h), c = Math.max(c, f.x + f.w), f.w === v.w && f.h === v.h) {
                  const S = a.pop();
                  S && _ < a.length && (a[_] = S)
                } else f.h === v.h ? (v.x += f.w, v.w -= f.w) : f.w === v.w ? (v.y += f.h, v.h -= f.h) : (a.push({
                  x: v.x + f.w,
                  y: v.y,
                  w: v.w - f.w,
                  h: f.h
                }), v.y += f.h, v.h -= f.h);
                break
              }
            }
          return {
            w: c,
            h: p,
            fill: t / (c * p) || 0
          }
        }
        class Dp {
          constructor(t, {
            pixelRatio: r,
            version: a,
            stretchX: c,
            stretchY: p,
            content: f,
            textFitWidth: _,
            textFitHeight: v
          }) {
            this.paddedRect = t, this.pixelRatio = r, this.stretchX = c, this.stretchY = p, this.content = f, this.version = a, this.textFitWidth = _, this.textFitHeight = v
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1]
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
          }
          get tlbr() {
            return this.tl.concat(this.br)
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
          }
        }
        class c_ {
          constructor(t, r) {
            const a = {},
              c = {};
            this.haveRenderCallbacks = [];
            const p = [];
            this.addImages(t, a, p), this.addImages(r, c, p);
            const {
              w: f,
              h: _
            } = l_(p), v = new na({
              width: f || 1,
              height: _ || 1
            });
            for (const S in t) {
              const I = t[S],
                E = a[S].paddedRect;
              na.copy(I.data, v, {
                x: 0,
                y: 0
              }, {
                x: E.x + 1,
                y: E.y + 1
              }, I.data)
            }
            for (const S in r) {
              const I = r[S],
                E = c[S].paddedRect,
                R = E.x + 1,
                O = E.y + 1,
                j = I.data.width,
                Z = I.data.height;
              na.copy(I.data, v, {
                x: 0,
                y: 0
              }, {
                x: R,
                y: O
              }, I.data), na.copy(I.data, v, {
                x: 0,
                y: Z - 1
              }, {
                x: R,
                y: O - 1
              }, {
                width: j,
                height: 1
              }), na.copy(I.data, v, {
                x: 0,
                y: 0
              }, {
                x: R,
                y: O + Z
              }, {
                width: j,
                height: 1
              }), na.copy(I.data, v, {
                x: j - 1,
                y: 0
              }, {
                x: R - 1,
                y: O
              }, {
                width: 1,
                height: Z
              }), na.copy(I.data, v, {
                x: 0,
                y: 0
              }, {
                x: R + j,
                y: O
              }, {
                width: 1,
                height: Z
              })
            }
            this.image = v, this.iconPositions = a, this.patternPositions = c
          }
          addImages(t, r, a) {
            for (const c in t) {
              const p = t[c],
                f = {
                  x: 0,
                  y: 0,
                  w: p.data.width + 2,
                  h: p.data.height + 2
                };
              a.push(f), r[c] = new Dp(f, p), p.hasRenderCallback && this.haveRenderCallbacks.push(c)
            }
          }
          patchUpdatedImages(t, r) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const a in t.updatedImages) this.patchUpdatedImage(this.iconPositions[a], t.getImage(a), r), this.patchUpdatedImage(this.patternPositions[a], t.getImage(a), r)
          }
          patchUpdatedImage(t, r, a) {
            if (!t || !r || t.version === r.version) return;
            t.version = r.version;
            const [c, p] = t.tl;
            a.update(r.data, void 0, {
              x: c,
              y: p
            })
          }
        }
        var eo;
        Wt("ImagePosition", Dp), Wt("ImageAtlas", c_), T.ao = void 0, (eo = T.ao || (T.ao = {}))[eo.none = 0] = "none", eo[eo.horizontal = 1] = "horizontal", eo[eo.vertical = 2] = "vertical", eo[eo.horizontalOnly = 3] = "horizontalOnly";
        class du {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom"
          }
          static forText(t, r, a) {
            const c = new du;
            return c.scale = t || 1, c.fontStack = r, c.verticalAlign = a || "bottom", c
          }
          static forImage(t, r) {
            const a = new du;
            return a.imageName = t, a.verticalAlign = r || "bottom", a
          }
        }
        class Ol {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
          }
          static fromFeature(t, r) {
            const a = new Ol;
            for (let c = 0; c < t.sections.length; c++) {
              const p = t.sections[c];
              p.image ? a.addImageSection(p) : a.addTextSection(p, r)
            }
            return a
          }
          length() {
            return this.text.length
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]]
          }
          getSectionIndex(t) {
            return this.sectionIndex[t]
          }
          getCharCode(t) {
            return this.text.charCodeAt(t)
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let r = "";
              for (let a = 0; a < t.length; a++) {
                const c = t.charCodeAt(a + 1) || null,
                  p = t.charCodeAt(a - 1) || null;
                r += c && Wh(c) && !hu[t[a + 1]] || p && Wh(p) && !hu[t[a - 1]] || !hu[t[a]] ? t[a] : hu[t[a]]
              }
              return r
            })(this.text)
          }
          trim() {
            let t = 0;
            for (let a = 0; a < this.text.length && ud[this.text.charCodeAt(a)]; a++) t++;
            let r = this.text.length;
            for (let a = this.text.length - 1; a >= 0 && a >= t && ud[this.text.charCodeAt(a)]; a--) r--;
            this.text = this.text.substring(t, r), this.sectionIndex = this.sectionIndex.slice(t, r)
          }
          substring(t, r) {
            const a = new Ol;
            return a.text = this.text.substring(t, r), a.sectionIndex = this.sectionIndex.slice(t, r), a.sections = this.sections, a
          }
          toString() {
            return this.text
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, r) => Math.max(t, this.sections[r].scale)), 0)
          }
          getMaxImageSize(t) {
            let r = 0,
              a = 0;
            for (let c = 0; c < this.length(); c++) {
              const p = this.getSection(c);
              if (p.imageName) {
                const f = t[p.imageName];
                if (!f) continue;
                const _ = f.displaySize;
                r = Math.max(r, _[0]), a = Math.max(a, _[1])
              }
            }
            return {
              maxImageWidth: r,
              maxImageHeight: a
            }
          }
          addTextSection(t, r) {
            this.text += t.text, this.sections.push(du.forText(t.scale, t.fontStack || r, t.verticalAlign));
            const a = this.sections.length - 1;
            for (let c = 0; c < t.text.length; ++c) this.sectionIndex.push(a)
          }
          addImageSection(t) {
            const r = t.image ? t.image.name : "";
            if (r.length === 0) return void Lt("Can't add FormattedSection with an empty image.");
            const a = this.getNextImageSectionCharCode();
            a ? (this.text += String.fromCharCode(a), this.sections.push(du.forImage(r, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Lt("Reached maximum number of images 6401")
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
          }
        }

        function cd(i, t, r, a, c, p, f, _, v, S, I, E, R, O, j) {
          const Z = Ol.fromFeature(i, c);
          let Y;
          E === T.ao.vertical && Z.verticalizePunctuation();
          const {
            processBidirectionalText: ne,
            processStyledBidirectionalText: ke
          } = Ca;
          if (ne && Z.sections.length === 1) {
            Y = [];
            const Ve = ne(Z.toString(), Rp(Z, S, p, t, a, O));
            for (const et of Ve) {
              const xt = new Ol;
              xt.text = et, xt.sections = Z.sections;
              for (let Zt = 0; Zt < et.length; Zt++) xt.sectionIndex.push(0);
              Y.push(xt)
            }
          } else if (ke) {
            Y = [];
            const Ve = ke(Z.text, Z.sectionIndex, Rp(Z, S, p, t, a, O));
            for (const et of Ve) {
              const xt = new Ol;
              xt.text = et[0], xt.sectionIndex = et[1], xt.sections = Z.sections, Y.push(xt)
            }
          } else Y = (function(Ve, et) {
            const xt = [],
              Zt = Ve.text;
            let Rt = 0;
            for (const Vt of et) xt.push(Ve.substring(Rt, Vt)), Rt = Vt;
            return Rt < Zt.length && xt.push(Ve.substring(Rt, Zt.length)), xt
          })(Z, Rp(Z, S, p, t, a, O));
          const pe = [],
            be = {
              positionedLines: pe,
              text: Z.toString(),
              top: I[1],
              bottom: I[1],
              left: I[0],
              right: I[0],
              writingMode: E,
              iconsInText: !1,
              verticalizable: !1
            };
          return (function(Ve, et, xt, Zt, Rt, Vt, fr, qt, Ut, dt, Br, Zr) {
            let yr = 0,
              or = 0,
              oi = 0,
              Gi = 0;
            const fn = qt === "right" ? 1 : qt === "left" ? 0 : .5,
              Fn = bn / Zr;
            let Aa = 0;
            for (const Vi of Rt) {
              Vi.trim();
              const wn = Vi.getMaxScale(),
                kn = {
                  positionedGlyphs: [],
                  lineOffset: 0
                };
              Ve.positionedLines[Aa] = kn;
              const En = kn.positionedGlyphs;
              let Jn = 0;
              if (!Vi.length()) {
                or += Vt, ++Aa;
                continue
              }
              const ka = $0(Zt, Vi, Fn);
              for (let sa = 0; sa < Vi.length(); sa++) {
                const mn = Vi.getSection(sa),
                  Cn = Vi.getSectionIndex(sa),
                  Sn = Vi.getCharCode(sa),
                  on = G0(Ut, Br, Sn);
                let Fi;
                if (mn.imageName) {
                  if (Ve.iconsInText = !0, mn.scale = mn.scale * Fn, Fi = W0(mn, on, wn, ka, Zt), !Fi) continue;
                  Jn = Math.max(Jn, Fi.imageOffset)
                } else if (Fi = H0(mn, Sn, on, ka, et, xt), !Fi) continue;
                const {
                  rect: Wa,
                  metrics: Vl,
                  baselineOffset: Xa
                } = Fi;
                En.push({
                  glyph: Sn,
                  imageName: mn.imageName,
                  x: yr,
                  y: or + Xa + -17,
                  vertical: on,
                  scale: mn.scale,
                  fontStack: mn.fontStack,
                  sectionIndex: Cn,
                  metrics: Vl,
                  rect: Wa
                }), on ? (Ve.verticalizable = !0, yr += (mn.imageName ? Vl.advance : bn) * mn.scale + dt) : yr += Vl.advance * mn.scale + dt
              }
              En.length !== 0 && (oi = Math.max(yr - dt, oi), X0(En, 0, En.length - 1, fn)), yr = 0, kn.lineOffset = Math.max(Jn, (wn - 1) * bn);
              const Tn = Vt * wn + Jn;
              or += Tn, Gi = Math.max(Tn, Gi), ++Aa
            }
            const {
              horizontalAlign: aa,
              verticalAlign: An
            } = Bp(fr);
            (function(Vi, wn, kn, En, Jn, ka, Tn, sa, mn) {
              const Cn = (wn - kn) * Jn;
              let Sn = 0;
              Sn = ka !== Tn ? -sa * En - -17 : -En * mn * Tn + .5 * Tn;
              for (const on of Vi)
                for (const Fi of on.positionedGlyphs) Fi.x += Cn, Fi.y += Sn
            })(Ve.positionedLines, fn, aa, An, oi, Gi, Vt, or, Rt.length), Ve.top += -An * or, Ve.bottom = Ve.top + or, Ve.left += -aa * oi, Ve.right = Ve.left + oi
          })(be, t, r, a, Y, f, _, v, E, S, R, j), !(function(Ve) {
            for (const et of Ve)
              if (et.positionedGlyphs.length !== 0) return !1;
            return !0
          })(pe) && be
        }
        const ud = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
          },
          V0 = {
            10: !0,
            32: !0,
            38: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
          },
          U0 = {
            40: !0
          };

        function u_(i, t, r, a, c, p) {
          if (t.imageName) {
            const f = a[t.imageName];
            return f ? f.displaySize[0] * t.scale * bn / p + c : 0
          } {
            const f = r[t.fontStack],
              _ = f && f[i];
            return _ ? _.metrics.advance * t.scale + c : 0
          }
        }

        function h_(i, t, r, a) {
          const c = Math.pow(i - t, 2);
          return a ? i < t ? c / 2 : 2 * c : c + Math.abs(r) * r
        }

        function Z0(i, t, r) {
          let a = 0;
          return i === 10 && (a -= 1e4), r && (a += 150), i !== 40 && i !== 65288 || (a += 50), t !== 41 && t !== 65289 || (a += 50), a
        }

        function d_(i, t, r, a, c, p) {
          let f = null,
            _ = h_(t, r, c, p);
          for (const v of a) {
            const S = h_(t - v.x, r, c, p) + v.badness;
            S <= _ && (f = v, _ = S)
          }
          return {
            index: i,
            x: t,
            priorBreak: f,
            badness: _
          }
        }

        function p_(i) {
          return i ? p_(i.priorBreak).concat(i.index) : []
        }

        function Rp(i, t, r, a, c, p) {
          if (!i) return [];
          const f = [],
            _ = (function(E, R, O, j, Z, Y) {
              let ne = 0;
              for (let ke = 0; ke < E.length(); ke++) {
                const pe = E.getSection(ke);
                ne += u_(E.getCharCode(ke), pe, j, Z, R, Y)
              }
              return ne / Math.max(1, Math.ceil(ne / O))
            })(i, t, r, a, c, p),
            v = i.text.indexOf("â€‹") >= 0;
          let S = 0;
          for (let E = 0; E < i.length(); E++) {
            const R = i.getSection(E),
              O = i.getCharCode(E);
            if (ud[O] || (S += u_(O, R, a, c, t, p)), E < i.length() - 1) {
              const j = !((I = O) < 11904) && (!!si["CJK Compatibility Forms"](I) || !!si["CJK Compatibility"](I) || !!si["CJK Strokes"](I) || !!si["CJK Symbols and Punctuation"](I) || !!si["Enclosed CJK Letters and Months"](I) || !!si["Halfwidth and Fullwidth Forms"](I) || !!si["Ideographic Description Characters"](I) || !!si["Vertical Forms"](I) || Zc.test(String.fromCodePoint(I)));
              (V0[O] || j || R.imageName || E !== i.length() - 2 && U0[i.getCharCode(E + 1)]) && f.push(d_(E + 1, S, _, f, Z0(O, i.getCharCode(E + 1), j && v), !1))
            }
          }
          var I;
          return p_(d_(i.length(), S, _, f, 0, !0))
        }

        function Bp(i) {
          let t = .5,
            r = .5;
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0
          }
          switch (i) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r = 0
          }
          return {
            horizontalAlign: t,
            verticalAlign: r
          }
        }

        function $0(i, t, r) {
          const a = t.getMaxScale() * bn,
            {
              maxImageWidth: c,
              maxImageHeight: p
            } = t.getMaxImageSize(i),
            f = Math.max(a, p * r);
          return {
            verticalLineContentWidth: Math.max(a, c * r),
            horizontalLineContentHeight: f
          }
        }

        function f_(i) {
          switch (i) {
            case "top":
              return 0;
            case "center":
              return .5;
            default:
              return 1
          }
        }

        function G0(i, t, r) {
          return !(i === T.ao.horizontal || !t && !$c(r) || t && (ud[r] || (a = r, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(a)))));
          var a
        }

        function H0(i, t, r, a, c, p) {
          const f = p[i.fontStack],
            _ = (function(S, I, E, R) {
              if (S && S.rect) return S;
              const O = I[E.fontStack],
                j = O && O[R];
              return j ? {
                rect: null,
                metrics: j.metrics
              } : null
            })(f && f[t], c, i, t);
          if (_ === null) return null;
          let v;
          if (r) v = a.verticalLineContentWidth - i.scale * bn;
          else {
            const S = f_(i.verticalAlign);
            v = (a.horizontalLineContentHeight - i.scale * bn) * S
          }
          return {
            rect: _.rect,
            metrics: _.metrics,
            baselineOffset: v
          }
        }

        function W0(i, t, r, a, c) {
          const p = c[i.imageName];
          if (!p) return null;
          const f = p.paddedRect,
            _ = p.displaySize,
            v = {
              width: _[0],
              height: _[1],
              left: 1,
              top: -3,
              advance: t ? _[1] : _[0]
            };
          let S;
          if (t) S = a.verticalLineContentWidth - _[1] * i.scale;
          else {
            const I = f_(i.verticalAlign);
            S = (a.horizontalLineContentHeight - _[1] * i.scale) * I
          }
          return {
            rect: f,
            metrics: v,
            baselineOffset: S,
            imageOffset: (t ? _[0] : _[1]) * i.scale - bn * r
          }
        }

        function X0(i, t, r, a) {
          if (a === 0) return;
          const c = i[r],
            p = (i[r].x + c.metrics.advance * c.scale) * a;
          for (let f = t; f <= r; f++) i[f].x -= p
        }

        function K0(i, t, r) {
          const {
            horizontalAlign: a,
            verticalAlign: c
          } = Bp(r), p = t[0] - i.displaySize[0] * a, f = t[1] - i.displaySize[1] * c;
          return {
            image: i,
            top: f,
            bottom: f + i.displaySize[1],
            left: p,
            right: p + i.displaySize[0]
          }
        }

        function m_(i) {
          var t, r;
          let a = i.left,
            c = i.top,
            p = i.right - a,
            f = i.bottom - c;
          const _ = (t = i.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink",
            v = (r = i.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink",
            S = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
          if (v === "proportional") {
            if (_ === "stretchOnly" && p / f < S || _ === "proportional") {
              const I = Math.ceil(f * S);
              a *= I / p, p = I
            }
          } else if (_ === "proportional" && v === "stretchOnly" && S !== 0 && p / f > S) {
            const I = Math.ceil(p / S);
            c *= I / f, f = I
          }
          return {
            x1: a,
            y1: c,
            x2: a + p,
            y2: c + f
          }
        }

        function __(i, t, r, a, c, p) {
          const f = i.image;
          let _;
          if (f.content) {
            const Y = f.content,
              ne = f.pixelRatio || 1;
            _ = [Y[0] / ne, Y[1] / ne, f.displaySize[0] - Y[2] / ne, f.displaySize[1] - Y[3] / ne]
          }
          const v = t.left * p,
            S = t.right * p;
          let I, E, R, O;
          r === "width" || r === "both" ? (O = c[0] + v - a[3], E = c[0] + S + a[1]) : (O = c[0] + (v + S - f.displaySize[0]) / 2, E = O + f.displaySize[0]);
          const j = t.top * p,
            Z = t.bottom * p;
          return r === "height" || r === "both" ? (I = c[1] + j - a[0], R = c[1] + Z + a[2]) : (I = c[1] + (j + Z - f.displaySize[1]) / 2, R = I + f.displaySize[1]), {
            image: f,
            top: I,
            right: E,
            bottom: R,
            left: O,
            collisionPadding: _
          }
        }
        const Ms = 128,
          to = 32640;

        function g_(i, t) {
          const {
            expression: r
          } = t;
          if (r.kind === "constant") return {
            kind: "constant",
            layoutSize: r.evaluate(new ji(i + 1))
          };
          if (r.kind === "source") return {
            kind: "source"
          };
          {
            const {
              zoomStops: a,
              interpolationType: c
            } = r;
            let p = 0;
            for (; p < a.length && a[p] <= i;) p++;
            p = Math.max(0, p - 1);
            let f = p;
            for (; f < a.length && a[f] < i + 1;) f++;
            f = Math.min(a.length - 1, f);
            const _ = a[p],
              v = a[f];
            return r.kind === "composite" ? {
              kind: "composite",
              minZoom: _,
              maxZoom: v,
              interpolationType: c
            } : {
              kind: "camera",
              minZoom: _,
              maxZoom: v,
              minSize: r.evaluate(new ji(_)),
              maxSize: r.evaluate(new ji(v)),
              interpolationType: c
            }
          }
        }

        function Fp(i, t, r) {
          let a = "never";
          const c = i.get(t);
          return c ? a = c : i.get(r) && (a = "always"), a
        }
        const Y0 = [{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint8",
          offset: 0
        }];

        function hd(i, t, r, a, c, p, f, _, v, S, I, E, R) {
          const O = _ ? Math.min(to, Math.round(_[0])) : 0,
            j = _ ? Math.min(to, Math.round(_[1])) : 0;
          i.emplaceBack(t, r, Math.round(32 * a), Math.round(32 * c), p, f, (O << 1) + (v ? 1 : 0), j, 16 * S, 16 * I, 256 * E, 256 * R)
        }

        function Op(i, t, r) {
          i.emplaceBack(t.x, t.y, r), i.emplaceBack(t.x, t.y, r), i.emplaceBack(t.x, t.y, r), i.emplaceBack(t.x, t.y, r)
        }

        function J0(i) {
          for (const t of i.sections)
            if (Yh(t.text)) return !0;
          return !1
        }
        class Np {
          constructor(t) {
            this.layoutVertexArray = new Ft, this.indexArray = new ki, this.programConfigurations = t, this.segments = new Xr, this.dynamicLayoutVertexArray = new vt, this.opacityVertexArray = new sr, this.hasVisibleVertices = !1, this.placedSymbolArray = new U
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
          }
          upload(t, r, a, c) {
            this.isEmpty() || (a && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, S0.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, P0.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Y0, !0), this.opacityVertexBuffer.itemSize = 1), (a || c) && this.programConfigurations.upload(t))
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy())
          }
        }
        Wt("SymbolBuffers", Np);
        class jp {
          constructor(t, r, a) {
            this.layoutVertexArray = new t, this.layoutAttributes = r, this.indexArray = new a, this.segments = new Xr, this.collisionVertexArray = new wi
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, I0.members, !0)
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy())
          }
        }
        Wt("CollisionBuffers", jp);
        class Nl {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((f => f.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const r = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = g_(this.zoom, r["text-size"]), this.iconSizeData = g_(this.zoom, r["icon-size"]);
            const a = this.layers[0].layout,
              c = a.get("symbol-sort-key"),
              p = a.get("symbol-z-order");
            this.canOverlap = Fp(a, "text-overlap", "text-allow-overlap") !== "never" || Fp(a, "icon-overlap", "icon-allow-overlap") !== "never" || a.get("text-ignore-placement") || a.get("icon-ignore-placement"), this.sortFeaturesByKey = p !== "viewport-y" && !c.isConstant(), this.sortFeaturesByY = (p === "viewport-y" || p === "auto" && !this.sortFeaturesByKey) && this.canOverlap, a.get("symbol-placement") === "point" && (this.writingModes = a.get("text-writing-mode").map((f => T.ao[f]))), this.stateDependentLayerIds = this.layers.filter((f => f.isStateDependent())).map((f => f.id)), this.sourceID = t.sourceID
          }
          createArrays() {
            this.text = new Np(new ia(this.layers, this.zoom, (t => /^text/.test(t)))), this.icon = new Np(new ia(this.layers, this.zoom, (t => /^icon/.test(t)))), this.glyphOffsetArray = new re, this.lineVertexArray = new se, this.symbolInstances = new J, this.textAnchorOffsets = new ue
          }
          calculateGlyphDependencies(t, r, a, c, p) {
            for (let f = 0; f < t.length; f++)
              if (r[t.charCodeAt(f)] = !0, (a || c) && p) {
                const _ = hu[t.charAt(f)];
                _ && (r[_.charCodeAt(0)] = !0)
              }
          }
          populate(t, r, a) {
            const c = this.layers[0],
              p = c.layout,
              f = p.get("text-font"),
              _ = p.get("text-field"),
              v = p.get("icon-image"),
              S = (_.value.kind !== "constant" || _.value.value instanceof Ji && !_.value.value.isEmpty() || _.value.value.toString().length > 0) && (f.value.kind !== "constant" || f.value.value.length > 0),
              I = v.value.kind !== "constant" || !!v.value.value || Object.keys(v.parameters).length > 0,
              E = p.get("symbol-sort-key");
            if (this.features = [], !S && !I) return;
            const R = r.iconDependencies,
              O = r.glyphDependencies,
              j = r.availableImages,
              Z = new ji(this.zoom, {
                globalState: this.globalState
              });
            for (const {
                feature: Y,
                id: ne,
                index: ke,
                sourceLayerIndex: pe
              }
              of t) {
              const be = c._featureFilter.needGeometry,
                Ve = Ha(Y, be);
              if (!c._featureFilter.filter(Z, Ve, a)) continue;
              let et, xt;
              if (be || (Ve.geometry = ls(Y)), S) {
                const Rt = c.getValueAndResolveTokens("text-field", Ve, a, j),
                  Vt = Ji.factory(Rt),
                  fr = this.hasRTLText = this.hasRTLText || J0(Vt);
                (!fr || Ca.getRTLTextPluginStatus() === "unavailable" || fr && Ca.isParsed()) && (et = A0(Vt, c, Ve))
              }
              if (I) {
                const Rt = c.getValueAndResolveTokens("icon-image", Ve, a, j);
                xt = Rt instanceof Nn ? Rt : Nn.fromString(Rt)
              }
              if (!et && !xt) continue;
              const Zt = this.sortFeaturesByKey ? E.evaluate(Ve, {}, a) : void 0;
              if (this.features.push({
                  id: ne,
                  text: et,
                  icon: xt,
                  index: ke,
                  sourceLayerIndex: pe,
                  geometry: Ve.geometry,
                  properties: Y.properties,
                  type: Bl.types[Y.type],
                  sortKey: Zt
                }), xt && (R[xt.name] = !0), et) {
                const Rt = f.evaluate(Ve, {}, a).join(","),
                  Vt = p.get("text-rotation-alignment") !== "viewport" && p.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(T.ao.vertical) >= 0;
                for (const fr of et.sections)
                  if (fr.image) R[fr.image.name] = !0;
                  else {
                    const qt = wl(et.toString()),
                      Ut = fr.fontStack || Rt,
                      dt = O[Ut] = O[Ut] || {};
                    this.calculateGlyphDependencies(fr.text, dt, Vt, this.allowVerticalPlacement, qt)
                  }
              }
            }
            p.get("symbol-placement") === "line" && (this.features = (function(Y) {
              const ne = {},
                ke = {},
                pe = [];
              let be = 0;

              function Ve(Rt) {
                pe.push(Y[Rt]), be++
              }

              function et(Rt, Vt, fr) {
                const qt = ke[Rt];
                return delete ke[Rt], ke[Vt] = qt, pe[qt].geometry[0].pop(), pe[qt].geometry[0] = pe[qt].geometry[0].concat(fr[0]), qt
              }

              function xt(Rt, Vt, fr) {
                const qt = ne[Vt];
                return delete ne[Vt], ne[Rt] = qt, pe[qt].geometry[0].shift(), pe[qt].geometry[0] = fr[0].concat(pe[qt].geometry[0]), qt
              }

              function Zt(Rt, Vt, fr) {
                const qt = fr ? Vt[0][Vt[0].length - 1] : Vt[0][0];
                return `${Rt}:${qt.x}:${qt.y}`
              }
              for (let Rt = 0; Rt < Y.length; Rt++) {
                const Vt = Y[Rt],
                  fr = Vt.geometry,
                  qt = Vt.text ? Vt.text.toString() : null;
                if (!qt) {
                  Ve(Rt);
                  continue
                }
                const Ut = Zt(qt, fr),
                  dt = Zt(qt, fr, !0);
                if (Ut in ke && dt in ne && ke[Ut] !== ne[dt]) {
                  const Br = xt(Ut, dt, fr),
                    Zr = et(Ut, dt, pe[Br].geometry);
                  delete ne[Ut], delete ke[dt], ke[Zt(qt, pe[Zr].geometry, !0)] = Zr, pe[Br].geometry = null
                } else Ut in ke ? et(Ut, dt, fr) : dt in ne ? xt(Ut, dt, fr) : (Ve(Rt), ne[Ut] = be - 1, ke[dt] = be - 1)
              }
              return pe.filter((Rt => Rt.geometry))
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((Y, ne) => Y.sortKey - ne.sortKey))
          }
          update(t, r, a) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, r, this.layers, a), this.icon.programConfigurations.updatePaintArrays(t, r, this.layers, a))
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
          }
          addToLineVertexArray(t, r) {
            const a = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let c = t.dist(r[t.segment + 1]),
                p = t.dist(r[t.segment]);
              const f = {};
              for (let _ = t.segment + 1; _ < r.length; _++) f[_] = {
                x: r[_].x,
                y: r[_].y,
                tileUnitDistanceFromAnchor: c
              }, _ < r.length - 1 && (c += r[_ + 1].dist(r[_]));
              for (let _ = t.segment || 0; _ >= 0; _--) f[_] = {
                x: r[_].x,
                y: r[_].y,
                tileUnitDistanceFromAnchor: p
              }, _ > 0 && (p += r[_ - 1].dist(r[_]));
              for (let _ = 0; _ < r.length; _++) {
                const v = f[_];
                this.lineVertexArray.emplaceBack(v.x, v.y, v.tileUnitDistanceFromAnchor)
              }
            }
            return {
              lineStartIndex: a,
              lineLength: this.lineVertexArray.length - a
            }
          }
          addSymbols(t, r, a, c, p, f, _, v, S, I, E, R) {
            const O = t.indexArray,
              j = t.layoutVertexArray,
              Z = t.segments.prepareSegment(4 * r.length, j, O, this.canOverlap ? f.sortKey : void 0),
              Y = this.glyphOffsetArray.length,
              ne = Z.vertexLength,
              ke = this.allowVerticalPlacement && _ === T.ao.vertical ? Math.PI / 2 : 0,
              pe = f.text && f.text.sections;
            for (let be = 0; be < r.length; be++) {
              const {
                tl: Ve,
                tr: et,
                bl: xt,
                br: Zt,
                tex: Rt,
                pixelOffsetTL: Vt,
                pixelOffsetBR: fr,
                minFontScaleX: qt,
                minFontScaleY: Ut,
                glyphOffset: dt,
                isSDF: Br,
                sectionIndex: Zr
              } = r[be], yr = Z.vertexLength, or = dt[1];
              hd(j, v.x, v.y, Ve.x, or + Ve.y, Rt.x, Rt.y, a, Br, Vt.x, Vt.y, qt, Ut), hd(j, v.x, v.y, et.x, or + et.y, Rt.x + Rt.w, Rt.y, a, Br, fr.x, Vt.y, qt, Ut), hd(j, v.x, v.y, xt.x, or + xt.y, Rt.x, Rt.y + Rt.h, a, Br, Vt.x, fr.y, qt, Ut), hd(j, v.x, v.y, Zt.x, or + Zt.y, Rt.x + Rt.w, Rt.y + Rt.h, a, Br, fr.x, fr.y, qt, Ut), Op(t.dynamicLayoutVertexArray, v, ke), O.emplaceBack(yr, yr + 2, yr + 1), O.emplaceBack(yr + 1, yr + 2, yr + 3), Z.vertexLength += 4, Z.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(dt[0]), be !== r.length - 1 && Zr === r[be + 1].sectionIndex || t.programConfigurations.populatePaintArrays(j.length, f, f.index, {}, R, pe && pe[Zr])
            }
            t.placedSymbolArray.emplaceBack(v.x, v.y, Y, this.glyphOffsetArray.length - Y, ne, S, I, v.segment, a ? a[0] : 0, a ? a[1] : 0, c[0], c[1], _, 0, !1, 0, E)
          }
          _addCollisionDebugVertex(t, r, a, c, p, f) {
            return r.emplaceBack(0, 0), t.emplaceBack(a.x, a.y, c, p, Math.round(f.x), Math.round(f.y))
          }
          addCollisionDebugVertices(t, r, a, c, p, f, _) {
            const v = p.segments.prepareSegment(4, p.layoutVertexArray, p.indexArray),
              S = v.vertexLength,
              I = p.layoutVertexArray,
              E = p.collisionVertexArray,
              R = _.anchorX,
              O = _.anchorY;
            this._addCollisionDebugVertex(I, E, f, R, O, new G(t, r)), this._addCollisionDebugVertex(I, E, f, R, O, new G(a, r)), this._addCollisionDebugVertex(I, E, f, R, O, new G(a, c)), this._addCollisionDebugVertex(I, E, f, R, O, new G(t, c)), v.vertexLength += 4;
            const j = p.indexArray;
            j.emplaceBack(S, S + 1), j.emplaceBack(S + 1, S + 2), j.emplaceBack(S + 2, S + 3), j.emplaceBack(S + 3, S), v.primitiveLength += 4
          }
          addDebugCollisionBoxes(t, r, a, c) {
            for (let p = t; p < r; p++) {
              const f = this.collisionBoxArray.get(p);
              this.addCollisionDebugVertices(f.x1, f.y1, f.x2, f.y2, c ? this.textCollisionBox : this.iconCollisionBox, f.anchorPoint, a)
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new jp(Kr, n_.members, Ii), this.iconCollisionBox = new jp(Kr, n_.members, Ii);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const r = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, !1), this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, !1)
            }
          }
          _deserializeCollisionBoxesForSymbol(t, r, a, c, p, f, _, v, S) {
            const I = {};
            for (let E = r; E < a; E++) {
              const R = t.get(E);
              I.textBox = {
                x1: R.x1,
                y1: R.y1,
                x2: R.x2,
                y2: R.y2,
                anchorPointX: R.anchorPointX,
                anchorPointY: R.anchorPointY
              }, I.textFeatureIndex = R.featureIndex;
              break
            }
            for (let E = c; E < p; E++) {
              const R = t.get(E);
              I.verticalTextBox = {
                x1: R.x1,
                y1: R.y1,
                x2: R.x2,
                y2: R.y2,
                anchorPointX: R.anchorPointX,
                anchorPointY: R.anchorPointY
              }, I.verticalTextFeatureIndex = R.featureIndex;
              break
            }
            for (let E = f; E < _; E++) {
              const R = t.get(E);
              I.iconBox = {
                x1: R.x1,
                y1: R.y1,
                x2: R.x2,
                y2: R.y2,
                anchorPointX: R.anchorPointX,
                anchorPointY: R.anchorPointY
              }, I.iconFeatureIndex = R.featureIndex;
              break
            }
            for (let E = v; E < S; E++) {
              const R = t.get(E);
              I.verticalIconBox = {
                x1: R.x1,
                y1: R.y1,
                x2: R.x2,
                y2: R.y2,
                anchorPointX: R.anchorPointX,
                anchorPointY: R.anchorPointY
              }, I.verticalIconFeatureIndex = R.featureIndex;
              break
            }
            return I
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let r = 0; r < this.symbolInstances.length; r++) {
              const a = this.symbolInstances.get(r);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, a.textBoxStartIndex, a.textBoxEndIndex, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a.iconBoxStartIndex, a.iconBoxEndIndex, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex))
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0
          }
          hasIconData() {
            return this.icon.segments.get().length > 0
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
          }
          addIndicesForPlacedSymbol(t, r) {
            const a = t.placedSymbolArray.get(r),
              c = a.vertexStartIndex + 4 * a.numGlyphs;
            for (let p = a.vertexStartIndex; p < c; p += 4) t.indexArray.emplaceBack(p, p + 2, p + 1), t.indexArray.emplaceBack(p + 1, p + 2, p + 3)
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const r = Math.sin(t),
              a = Math.cos(t),
              c = [],
              p = [],
              f = [];
            for (let _ = 0; _ < this.symbolInstances.length; ++_) {
              f.push(_);
              const v = this.symbolInstances.get(_);
              c.push(0 | Math.round(r * v.anchorX + a * v.anchorY)), p.push(v.featureIndex)
            }
            return f.sort(((_, v) => c[_] - c[v] || p[v] - p[_])), f
          }
          addToSortKeyRanges(t, r) {
            const a = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            a && a.sortKey === r ? a.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
              sortKey: r,
              symbolInstanceStart: t,
              symbolInstanceEnd: t + 1
            })
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const r of this.symbolInstanceIndexes) {
                const a = this.symbolInstances.get(r);
                this.featureSortOrder.push(a.featureIndex), [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach(((c, p, f) => {
                  c >= 0 && f.indexOf(c) === p && this.addIndicesForPlacedSymbol(this.text, c)
                })), a.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, a.verticalPlacedTextSymbolIndex), a.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.placedIconSymbolIndex), a.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.verticalPlacedIconSymbolIndex)
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
            }
          }
        }
        let v_, y_;
        Wt("SymbolBucket", Nl, {
          omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }), Nl.MAX_GLYPHS = 65535, Nl.addDynamicAttributes = Op;
        var qp = {
          get paint() {
            return y_ = y_ || new jn({
              "icon-opacity": new Lr(ye.paint_symbol["icon-opacity"]),
              "icon-color": new Lr(ye.paint_symbol["icon-color"]),
              "icon-halo-color": new Lr(ye.paint_symbol["icon-halo-color"]),
              "icon-halo-width": new Lr(ye.paint_symbol["icon-halo-width"]),
              "icon-halo-blur": new Lr(ye.paint_symbol["icon-halo-blur"]),
              "icon-translate": new hr(ye.paint_symbol["icon-translate"]),
              "icon-translate-anchor": new hr(ye.paint_symbol["icon-translate-anchor"]),
              "text-opacity": new Lr(ye.paint_symbol["text-opacity"]),
              "text-color": new Lr(ye.paint_symbol["text-color"], {
                runtimeType: zr,
                getOverride: i => i.textColor,
                hasOverride: i => !!i.textColor
              }),
              "text-halo-color": new Lr(ye.paint_symbol["text-halo-color"]),
              "text-halo-width": new Lr(ye.paint_symbol["text-halo-width"]),
              "text-halo-blur": new Lr(ye.paint_symbol["text-halo-blur"]),
              "text-translate": new hr(ye.paint_symbol["text-translate"]),
              "text-translate-anchor": new hr(ye.paint_symbol["text-translate-anchor"])
            })
          },
          get layout() {
            return v_ = v_ || new jn({
              "symbol-placement": new hr(ye.layout_symbol["symbol-placement"]),
              "symbol-spacing": new hr(ye.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new hr(ye.layout_symbol["symbol-avoid-edges"]),
              "symbol-sort-key": new Lr(ye.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new hr(ye.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new hr(ye.layout_symbol["icon-allow-overlap"]),
              "icon-overlap": new hr(ye.layout_symbol["icon-overlap"]),
              "icon-ignore-placement": new hr(ye.layout_symbol["icon-ignore-placement"]),
              "icon-optional": new hr(ye.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new hr(ye.layout_symbol["icon-rotation-alignment"]),
              "icon-size": new Lr(ye.layout_symbol["icon-size"]),
              "icon-text-fit": new hr(ye.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new hr(ye.layout_symbol["icon-text-fit-padding"]),
              "icon-image": new Lr(ye.layout_symbol["icon-image"]),
              "icon-rotate": new Lr(ye.layout_symbol["icon-rotate"]),
              "icon-padding": new Lr(ye.layout_symbol["icon-padding"]),
              "icon-keep-upright": new hr(ye.layout_symbol["icon-keep-upright"]),
              "icon-offset": new Lr(ye.layout_symbol["icon-offset"]),
              "icon-anchor": new Lr(ye.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new hr(ye.layout_symbol["icon-pitch-alignment"]),
              "text-pitch-alignment": new hr(ye.layout_symbol["text-pitch-alignment"]),
              "text-rotation-alignment": new hr(ye.layout_symbol["text-rotation-alignment"]),
              "text-field": new Lr(ye.layout_symbol["text-field"]),
              "text-font": new Lr(ye.layout_symbol["text-font"]),
              "text-size": new Lr(ye.layout_symbol["text-size"]),
              "text-max-width": new Lr(ye.layout_symbol["text-max-width"]),
              "text-line-height": new hr(ye.layout_symbol["text-line-height"]),
              "text-letter-spacing": new Lr(ye.layout_symbol["text-letter-spacing"]),
              "text-justify": new Lr(ye.layout_symbol["text-justify"]),
              "text-radial-offset": new Lr(ye.layout_symbol["text-radial-offset"]),
              "text-variable-anchor": new hr(ye.layout_symbol["text-variable-anchor"]),
              "text-variable-anchor-offset": new Lr(ye.layout_symbol["text-variable-anchor-offset"]),
              "text-anchor": new Lr(ye.layout_symbol["text-anchor"]),
              "text-max-angle": new hr(ye.layout_symbol["text-max-angle"]),
              "text-writing-mode": new hr(ye.layout_symbol["text-writing-mode"]),
              "text-rotate": new Lr(ye.layout_symbol["text-rotate"]),
              "text-padding": new hr(ye.layout_symbol["text-padding"]),
              "text-keep-upright": new hr(ye.layout_symbol["text-keep-upright"]),
              "text-transform": new Lr(ye.layout_symbol["text-transform"]),
              "text-offset": new Lr(ye.layout_symbol["text-offset"]),
              "text-allow-overlap": new hr(ye.layout_symbol["text-allow-overlap"]),
              "text-overlap": new hr(ye.layout_symbol["text-overlap"]),
              "text-ignore-placement": new hr(ye.layout_symbol["text-ignore-placement"]),
              "text-optional": new hr(ye.layout_symbol["text-optional"])
            })
          }
        };
        class x_ {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : Pt, this.defaultValue = t
          }
          evaluate(t) {
            if (t.formattedSection) {
              const r = this.defaultValue.property.overrides;
              if (r && r.hasOverride(t.formattedSection)) return r.getOverride(t.formattedSection)
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
          }
          outputDefined() {
            return !1
          }
          serialize() {
            return null
          }
        }
        Wt("FormatSectionOverride", x_, {
          omit: ["defaultValue"]
        });
        class dd extends ha {
          constructor(t) {
            super(t, qp)
          }
          recalculate(t, r) {
            if (super.recalculate(t, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const a = this.layout.get("text-writing-mode");
              if (a) {
                const c = [];
                for (const p of a) c.indexOf(p) < 0 && c.push(p);
                this.layout._values["text-writing-mode"] = c
              } else this.layout._values["text-writing-mode"] = ["horizontal"]
            }
            this._setPaintOverrides()
          }
          getValueAndResolveTokens(t, r, a, c) {
            const p = this.layout.get(t).evaluate(r, {}, a, c),
              f = this._unevaluatedLayout._values[t];
            return f.isDataDriven() || fl(f.value) || !p ? p : (function(_, v) {
              return v.replace(/{([^{}]+)}/g, ((S, I) => _ && I in _ ? String(_[I]) : ""))
            })(r.properties, p)
          }
          createBucket(t) {
            return new Nl(t)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex")
          }
          _setPaintOverrides() {
            for (const t of qp.paint.overridableProperties) {
              if (!dd.hasPaintOverride(this.layout, t)) continue;
              const r = this.paint.get(t),
                a = new x_(r),
                c = new zc(a, r.property.specification);
              let p = null;
              p = r.value.kind === "constant" || r.value.kind === "source" ? new Po("source", c) : new Lc("composite", c, r.value.zoomStops), this.paint._values[t] = new Oa(r.property, p, r.parameters)
            }
          }
          _handleOverridablePaintPropertyUpdate(t, r, a) {
            return !(!this.layout || r.isDataDriven() || a.isDataDriven()) && dd.hasPaintOverride(this.layout, t)
          }
          static hasPaintOverride(t, r) {
            const a = t.get("text-field"),
              c = qp.paint.properties[r];
            let p = !1;
            const f = _ => {
              for (const v of _)
                if (c.overrides && c.overrides.hasOverride(v)) return void(p = !0)
            };
            if (a.value.kind === "constant" && a.value.value instanceof Ji) f(a.value.value.sections);
            else if (a.value.kind === "source") {
              const _ = S => {
                  p || (S instanceof ga && wr(S.value) === Pi ? f(S.value.sections) : S instanceof fs ? f(S.sections) : S.eachChild(_))
                },
                v = a.value;
              v._styleExpression && _(v._styleExpression.expression)
            }
            return p
          }
        }
        let b_;
        var Q0 = {
          get paint() {
            return b_ = b_ || new jn({
              "background-color": new hr(ye.paint_background["background-color"]),
              "background-pattern": new is(ye.paint_background["background-pattern"]),
              "background-opacity": new hr(ye.paint_background["background-opacity"])
            })
          }
        };
        class ey extends ha {
          constructor(t) {
            super(t, Q0)
          }
        }
        let w_;
        var ty = {
          get paint() {
            return w_ = w_ || new jn({
              "raster-opacity": new hr(ye.paint_raster["raster-opacity"]),
              "raster-hue-rotate": new hr(ye.paint_raster["raster-hue-rotate"]),
              "raster-brightness-min": new hr(ye.paint_raster["raster-brightness-min"]),
              "raster-brightness-max": new hr(ye.paint_raster["raster-brightness-max"]),
              "raster-saturation": new hr(ye.paint_raster["raster-saturation"]),
              "raster-contrast": new hr(ye.paint_raster["raster-contrast"]),
              "raster-resampling": new hr(ye.paint_raster["raster-resampling"]),
              "raster-fade-duration": new hr(ye.paint_raster["raster-fade-duration"])
            })
          }
        };
        class ry extends ha {
          constructor(t) {
            super(t, ty)
          }
        }
        class iy extends ha {
          constructor(t) {
            super(t, {}), this.onAdd = r => {
              this.implementation.onAdd && this.implementation.onAdd(r, r.painter.context.gl)
            }, this.onRemove = r => {
              this.implementation.onRemove && this.implementation.onRemove(r, r.painter.context.gl)
            }, this.implementation = t
          }
          is3D() {
            return this.implementation.renderingMode === "3d"
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0
          }
          recalculate() {}
          updateTransitions() {}
          hasTransition() {
            return !1
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized")
          }
        }
        class ny {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle()
            })
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle()
            }), 0))
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {}
          }
        }
        const ay = {
            once: !0
          },
          Vp = 63710088e-1;
        class ro {
          constructor(t, r) {
            if (isNaN(t) || isNaN(r)) throw new Error(`Invalid LngLat object: (${t}, ${r})`);
            if (this.lng = +t, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
          }
          wrap() {
            return new ro(st(this.lng, -180, 180), this.lat)
          }
          toArray() {
            return [this.lng, this.lat]
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`
          }
          distanceTo(t) {
            const r = Math.PI / 180,
              a = this.lat * r,
              c = t.lat * r,
              p = Math.sin(a) * Math.sin(c) + Math.cos(a) * Math.cos(c) * Math.cos((t.lng - this.lng) * r);
            return Vp * Math.acos(Math.min(p, 1))
          }
          static convert(t) {
            if (t instanceof ro) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new ro(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new ro(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
          }
        }
        const T_ = 2 * Math.PI * Vp;

        function C_(i) {
          return T_ * Math.cos(i * Math.PI / 180)
        }

        function S_(i) {
          return (180 + i) / 360
        }

        function P_(i) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360
        }

        function I_(i, t) {
          return i / C_(t)
        }

        function Up(i) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90
        }

        function M_(i, t) {
          return i * C_(Up(t))
        }
        class pu {
          constructor(t, r, a = 0) {
            this.x = +t, this.y = +r, this.z = +a
          }
          static fromLngLat(t, r = 0) {
            const a = ro.convert(t);
            return new pu(S_(a.lng), P_(a.lat), I_(r, a.lat))
          }
          toLngLat() {
            return new ro(360 * this.x - 180, Up(this.y))
          }
          toAltitude() {
            return M_(this.z, this.y)
          }
          meterInMercatorCoordinateUnits() {
            return 1 / T_ * (t = Up(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t
          }
        }

        function A_(i, t, r) {
          var a = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
          return [i * a - 2 * Math.PI * 6378137 / 2, t * a - 2 * Math.PI * 6378137 / 2]
        }
        class Zp {
          constructor(t, r, a) {
            if (!(function(c, p, f) {
                return !(c < 0 || c > 25 || f < 0 || f >= Math.pow(2, c) || p < 0 || p >= Math.pow(2, c))
              })(t, r, a)) throw new Error(`x=${r}, y=${a}, z=${t} outside of bounds. 0<=x<${Math.pow(2,t)}, 0<=y<${Math.pow(2,t)} 0<=z<=25 `);
            this.z = t, this.x = r, this.y = a, this.key = jl(0, t, t, r, a)
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y
          }
          url(t, r, a) {
            const c = (f = this.y, _ = this.z, v = A_(256 * (p = this.x), 256 * (f = Math.pow(2, _) - f - 1), _), S = A_(256 * (p + 1), 256 * (f + 1), _), v[0] + "," + v[1] + "," + S[0] + "," + S[1]);
            var p, f, _, v, S;
            const I = (function(E, R, O) {
              let j, Z = "";
              for (let Y = E; Y > 0; Y--) j = 1 << Y - 1, Z += (R & j ? 1 : 0) + (O & j ? 2 : 0);
              return Z
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(a === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, I).replace(/{bbox-epsg-3857}/g, c)
          }
          isChildOf(t) {
            const r = this.z - t.z;
            return r > 0 && t.x === this.x >> r && t.y === this.y >> r
          }
          getTilePoint(t) {
            const r = Math.pow(2, this.z);
            return new G((t.x * r - this.x) * ie, (t.y * r - this.y) * ie)
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`
          }
        }
        class k_ {
          constructor(t, r) {
            this.wrap = t, this.canonical = r, this.key = jl(t, r.z, r.z, r.x, r.y)
          }
        }
        class Ma {
          constructor(t, r, a, c, p) {
            if (this.terrainRttPosMatrix32f = null, t < a) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${a}`);
            this.overscaledZ = t, this.wrap = r, this.canonical = new Zp(a, +c, +p), this.key = jl(r, t, a, c, p)
          }
          clone() {
            return new Ma(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const r = this.canonical.z - t;
            return t > this.canonical.z ? new Ma(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Ma(t, this.wrap, t, this.canonical.x >> r, this.canonical.y >> r)
          }
          calculateScaledKey(t, r) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const a = this.canonical.z - t;
            return t > this.canonical.z ? jl(this.wrap * +r, t, this.canonical.z, this.canonical.x, this.canonical.y) : jl(this.wrap * +r, t, t, this.canonical.x >> a, this.canonical.y >> a)
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap) return !1;
            const r = this.canonical.z - t.canonical.z;
            return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> r && t.canonical.y === this.canonical.y >> r
          }
          children(t) {
            if (this.overscaledZ >= t) return [new Ma(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const r = this.canonical.z + 1,
              a = 2 * this.canonical.x,
              c = 2 * this.canonical.y;
            return [new Ma(r, this.wrap, r, a, c), new Ma(r, this.wrap, r, a + 1, c), new Ma(r, this.wrap, r, a, c + 1), new Ma(r, this.wrap, r, a + 1, c + 1)]
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
          }
          wrapped() {
            return new Ma(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          unwrapTo(t) {
            return new Ma(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z)
          }
          toUnwrapped() {
            return new k_(this.wrap, this.canonical)
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new pu(t.x - this.wrap, t.y))
          }
        }

        function jl(i, t, r, a, c) {
          (i *= 2) < 0 && (i = -1 * i - 1);
          const p = 1 << r;
          return (p * p * i + p * c + a).toString(36) + r.toString(36) + t.toString(36)
        }

        function fu(i, t) {
          return t ? i.properties[t] : i.id
        }
        Wt("CanonicalTileID", Zp), Wt("OverscaledTileID", Ma, {
          omit: ["terrainRttPosMatrix32f"]
        });
        class No {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this
          }
          shrinkBy(t) {
            return this.expandBy(-t)
          }
          map(t) {
            const r = new No;
            return r.extend(t(new G(this.minX, this.minY))), r.extend(t(new G(this.maxX, this.minY))), r.extend(t(new G(this.minX, this.maxY))), r.extend(t(new G(this.maxX, this.maxY))), r
          }
          static fromPoints(t) {
            const r = new No;
            for (const a of t) r.extend(a);
            return r
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY
          }
          empty() {
            return this.minX > this.maxX
          }
          width() {
            return this.maxX - this.minX
          }
          height() {
            return this.maxY - this.minY
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY
          }
        }
        class E_ {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let r = 0; r < t.length; r++) {
              const a = t[r];
              this._stringToNumber[a] = r, this._numberToString[r] = a
            }
          }
          encode(t) {
            return this._stringToNumber[t]
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t]
          }
        }
        class z_ {
          constructor(t, r, a, c, p) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = r, t._x = a, t._y = c, this.properties = t.properties, this.id = p
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry
          }
          set geometry(t) {
            this._geometry = t
          }
          toJSON() {
            const t = {
              geometry: this.geometry
            };
            for (const r in this) r !== "_geometry" && r !== "_vectorTileFeature" && (t[r] = this[r]);
            return t
          }
        }
        class L_ {
          constructor(t, r) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Lo(ie, 16, 0), this.grid3D = new Lo(ie, 16, 0), this.featureIndexArray = new we, this.promoteId = r
          }
          insert(t, r, a, c, p, f) {
            const _ = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(a, c, p);
            const v = f ? this.grid3D : this.grid;
            for (let S = 0; S < r.length; S++) {
              const I = r[S],
                E = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let R = 0; R < I.length; R++) {
                const O = I[R];
                E[0] = Math.min(E[0], O.x), E[1] = Math.min(E[1], O.y), E[2] = Math.max(E[2], O.x), E[3] = Math.max(E[3], O.y)
              }
              E[0] < ie && E[1] < ie && E[2] >= 0 && E[3] >= 0 && v.insert(_, E[0], E[1], E[2], E[3])
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new Xm(new Lp(this.rawTileData)).layers, this.sourceLayerCoder = new E_(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers
          }
          query(t, r, a, c) {
            this.loadVTLayers();
            const p = t.params,
              f = ie / t.tileSize / t.scale,
              _ = xs(p.filter),
              v = t.queryGeometry,
              S = t.queryPadding * f,
              I = No.fromPoints(v),
              E = this.grid.query(I.minX - S, I.minY - S, I.maxX + S, I.maxY + S),
              R = No.fromPoints(t.cameraQueryGeometry).expandBy(S),
              O = this.grid3D.query(R.minX, R.minY, R.maxX, R.maxY, ((Y, ne, ke, pe) => (function(be, Ve, et, xt, Zt) {
                for (const Vt of be)
                  if (Ve <= Vt.x && et <= Vt.y && xt >= Vt.x && Zt >= Vt.y) return !0;
                const Rt = [new G(Ve, et), new G(Ve, Zt), new G(xt, Zt), new G(xt, et)];
                if (be.length > 2) {
                  for (const Vt of Rt)
                    if (zl(be, Vt)) return !0
                }
                for (let Vt = 0; Vt < be.length - 1; Vt++)
                  if (Fv(be[Vt], be[Vt + 1], Rt)) return !0;
                return !1
              })(t.cameraQueryGeometry, Y - S, ne - S, ke + S, pe + S)));
            for (const Y of O) E.push(Y);
            E.sort(sy);
            const j = {};
            let Z;
            for (let Y = 0; Y < E.length; Y++) {
              const ne = E[Y];
              if (ne === Z) continue;
              Z = ne;
              const ke = this.featureIndexArray.get(ne);
              let pe = null;
              this.loadMatchingFeature(j, ke.bucketIndex, ke.sourceLayerIndex, ke.featureIndex, _, p.layers, p.availableImages, r, a, c, ((be, Ve, et) => (pe || (pe = ls(be)), Ve.queryIntersectsFeature({
                queryGeometry: v,
                feature: be,
                featureState: et,
                geometry: pe,
                zoom: this.z,
                transform: t.transform,
                pixelsToTileUnits: f,
                pixelPosMatrix: t.pixelPosMatrix,
                unwrappedTileID: this.tileID.toUnwrapped(),
                getElevation: t.getElevation
              }))))
            }
            return j
          }
          loadMatchingFeature(t, r, a, c, p, f, _, v, S, I, E) {
            const R = this.bucketLayerIDs[r];
            if (f && !R.some((Y => f.has(Y)))) return;
            const O = this.sourceLayerCoder.decode(a),
              j = this.vtLayers[O].feature(c);
            if (p.needGeometry) {
              const Y = Ha(j, !0);
              if (!p.filter(new ji(this.tileID.overscaledZ), Y, this.tileID.canonical)) return
            } else if (!p.filter(new ji(this.tileID.overscaledZ), j)) return;
            const Z = this.getId(j, O);
            for (let Y = 0; Y < R.length; Y++) {
              const ne = R[Y];
              if (f && !f.has(ne)) continue;
              const ke = v[ne];
              if (!ke) continue;
              let pe = {};
              Z && I && (pe = I.getState(ke.sourceLayer || "_geojsonTileLayer", Z));
              const be = Tt({}, S[ne]);
              be.paint = D_(be.paint, ke.paint, j, pe, _), be.layout = D_(be.layout, ke.layout, j, pe, _);
              const Ve = !E || E(j, ke, pe);
              if (!Ve) continue;
              const et = new z_(j, this.z, this.x, this.y, Z);
              et.layer = be;
              let xt = t[ne];
              xt === void 0 && (xt = t[ne] = []), xt.push({
                featureIndex: c,
                feature: et,
                intersectionZ: Ve
              })
            }
          }
          lookupSymbolFeatures(t, r, a, c, p, f, _, v) {
            const S = {};
            this.loadVTLayers();
            const I = xs(p);
            for (const E of t) this.loadMatchingFeature(S, a, c, E, I, f, _, v, r);
            return S
          }
          hasLayer(t) {
            for (const r of this.bucketLayerIDs)
              for (const a of r)
                if (t === a) return !0;
            return !1
          }
          getId(t, r) {
            var a;
            let c = t.id;
            return this.promoteId && (c = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]], typeof c == "boolean" && (c = Number(c)), c === void 0 && (!((a = t.properties) === null || a === void 0) && a.cluster) && this.promoteId && (c = Number(t.properties.cluster_id))), c
          }
        }

        function D_(i, t, r, a, c) {
          return yt(i, ((p, f) => {
            const _ = t instanceof Cl ? t.get(f) : null;
            return _ && _.evaluate ? _.evaluate(r, a, c) : _
          }))
        }

        function sy(i, t) {
          return t - i
        }

        function R_(i, t, r, a, c) {
          const p = [];
          for (let f = 0; f < i.length; f++) {
            const _ = i[f];
            let v;
            for (let S = 0; S < _.length - 1; S++) {
              let I = _[S],
                E = _[S + 1];
              I.x < t && E.x < t || (I.x < t ? I = new G(t, I.y + (t - I.x) / (E.x - I.x) * (E.y - I.y))._round() : E.x < t && (E = new G(t, I.y + (t - I.x) / (E.x - I.x) * (E.y - I.y))._round()), I.y < r && E.y < r || (I.y < r ? I = new G(I.x + (r - I.y) / (E.y - I.y) * (E.x - I.x), r)._round() : E.y < r && (E = new G(I.x + (r - I.y) / (E.y - I.y) * (E.x - I.x), r)._round()), I.x >= a && E.x >= a || (I.x >= a ? I = new G(a, I.y + (a - I.x) / (E.x - I.x) * (E.y - I.y))._round() : E.x >= a && (E = new G(a, I.y + (a - I.x) / (E.x - I.x) * (E.y - I.y))._round()), I.y >= c && E.y >= c || (I.y >= c ? I = new G(I.x + (c - I.y) / (E.y - I.y) * (E.x - I.x), c)._round() : E.y >= c && (E = new G(I.x + (c - I.y) / (E.y - I.y) * (E.x - I.x), c)._round()), v && I.equals(v[v.length - 1]) || (v = [I], p.push(v)), v.push(E)))))
            }
          }
          return p
        }
        Wt("FeatureIndex", L_, {
          omit: ["rawTileData", "sourceLayerCoder"]
        });
        class io extends G {
          constructor(t, r, a, c) {
            super(t, r), this.angle = a, c !== void 0 && (this.segment = c)
          }
          clone() {
            return new io(this.x, this.y, this.angle, this.segment)
          }
        }

        function B_(i, t, r, a, c) {
          if (t.segment === void 0 || r === 0) return !0;
          let p = t,
            f = t.segment + 1,
            _ = 0;
          for (; _ > -r / 2;) {
            if (f--, f < 0) return !1;
            _ -= i[f].dist(p), p = i[f]
          }
          _ += i[f].dist(i[f + 1]), f++;
          const v = [];
          let S = 0;
          for (; _ < r / 2;) {
            const I = i[f],
              E = i[f + 1];
            if (!E) return !1;
            let R = i[f - 1].angleTo(I) - I.angleTo(E);
            for (R = Math.abs((R + 3 * Math.PI) % (2 * Math.PI) - Math.PI), v.push({
                distance: _,
                angleDelta: R
              }), S += R; _ - v[0].distance > a;) S -= v.shift().angleDelta;
            if (S > c) return !1;
            f++, _ += I.dist(E)
          }
          return !0
        }

        function F_(i) {
          let t = 0;
          for (let r = 0; r < i.length - 1; r++) t += i[r].dist(i[r + 1]);
          return t
        }

        function O_(i, t, r) {
          return i ? .6 * t * r : 0
        }

        function N_(i, t) {
          return Math.max(i ? i.right - i.left : 0, t ? t.right - t.left : 0)
        }

        function oy(i, t, r, a, c, p) {
          const f = O_(r, c, p),
            _ = N_(r, a) * p;
          let v = 0;
          const S = F_(i) / 2;
          for (let I = 0; I < i.length - 1; I++) {
            const E = i[I],
              R = i[I + 1],
              O = E.dist(R);
            if (v + O > S) {
              const j = (S - v) / O,
                Z = Ba.number(E.x, R.x, j),
                Y = Ba.number(E.y, R.y, j),
                ne = new io(Z, Y, R.angleTo(E), I);
              return ne._round(), !f || B_(i, ne, _, f, t) ? ne : void 0
            }
            v += O
          }
        }

        function ly(i, t, r, a, c, p, f, _, v) {
          const S = O_(a, p, f),
            I = N_(a, c),
            E = I * f,
            R = i[0].x === 0 || i[0].x === v || i[0].y === 0 || i[0].y === v;
          return t - E < t / 4 && (t = E + t / 4), j_(i, R ? t / 2 * _ % t : (I / 2 + 2 * p) * f * _ % t, t, S, r, E, R, !1, v)
        }

        function j_(i, t, r, a, c, p, f, _, v) {
          const S = p / 2,
            I = F_(i);
          let E = 0,
            R = t - r,
            O = [];
          for (let j = 0; j < i.length - 1; j++) {
            const Z = i[j],
              Y = i[j + 1],
              ne = Z.dist(Y),
              ke = Y.angleTo(Z);
            for (; R + r < E + ne;) {
              R += r;
              const pe = (R - E) / ne,
                be = Ba.number(Z.x, Y.x, pe),
                Ve = Ba.number(Z.y, Y.y, pe);
              if (be >= 0 && be < v && Ve >= 0 && Ve < v && R - S >= 0 && R + S <= I) {
                const et = new io(be, Ve, ke, j);
                et._round(), a && !B_(i, et, p, a, c) || O.push(et)
              }
            }
            E += ne
          }
          return _ || O.length || f || (O = j_(i, E / 2, r, a, c, p, f, !0, v)), O
        }

        function q_(i, t, r, a) {
          const c = [],
            p = i.image,
            f = p.pixelRatio,
            _ = p.paddedRect.w - 2,
            v = p.paddedRect.h - 2;
          let S = {
            x1: i.left,
            y1: i.top,
            x2: i.right,
            y2: i.bottom
          };
          const I = p.stretchX || [
              [0, _]
            ],
            E = p.stretchY || [
              [0, v]
            ],
            R = (dt, Br) => dt + Br[1] - Br[0],
            O = I.reduce(R, 0),
            j = E.reduce(R, 0),
            Z = _ - O,
            Y = v - j;
          let ne = 0,
            ke = O,
            pe = 0,
            be = j,
            Ve = 0,
            et = Z,
            xt = 0,
            Zt = Y;
          if (p.content && a) {
            const dt = p.content,
              Br = dt[2] - dt[0],
              Zr = dt[3] - dt[1];
            (p.textFitWidth || p.textFitHeight) && (S = m_(i)), ne = pd(I, 0, dt[0]), pe = pd(E, 0, dt[1]), ke = pd(I, dt[0], dt[2]), be = pd(E, dt[1], dt[3]), Ve = dt[0] - ne, xt = dt[1] - pe, et = Br - ke, Zt = Zr - be
          }
          const Rt = S.x1,
            Vt = S.y1,
            fr = S.x2 - Rt,
            qt = S.y2 - Vt,
            Ut = (dt, Br, Zr, yr) => {
              const or = fd(dt.stretch - ne, ke, fr, Rt),
                oi = md(dt.fixed - Ve, et, dt.stretch, O),
                Gi = fd(Br.stretch - pe, be, qt, Vt),
                fn = md(Br.fixed - xt, Zt, Br.stretch, j),
                Fn = fd(Zr.stretch - ne, ke, fr, Rt),
                Aa = md(Zr.fixed - Ve, et, Zr.stretch, O),
                aa = fd(yr.stretch - pe, be, qt, Vt),
                An = md(yr.fixed - xt, Zt, yr.stretch, j),
                Vi = new G(or, Gi),
                wn = new G(Fn, Gi),
                kn = new G(Fn, aa),
                En = new G(or, aa),
                Jn = new G(oi / f, fn / f),
                ka = new G(Aa / f, An / f),
                Tn = t * Math.PI / 180;
              if (Tn) {
                const Cn = Math.sin(Tn),
                  Sn = Math.cos(Tn),
                  on = [Sn, -Cn, Cn, Sn];
                Vi._matMult(on), wn._matMult(on), En._matMult(on), kn._matMult(on)
              }
              const sa = dt.stretch + dt.fixed,
                mn = Br.stretch + Br.fixed;
              return {
                tl: Vi,
                tr: wn,
                bl: En,
                br: kn,
                tex: {
                  x: p.paddedRect.x + 1 + sa,
                  y: p.paddedRect.y + 1 + mn,
                  w: Zr.stretch + Zr.fixed - sa,
                  h: yr.stretch + yr.fixed - mn
                },
                writingMode: void 0,
                glyphOffset: [0, 0],
                sectionIndex: 0,
                pixelOffsetTL: Jn,
                pixelOffsetBR: ka,
                minFontScaleX: et / f / fr,
                minFontScaleY: Zt / f / qt,
                isSDF: r
              }
            };
          if (a && (p.stretchX || p.stretchY)) {
            const dt = V_(I, Z, O),
              Br = V_(E, Y, j);
            for (let Zr = 0; Zr < dt.length - 1; Zr++) {
              const yr = dt[Zr],
                or = dt[Zr + 1];
              for (let oi = 0; oi < Br.length - 1; oi++) c.push(Ut(yr, Br[oi], or, Br[oi + 1]))
            }
          } else c.push(Ut({
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: _ + 1
          }, {
            fixed: 0,
            stretch: v + 1
          }));
          return c
        }

        function pd(i, t, r) {
          let a = 0;
          for (const c of i) a += Math.max(t, Math.min(r, c[1])) - Math.max(t, Math.min(r, c[0]));
          return a
        }

        function V_(i, t, r) {
          const a = [{
            fixed: -1,
            stretch: 0
          }];
          for (const [c, p] of i) {
            const f = a[a.length - 1];
            a.push({
              fixed: c - f.stretch,
              stretch: f.stretch
            }), a.push({
              fixed: c - f.stretch,
              stretch: f.stretch + (p - c)
            })
          }
          return a.push({
            fixed: t + 1,
            stretch: r
          }), a
        }

        function fd(i, t, r, a) {
          return i / t * r + a
        }

        function md(i, t, r, a) {
          return i - t * r / a
        }
        Wt("Anchor", io);
        class _d {
          constructor(t, r, a, c, p, f, _, v, S, I) {
            var E;
            if (this.boxStartIndex = t.length, S) {
              let R = f.top,
                O = f.bottom;
              const j = f.collisionPadding;
              j && (R -= j[1], O += j[3]);
              let Z = O - R;
              Z > 0 && (Z = Math.max(10, Z), this.circleDiameter = Z)
            } else {
              const R = !((E = f.image) === null || E === void 0) && E.content && (f.image.textFitWidth || f.image.textFitHeight) ? m_(f) : {
                x1: f.left,
                y1: f.top,
                x2: f.right,
                y2: f.bottom
              };
              R.y1 = R.y1 * _ - v[0], R.y2 = R.y2 * _ + v[2], R.x1 = R.x1 * _ - v[3], R.x2 = R.x2 * _ + v[1];
              const O = f.collisionPadding;
              if (O && (R.x1 -= O[0] * _, R.y1 -= O[1] * _, R.x2 += O[2] * _, R.y2 += O[3] * _), I) {
                const j = new G(R.x1, R.y1),
                  Z = new G(R.x2, R.y1),
                  Y = new G(R.x1, R.y2),
                  ne = new G(R.x2, R.y2),
                  ke = I * Math.PI / 180;
                j._rotate(ke), Z._rotate(ke), Y._rotate(ke), ne._rotate(ke), R.x1 = Math.min(j.x, Z.x, Y.x, ne.x), R.x2 = Math.max(j.x, Z.x, Y.x, ne.x), R.y1 = Math.min(j.y, Z.y, Y.y, ne.y), R.y2 = Math.max(j.y, Z.y, Y.y, ne.y)
              }
              t.emplaceBack(r.x, r.y, R.x1, R.y1, R.x2, R.y2, a, c, p)
            }
            this.boxEndIndex = t.length
          }
        }
        class cy {
          constructor(t = [], r = (a, c) => a < c ? -1 : a > c ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = r, this.length > 0)
              for (let a = (this.length >> 1) - 1; a >= 0; a--) this._down(a)
          }
          push(t) {
            this.data.push(t), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0],
              r = this.data.pop();
            return --this.length > 0 && (this.data[0] = r, this._down(0)), t
          }
          peek() {
            return this.data[0]
          }
          _up(t) {
            const {
              data: r,
              compare: a
            } = this, c = r[t];
            for (; t > 0;) {
              const p = t - 1 >> 1,
                f = r[p];
              if (a(c, f) >= 0) break;
              r[t] = f, t = p
            }
            r[t] = c
          }
          _down(t) {
            const {
              data: r,
              compare: a
            } = this, c = this.length >> 1, p = r[t];
            for (; t < c;) {
              let f = 1 + (t << 1);
              const _ = f + 1;
              if (_ < this.length && a(r[_], r[f]) < 0 && (f = _), a(r[f], p) >= 0) break;
              r[t] = r[f], t = f
            }
            r[t] = p
          }
        }

        function uy(i, t = 1, r = !1) {
          const a = No.fromPoints(i[0]),
            c = Math.min(a.width(), a.height());
          let p = c / 2;
          const f = new cy([], hy),
            {
              minX: _,
              minY: v,
              maxX: S,
              maxY: I
            } = a;
          if (c === 0) return new G(_, v);
          for (let O = _; O < S; O += c)
            for (let j = v; j < I; j += c) f.push(new ql(O + p, j + p, p, i));
          let E = (function(O) {
              let j = 0,
                Z = 0,
                Y = 0;
              const ne = O[0];
              for (let ke = 0, pe = ne.length, be = pe - 1; ke < pe; be = ke++) {
                const Ve = ne[ke],
                  et = ne[be],
                  xt = Ve.x * et.y - et.x * Ve.y;
                Z += (Ve.x + et.x) * xt, Y += (Ve.y + et.y) * xt, j += 3 * xt
              }
              return new ql(Z / j, Y / j, 0, O)
            })(i),
            R = f.length;
          for (; f.length;) {
            const O = f.pop();
            (O.d > E.d || !E.d) && (E = O, r && console.log("found best %d after %d probes", Math.round(1e4 * O.d) / 1e4, R)), O.max - E.d <= t || (p = O.h / 2, f.push(new ql(O.p.x - p, O.p.y - p, p, i)), f.push(new ql(O.p.x + p, O.p.y - p, p, i)), f.push(new ql(O.p.x - p, O.p.y + p, p, i)), f.push(new ql(O.p.x + p, O.p.y + p, p, i)), R += 4)
          }
          return r && (console.log(`num probes: ${R}`), console.log(`best distance: ${E.d}`)), E.p
        }

        function hy(i, t) {
          return t.max - i.max
        }

        function ql(i, t, r, a) {
          this.p = new G(i, t), this.h = r, this.d = (function(c, p) {
            let f = !1,
              _ = 1 / 0;
            for (let v = 0; v < p.length; v++) {
              const S = p[v];
              for (let I = 0, E = S.length, R = E - 1; I < E; R = I++) {
                const O = S[I],
                  j = S[R];
                O.y > c.y != j.y > c.y && c.x < (j.x - O.x) * (c.y - O.y) / (j.y - O.y) + O.x && (f = !f), _ = Math.min(_, Pm(c, O, j))
              }
            }
            return (f ? 1 : -1) * Math.sqrt(_)
          })(this.p, a), this.max = this.d + this.h * Math.SQRT2
        }
        var Bn;
        T.aE = void 0, (Bn = T.aE || (T.aE = {}))[Bn.center = 1] = "center", Bn[Bn.left = 2] = "left", Bn[Bn.right = 3] = "right", Bn[Bn.top = 4] = "top", Bn[Bn.bottom = 5] = "bottom", Bn[Bn["top-left"] = 6] = "top-left", Bn[Bn["top-right"] = 7] = "top-right", Bn[Bn["bottom-left"] = 8] = "bottom-left", Bn[Bn["bottom-right"] = 9] = "bottom-right";
        const $p = Number.POSITIVE_INFINITY;

        function U_(i, t) {
          return t[1] !== $p ? (function(r, a, c) {
            let p = 0,
              f = 0;
            switch (a = Math.abs(a), c = Math.abs(c), r) {
              case "top-right":
              case "top-left":
              case "top":
                f = c - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                f = 7 - c
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
              case "right":
                p = -a;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                p = a
            }
            return [p, f]
          })(i, t[0], t[1]) : (function(r, a) {
            let c = 0,
              p = 0;
            a < 0 && (a = 0);
            const f = a / Math.SQRT2;
            switch (r) {
              case "top-right":
              case "top-left":
                p = f - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                p = 7 - f;
                break;
              case "bottom":
                p = 7 - a;
                break;
              case "top":
                p = a - 7
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
                c = -f;
                break;
              case "top-left":
              case "bottom-left":
                c = f;
                break;
              case "left":
                c = a;
                break;
              case "right":
                c = -a
            }
            return [c, p]
          })(i, t[0])
        }

        function Z_(i, t, r) {
          var a;
          const c = i.layout,
            p = (a = c.get("text-variable-anchor-offset")) === null || a === void 0 ? void 0 : a.evaluate(t, {}, r);
          if (p) {
            const _ = p.values,
              v = [];
            for (let S = 0; S < _.length; S += 2) {
              const I = v[S] = _[S],
                E = _[S + 1].map((R => R * bn));
              I.startsWith("top") ? E[1] -= 7 : I.startsWith("bottom") && (E[1] += 7), v[S + 1] = E
            }
            return new un(v)
          }
          const f = c.get("text-variable-anchor");
          if (f) {
            let _;
            _ = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [c.get("text-radial-offset").evaluate(t, {}, r) * bn, $p] : c.get("text-offset").evaluate(t, {}, r).map((S => S * bn));
            const v = [];
            for (const S of f) v.push(S, U_(S, _));
            return new un(v)
          }
          return null
        }

        function Gp(i) {
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left"
          }
          return "center"
        }

        function dy(i, t, r, a, c, p, f, _, v, S, I, E) {
          let R = p.textMaxSize.evaluate(t, {});
          R === void 0 && (R = f);
          const O = i.layers[0].layout,
            j = O.get("icon-offset").evaluate(t, {}, I),
            Z = G_(r.horizontal),
            Y = f / 24,
            ne = i.tilePixelRatio * Y,
            ke = i.tilePixelRatio * R / 24,
            pe = i.tilePixelRatio * _,
            be = i.tilePixelRatio * O.get("symbol-spacing"),
            Ve = O.get("text-padding") * i.tilePixelRatio,
            et = (function(Zr, yr, or, oi = 1) {
              const Gi = Zr.get("icon-padding").evaluate(yr, {}, or),
                fn = Gi && Gi.values;
              return [fn[0] * oi, fn[1] * oi, fn[2] * oi, fn[3] * oi]
            })(O, t, I, i.tilePixelRatio),
            xt = O.get("text-max-angle") / 180 * Math.PI,
            Zt = O.get("text-rotation-alignment") !== "viewport" && O.get("symbol-placement") !== "point",
            Rt = O.get("icon-rotation-alignment") === "map" && O.get("symbol-placement") !== "point",
            Vt = O.get("symbol-placement"),
            fr = be / 2,
            qt = O.get("icon-text-fit");
          let Ut;
          a && qt !== "none" && (i.allowVerticalPlacement && r.vertical && (Ut = __(a, r.vertical, qt, O.get("icon-text-fit-padding"), j, Y)), Z && (a = __(a, Z, qt, O.get("icon-text-fit-padding"), j, Y)));
          const dt = I ? E.line.getGranularityForZoomLevel(I.z) : 1,
            Br = (Zr, yr) => {
              yr.x < 0 || yr.x >= ie || yr.y < 0 || yr.y >= ie || (function(or, oi, Gi, fn, Fn, Aa, aa, An, Vi, wn, kn, En, Jn, ka, Tn, sa, mn, Cn, Sn, on, Fi, Wa, Vl, Xa, my) {
                const Ul = or.addToLineVertexArray(oi, Gi);
                let jo, Zl, $l, Gl, K_ = 0,
                  Y_ = 0,
                  J_ = 0,
                  Q_ = 0,
                  ef = -1,
                  tf = -1;
                const As = {};
                let eg = Js("");
                if (or.allowVerticalPlacement && fn.vertical) {
                  const Un = An.layout.get("text-rotate").evaluate(Fi, {}, Xa) + 90;
                  $l = new _d(Vi, oi, wn, kn, En, fn.vertical, Jn, ka, Tn, Un), aa && (Gl = new _d(Vi, oi, wn, kn, En, aa, mn, Cn, Tn, Un))
                }
                if (Fn) {
                  const Un = An.layout.get("icon-rotate").evaluate(Fi, {}),
                    Ea = An.layout.get("icon-text-fit") !== "none",
                    qo = q_(Fn, Un, Vl, Ea),
                    Ya = aa ? q_(aa, Un, Vl, Ea) : void 0;
                  Zl = new _d(Vi, oi, wn, kn, En, Fn, mn, Cn, !1, Un), K_ = 4 * qo.length;
                  const Vo = or.iconSizeData;
                  let cs = null;
                  Vo.kind === "source" ? (cs = [Ms * An.layout.get("icon-size").evaluate(Fi, {})], cs[0] > to && Lt(`${or.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : Vo.kind === "composite" && (cs = [Ms * Wa.compositeIconSizes[0].evaluate(Fi, {}, Xa), Ms * Wa.compositeIconSizes[1].evaluate(Fi, {}, Xa)], (cs[0] > to || cs[1] > to) && Lt(`${or.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), or.addSymbols(or.icon, qo, cs, on, Sn, Fi, T.ao.none, oi, Ul.lineStartIndex, Ul.lineLength, -1, Xa), ef = or.icon.placedSymbolArray.length - 1, Ya && (Y_ = 4 * Ya.length, or.addSymbols(or.icon, Ya, cs, on, Sn, Fi, T.ao.vertical, oi, Ul.lineStartIndex, Ul.lineLength, -1, Xa), tf = or.icon.placedSymbolArray.length - 1)
                }
                const tg = Object.keys(fn.horizontal);
                for (const Un of tg) {
                  const Ea = fn.horizontal[Un];
                  if (!jo) {
                    eg = Js(Ea.text);
                    const Ya = An.layout.get("text-rotate").evaluate(Fi, {}, Xa);
                    jo = new _d(Vi, oi, wn, kn, En, Ea, Jn, ka, Tn, Ya)
                  }
                  const qo = Ea.positionedLines.length === 1;
                  if (J_ += $_(or, oi, Ea, Aa, An, Tn, Fi, sa, Ul, fn.vertical ? T.ao.horizontal : T.ao.horizontalOnly, qo ? tg : [Un], As, ef, Wa, Xa), qo) break
                }
                fn.vertical && (Q_ += $_(or, oi, fn.vertical, Aa, An, Tn, Fi, sa, Ul, T.ao.vertical, ["vertical"], As, tf, Wa, Xa));
                const _y = jo ? jo.boxStartIndex : or.collisionBoxArray.length,
                  gy = jo ? jo.boxEndIndex : or.collisionBoxArray.length,
                  vy = $l ? $l.boxStartIndex : or.collisionBoxArray.length,
                  yy = $l ? $l.boxEndIndex : or.collisionBoxArray.length,
                  xy = Zl ? Zl.boxStartIndex : or.collisionBoxArray.length,
                  by = Zl ? Zl.boxEndIndex : or.collisionBoxArray.length,
                  wy = Gl ? Gl.boxStartIndex : or.collisionBoxArray.length,
                  Ty = Gl ? Gl.boxEndIndex : or.collisionBoxArray.length;
                let Ka = -1;
                const vd = (Un, Ea) => Un && Un.circleDiameter ? Math.max(Un.circleDiameter, Ea) : Ea;
                Ka = vd(jo, Ka), Ka = vd($l, Ka), Ka = vd(Zl, Ka), Ka = vd(Gl, Ka);
                const rg = Ka > -1 ? 1 : 0;
                rg && (Ka *= my / bn), or.glyphOffsetArray.length >= Nl.MAX_GLYPHS && Lt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Fi.sortKey !== void 0 && or.addToSortKeyRanges(or.symbolInstances.length, Fi.sortKey);
                const Cy = Z_(An, Fi, Xa),
                  [Sy, Py] = (function(Un, Ea) {
                    const qo = Un.length,
                      Ya = Ea == null ? void 0 : Ea.values;
                    if ((Ya == null ? void 0 : Ya.length) > 0)
                      for (let Vo = 0; Vo < Ya.length; Vo += 2) {
                        const cs = Ya[Vo + 1];
                        Un.emplaceBack(T.aE[Ya[Vo]], cs[0], cs[1])
                      }
                    return [qo, Un.length]
                  })(or.textAnchorOffsets, Cy);
                or.symbolInstances.emplaceBack(oi.x, oi.y, As.right >= 0 ? As.right : -1, As.center >= 0 ? As.center : -1, As.left >= 0 ? As.left : -1, As.vertical || -1, ef, tf, eg, _y, gy, vy, yy, xy, by, wy, Ty, wn, J_, Q_, K_, Y_, rg, 0, Jn, Ka, Sy, Py)
              })(i, yr, Zr, r, a, c, Ut, i.layers[0], i.collisionBoxArray, t.index, t.sourceLayerIndex, i.index, ne, [Ve, Ve, Ve, Ve], Zt, v, pe, et, Rt, j, t, p, S, I, f)
            };
          if (Vt === "line")
            for (const Zr of R_(t.geometry, 0, 0, ie, ie)) {
              const yr = Oo(Zr, dt),
                or = ly(yr, be, xt, r.vertical || Z, a, 24, ke, i.overscaling, ie);
              for (const oi of or) Z && py(i, Z.text, fr, oi) || Br(yr, oi)
            } else if (Vt === "line-center") {
              for (const Zr of t.geometry)
                if (Zr.length > 1) {
                  const yr = Oo(Zr, dt),
                    or = oy(yr, xt, r.vertical || Z, a, 24, ke);
                  or && Br(yr, or)
                }
            } else if (t.type === "Polygon")
            for (const Zr of bo(t.geometry, 0)) {
              const yr = uy(Zr, 16);
              Br(Oo(Zr[0], dt, !0), new io(yr.x, yr.y, 0))
            } else if (t.type === "LineString")
              for (const Zr of t.geometry) {
                const yr = Oo(Zr, dt);
                Br(yr, new io(yr[0].x, yr[0].y, 0))
              } else if (t.type === "Point")
                for (const Zr of t.geometry)
                  for (const yr of Zr) Br([yr], new io(yr.x, yr.y, 0))
        }

        function $_(i, t, r, a, c, p, f, _, v, S, I, E, R, O, j) {
          const Z = (function(ke, pe, be, Ve, et, xt, Zt, Rt) {
              const Vt = Ve.layout.get("text-rotate").evaluate(xt, {}) * Math.PI / 180,
                fr = [];
              for (const qt of pe.positionedLines)
                for (const Ut of qt.positionedGlyphs) {
                  if (!Ut.rect) continue;
                  const dt = Ut.rect || {};
                  let Br = 4,
                    Zr = !0,
                    yr = 1,
                    or = 0;
                  const oi = (et || Rt) && Ut.vertical,
                    Gi = Ut.metrics.advance * Ut.scale / 2;
                  if (Rt && pe.verticalizable && (or = qt.lineOffset / 2 - (Ut.imageName ? -(bn - Ut.metrics.width * Ut.scale) / 2 : (Ut.scale - 1) * bn)), Ut.imageName) {
                    const Cn = Zt[Ut.imageName];
                    Zr = Cn.sdf, yr = Cn.pixelRatio, Br = 1 / yr
                  }
                  const fn = et ? [Ut.x + Gi, Ut.y] : [0, 0];
                  let Fn = et ? [0, 0] : [Ut.x + Gi + be[0], Ut.y + be[1] - or],
                    Aa = [0, 0];
                  oi && (Aa = Fn, Fn = [0, 0]);
                  const aa = Ut.metrics.isDoubleResolution ? 2 : 1,
                    An = (Ut.metrics.left - Br) * Ut.scale - Gi + Fn[0],
                    Vi = (-Ut.metrics.top - Br) * Ut.scale + Fn[1],
                    wn = An + dt.w / aa * Ut.scale / yr,
                    kn = Vi + dt.h / aa * Ut.scale / yr,
                    En = new G(An, Vi),
                    Jn = new G(wn, Vi),
                    ka = new G(An, kn),
                    Tn = new G(wn, kn);
                  if (oi) {
                    const Cn = new G(-Gi, Gi - -17),
                      Sn = -Math.PI / 2,
                      on = 12 - Gi,
                      Fi = new G(22 - on, -(Ut.imageName ? on : 0)),
                      Wa = new G(...Aa);
                    En._rotateAround(Sn, Cn)._add(Fi)._add(Wa), Jn._rotateAround(Sn, Cn)._add(Fi)._add(Wa), ka._rotateAround(Sn, Cn)._add(Fi)._add(Wa), Tn._rotateAround(Sn, Cn)._add(Fi)._add(Wa)
                  }
                  if (Vt) {
                    const Cn = Math.sin(Vt),
                      Sn = Math.cos(Vt),
                      on = [Sn, -Cn, Cn, Sn];
                    En._matMult(on), Jn._matMult(on), ka._matMult(on), Tn._matMult(on)
                  }
                  const sa = new G(0, 0),
                    mn = new G(0, 0);
                  fr.push({
                    tl: En,
                    tr: Jn,
                    bl: ka,
                    br: Tn,
                    tex: dt,
                    writingMode: pe.writingMode,
                    glyphOffset: fn,
                    sectionIndex: Ut.sectionIndex,
                    isSDF: Zr,
                    pixelOffsetTL: sa,
                    pixelOffsetBR: mn,
                    minFontScaleX: 0,
                    minFontScaleY: 0
                  })
                }
              return fr
            })(0, r, _, c, p, f, a, i.allowVerticalPlacement),
            Y = i.textSizeData;
          let ne = null;
          Y.kind === "source" ? (ne = [Ms * c.layout.get("text-size").evaluate(f, {})], ne[0] > to && Lt(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : Y.kind === "composite" && (ne = [Ms * O.compositeTextSizes[0].evaluate(f, {}, j), Ms * O.compositeTextSizes[1].evaluate(f, {}, j)], (ne[0] > to || ne[1] > to) && Lt(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), i.addSymbols(i.text, Z, ne, _, p, f, S, t, v.lineStartIndex, v.lineLength, R, j);
          for (const ke of I) E[ke] = i.text.placedSymbolArray.length - 1;
          return 4 * Z.length
        }

        function G_(i) {
          for (const t in i) return i[t];
          return null
        }

        function py(i, t, r, a) {
          const c = i.compareText;
          if (t in c) {
            const p = c[t];
            for (let f = p.length - 1; f >= 0; f--)
              if (a.dist(p[f]) < r) return !0
          } else c[t] = [];
          return c[t].push(a), !1
        }
        const H_ = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Hp {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [r, a] = new Uint8Array(t, 0, 2);
            if (r !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const c = a >> 4;
            if (c !== 1) throw new Error(`Got v${c} data when expected v1.`);
            const p = H_[15 & a];
            if (!p) throw new Error("Unrecognized array type.");
            const [f] = new Uint16Array(t, 2, 1), [_] = new Uint32Array(t, 4, 1);
            return new Hp(_, f, p, t)
          }
          constructor(t, r = 64, a = Float64Array, c) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = a, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const p = H_.indexOf(this.ArrayType),
              f = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
              _ = t * this.IndexArrayType.BYTES_PER_ELEMENT,
              v = (8 - _ % 8) % 8;
            if (p < 0) throw new Error(`Unexpected typed array class: ${a}.`);
            c && c instanceof ArrayBuffer ? (this.data = c, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + _ + v, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + f + _ + v), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + _ + v, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + p]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = t)
          }
          add(t, r) {
            const a = this._pos >> 1;
            return this.ids[a] = a, this.coords[this._pos++] = t, this.coords[this._pos++] = r, a
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return Wp(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this
          }
          range(t, r, a, c) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: p,
              coords: f,
              nodeSize: _
            } = this, v = [0, p.length - 1, 0], S = [];
            for (; v.length;) {
              const I = v.pop() || 0,
                E = v.pop() || 0,
                R = v.pop() || 0;
              if (E - R <= _) {
                for (let Y = R; Y <= E; Y++) {
                  const ne = f[2 * Y],
                    ke = f[2 * Y + 1];
                  ne >= t && ne <= a && ke >= r && ke <= c && S.push(p[Y])
                }
                continue
              }
              const O = R + E >> 1,
                j = f[2 * O],
                Z = f[2 * O + 1];
              j >= t && j <= a && Z >= r && Z <= c && S.push(p[O]), (I === 0 ? t <= j : r <= Z) && (v.push(R), v.push(O - 1), v.push(1 - I)), (I === 0 ? a >= j : c >= Z) && (v.push(O + 1), v.push(E), v.push(1 - I))
            }
            return S
          }
          within(t, r, a) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: c,
              coords: p,
              nodeSize: f
            } = this, _ = [0, c.length - 1, 0], v = [], S = a * a;
            for (; _.length;) {
              const I = _.pop() || 0,
                E = _.pop() || 0,
                R = _.pop() || 0;
              if (E - R <= f) {
                for (let Y = R; Y <= E; Y++) X_(p[2 * Y], p[2 * Y + 1], t, r) <= S && v.push(c[Y]);
                continue
              }
              const O = R + E >> 1,
                j = p[2 * O],
                Z = p[2 * O + 1];
              X_(j, Z, t, r) <= S && v.push(c[O]), (I === 0 ? t - a <= j : r - a <= Z) && (_.push(R), _.push(O - 1), _.push(1 - I)), (I === 0 ? t + a >= j : r + a >= Z) && (_.push(O + 1), _.push(E), _.push(1 - I))
            }
            return v
          }
        }

        function Wp(i, t, r, a, c, p) {
          if (c - a <= r) return;
          const f = a + c >> 1;
          W_(i, t, f, a, c, p), Wp(i, t, r, a, f - 1, 1 - p), Wp(i, t, r, f + 1, c, 1 - p)
        }

        function W_(i, t, r, a, c, p) {
          for (; c > a;) {
            if (c - a > 600) {
              const S = c - a + 1,
                I = r - a + 1,
                E = Math.log(S),
                R = .5 * Math.exp(2 * E / 3),
                O = .5 * Math.sqrt(E * R * (S - R) / S) * (I - S / 2 < 0 ? -1 : 1);
              W_(i, t, r, Math.max(a, Math.floor(r - I * R / S + O)), Math.min(c, Math.floor(r + (S - I) * R / S + O)), p)
            }
            const f = t[2 * r + p];
            let _ = a,
              v = c;
            for (mu(i, t, a, r), t[2 * c + p] > f && mu(i, t, a, c); _ < v;) {
              for (mu(i, t, _, v), _++, v--; t[2 * _ + p] < f;) _++;
              for (; t[2 * v + p] > f;) v--
            }
            t[2 * a + p] === f ? mu(i, t, a, v) : (v++, mu(i, t, v, c)), v <= r && (a = v + 1), r <= v && (c = v - 1)
          }
        }

        function mu(i, t, r, a) {
          Xp(i, r, a), Xp(t, 2 * r, 2 * a), Xp(t, 2 * r + 1, 2 * a + 1)
        }

        function Xp(i, t, r) {
          const a = i[t];
          i[t] = i[r], i[r] = a
        }

        function X_(i, t, r, a) {
          const c = i - r,
            p = t - a;
          return c * c + p * p
        }
        var Kp;
        T.cx = void 0, (Kp = T.cx || (T.cx = {})).create = "create", Kp.load = "load", Kp.fullLoad = "fullLoad";
        let gd = null,
          _u = [];
        const Yp = 1e3 / 60,
          Jp = "loadTime",
          Qp = "fullLoadTime",
          fy = {
            mark(i) {
              performance.mark(i)
            },
            frame(i) {
              const t = i;
              gd != null && _u.push(t - gd), gd = t
            },
            clearMetrics() {
              gd = null, _u = [], performance.clearMeasures(Jp), performance.clearMeasures(Qp);
              for (const i in T.cx) performance.clearMarks(T.cx[i])
            },
            getPerformanceMetrics() {
              performance.measure(Jp, T.cx.create, T.cx.load), performance.measure(Qp, T.cx.create, T.cx.fullLoad);
              const i = performance.getEntriesByName(Jp)[0].duration,
                t = performance.getEntriesByName(Qp)[0].duration,
                r = _u.length,
                a = 1 / (_u.reduce(((p, f) => p + f), 0) / r / 1e3),
                c = _u.filter((p => p > Yp)).reduce(((p, f) => p + (f - Yp) / Yp), 0);
              return {
                loadTime: i,
                fullLoadTime: t,
                fps: a,
                percentDroppedFrames: c / (r + c) * 100,
                totalFrames: r
              }
            }
          };
        T.$ = ie, T.A = Le, T.B = function([i, t, r]) {
          return t += 90, t *= Math.PI / 180, r *= Math.PI / 180, {
            x: i * Math.cos(t) * Math.sin(r),
            y: i * Math.sin(t) * Math.sin(r),
            z: i * Math.cos(r)
          }
        }, T.C = Ba, T.D = hr, T.E = kt, T.F = ji, T.G = Eo, T.H = function(i) {
          if (dr == null) {
            const t = i.navigator ? i.navigator.userAgent : null;
            dr = !!i.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
          }
          return dr
        }, T.I = Dp, T.J = class {
          constructor(i, t) {
            this.target = i, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new ny((() => this.process())), this.subscription = Vr(this.target, "message", (r => this.receive(r)), !1), this.globalScope = Jt(self) ? i : window
          }
          registerMessageHandler(i, t) {
            this.messageHandlers[i] = t
          }
          sendAsync(i, t) {
            return new Promise(((r, a) => {
              const c = Math.round(1e18 * Math.random()).toString(36).substring(0, 10),
                p = t ? Vr(t.signal, "abort", (() => {
                  p == null || p.unsubscribe(), delete this.resolveRejects[c];
                  const v = {
                    id: c,
                    type: "<cancel>",
                    origin: location.origin,
                    targetMapId: i.targetMapId,
                    sourceMapId: this.mapId
                  };
                  this.target.postMessage(v)
                }), ay) : null;
              this.resolveRejects[c] = {
                resolve: v => {
                  p == null || p.unsubscribe(), r(v)
                },
                reject: v => {
                  p == null || p.unsubscribe(), a(v)
                }
              };
              const f = [],
                _ = Object.assign(Object.assign({}, i), {
                  id: c,
                  sourceMapId: this.mapId,
                  origin: location.origin,
                  data: Gs(i.data, f)
                });
              this.target.postMessage(_, {
                transfer: f
              })
            }))
          }
          receive(i) {
            const t = i.data,
              r = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[r];
                const a = this.abortControllers[r];
                return delete this.abortControllers[r], void(a && a.abort())
              }
              if (Jt(self) || t.mustQueue) return this.tasks[r] = t, this.taskQueue.push(r), void this.invoker.trigger();
              this.processTask(r, t)
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const i = this.taskQueue.shift(),
              t = this.tasks[i];
            delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(i, t)
          }
          processTask(i, t) {
            return o(this, void 0, void 0, (function*() {
              if (t.type === "<response>") {
                const c = this.resolveRejects[i];
                return delete this.resolveRejects[i], c ? void(t.error ? c.reject(Ts(t.error)) : c.resolve(Ts(t.data))) : void 0
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const r = Ts(t.data),
                a = new AbortController;
              this.abortControllers[i] = a;
              try {
                const c = yield this.messageHandlers[t.type](t.sourceMapId, r, a);
                this.completeTask(i, null, c)
              } catch (c) {
                this.completeTask(i, c)
              }
            }))
          }
          completeTask(i, t, r) {
            const a = [];
            delete this.abortControllers[i];
            const c = {
              id: i,
              type: "<response>",
              sourceMapId: this.mapId,
              origin: location.origin,
              error: t ? Gs(t) : null,
              data: Gs(r, a)
            };
            this.target.postMessage(c, {
              transfer: a
            })
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe()
          }
        }, T.K = $, T.L = function() {
          var i = new Le(16);
          return Le != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i
        }, T.M = function(i, t, r) {
          var a, c, p, f, _, v, S, I, E, R, O, j, Z = r[0],
            Y = r[1],
            ne = r[2];
          return t === i ? (i[12] = t[0] * Z + t[4] * Y + t[8] * ne + t[12], i[13] = t[1] * Z + t[5] * Y + t[9] * ne + t[13], i[14] = t[2] * Z + t[6] * Y + t[10] * ne + t[14], i[15] = t[3] * Z + t[7] * Y + t[11] * ne + t[15]) : (c = t[1], p = t[2], f = t[3], _ = t[4], v = t[5], S = t[6], I = t[7], E = t[8], R = t[9], O = t[10], j = t[11], i[0] = a = t[0], i[1] = c, i[2] = p, i[3] = f, i[4] = _, i[5] = v, i[6] = S, i[7] = I, i[8] = E, i[9] = R, i[10] = O, i[11] = j, i[12] = a * Z + _ * Y + E * ne + t[12], i[13] = c * Z + v * Y + R * ne + t[13], i[14] = p * Z + S * Y + O * ne + t[14], i[15] = f * Z + I * Y + j * ne + t[15]), i
        }, T.N = function(i, t, r) {
          var a = r[0],
            c = r[1],
            p = r[2];
          return i[0] = t[0] * a, i[1] = t[1] * a, i[2] = t[2] * a, i[3] = t[3] * a, i[4] = t[4] * c, i[5] = t[5] * c, i[6] = t[6] * c, i[7] = t[7] * c, i[8] = t[8] * p, i[9] = t[9] * p, i[10] = t[10] * p, i[11] = t[11] * p, i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i
        }, T.O = function(i, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2],
            f = t[3],
            _ = t[4],
            v = t[5],
            S = t[6],
            I = t[7],
            E = t[8],
            R = t[9],
            O = t[10],
            j = t[11],
            Z = t[12],
            Y = t[13],
            ne = t[14],
            ke = t[15],
            pe = r[0],
            be = r[1],
            Ve = r[2],
            et = r[3];
          return i[0] = pe * a + be * _ + Ve * E + et * Z, i[1] = pe * c + be * v + Ve * R + et * Y, i[2] = pe * p + be * S + Ve * O + et * ne, i[3] = pe * f + be * I + Ve * j + et * ke, i[4] = (pe = r[4]) * a + (be = r[5]) * _ + (Ve = r[6]) * E + (et = r[7]) * Z, i[5] = pe * c + be * v + Ve * R + et * Y, i[6] = pe * p + be * S + Ve * O + et * ne, i[7] = pe * f + be * I + Ve * j + et * ke, i[8] = (pe = r[8]) * a + (be = r[9]) * _ + (Ve = r[10]) * E + (et = r[11]) * Z, i[9] = pe * c + be * v + Ve * R + et * Y, i[10] = pe * p + be * S + Ve * O + et * ne, i[11] = pe * f + be * I + Ve * j + et * ke, i[12] = (pe = r[12]) * a + (be = r[13]) * _ + (Ve = r[14]) * E + (et = r[15]) * Z, i[13] = pe * c + be * v + Ve * R + et * Y, i[14] = pe * p + be * S + Ve * O + et * ne, i[15] = pe * f + be * I + Ve * j + et * ke, i
        }, T.P = G, T.Q = function(i, t) {
          const r = {};
          for (let a = 0; a < t.length; a++) {
            const c = t[a];
            c in i && (r[c] = i[c])
          }
          return r
        }, T.R = na, T.S = ro, T.T = Tp, T.U = P_, T.V = S_, T.W = De, T.X = Be, T.Y = pr, T.Z = Ma, T._ = o, T.a = F, T.a$ = Qe, T.a0 = function(i, t) {
          var r, a, c, p;
          if (!i) return t ?? {};
          if (!t) return i;
          const f = Object.assign({}, i);
          if (t.removeAll && (f.removeAll = !0), t.remove) {
            const _ = new Set(f.remove ? f.remove.concat(t.remove) : t.remove);
            f.remove = Array.from(_.values())
          }
          if (t.add) {
            const _ = f.add ? f.add.concat(t.add) : t.add,
              v = new Map(_.map((S => [S.id, S])));
            f.add = Array.from(v.values())
          }
          if (t.update) {
            const _ = new Map((r = f.update) === null || r === void 0 ? void 0 : r.map((v => [v.id, v])));
            for (const v of t.update) {
              const S = (a = _.get(v.id)) !== null && a !== void 0 ? a : {
                id: v.id
              };
              v.newGeometry && (S.newGeometry = v.newGeometry), v.addOrUpdateProperties && (S.addOrUpdateProperties = ((c = S.addOrUpdateProperties) !== null && c !== void 0 ? c : []).concat(v.addOrUpdateProperties)), v.removeProperties && (S.removeProperties = ((p = S.removeProperties) !== null && p !== void 0 ? p : []).concat(v.removeProperties)), v.removeAllProperties && (S.removeAllProperties = !0), _.set(v.id, S)
            }
            f.update = Array.from(_.values())
          }
          return f
        }, T.a1 = pu, T.a2 = No, T.a3 = 25, T.a4 = Zp, T.a5 = i => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise((r => {
            t.onloadstart = () => {
              r(t)
            };
            for (const a of i) {
              const c = window.document.createElement("source");
              Ee(a) || (t.crossOrigin = "Anonymous"), c.src = a, t.appendChild(c)
            }
          }))
        }, T.a6 = ft, T.a7 = function() {
          return Ct++
        }, T.a8 = z, T.a9 = Nl, T.aA = function(i) {
          let t = 1 / 0,
            r = 1 / 0,
            a = -1 / 0,
            c = -1 / 0;
          for (const p of i) t = Math.min(t, p.x), r = Math.min(r, p.y), a = Math.max(a, p.x), c = Math.max(c, p.y);
          return [t, r, a, c]
        }, T.aB = bn, T.aC = Se, T.aD = function(i, t, r, a, c = !1) {
          if (!r[0] && !r[1]) return [0, 0];
          const p = c ? a === "map" ? -i.bearingInRadians : 0 : a === "viewport" ? i.bearingInRadians : 0;
          if (p) {
            const f = Math.sin(p),
              _ = Math.cos(p);
            r = [r[0] * _ - r[1] * f, r[0] * f + r[1] * _]
          }
          return [c ? r[0] : Se(t, r[0], i.zoom), c ? r[1] : Se(t, r[1], i.zoom)]
        }, T.aF = Fp, T.aG = Gp, T.aH = Bp, T.aI = Hp, T.aJ = Xi, T.aK = od, T.aL = he, T.aM = Xr, T.aN = ki, T.aO = st, T.aP = Pr, T.aQ = M_, T.aR = Re, T.aS = tt, T.aT = function(i) {
          var t = new Le(3);
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t
        }, T.aU = function(i, t, r) {
          return i[0] = t[0] - r[0], i[1] = t[1] - r[1], i[2] = t[2] - r[2], i
        }, T.aV = function(i, t) {
          var r = t[0],
            a = t[1],
            c = t[2],
            p = r * r + a * a + c * c;
          return p > 0 && (p = 1 / Math.sqrt(p)), i[0] = t[0] * p, i[1] = t[1] * p, i[2] = t[2] * p, i
        }, T.aW = ot, T.aX = function(i, t) {
          return i[0] * t[0] + i[1] * t[1] + i[2] * t[2]
        }, T.aY = function(i, t, r) {
          return i[0] = t[0] * r[0], i[1] = t[1] * r[1], i[2] = t[2] * r[2], i[3] = t[3] * r[3], i
        }, T.aZ = Ke, T.a_ = function(i, t, r) {
          const a = t[0] * r[0] + t[1] * r[1] + t[2] * r[2];
          return a === 0 ? null : (-(i[0] * r[0] + i[1] * r[1] + i[2] * r[2]) - r[3]) / a
        }, T.aa = xs, T.ab = Ha, T.ac = z_, T.ad = function(i) {
          const t = {};
          if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((r, a, c, p) => {
              const f = c || p;
              return t[a] = !f || f.toLowerCase(), ""
            })), t["max-age"]) {
            const r = parseInt(t["max-age"], 10);
            isNaN(r) ? delete t["max-age"] : t["max-age"] = r
          }
          return t
        }, T.ae = ur, T.af = function(i) {
          return Math.pow(2, i)
        }, T.ag = mt, T.ah = Nt, T.ai = 85.051129, T.aj = I_, T.ak = function(i) {
          return Math.log(i) / Math.LN2
        }, T.al = function(i) {
          var t = i[0],
            r = i[1];
          return t * t + r * r
        }, T.am = function(i, t) {
          const r = [];
          for (const a in i) a in t || r.push(a);
          return r
        }, T.an = function(i, t) {
          let r = 0,
            a = 0;
          if (i.kind === "constant") a = i.layoutSize;
          else if (i.kind !== "source") {
            const {
              interpolationType: c,
              minZoom: p,
              maxZoom: f
            } = i, _ = c ? Nt(Mn.interpolationFactor(c, t, p, f), 0, 1) : 0;
            i.kind === "camera" ? a = Ba.number(i.minSize, i.maxSize, _) : r = _
          }
          return {
            uSizeT: r,
            uSize: a
          }
        }, T.ap = function(i, {
          uSize: t,
          uSizeT: r
        }, {
          lowerSize: a,
          upperSize: c
        }) {
          return i.kind === "source" ? a / Ms : i.kind === "composite" ? Ba.number(a / Ms, c / Ms, r) : t
        }, T.aq = function(i, t) {
          var r = t[0],
            a = t[1],
            c = t[2],
            p = t[3],
            f = t[4],
            _ = t[5],
            v = t[6],
            S = t[7],
            I = t[8],
            E = t[9],
            R = t[10],
            O = t[11],
            j = t[12],
            Z = t[13],
            Y = t[14],
            ne = t[15],
            ke = r * _ - a * f,
            pe = r * v - c * f,
            be = r * S - p * f,
            Ve = a * v - c * _,
            et = a * S - p * _,
            xt = c * S - p * v,
            Zt = I * Z - E * j,
            Rt = I * Y - R * j,
            Vt = I * ne - O * j,
            fr = E * Y - R * Z,
            qt = E * ne - O * Z,
            Ut = R * ne - O * Y,
            dt = ke * Ut - pe * qt + be * fr + Ve * Vt - et * Rt + xt * Zt;
          return dt ? (i[0] = (_ * Ut - v * qt + S * fr) * (dt = 1 / dt), i[1] = (c * qt - a * Ut - p * fr) * dt, i[2] = (Z * xt - Y * et + ne * Ve) * dt, i[3] = (R * et - E * xt - O * Ve) * dt, i[4] = (v * Vt - f * Ut - S * Rt) * dt, i[5] = (r * Ut - c * Vt + p * Rt) * dt, i[6] = (Y * be - j * xt - ne * pe) * dt, i[7] = (I * xt - R * be + O * pe) * dt, i[8] = (f * qt - _ * Vt + S * Zt) * dt, i[9] = (a * Vt - r * qt - p * Zt) * dt, i[10] = (j * et - Z * be + ne * ke) * dt, i[11] = (E * be - I * et - O * ke) * dt, i[12] = (_ * Rt - f * fr - v * Zt) * dt, i[13] = (r * fr - a * Rt + c * Zt) * dt, i[14] = (Z * pe - j * Ve - Y * ke) * dt, i[15] = (I * Ve - E * pe + R * ke) * dt, i) : null
        }, T.ar = te, T.as = function(i) {
          return Math.hypot(i[0], i[1])
        }, T.at = function(i) {
          return i[0] = 0, i[1] = 0, i
        }, T.au = function(i, t, r) {
          return i[0] = t[0] * r, i[1] = t[1] * r, i
        }, T.av = Op, T.aw = Ae, T.ax = function(i, t, r, a) {
          const c = t.y - i.y,
            p = t.x - i.x,
            f = a.y - r.y,
            _ = a.x - r.x,
            v = f * p - _ * c;
          if (v === 0) return null;
          const S = (_ * (i.y - r.y) - f * (i.x - r.x)) / v;
          return new G(i.x + S * p, i.y + S * c)
        }, T.ay = R_, T.az = Cm, T.b = nr, T.b$ = class extends h {}, T.b0 = function(i, t, r) {
          return i[0] = t[0] * r, i[1] = t[1] * r, i[2] = t[2] * r, i[3] = t[3] * r, i
        }, T.b1 = function(i, t) {
          return i[0] * t[0] + i[1] * t[1] + i[2] * t[2] + i[3]
        }, T.b2 = k_, T.b3 = jl, T.b4 = function(i, t, r, a, c) {
          var p, f = 1 / Math.tan(t / 2);
          return i[0] = f / r, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = f, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, c != null && c !== 1 / 0 ? (i[10] = (c + a) * (p = 1 / (a - c)), i[14] = 2 * c * a * p) : (i[10] = -1, i[14] = -2 * a), i
        }, T.b5 = function(i) {
          var t = new Le(16);
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], t
        }, T.b6 = function(i, t, r) {
          var a = Math.sin(r),
            c = Math.cos(r),
            p = t[0],
            f = t[1],
            _ = t[2],
            v = t[3],
            S = t[4],
            I = t[5],
            E = t[6],
            R = t[7];
          return t !== i && (i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = p * c + S * a, i[1] = f * c + I * a, i[2] = _ * c + E * a, i[3] = v * c + R * a, i[4] = S * c - p * a, i[5] = I * c - f * a, i[6] = E * c - _ * a, i[7] = R * c - v * a, i
        }, T.b7 = function(i, t, r) {
          var a = Math.sin(r),
            c = Math.cos(r),
            p = t[4],
            f = t[5],
            _ = t[6],
            v = t[7],
            S = t[8],
            I = t[9],
            E = t[10],
            R = t[11];
          return t !== i && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[4] = p * c + S * a, i[5] = f * c + I * a, i[6] = _ * c + E * a, i[7] = v * c + R * a, i[8] = S * c - p * a, i[9] = I * c - f * a, i[10] = E * c - _ * a, i[11] = R * c - v * a, i
        }, T.b8 = function() {
          const i = new Float32Array(16);
          return mt(i), i
        }, T.b9 = function() {
          const i = new Float64Array(16);
          return mt(i), i
        }, T.bA = function(i, t) {
          const r = Me(i, 360),
            a = Me(t, 360),
            c = a - r,
            p = a > r ? c - 360 : c + 360;
          return Math.abs(c) < Math.abs(p) ? c : p
        }, T.bB = function(i) {
          return i[0] = 0, i[1] = 0, i[2] = 0, i
        }, T.bC = function(i, t, r, a) {
          const c = Math.sqrt(i * i + t * t),
            p = Math.sqrt(r * r + a * a);
          i /= c, t /= c, r /= p, a /= p;
          const f = Math.acos(i * r + t * a);
          return -t * r + i * a > 0 ? f : -f
        }, T.bD = function(i, t) {
          const r = Me(i, 2 * Math.PI),
            a = Me(t, 2 * Math.PI);
          return Math.min(Math.abs(r - a), Math.abs(r - a + 2 * Math.PI), Math.abs(r - a - 2 * Math.PI))
        }, T.bE = function() {
          const i = {},
            t = ye.$version;
          for (const r in ye.$root) {
            const a = ye.$root[r];
            if (a.required) {
              let c = null;
              c = r === "version" ? t : a.type === "array" ? [] : {}, c != null && (i[r] = c)
            }
          }
          return i
        }, T.bF = bl, T.bG = oe, T.bH = function i(t, r) {
          if (Array.isArray(t)) {
            if (!Array.isArray(r) || t.length !== r.length) return !1;
            for (let a = 0; a < t.length; a++)
              if (!i(t[a], r[a])) return !1;
            return !0
          }
          if (typeof t == "object" && t !== null && r !== null) {
            if (typeof r != "object" || Object.keys(t).length !== Object.keys(r).length) return !1;
            for (const a in t)
              if (!i(t[a], r[a])) return !1;
            return !0
          }
          return t === r
        }, T.bI = function(i) {
          i = i.slice();
          const t = Object.create(null);
          for (let r = 0; r < i.length; r++) t[i[r].id] = i[r];
          for (let r = 0; r < i.length; r++) "ref" in i[r] && (i[r] = Ht(i[r], t[i[r].ref]));
          return i
        }, T.bJ = function(i) {
          if (i.type === "custom") return new iy(i);
          switch (i.type) {
            case "background":
              return new ey(i);
            case "circle":
              return new Nv(i);
            case "color-relief":
              return new $v(i);
            case "fill":
              return new s0(i);
            case "fill-extrusion":
              return new g0(i);
            case "heatmap":
              return new qv(i);
            case "hillshade":
              return new Uv(i);
            case "line":
              return new C0(i);
            case "raster":
              return new ry(i);
            case "symbol":
              return new dd(i)
          }
        }, T.bK = St, T.bL = function(i, t) {
          if (!i) return [{
            command: "setStyle",
            args: [t]
          }];
          let r = [];
          try {
            if (!pt(i.version, t.version)) return [{
              command: "setStyle",
              args: [t]
            }];
            pt(i.center, t.center) || r.push({
              command: "setCenter",
              args: [t.center]
            }), pt(i.state, t.state) || r.push({
              command: "setGlobalState",
              args: [t.state]
            }), pt(i.centerAltitude, t.centerAltitude) || r.push({
              command: "setCenterAltitude",
              args: [t.centerAltitude]
            }), pt(i.zoom, t.zoom) || r.push({
              command: "setZoom",
              args: [t.zoom]
            }), pt(i.bearing, t.bearing) || r.push({
              command: "setBearing",
              args: [t.bearing]
            }), pt(i.pitch, t.pitch) || r.push({
              command: "setPitch",
              args: [t.pitch]
            }), pt(i.roll, t.roll) || r.push({
              command: "setRoll",
              args: [t.roll]
            }), pt(i.sprite, t.sprite) || r.push({
              command: "setSprite",
              args: [t.sprite]
            }), pt(i.glyphs, t.glyphs) || r.push({
              command: "setGlyphs",
              args: [t.glyphs]
            }), pt(i.transition, t.transition) || r.push({
              command: "setTransition",
              args: [t.transition]
            }), pt(i.light, t.light) || r.push({
              command: "setLight",
              args: [t.light]
            }), pt(i.terrain, t.terrain) || r.push({
              command: "setTerrain",
              args: [t.terrain]
            }), pt(i.sky, t.sky) || r.push({
              command: "setSky",
              args: [t.sky]
            }), pt(i.projection, t.projection) || r.push({
              command: "setProjection",
              args: [t.projection]
            });
            const a = {},
              c = [];
            (function(f, _, v, S) {
              let I;
              for (I in _ = _ || {}, f = f || {}) Object.prototype.hasOwnProperty.call(f, I) && (Object.prototype.hasOwnProperty.call(_, I) || jr(I, v, S));
              for (I in _) Object.prototype.hasOwnProperty.call(_, I) && (Object.prototype.hasOwnProperty.call(f, I) ? pt(f[I], _[I]) || (f[I].type === "geojson" && _[I].type === "geojson" && Gr(f, _, I) ? bt(v, {
                command: "setGeoJSONSourceData",
                args: [I, _[I].data]
              }) : qr(I, _, v, S)) : ar(I, _, v))
            })(i.sources, t.sources, c, a);
            const p = [];
            i.layers && i.layers.forEach((f => {
              "source" in f && a[f.source] ? r.push({
                command: "removeLayer",
                args: [f.id]
              }) : p.push(f)
            })), r = r.concat(c), (function(f, _, v) {
              _ = _ || [];
              const S = (f = f || []).map(Er),
                I = _.map(Er),
                E = f.reduce(ai, {}),
                R = _.reduce(ai, {}),
                O = S.slice(),
                j = Object.create(null);
              let Z, Y, ne, ke, pe;
              for (let be = 0, Ve = 0; be < S.length; be++) Z = S[be], Object.prototype.hasOwnProperty.call(R, Z) ? Ve++ : (bt(v, {
                command: "removeLayer",
                args: [Z]
              }), O.splice(O.indexOf(Z, Ve), 1));
              for (let be = 0, Ve = 0; be < I.length; be++) Z = I[I.length - 1 - be], O[O.length - 1 - be] !== Z && (Object.prototype.hasOwnProperty.call(E, Z) ? (bt(v, {
                command: "removeLayer",
                args: [Z]
              }), O.splice(O.lastIndexOf(Z, O.length - Ve), 1)) : Ve++, ke = O[O.length - be], bt(v, {
                command: "addLayer",
                args: [R[Z], ke]
              }), O.splice(O.length - be, 0, Z), j[Z] = !0);
              for (let be = 0; be < I.length; be++)
                if (Z = I[be], Y = E[Z], ne = R[Z], !j[Z] && !pt(Y, ne))
                  if (pt(Y.source, ne.source) && pt(Y["source-layer"], ne["source-layer"]) && pt(Y.type, ne.type)) {
                    for (pe in mr(Y.layout, ne.layout, v, Z, null, "setLayoutProperty"), mr(Y.paint, ne.paint, v, Z, null, "setPaintProperty"), pt(Y.filter, ne.filter) || bt(v, {
                        command: "setFilter",
                        args: [Z, ne.filter]
                      }), pt(Y.minzoom, ne.minzoom) && pt(Y.maxzoom, ne.maxzoom) || bt(v, {
                        command: "setLayerZoomRange",
                        args: [Z, ne.minzoom, ne.maxzoom]
                      }), Y) Object.prototype.hasOwnProperty.call(Y, pe) && pe !== "layout" && pe !== "paint" && pe !== "filter" && pe !== "metadata" && pe !== "minzoom" && pe !== "maxzoom" && (pe.indexOf("paint.") === 0 ? mr(Y[pe], ne[pe], v, Z, pe.slice(6), "setPaintProperty") : pt(Y[pe], ne[pe]) || bt(v, {
                      command: "setLayerProperty",
                      args: [Z, pe, ne[pe]]
                    }));
                    for (pe in ne) Object.prototype.hasOwnProperty.call(ne, pe) && !Object.prototype.hasOwnProperty.call(Y, pe) && pe !== "layout" && pe !== "paint" && pe !== "filter" && pe !== "metadata" && pe !== "minzoom" && pe !== "maxzoom" && (pe.indexOf("paint.") === 0 ? mr(Y[pe], ne[pe], v, Z, pe.slice(6), "setPaintProperty") : pt(Y[pe], ne[pe]) || bt(v, {
                      command: "setLayerProperty",
                      args: [Z, pe, ne[pe]]
                    }))
                  } else bt(v, {
                    command: "removeLayer",
                    args: [Z]
                  }), ke = O[O.lastIndexOf(Z) + 1], bt(v, {
                    command: "addLayer",
                    args: [ne, ke]
                  })
            })(p, t.layers, r)
          } catch (a) {
            console.warn("Unable to compute style diff:", a), r = [{
              command: "setStyle",
              args: [t]
            }]
          }
          return r
        }, T.bM = function(i) {
          const t = [],
            r = i.id;
          return r === void 0 && t.push({
            message: `layers.${r}: missing required property "id"`
          }), i.render === void 0 && t.push({
            message: `layers.${r}: missing required method "render"`
          }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && t.push({
            message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
          }), t
        }, T.bN = yt, T.bO = Mt, T.bP = class extends Vn {
          constructor(i, t) {
            super(i, t), this.current = 0
          }
          set(i) {
            this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i))
          }
        }, T.bQ = pn, T.bR = class extends Vn {
          constructor(i, t) {
            super(i, t), this.current = da
          }
          set(i) {
            if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
            for (let t = 1; t < 16; t++)
              if (i[t] !== this.current[t]) {
                this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
                break
              }
          }
        }, T.bS = an, T.bT = class extends Vn {
          constructor(i, t) {
            super(i, t), this.current = [0, 0, 0]
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]))
          }
        }, T.bU = class extends Vn {
          constructor(i, t) {
            super(i, t), this.current = [0, 0]
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]))
          }
        }, T.bV = Fe, T.bW = function(i, t) {
          var r = Math.sin(t),
            a = Math.cos(t);
          return i[0] = a, i[1] = r, i[2] = 0, i[3] = -r, i[4] = a, i[5] = 0, i[6] = 0, i[7] = 0, i[8] = 1, i
        }, T.bX = function(i, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2];
          return i[0] = a * r[0] + c * r[3] + p * r[6], i[1] = a * r[1] + c * r[4] + p * r[7], i[2] = a * r[2] + c * r[5] + p * r[8], i
        }, T.bY = function(i, t, r, a, c, p, f) {
          var _ = 1 / (t - r),
            v = 1 / (a - c),
            S = 1 / (p - f);
          return i[0] = -2 * _, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * v, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * S, i[11] = 0, i[12] = (t + r) * _, i[13] = (c + a) * v, i[14] = (f + p) * S, i[15] = 1, i
        }, T.bZ = class extends Vn {
          constructor(i, t) {
            super(i, t), this.current = new Array
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const t = new Float32Array(4 * i.length);
              for (let r = 0; r < i.length; r++) t[4 * r] = i[r].r, t[4 * r + 1] = i[r].g, t[4 * r + 2] = i[r].b, t[4 * r + 3] = i[r].a;
              this.gl.uniform4fv(this.location, t)
            }
          }
        }, T.b_ = class extends Vn {
          constructor(i, t) {
            super(i, t), this.current = new Array
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const t = new Float32Array(i);
              this.gl.uniform1fv(this.location, t)
            }
          }
        }, T.ba = function() {
          return new Float64Array(16)
        }, T.bb = function(i, t, r) {
          const a = new Float64Array(4);
          return ee(a, i, t - 90, r), a
        }, T.bc = function(i, t, r, a) {
          var c, p, f, _, v, S = t[0],
            I = t[1],
            E = t[2],
            R = t[3],
            O = r[0],
            j = r[1],
            Z = r[2],
            Y = r[3];
          return (p = S * O + I * j + E * Z + R * Y) < 0 && (p = -p, O = -O, j = -j, Z = -Z, Y = -Y), 1 - p > je ? (c = Math.acos(p), f = Math.sin(c), _ = Math.sin((1 - a) * c) / f, v = Math.sin(a * c) / f) : (_ = 1 - a, v = a), i[0] = _ * S + v * O, i[1] = _ * I + v * j, i[2] = _ * E + v * Z, i[3] = _ * R + v * Y, i
        }, T.bd = function(i) {
          const t = new Float64Array(9);
          var r, a, c, p, f, _, v, S, I, E, R, O, j, Z, Y, ne, ke, pe;
          E = (c = (a = i)[0]) * (v = c + c), R = (p = a[1]) * v, j = (f = a[2]) * v, Z = f * (S = p + p), ne = (_ = a[3]) * v, ke = _ * S, pe = _ * (I = f + f), (r = t)[0] = 1 - (O = p * S) - (Y = f * I), r[3] = R - pe, r[6] = j + ke, r[1] = R + pe, r[4] = 1 - E - Y, r[7] = Z - ne, r[2] = j - ke, r[5] = Z + ne, r[8] = 1 - E - O;
          const be = Pr(-Math.asin(Nt(t[2], -1, 1)));
          let Ve, et;
          return Math.hypot(t[5], t[8]) < .001 ? (Ve = 0, et = -Pr(Math.atan2(t[3], t[4]))) : (Ve = Pr(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), et = Pr(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), {
            roll: Ve,
            pitch: be + 90,
            bearing: et
          }
        }, T.be = function(i, t) {
          return i.roll == t.roll && i.pitch == t.pitch && i.bearing == t.bearing
        }, T.bf = br, T.bg = ss, T.bh = Rl, T.bi = ou, T.bj = Dl, T.bk = nt, T.bl = Ye, T.bm = hn, T.bn = function(i, t, r, a, c) {
          return nt(a, c, Nt((i - t) / (r - t), 0, 1))
        }, T.bo = Me, T.bp = function() {
          return new Float64Array(3)
        }, T.bq = function(i, t, r, a) {
          return i[0] = t[0] + r[0] * a, i[1] = t[1] + r[1] * a, i[2] = t[2] + r[2] * a, i
        }, T.br = ee, T.bs = function(i, t, r) {
          var a = r[0],
            c = r[1],
            p = r[2],
            f = t[0],
            _ = t[1],
            v = t[2],
            S = c * v - p * _,
            I = p * f - a * v,
            E = a * _ - c * f,
            R = c * E - p * I,
            O = p * S - a * E,
            j = a * I - c * S,
            Z = 2 * r[3];
          return I *= Z, E *= Z, O *= 2, j *= 2, i[0] = f + (S *= Z) + (R *= 2), i[1] = _ + I + O, i[2] = v + E + j, i
        }, T.bt = function(i, t, r) {
          const a = (c = [i[0], i[1], i[2], t[0], t[1], t[2], r[0], r[1], r[2]])[0] * ((I = c[8]) * (f = c[4]) - (_ = c[5]) * (S = c[7])) + c[1] * (-I * (p = c[3]) + _ * (v = c[6])) + c[2] * (S * p - f * v);
          var c, p, f, _, v, S, I;
          if (a === 0) return null;
          const E = ot([], [t[0], t[1], t[2]], [r[0], r[1], r[2]]),
            R = ot([], [r[0], r[1], r[2]], [i[0], i[1], i[2]]),
            O = ot([], [i[0], i[1], i[2]], [t[0], t[1], t[2]]),
            j = Re([], E, -i[3]);
          return tt(j, j, Re([], R, -t[3])), tt(j, j, Re([], O, -r[3])), Re(j, j, 1 / a), j
        }, T.bu = Vp, T.bv = function() {
          return new Float64Array(4)
        }, T.bw = function(i, t, r, a) {
          var c = [],
            p = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], p[0] = c[0] * Math.cos(a) - c[1] * Math.sin(a), p[1] = c[0] * Math.sin(a) + c[1] * Math.cos(a), p[2] = c[2], i[0] = p[0] + r[0], i[1] = p[1] + r[1], i[2] = p[2] + r[2], i
        }, T.bx = function(i, t, r, a) {
          var c = [],
            p = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], p[0] = c[0], p[1] = c[1] * Math.cos(a) - c[2] * Math.sin(a), p[2] = c[1] * Math.sin(a) + c[2] * Math.cos(a), i[0] = p[0] + r[0], i[1] = p[1] + r[1], i[2] = p[2] + r[2], i
        }, T.by = function(i, t, r, a) {
          var c = [],
            p = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], p[0] = c[2] * Math.sin(a) + c[0] * Math.cos(a), p[1] = c[1], p[2] = c[2] * Math.cos(a) - c[0] * Math.sin(a), i[0] = p[0] + r[0], i[1] = p[1] + r[1], i[2] = p[2] + r[2], i
        }, T.bz = function(i, t, r) {
          var a = Math.sin(r),
            c = Math.cos(r),
            p = t[0],
            f = t[1],
            _ = t[2],
            v = t[3],
            S = t[8],
            I = t[9],
            E = t[10],
            R = t[11];
          return t !== i && (i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = p * c - S * a, i[1] = f * c - I * a, i[2] = _ * c - E * a, i[3] = v * c - R * a, i[8] = p * a + S * c, i[9] = f * a + I * c, i[10] = _ * a + E * c, i[11] = v * a + R * c, i
        }, T.c = ce, T.c0 = M0, T.c1 = class extends n {}, T.c2 = wp, T.c3 = function(i) {
          return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2))
        }, T.c4 = Dm, T.c5 = function(i, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2],
            f = r[3] * a + r[7] * c + r[11] * p + r[15];
          return i[0] = (r[0] * a + r[4] * c + r[8] * p + r[12]) / (f = f || 1), i[1] = (r[1] * a + r[5] * c + r[9] * p + r[13]) / f, i[2] = (r[2] * a + r[6] * c + r[10] * p + r[14]) / f, i
        }, T.c6 = class extends Kc {}, T.c7 = class extends P {}, T.c8 = function(i, t) {
          return i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3] && i[4] === t[4] && i[5] === t[5] && i[6] === t[6] && i[7] === t[7] && i[8] === t[8] && i[9] === t[9] && i[10] === t[10] && i[11] === t[11] && i[12] === t[12] && i[13] === t[13] && i[14] === t[14] && i[15] === t[15]
        }, T.c9 = function(i, t) {
          var r = i[0],
            a = i[1],
            c = i[2],
            p = i[3],
            f = i[4],
            _ = i[5],
            v = i[6],
            S = i[7],
            I = i[8],
            E = i[9],
            R = i[10],
            O = i[11],
            j = i[12],
            Z = i[13],
            Y = i[14],
            ne = i[15],
            ke = t[0],
            pe = t[1],
            be = t[2],
            Ve = t[3],
            et = t[4],
            xt = t[5],
            Zt = t[6],
            Rt = t[7],
            Vt = t[8],
            fr = t[9],
            qt = t[10],
            Ut = t[11],
            dt = t[12],
            Br = t[13],
            Zr = t[14],
            yr = t[15];
          return Math.abs(r - ke) <= je * Math.max(1, Math.abs(r), Math.abs(ke)) && Math.abs(a - pe) <= je * Math.max(1, Math.abs(a), Math.abs(pe)) && Math.abs(c - be) <= je * Math.max(1, Math.abs(c), Math.abs(be)) && Math.abs(p - Ve) <= je * Math.max(1, Math.abs(p), Math.abs(Ve)) && Math.abs(f - et) <= je * Math.max(1, Math.abs(f), Math.abs(et)) && Math.abs(_ - xt) <= je * Math.max(1, Math.abs(_), Math.abs(xt)) && Math.abs(v - Zt) <= je * Math.max(1, Math.abs(v), Math.abs(Zt)) && Math.abs(S - Rt) <= je * Math.max(1, Math.abs(S), Math.abs(Rt)) && Math.abs(I - Vt) <= je * Math.max(1, Math.abs(I), Math.abs(Vt)) && Math.abs(E - fr) <= je * Math.max(1, Math.abs(E), Math.abs(fr)) && Math.abs(R - qt) <= je * Math.max(1, Math.abs(R), Math.abs(qt)) && Math.abs(O - Ut) <= je * Math.max(1, Math.abs(O), Math.abs(Ut)) && Math.abs(j - dt) <= je * Math.max(1, Math.abs(j), Math.abs(dt)) && Math.abs(Z - Br) <= je * Math.max(1, Math.abs(Z), Math.abs(Br)) && Math.abs(Y - Zr) <= je * Math.max(1, Math.abs(Y), Math.abs(Zr)) && Math.abs(ne - yr) <= je * Math.max(1, Math.abs(ne), Math.abs(yr))
        }, T.cA = function(i, t) {
          F.REGISTERED_PROTOCOLS[i] = t
        }, T.cB = function(i) {
          delete F.REGISTERED_PROTOCOLS[i]
        }, T.cC = function(i, t) {
          const r = {};
          for (let c = 0; c < i.length; c++) {
            const p = t && t[i[c].id] || up(i[c]);
            t && (t[i[c].id] = p);
            let f = r[p];
            f || (f = r[p] = []), f.push(i[c])
          }
          const a = [];
          for (const c in r) a.push(r[c]);
          return a
        }, T.cD = Wt, T.cE = E_, T.cF = L_, T.cG = c_, T.cH = function(i) {
          i.bucket.createArrays(), i.bucket.tilePixelRatio = ie / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
          const t = i.bucket.layers[0],
            r = t.layout,
            a = t._unevaluatedLayout._values,
            c = {
              layoutIconSize: a["icon-size"].possiblyEvaluate(new ji(i.bucket.zoom + 1), i.canonical),
              layoutTextSize: a["text-size"].possiblyEvaluate(new ji(i.bucket.zoom + 1), i.canonical),
              textMaxSize: a["text-size"].possiblyEvaluate(new ji(18))
            };
          if (i.bucket.textSizeData.kind === "composite") {
            const {
              minZoom: S,
              maxZoom: I
            } = i.bucket.textSizeData;
            c.compositeTextSizes = [a["text-size"].possiblyEvaluate(new ji(S), i.canonical), a["text-size"].possiblyEvaluate(new ji(I), i.canonical)]
          }
          if (i.bucket.iconSizeData.kind === "composite") {
            const {
              minZoom: S,
              maxZoom: I
            } = i.bucket.iconSizeData;
            c.compositeIconSizes = [a["icon-size"].possiblyEvaluate(new ji(S), i.canonical), a["icon-size"].possiblyEvaluate(new ji(I), i.canonical)]
          }
          const p = r.get("text-line-height") * bn,
            f = r.get("text-rotation-alignment") !== "viewport" && r.get("symbol-placement") !== "point",
            _ = r.get("text-keep-upright"),
            v = r.get("text-size");
          for (const S of i.bucket.features) {
            const I = r.get("text-font").evaluate(S, {}, i.canonical).join(","),
              E = v.evaluate(S, {}, i.canonical),
              R = c.layoutTextSize.evaluate(S, {}, i.canonical),
              O = c.layoutIconSize.evaluate(S, {}, i.canonical),
              j = {
                horizontal: {},
                vertical: void 0
              },
              Z = S.text;
            let Y, ne = [0, 0];
            if (Z) {
              const be = Z.toString(),
                Ve = r.get("text-letter-spacing").evaluate(S, {}, i.canonical) * bn,
                et = fp(be) ? Ve : 0,
                xt = r.get("text-anchor").evaluate(S, {}, i.canonical),
                Zt = Z_(t, S, i.canonical);
              if (!Zt) {
                const qt = r.get("text-radial-offset").evaluate(S, {}, i.canonical);
                ne = qt ? U_(xt, [qt * bn, $p]) : r.get("text-offset").evaluate(S, {}, i.canonical).map((Ut => Ut * bn))
              }
              let Rt = f ? "center" : r.get("text-justify").evaluate(S, {}, i.canonical);
              const Vt = r.get("symbol-placement") === "point" ? r.get("text-max-width").evaluate(S, {}, i.canonical) * bn : 1 / 0,
                fr = () => {
                  i.bucket.allowVerticalPlacement && wl(be) && (j.vertical = cd(Z, i.glyphMap, i.glyphPositions, i.imagePositions, I, Vt, p, xt, "left", et, ne, T.ao.vertical, !0, R, E))
                };
              if (!f && Zt) {
                const qt = new Set;
                if (Rt === "auto")
                  for (let dt = 0; dt < Zt.values.length; dt += 2) qt.add(Gp(Zt.values[dt]));
                else qt.add(Rt);
                let Ut = !1;
                for (const dt of qt)
                  if (!j.horizontal[dt])
                    if (Ut) j.horizontal[dt] = j.horizontal[0];
                    else {
                      const Br = cd(Z, i.glyphMap, i.glyphPositions, i.imagePositions, I, Vt, p, "center", dt, et, ne, T.ao.horizontal, !1, R, E);
                      Br && (j.horizontal[dt] = Br, Ut = Br.positionedLines.length === 1)
                    } fr()
              } else {
                Rt === "auto" && (Rt = Gp(xt));
                const qt = cd(Z, i.glyphMap, i.glyphPositions, i.imagePositions, I, Vt, p, xt, Rt, et, ne, T.ao.horizontal, !1, R, E);
                qt && (j.horizontal[Rt] = qt), fr(), wl(be) && f && _ && (j.vertical = cd(Z, i.glyphMap, i.glyphPositions, i.imagePositions, I, Vt, p, xt, Rt, et, ne, T.ao.vertical, !1, R, E))
              }
            }
            let ke = !1;
            if (S.icon && S.icon.name) {
              const be = i.imageMap[S.icon.name];
              be && (Y = K0(i.imagePositions[S.icon.name], r.get("icon-offset").evaluate(S, {}, i.canonical), r.get("icon-anchor").evaluate(S, {}, i.canonical)), ke = !!be.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = ke : i.bucket.sdfIcons !== ke && Lt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (be.pixelRatio !== i.bucket.pixelRatio || r.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0))
            }
            const pe = G_(j.horizontal) || j.vertical;
            i.bucket.iconsInText = !!pe && pe.iconsInText, (pe || Y) && dy(i.bucket, S, j, Y, i.imageMap, c, R, O, ne, ke, i.canonical, i.subdivisionGranularity)
          }
          i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers()
        }, T.cI = Ep, T.cJ = Mp, T.cK = kp, T.cL = Xm, T.cM = Lp, T.cN = class {
          constructor(i) {
            this._marks = {
              start: [i.url, "start"].join("#"),
              end: [i.url, "end"].join("#"),
              measure: i.url.toString()
            }, performance.mark(this._marks.start)
          }
          finish() {
            performance.mark(this._marks.end);
            let i = performance.getEntriesByName(this._marks.measure);
            return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i
          }
        }, T.cO = function(i, t, r, a, c) {
          return o(this, void 0, void 0, (function*() {
            if (Be()) try {
              return yield pr(i, t, r, a, c)
            } catch {}
            return (function(p, f, _, v, S) {
              const I = p.width,
                E = p.height;
              gr && Sr || (gr = new OffscreenCanvas(I, E), Sr = gr.getContext("2d", {
                willReadFrequently: !0
              })), gr.width = I, gr.height = E, Sr.drawImage(p, 0, 0, I, E);
              const R = Sr.getImageData(f, _, v, S);
              return Sr.clearRect(0, 0, I, E), R.data
            })(i, t, r, a, c)
          }))
        }, T.cP = Fm, T.cQ = W, T.cR = Wm, T.cS = Bl, T.cT = So, T.cU = function(i, t) {
          const r = new Map;
          if (i != null)
            if (i.type === "Feature") r.set(fu(i, t), i);
            else
              for (const a of i.features) r.set(fu(a, t), a);
          return r
        }, T.cV = function(i, t) {
          if (i == null) return !0;
          if (i.type === "Feature") return fu(i, t) != null;
          if (i.type === "FeatureCollection") {
            const r = new Set;
            for (const a of i.features) {
              const c = fu(a, t);
              if (c == null || r.has(c)) return !1;
              r.add(c)
            }
            return !0
          }
          return !1
        }, T.cW = function(i, t, r) {
          var a, c, p, f;
          if (t.removeAll && i.clear(), t.remove)
            for (const _ of t.remove) i.delete(_);
          if (t.add)
            for (const _ of t.add) {
              const v = fu(_, r);
              v != null && i.set(v, _)
            }
          if (t.update)
            for (const _ of t.update) {
              let v = i.get(_.id);
              if (v == null) continue;
              const S = !_.removeAllProperties && (((a = _.removeProperties) === null || a === void 0 ? void 0 : a.length) > 0 || ((c = _.addOrUpdateProperties) === null || c === void 0 ? void 0 : c.length) > 0);
              if ((_.newGeometry || _.removeAllProperties || S) && (v = Object.assign({}, v), i.set(_.id, v), S && (v.properties = Object.assign({}, v.properties))), _.newGeometry && (v.geometry = _.newGeometry), _.removeAllProperties) v.properties = {};
              else if (((p = _.removeProperties) === null || p === void 0 ? void 0 : p.length) > 0)
                for (const I of _.removeProperties) Object.prototype.hasOwnProperty.call(v.properties, I) && delete v.properties[I];
              if (((f = _.addOrUpdateProperties) === null || f === void 0 ? void 0 : f.length) > 0)
                for (const {
                    key: I,
                    value: E
                  }
                  of _.addOrUpdateProperties) v.properties[I] = E
            }
        }, T.cX = Ca, T.ca = function(i, t) {
          return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i
        }, T.cb = i => i.type === "symbol", T.cc = i => i.type === "circle", T.cd = i => i.type === "heatmap", T.ce = i => i.type === "line", T.cf = i => i.type === "fill", T.cg = i => i.type === "fill-extrusion", T.ch = i => i.type === "hillshade", T.ci = i => i.type === "color-relief", T.cj = i => i.type === "raster", T.ck = i => i.type === "background", T.cl = i => i.type === "custom", T.cm = wt, T.cn = function(i, t, r) {
          const a = fe(t.x - r.x, t.y - r.y),
            c = fe(i.x - r.x, i.y - r.y);
          var p, f;
          return Pr(Math.atan2(a[0] * c[1] - a[1] * c[0], (p = a)[0] * (f = c)[0] + p[1] * f[1]))
        }, T.co = zt, T.cp = function(i, t) {
          return Mr[t] && (i instanceof MouseEvent || i instanceof WheelEvent)
        }, T.cq = function(i, t) {
          return Ir[t] && "touches" in i
        }, T.cr = function(i) {
          return Ir[i] || Mr[i]
        }, T.cs = function(i, t, r) {
          var a = t[0],
            c = t[1];
          return i[0] = r[0] * a + r[4] * c + r[12], i[1] = r[1] * a + r[5] * c + r[13], i
        }, T.ct = function(i, t) {
          const {
            x: r,
            y: a
          } = pu.fromLngLat(t);
          return !(i < 0 || i > 25 || a < 0 || a >= 1 || r < 0 || r >= 1)
        }, T.cu = function(i, t) {
          return i[0] = t[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = t[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
        }, T.cv = class extends Xs {}, T.cw = fy, T.cy = function(i) {
          return i.message === Nr
        }, T.cz = X, T.d = Ee, T.e = Tt, T.f = i => o(void 0, void 0, void 0, (function*() {
          if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(i)], {
            type: "image/png"
          });
          try {
            return createImageBitmap(t)
          } catch (r) {
            throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
          }
        })), T.g = q, T.h = i => new Promise(((t, r) => {
          const a = new Image;
          a.onload = () => {
            t(a), URL.revokeObjectURL(a.src), a.onload = null, window.requestAnimationFrame((() => {
              a.src = Bt
            }))
          }, a.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const c = new Blob([new Uint8Array(i)], {
            type: "image/png"
          });
          a.src = i.byteLength ? URL.createObjectURL(c) : Bt
        })), T.i = Jt, T.j = (i, t) => me(Tt(i, {
          type: "json"
        }), t), T.k = $e, T.l = it, T.m = me, T.n = (i, t) => me(Tt(i, {
          type: "arrayBuffer"
        }), t), T.o = function(i) {
          return new Lp(i).readFields(N0, [])
        }, T.p = l_, T.q = ru, T.r = jn, T.s = Vr, T.t = Jh, T.u = si, T.v = ye, T.w = Lt, T.x = hp, T.y = zo, T.z = $s
      })), D("worker", ["./shared"], (function(T) {
        class o {
          constructor(F) {
            this.keyCache = {}, F && this.replace(F)
          }
          replace(F) {
            this._layerConfigs = {}, this._layers = {}, this.update(F, [])
          }
          update(F, q) {
            for (const X of F) {
              this._layerConfigs[X.id] = X;
              const oe = this._layers[X.id] = T.bJ(X);
              oe._featureFilter = T.aa(oe.filter), this.keyCache[X.id] && delete this.keyCache[X.id]
            }
            for (const X of q) delete this.keyCache[X], delete this._layerConfigs[X], delete this._layers[X];
            this.familiesBySource = {};
            const $ = T.cC(Object.values(this._layerConfigs), this.keyCache);
            for (const X of $) {
              const oe = X.map(($e => this._layers[$e.id])),
                me = oe[0];
              if (me.visibility === "none") continue;
              const Ee = me.source || "";
              let Te = this.familiesBySource[Ee];
              Te || (Te = this.familiesBySource[Ee] = {});
              const Ze = me.sourceLayer || "_geojsonTileLayer";
              let it = Te[Ze];
              it || (it = Te[Ze] = []), it.push(oe)
            }
          }
        }
        class G {
          constructor(F) {
            const q = {},
              $ = [];
            for (const Ee in F) {
              const Te = F[Ee],
                Ze = q[Ee] = {};
              for (const it in Te) {
                const $e = Te[+it];
                if (!$e || $e.bitmap.width === 0 || $e.bitmap.height === 0) continue;
                const kt = {
                  x: 0,
                  y: 0,
                  w: $e.bitmap.width + 2,
                  h: $e.bitmap.height + 2
                };
                $.push(kt), Ze[it] = {
                  rect: kt,
                  metrics: $e.metrics
                }
              }
            }
            const {
              w: X,
              h: oe
            } = T.p($), me = new T.q({
              width: X || 1,
              height: oe || 1
            });
            for (const Ee in F) {
              const Te = F[Ee];
              for (const Ze in Te) {
                const it = Te[+Ze];
                if (!it || it.bitmap.width === 0 || it.bitmap.height === 0) continue;
                const $e = q[Ee][Ze].rect;
                T.q.copy(it.bitmap, me, {
                  x: 0,
                  y: 0
                }, {
                  x: $e.x + 1,
                  y: $e.y + 1
                }, it.bitmap)
              }
            }
            this.image = me, this.positions = q
          }
        }
        T.cD("GlyphAtlas", G);
        class W {
          constructor(F) {
            this.tileID = new T.Z(F.tileID.overscaledZ, F.tileID.wrap, F.tileID.canonical.z, F.tileID.canonical.x, F.tileID.canonical.y), this.uid = F.uid, this.zoom = F.zoom, this.pixelRatio = F.pixelRatio, this.tileSize = F.tileSize, this.source = F.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = F.showCollisionBoxes, this.collectResourceTiming = !!F.collectResourceTiming, this.returnDependencies = !!F.returnDependencies, this.promoteId = F.promoteId, this.inFlightDependencies = [], this.globalState = F.globalState
          }
          parse(F, q, $, X, oe) {
            return T._(this, void 0, void 0, (function*() {
              this.status = "parsing", this.data = F, this.collisionBoxArray = new T.a8;
              const me = new T.cE(Object.keys(F.layers).sort()),
                Ee = new T.cF(this.tileID, this.promoteId);
              Ee.bucketLayerIDs = [];
              const Te = {},
                Ze = {
                  featureIndex: Ee,
                  iconDependencies: {},
                  patternDependencies: {},
                  glyphDependencies: {},
                  availableImages: $,
                  subdivisionGranularity: oe
                },
                it = q.familiesBySource[this.source];
              for (const mr in it) {
                const Er = F.layers[mr];
                if (!Er) continue;
                Er.version === 1 && T.w(`Vector tile source "${this.source}" layer "${mr}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const ai = me.encode(mr),
                  ft = [];
                for (let yi = 0; yi < Er.length; yi++) {
                  const pi = Er.feature(yi),
                    In = Ee.getId(pi, mr);
                  ft.push({
                    feature: pi,
                    id: In,
                    index: yi,
                    sourceLayerIndex: ai
                  })
                }
                for (const yi of it[mr]) {
                  const pi = yi[0];
                  pi.source !== this.source && T.w(`layer.source = ${pi.source} does not equal this.source = ${this.source}`), pi.minzoom && this.zoom < Math.floor(pi.minzoom) || pi.maxzoom && this.zoom >= pi.maxzoom || pi.visibility !== "none" && (ae(yi, this.zoom, $), (Te[pi.id] = pi.createBucket({
                    index: Ee.bucketLayerIDs.length,
                    layers: yi,
                    zoom: this.zoom,
                    pixelRatio: this.pixelRatio,
                    overscaling: this.overscaling,
                    collisionBoxArray: this.collisionBoxArray,
                    sourceLayerIndex: ai,
                    sourceID: this.source,
                    globalState: this.globalState
                  })).populate(ft, Ze, this.tileID.canonical), Ee.bucketLayerIDs.push(yi.map((In => In.id))))
                }
              }
              const $e = T.bN(Ze.glyphDependencies, (mr => Object.keys(mr).map(Number)));
              this.inFlightDependencies.forEach((mr => mr == null ? void 0 : mr.abort())), this.inFlightDependencies = [];
              let kt = Promise.resolve({});
              if (Object.keys($e).length) {
                const mr = new AbortController;
                this.inFlightDependencies.push(mr), kt = X.sendAsync({
                  type: "GG",
                  data: {
                    stacks: $e,
                    source: this.source,
                    tileID: this.tileID,
                    type: "glyphs"
                  }
                }, mr)
              }
              const ye = Object.keys(Ze.iconDependencies);
              let Xt = Promise.resolve({});
              if (ye.length) {
                const mr = new AbortController;
                this.inFlightDependencies.push(mr), Xt = X.sendAsync({
                  type: "GI",
                  data: {
                    icons: ye,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                  }
                }, mr)
              }
              const Ht = Object.keys(Ze.patternDependencies);
              let pt = Promise.resolve({});
              if (Ht.length) {
                const mr = new AbortController;
                this.inFlightDependencies.push(mr), pt = X.sendAsync({
                  type: "GI",
                  data: {
                    icons: Ht,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                  }
                }, mr)
              }
              const [bt, ar, jr] = yield Promise.all([kt, Xt, pt]), qr = new G(bt), Gr = new T.cG(ar, jr);
              for (const mr in Te) {
                const Er = Te[mr];
                Er instanceof T.a9 ? (ae(Er.layers, this.zoom, $), T.cH({
                  bucket: Er,
                  glyphMap: bt,
                  glyphPositions: qr.positions,
                  imageMap: ar,
                  imagePositions: Gr.iconPositions,
                  showCollisionBoxes: this.showCollisionBoxes,
                  canonical: this.tileID.canonical,
                  subdivisionGranularity: Ze.subdivisionGranularity
                })) : Er.hasPattern && (Er instanceof T.cI || Er instanceof T.cJ || Er instanceof T.cK) && (ae(Er.layers, this.zoom, $), Er.addFeatures(Ze, this.tileID.canonical, Gr.patternPositions))
              }
              return this.status = "done", {
                buckets: Object.values(Te).filter((mr => !mr.isEmpty())),
                featureIndex: Ee,
                collisionBoxArray: this.collisionBoxArray,
                glyphAtlasImage: qr.image,
                imageAtlas: Gr,
                glyphMap: this.returnDependencies ? bt : null,
                iconMap: this.returnDependencies ? ar : null,
                glyphPositions: this.returnDependencies ? qr.positions : null
              }
            }))
          }
        }

        function ae(ce, F, q) {
          const $ = new T.F(F);
          for (const X of ce) X.recalculate($, q)
        }
        class _e {
          constructor(F, q, $) {
            this.actor = F, this.layerIndex = q, this.availableImages = $, this.fetching = {}, this.loading = {}, this.loaded = {}
          }
          loadVectorTile(F, q) {
            return T._(this, void 0, void 0, (function*() {
              const $ = yield T.n(F.request, q);
              try {
                return {
                  vectorTile: new T.cL(new T.cM($.data)),
                  rawData: $.data,
                  cacheControl: $.cacheControl,
                  expires: $.expires
                }
              } catch (X) {
                const oe = new Uint8Array($.data);
                let me = `Unable to parse the tile at ${F.request.url}, `;
                throw me += oe[0] === 31 && oe[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${X.message}`, new Error(me)
              }
            }))
          }
          loadTile(F) {
            return T._(this, void 0, void 0, (function*() {
              const q = F.uid,
                $ = !!(F && F.request && F.request.collectResourceTiming) && new T.cN(F.request),
                X = new W(F);
              this.loading[q] = X;
              const oe = new AbortController;
              X.abort = oe;
              try {
                const me = yield this.loadVectorTile(F, oe);
                if (delete this.loading[q], !me) return null;
                const Ee = me.rawData,
                  Te = {};
                me.expires && (Te.expires = me.expires), me.cacheControl && (Te.cacheControl = me.cacheControl);
                const Ze = {};
                if ($) {
                  const $e = $.finish();
                  $e && (Ze.resourceTiming = JSON.parse(JSON.stringify($e)))
                }
                X.vectorTile = me.vectorTile;
                const it = X.parse(me.vectorTile, this.layerIndex, this.availableImages, this.actor, F.subdivisionGranularity);
                this.loaded[q] = X, this.fetching[q] = {
                  rawTileData: Ee,
                  cacheControl: Te,
                  resourceTiming: Ze
                };
                try {
                  const $e = yield it;
                  return T.e({
                    rawTileData: Ee.slice(0)
                  }, $e, Te, Ze)
                } finally {
                  delete this.fetching[q]
                }
              } catch (me) {
                throw delete this.loading[q], X.status = "done", this.loaded[q] = X, me
              }
            }))
          }
          reloadTile(F) {
            return T._(this, void 0, void 0, (function*() {
              const q = F.uid;
              if (!this.loaded || !this.loaded[q]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const $ = this.loaded[q];
              if ($.showCollisionBoxes = F.showCollisionBoxes, $.globalState = F.globalState, $.status === "parsing") {
                const X = yield $.parse($.vectorTile, this.layerIndex, this.availableImages, this.actor, F.subdivisionGranularity);
                let oe;
                if (this.fetching[q]) {
                  const {
                    rawTileData: me,
                    cacheControl: Ee,
                    resourceTiming: Te
                  } = this.fetching[q];
                  delete this.fetching[q], oe = T.e({
                    rawTileData: me.slice(0)
                  }, X, Ee, Te)
                } else oe = X;
                return oe
              }
              if ($.status === "done" && $.vectorTile) return $.parse($.vectorTile, this.layerIndex, this.availableImages, this.actor, F.subdivisionGranularity)
            }))
          }
          abortTile(F) {
            return T._(this, void 0, void 0, (function*() {
              const q = this.loading,
                $ = F.uid;
              q && q[$] && q[$].abort && (q[$].abort.abort(), delete q[$])
            }))
          }
          removeTile(F) {
            return T._(this, void 0, void 0, (function*() {
              this.loaded && this.loaded[F.uid] && delete this.loaded[F.uid]
            }))
          }
        }
        class xe {
          constructor() {
            this.loaded = {}
          }
          loadTile(F) {
            return T._(this, void 0, void 0, (function*() {
              const {
                uid: q,
                encoding: $,
                rawImageData: X,
                redFactor: oe,
                greenFactor: me,
                blueFactor: Ee,
                baseShift: Te
              } = F, Ze = X.width + 2, it = X.height + 2, $e = T.b(X) ? new T.R({
                width: Ze,
                height: it
              }, yield T.cO(X, -1, -1, Ze, it)) : X, kt = new T.cP(q, $e, $, oe, me, Ee, Te);
              return this.loaded = this.loaded || {}, this.loaded[q] = kt, kt
            }))
          }
          removeTile(F) {
            const q = this.loaded,
              $ = F.uid;
            q && q[$] && delete q[$]
          }
        }
        var K, Ie, Ce = (function() {
            if (Ie) return K;

            function ce(q, $) {
              if (q.length !== 0) {
                F(q[0], $);
                for (var X = 1; X < q.length; X++) F(q[X], !$)
              }
            }

            function F(q, $) {
              for (var X = 0, oe = 0, me = 0, Ee = q.length, Te = Ee - 1; me < Ee; Te = me++) {
                var Ze = (q[me][0] - q[Te][0]) * (q[Te][1] + q[me][1]),
                  it = X + Ze;
                oe += Math.abs(X) >= Math.abs(Ze) ? X - it + Ze : Ze - it + X, X = it
              }
              X + oe >= 0 != !!$ && q.reverse()
            }
            return Ie = 1, K = function q($, X) {
              var oe, me = $ && $.type;
              if (me === "FeatureCollection")
                for (oe = 0; oe < $.features.length; oe++) q($.features[oe], X);
              else if (me === "GeometryCollection")
                for (oe = 0; oe < $.geometries.length; oe++) q($.geometries[oe], X);
              else if (me === "Feature") q($.geometry, X);
              else if (me === "Polygon") ce($.coordinates, X);
              else if (me === "MultiPolygon")
                for (oe = 0; oe < $.coordinates.length; oe++) ce($.coordinates[oe], X);
              return $
            }
          })(),
          De = T.cQ(Ce);
        class Be extends T.cS {
          constructor(F, q) {
            super(new T.cM, 0, q, [], []), this.feature = F, this.type = F.type, this.properties = F.tags ? F.tags : {}, "id" in F && (typeof F.id == "string" ? this.id = parseInt(F.id, 10) : typeof F.id != "number" || isNaN(F.id) || (this.id = F.id))
          }
          loadGeometry() {
            const F = [],
              q = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const $ of q) {
              const X = [];
              for (const oe of $) X.push(new T.P(oe[0], oe[1]));
              F.push(X)
            }
            return F
          }
        }
        class je extends T.cR {
          constructor(F, q) {
            super(new T.cM), this.layers = {
              _geojsonTileLayer: this
            }, this.name = "_geojsonTileLayer", this.version = q ? q.version : 1, this.extent = q ? q.extent : 4096, this.length = F.length, this.features = F
          }
          feature(F) {
            return new Be(this.features[F], this.extent)
          }
        }

        function Le(ce, F) {
          F.writeVarintField(15, ce.version || 1), F.writeStringField(1, ce.name || ""), F.writeVarintField(5, ce.extent || 4096);
          const q = {
            keys: [],
            values: [],
            keycache: {},
            valuecache: {}
          };
          for (let oe = 0; oe < ce.length; oe++) q.feature = ce.feature(oe), F.writeMessage(2, Fe, q);
          const $ = q.keys;
          for (const oe of $) F.writeStringField(3, oe);
          const X = q.values;
          for (const oe of X) F.writeMessage(4, tt, oe)
        }

        function Fe(ce, F) {
          if (!ce.feature) return;
          const q = ce.feature;
          q.id !== void 0 && F.writeVarintField(1, q.id), F.writeMessage(2, mt, ce), F.writeVarintField(3, q.type), F.writeMessage(4, ct, q)
        }

        function mt(ce, F) {
          var q;
          for (const $ in (q = ce.feature) == null ? void 0 : q.properties) {
            let X = ce.feature.properties[$],
              oe = ce.keycache[$];
            if (X === null) continue;
            oe === void 0 && (ce.keys.push($), oe = ce.keys.length - 1, ce.keycache[$] = oe), F.writeVarint(oe), typeof X != "string" && typeof X != "boolean" && typeof X != "number" && (X = JSON.stringify(X));
            const me = typeof X + ":" + X;
            let Ee = ce.valuecache[me];
            Ee === void 0 && (ce.values.push(X), Ee = ce.values.length - 1, ce.valuecache[me] = Ee), F.writeVarint(Ee)
          }
        }

        function ut(ce, F) {
          return (F << 3) + (7 & ce)
        }

        function Ke(ce) {
          return ce << 1 ^ ce >> 31
        }

        function ct(ce, F) {
          const q = ce.loadGeometry(),
            $ = ce.type;
          let X = 0,
            oe = 0;
          for (const me of q) {
            let Ee = 1;
            $ === 1 && (Ee = me.length), F.writeVarint(ut(1, Ee));
            const Te = $ === 3 ? me.length - 1 : me.length;
            for (let Ze = 0; Ze < Te; Ze++) {
              Ze === 1 && $ !== 1 && F.writeVarint(ut(2, Te - 1));
              const it = me[Ze].x - X,
                $e = me[Ze].y - oe;
              F.writeVarint(Ke(it)), F.writeVarint(Ke($e)), X += it, oe += $e
            }
            ce.type === 3 && F.writeVarint(ut(7, 1))
          }
        }

        function tt(ce, F) {
          const q = typeof ce;
          q === "string" ? F.writeStringField(1, ce) : q === "boolean" ? F.writeBooleanField(7, ce) : q === "number" && (ce % 1 != 0 ? F.writeDoubleField(3, ce) : ce < 0 ? F.writeSVarintField(6, ce) : F.writeVarintField(5, ce))
        }
        const Re = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: ce => ce
          },
          ot = Math.fround || (rt = new Float32Array(1), ce => (rt[0] = +ce, rt[0]));
        var rt;
        class Qe {
          constructor(F) {
            this.options = Object.assign(Object.create(Re), F), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []
          }
          load(F) {
            const {
              log: q,
              minZoom: $,
              maxZoom: X
            } = this.options;
            q && console.time("total time");
            const oe = `prepare ${F.length} points`;
            q && console.time(oe), this.points = F;
            const me = [];
            for (let Te = 0; Te < F.length; Te++) {
              const Ze = F[Te];
              if (!Ze.geometry) continue;
              const [it, $e] = Ze.geometry.coordinates, kt = ot(ee(it)), ye = ot(te($e));
              me.push(kt, ye, 1 / 0, Te, -1, 1), this.options.reduce && me.push(0)
            }
            let Ee = this.trees[X + 1] = this._createTree(me);
            q && console.timeEnd(oe);
            for (let Te = X; Te >= $; Te--) {
              const Ze = +Date.now();
              Ee = this.trees[Te] = this._createTree(this._cluster(Ee, Te)), q && console.log("z%d: %d clusters in %dms", Te, Ee.numItems, +Date.now() - Ze)
            }
            return q && console.timeEnd("total time"), this
          }
          getClusters(F, q) {
            let $ = ((F[0] + 180) % 360 + 360) % 360 - 180;
            const X = Math.max(-90, Math.min(90, F[1]));
            let oe = F[2] === 180 ? 180 : ((F[2] + 180) % 360 + 360) % 360 - 180;
            const me = Math.max(-90, Math.min(90, F[3]));
            if (F[2] - F[0] >= 360) $ = -180, oe = 180;
            else if ($ > oe) {
              const $e = this.getClusters([$, X, 180, me], q),
                kt = this.getClusters([-180, X, oe, me], q);
              return $e.concat(kt)
            }
            const Ee = this.trees[this._limitZoom(q)],
              Te = Ee.range(ee($), te(me), ee(oe), te(X)),
              Ze = Ee.data,
              it = [];
            for (const $e of Te) {
              const kt = this.stride * $e;
              it.push(Ze[kt + 5] > 1 ? Ae(Ze, kt, this.clusterProps) : this.points[Ze[kt + 3]])
            }
            return it
          }
          getChildren(F) {
            const q = this._getOriginId(F),
              $ = this._getOriginZoom(F),
              X = "No cluster with the specified id.",
              oe = this.trees[$];
            if (!oe) throw new Error(X);
            const me = oe.data;
            if (q * this.stride >= me.length) throw new Error(X);
            const Ee = this.options.radius / (this.options.extent * Math.pow(2, $ - 1)),
              Te = oe.within(me[q * this.stride], me[q * this.stride + 1], Ee),
              Ze = [];
            for (const it of Te) {
              const $e = it * this.stride;
              me[$e + 4] === F && Ze.push(me[$e + 5] > 1 ? Ae(me, $e, this.clusterProps) : this.points[me[$e + 3]])
            }
            if (Ze.length === 0) throw new Error(X);
            return Ze
          }
          getLeaves(F, q, $) {
            const X = [];
            return this._appendLeaves(X, F, q = q || 10, $ = $ || 0, 0), X
          }
          getTile(F, q, $) {
            const X = this.trees[this._limitZoom(F)],
              oe = Math.pow(2, F),
              {
                extent: me,
                radius: Ee
              } = this.options,
              Te = Ee / me,
              Ze = ($ - Te) / oe,
              it = ($ + 1 + Te) / oe,
              $e = {
                features: []
              };
            return this._addTileFeatures(X.range((q - Te) / oe, Ze, (q + 1 + Te) / oe, it), X.data, q, $, oe, $e), q === 0 && this._addTileFeatures(X.range(1 - Te / oe, Ze, 1, it), X.data, oe, $, oe, $e), q === oe - 1 && this._addTileFeatures(X.range(0, Ze, Te / oe, it), X.data, -1, $, oe, $e), $e.features.length ? $e : null
          }
          getClusterExpansionZoom(F) {
            let q = this._getOriginZoom(F) - 1;
            for (; q <= this.options.maxZoom;) {
              const $ = this.getChildren(F);
              if (q++, $.length !== 1) break;
              F = $[0].properties.cluster_id
            }
            return q
          }
          _appendLeaves(F, q, $, X, oe) {
            const me = this.getChildren(q);
            for (const Ee of me) {
              const Te = Ee.properties;
              if (Te && Te.cluster ? oe + Te.point_count <= X ? oe += Te.point_count : oe = this._appendLeaves(F, Te.cluster_id, $, X, oe) : oe < X ? oe++ : F.push(Ee), F.length === $) break
            }
            return oe
          }
          _createTree(F) {
            const q = new T.aI(F.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let $ = 0; $ < F.length; $ += this.stride) q.add(F[$], F[$ + 1]);
            return q.finish(), q.data = F, q
          }
          _addTileFeatures(F, q, $, X, oe, me) {
            for (const Ee of F) {
              const Te = Ee * this.stride,
                Ze = q[Te + 5] > 1;
              let it, $e, kt;
              if (Ze) it = gt(q, Te, this.clusterProps), $e = q[Te], kt = q[Te + 1];
              else {
                const Ht = this.points[q[Te + 3]];
                it = Ht.properties;
                const [pt, bt] = Ht.geometry.coordinates;
                $e = ee(pt), kt = te(bt)
              }
              const ye = {
                type: 1,
                geometry: [
                  [Math.round(this.options.extent * ($e * oe - $)), Math.round(this.options.extent * (kt * oe - X))]
                ],
                tags: it
              };
              let Xt;
              Xt = Ze || this.options.generateId ? q[Te + 3] : this.points[q[Te + 3]].id, Xt !== void 0 && (ye.id = Xt), me.features.push(ye)
            }
          }
          _limitZoom(F) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+F), this.options.maxZoom + 1))
          }
          _cluster(F, q) {
            const {
              radius: $,
              extent: X,
              reduce: oe,
              minPoints: me
            } = this.options, Ee = $ / (X * Math.pow(2, q)), Te = F.data, Ze = [], it = this.stride;
            for (let $e = 0; $e < Te.length; $e += it) {
              if (Te[$e + 2] <= q) continue;
              Te[$e + 2] = q;
              const kt = Te[$e],
                ye = Te[$e + 1],
                Xt = F.within(Te[$e], Te[$e + 1], Ee),
                Ht = Te[$e + 5];
              let pt = Ht;
              for (const bt of Xt) {
                const ar = bt * it;
                Te[ar + 2] > q && (pt += Te[ar + 5])
              }
              if (pt > Ht && pt >= me) {
                let bt, ar = kt * Ht,
                  jr = ye * Ht,
                  qr = -1;
                const Gr = ($e / it << 5) + (q + 1) + this.points.length;
                for (const mr of Xt) {
                  const Er = mr * it;
                  if (Te[Er + 2] <= q) continue;
                  Te[Er + 2] = q;
                  const ai = Te[Er + 5];
                  ar += Te[Er] * ai, jr += Te[Er + 1] * ai, Te[Er + 4] = Gr, oe && (bt || (bt = this._map(Te, $e, !0), qr = this.clusterProps.length, this.clusterProps.push(bt)), oe(bt, this._map(Te, Er)))
                }
                Te[$e + 4] = Gr, Ze.push(ar / pt, jr / pt, 1 / 0, Gr, -1, pt), oe && Ze.push(qr)
              } else {
                for (let bt = 0; bt < it; bt++) Ze.push(Te[$e + bt]);
                if (pt > 1)
                  for (const bt of Xt) {
                    const ar = bt * it;
                    if (!(Te[ar + 2] <= q)) {
                      Te[ar + 2] = q;
                      for (let jr = 0; jr < it; jr++) Ze.push(Te[ar + jr])
                    }
                  }
              }
            }
            return Ze
          }
          _getOriginId(F) {
            return F - this.points.length >> 5
          }
          _getOriginZoom(F) {
            return (F - this.points.length) % 32
          }
          _map(F, q, $) {
            if (F[q + 5] > 1) {
              const me = this.clusterProps[F[q + 6]];
              return $ ? Object.assign({}, me) : me
            }
            const X = this.points[F[q + 3]].properties,
              oe = this.options.map(X);
            return $ && oe === X ? Object.assign({}, oe) : oe
          }
        }

        function Ae(ce, F, q) {
          return {
            type: "Feature",
            id: ce[F + 3],
            properties: gt(ce, F, q),
            geometry: {
              type: "Point",
              coordinates: [($ = ce[F], 360 * ($ - .5)), fe(ce[F + 1])]
            }
          };
          var $
        }

        function gt(ce, F, q) {
          const $ = ce[F + 5],
            X = $ >= 1e4 ? `${Math.round($/1e3)}k` : $ >= 1e3 ? Math.round($ / 100) / 10 + "k" : $,
            oe = ce[F + 6],
            me = oe === -1 ? {} : Object.assign({}, q[oe]);
          return Object.assign(me, {
            cluster: !0,
            cluster_id: ce[F + 3],
            point_count: $,
            point_count_abbreviated: X
          })
        }

        function ee(ce) {
          return ce / 360 + .5
        }

        function te(ce) {
          const F = Math.sin(ce * Math.PI / 180),
            q = .5 - .25 * Math.log((1 + F) / (1 - F)) / Math.PI;
          return q < 0 ? 0 : q > 1 ? 1 : q
        }

        function fe(ce) {
          const F = (180 - 360 * ce) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(F)) / Math.PI - 90
        }

        function ie(ce, F, q, $) {
          let X = $;
          const oe = F + (q - F >> 1);
          let me, Ee = q - F;
          const Te = ce[F],
            Ze = ce[F + 1],
            it = ce[q],
            $e = ce[q + 1];
          for (let kt = F + 3; kt < q; kt += 3) {
            const ye = Se(ce[kt], ce[kt + 1], Te, Ze, it, $e);
            if (ye > X) me = kt, X = ye;
            else if (ye === X) {
              const Xt = Math.abs(kt - oe);
              Xt < Ee && (me = kt, Ee = Xt)
            }
          }
          X > $ && (me - F > 3 && ie(ce, F, me, $), ce[me + 2] = X, q - me > 3 && ie(ce, me, q, $))
        }

        function Se(ce, F, q, $, X, oe) {
          let me = X - q,
            Ee = oe - $;
          if (me !== 0 || Ee !== 0) {
            const Te = ((ce - q) * me + (F - $) * Ee) / (me * me + Ee * Ee);
            Te > 1 ? (q = X, $ = oe) : Te > 0 && (q += me * Te, $ += Ee * Te)
          }
          return me = ce - q, Ee = F - $, me * me + Ee * Ee
        }

        function Me(ce, F, q, $) {
          const X = {
            id: ce ?? null,
            type: F,
            geometry: q,
            tags: $,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
          };
          if (F === "Point" || F === "MultiPoint" || F === "LineString") nt(X, q);
          else if (F === "Polygon") nt(X, q[0]);
          else if (F === "MultiLineString")
            for (const oe of q) nt(X, oe);
          else if (F === "MultiPolygon")
            for (const oe of q) nt(X, oe[0]);
          return X
        }

        function nt(ce, F) {
          for (let q = 0; q < F.length; q += 3) ce.minX = Math.min(ce.minX, F[q]), ce.minY = Math.min(ce.minY, F[q + 1]), ce.maxX = Math.max(ce.maxX, F[q]), ce.maxY = Math.max(ce.maxY, F[q + 1])
        }

        function Ye(ce, F, q, $) {
          if (!F.geometry) return;
          const X = F.geometry.coordinates;
          if (X && X.length === 0) return;
          const oe = F.geometry.type,
            me = Math.pow(q.tolerance / ((1 << q.maxZoom) * q.extent), 2);
          let Ee = [],
            Te = F.id;
          if (q.promoteId ? Te = F.properties[q.promoteId] : q.generateId && (Te = $ || 0), oe === "Point") wt(X, Ee);
          else if (oe === "MultiPoint")
            for (const Ze of X) wt(Ze, Ee);
          else if (oe === "LineString") zt(X, Ee, me, !1);
          else if (oe === "MultiLineString") {
            if (q.lineMetrics) {
              for (const Ze of X) Ee = [], zt(Ze, Ee, me, !1), ce.push(Me(Te, "LineString", Ee, F.properties));
              return
            }
            Nt(X, Ee, me, !1)
          } else if (oe === "Polygon") Nt(X, Ee, me, !0);
          else {
            if (oe !== "MultiPolygon") {
              if (oe === "GeometryCollection") {
                for (const Ze of F.geometry.geometries) Ye(ce, {
                  id: Te,
                  geometry: Ze,
                  properties: F.properties
                }, q, $);
                return
              }
              throw new Error("Input data is not a valid GeoJSON object.")
            }
            for (const Ze of X) {
              const it = [];
              Nt(Ze, it, me, !0), Ee.push(it)
            }
          }
          ce.push(Me(Te, oe, Ee, F.properties))
        }

        function wt(ce, F) {
          F.push(st(ce[0]), Tt(ce[1]), 0)
        }

        function zt(ce, F, q, $) {
          let X, oe, me = 0;
          for (let Te = 0; Te < ce.length; Te++) {
            const Ze = st(ce[Te][0]),
              it = Tt(ce[Te][1]);
            F.push(Ze, it, 0), Te > 0 && (me += $ ? (X * it - Ze * oe) / 2 : Math.sqrt(Math.pow(Ze - X, 2) + Math.pow(it - oe, 2))), X = Ze, oe = it
          }
          const Ee = F.length - 3;
          F[2] = 1, ie(F, 0, Ee, q), F[Ee + 2] = 1, F.size = Math.abs(me), F.start = 0, F.end = F.size
        }

        function Nt(ce, F, q, $) {
          for (let X = 0; X < ce.length; X++) {
            const oe = [];
            zt(ce[X], oe, q, $), F.push(oe)
          }
        }

        function st(ce) {
          return ce / 360 + .5
        }

        function Tt(ce) {
          const F = Math.sin(ce * Math.PI / 180),
            q = .5 - .25 * Math.log((1 + F) / (1 - F)) / Math.PI;
          return q < 0 ? 0 : q > 1 ? 1 : q
        }

        function Ct(ce, F, q, $, X, oe, me, Ee) {
          if ($ /= F, oe >= (q /= F) && me < $) return ce;
          if (me < q || oe >= $) return null;
          const Te = [];
          for (const Ze of ce) {
            const it = Ze.geometry;
            let $e = Ze.type;
            const kt = X === 0 ? Ze.minX : Ze.minY,
              ye = X === 0 ? Ze.maxX : Ze.maxY;
            if (kt >= q && ye < $) {
              Te.push(Ze);
              continue
            }
            if (ye < q || kt >= $) continue;
            let Xt = [];
            if ($e === "Point" || $e === "MultiPoint") yt(it, Xt, q, $, X);
            else if ($e === "LineString") Mt(it, Xt, q, $, X, !1, Ee.lineMetrics);
            else if ($e === "MultiLineString") ht(it, Xt, q, $, X, !1);
            else if ($e === "Polygon") ht(it, Xt, q, $, X, !0);
            else if ($e === "MultiPolygon")
              for (const Ht of it) {
                const pt = [];
                ht(Ht, pt, q, $, X, !0), pt.length && Xt.push(pt)
              }
            if (Xt.length) {
              if (Ee.lineMetrics && $e === "LineString") {
                for (const Ht of Xt) Te.push(Me(Ze.id, $e, Ht, Ze.tags));
                continue
              }
              $e !== "LineString" && $e !== "MultiLineString" || (Xt.length === 1 ? ($e = "LineString", Xt = Xt[0]) : $e = "MultiLineString"), $e !== "Point" && $e !== "MultiPoint" || ($e = Xt.length === 3 ? "Point" : "MultiPoint"), Te.push(Me(Ze.id, $e, Xt, Ze.tags))
            }
          }
          return Te.length ? Te : null
        }

        function yt(ce, F, q, $, X) {
          for (let oe = 0; oe < ce.length; oe += 3) {
            const me = ce[oe + X];
            me >= q && me <= $ && Lt(F, ce[oe], ce[oe + 1], ce[oe + 2])
          }
        }

        function Mt(ce, F, q, $, X, oe, me) {
          let Ee = St(ce);
          const Te = X === 0 ? tr : Jt;
          let Ze, it, $e = ce.start;
          for (let pt = 0; pt < ce.length - 3; pt += 3) {
            const bt = ce[pt],
              ar = ce[pt + 1],
              jr = ce[pt + 2],
              qr = ce[pt + 3],
              Gr = ce[pt + 4],
              mr = X === 0 ? bt : ar,
              Er = X === 0 ? qr : Gr;
            let ai = !1;
            me && (Ze = Math.sqrt(Math.pow(bt - qr, 2) + Math.pow(ar - Gr, 2))), mr < q ? Er > q && (it = Te(Ee, bt, ar, qr, Gr, q), me && (Ee.start = $e + Ze * it)) : mr > $ ? Er < $ && (it = Te(Ee, bt, ar, qr, Gr, $), me && (Ee.start = $e + Ze * it)) : Lt(Ee, bt, ar, jr), Er < q && mr >= q && (it = Te(Ee, bt, ar, qr, Gr, q), ai = !0), Er > $ && mr <= $ && (it = Te(Ee, bt, ar, qr, Gr, $), ai = !0), !oe && ai && (me && (Ee.end = $e + Ze * it), F.push(Ee), Ee = St(ce)), me && ($e += Ze)
          }
          let kt = ce.length - 3;
          const ye = ce[kt],
            Xt = ce[kt + 1],
            Ht = X === 0 ? ye : Xt;
          Ht >= q && Ht <= $ && Lt(Ee, ye, Xt, ce[kt + 2]), kt = Ee.length - 3, oe && kt >= 3 && (Ee[kt] !== Ee[0] || Ee[kt + 1] !== Ee[1]) && Lt(Ee, Ee[0], Ee[1], Ee[2]), Ee.length && F.push(Ee)
        }

        function St(ce) {
          const F = [];
          return F.size = ce.size, F.start = ce.start, F.end = ce.end, F
        }

        function ht(ce, F, q, $, X, oe) {
          for (const me of ce) Mt(me, F, q, $, X, oe, !1)
        }

        function Lt(ce, F, q, $) {
          ce.push(F, q, $)
        }

        function tr(ce, F, q, $, X, oe) {
          const me = (oe - F) / ($ - F);
          return Lt(ce, oe, q + (X - q) * me, 1), me
        }

        function Jt(ce, F, q, $, X, oe) {
          const me = (oe - q) / (X - q);
          return Lt(ce, F + ($ - F) * me, oe, 1), me
        }

        function dr(ce, F) {
          const q = [];
          for (let $ = 0; $ < ce.length; $++) {
            const X = ce[$],
              oe = X.type;
            let me;
            if (oe === "Point" || oe === "MultiPoint" || oe === "LineString") me = nr(X.geometry, F);
            else if (oe === "MultiLineString" || oe === "Polygon") {
              me = [];
              for (const Ee of X.geometry) me.push(nr(Ee, F))
            } else if (oe === "MultiPolygon") {
              me = [];
              for (const Ee of X.geometry) {
                const Te = [];
                for (const Ze of Ee) Te.push(nr(Ze, F));
                me.push(Te)
              }
            }
            q.push(Me(X.id, oe, me, X.tags))
          }
          return q
        }

        function nr(ce, F) {
          const q = [];
          q.size = ce.size, ce.start !== void 0 && (q.start = ce.start, q.end = ce.end);
          for (let $ = 0; $ < ce.length; $ += 3) q.push(ce[$] + F, ce[$ + 1], ce[$ + 2]);
          return q
        }

        function Bt(ce, F) {
          if (ce.transformed) return ce;
          const q = 1 << ce.z,
            $ = ce.x,
            X = ce.y;
          for (const oe of ce.features) {
            const me = oe.geometry,
              Ee = oe.type;
            if (oe.geometry = [], Ee === 1)
              for (let Te = 0; Te < me.length; Te += 2) oe.geometry.push(pr(me[Te], me[Te + 1], F, q, $, X));
            else
              for (let Te = 0; Te < me.length; Te++) {
                const Ze = [];
                for (let it = 0; it < me[Te].length; it += 2) Ze.push(pr(me[Te][it], me[Te][it + 1], F, q, $, X));
                oe.geometry.push(Ze)
              }
          }
          return ce.transformed = !0, ce
        }

        function pr(ce, F, q, $, X, oe) {
          return [Math.round(q * (ce * $ - X)), Math.round(q * (F * $ - oe))]
        }

        function gr(ce, F, q, $, X) {
          const oe = F === X.maxZoom ? 0 : X.tolerance / ((1 << F) * X.extent),
            me = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: ce.length,
              source: null,
              x: q,
              y: $,
              z: F,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0
            };
          for (const Ee of ce) Sr(me, Ee, oe, X);
          return me
        }

        function Sr(ce, F, q, $) {
          const X = F.geometry,
            oe = F.type,
            me = [];
          if (ce.minX = Math.min(ce.minX, F.minX), ce.minY = Math.min(ce.minY, F.minY), ce.maxX = Math.max(ce.maxX, F.maxX), ce.maxY = Math.max(ce.maxY, F.maxY), oe === "Point" || oe === "MultiPoint")
            for (let Ee = 0; Ee < X.length; Ee += 3) me.push(X[Ee], X[Ee + 1]), ce.numPoints++, ce.numSimplified++;
          else if (oe === "LineString") Vr(me, X, ce, q, !1, !1);
          else if (oe === "MultiLineString" || oe === "Polygon")
            for (let Ee = 0; Ee < X.length; Ee++) Vr(me, X[Ee], ce, q, oe === "Polygon", Ee === 0);
          else if (oe === "MultiPolygon")
            for (let Ee = 0; Ee < X.length; Ee++) {
              const Te = X[Ee];
              for (let Ze = 0; Ze < Te.length; Ze++) Vr(me, Te[Ze], ce, q, !0, Ze === 0)
            }
          if (me.length) {
            let Ee = F.tags || null;
            if (oe === "LineString" && $.lineMetrics) {
              Ee = {};
              for (const Ze in F.tags) Ee[Ze] = F.tags[Ze];
              Ee.mapbox_clip_start = X.start / X.size, Ee.mapbox_clip_end = X.end / X.size
            }
            const Te = {
              geometry: me,
              type: oe === "Polygon" || oe === "MultiPolygon" ? 3 : oe === "LineString" || oe === "MultiLineString" ? 2 : 1,
              tags: Ee
            };
            F.id !== null && (Te.id = F.id), ce.features.push(Te)
          }
        }

        function Vr(ce, F, q, $, X, oe) {
          const me = $ * $;
          if ($ > 0 && F.size < (X ? me : $)) return void(q.numPoints += F.length / 3);
          const Ee = [];
          for (let Te = 0; Te < F.length; Te += 3)($ === 0 || F[Te + 2] > me) && (q.numSimplified++, Ee.push(F[Te], F[Te + 1])), q.numPoints++;
          X && (function(Te, Ze) {
            let it = 0;
            for (let $e = 0, kt = Te.length, ye = kt - 2; $e < kt; ye = $e, $e += 2) it += (Te[$e] - Te[ye]) * (Te[$e + 1] + Te[ye + 1]);
            if (it > 0 === Ze)
              for (let $e = 0, kt = Te.length; $e < kt / 2; $e += 2) {
                const ye = Te[$e],
                  Xt = Te[$e + 1];
                Te[$e] = Te[kt - 2 - $e], Te[$e + 1] = Te[kt - 1 - $e], Te[kt - 2 - $e] = ye, Te[kt - 1 - $e] = Xt
              }
          })(Ee, oe), ce.push(Ee)
        }
        const ur = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0
        };
        class Pr {
          constructor(F, q) {
            const $ = (q = this.options = (function(oe, me) {
              for (const Ee in me) oe[Ee] = me[Ee];
              return oe
            })(Object.create(ur), q)).debug;
            if ($ && console.time("preprocess data"), q.maxZoom < 0 || q.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (q.promoteId && q.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let X = (function(oe, me) {
              const Ee = [];
              if (oe.type === "FeatureCollection")
                for (let Te = 0; Te < oe.features.length; Te++) Ye(Ee, oe.features[Te], me, Te);
              else Ye(Ee, oe.type === "Feature" ? oe : {
                geometry: oe
              }, me);
              return Ee
            })(F, q);
            this.tiles = {}, this.tileCoords = [], $ && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", q.indexMaxZoom, q.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), X = (function(oe, me) {
              const Ee = me.buffer / me.extent;
              let Te = oe;
              const Ze = Ct(oe, 1, -1 - Ee, Ee, 0, -1, 2, me),
                it = Ct(oe, 1, 1 - Ee, 2 + Ee, 0, -1, 2, me);
              return (Ze || it) && (Te = Ct(oe, 1, -Ee, 1 + Ee, 0, -1, 2, me) || [], Ze && (Te = dr(Ze, 1).concat(Te)), it && (Te = Te.concat(dr(it, -1)))), Te
            })(X, q), X.length && this.splitTile(X, 0, 0, 0), $ && (X.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
          }
          splitTile(F, q, $, X, oe, me, Ee) {
            const Te = [F, q, $, X],
              Ze = this.options,
              it = Ze.debug;
            for (; Te.length;) {
              X = Te.pop(), $ = Te.pop(), q = Te.pop(), F = Te.pop();
              const $e = 1 << q,
                kt = Ir(q, $, X);
              let ye = this.tiles[kt];
              if (!ye && (it > 1 && console.time("creation"), ye = this.tiles[kt] = gr(F, q, $, X, Ze), this.tileCoords.push({
                  z: q,
                  x: $,
                  y: X
                }), it)) {
                it > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", q, $, X, ye.numFeatures, ye.numPoints, ye.numSimplified), console.timeEnd("creation"));
                const ai = `z${q}`;
                this.stats[ai] = (this.stats[ai] || 0) + 1, this.total++
              }
              if (ye.source = F, oe == null) {
                if (q === Ze.indexMaxZoom || ye.numPoints <= Ze.indexMaxPoints) continue
              } else {
                if (q === Ze.maxZoom || q === oe) continue;
                if (oe != null) {
                  const ai = oe - q;
                  if ($ !== me >> ai || X !== Ee >> ai) continue
                }
              }
              if (ye.source = null, F.length === 0) continue;
              it > 1 && console.time("clipping");
              const Xt = .5 * Ze.buffer / Ze.extent,
                Ht = .5 - Xt,
                pt = .5 + Xt,
                bt = 1 + Xt;
              let ar = null,
                jr = null,
                qr = null,
                Gr = null,
                mr = Ct(F, $e, $ - Xt, $ + pt, 0, ye.minX, ye.maxX, Ze),
                Er = Ct(F, $e, $ + Ht, $ + bt, 0, ye.minX, ye.maxX, Ze);
              F = null, mr && (ar = Ct(mr, $e, X - Xt, X + pt, 1, ye.minY, ye.maxY, Ze), jr = Ct(mr, $e, X + Ht, X + bt, 1, ye.minY, ye.maxY, Ze), mr = null), Er && (qr = Ct(Er, $e, X - Xt, X + pt, 1, ye.minY, ye.maxY, Ze), Gr = Ct(Er, $e, X + Ht, X + bt, 1, ye.minY, ye.maxY, Ze), Er = null), it > 1 && console.timeEnd("clipping"), Te.push(ar || [], q + 1, 2 * $, 2 * X), Te.push(jr || [], q + 1, 2 * $, 2 * X + 1), Te.push(qr || [], q + 1, 2 * $ + 1, 2 * X), Te.push(Gr || [], q + 1, 2 * $ + 1, 2 * X + 1)
            }
          }
          getTile(F, q, $) {
            F = +F, q = +q, $ = +$;
            const X = this.options,
              {
                extent: oe,
                debug: me
              } = X;
            if (F < 0 || F > 24) return null;
            const Ee = 1 << F,
              Te = Ir(F, q = q + Ee & Ee - 1, $);
            if (this.tiles[Te]) return Bt(this.tiles[Te], oe);
            me > 1 && console.log("drilling down to z%d-%d-%d", F, q, $);
            let Ze, it = F,
              $e = q,
              kt = $;
            for (; !Ze && it > 0;) it--, $e >>= 1, kt >>= 1, Ze = this.tiles[Ir(it, $e, kt)];
            return Ze && Ze.source ? (me > 1 && (console.log("found parent tile z%d-%d-%d", it, $e, kt), console.time("drilling down")), this.splitTile(Ze.source, it, $e, kt, F, q, $), me > 1 && console.timeEnd("drilling down"), this.tiles[Te] ? Bt(this.tiles[Te], oe) : null) : null
          }
        }

        function Ir(ce, F, q) {
          return 32 * ((1 << ce) * q + F) + ce
        }
        class Mr extends _e {
          constructor() {
            super(...arguments), this._dataUpdateable = new Map
          }
          loadVectorTile(F, q) {
            return T._(this, void 0, void 0, (function*() {
              const $ = F.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const X = this._geoJSONIndex.getTile($.z, $.x, $.y);
              if (!X) return null;
              const oe = new je(X.features, {
                version: 2,
                extent: T.$
              });
              let me = (function(Ee) {
                const Te = new T.cM;
                return (function(Ze, it) {
                  for (const $e in Ze.layers) it.writeMessage(3, Le, Ze.layers[$e])
                })(Ee, Te), Te.finish()
              })(oe);
              return me.byteOffset === 0 && me.byteLength === me.buffer.byteLength || (me = new Uint8Array(me)), {
                vectorTile: oe,
                rawData: me.buffer
              }
            }))
          }
          loadData(F) {
            return T._(this, void 0, void 0, (function*() {
              var q;
              (q = this._pendingRequest) === null || q === void 0 || q.abort();
              const $ = !!(F && F.request && F.request.collectResourceTiming) && new T.cN(F.request);
              this._pendingRequest = new AbortController;
              try {
                this._pendingData = this.loadAndProcessGeoJSON(F, this._pendingRequest);
                const X = yield this._pendingData;
                this._geoJSONIndex = F.cluster ? new Qe((function({
                  superclusterOptions: me,
                  clusterProperties: Ee
                }) {
                  if (!Ee || !me) return me;
                  const Te = {},
                    Ze = {},
                    it = {
                      accumulated: null,
                      zoom: 0
                    },
                    $e = {
                      properties: null
                    },
                    kt = Object.keys(Ee);
                  for (const ye of kt) {
                    const [Xt, Ht] = Ee[ye], pt = T.cT(Ht), bt = T.cT(typeof Xt == "string" ? [Xt, ["accumulated"],
                      ["get", ye]
                    ] : Xt);
                    Te[ye] = pt.value, Ze[ye] = bt.value
                  }
                  return me.map = ye => {
                    $e.properties = ye;
                    const Xt = {};
                    for (const Ht of kt) Xt[Ht] = Te[Ht].evaluate(it, $e);
                    return Xt
                  }, me.reduce = (ye, Xt) => {
                    $e.properties = Xt;
                    for (const Ht of kt) it.accumulated = ye[Ht], ye[Ht] = Ze[Ht].evaluate(it, $e)
                  }, me
                })(F)).load(X.features) : (function(me, Ee) {
                  return new Pr(me, Ee)
                })(X, F.geojsonVtOptions), this.loaded = {};
                const oe = {
                  data: X
                };
                if ($) {
                  const me = $.finish();
                  me && (oe.resourceTiming = {}, oe.resourceTiming[F.source] = JSON.parse(JSON.stringify(me)))
                }
                return oe
              } catch (X) {
                if (delete this._pendingRequest, T.cy(X)) return {
                  abandoned: !0
                };
                throw X
              }
            }))
          }
          getData() {
            return T._(this, void 0, void 0, (function*() {
              return this._pendingData
            }))
          }
          reloadTile(F) {
            const q = this.loaded;
            return q && q[F.uid] ? super.reloadTile(F) : this.loadTile(F)
          }
          loadAndProcessGeoJSON(F, q) {
            return T._(this, void 0, void 0, (function*() {
              let $ = yield this.loadGeoJSON(F, q);
              if (delete this._pendingRequest, typeof $ != "object") throw new Error(`Input data given to '${F.source}' is not a valid GeoJSON object.`);
              if (De($, !0), F.filter) {
                const X = T.cT(F.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1
                });
                if (X.result === "error") throw new Error(X.value.map((me => `${me.key}: ${me.message}`)).join(", "));
                $ = {
                  type: "FeatureCollection",
                  features: $.features.filter((me => X.value.evaluate({
                    zoom: 0
                  }, me)))
                }
              }
              return $
            }))
          }
          loadGeoJSON(F, q) {
            return T._(this, void 0, void 0, (function*() {
              const {
                promoteId: $
              } = F;
              if (F.request) {
                const X = yield T.j(F.request, q);
                return this._dataUpdateable = T.cV(X.data, $) ? T.cU(X.data, $) : void 0, X.data
              }
              if (typeof F.data == "string") try {
                const X = JSON.parse(F.data);
                return this._dataUpdateable = T.cV(X, $) ? T.cU(X, $) : void 0, X
              } catch {
                throw new Error(`Input data given to '${F.source}' is not a valid GeoJSON object.`)
              }
              if (!F.dataDiff) throw new Error(`Input data given to '${F.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${F.source}`);
              return T.cW(this._dataUpdateable, F.dataDiff, $), {
                type: "FeatureCollection",
                features: Array.from(this._dataUpdateable.values())
              }
            }))
          }
          removeSource(F) {
            return T._(this, void 0, void 0, (function*() {
              this._pendingRequest && this._pendingRequest.abort()
            }))
          }
          getClusterExpansionZoom(F) {
            return this._geoJSONIndex.getClusterExpansionZoom(F.clusterId)
          }
          getClusterChildren(F) {
            return this._geoJSONIndex.getChildren(F.clusterId)
          }
          getClusterLeaves(F) {
            return this._geoJSONIndex.getLeaves(F.clusterId, F.limit, F.offset)
          }
        }
        class Nr {
          constructor(F) {
            this.self = F, this.actor = new T.J(F), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (q, $) => {
              if (this.externalWorkerSourceTypes[q]) throw new Error(`Worker source with name "${q}" already registered.`);
              this.externalWorkerSourceTypes[q] = $
            }, this.self.addProtocol = T.cA, this.self.removeProtocol = T.cB, this.self.registerRTLTextPlugin = q => {
              T.cX.setMethods(q)
            }, this.actor.registerMessageHandler("LDT", ((q, $) => this._getDEMWorkerSource(q, $.source).loadTile($))), this.actor.registerMessageHandler("RDT", ((q, $) => T._(this, void 0, void 0, (function*() {
              this._getDEMWorkerSource(q, $.source).removeTile($)
            })))), this.actor.registerMessageHandler("GCEZ", ((q, $) => T._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(q, $.type, $.source).getClusterExpansionZoom($)
            })))), this.actor.registerMessageHandler("GCC", ((q, $) => T._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(q, $.type, $.source).getClusterChildren($)
            })))), this.actor.registerMessageHandler("GCL", ((q, $) => T._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(q, $.type, $.source).getClusterLeaves($)
            })))), this.actor.registerMessageHandler("LD", ((q, $) => this._getWorkerSource(q, $.type, $.source).loadData($))), this.actor.registerMessageHandler("GD", ((q, $) => this._getWorkerSource(q, $.type, $.source).getData())), this.actor.registerMessageHandler("LT", ((q, $) => this._getWorkerSource(q, $.type, $.source).loadTile($))), this.actor.registerMessageHandler("RT", ((q, $) => this._getWorkerSource(q, $.type, $.source).reloadTile($))), this.actor.registerMessageHandler("AT", ((q, $) => this._getWorkerSource(q, $.type, $.source).abortTile($))), this.actor.registerMessageHandler("RMT", ((q, $) => this._getWorkerSource(q, $.type, $.source).removeTile($))), this.actor.registerMessageHandler("RS", ((q, $) => T._(this, void 0, void 0, (function*() {
              if (!this.workerSources[q] || !this.workerSources[q][$.type] || !this.workerSources[q][$.type][$.source]) return;
              const X = this.workerSources[q][$.type][$.source];
              delete this.workerSources[q][$.type][$.source], X.removeSource !== void 0 && X.removeSource($)
            })))), this.actor.registerMessageHandler("RM", (q => T._(this, void 0, void 0, (function*() {
              delete this.layerIndexes[q], delete this.availableImages[q], delete this.workerSources[q], delete this.demWorkerSources[q]
            })))), this.actor.registerMessageHandler("SR", ((q, $) => T._(this, void 0, void 0, (function*() {
              this.referrer = $
            })))), this.actor.registerMessageHandler("SRPS", ((q, $) => this._syncRTLPluginState(q, $))), this.actor.registerMessageHandler("IS", ((q, $) => T._(this, void 0, void 0, (function*() {
              this.self.importScripts($)
            })))), this.actor.registerMessageHandler("SI", ((q, $) => this._setImages(q, $))), this.actor.registerMessageHandler("UL", ((q, $) => T._(this, void 0, void 0, (function*() {
              this._getLayerIndex(q).update($.layers, $.removedIds)
            })))), this.actor.registerMessageHandler("SL", ((q, $) => T._(this, void 0, void 0, (function*() {
              this._getLayerIndex(q).replace($)
            }))))
          }
          _setImages(F, q) {
            return T._(this, void 0, void 0, (function*() {
              this.availableImages[F] = q;
              for (const $ in this.workerSources[F]) {
                const X = this.workerSources[F][$];
                for (const oe in X) X[oe].availableImages = q
              }
            }))
          }
          _syncRTLPluginState(F, q) {
            return T._(this, void 0, void 0, (function*() {
              return yield T.cX.syncState(q, this.self.importScripts)
            }))
          }
          _getAvailableImages(F) {
            let q = this.availableImages[F];
            return q || (q = []), q
          }
          _getLayerIndex(F) {
            let q = this.layerIndexes[F];
            return q || (q = this.layerIndexes[F] = new o), q
          }
          _getWorkerSource(F, q, $) {
            if (this.workerSources[F] || (this.workerSources[F] = {}), this.workerSources[F][q] || (this.workerSources[F][q] = {}), !this.workerSources[F][q][$]) {
              const X = {
                sendAsync: (oe, me) => (oe.targetMapId = F, this.actor.sendAsync(oe, me))
              };
              switch (q) {
                case "vector":
                  this.workerSources[F][q][$] = new _e(X, this._getLayerIndex(F), this._getAvailableImages(F));
                  break;
                case "geojson":
                  this.workerSources[F][q][$] = new Mr(X, this._getLayerIndex(F), this._getAvailableImages(F));
                  break;
                default:
                  this.workerSources[F][q][$] = new this.externalWorkerSourceTypes[q](X, this._getLayerIndex(F), this._getAvailableImages(F))
              }
            }
            return this.workerSources[F][q][$]
          }
          _getDEMWorkerSource(F, q) {
            return this.demWorkerSources[F] || (this.demWorkerSources[F] = {}), this.demWorkerSources[F][q] || (this.demWorkerSources[F][q] = new xe), this.demWorkerSources[F][q]
          }
        }
        return T.i(self) && (self.worker = new Nr(self)), Nr
      })), D("index", ["exports", "./shared"], (function(T, o) {
        var G = "5.6.2";

        function W() {
          var h = new o.A(4);
          return o.A != Float32Array && (h[1] = 0, h[2] = 0), h[0] = 1, h[3] = 1, h
        }
        let ae, _e;
        const xe = {
          now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),
          frame(h, e, n) {
            const s = requestAnimationFrame((d => {
                u(), e(d)
              })),
              {
                unsubscribe: u
              } = o.s(h.signal, "abort", (() => {
                u(), cancelAnimationFrame(s), n(o.c())
              }), !1)
          },
          frameAsync(h) {
            return new Promise(((e, n) => {
              this.frame(h, e, n)
            }))
          },
          getImageData(h, e = 0) {
            return this.getImageCanvasContext(h).getImageData(-e, -e, h.width + 2 * e, h.height + 2 * e)
          },
          getImageCanvasContext(h) {
            const e = window.document.createElement("canvas"),
              n = e.getContext("2d", {
                willReadFrequently: !0
              });
            if (!n) throw new Error("failed to create canvas 2d context");
            return e.width = h.width, e.height = h.height, n.drawImage(h, 0, 0, h.width, h.height), n
          },
          resolveURL: h => (ae || (ae = document.createElement("a")), ae.href = h, ae.href),
          hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
          get prefersReducedMotion() {
            return !!matchMedia && (_e == null && (_e = matchMedia("(prefers-reduced-motion: reduce)")), _e.matches)
          }
        };
        class K {
          static testProp(e) {
            if (!K.docStyle) return e[0];
            for (let n = 0; n < e.length; n++)
              if (e[n] in K.docStyle) return e[n];
            return e[0]
          }
          static create(e, n, s) {
            const u = window.document.createElement(e);
            return n !== void 0 && (u.className = n), s && s.appendChild(u), u
          }
          static createNS(e, n) {
            return window.document.createElementNS(e, n)
          }
          static disableDrag() {
            K.docStyle && K.selectProp && (K.userSelect = K.docStyle[K.selectProp], K.docStyle[K.selectProp] = "none")
          }
          static enableDrag() {
            K.docStyle && K.selectProp && (K.docStyle[K.selectProp] = K.userSelect)
          }
          static setTransform(e, n) {
            e.style[K.transformProp] = n
          }
          static addEventListener(e, n, s, u = {}) {
            e.addEventListener(n, s, "passive" in u ? u : u.capture)
          }
          static removeEventListener(e, n, s, u = {}) {
            e.removeEventListener(n, s, "passive" in u ? u : u.capture)
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", K.suppressClickInternal, !0)
          }
          static suppressClick() {
            window.addEventListener("click", K.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", K.suppressClickInternal, !0)
            }), 0)
          }
          static getScale(e) {
            const n = e.getBoundingClientRect();
            return {
              x: n.width / e.offsetWidth || 1,
              y: n.height / e.offsetHeight || 1,
              boundingClientRect: n
            }
          }
          static getPoint(e, n, s) {
            const u = n.boundingClientRect;
            return new o.P((s.clientX - u.left) / n.x - e.clientLeft, (s.clientY - u.top) / n.y - e.clientTop)
          }
          static mousePos(e, n) {
            const s = K.getScale(e);
            return K.getPoint(e, s, n)
          }
          static touchPos(e, n) {
            const s = [],
              u = K.getScale(e);
            for (let d = 0; d < n.length; d++) s.push(K.getPoint(e, u, n[d]));
            return s
          }
          static mouseButton(e) {
            return e.button
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e)
          }
          static sanitize(e) {
            const n = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"),
              s = n.querySelectorAll("script");
            for (const u of s) u.remove();
            return K.clean(n), n.innerHTML
          }
          static isPossiblyDangerous(e, n) {
            const s = n.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !s.includes("javascript:") && !s.includes("data:")) || !!e.startsWith("on") || void 0
          }
          static clean(e) {
            const n = e.children;
            for (const s of n) K.removeAttributes(s), K.clean(s)
          }
          static removeAttributes(e) {
            for (const {
                name: n,
                value: s
              }
              of e.attributes) K.isPossiblyDangerous(n, s) && e.removeAttribute(n)
          }
        }
        K.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, K.selectProp = K.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), K.transformProp = K.testProp(["transform", "WebkitTransform"]);
        const Ie = {
          supported: !1,
          testSupport: function(h) {
            !Be && De && (je ? Le(h) : Ce = h)
          }
        };
        let Ce, De, Be = !1,
          je = !1;

        function Le(h) {
          const e = h.createTexture();
          h.bindTexture(h.TEXTURE_2D, e);
          try {
            if (h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, De), h.isContextLost()) return;
            Ie.supported = !0
          } catch {}
          h.deleteTexture(e), Be = !0
        }
        var Fe;
        typeof document < "u" && (De = document.createElement("img"), De.onload = () => {
          Ce && Le(Ce), Ce = null, je = !0
        }, De.onerror = () => {
          Be = !0, Ce = null
        }, De.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(h) {
          let e, n, s, u;
          h.resetRequestQueue = () => {
            e = [], n = 0, s = 0, u = {}
          }, h.addThrottleControl = b => {
            const P = s++;
            return u[P] = b, P
          }, h.removeThrottleControl = b => {
            delete u[b], m()
          }, h.getImage = (b, P, M = !0) => new Promise(((L, z) => {
            Ie.supported && (b.headers || (b.headers = {}), b.headers.accept = "image/webp,*/*"), o.e(b, {
              type: "image"
            }), e.push({
              abortController: P,
              requestParameters: b,
              supportImageRefresh: M,
              state: "queued",
              onError: B => {
                z(B)
              },
              onSuccess: B => {
                L(B)
              }
            }), m()
          }));
          const d = b => o._(this, void 0, void 0, (function*() {
              b.state = "running";
              const {
                requestParameters: P,
                supportImageRefresh: M,
                onError: L,
                onSuccess: z,
                abortController: B
              } = b, U = M === !1 && !o.i(self) && !o.g(P.url) && (!P.headers || Object.keys(P.headers).reduce(((re, se) => re && se === "accept"), !0));
              n++;
              const Q = U ? y(P, B) : o.m(P, B);
              try {
                const re = yield Q;
                delete b.abortController, b.state = "completed", re.data instanceof HTMLImageElement || o.b(re.data) ? z(re) : re.data && z({
                  data: yield(J = re.data, typeof createImageBitmap == "function" ? o.f(J) : o.h(J)),
                  cacheControl: re.cacheControl,
                  expires: re.expires
                })
              } catch (re) {
                delete b.abortController, L(re)
              } finally {
                n--, m()
              }
              var J
            })),
            m = () => {
              const b = (() => {
                for (const P of Object.keys(u))
                  if (u[P]()) return !0;
                return !1
              })() ? o.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : o.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let P = n; P < b && e.length > 0; P++) {
                const M = e.shift();
                M.abortController.signal.aborted ? P-- : d(M)
              }
            },
            y = (b, P) => new Promise(((M, L) => {
              const z = new Image,
                B = b.url,
                U = b.credentials;
              U && U === "include" ? z.crossOrigin = "use-credentials" : (U && U === "same-origin" || !o.d(B)) && (z.crossOrigin = "anonymous"), P.signal.addEventListener("abort", (() => {
                z.src = "", L(o.c())
              })), z.fetchPriority = "high", z.onload = () => {
                z.onerror = z.onload = null, M({
                  data: z
                })
              }, z.onerror = () => {
                z.onerror = z.onload = null, P.signal.aborted || L(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
              }, z.src = B
            }))
        })(Fe || (Fe = {})), Fe.resetRequestQueue();
        class mt {
          constructor(e) {
            this._transformRequestFn = e ?? null
          }
          transformRequest(e, n) {
            return this._transformRequestFn && this._transformRequestFn(e, n) || {
              url: e
            }
          }
          setTransformRequest(e) {
            this._transformRequestFn = e
          }
        }

        function ut(h) {
          const e = [];
          if (typeof h == "string") e.push({
            id: "default",
            url: h
          });
          else if (h && h.length > 0) {
            const n = [];
            for (const {
                id: s,
                url: u
              }
              of h) {
              const d = `${s}${u}`;
              n.indexOf(d) === -1 && (n.push(d), e.push({
                id: s,
                url: u
              }))
            }
          }
          return e
        }

        function Ke(h, e, n) {
          try {
            const s = new URL(h);
            return s.pathname += `${e}${n}`, s.toString()
          } catch {
            throw new Error(`Invalid sprite URL "${h}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
          }
        }

        function ct(h) {
          const {
            userImage: e
          } = h;
          return !!(e && e.render && e.render()) && (h.data.replace(new Uint8Array(e.data.buffer)), !0)
        }
        class tt extends o.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new o.R({
              width: 1,
              height: 1
            }), this.dirty = !0
          }
          isLoaded() {
            return this.loaded
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const {
                  ids: n,
                  promiseResolve: s
                }
                of this.requestors) s(this._getImagesForIds(n));
              this.requestors = []
            }
          }
          getImage(e) {
            const n = this.images[e];
            if (n && !n.data && n.spriteData) {
              const s = n.spriteData;
              n.data = new o.R({
                width: s.width,
                height: s.height
              }, s.context.getImageData(s.x, s.y, s.width, s.height).data), n.spriteData = null
            }
            return n
          }
          addImage(e, n) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, n) && (this.images[e] = n)
          }
          _validate(e, n) {
            let s = !0;
            const u = n.data || n.spriteData;
            return this._validateStretch(n.stretchX, u && u.width) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "stretchX" value`))), s = !1), this._validateStretch(n.stretchY, u && u.height) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "stretchY" value`))), s = !1), this._validateContent(n.content, n) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "content" value`))), s = !1), s
          }
          _validateStretch(e, n) {
            if (!e) return !0;
            let s = 0;
            for (const u of e) {
              if (u[0] < s || u[1] < u[0] || n < u[1]) return !1;
              s = u[1]
            }
            return !0
          }
          _validateContent(e, n) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const s = n.spriteData,
              u = s && s.width || n.data.width,
              d = s && s.height || n.data.height;
            return !(e[0] < 0 || u < e[0] || e[1] < 0 || d < e[1] || e[2] < 0 || u < e[2] || e[3] < 0 || d < e[3] || e[2] < e[0] || e[3] < e[1])
          }
          updateImage(e, n, s = !0) {
            const u = this.getImage(e);
            if (s && (u.data.width !== n.data.width || u.data.height !== n.data.height)) throw new Error(`size mismatch between old image (${u.data.width}x${u.data.height}) and new image (${n.data.width}x${n.data.height}).`);
            n.version = u.version + 1, this.images[e] = n, this.updatedImages[e] = !0
          }
          removeImage(e) {
            const n = this.images[e];
            delete this.images[e], delete this.patterns[e], n.userImage && n.userImage.onRemove && n.userImage.onRemove()
          }
          listImages() {
            return Object.keys(this.images)
          }
          getImages(e) {
            return new Promise(((n, s) => {
              let u = !0;
              if (!this.isLoaded())
                for (const d of e) this.images[d] || (u = !1);
              this.isLoaded() || u ? n(this._getImagesForIds(e)) : this.requestors.push({
                ids: e,
                promiseResolve: n
              })
            }))
          }
          _getImagesForIds(e) {
            const n = {};
            for (const s of e) {
              let u = this.getImage(s);
              u || (this.fire(new o.l("styleimagemissing", {
                id: s
              })), u = this.getImage(s)), u ? n[s] = {
                data: u.data.clone(),
                pixelRatio: u.pixelRatio,
                sdf: u.sdf,
                version: u.version,
                stretchX: u.stretchX,
                stretchY: u.stretchY,
                content: u.content,
                textFitWidth: u.textFitWidth,
                textFitHeight: u.textFitHeight,
                hasRenderCallback: !!(u.userImage && u.userImage.render)
              } : o.w(`Image "${s}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
            }
            return n
          }
          getPixelSize() {
            const {
              width: e,
              height: n
            } = this.atlasImage;
            return {
              width: e,
              height: n
            }
          }
          getPattern(e) {
            const n = this.patterns[e],
              s = this.getImage(e);
            if (!s) return null;
            if (n && n.position.version === s.version) return n.position;
            if (n) n.position.version = s.version;
            else {
              const u = {
                  w: s.data.width + 2,
                  h: s.data.height + 2,
                  x: 0,
                  y: 0
                },
                d = new o.I(u, s);
              this.patterns[e] = {
                bin: u,
                position: d
              }
            }
            return this._updatePatternAtlas(), this.patterns[e].position
          }
          bind(e) {
            const n = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new o.T(e, this.atlasImage, n.RGBA), this.atlasTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE)
          }
          _updatePatternAtlas() {
            const e = [];
            for (const d in this.patterns) e.push(this.patterns[d].bin);
            const {
              w: n,
              h: s
            } = o.p(e), u = this.atlasImage;
            u.resize({
              width: n || 1,
              height: s || 1
            });
            for (const d in this.patterns) {
              const {
                bin: m
              } = this.patterns[d], y = m.x + 1, b = m.y + 1, P = this.getImage(d).data, M = P.width, L = P.height;
              o.R.copy(P, u, {
                x: 0,
                y: 0
              }, {
                x: y,
                y: b
              }, {
                width: M,
                height: L
              }), o.R.copy(P, u, {
                x: 0,
                y: L - 1
              }, {
                x: y,
                y: b - 1
              }, {
                width: M,
                height: 1
              }), o.R.copy(P, u, {
                x: 0,
                y: 0
              }, {
                x: y,
                y: b + L
              }, {
                width: M,
                height: 1
              }), o.R.copy(P, u, {
                x: M - 1,
                y: 0
              }, {
                x: y - 1,
                y: b
              }, {
                width: 1,
                height: L
              }), o.R.copy(P, u, {
                x: 0,
                y: 0
              }, {
                x: y + M,
                y: b
              }, {
                width: 1,
                height: L
              })
            }
            this.dirty = !0
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {}
          }
          dispatchRenderCallbacks(e) {
            for (const n of e) {
              if (this.callbackDispatchedThisFrame[n]) continue;
              this.callbackDispatchedThisFrame[n] = !0;
              const s = this.getImage(n);
              s || o.w(`Image with ID: "${n}" was not found`), ct(s) && this.updateImage(n, s)
            }
          }
        }
        const Re = 1e20;

        function ot(h, e, n, s, u, d, m, y, b) {
          for (let P = e; P < e + s; P++) rt(h, n * d + P, d, u, m, y, b);
          for (let P = n; P < n + u; P++) rt(h, P * d + e, 1, s, m, y, b)
        }

        function rt(h, e, n, s, u, d, m) {
          d[0] = 0, m[0] = -Re, m[1] = Re, u[0] = h[e];
          for (let y = 1, b = 0, P = 0; y < s; y++) {
            u[y] = h[e + y * n];
            const M = y * y;
            do {
              const L = d[b];
              P = (u[y] - u[L] + M - L * L) / (y - L) / 2
            } while (P <= m[b] && --b > -1);
            b++, d[b] = y, m[b] = P, m[b + 1] = Re
          }
          for (let y = 0, b = 0; y < s; y++) {
            for (; m[b + 1] < y;) b++;
            const P = d[b],
              M = y - P;
            h[e + y * n] = u[P] + M * M
          }
        }
        class Qe {
          constructor(e, n) {
            this.requestManager = e, this.localIdeographFontFamily = n, this.entries = {}
          }
          setURL(e) {
            this.url = e
          }
          getGlyphs(e) {
            return o._(this, void 0, void 0, (function*() {
              const n = [];
              for (const d in e)
                for (const m of e[d]) n.push(this._getAndCacheGlyphsPromise(d, m));
              const s = yield Promise.all(n), u = {};
              for (const {
                  stack: d,
                  id: m,
                  glyph: y
                }
                of s) u[d] || (u[d] = {}), u[d][m] = y && {
                id: y.id,
                bitmap: y.bitmap.clone(),
                metrics: y.metrics
              };
              return u
            }))
          }
          _getAndCacheGlyphsPromise(e, n) {
            return o._(this, void 0, void 0, (function*() {
              let s = this.entries[e];
              s || (s = this.entries[e] = {
                glyphs: {},
                requests: {},
                ranges: {}
              });
              let u = s.glyphs[n];
              if (u !== void 0) return {
                stack: e,
                id: n,
                glyph: u
              };
              if (u = this._tinySDF(s, e, n), u) return s.glyphs[n] = u, {
                stack: e,
                id: n,
                glyph: u
              };
              const d = Math.floor(n / 256);
              if (256 * d > 65535) throw new Error("glyphs > 65535 not supported");
              if (s.ranges[d]) return {
                stack: e,
                id: n,
                glyph: u
              };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!s.requests[d]) {
                const y = Qe.loadGlyphRange(e, d, this.url, this.requestManager);
                s.requests[d] = y
              }
              const m = yield s.requests[d];
              for (const y in m) this._doesCharSupportLocalGlyph(+y) || (s.glyphs[+y] = m[+y]);
              return s.ranges[d] = !0, {
                stack: e,
                id: n,
                glyph: m[n] || null
              }
            }))
          }
          _doesCharSupportLocalGlyph(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || o.u["CJK Unified Ideographs"](e) || o.u["Hangul Syllables"](e) || o.u.Hiragana(e) || o.u.Katakana(e) || o.u["CJK Symbols and Punctuation"](e) || o.u["Halfwidth and Fullwidth Forms"](e))
          }
          _tinySDF(e, n, s) {
            const u = this.localIdeographFontFamily;
            if (!u || !this._doesCharSupportLocalGlyph(s)) return;
            let d = e.tinySDF;
            if (!d) {
              let y = "400";
              /bold/i.test(n) ? y = "900" : /medium/i.test(n) ? y = "500" : /light/i.test(n) && (y = "200"), d = e.tinySDF = new Qe.TinySDF({
                fontSize: 48,
                buffer: 6,
                radius: 16,
                cutoff: .25,
                fontFamily: u,
                fontWeight: y
              })
            }
            const m = d.draw(String.fromCharCode(s));
            return {
              id: s,
              bitmap: new o.q({
                width: m.width || 60,
                height: m.height || 60
              }, m.data),
              metrics: {
                width: m.glyphWidth / 2 || 24,
                height: m.glyphHeight / 2 || 24,
                left: m.glyphLeft / 2 + .5 || 0,
                top: m.glyphTop / 2 - 27.5 || -8,
                advance: m.glyphAdvance / 2 || 24,
                isDoubleResolution: !0
              }
            }
          }
        }
        Qe.loadGlyphRange = function(h, e, n, s) {
          return o._(this, void 0, void 0, (function*() {
            const u = 256 * e,
              d = u + 255,
              m = s.transformRequest(n.replace("{fontstack}", h).replace("{range}", `${u}-${d}`), "Glyphs"),
              y = yield o.n(m, new AbortController);
            if (!y || !y.data) throw new Error(`Could not load glyph range. range: ${e}, ${u}-${d}`);
            const b = {};
            for (const P of o.o(y.data)) b[P.id] = P;
            return b
          }))
        }, Qe.TinySDF = class {
          constructor({
            fontSize: h = 24,
            buffer: e = 3,
            radius: n = 8,
            cutoff: s = .25,
            fontFamily: u = "sans-serif",
            fontWeight: d = "normal",
            fontStyle: m = "normal",
            lang: y = null
          } = {}) {
            this.buffer = e, this.cutoff = s, this.radius = n, this.lang = y;
            const b = this.size = h + 4 * e,
              P = this._createCanvas(b),
              M = this.ctx = P.getContext("2d", {
                willReadFrequently: !0
              });
            M.font = `${m} ${d} ${h}px ${u}`, M.textBaseline = "alphabetic", M.textAlign = "left", M.fillStyle = "black", this.gridOuter = new Float64Array(b * b), this.gridInner = new Float64Array(b * b), this.f = new Float64Array(b), this.z = new Float64Array(b + 1), this.v = new Uint16Array(b)
          }
          _createCanvas(h) {
            const e = document.createElement("canvas");
            return e.width = e.height = h, e
          }
          draw(h) {
            const {
              width: e,
              actualBoundingBoxAscent: n,
              actualBoundingBoxDescent: s,
              actualBoundingBoxLeft: u,
              actualBoundingBoxRight: d
            } = this.ctx.measureText(h), m = Math.ceil(n), y = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(d - u))), b = Math.min(this.size - this.buffer, m + Math.ceil(s)), P = y + 2 * this.buffer, M = b + 2 * this.buffer, L = Math.max(P * M, 0), z = new Uint8ClampedArray(L), B = {
              data: z,
              width: P,
              height: M,
              glyphWidth: y,
              glyphHeight: b,
              glyphTop: m,
              glyphLeft: 0,
              glyphAdvance: e
            };
            if (y === 0 || b === 0) return B;
            const {
              ctx: U,
              buffer: Q,
              gridInner: J,
              gridOuter: re
            } = this;
            this.lang && (U.lang = this.lang), U.clearRect(Q, Q, y, b), U.fillText(h, Q, Q + m);
            const se = U.getImageData(Q, Q, y, b);
            re.fill(Re, 0, L), J.fill(0, 0, L);
            for (let de = 0; de < b; de++)
              for (let ue = 0; ue < y; ue++) {
                const ge = se.data[4 * (de * y + ue) + 3] / 255;
                if (ge === 0) continue;
                const we = (de + Q) * P + ue + Q;
                if (ge === 1) re[we] = 0, J[we] = Re;
                else {
                  const he = .5 - ge;
                  re[we] = he > 0 ? he * he : 0, J[we] = he < 0 ? he * he : 0
                }
              }
            ot(re, 0, 0, P, M, P, this.f, this.v, this.z), ot(J, Q, Q, y, b, P, this.f, this.v, this.z);
            for (let de = 0; de < L; de++) {
              const ue = Math.sqrt(re[de]) - Math.sqrt(J[de]);
              z[de] = Math.round(255 - 255 * (ue / this.radius + this.cutoff))
            }
            return B
          }
        };
        class Ae {
          constructor() {
            this.specification = o.v.light.position
          }
          possiblyEvaluate(e, n) {
            return o.B(e.expression.evaluate(n))
          }
          interpolate(e, n, s) {
            return {
              x: o.C.number(e.x, n.x, s),
              y: o.C.number(e.y, n.y, s),
              z: o.C.number(e.z, n.z, s)
            }
          }
        }
        let gt;
        class ee extends o.E {
          constructor(e) {
            super(), gt = gt || new o.r({
              anchor: new o.D(o.v.light.anchor),
              position: new Ae,
              color: new o.D(o.v.light.color),
              intensity: new o.D(o.v.light.intensity)
            }), this._transitionable = new o.t(gt), this.setLight(e), this._transitioning = this._transitionable.untransitioned()
          }
          getLight() {
            return this._transitionable.serialize()
          }
          setLight(e, n = {}) {
            if (!this._validate(o.x, e, n))
              for (const s in e) {
                const u = e[s];
                s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), u) : this._transitionable.setValue(s, u)
              }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, n, s) {
            return (!s || s.validate !== !1) && o.y(this, e.call(o.z, {
              value: n,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: o.v
            }))
          }
        }
        const te = new o.r({
          "sky-color": new o.D(o.v.sky["sky-color"]),
          "horizon-color": new o.D(o.v.sky["horizon-color"]),
          "fog-color": new o.D(o.v.sky["fog-color"]),
          "fog-ground-blend": new o.D(o.v.sky["fog-ground-blend"]),
          "horizon-fog-blend": new o.D(o.v.sky["horizon-fog-blend"]),
          "sky-horizon-blend": new o.D(o.v.sky["sky-horizon-blend"]),
          "atmosphere-blend": new o.D(o.v.sky["atmosphere-blend"])
        });
        class fe extends o.E {
          constructor(e) {
            super(), this._transitionable = new o.t(te), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.F(0))
          }
          setSky(e, n = {}) {
            if (!this._validate(o.G, e, n)) {
              e || (e = {
                "sky-color": "transparent",
                "horizon-color": "transparent",
                "fog-color": "transparent",
                "fog-ground-blend": 1,
                "atmosphere-blend": 0
              });
              for (const s in e) {
                const u = e[s];
                s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), u) : this._transitionable.setValue(s, u)
              }
            }
          }
          getSky() {
            return this._transitionable.serialize()
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, n, s = {}) {
            return (s == null ? void 0 : s.validate) !== !1 && o.y(this, e.call(o.z, o.e({
              value: n,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: o.v
            })))
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
          }
        }
        class ie {
          constructor(e, n) {
            this.width = e, this.height = n, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {}
          }
          getDash(e, n) {
            const s = e.join(",") + String(n);
            return this.dashEntry[s] || (this.dashEntry[s] = this.addDash(e, n)), this.dashEntry[s]
          }
          getDashRanges(e, n, s) {
            const u = [];
            let d = e.length % 2 == 1 ? -e[e.length - 1] * s : 0,
              m = e[0] * s,
              y = !0;
            u.push({
              left: d,
              right: m,
              isDash: y,
              zeroLength: e[0] === 0
            });
            let b = e[0];
            for (let P = 1; P < e.length; P++) {
              y = !y;
              const M = e[P];
              d = b * s, b += M, m = b * s, u.push({
                left: d,
                right: m,
                isDash: y,
                zeroLength: M === 0
              })
            }
            return u
          }
          addRoundDash(e, n, s) {
            const u = n / 2;
            for (let d = -s; d <= s; d++) {
              const m = this.width * (this.nextRow + s + d);
              let y = 0,
                b = e[y];
              for (let P = 0; P < this.width; P++) {
                P / b.right > 1 && (b = e[++y]);
                const M = Math.abs(P - b.left),
                  L = Math.abs(P - b.right),
                  z = Math.min(M, L);
                let B;
                const U = d / s * (u + 1);
                if (b.isDash) {
                  const Q = u - Math.abs(U);
                  B = Math.sqrt(z * z + Q * Q)
                } else B = u - Math.sqrt(z * z + U * U);
                this.data[m + P] = Math.max(0, Math.min(255, B + 128))
              }
            }
          }
          addRegularDash(e) {
            for (let y = e.length - 1; y >= 0; --y) {
              const b = e[y],
                P = e[y + 1];
              b.zeroLength ? e.splice(y, 1) : P && P.isDash === b.isDash && (P.left = b.left, e.splice(y, 1))
            }
            const n = e[0],
              s = e[e.length - 1];
            n.isDash === s.isDash && (n.left = s.left - this.width, s.right = n.right + this.width);
            const u = this.width * this.nextRow;
            let d = 0,
              m = e[d];
            for (let y = 0; y < this.width; y++) {
              y / m.right > 1 && (m = e[++d]);
              const b = Math.abs(y - m.left),
                P = Math.abs(y - m.right),
                M = Math.min(b, P);
              this.data[u + y] = Math.max(0, Math.min(255, (m.isDash ? M : -M) + 128))
            }
          }
          addDash(e, n) {
            const s = n ? 7 : 0,
              u = 2 * s + 1;
            if (this.nextRow + u > this.height) return o.w("LineAtlas out of space"), null;
            let d = 0;
            for (let y = 0; y < e.length; y++) d += e[y];
            if (d !== 0) {
              const y = this.width / d,
                b = this.getDashRanges(e, this.width, y);
              n ? this.addRoundDash(b, y, s) : this.addRegularDash(b)
            }
            const m = {
              y: (this.nextRow + s + .5) / this.height,
              height: 2 * s / this.height,
              width: d
            };
            return this.nextRow += u, this.dirty = !0, m
          }
          bind(e) {
            const n = e.gl;
            this.texture ? (n.bindTexture(n.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, this.width, this.height, n.ALPHA, n.UNSIGNED_BYTE, this.data))) : (this.texture = n.createTexture(), n.bindTexture(n.TEXTURE_2D, this.texture), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.REPEAT), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.REPEAT), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR), n.texImage2D(n.TEXTURE_2D, 0, n.ALPHA, this.width, this.height, 0, n.ALPHA, n.UNSIGNED_BYTE, this.data))
          }
        }
        const Se = "maplibre_preloaded_worker_pool";
        class Me {
          constructor() {
            this.active = {}
          }
          acquire(e) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < Me.workerCount;) this.workers.push(new Worker(o.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice()
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach((n => {
              n.terminate()
            })), this.workers = null)
          }
          isPreloaded() {
            return !!this.active[Se]
          }
          numActive() {
            return Object.keys(this.active).length
          }
        }
        const nt = Math.floor(xe.hardwareConcurrency / 2);
        let Ye, wt;

        function zt() {
          return Ye || (Ye = new Me), Ye
        }
        Me.workerCount = o.H(globalThis) ? Math.max(Math.min(nt, 3), 1) : 1;
        class Nt {
          constructor(e, n) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = n;
            const s = this.workerPool.acquire(n);
            for (let u = 0; u < s.length; u++) {
              const d = new o.J(s[u], n);
              d.name = `Worker ${u}`, this.actors.push(d)
            }
            if (!this.actors.length) throw new Error("No actors found")
          }
          broadcast(e, n) {
            const s = [];
            for (const u of this.actors) s.push(u.sendAsync({
              type: e,
              data: n
            }));
            return Promise.all(s)
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
          }
          remove(e = !0) {
            this.actors.forEach((n => {
              n.remove()
            })), this.actors = [], e && this.workerPool.release(this.id)
          }
          registerMessageHandler(e, n) {
            for (const s of this.actors) s.registerMessageHandler(e, n)
          }
        }

        function st() {
          return wt || (wt = new Nt(zt(), o.K), wt.registerMessageHandler("GR", ((h, e, n) => o.m(e, n)))), wt
        }

        function Tt(h, e) {
          const n = o.L();
          return o.M(n, n, [1, 1, 0]), o.N(n, n, [.5 * h.width, .5 * h.height, 1]), h.calculatePosMatrix ? o.O(n, n, h.calculatePosMatrix(e.toUnwrapped())) : n
        }

        function Ct(h, e, n, s, u, d, m) {
          var y;
          const b = (function(z, B, U) {
              if (z)
                for (const Q of z) {
                  const J = B[Q];
                  if (J && J.source === U && J.type === "fill-extrusion") return !0
                } else
                  for (const Q in B) {
                    const J = B[Q];
                    if (J.source === U && J.type === "fill-extrusion") return !0
                  }
              return !1
            })((y = u == null ? void 0 : u.layers) !== null && y !== void 0 ? y : null, e, h.id),
            P = d.maxPitchScaleFactor(),
            M = h.tilesIn(s, P, b);
          M.sort(yt);
          const L = [];
          for (const z of M) L.push({
            wrappedTileID: z.tileID.wrapped().key,
            queryResults: z.tile.queryRenderedFeatures(e, n, h._state, z.queryGeometry, z.cameraQueryGeometry, z.scale, u, d, P, Tt(h.transform, z.tileID), m ? (B, U) => m(z.tileID, B, U) : void 0)
          });
          return (function(z, B) {
            for (const U in z)
              for (const Q of z[U]) Mt(Q, B);
            return z
          })((function(z) {
            const B = {},
              U = {};
            for (const Q of z) {
              const J = Q.queryResults,
                re = Q.wrappedTileID,
                se = U[re] = U[re] || {};
              for (const de in J) {
                const ue = J[de],
                  ge = se[de] = se[de] || {},
                  we = B[de] = B[de] || [];
                for (const he of ue) ge[he.featureIndex] || (ge[he.featureIndex] = !0, we.push(he))
              }
            }
            return B
          })(L), h)
        }

        function yt(h, e) {
          const n = h.tileID,
            s = e.tileID;
          return n.overscaledZ - s.overscaledZ || n.canonical.y - s.canonical.y || n.wrap - s.wrap || n.canonical.x - s.canonical.x
        }

        function Mt(h, e) {
          const n = h.feature,
            s = e.getFeatureState(n.layer["source-layer"], n.id);
          n.source = n.layer.source, n.layer["source-layer"] && (n.sourceLayer = n.layer["source-layer"]), n.state = s
        }

        function St(h, e, n) {
          return o._(this, void 0, void 0, (function*() {
            let s = h;
            if (h.url ? s = (yield o.j(e.transformRequest(h.url, "Source"), n)).data : yield xe.frameAsync(n), !s) return null;
            const u = o.Q(o.e(s, h), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in s && s.vector_layers && (u.vectorLayerIds = s.vector_layers.map((d => d.id))), u
          }))
        }
        class ht {
          constructor(e, n) {
            e && (n ? this.setSouthWest(e).setNorthEast(n) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
          }
          setNorthEast(e) {
            return this._ne = e instanceof o.S ? new o.S(e.lng, e.lat) : o.S.convert(e), this
          }
          setSouthWest(e) {
            return this._sw = e instanceof o.S ? new o.S(e.lng, e.lat) : o.S.convert(e), this
          }
          extend(e) {
            const n = this._sw,
              s = this._ne;
            let u, d;
            if (e instanceof o.S) u = e, d = e;
            else {
              if (!(e instanceof ht)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(ht.convert(e)) : this.extend(o.S.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(o.S.convert(e)) : this;
              if (u = e._sw, d = e._ne, !u || !d) return this
            }
            return n || s ? (n.lng = Math.min(u.lng, n.lng), n.lat = Math.min(u.lat, n.lat), s.lng = Math.max(d.lng, s.lng), s.lat = Math.max(d.lat, s.lat)) : (this._sw = new o.S(u.lng, u.lat), this._ne = new o.S(d.lng, d.lat)), this
          }
          getCenter() {
            return new o.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
          }
          getSouthWest() {
            return this._sw
          }
          getNorthEast() {
            return this._ne
          }
          getNorthWest() {
            return new o.S(this.getWest(), this.getNorth())
          }
          getSouthEast() {
            return new o.S(this.getEast(), this.getSouth())
          }
          getWest() {
            return this._sw.lng
          }
          getSouth() {
            return this._sw.lat
          }
          getEast() {
            return this._ne.lng
          }
          getNorth() {
            return this._ne.lat
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()]
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
          }
          isEmpty() {
            return !(this._sw && this._ne)
          }
          contains(e) {
            const {
              lng: n,
              lat: s
            } = o.S.convert(e);
            let u = this._sw.lng <= n && n <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (u = this._sw.lng >= n && n >= this._ne.lng), this._sw.lat <= s && s <= this._ne.lat && u
          }
          static convert(e) {
            return e instanceof ht ? e : e && new ht(e)
          }
          static fromLngLat(e, n = 0) {
            const s = 360 * n / 40075017,
              u = s / Math.cos(Math.PI / 180 * e.lat);
            return new ht(new o.S(e.lng - u, e.lat - s), new o.S(e.lng + u, e.lat + s))
          }
          adjustAntiMeridian() {
            const e = new o.S(this._sw.lng, this._sw.lat),
              n = new o.S(this._ne.lng, this._ne.lat);
            return new ht(e, e.lng > n.lng ? new o.S(n.lng + 360, n.lat) : n)
          }
        }
        class Lt {
          constructor(e, n, s) {
            this.bounds = ht.convert(this.validateBounds(e)), this.minzoom = n || 0, this.maxzoom = s || 24
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
          }
          contains(e) {
            const n = Math.pow(2, e.z),
              s = Math.floor(o.V(this.bounds.getWest()) * n),
              u = Math.floor(o.U(this.bounds.getNorth()) * n),
              d = Math.ceil(o.V(this.bounds.getEast()) * n),
              m = Math.ceil(o.U(this.bounds.getSouth()) * n);
            return e.x >= s && e.x < d && e.y >= u && e.y < m
          }
        }
        class tr extends o.E {
          constructor(e, n, s, u) {
            if (super(), this.id = e, this.dispatcher = s, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, o.e(this, o.Q(n, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.e({
                type: "vector"
              }, n), this._collectResourceTiming = n.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(u)
          }
          load() {
            return o._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new o.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const e = yield St(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (o.e(this, e), e.bounds && (this.tileBounds = new Lt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new o.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new o.l("data", {
                  dataType: "source",
                  sourceDataType: "content"
                })))
              } catch (e) {
                this._tileJSONRequest = null, this.fire(new o.k(e))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load()
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          serialize() {
            return o.e({}, this._options)
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              const n = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                s = {
                  request: this.map._requestManager.transformRequest(n, "Tile"),
                  uid: e.uid,
                  tileID: e.tileID,
                  zoom: e.tileID.overscaledZ,
                  tileSize: this.tileSize * e.tileID.overscaleFactor(),
                  type: this.type,
                  source: this.id,
                  pixelRatio: this.map.getPixelRatio(),
                  showCollisionBoxes: this.map.showCollisionBoxes,
                  promoteId: this.promoteId,
                  subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                  globalState: this.map.getGlobalState()
                };
              s.request.collectResourceTiming = this._collectResourceTiming;
              let u = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((d, m) => {
                  e.reloadPromise = {
                    resolve: d,
                    reject: m
                  }
                }))
              } else e.actor = this.dispatcher.getActor(), u = "LT";
              e.abortController = new AbortController;
              try {
                const d = yield e.actor.sendAsync({
                  type: u,
                  data: s
                }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, d)
              } catch (d) {
                if (delete e.abortController, e.aborted) return;
                if (d && d.status !== 404) throw d;
                this._afterTileLoadWorkerResponse(e, null)
              }
            }))
          }
          _afterTileLoadWorkerResponse(e, n) {
            if (n && n.resourceTiming && (e.resourceTiming = n.resourceTiming), n && this.map._refreshExpiredTiles && e.setExpiryData(n), e.loadVectorData(n, this.map.painter), e.reloadPromise) {
              const s = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(s.resolve).catch(s.reject)
            }
          }
          abortTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({
                type: "AT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class Jt extends o.E {
          constructor(e, n, s, u) {
            super(), this.id = e, this.dispatcher = s, this.setEventedParent(u), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = o.e({
              type: "raster"
            }, n), o.e(this, o.Q(n, ["url", "scheme", "tileSize"]))
          }
          load() {
            return o._(this, arguments, void 0, (function*(e = !1) {
              this._loaded = !1, this.fire(new o.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const n = yield St(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, n && (o.e(this, n), n.bounds && (this.tileBounds = new Lt(n.bounds, this.minzoom, this.maxzoom)), this.fire(new o.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new o.l("data", {
                  dataType: "source",
                  sourceDataType: "content",
                  sourceDataChanged: e
                })))
              } catch (n) {
                this._tileJSONRequest = null, this.fire(new o.k(n))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0)
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          serialize() {
            return o.e({}, this._options)
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              const n = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController;
              try {
                const s = yield Fe.getImage(this.map._requestManager.transformRequest(n, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (s && s.data) {
                  this.map._refreshExpiredTiles && (s.cacheControl || s.expires) && e.setExpiryData({
                    cacheControl: s.cacheControl,
                    expires: s.expires
                  });
                  const u = this.map.painter.context,
                    d = u.gl,
                    m = s.data;
                  e.texture = this.map.painter.getTileTexture(m.width), e.texture ? e.texture.update(m, {
                    useMipmap: !0
                  }) : (e.texture = new o.T(u, m, d.RGBA, {
                    useMipmap: !0
                  }), e.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST)), e.state = "loaded"
                }
              } catch (s) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (s) throw e.state = "errored", s
              }
            }))
          }
          abortTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController)
            }))
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.texture && this.map.painter.saveTileTexture(e.texture)
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class dr extends Jt {
          constructor(e, n, s, u) {
            super(e, n, s, u), this.type = "raster-dem", this.maxzoom = 22, this._options = o.e({
              type: "raster-dem"
            }, n), this.encoding = n.encoding || "mapbox", this.redFactor = n.redFactor, this.greenFactor = n.greenFactor, this.blueFactor = n.blueFactor, this.baseShift = n.baseShift
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              const n = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                s = this.map._requestManager.transformRequest(n, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController;
              try {
                const u = yield Fe.getImage(s, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (u && u.data) {
                  const d = u.data;
                  this.map._refreshExpiredTiles && (u.cacheControl || u.expires) && e.setExpiryData({
                    cacheControl: u.cacheControl,
                    expires: u.expires
                  });
                  const m = o.b(d) && o.W() ? d : yield this.readImageNow(d), y = {
                    type: this.type,
                    uid: e.uid,
                    source: this.id,
                    rawImageData: m,
                    encoding: this.encoding,
                    redFactor: this.redFactor,
                    greenFactor: this.greenFactor,
                    blueFactor: this.blueFactor,
                    baseShift: this.baseShift
                  };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const b = yield e.actor.sendAsync({
                      type: "LDT",
                      data: y
                    });
                    e.dem = b, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded"
                  }
                }
              } catch (u) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (u) throw e.state = "errored", u
              }
            }))
          }
          readImageNow(e) {
            return o._(this, void 0, void 0, (function*() {
              if (typeof VideoFrame < "u" && o.X()) {
                const n = e.width + 2,
                  s = e.height + 2;
                try {
                  return new o.R({
                    width: n,
                    height: s
                  }, yield o.Y(e, -1, -1, n, s))
                } catch {}
              }
              return xe.getImageData(e, 1)
            }))
          }
          _getNeighboringTiles(e) {
            const n = e.canonical,
              s = Math.pow(2, n.z),
              u = (n.x - 1 + s) % s,
              d = n.x === 0 ? e.wrap - 1 : e.wrap,
              m = (n.x + 1 + s) % s,
              y = n.x + 1 === s ? e.wrap + 1 : e.wrap,
              b = {};
            return b[new o.Z(e.overscaledZ, d, n.z, u, n.y).key] = {
              backfilled: !1
            }, b[new o.Z(e.overscaledZ, y, n.z, m, n.y).key] = {
              backfilled: !1
            }, n.y > 0 && (b[new o.Z(e.overscaledZ, d, n.z, u, n.y - 1).key] = {
              backfilled: !1
            }, b[new o.Z(e.overscaledZ, e.wrap, n.z, n.x, n.y - 1).key] = {
              backfilled: !1
            }, b[new o.Z(e.overscaledZ, y, n.z, m, n.y - 1).key] = {
              backfilled: !1
            }), n.y + 1 < s && (b[new o.Z(e.overscaledZ, d, n.z, u, n.y + 1).key] = {
              backfilled: !1
            }, b[new o.Z(e.overscaledZ, e.wrap, n.z, n.x, n.y + 1).key] = {
              backfilled: !1
            }, b[new o.Z(e.overscaledZ, y, n.z, m, n.y + 1).key] = {
              backfilled: !1
            }), b
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({
                type: "RDT",
                data: {
                  type: this.type,
                  uid: e.uid,
                  source: this.id
                }
              }))
            }))
          }
        }
        class nr extends o.E {
          constructor(e, n, s, u) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = {
              data: n.data
            }, this.actor = s.getActor(), this.setEventedParent(u), this._data = n.data, this._options = o.e({}, n), this._collectResourceTiming = n.collectResourceTiming, n.maxzoom !== void 0 && (this.maxzoom = n.maxzoom), n.type && (this.type = n.type), n.attribution && (this.attribution = n.attribution), this.promoteId = n.promoteId, n.clusterMaxZoom !== void 0 && this.maxzoom <= n.clusterMaxZoom && o.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${n.clusterMaxZoom}".`), this.workerOptions = o.e({
              source: this.id,
              cluster: n.cluster || !1,
              geojsonVtOptions: {
                buffer: this._pixelsToTileUnits(n.buffer !== void 0 ? n.buffer : 128),
                tolerance: this._pixelsToTileUnits(n.tolerance !== void 0 ? n.tolerance : .375),
                extent: o.$,
                maxZoom: this.maxzoom,
                lineMetrics: n.lineMetrics || !1,
                generateId: n.generateId || !1
              },
              superclusterOptions: {
                maxZoom: this._getClusterMaxZoom(n.clusterMaxZoom),
                minPoints: Math.max(2, n.clusterMinPoints || 2),
                extent: o.$,
                radius: this._pixelsToTileUnits(n.clusterRadius || 50),
                log: !1,
                generateId: n.generateId || !1
              },
              clusterProperties: n.clusterProperties,
              filter: n.filter
            }, n.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
          }
          _pixelsToTileUnits(e) {
            return e * (o.$ / this.tileSize)
          }
          _getClusterMaxZoom(e) {
            const n = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || o.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${n}"`), n
          }
          load() {
            return o._(this, void 0, void 0, (function*() {
              yield this._updateWorkerData()
            }))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = {
              data: e
            }, this._updateWorkerData(), this
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = o.a0(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this
          }
          getData() {
            return o._(this, void 0, void 0, (function*() {
              const e = o.e({
                type: this.type
              }, this.workerOptions);
              return this.actor.sendAsync({
                type: "GD",
                data: e
              })
            }))
          }
          getCoordinatesFromGeometry(e) {
            return e.type === "GeometryCollection" ? e.geometries.map((n => n.coordinates)).flat(1 / 0) : e.coordinates.flat(1 / 0)
          }
          getBounds() {
            return o._(this, void 0, void 0, (function*() {
              const e = new ht,
                n = yield this.getData();
              let s;
              switch (n.type) {
                case "FeatureCollection":
                  s = n.features.map((u => this.getCoordinatesFromGeometry(u.geometry))).flat(1 / 0);
                  break;
                case "Feature":
                  s = this.getCoordinatesFromGeometry(n.geometry);
                  break;
                default:
                  s = this.getCoordinatesFromGeometry(n)
              }
              if (s.length == 0) return e;
              for (let u = 0; u < s.length - 1; u += 2) e.extend([s[u], s[u + 1]]);
              return e
            }))
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom))), this._updateWorkerData(), this
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({
              type: "GCEZ",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({
              type: "GCC",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterLeaves(e, n, s) {
            return this.actor.sendAsync({
              type: "GCL",
              data: {
                type: this.type,
                source: this.id,
                clusterId: e,
                limit: n,
                offset: s
              }
            })
          }
          _updateWorkerData() {
            return o._(this, void 0, void 0, (function*() {
              if (this._isUpdatingWorker) return;
              const {
                data: e,
                diff: n
              } = this._pendingWorkerUpdate;
              if (!e && !n) return void o.w(`No data or diff provided to GeoJSONSource ${this.id}.`);
              const s = o.e({
                type: this.type
              }, this.workerOptions);
              e ? (typeof e == "string" ? (s.request = this.map._requestManager.transformRequest(xe.resolveURL(e), "Source"), s.request.collectResourceTiming = this._collectResourceTiming) : s.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : n && (s.dataDiff = n, this._pendingWorkerUpdate.diff = void 0), this._isUpdatingWorker = !0, this.fire(new o.l("dataloading", {
                dataType: "source"
              }));
              try {
                const u = yield this.actor.sendAsync({
                  type: "LD",
                  data: s
                });
                if (this._isUpdatingWorker = !1, this._removed || u.abandoned) return void this.fire(new o.l("dataabort", {
                  dataType: "source"
                }));
                this._data = u.data;
                let d = null;
                u.resourceTiming && u.resourceTiming[this.id] && (d = u.resourceTiming[this.id].slice(0));
                const m = {
                  dataType: "source"
                };
                this._collectResourceTiming && d && d.length > 0 && o.e(m, {
                  resourceTiming: d
                }), this.fire(new o.l("data", Object.assign(Object.assign({}, m), {
                  sourceDataType: "metadata"
                }))), this.fire(new o.l("data", Object.assign(Object.assign({}, m), {
                  sourceDataType: "content"
                })))
              } catch (u) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new o.l("dataabort", {
                  dataType: "source"
                }));
                this.fire(new o.k(u))
              } finally {
                (this._pendingWorkerUpdate.data || this._pendingWorkerUpdate.diff) && this._updateWorkerData()
              }
            }))
          }
          loaded() {
            return !this._isUpdatingWorker && this._pendingWorkerUpdate.data === void 0 && this._pendingWorkerUpdate.diff === void 0
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              const n = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const s = {
                type: this.type,
                uid: e.uid,
                tileID: e.tileID,
                zoom: e.tileID.overscaledZ,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                globalState: this.map.getGlobalState()
              };
              e.abortController = new AbortController;
              const u = yield this.actor.sendAsync({
                type: n,
                data: s
              }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(u, this.map.painter, n === "RT")
            }))
          }
          abortTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0
            }))
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), yield this.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              })
            }))
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({
              type: "RS",
              data: {
                type: this.type,
                source: this.id
              }
            })
          }
          serialize() {
            return o.e({}, this._options, {
              type: this.type,
              data: this._data
            })
          }
          hasTransition() {
            return !1
          }
        }
        class Bt extends o.E {
          constructor(e, n, s, u) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = s, this.coordinates = n.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(u), this.options = n
          }
          load(e) {
            return o._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new o.l("dataloading", {
                dataType: "source"
              })), this.url = this.options.url, this._request = new AbortController;
              try {
                const n = yield Fe.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, n && n.data && (this.image = n.data, e && (this.coordinates = e), this._finishLoading())
              } catch (n) {
                this._request = null, this._loaded = !0, this.fire(new o.k(n))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null
            })), this) : this
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null)
          }
          setCoordinates(e) {
            this.coordinates = e;
            const n = e.map(o.a1.fromLngLat);
            var s;
            return this.tileID = (function(u) {
              const d = o.a2.fromPoints(u),
                m = d.width(),
                y = d.height(),
                b = Math.max(m, y),
                P = Math.max(0, Math.floor(-Math.log(b) / Math.LN2)),
                M = Math.pow(2, P);
              return new o.a4(P, Math.floor((d.minX + d.maxX) / 2 * M), Math.floor((d.minY + d.maxY) / 2 * M))
            })(n), this.terrainTileRanges = this._getOverlappingTileRanges(n), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = n.map((u => this.tileID.getTilePoint(u)._round())), this.flippedWindingOrder = ((s = this.tileCoords)[1].x - s[0].x) * (s[2].y - s[0].y) - (s[1].y - s[0].y) * (s[2].x - s[0].x) < 0, this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "content"
            })), this
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context,
              n = e.gl;
            this.texture || (this.texture = new o.T(e, this.image, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
            let s = !1;
            for (const u in this.tiles) {
              const d = this.tiles[u];
              d.state !== "loaded" && (d.state = "loaded", d.texture = this.texture, s = !0)
            }
            s && this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored"
            }))
          }
          serialize() {
            return {
              type: "image",
              url: this.options.url,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return !1
          }
          _getOverlappingTileRanges(e) {
            const {
              minX: n,
              minY: s,
              maxX: u,
              maxY: d
            } = o.a2.fromPoints(e), m = {};
            for (let y = 0; y <= o.a3; y++) {
              const b = Math.pow(2, y),
                P = Math.floor(n * b),
                M = Math.floor(s * b),
                L = Math.floor(u * b),
                z = Math.floor(d * b);
              m[y] = {
                minTileX: P,
                minTileY: M,
                maxTileX: L,
                maxTileY: z
              }
            }
            return m
          }
        }
        class pr extends Bt {
          constructor(e, n, s, u) {
            super(e, n, s, u), this.roundZoom = !0, this.type = "video", this.options = n
          }
          load() {
            return o._(this, void 0, void 0, (function*() {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const n of e.urls) this.urls.push(this.map._requestManager.transformRequest(n, "Source").url);
              try {
                const n = yield o.a5(this.urls);
                if (this._loaded = !0, !n) return;
                this.video = n, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint()
                })), this.map && this.video.play(), this._finishLoading()
              } catch (n) {
                this.fire(new o.k(n))
              }
            }))
          }
          pause() {
            this.video && this.video.pause()
          }
          play() {
            this.video && this.video.play()
          }
          seek(e) {
            if (this.video) {
              const n = this.video.seekable;
              e < n.start(0) || e > n.end(0) ? this.fire(new o.k(new o.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${n.start(0)} and ${n.end(0)}-second mark.`))) : this.video.currentTime = e
            }
          }
          getVideo() {
            return this.video
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context,
              n = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, this.video)) : (this.texture = new o.T(e, this.video, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
            let s = !1;
            for (const u in this.tiles) {
              const d = this.tiles[u];
              d.state !== "loaded" && (d.state = "loaded", d.texture = this.texture, s = !0)
            }
            s && this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this.video && !this.video.paused
          }
        }
        class gr extends Bt {
          constructor(e, n, s, u) {
            super(e, n, s, u), n.coordinates ? Array.isArray(n.coordinates) && n.coordinates.length === 4 && !n.coordinates.some((d => !Array.isArray(d) || d.length !== 2 || d.some((m => typeof m != "number")))) || this.fire(new o.k(new o.a6(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.k(new o.a6(`sources.${e}`, null, 'missing required property "coordinates"'))), n.animate && typeof n.animate != "boolean" && this.fire(new o.k(new o.a6(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), n.canvas ? typeof n.canvas == "string" || n.canvas instanceof HTMLCanvasElement || this.fire(new o.k(new o.a6(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.k(new o.a6(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = n, this.animate = n.animate === void 0 || n.animate
          }
          load() {
            return o._(this, void 0, void 0, (function*() {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint()
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1)
              }, this._finishLoading())
            }))
          }
          getCanvas() {
            return this.canvas
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play()
          }
          onRemove() {
            this.pause()
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const n = this.map.painter.context,
              s = n.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
              premultiply: !0
            }) : this.texture = new o.T(n, this.canvas, s.RGBA, {
              premultiply: !0
            });
            let u = !1;
            for (const d in this.tiles) {
              const m = this.tiles[d];
              m.state !== "loaded" && (m.state = "loaded", m.texture = this.texture, u = !0)
            }
            u && this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "canvas",
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this._playing
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height])
              if (isNaN(e) || e <= 0) return !0;
            return !1
          }
        }
        const Sr = {},
          Vr = h => {
            switch (h) {
              case "geojson":
                return nr;
              case "image":
                return Bt;
              case "raster":
                return Jt;
              case "raster-dem":
                return dr;
              case "vector":
                return tr;
              case "video":
                return pr;
              case "canvas":
                return gr
            }
            return Sr[h]
          },
          ur = "RTLPluginLoaded";
        class Pr extends o.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = st()
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", {
              pluginStatus: e,
              pluginURL: this.url
            }).catch((n => {
              throw this.status = "error", n
            }))
          }
          getRTLTextPluginStatus() {
            return this.status
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null
          }
          setRTLTextPlugin(e) {
            return o._(this, arguments, void 0, (function*(n, s = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = xe.resolveURL(n), !this.url) throw new Error(`requested url ${n} is invalid`);
              if (this.status === "unavailable") {
                if (!s) return this._requestImport();
                this.status = "deferred", this._syncState(this.status)
              } else if (this.status === "requested") return this._requestImport()
            }))
          }
          _requestImport() {
            return o._(this, void 0, void 0, (function*() {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new o.l(ur))
            }))
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
          }
        }
        let Ir = null;

        function Mr() {
          return Ir || (Ir = new Pr), Ir
        }
        class Nr {
          constructor(e, n) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = o.a7(), this.uses = 0, this.tileSize = n, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading"
          }
          registerFadeDuration(e) {
            const n = e + this.timeAdded;
            n < this.fadeEndTime || (this.fadeEndTime = n)
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null
          }
          loadVectorData(e, n, s) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(u, d) {
                const m = {};
                if (!d) return m;
                for (const y of u) {
                  const b = y.layerIds.map((P => d.getLayer(P))).filter(Boolean);
                  if (b.length !== 0) {
                    y.layers = b, y.stateDependentLayerIds && (y.stateDependentLayers = y.stateDependentLayerIds.map((P => b.filter((M => M.id === P))[0])));
                    for (const P of b) m[P.id] = y
                  }
                }
                return m
              })(e.buckets, n == null ? void 0 : n.style), this.hasSymbolBuckets = !1;
              for (const u in this.buckets) {
                const d = this.buckets[u];
                if (d instanceof o.a9) {
                  if (this.hasSymbolBuckets = !0, !s) break;
                  d.justReloaded = !0
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets)
                for (const u in this.buckets) {
                  const d = this.buckets[u];
                  if (d instanceof o.a9 && d.hasRTLText) {
                    this.hasRTLText = !0, Mr().lazyLoad();
                    break
                  }
                }
              this.queryPadding = 0;
              for (const u in this.buckets) {
                const d = this.buckets[u];
                this.queryPadding = Math.max(this.queryPadding, n.style.getLayer(u).queryRadius(d))
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage)
            } else this.collisionBoxArray = new o.a8
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded"
          }
          getBucket(e) {
            return this.buckets[e.id]
          }
          upload(e) {
            for (const s in this.buckets) {
              const u = this.buckets[s];
              u.uploadPending() && u.upload(e)
            }
            const n = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new o.T(e, this.imageAtlas.image, n.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new o.T(e, this.glyphAtlasImage, n.ALPHA), this.glyphAtlasImage = null)
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
          }
          queryRenderedFeatures(e, n, s, u, d, m, y, b, P, M, L) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
              queryGeometry: u,
              cameraQueryGeometry: d,
              scale: m,
              tileSize: this.tileSize,
              pixelPosMatrix: M,
              transform: b,
              params: y,
              queryPadding: this.queryPadding * P,
              getElevation: L
            }, e, n, s) : {}
          }
          querySourceFeatures(e, n) {
            const s = this.latestFeatureIndex;
            if (!s || !s.rawTileData) return;
            const u = s.loadVTLayers(),
              d = n && n.sourceLayer ? n.sourceLayer : "",
              m = u._geojsonTileLayer || u[d];
            if (!m) return;
            const y = o.aa(n && n.filter),
              {
                z: b,
                x: P,
                y: M
              } = this.tileID.canonical,
              L = {
                z: b,
                x: P,
                y: M
              };
            for (let z = 0; z < m.length; z++) {
              const B = m.feature(z);
              if (y.needGeometry) {
                const J = o.ab(B, !0);
                if (!y.filter(new o.F(this.tileID.overscaledZ), J, this.tileID.canonical)) continue
              } else if (!y.filter(new o.F(this.tileID.overscaledZ), B)) continue;
              const U = s.getId(B, d),
                Q = new o.ac(B, b, P, M, U);
              Q.tile = L, e.push(Q)
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
          }
          setExpiryData(e) {
            const n = this.expirationTime;
            if (e.cacheControl) {
              const s = o.ad(e.cacheControl);
              s["max-age"] && (this.expirationTime = Date.now() + 1e3 * s["max-age"])
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const s = Date.now();
              let u = !1;
              if (this.expirationTime > s) u = !1;
              else if (n)
                if (this.expirationTime < n) u = !0;
                else {
                  const d = this.expirationTime - n;
                  d ? this.expirationTime = s + Math.max(d, 3e4) : u = !0
                }
              else u = !0;
              u ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
          }
          setFeatureState(e, n) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const s = this.latestFeatureIndex.loadVTLayers();
            for (const u in this.buckets) {
              if (!n.style.hasLayer(u)) continue;
              const d = this.buckets[u],
                m = d.layers[0].sourceLayer || "_geojsonTileLayer",
                y = s[m],
                b = e[m];
              if (!y || !b || Object.keys(b).length === 0) continue;
              d.update(b, y, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const P = n && n.style && n.style.getLayer(u);
              P && (this.queryPadding = Math.max(this.queryPadding, P.queryRadius(d)))
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < xe.now()
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0
          }
          setHoldDuration(e) {
            this.symbolFadeHoldUntil = xe.now() + e
          }
          setDependencies(e, n) {
            const s = {};
            for (const u of n) s[u] = !0;
            this.dependencies[e] = s
          }
          hasDependency(e, n) {
            for (const s of e) {
              const u = this.dependencies[s];
              if (u) {
                for (const d of n)
                  if (u[d]) return !0
              }
            }
            return !1
          }
        }
        class ce {
          constructor(e, n) {
            this.max = e, this.onRemove = n, this.reset()
          }
          reset() {
            for (const e in this.data)
              for (const n of this.data[e]) n.timeout && clearTimeout(n.timeout), this.onRemove(n.value);
            return this.data = {}, this.order = [], this
          }
          add(e, n, s) {
            const u = e.wrapped().key;
            this.data[u] === void 0 && (this.data[u] = []);
            const d = {
              value: n,
              timeout: void 0
            };
            if (s !== void 0 && (d.timeout = setTimeout((() => {
                this.remove(e, d)
              }), s)), this.data[u].push(d), this.order.push(u), this.order.length > this.max) {
              const m = this._getAndRemoveByKey(this.order[0]);
              m && this.onRemove(m)
            }
            return this
          }
          has(e) {
            return e.wrapped().key in this.data
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
          }
          _getAndRemoveByKey(e) {
            const n = this.data[e].shift();
            return n.timeout && clearTimeout(n.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), n.value
          }
          getByKey(e) {
            const n = this.data[e];
            return n ? n[0].value : null
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null
          }
          remove(e, n) {
            if (!this.has(e)) return this;
            const s = e.wrapped().key,
              u = n === void 0 ? 0 : this.data[s].indexOf(n),
              d = this.data[s][u];
            return this.data[s].splice(u, 1), d.timeout && clearTimeout(d.timeout), this.data[s].length === 0 && delete this.data[s], this.onRemove(d.value), this.order.splice(this.order.indexOf(s), 1), this
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max;) {
              const n = this._getAndRemoveByKey(this.order[0]);
              n && this.onRemove(n)
            }
            return this
          }
          filter(e) {
            const n = [];
            for (const s in this.data)
              for (const u of this.data[s]) e(u.value) || n.push(u);
            for (const s of n) this.remove(s.value.tileID, s)
          }
        }
        class F {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {}
          }
          updateState(e, n, s) {
            const u = String(n);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][u] = this.stateChanges[e][u] || {}, o.e(this.stateChanges[e][u], s), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const d in this.state[e]) d !== u && (this.deletedStates[e][d] = null)
            } else if (this.deletedStates[e] && this.deletedStates[e][u] === null) {
              this.deletedStates[e][u] = {};
              for (const d in this.state[e][u]) s[d] || (this.deletedStates[e][u][d] = null)
            } else
              for (const d in s) this.deletedStates[e] && this.deletedStates[e][u] && this.deletedStates[e][u][d] === null && delete this.deletedStates[e][u][d]
          }
          removeFeatureState(e, n, s) {
            if (this.deletedStates[e] === null) return;
            const u = String(n);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, s && n !== void 0) this.deletedStates[e][u] !== null && (this.deletedStates[e][u] = this.deletedStates[e][u] || {}, this.deletedStates[e][u][s] = null);
            else if (n !== void 0)
              if (this.stateChanges[e] && this.stateChanges[e][u])
                for (s in this.deletedStates[e][u] = {}, this.stateChanges[e][u]) this.deletedStates[e][u][s] = null;
              else this.deletedStates[e][u] = null;
            else this.deletedStates[e] = null
          }
          getState(e, n) {
            const s = String(n),
              u = o.e({}, (this.state[e] || {})[s], (this.stateChanges[e] || {})[s]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const d = this.deletedStates[e][n];
              if (d === null) return {};
              for (const m in d) delete u[m]
            }
            return u
          }
          initializeTileState(e, n) {
            e.setFeatureState(this.state, n)
          }
          coalesceChanges(e, n) {
            const s = {};
            for (const u in this.stateChanges) {
              this.state[u] = this.state[u] || {};
              const d = {};
              for (const m in this.stateChanges[u]) this.state[u][m] || (this.state[u][m] = {}), o.e(this.state[u][m], this.stateChanges[u][m]), d[m] = this.state[u][m];
              s[u] = d
            }
            for (const u in this.deletedStates) {
              this.state[u] = this.state[u] || {};
              const d = {};
              if (this.deletedStates[u] === null)
                for (const m in this.state[u]) d[m] = {}, this.state[u][m] = {};
              else
                for (const m in this.deletedStates[u]) {
                  if (this.deletedStates[u][m] === null) this.state[u][m] = {};
                  else
                    for (const y of Object.keys(this.deletedStates[u][m])) delete this.state[u][m][y];
                  d[m] = this.state[u][m]
                }
              s[u] = s[u] || {}, o.e(s[u], d)
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(s).length !== 0)
              for (const u in e) e[u].setFeatureState(s, n)
          }
        }
        const q = 89.25;

        function $(h, e) {
          const n = o.ah(e.lat, -o.ai, o.ai);
          return new o.P(o.V(e.lng) * h, o.U(n) * h)
        }

        function X(h, e) {
          return new o.a1(e.x / h, e.y / h).toLngLat()
        }

        function oe(h) {
          return h.cameraToCenterDistance * Math.min(.85 * Math.tan(o.ae(90 - h.pitch)), Math.tan(o.ae(q - h.pitch)))
        }

        function me(h, e) {
          const n = h.canonical,
            s = e / o.af(n.z),
            u = n.x + Math.pow(2, n.z) * h.wrap,
            d = o.ag(new Float64Array(16));
          return o.M(d, d, [u * s, n.y * s, 0]), o.N(d, d, [s / o.$, s / o.$, 1]), d
        }

        function Ee(h, e, n, s, u) {
          const d = o.a1.fromLngLat(h, e),
            m = u * o.aj(1, h.lat),
            y = m * Math.cos(o.ae(n)),
            b = Math.sqrt(m * m - y * y),
            P = b * Math.sin(o.ae(-s)),
            M = b * Math.cos(o.ae(-s));
          return new o.a1(d.x + P, d.y + M, d.z + y)
        }

        function Te(h, e, n) {
          const s = e.intersectsFrustum(h);
          if (!n || s === 0) return s;
          const u = e.intersectsPlane(n);
          return u === 0 ? 0 : s === 2 && u === 2 ? 2 : 1
        }

        function Ze(h, e, n) {
          let s = 0;
          const u = (n - e) / 10;
          for (let d = 0; d < 10; d++) s += u * Math.pow(Math.cos(e + (d + .5) / 10 * (n - e)), h);
          return s
        }

        function it(h, e) {
          return function(n, s, u, d, m) {
            const y = 2 * ((h - 1) / o.ak(Math.cos(o.ae(q - m)) / Math.cos(o.ae(q))) - 1),
              b = Math.acos(u / d),
              P = 2 * Ze(y - 1, 0, o.ae(m / 2)),
              M = Math.min(o.ae(q), b + o.ae(m / 2)),
              L = Ze(y - 1, Math.min(M, b - o.ae(m / 2)), M),
              z = Math.atan(s / u),
              B = Math.hypot(s, u);
            let U = n;
            return U += o.ak(d / B / Math.max(.5, Math.cos(o.ae(m / 2)))), U += y * o.ak(Math.cos(z)) / 2, U -= o.ak(Math.max(1, L / P / e)) / 2, U
          }
        }
        const $e = it(9.314, 3);

        function kt(h, e) {
          const n = (e.roundZoom ? Math.round : Math.floor)(h.zoom + o.ak(h.tileSize / e.tileSize));
          return Math.max(0, n)
        }

        function ye(h, e) {
          const n = h.getCameraFrustum(),
            s = h.getClippingPlane(),
            u = h.screenPointToMercatorCoordinate(h.getCameraPoint()),
            d = o.a1.fromLngLat(h.center, h.elevation);
          u.z = d.z + Math.cos(h.pitchInRadians) * h.cameraToCenterDistance / h.worldSize;
          const m = h.getCoveringTilesDetailsProvider(),
            y = m.allowVariableZoom(h, e),
            b = kt(h, e),
            P = e.minzoom || 0,
            M = e.maxzoom !== void 0 ? e.maxzoom : h.maxZoom,
            L = Math.min(Math.max(0, b), M),
            z = Math.pow(2, L),
            B = [z * u.x, z * u.y, 0],
            U = [z * d.x, z * d.y, 0],
            Q = Math.hypot(d.x - u.x, d.y - u.y),
            J = Math.abs(d.z - u.z),
            re = Math.hypot(Q, J),
            se = ge => ({
              zoom: 0,
              x: 0,
              y: 0,
              wrap: ge,
              fullyVisible: !1
            }),
            de = [],
            ue = [];
          if (h.renderWorldCopies && m.allowWorldCopies())
            for (let ge = 1; ge <= 3; ge++) de.push(se(-ge)), de.push(se(ge));
          for (de.push(se(0)); de.length > 0;) {
            const ge = de.pop(),
              we = ge.x,
              he = ge.y;
            let ze = ge.fullyVisible;
            const He = {
                x: we,
                y: he,
                z: ge.zoom
              },
              Ne = m.getTileBoundingVolume(He, ge.wrap, h.elevation, e);
            if (!ze) {
              const Ft = Te(n, Ne, s);
              if (Ft === 0) continue;
              ze = Ft === 2
            }
            const qe = m.distanceToTile2d(u.x, u.y, He, Ne);
            let Ge = b;
            y && (Ge = (e.calculateTileZoom || $e)(h.zoom + o.ak(h.tileSize / e.tileSize), qe, J, re, h.fov)), Ge = (e.roundZoom ? Math.round : Math.floor)(Ge), Ge = Math.max(0, Ge);
            const Dt = Math.min(Ge, M);
            if (ge.wrap = m.getWrap(d, He, ge.wrap), ge.zoom >= Dt) {
              if (ge.zoom < P) continue;
              const Ft = L - ge.zoom,
                vt = B[0] - .5 - (we << Ft),
                sr = B[1] - .5 - (he << Ft),
                Kr = e.reparseOverscaled ? Math.max(ge.zoom, Ge) : ge.zoom;
              ue.push({
                tileID: new o.Z(ge.zoom === M ? Kr : ge.zoom, ge.wrap, ge.zoom, we, he),
                distanceSq: o.al([U[0] - .5 - we, U[1] - .5 - he]),
                tileDistanceToCamera: Math.sqrt(vt * vt + sr * sr)
              })
            } else
              for (let Ft = 0; Ft < 4; Ft++) de.push({
                zoom: ge.zoom + 1,
                x: (we << 1) + Ft % 2,
                y: (he << 1) + (Ft >> 1),
                wrap: ge.wrap,
                fullyVisible: ze
              })
          }
          return ue.sort(((ge, we) => ge.distanceSq - we.distanceSq)).map((ge => ge.tileID))
        }
        const Xt = o.a2.fromPoints([new o.P(0, 0), new o.P(o.$, o.$)]);
        class Ht extends o.E {
          constructor(e, n, s) {
            super(), this.id = e, this.dispatcher = s, this.on("data", (u => this._dataHandler(u))), this.on("dataloading", (() => {
              this._sourceErrored = !1
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded()
            })), this._source = ((u, d, m, y) => {
              const b = new(Vr(d.type))(u, d, m, y);
              if (b.id !== u) throw new Error(`Expected Source id to be ${u} instead of ${b.id}`);
              return b
            })(e, n, s, this), this._tiles = {}, this._cache = new ce(0, (u => this._unloadTile(u))), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new F, this._didEmitContent = !1, this._updated = !1
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e)
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e)
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const n = this._tiles[e];
              if (n.state !== "loaded" && n.state !== "errored") return !1
            }
            return !0
          }
          getSource() {
            return this._source
          }
          pause() {
            this._paused = !0
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain)
          }
          _loadTile(e, n, s) {
            return o._(this, void 0, void 0, (function*() {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, n, s)
              } catch (u) {
                e.state = "errored", u.status !== 404 ? this._source.fire(new o.k(u, {
                  tile: e
                })) : this.update(this.transform, this.terrain)
              }
            }))
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e)
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new o.l("dataabort", {
              tile: e,
              coord: e.tileID,
              dataType: "source"
            }))
          }
          serialize() {
            return this._source.serialize()
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const n in this._tiles) {
              const s = this._tiles[n];
              s.upload(e), s.prepare(this.map.style.imageManager)
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e => e.tileID)).sort(pt).map((e => e.key))
          }
          getRenderableIds(e) {
            const n = [];
            for (const s in this._tiles) this._isIdRenderable(s, e) && n.push(this._tiles[s]);
            return e ? n.sort(((s, u) => {
              const d = s.tileID,
                m = u.tileID,
                y = new o.P(d.canonical.x, d.canonical.y)._rotate(-this.transform.bearingInRadians),
                b = new o.P(m.canonical.x, m.canonical.y)._rotate(-this.transform.bearingInRadians);
              return d.overscaledZ - m.overscaledZ || b.y - y.y || b.x - y.x
            })).map((s => s.tileID.key)) : n.map((s => s.tileID)).sort(pt).map((s => s.key))
          }
          hasRenderableParent(e) {
            const n = this.findLoadedParent(e, 0);
            return !!n && this._isIdRenderable(n.tileID.key)
          }
          _isIdRenderable(e, n) {
            return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (n || !this._tiles[e].holdingForFade())
          }
          reload(e) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const n in this._tiles) e ? this._reloadTile(n, "expired") : this._tiles[n].state !== "errored" && this._reloadTile(n, "reloading")
            }
          }
          _reloadTile(e, n) {
            return o._(this, void 0, void 0, (function*() {
              const s = this._tiles[e];
              s && (s.state !== "loading" && (s.state = n), yield this._loadTile(s, e, n))
            }))
          }
          _tileLoaded(e, n, s) {
            e.timeAdded = xe.now(), s === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(n, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new o.l("data", {
              dataType: "source",
              tile: e,
              coord: e.tileID
            }))
          }
          _backfillDEM(e) {
            const n = this.getRenderableIds();
            for (let u = 0; u < n.length; u++) {
              const d = n[u];
              if (e.neighboringTiles && e.neighboringTiles[d]) {
                const m = this.getTileByID(d);
                s(e, m), s(m, e)
              }
            }

            function s(u, d) {
              u.needsHillshadePrepare = !0, u.needsTerrainPrepare = !0;
              let m = d.tileID.canonical.x - u.tileID.canonical.x;
              const y = d.tileID.canonical.y - u.tileID.canonical.y,
                b = Math.pow(2, u.tileID.canonical.z),
                P = d.tileID.key;
              m === 0 && y === 0 || Math.abs(y) > 1 || (Math.abs(m) > 1 && (Math.abs(m + b) === 1 ? m += b : Math.abs(m - b) === 1 && (m -= b)), d.dem && u.dem && (u.dem.backfillBorder(d.dem, m, y), u.neighboringTiles && u.neighboringTiles[P] && (u.neighboringTiles[P].backfilled = !0)))
            }
          }
          getTile(e) {
            return this.getTileByID(e.key)
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          _retainLoadedChildren(e, n, s, u) {
            for (const d in this._tiles) {
              let m = this._tiles[d];
              if (u[d] || !m.hasData() || m.tileID.overscaledZ <= n || m.tileID.overscaledZ > s) continue;
              let y = m.tileID;
              for (; m && m.tileID.overscaledZ > n + 1;) {
                const P = m.tileID.scaledTo(m.tileID.overscaledZ - 1);
                m = this._tiles[P.key], m && m.hasData() && (y = P)
              }
              let b = y;
              for (; b.overscaledZ > n;)
                if (b = b.scaledTo(b.overscaledZ - 1), e[b.key] || e[b.canonical.key]) {
                  u[y.key] = y;
                  break
                }
            }
          }
          findLoadedParent(e, n) {
            if (e.key in this._loadedParentTiles) {
              const s = this._loadedParentTiles[e.key];
              return s && s.tileID.overscaledZ >= n ? s : null
            }
            for (let s = e.overscaledZ - 1; s >= n; s--) {
              const u = e.scaledTo(s),
                d = this._getLoadedTile(u);
              if (d) return d
            }
          }
          findLoadedSibling(e) {
            return this._getLoadedTile(e)
          }
          _getLoadedTile(e) {
            const n = this._tiles[e.key];
            return n && n.hasData() ? n : this._cache.getByKey(e.wrapped().key)
          }
          updateCacheSize(e) {
            const n = Math.ceil(e.width / this._source.tileSize) + 1,
              s = Math.ceil(e.height / this._source.tileSize) + 1,
              u = Math.floor(n * s * (this._maxTileCacheZoomLevels === null ? o.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)),
              d = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, u) : u;
            this._cache.setMaxSize(d)
          }
          handleWrapJump(e) {
            const n = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, n) {
              const s = {};
              for (const u in this._tiles) {
                const d = this._tiles[u];
                d.tileID = d.tileID.unwrapTo(d.tileID.wrap + n), s[d.tileID.key] = d
              }
              this._tiles = s;
              for (const u in this._timers) clearTimeout(this._timers[u]), delete this._timers[u];
              for (const u in this._tiles) this._setTileReloadTimer(u, this._tiles[u])
            }
          }
          _updateCoveredAndRetainedTiles(e, n, s, u, d, m) {
            const y = {},
              b = {},
              P = Object.keys(e),
              M = xe.now();
            for (const L of P) {
              const z = e[L],
                B = this._tiles[L];
              if (!B || B.fadeEndTime !== 0 && B.fadeEndTime <= M) continue;
              const U = this.findLoadedParent(z, n),
                Q = this.findLoadedSibling(z),
                J = U || Q || null;
              J && (this._addTile(J.tileID), y[J.tileID.key] = J.tileID), b[L] = z
            }
            this._retainLoadedChildren(b, u, s, e);
            for (const L in y) e[L] || (this._coveredTiles[L] = !0, e[L] = y[L]);
            if (m) {
              const L = {},
                z = {};
              for (const B of d) this._tiles[B.key].hasData() ? L[B.key] = B : z[B.key] = B;
              for (const B in z) {
                const U = z[B].children(this._source.maxzoom);
                this._tiles[U[0].key] && this._tiles[U[1].key] && this._tiles[U[2].key] && this._tiles[U[3].key] && (L[U[0].key] = e[U[0].key] = U[0], L[U[1].key] = e[U[1].key] = U[1], L[U[2].key] = e[U[2].key] = U[2], L[U[3].key] = e[U[3].key] = U[3], delete z[B])
              }
              for (const B in z) {
                const U = z[B],
                  Q = this.findLoadedParent(U, this._source.minzoom),
                  J = this.findLoadedSibling(U),
                  re = Q || J || null;
                if (re) {
                  L[re.tileID.key] = e[re.tileID.key] = re.tileID;
                  for (const se in L) L[se].isChildOf(re.tileID) && delete L[se]
                }
              }
              for (const B in this._tiles) L[B] || (this._coveredTiles[B] = !0)
            }
          }
          update(e, n) {
            if (!this._sourceLoaded || this._paused) return;
            let s;
            this.transform = e, this.terrain = n, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? s = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((M => new o.Z(M.canonical.z, M.wrap, M.canonical.z, M.canonical.x, M.canonical.y))) : (s = ye(e, {
              tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
              minzoom: this._source.minzoom,
              maxzoom: this._source.maxzoom,
              roundZoom: !this.usedForTerrain && this._source.roundZoom,
              reparseOverscaled: this._source.reparseOverscaled,
              terrain: n,
              calculateTileZoom: this._source.calculateTileZoom
            }), this._source.hasTile && (s = s.filter((M => this._source.hasTile(M))))) : s = [];
            const u = kt(e, this._source),
              d = Math.max(u - Ht.maxOverzooming, this._source.minzoom),
              m = Math.max(u + Ht.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const M = {};
              for (const L of s)
                if (L.canonical.z > this._source.minzoom) {
                  const z = L.scaledTo(L.canonical.z - 1);
                  M[z.key] = z;
                  const B = L.scaledTo(Math.max(this._source.minzoom, Math.min(L.canonical.z, 5)));
                  M[B.key] = B
                } s = s.concat(Object.values(M))
            }
            const y = s.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, y && this.fire(new o.l("data", {
              sourceDataType: "idle",
              dataType: "source",
              sourceId: this.id
            }));
            const b = this._updateRetainedTiles(s, u);
            bt(this._source.type) && this._updateCoveredAndRetainedTiles(b, d, m, u, s, n);
            for (const M in b) this._tiles[M].clearFadeHold();
            const P = o.am(this._tiles, b);
            for (const M of P) {
              const L = this._tiles[M];
              L.hasSymbolBuckets && !L.holdingForFade() ? L.setHoldDuration(this.map._fadeDuration) : L.hasSymbolBuckets && !L.symbolFadeFinished() || this._removeTile(M)
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache()
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e)
          }
          _updateRetainedTiles(e, n) {
            var s;
            const u = {},
              d = {},
              m = Math.max(n - Ht.maxOverzooming, this._source.minzoom),
              y = Math.max(n + Ht.maxUnderzooming, this._source.minzoom),
              b = {};
            for (const P of e) {
              const M = this._addTile(P);
              u[P.key] = P, M.hasData() || n < this._source.maxzoom && (b[P.key] = P)
            }
            this._retainLoadedChildren(b, n, y, u);
            for (const P of e) {
              let M = this._tiles[P.key];
              if (M.hasData()) continue;
              if (n + 1 > this._source.maxzoom) {
                const z = P.children(this._source.maxzoom)[0],
                  B = this.getTile(z);
                if (B && B.hasData()) {
                  u[z.key] = z;
                  continue
                }
              } else {
                const z = P.children(this._source.maxzoom);
                if (u[z[0].key] && u[z[1].key] && u[z[2].key] && u[z[3].key]) continue
              }
              let L = M.wasRequested();
              for (let z = P.overscaledZ - 1; z >= m; --z) {
                const B = P.scaledTo(z);
                if (d[B.key]) break;
                if (d[B.key] = !0, M = this.getTile(B), !M && L && (M = this._addTile(B)), M) {
                  const U = M.hasData();
                  if ((U || !(!((s = this.map) === null || s === void 0) && s.cancelPendingTileRequestsWhileZooming) || L) && (u[B.key] = B), L = M.wasRequested(), U) break
                }
              }
            }
            return u
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e in this._tiles) {
              const n = [];
              let s, u = this._tiles[e].tileID;
              for (; u.overscaledZ > 0;) {
                if (u.key in this._loadedParentTiles) {
                  s = this._loadedParentTiles[u.key];
                  break
                }
                n.push(u.key);
                const d = u.scaledTo(u.overscaledZ - 1);
                if (s = this._getLoadedTile(d), s) break;
                u = d
              }
              for (const d of n) this._loadedParentTiles[d] = s
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const e in this._tiles) {
              const n = this._tiles[e].tileID,
                s = this._getLoadedTile(n);
              this._loadedSiblingTiles[n.key] = s
            }
          }
          _addTile(e) {
            let n = this._tiles[e.key];
            if (n) return n;
            n = this._cache.getAndRemove(e), n && (this._setTileReloadTimer(e.key, n), n.tileID = e, this._state.initializeTileState(n, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, n)));
            const s = n;
            return n || (n = new Nr(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(n, e.key, n.state)), n.uses++, this._tiles[e.key] = n, s || this._source.fire(new o.l("dataloading", {
              tile: n,
              coord: n.tileID,
              dataType: "source"
            })), n
          }
          _setTileReloadTimer(e, n) {
            e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
            const s = n.getExpiryTimeout();
            s && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e]
            }), s))
          }
          refreshTiles(e) {
            for (const n in this._tiles)(this._isIdRenderable(n) || this._tiles[n].state == "errored") && e.some((s => s.equals(this._tiles[n].tileID.canonical))) && this._reloadTile(n, "expired")
          }
          _removeTile(e) {
            const n = this._tiles[e];
            n && (n.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), n.uses > 0 || (n.hasData() && n.state !== "reloading" ? this._cache.add(n.tileID, n, n.getExpiryTimeout()) : (n.aborted = !0, this._abortTile(n), this._unloadTile(n))))
          }
          _dataHandler(e) {
            const n = e.sourceDataType;
            e.dataType === "source" && n === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && e.dataType === "source" && n === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0)
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset()
          }
          tilesIn(e, n, s) {
            const u = [],
              d = this.transform;
            if (!d) return u;
            const m = d.getCoveringTilesDetailsProvider().allowWorldCopies(),
              y = s ? d.getCameraQueryGeometry(e) : e,
              b = B => d.screenPointToMercatorCoordinate(B, this.terrain),
              P = this.transformBbox(e, b, !m),
              M = this.transformBbox(y, b, !m),
              L = this.getIds(),
              z = o.a2.fromPoints(M);
            for (let B = 0; B < L.length; B++) {
              const U = this._tiles[L[B]];
              if (U.holdingForFade()) continue;
              const Q = m ? [U.tileID] : [U.tileID.unwrapTo(-1), U.tileID.unwrapTo(0)],
                J = Math.pow(2, d.zoom - U.tileID.overscaledZ),
                re = n * U.queryPadding * o.$ / U.tileSize / J;
              for (const se of Q) {
                const de = z.map((ue => se.getTilePoint(new o.a1(ue.x, ue.y))));
                if (de.expandBy(re), de.intersects(Xt)) {
                  const ue = P.map((we => se.getTilePoint(we))),
                    ge = M.map((we => se.getTilePoint(we)));
                  u.push({
                    tile: U,
                    tileID: m ? se : se.unwrapTo(0),
                    queryGeometry: ue,
                    cameraQueryGeometry: ge,
                    scale: J
                  })
                }
              }
            }
            return u
          }
          transformBbox(e, n, s) {
            let u = e.map(n);
            if (s) {
              const d = o.a2.fromPoints(e);
              d.shrinkBy(.001 * Math.min(d.width(), d.height()));
              const m = d.map(n);
              o.a2.fromPoints(u).covers(m) || (u = u.map((y => y.x > .5 ? new o.a1(y.x - 1, y.y, y.z) : y)))
            }
            return u
          }
          getVisibleCoordinates(e) {
            const n = this.getRenderableIds(e).map((s => this._tiles[s].tileID));
            return this.transform && this.transform.populateCache(n), n
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (bt(this._source.type)) {
              const e = xe.now();
              for (const n in this._tiles)
                if (this._tiles[n].fadeEndTime >= e) return !0
            }
            return !1
          }
          setFeatureState(e, n, s) {
            this._state.updateState(e = e || "_geojsonTileLayer", n, s)
          }
          removeFeatureState(e, n, s) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", n, s)
          }
          getFeatureState(e, n) {
            return this._state.getState(e = e || "_geojsonTileLayer", n)
          }
          setDependencies(e, n, s) {
            const u = this._tiles[e];
            u && u.setDependencies(n, s)
          }
          reloadTilesForDependencies(e, n) {
            for (const s in this._tiles) this._tiles[s].hasDependency(e, n) && this._reloadTile(s, "reloading");
            this._cache.filter((s => !s.hasDependency(e, n)))
          }
        }

        function pt(h, e) {
          const n = Math.abs(2 * h.wrap) - +(h.wrap < 0),
            s = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return h.overscaledZ - e.overscaledZ || s - n || e.canonical.y - h.canonical.y || e.canonical.x - h.canonical.x
        }

        function bt(h) {
          return h === "raster" || h === "image" || h === "video"
        }
        Ht.maxOverzooming = 10, Ht.maxUnderzooming = 3;
        class ar {
          constructor(e, n) {
            this.reset(e, n)
          }
          reset(e, n) {
            this.points = e || [], this._distances = [0];
            for (let s = 1; s < this.points.length; s++) this._distances[s] = this._distances[s - 1] + this.points[s].dist(this.points[s - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(n || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = o.ah(e, 0, 1);
            let n = 1,
              s = this._distances[n];
            const u = e * this.paddedLength + this.padding;
            for (; s < u && n < this._distances.length;) s = this._distances[++n];
            const d = n - 1,
              m = this._distances[d],
              y = s - m,
              b = y > 0 ? (u - m) / y : 0;
            return this.points[d].mult(1 - b).add(this.points[n].mult(b))
          }
        }

        function jr(h, e) {
          let n = !0;
          return h === "always" || h !== "never" && e !== "never" || (n = !1), n
        }
        class qr {
          constructor(e, n, s) {
            const u = this.boxCells = [],
              d = this.circleCells = [];
            this.xCellCount = Math.ceil(e / s), this.yCellCount = Math.ceil(n / s);
            for (let m = 0; m < this.xCellCount * this.yCellCount; m++) u.push([]), d.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = n, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / n, this.boxUid = 0, this.circleUid = 0
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length
          }
          insert(e, n, s, u, d) {
            this._forEachCell(n, s, u, d, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(n), this.bboxes.push(s), this.bboxes.push(u), this.bboxes.push(d)
          }
          insertCircle(e, n, s, u) {
            this._forEachCell(n - u, s - u, n + u, s + u, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(n), this.circles.push(s), this.circles.push(u)
          }
          _insertBoxCell(e, n, s, u, d, m) {
            this.boxCells[d].push(m)
          }
          _insertCircleCell(e, n, s, u, d, m) {
            this.circleCells[d].push(m)
          }
          _query(e, n, s, u, d, m, y) {
            if (s < 0 || e > this.width || u < 0 || n > this.height) return [];
            const b = [];
            if (e <= 0 && n <= 0 && this.width <= s && this.height <= u) {
              if (d) return [{
                key: null,
                x1: e,
                y1: n,
                x2: s,
                y2: u
              }];
              for (let P = 0; P < this.boxKeys.length; P++) b.push({
                key: this.boxKeys[P],
                x1: this.bboxes[4 * P],
                y1: this.bboxes[4 * P + 1],
                x2: this.bboxes[4 * P + 2],
                y2: this.bboxes[4 * P + 3]
              });
              for (let P = 0; P < this.circleKeys.length; P++) {
                const M = this.circles[3 * P],
                  L = this.circles[3 * P + 1],
                  z = this.circles[3 * P + 2];
                b.push({
                  key: this.circleKeys[P],
                  x1: M - z,
                  y1: L - z,
                  x2: M + z,
                  y2: L + z
                })
              }
            } else this._forEachCell(e, n, s, u, this._queryCell, b, {
              hitTest: d,
              overlapMode: m,
              seenUids: {
                box: {},
                circle: {}
              }
            }, y);
            return b
          }
          query(e, n, s, u) {
            return this._query(e, n, s, u, !1, null)
          }
          hitTest(e, n, s, u, d, m) {
            return this._query(e, n, s, u, !0, d, m).length > 0
          }
          hitTestCircle(e, n, s, u, d) {
            const m = e - s,
              y = e + s,
              b = n - s,
              P = n + s;
            if (y < 0 || m > this.width || P < 0 || b > this.height) return !1;
            const M = [];
            return this._forEachCell(m, b, y, P, this._queryCellCircle, M, {
              hitTest: !0,
              overlapMode: u,
              circle: {
                x: e,
                y: n,
                radius: s
              },
              seenUids: {
                box: {},
                circle: {}
              }
            }, d), M.length > 0
          }
          _queryCell(e, n, s, u, d, m, y, b) {
            const {
              seenUids: P,
              hitTest: M,
              overlapMode: L
            } = y, z = this.boxCells[d];
            if (z !== null) {
              const U = this.bboxes;
              for (const Q of z)
                if (!P.box[Q]) {
                  P.box[Q] = !0;
                  const J = 4 * Q,
                    re = this.boxKeys[Q];
                  if (e <= U[J + 2] && n <= U[J + 3] && s >= U[J + 0] && u >= U[J + 1] && (!b || b(re)) && (!M || !jr(L, re.overlapMode)) && (m.push({
                      key: re,
                      x1: U[J],
                      y1: U[J + 1],
                      x2: U[J + 2],
                      y2: U[J + 3]
                    }), M)) return !0
                }
            }
            const B = this.circleCells[d];
            if (B !== null) {
              const U = this.circles;
              for (const Q of B)
                if (!P.circle[Q]) {
                  P.circle[Q] = !0;
                  const J = 3 * Q,
                    re = this.circleKeys[Q];
                  if (this._circleAndRectCollide(U[J], U[J + 1], U[J + 2], e, n, s, u) && (!b || b(re)) && (!M || !jr(L, re.overlapMode))) {
                    const se = U[J],
                      de = U[J + 1],
                      ue = U[J + 2];
                    if (m.push({
                        key: re,
                        x1: se - ue,
                        y1: de - ue,
                        x2: se + ue,
                        y2: de + ue
                      }), M) return !0
                  }
                }
            }
            return !1
          }
          _queryCellCircle(e, n, s, u, d, m, y, b) {
            const {
              circle: P,
              seenUids: M,
              overlapMode: L
            } = y, z = this.boxCells[d];
            if (z !== null) {
              const U = this.bboxes;
              for (const Q of z)
                if (!M.box[Q]) {
                  M.box[Q] = !0;
                  const J = 4 * Q,
                    re = this.boxKeys[Q];
                  if (this._circleAndRectCollide(P.x, P.y, P.radius, U[J + 0], U[J + 1], U[J + 2], U[J + 3]) && (!b || b(re)) && !jr(L, re.overlapMode)) return m.push(!0), !0
                }
            }
            const B = this.circleCells[d];
            if (B !== null) {
              const U = this.circles;
              for (const Q of B)
                if (!M.circle[Q]) {
                  M.circle[Q] = !0;
                  const J = 3 * Q,
                    re = this.circleKeys[Q];
                  if (this._circlesCollide(U[J], U[J + 1], U[J + 2], P.x, P.y, P.radius) && (!b || b(re)) && !jr(L, re.overlapMode)) return m.push(!0), !0
                }
            }
          }
          _forEachCell(e, n, s, u, d, m, y, b) {
            const P = this._convertToXCellCoord(e),
              M = this._convertToYCellCoord(n),
              L = this._convertToXCellCoord(s),
              z = this._convertToYCellCoord(u);
            for (let B = P; B <= L; B++)
              for (let U = M; U <= z; U++)
                if (d.call(this, e, n, s, u, this.xCellCount * U + B, m, y, b)) return
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
          }
          _circlesCollide(e, n, s, u, d, m) {
            const y = u - e,
              b = d - n,
              P = s + m;
            return P * P > y * y + b * b
          }
          _circleAndRectCollide(e, n, s, u, d, m, y) {
            const b = (m - u) / 2,
              P = Math.abs(e - (u + b));
            if (P > b + s) return !1;
            const M = (y - d) / 2,
              L = Math.abs(n - (d + M));
            if (L > M + s) return !1;
            if (P <= b || L <= M) return !0;
            const z = P - b,
              B = L - M;
            return z * z + B * B <= s * s
          }
        }

        function Gr(h, e, n) {
          const s = o.L();
          if (!h) {
            const {
              vecSouth: L,
              vecEast: z
            } = Er(e), B = W();
            B[0] = z[0], B[1] = z[1], B[2] = L[0], B[3] = L[1], u = B, (M = (m = (d = B)[0]) * (P = d[3]) - (b = d[2]) * (y = d[1])) && (u[0] = P * (M = 1 / M), u[1] = -y * M, u[2] = -b * M, u[3] = m * M), s[0] = B[0], s[1] = B[1], s[4] = B[2], s[5] = B[3]
          }
          var u, d, m, y, b, P, M;
          return o.N(s, s, [1 / n, 1 / n, 1]), s
        }

        function mr(h, e, n, s) {
          if (h) {
            const u = o.L();
            if (!e) {
              const {
                vecSouth: d,
                vecEast: m
              } = Er(n);
              u[0] = m[0], u[1] = m[1], u[4] = d[0], u[5] = d[1]
            }
            return o.N(u, u, [s, s, 1]), u
          }
          return n.pixelsToClipSpaceMatrix
        }

        function Er(h) {
          const e = Math.cos(h.rollInRadians),
            n = Math.sin(h.rollInRadians),
            s = Math.cos(h.pitchInRadians),
            u = Math.cos(h.bearingInRadians),
            d = Math.sin(h.bearingInRadians),
            m = o.ar();
          m[0] = -u * s * n - d * e, m[1] = -d * s * n + u * e;
          const y = o.as(m);
          y < 1e-9 ? o.at(m) : o.au(m, m, 1 / y);
          const b = o.ar();
          b[0] = u * s * e - d * n, b[1] = d * s * e + u * n;
          const P = o.as(b);
          return P < 1e-9 ? o.at(b) : o.au(b, b, 1 / P), {
            vecEast: b,
            vecSouth: m
          }
        }

        function ai(h, e, n, s) {
          let u;
          s ? (u = [h, e, s(h, e), 1], o.aw(u, u, n)) : (u = [h, e, 0, 1], Di(u, u, n));
          const d = u[3];
          return {
            point: new o.P(u[0] / d, u[1] / d),
            signedDistanceFromCamera: d,
            isOccluded: !1
          }
        }

        function ft(h, e) {
          return .5 + h / e * .5
        }

        function yi(h, e) {
          return h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1]
        }

        function pi(h, e, n, s, u, d, m, y, b, P, M, L, z) {
          const B = n ? h.textSizeData : h.iconSizeData,
            U = o.an(B, e.transform.zoom),
            Q = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1],
            J = n ? h.text.dynamicLayoutVertexArray : h.icon.dynamicLayoutVertexArray;
          J.clear();
          const re = h.lineVertexArray,
            se = n ? h.text.placedSymbolArray : h.icon.placedSymbolArray,
            de = e.transform.width / e.transform.height;
          let ue = !1;
          for (let ge = 0; ge < se.length; ge++) {
            const we = se.get(ge);
            if (we.hidden || we.writingMode === o.ao.vertical && !ue) {
              mi(we.numGlyphs, J);
              continue
            }
            ue = !1;
            const he = new o.P(we.anchorX, we.anchorY),
              ze = {
                getElevation: z,
                pitchedLabelPlaneMatrix: s,
                lineVertexArray: re,
                pitchWithMap: d,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: e.transform,
                tileAnchorPoint: he,
                unwrappedTileID: b,
                width: P,
                height: M,
                translation: L
              },
              He = li(we.anchorX, we.anchorY, ze);
            if (!yi(He.point, Q)) {
              mi(we.numGlyphs, J);
              continue
            }
            const Ne = ft(e.transform.cameraToCenterDistance, He.signedDistanceFromCamera),
              qe = o.ap(B, U, we),
              Ge = d ? qe * e.transform.getPitchedTextCorrection(we.anchorX, we.anchorY, b) / Ne : qe * Ne,
              Dt = We({
                projectionContext: ze,
                pitchedLabelPlaneMatrixInverse: u,
                symbol: we,
                fontSize: Ge,
                flip: !1,
                keepUpright: m,
                glyphOffsetArray: h.glyphOffsetArray,
                dynamicLayoutVertexArray: J,
                aspectRatio: de,
                rotateToLine: y
              });
            ue = Dt.useVertical, (Dt.notEnoughRoom || ue || Dt.needsFlipping && We({
              projectionContext: ze,
              pitchedLabelPlaneMatrixInverse: u,
              symbol: we,
              fontSize: Ge,
              flip: !0,
              keepUpright: m,
              glyphOffsetArray: h.glyphOffsetArray,
              dynamicLayoutVertexArray: J,
              aspectRatio: de,
              rotateToLine: y
            }).notEnoughRoom) && mi(we.numGlyphs, J)
          }
          n ? h.text.dynamicLayoutVertexBuffer.updateData(J) : h.icon.dynamicLayoutVertexBuffer.updateData(J)
        }

        function In(h, e, n, s, u, d, m, y) {
          const b = d.glyphStartIndex + d.numGlyphs,
            P = d.lineStartIndex,
            M = d.lineStartIndex + d.lineLength,
            L = e.getoffsetX(d.glyphStartIndex),
            z = e.getoffsetX(b - 1),
            B = Pi(h * L, n, s, u, d.segment, P, M, y, m);
          if (!B) return null;
          const U = Pi(h * z, n, s, u, d.segment, P, M, y, m);
          return U ? y.projectionCache.anyProjectionOccluded ? null : {
            first: B,
            last: U
          } : null
        }

        function Pt(h, e, n, s) {
          return h === o.ao.horizontal && Math.abs(n.y - e.y) > Math.abs(n.x - e.x) * s ? {
            useVertical: !0
          } : (h === o.ao.vertical ? e.y < n.y : e.x > n.x) ? {
            needsFlipping: !0
          } : null
        }

        function We(h) {
          const {
            projectionContext: e,
            pitchedLabelPlaneMatrixInverse: n,
            symbol: s,
            fontSize: u,
            flip: d,
            keepUpright: m,
            glyphOffsetArray: y,
            dynamicLayoutVertexArray: b,
            aspectRatio: P,
            rotateToLine: M
          } = h, L = u / 24, z = s.lineOffsetX * L, B = s.lineOffsetY * L;
          let U;
          if (s.numGlyphs > 1) {
            const Q = s.glyphStartIndex + s.numGlyphs,
              J = s.lineStartIndex,
              re = s.lineStartIndex + s.lineLength,
              se = In(L, y, z, B, d, s, M, e);
            if (!se) return {
              notEnoughRoom: !0
            };
            const de = Wr(se.first.point.x, se.first.point.y, e, n),
              ue = Wr(se.last.point.x, se.last.point.y, e, n);
            if (m && !d) {
              const ge = Pt(s.writingMode, de, ue, P);
              if (ge) return ge
            }
            U = [se.first];
            for (let ge = s.glyphStartIndex + 1; ge < Q - 1; ge++) {
              const we = Pi(L * y.getoffsetX(ge), z, B, d, s.segment, J, re, e, M);
              if (!we) return {
                notEnoughRoom: !0
              };
              U.push(we)
            }
            U.push(se.last)
          } else {
            if (m && !d) {
              const J = zr(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point,
                re = s.lineStartIndex + s.segment + 1,
                se = new o.P(e.lineVertexArray.getx(re), e.lineVertexArray.gety(re)),
                de = zr(se.x, se.y, e),
                ue = de.signedDistanceFromCamera > 0 ? de.point : Ot(e.tileAnchorPoint, se, J, 1, e),
                ge = Wr(J.x, J.y, e, n),
                we = Wr(ue.x, ue.y, e, n),
                he = Pt(s.writingMode, ge, we, P);
              if (he) return he
            }
            const Q = Pi(L * y.getoffsetX(s.glyphStartIndex), z, B, d, s.segment, s.lineStartIndex, s.lineStartIndex + s.lineLength, e, M);
            if (!Q || e.projectionCache.anyProjectionOccluded) return {
              notEnoughRoom: !0
            };
            U = [Q]
          }
          for (const Q of U) o.av(b, Q.point, Q.angle);
          return {}
        }

        function Ot(h, e, n, s, u) {
          const d = h.add(h.sub(e)._unit()),
            m = zr(d.x, d.y, u).point,
            y = n.sub(m);
          return n.add(y._mult(s / y.mag()))
        }

        function $t(h, e, n) {
          const s = e.projectionCache;
          if (s.projections[h]) return s.projections[h];
          const u = new o.P(e.lineVertexArray.getx(h), e.lineVertexArray.gety(h)),
            d = zr(u.x, u.y, e);
          if (d.signedDistanceFromCamera > 0) return s.projections[h] = d.point, s.anyProjectionOccluded = s.anyProjectionOccluded || d.isOccluded, d.point;
          const m = h - n.direction;
          return Ot(n.distanceFromAnchor === 0 ? e.tileAnchorPoint : new o.P(e.lineVertexArray.getx(m), e.lineVertexArray.gety(m)), u, n.previousVertex, n.absOffsetX - n.distanceFromAnchor + 1, e)
        }

        function zr(h, e, n) {
          const s = h + n.translation[0],
            u = e + n.translation[1];
          let d;
          return n.pitchWithMap ? (d = ai(s, u, n.pitchedLabelPlaneMatrix, n.getElevation), d.isOccluded = !1) : (d = n.transform.projectTileCoordinates(s, u, n.unwrappedTileID, n.getElevation), d.point.x = (.5 * d.point.x + .5) * n.width, d.point.y = (.5 * -d.point.y + .5) * n.height), d
        }

        function Wr(h, e, n, s) {
          if (n.pitchWithMap) {
            const u = [h, e, 0, 1];
            return o.aw(u, u, s), n.transform.projectTileCoordinates(u[0] / u[3], u[1] / u[3], n.unwrappedTileID, n.getElevation).point
          }
          return {
            x: h / n.width * 2 - 1,
            y: 1 - e / n.height * 2
          }
        }

        function li(h, e, n) {
          return n.transform.projectTileCoordinates(h, e, n.unwrappedTileID, n.getElevation)
        }

        function _r(h, e, n) {
          return h._unit()._perp()._mult(e * n)
        }

        function Ti(h, e, n, s, u, d, m, y, b) {
          if (y.projectionCache.offsets[h]) return y.projectionCache.offsets[h];
          const P = n.add(e);
          if (h + b.direction < s || h + b.direction >= u) return y.projectionCache.offsets[h] = P, P;
          const M = $t(h + b.direction, y, b),
            L = _r(M.sub(n), m, b.direction),
            z = n.add(L),
            B = M.add(L);
          return y.projectionCache.offsets[h] = o.ax(d, P, z, B) || P, y.projectionCache.offsets[h]
        }

        function Pi(h, e, n, s, u, d, m, y, b) {
          const P = s ? h - e : h + e;
          let M = P > 0 ? 1 : -1,
            L = 0;
          s && (M *= -1, L = Math.PI), M < 0 && (L += Math.PI);
          let z, B = M > 0 ? d + u : d + u + 1;
          y.projectionCache.cachedAnchorPoint ? z = y.projectionCache.cachedAnchorPoint : (z = zr(y.tileAnchorPoint.x, y.tileAnchorPoint.y, y).point, y.projectionCache.cachedAnchorPoint = z);
          let U, Q, J = z,
            re = z,
            se = 0,
            de = 0;
          const ue = Math.abs(P),
            ge = [];
          let we;
          for (; se + de <= ue;) {
            if (B += M, B < d || B >= m) return null;
            se += de, re = J, Q = U;
            const He = {
              absOffsetX: ue,
              direction: M,
              distanceFromAnchor: se,
              previousVertex: re
            };
            if (J = $t(B, y, He), n === 0) ge.push(re), we = J.sub(re);
            else {
              let Ne;
              const qe = J.sub(re);
              Ne = qe.mag() === 0 ? _r($t(B + M, y, He).sub(J), n, M) : _r(qe, n, M), Q || (Q = re.add(Ne)), U = Ti(B, Ne, J, d, m, Q, n, y, He), ge.push(Q), we = U.sub(Q)
            }
            de = we.mag()
          }
          const he = we._mult((ue - se) / de)._add(Q || re),
            ze = L + Math.atan2(J.y - re.y, J.x - re.x);
          return ge.push(he), {
            point: he,
            angle: b ? ze : 0,
            path: ge
          }
        }
        const Li = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

        function mi(h, e) {
          for (let n = 0; n < h; n++) {
            const s = e.length;
            e.resize(s + 4), e.float32.set(Li, 3 * s)
          }
        }

        function Di(h, e, n) {
          const s = e[0],
            u = e[1];
          return h[0] = n[0] * s + n[4] * u + n[12], h[1] = n[1] * s + n[5] * u + n[13], h[3] = n[3] * s + n[7] * u + n[15], h
        }
        const rr = 100;
        class bi {
          constructor(e, n = new qr(e.width + 200, e.height + 200, 25), s = new qr(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = n, this.ignoredGrid = s, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + rr, this.screenBottomBoundary = e.height + rr, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6
          }
          placeCollisionBox(e, n, s, u, d, m, y, b, P, M, L, z) {
            const B = this.projectAndGetPerspectiveRatio(e.anchorPointX + b[0], e.anchorPointY + b[1], d, M, z),
              U = s * B.perspectiveRatio;
            let Q;
            if (m || y) Q = this._projectCollisionBox(e, U, u, d, m, y, b, B, M, L, z);
            else {
              const we = B.x + (L ? L.x * U : 0),
                he = B.y + (L ? L.y * U : 0);
              Q = {
                allPointsOccluded: !1,
                box: [we + e.x1 * U, he + e.y1 * U, we + e.x2 * U, he + e.y2 * U]
              }
            }
            const [J, re, se, de] = Q.box, ue = m ? Q.allPointsOccluded : B.isOccluded;
            let ge = ue;
            return ge || (ge = B.perspectiveRatio < this.perspectiveRatioCutoff), ge || (ge = !this.isInsideGrid(J, re, se, de)), ge || n !== "always" && this.grid.hitTest(J, re, se, de, n, P) ? {
              box: [J, re, se, de],
              placeable: !1,
              offscreen: !1,
              occluded: ue
            } : {
              box: [J, re, se, de],
              placeable: !0,
              offscreen: this.isOffscreen(J, re, se, de),
              occluded: ue
            }
          }
          placeCollisionCircles(e, n, s, u, d, m, y, b, P, M, L, z, B, U) {
            const Q = [],
              J = new o.P(n.anchorX, n.anchorY),
              re = this.getPerspectiveRatio(J.x, J.y, m, U),
              se = (P ? d * this.transform.getPitchedTextCorrection(n.anchorX, n.anchorY, m) / re : d * re) / o.aB,
              de = {
                getElevation: U,
                pitchedLabelPlaneMatrix: y,
                lineVertexArray: s,
                pitchWithMap: P,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: this.transform,
                tileAnchorPoint: J,
                unwrappedTileID: m,
                width: this.transform.width,
                height: this.transform.height,
                translation: B
              },
              ue = In(se, u, n.lineOffsetX * se, n.lineOffsetY * se, !1, n, !1, de);
            let ge = !1,
              we = !1,
              he = !0;
            if (ue) {
              const ze = .5 * L * re + z,
                He = new o.P(-100, -100),
                Ne = new o.P(this.screenRightBoundary, this.screenBottomBoundary),
                qe = new ar,
                Ge = ue.first,
                Dt = ue.last;
              let Ft = [];
              for (let Kr = Ge.path.length - 1; Kr >= 1; Kr--) Ft.push(Ge.path[Kr]);
              for (let Kr = 1; Kr < Dt.path.length; Kr++) Ft.push(Dt.path[Kr]);
              const vt = 2.5 * ze;
              if (P) {
                const Kr = this.projectPathToScreenSpace(Ft, de);
                Ft = Kr.some((wi => wi.signedDistanceFromCamera <= 0)) ? [] : Kr.map((wi => wi.point))
              }
              let sr = [];
              if (Ft.length > 0) {
                const Kr = Ft[0].clone(),
                  wi = Ft[0].clone();
                for (let ki = 1; ki < Ft.length; ki++) Kr.x = Math.min(Kr.x, Ft[ki].x), Kr.y = Math.min(Kr.y, Ft[ki].y), wi.x = Math.max(wi.x, Ft[ki].x), wi.y = Math.max(wi.y, Ft[ki].y);
                sr = Kr.x >= He.x && wi.x <= Ne.x && Kr.y >= He.y && wi.y <= Ne.y ? [Ft] : wi.x < He.x || Kr.x > Ne.x || wi.y < He.y || Kr.y > Ne.y ? [] : o.ay([Ft], He.x, He.y, Ne.x, Ne.y)
              }
              for (const Kr of sr) {
                qe.reset(Kr, .25 * ze);
                let wi = 0;
                wi = qe.length <= .5 * ze ? 1 : Math.ceil(qe.paddedLength / vt) + 1;
                for (let ki = 0; ki < wi; ki++) {
                  const Ii = ki / Math.max(wi - 1, 1),
                    qi = qe.lerp(Ii),
                    $i = qi.x + rr,
                    Xr = qi.y + rr;
                  Q.push($i, Xr, ze, 0);
                  const Ei = $i - ze,
                    nn = Xr - ze,
                    dn = $i + ze,
                    xn = Xr + ze;
                  if (he = he && this.isOffscreen(Ei, nn, dn, xn), we = we || this.isInsideGrid(Ei, nn, dn, xn), e !== "always" && this.grid.hitTestCircle($i, Xr, ze, e, M) && (ge = !0, !b)) return {
                    circles: [],
                    offscreen: !1,
                    collisionDetected: ge
                  }
                }
              }
            }
            return {
              circles: !b && ge || !we || re < this.perspectiveRatioCutoff ? [] : Q,
              offscreen: he,
              collisionDetected: ge
            }
          }
          projectPathToScreenSpace(e, n) {
            const s = (function(u, d) {
              const m = o.L();
              return o.aq(m, d.pitchedLabelPlaneMatrix), u.map((y => {
                const b = ai(y.x, y.y, m, d.getElevation),
                  P = d.transform.projectTileCoordinates(b.point.x, b.point.y, d.unwrappedTileID, d.getElevation);
                return P.point.x = (.5 * P.point.x + .5) * d.width, P.point.y = (.5 * -P.point.y + .5) * d.height, P
              }))
            })(e, n);
            return (function(u) {
              let d = 0,
                m = 0,
                y = 0,
                b = 0;
              for (let P = 0; P < u.length; P++) u[P].isOccluded ? (y = P + 1, b = 0) : (b++, b > m && (m = b, d = y));
              return u.slice(d, d + m)
            })(s)
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const n = [],
              s = new o.a2;
            for (const L of e) {
              const z = new o.P(L.x + rr, L.y + rr);
              s.extend(z), n.push(z)
            }
            const {
              minX: u,
              minY: d,
              maxX: m,
              maxY: y
            } = s, b = this.grid.query(u, d, m, y).concat(this.ignoredGrid.query(u, d, m, y)), P = {}, M = {};
            for (const L of b) {
              const z = L.key;
              if (P[z.bucketInstanceId] === void 0 && (P[z.bucketInstanceId] = {}), P[z.bucketInstanceId][z.featureIndex]) continue;
              const B = [new o.P(L.x1, L.y1), new o.P(L.x2, L.y1), new o.P(L.x2, L.y2), new o.P(L.x1, L.y2)];
              o.az(n, B) && (P[z.bucketInstanceId][z.featureIndex] = !0, M[z.bucketInstanceId] === void 0 && (M[z.bucketInstanceId] = []), M[z.bucketInstanceId].push(z.featureIndex))
            }
            return M
          }
          insertCollisionBox(e, n, s, u, d, m) {
            (s ? this.ignoredGrid : this.grid).insert({
              bucketInstanceId: u,
              featureIndex: d,
              collisionGroupID: m,
              overlapMode: n
            }, e[0], e[1], e[2], e[3])
          }
          insertCollisionCircles(e, n, s, u, d, m) {
            const y = s ? this.ignoredGrid : this.grid,
              b = {
                bucketInstanceId: u,
                featureIndex: d,
                collisionGroupID: m,
                overlapMode: n
              };
            for (let P = 0; P < e.length; P += 4) y.insertCircle(b, e[P], e[P + 1], e[P + 2])
          }
          projectAndGetPerspectiveRatio(e, n, s, u, d) {
            if (d) {
              let m;
              u ? (m = [e, n, u(e, n), 1], o.aw(m, m, d)) : (m = [e, n, 0, 1], Di(m, m, d));
              const y = m[3];
              return {
                x: (m[0] / y + 1) / 2 * this.transform.width + rr,
                y: (-m[1] / y + 1) / 2 * this.transform.height + rr,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / y * .5,
                isOccluded: !1,
                signedDistanceFromCamera: y
              }
            } {
              const m = this.transform.projectTileCoordinates(e, n, s, u);
              return {
                x: (m.point.x + 1) / 2 * this.transform.width + rr,
                y: (1 - m.point.y) / 2 * this.transform.height + rr,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / m.signedDistanceFromCamera * .5,
                isOccluded: m.isOccluded,
                signedDistanceFromCamera: m.signedDistanceFromCamera
              }
            }
          }
          getPerspectiveRatio(e, n, s, u) {
            const d = this.transform.projectTileCoordinates(e, n, s, u);
            return .5 + this.transform.cameraToCenterDistance / d.signedDistanceFromCamera * .5
          }
          isOffscreen(e, n, s, u) {
            return s < rr || e >= this.screenRightBoundary || u < rr || n > this.screenBottomBoundary
          }
          isInsideGrid(e, n, s, u) {
            return s >= 0 && e < this.gridRightBoundary && u >= 0 && n < this.gridBottomBoundary
          }
          getViewportMatrix() {
            const e = o.ag([]);
            return o.M(e, e, [-100, -100, 0]), e
          }
          _projectCollisionBox(e, n, s, u, d, m, y, b, P, M, L) {
            let z = 1,
              B = 0,
              U = 0,
              Q = 1;
            const J = e.anchorPointX + y[0],
              re = e.anchorPointY + y[1];
            if (m && !d) {
              const Ft = this.projectAndGetPerspectiveRatio(J + 1, re, u, P, L),
                vt = Ft.x - b.x,
                sr = Math.atan((Ft.y - b.y) / vt) + (vt < 0 ? Math.PI : 0),
                Kr = Math.sin(sr),
                wi = Math.cos(sr);
              z = wi, B = Kr, U = -Kr, Q = wi
            } else if (!m && d) {
              const Ft = Er(this.transform);
              z = Ft.vecEast[0], B = Ft.vecEast[1], U = Ft.vecSouth[0], Q = Ft.vecSouth[1]
            }
            let se = b.x,
              de = b.y,
              ue = n;
            d && (se = J, de = re, ue = Math.pow(2, -(this.transform.zoom - s.overscaledZ)), ue *= this.transform.getPitchedTextCorrection(J, re, u), M || (ue *= o.ah(.5 + b.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), M && (se += z * M.x * ue + U * M.y * ue, de += B * M.x * ue + Q * M.y * ue);
            const ge = e.x1 * ue,
              we = e.x2 * ue,
              he = (ge + we) / 2,
              ze = e.y1 * ue,
              He = e.y2 * ue,
              Ne = (ze + He) / 2,
              qe = [{
                offsetX: ge,
                offsetY: ze
              }, {
                offsetX: he,
                offsetY: ze
              }, {
                offsetX: we,
                offsetY: ze
              }, {
                offsetX: we,
                offsetY: Ne
              }, {
                offsetX: we,
                offsetY: He
              }, {
                offsetX: he,
                offsetY: He
              }, {
                offsetX: ge,
                offsetY: He
              }, {
                offsetX: ge,
                offsetY: Ne
              }];
            let Ge = [];
            for (const {
                offsetX: Ft,
                offsetY: vt
              }
              of qe) Ge.push(new o.P(se + z * Ft + U * vt, de + B * Ft + Q * vt));
            let Dt = !1;
            if (d) {
              const Ft = Ge.map((vt => this.projectAndGetPerspectiveRatio(vt.x, vt.y, u, P, L)));
              Dt = Ft.some((vt => !vt.isOccluded)), Ge = Ft.map((vt => new o.P(vt.x, vt.y)))
            } else Dt = !0;
            return {
              box: o.aA(Ge),
              allPointsOccluded: !Dt
            }
          }
        }
        class Qr {
          constructor(e, n, s, u) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? n : -n))) : u && s ? 1 : 0, this.placed = s
          }
          isHidden() {
            return this.opacity === 0 && !this.placed
          }
        }
        class Yr {
          constructor(e, n, s, u, d) {
            this.text = new Qr(e ? e.text : null, n, s, d), this.icon = new Qr(e ? e.icon : null, n, u, d)
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden()
          }
        }
        class la {
          constructor(e, n, s) {
            this.text = e, this.icon = n, this.skipFade = s
          }
        }
        class ln {
          constructor(e, n, s, u, d) {
            this.bucketInstanceId = e, this.featureIndex = n, this.sourceLayerIndex = s, this.bucketIndex = u, this.tileID = d
          }
        }
        class ta {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {}
          }
          get(e) {
            if (this.crossSourceCollisions) return {
              ID: 0,
              predicate: null
            };
            if (!this.collisionGroups[e]) {
              const n = ++this.maxGroupID;
              this.collisionGroups[e] = {
                ID: n,
                predicate: s => s.collisionGroupID === n
              }
            }
            return this.collisionGroups[e]
          }
        }

        function Oi(h, e, n, s, u) {
          const {
            horizontalAlign: d,
            verticalAlign: m
          } = o.aH(h);
          return new o.P(-(d - .5) * e + s[0] * u, -(m - .5) * n + s[1] * u)
        }
        class Ki {
          constructor(e, n, s, u, d) {
            this.transform = e.clone(), this.terrain = n, this.collisionIndex = new bi(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = s, this.retainedQueryData = {}, this.collisionGroups = new ta(u), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = d, d && (d.prevPlacement = void 0), this.placedOrientations = {}
          }
          _getTerrainElevationFunc(e) {
            const n = this.terrain;
            return n ? (s, u) => n.getElevation(e, s, u) : null
          }
          getBucketParts(e, n, s, u) {
            const d = s.getBucket(n),
              m = s.latestFeatureIndex;
            if (!d || !m || n.id !== d.layerIds[0]) return;
            const y = s.collisionBoxArray,
              b = d.layers[0].layout,
              P = d.layers[0].paint,
              M = Math.pow(2, this.transform.zoom - s.tileID.overscaledZ),
              L = s.tileSize / o.$,
              z = s.tileID.toUnwrapped(),
              B = b.get("text-rotation-alignment") === "map",
              U = o.aC(s, 1, this.transform.zoom),
              Q = o.aD(this.collisionIndex.transform, s, P.get("text-translate"), P.get("text-translate-anchor")),
              J = o.aD(this.collisionIndex.transform, s, P.get("icon-translate"), P.get("icon-translate-anchor")),
              re = Gr(B, this.transform, U);
            this.retainedQueryData[d.bucketInstanceId] = new ln(d.bucketInstanceId, m, d.sourceLayerIndex, d.index, s.tileID);
            const se = {
              bucket: d,
              layout: b,
              translationText: Q,
              translationIcon: J,
              unwrappedTileID: z,
              pitchedLabelPlaneMatrix: re,
              scale: M,
              textPixelRatio: L,
              holdingForFade: s.holdingForFade(),
              collisionBoxArray: y,
              partiallyEvaluatedTextSize: o.an(d.textSizeData, this.transform.zoom),
              collisionGroup: this.collisionGroups.get(d.sourceID)
            };
            if (u)
              for (const de of d.sortKeyRanges) {
                const {
                  sortKey: ue,
                  symbolInstanceStart: ge,
                  symbolInstanceEnd: we
                } = de;
                e.push({
                  sortKey: ue,
                  symbolInstanceStart: ge,
                  symbolInstanceEnd: we,
                  parameters: se
                })
              } else e.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: d.symbolInstances.length,
                parameters: se
              })
          }
          attemptAnchorPlacement(e, n, s, u, d, m, y, b, P, M, L, z, B, U, Q, J, re, se, de, ue) {
            const ge = o.aE[e.textAnchor],
              we = [e.textOffset0, e.textOffset1],
              he = Oi(ge, s, u, we, d),
              ze = this.collisionIndex.placeCollisionBox(n, z, b, P, M, y, m, J, L.predicate, de, he, ue);
            if ((!se || this.collisionIndex.placeCollisionBox(se, z, b, P, M, y, m, re, L.predicate, de, he, ue).placeable) && ze.placeable) {
              let He;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[B.crossTileID] && this.prevPlacement.placements[B.crossTileID] && this.prevPlacement.placements[B.crossTileID].text && (He = this.prevPlacement.variableOffsets[B.crossTileID].anchor), B.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[B.crossTileID] = {
                textOffset: we,
                width: s,
                height: u,
                anchor: ge,
                textBoxScale: d,
                prevAnchor: He
              }, this.markUsedJustification(U, ge, B, Q), U.allowVerticalPlacement && (this.markUsedOrientation(U, Q, B), this.placedOrientations[B.crossTileID] = Q), {
                shift: he,
                placedGlyphBoxes: ze
              }
            }
          }
          placeLayerBucketPart(e, n, s) {
            const {
              bucket: u,
              layout: d,
              translationText: m,
              translationIcon: y,
              unwrappedTileID: b,
              pitchedLabelPlaneMatrix: P,
              textPixelRatio: M,
              holdingForFade: L,
              collisionBoxArray: z,
              partiallyEvaluatedTextSize: B,
              collisionGroup: U
            } = e.parameters, Q = d.get("text-optional"), J = d.get("icon-optional"), re = o.aF(d, "text-overlap", "text-allow-overlap"), se = re === "always", de = o.aF(d, "icon-overlap", "icon-allow-overlap"), ue = de === "always", ge = d.get("text-rotation-alignment") === "map", we = d.get("text-pitch-alignment") === "map", he = d.get("icon-text-fit") !== "none", ze = d.get("symbol-z-order") === "viewport-y", He = se && (ue || !u.hasIconData() || J), Ne = ue && (se || !u.hasTextData() || Q);
            !u.collisionArrays && z && u.deserializeCollisionBoxes(z);
            const qe = this.retainedQueryData[u.bucketInstanceId].tileID,
              Ge = this._getTerrainElevationFunc(qe),
              Dt = this.transform.getFastPathSimpleProjectionMatrix(qe),
              Ft = (vt, sr, Kr) => {
                var wi, ki;
                if (n[vt.crossTileID]) return;
                if (L) return void(this.placements[vt.crossTileID] = new la(!1, !1, !1));
                let Ii = !1,
                  qi = !1,
                  $i = !0,
                  Xr = null,
                  Ei = {
                    box: null,
                    placeable: !1,
                    offscreen: null,
                    occluded: !1
                  },
                  nn = {
                    placeable: !1
                  },
                  dn = null,
                  xn = null,
                  qn = null,
                  Sa = 0,
                  ns = 0,
                  as = 0;
                sr.textFeatureIndex ? Sa = sr.textFeatureIndex : vt.useRuntimeCollisionCircles && (Sa = vt.featureIndex), sr.verticalTextFeatureIndex && (ns = sr.verticalTextFeatureIndex);
                const Ys = sr.textBox;
                if (Ys) {
                  const Yn = an => {
                      let pn = o.ao.horizontal;
                      if (u.allowVerticalPlacement && !an && this.prevPlacement) {
                        const da = this.prevPlacement.placedOrientations[vt.crossTileID];
                        da && (this.placedOrientations[vt.crossTileID] = da, pn = da, this.markUsedOrientation(u, pn, vt))
                      }
                      return pn
                    },
                    Pa = (an, pn) => {
                      if (u.allowVerticalPlacement && vt.numVerticalGlyphVertices > 0 && sr.verticalTextBox) {
                        for (const da of u.writingModes)
                          if (da === o.ao.vertical ? (Ei = pn(), nn = Ei) : Ei = an(), Ei && Ei.placeable) break
                      } else Ei = an()
                    },
                    Vn = vt.textAnchorOffsetStartIndex,
                    ss = vt.textAnchorOffsetEndIndex;
                  if (ss === Vn) {
                    const an = (pn, da) => {
                      const sn = this.collisionIndex.placeCollisionBox(pn, re, M, qe, b, we, ge, m, U.predicate, Ge, void 0, Dt);
                      return sn && sn.placeable && (this.markUsedOrientation(u, da, vt), this.placedOrientations[vt.crossTileID] = da), sn
                    };
                    Pa((() => an(Ys, o.ao.horizontal)), (() => {
                      const pn = sr.verticalTextBox;
                      return u.allowVerticalPlacement && vt.numVerticalGlyphVertices > 0 && pn ? an(pn, o.ao.vertical) : {
                        box: null,
                        offscreen: null
                      }
                    })), Yn(Ei && Ei.placeable)
                  } else {
                    let an = o.aE[(ki = (wi = this.prevPlacement) === null || wi === void 0 ? void 0 : wi.variableOffsets[vt.crossTileID]) === null || ki === void 0 ? void 0 : ki.anchor];
                    const pn = (sn, Bo, Qs) => {
                      const Ga = sn.x2 - sn.x1,
                        Ia = sn.y2 - sn.y1,
                        os = vt.textBoxScale,
                        td = he && de === "never" ? Bo : null;
                      let ia = null,
                        rd = re === "never" ? 1 : 2,
                        eu = "never";
                      an && rd++;
                      for (let kl = 0; kl < rd; kl++) {
                        for (let El = Vn; El < ss; El++) {
                          const ls = u.textAnchorOffsets.get(El);
                          if (an && ls.textAnchor !== an) continue;
                          const Ha = this.attemptAnchorPlacement(ls, sn, Ga, Ia, os, ge, we, M, qe, b, U, eu, vt, u, Qs, m, y, td, Ge);
                          if (Ha && (ia = Ha.placedGlyphBoxes, ia && ia.placeable)) return Ii = !0, Xr = Ha.shift, ia
                        }
                        an ? an = null : eu = re
                      }
                      return s && !ia && (ia = {
                        box: this.collisionIndex.placeCollisionBox(Ys, "always", M, qe, b, we, ge, m, U.predicate, Ge, void 0, Dt).box,
                        offscreen: !1,
                        placeable: !1,
                        occluded: !1
                      }), ia
                    };
                    Pa((() => pn(Ys, sr.iconBox, o.ao.horizontal)), (() => {
                      const sn = sr.verticalTextBox;
                      return u.allowVerticalPlacement && (!Ei || !Ei.placeable) && vt.numVerticalGlyphVertices > 0 && sn ? pn(sn, sr.verticalIconBox, o.ao.vertical) : {
                        box: null,
                        occluded: !0,
                        offscreen: null
                      }
                    })), Ei && (Ii = Ei.placeable, $i = Ei.offscreen);
                    const da = Yn(Ei && Ei.placeable);
                    if (!Ii && this.prevPlacement) {
                      const sn = this.prevPlacement.variableOffsets[vt.crossTileID];
                      sn && (this.variableOffsets[vt.crossTileID] = sn, this.markUsedJustification(u, sn.anchor, vt, da))
                    }
                  }
                }
                if (dn = Ei, Ii = dn && dn.placeable, $i = dn && dn.offscreen, vt.useRuntimeCollisionCircles) {
                  const Yn = u.text.placedSymbolArray.get(vt.centerJustifiedTextSymbolIndex),
                    Pa = o.ap(u.textSizeData, B, Yn),
                    Vn = d.get("text-padding");
                  xn = this.collisionIndex.placeCollisionCircles(re, Yn, u.lineVertexArray, u.glyphOffsetArray, Pa, b, P, s, we, U.predicate, vt.collisionCircleDiameter, Vn, m, Ge), xn.circles.length && xn.collisionDetected && !s && o.w("Collisions detected, but collision boxes are not shown"), Ii = se || xn.circles.length > 0 && !xn.collisionDetected, $i = $i && xn.offscreen
                }
                if (sr.iconFeatureIndex && (as = sr.iconFeatureIndex), sr.iconBox) {
                  const Yn = Pa => this.collisionIndex.placeCollisionBox(Pa, de, M, qe, b, we, ge, y, U.predicate, Ge, he && Xr ? Xr : void 0, Dt);
                  nn && nn.placeable && sr.verticalIconBox ? (qn = Yn(sr.verticalIconBox), qi = qn.placeable) : (qn = Yn(sr.iconBox), qi = qn.placeable), $i = $i && qn.offscreen
                }
                const Js = Q || vt.numHorizontalGlyphVertices === 0 && vt.numVerticalGlyphVertices === 0,
                  Ps = J || vt.numIconVertices === 0;
                Js || Ps ? Ps ? Js || (qi = qi && Ii) : Ii = qi && Ii : qi = Ii = qi && Ii;
                const Is = qi && qn.placeable;
                if (Ii && dn.placeable && this.collisionIndex.insertCollisionBox(dn.box, re, d.get("text-ignore-placement"), u.bucketInstanceId, nn && nn.placeable && ns ? ns : Sa, U.ID), Is && this.collisionIndex.insertCollisionBox(qn.box, de, d.get("icon-ignore-placement"), u.bucketInstanceId, as, U.ID), xn && Ii && this.collisionIndex.insertCollisionCircles(xn.circles, re, d.get("text-ignore-placement"), u.bucketInstanceId, Sa, U.ID), s && this.storeCollisionData(u.bucketInstanceId, Kr, sr, dn, qn, xn), vt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                if (u.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[vt.crossTileID] = new la((Ii || He) && !(dn != null && dn.occluded), (qi || Ne) && !(qn != null && qn.occluded), $i || u.justReloaded), n[vt.crossTileID] = !0
              };
            if (ze) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const vt = u.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let sr = vt.length - 1; sr >= 0; --sr) {
                const Kr = vt[sr];
                Ft(u.symbolInstances.get(Kr), u.collisionArrays[Kr], Kr)
              }
            } else
              for (let vt = e.symbolInstanceStart; vt < e.symbolInstanceEnd; vt++) Ft(u.symbolInstances.get(vt), u.collisionArrays[vt], vt);
            u.justReloaded = !1
          }
          storeCollisionData(e, n, s, u, d, m) {
            if (s.textBox || s.iconBox) {
              let y, b;
              this.collisionBoxArrays.has(e) ? y = this.collisionBoxArrays.get(e) : (y = new Map, this.collisionBoxArrays.set(e, y)), y.has(n) ? b = y.get(n) : (b = {
                text: null,
                icon: null
              }, y.set(n, b)), s.textBox && (b.text = u.box), s.iconBox && (b.icon = d.box)
            }
            if (m) {
              let y = this.collisionCircleArrays[e];
              y === void 0 && (y = this.collisionCircleArrays[e] = []);
              for (let b = 0; b < m.circles.length; b += 4) y.push(m.circles[b + 0] - rr), y.push(m.circles[b + 1] - rr), y.push(m.circles[b + 2]), y.push(m.collisionDetected ? 1 : 0)
            }
          }
          markUsedJustification(e, n, s, u) {
            let d;
            d = u === o.ao.vertical ? s.verticalPlacedTextSymbolIndex : {
              left: s.leftJustifiedTextSymbolIndex,
              center: s.centerJustifiedTextSymbolIndex,
              right: s.rightJustifiedTextSymbolIndex
            } [o.aG(n)];
            const m = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex, s.verticalPlacedTextSymbolIndex];
            for (const y of m) y >= 0 && (e.text.placedSymbolArray.get(y).crossTileID = d >= 0 && y !== d ? 0 : s.crossTileID)
          }
          markUsedOrientation(e, n, s) {
            const u = n === o.ao.horizontal || n === o.ao.horizontalOnly ? n : 0,
              d = n === o.ao.vertical ? n : 0,
              m = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex];
            for (const y of m) e.text.placedSymbolArray.get(y).placedOrientation = u;
            s.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(s.verticalPlacedTextSymbolIndex).placedOrientation = d)
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const n = this.prevPlacement;
            let s = !1;
            this.prevZoomAdjustment = n ? n.zoomAdjustment(this.transform.zoom) : 0;
            const u = n ? n.symbolFadeChange(e) : 1,
              d = n ? n.opacities : {},
              m = n ? n.variableOffsets : {},
              y = n ? n.placedOrientations : {};
            for (const b in this.placements) {
              const P = this.placements[b],
                M = d[b];
              M ? (this.opacities[b] = new Yr(M, u, P.text, P.icon), s = s || P.text !== M.text.placed || P.icon !== M.icon.placed) : (this.opacities[b] = new Yr(null, u, P.text, P.icon, P.skipFade), s = s || P.text || P.icon)
            }
            for (const b in d) {
              const P = d[b];
              if (!this.opacities[b]) {
                const M = new Yr(P, u, !1, !1);
                M.isHidden() || (this.opacities[b] = M, s = s || P.text.placed || P.icon.placed)
              }
            }
            for (const b in m) this.variableOffsets[b] || !this.opacities[b] || this.opacities[b].isHidden() || (this.variableOffsets[b] = m[b]);
            for (const b in y) this.placedOrientations[b] || !this.opacities[b] || this.opacities[b].isHidden() || (this.placedOrientations[b] = y[b]);
            if (n && n.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            s ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = n ? n.lastPlacementChangeTime : e)
          }
          updateLayerOpacities(e, n) {
            const s = {};
            for (const u of n) {
              const d = u.getBucket(e);
              d && u.latestFeatureIndex && e.id === d.layerIds[0] && this.updateBucketOpacities(d, u.tileID, s, u.collisionBoxArray)
            }
          }
          updateBucketOpacities(e, n, s, u) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const d = e.layers[0],
              m = d.layout,
              y = new Yr(null, 0, !1, !1, !0),
              b = m.get("text-allow-overlap"),
              P = m.get("icon-allow-overlap"),
              M = d._unevaluatedLayout.hasValue("text-variable-anchor") || d._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
              L = m.get("text-rotation-alignment") === "map",
              z = m.get("text-pitch-alignment") === "map",
              B = m.get("icon-text-fit") !== "none",
              U = new Yr(null, 0, b && (P || !e.hasIconData() || m.get("icon-optional")), P && (b || !e.hasTextData() || m.get("text-optional")), !0);
            !e.collisionArrays && u && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(u);
            const Q = (re, se, de) => {
                for (let ue = 0; ue < se / 4; ue++) re.opacityVertexArray.emplaceBack(de);
                re.hasVisibleVertices = re.hasVisibleVertices || de !== Mi
              },
              J = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let re = 0; re < e.symbolInstances.length; re++) {
              const se = e.symbolInstances.get(re),
                {
                  numHorizontalGlyphVertices: de,
                  numVerticalGlyphVertices: ue,
                  crossTileID: ge
                } = se;
              let we = this.opacities[ge];
              s[ge] ? we = y : we || (we = U, this.opacities[ge] = we), s[ge] = !0;
              const he = se.numIconVertices > 0,
                ze = this.placedOrientations[se.crossTileID],
                He = ze === o.ao.vertical,
                Ne = ze === o.ao.horizontal || ze === o.ao.horizontalOnly;
              if (de > 0 || ue > 0) {
                const Ge = Hi(we.text);
                Q(e.text, de, He ? Mi : Ge), Q(e.text, ue, Ne ? Mi : Ge);
                const Dt = we.text.isHidden();
                [se.rightJustifiedTextSymbolIndex, se.centerJustifiedTextSymbolIndex, se.leftJustifiedTextSymbolIndex].forEach((sr => {
                  sr >= 0 && (e.text.placedSymbolArray.get(sr).hidden = Dt || He ? 1 : 0)
                })), se.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(se.verticalPlacedTextSymbolIndex).hidden = Dt || Ne ? 1 : 0);
                const Ft = this.variableOffsets[se.crossTileID];
                Ft && this.markUsedJustification(e, Ft.anchor, se, ze);
                const vt = this.placedOrientations[se.crossTileID];
                vt && (this.markUsedJustification(e, "left", se, vt), this.markUsedOrientation(e, vt, se))
              }
              if (he) {
                const Ge = Hi(we.icon),
                  Dt = !(B && se.verticalPlacedIconSymbolIndex && He);
                se.placedIconSymbolIndex >= 0 && (Q(e.icon, se.numIconVertices, Dt ? Ge : Mi), e.icon.placedSymbolArray.get(se.placedIconSymbolIndex).hidden = we.icon.isHidden()), se.verticalPlacedIconSymbolIndex >= 0 && (Q(e.icon, se.numVerticalIconVertices, Dt ? Mi : Ge), e.icon.placedSymbolArray.get(se.verticalPlacedIconSymbolIndex).hidden = we.icon.isHidden())
              }
              const qe = J && J.has(re) ? J.get(re) : {
                text: null,
                icon: null
              };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const Ge = e.collisionArrays[re];
                if (Ge) {
                  let Dt = new o.P(0, 0);
                  if (Ge.textBox || Ge.verticalTextBox) {
                    let Ft = !0;
                    if (M) {
                      const vt = this.variableOffsets[ge];
                      vt ? (Dt = Oi(vt.anchor, vt.width, vt.height, vt.textOffset, vt.textBoxScale), L && Dt._rotate(z ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Ft = !1
                    }
                    if (Ge.textBox || Ge.verticalTextBox) {
                      let vt;
                      Ge.textBox && (vt = He), Ge.verticalTextBox && (vt = Ne), Hn(e.textCollisionBox.collisionVertexArray, we.text.placed, !Ft || vt, qe.text, Dt.x, Dt.y)
                    }
                  }
                  if (Ge.iconBox || Ge.verticalIconBox) {
                    const Ft = !!(!Ne && Ge.verticalIconBox);
                    let vt;
                    Ge.iconBox && (vt = Ft), Ge.verticalIconBox && (vt = !Ft), Hn(e.iconCollisionBox.collisionVertexArray, we.icon.placed, vt, qe.icon, B ? Dt.x : 0, B ? Dt.y : 0)
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId])
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5)
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
          }
          stillRecent(e, n) {
            const s = this.zoomAtLastRecencyCheck === n ? 1 - this.zoomAdjustment(n) : 1;
            return this.zoomAtLastRecencyCheck = n, this.commitTime + this.fadeDuration * s > e
          }
          setStale() {
            this.stale = !0
          }
        }

        function Hn(h, e, n, s, u, d) {
          s && s.length !== 0 || (s = [0, 0, 0, 0]);
          const m = s[0] - rr,
            y = s[1] - rr,
            b = s[2] - rr,
            P = s[3] - rr;
          h.emplaceBack(e ? 1 : 0, n ? 1 : 0, u || 0, d || 0, m, y), h.emplaceBack(e ? 1 : 0, n ? 1 : 0, u || 0, d || 0, b, y), h.emplaceBack(e ? 1 : 0, n ? 1 : 0, u || 0, d || 0, b, P), h.emplaceBack(e ? 1 : 0, n ? 1 : 0, u || 0, d || 0, m, P)
        }
        const Wn = Math.pow(2, 25),
          Dn = Math.pow(2, 24),
          _t = Math.pow(2, 17),
          jt = Math.pow(2, 16),
          vr = Math.pow(2, 9),
          _i = Math.pow(2, 8),
          Ri = Math.pow(2, 1);

        function Hi(h) {
          if (h.opacity === 0 && !h.placed) return 0;
          if (h.opacity === 1 && h.placed) return 4294967295;
          const e = h.placed ? 1 : 0,
            n = Math.floor(127 * h.opacity);
          return n * Wn + e * Dn + n * _t + e * jt + n * vr + e * _i + n * Ri + e
        }
        const Mi = 0;
        class Tr {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []
          }
          continuePlacement(e, n, s, u, d) {
            const m = this._bucketParts;
            for (; this._currentTileIndex < e.length;)
              if (n.getBucketParts(m, u, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, d()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, m.sort(((y, b) => y.sortKey - b.sortKey))); this._currentPartIndex < m.length;)
              if (n.placeLayerBucketPart(m[this._currentPartIndex], this._seenCrossTileIDs, s), this._currentPartIndex++, d()) return !0;
            return !1
          }
        }
        class vn {
          constructor(e, n, s, u, d, m, y, b) {
            this.placement = new Ki(e, n, m, y, b), this._currentPlacementIndex = s.length - 1, this._forceFullPlacement = u, this._showCollisionBoxes = d, this._done = !1
          }
          isDone() {
            return this._done
          }
          continuePlacement(e, n, s) {
            const u = xe.now(),
              d = () => !this._forceFullPlacement && xe.now() - u > 2;
            for (; this._currentPlacementIndex >= 0;) {
              const m = n[e[this._currentPlacementIndex]],
                y = this.placement.collisionIndex.transform.zoom;
              if (m.type === "symbol" && (!m.minzoom || m.minzoom <= y) && (!m.maxzoom || m.maxzoom > y)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Tr(m)), this._inProgressLayer.continuePlacement(s[m.source], this.placement, this._showCollisionBoxes, m, d)) return;
                delete this._inProgressLayer
              }
              this._currentPlacementIndex--
            }
            this._done = !0
          }
          commit(e) {
            return this.placement.commit(e), this.placement
          }
        }
        const Qt = 512 / o.$ / 2;
        class Gt {
          constructor(e, n, s) {
            this.tileID = e, this.bucketInstanceId = s, this._symbolsByKey = {};
            const u = new Map;
            for (let d = 0; d < n.length; d++) {
              const m = n.get(d),
                y = m.key,
                b = u.get(y);
              b ? b.push(m) : u.set(y, [m])
            }
            for (const [d, m] of u) {
              const y = {
                positions: m.map((b => ({
                  x: Math.floor(b.anchorX * Qt),
                  y: Math.floor(b.anchorY * Qt)
                }))),
                crossTileIDs: m.map((b => b.crossTileID))
              };
              if (y.positions.length > 128) {
                const b = new o.aI(y.positions.length, 16, Uint16Array);
                for (const {
                    x: P,
                    y: M
                  }
                  of y.positions) b.add(P, M);
                b.finish(), delete y.positions, y.index = b
              }
              this._symbolsByKey[d] = y
            }
          }
          getScaledCoordinates(e, n) {
            const {
              x: s,
              y: u,
              z: d
            } = this.tileID.canonical, {
              x: m,
              y,
              z: b
            } = n.canonical, P = Qt / Math.pow(2, b - d), M = (y * o.$ + e.anchorY) * P, L = u * o.$ * Qt;
            return {
              x: Math.floor((m * o.$ + e.anchorX) * P - s * o.$ * Qt),
              y: Math.floor(M - L)
            }
          }
          findMatches(e, n, s) {
            const u = this.tileID.canonical.z < n.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - n.canonical.z);
            for (let d = 0; d < e.length; d++) {
              const m = e.get(d);
              if (m.crossTileID) continue;
              const y = this._symbolsByKey[m.key];
              if (!y) continue;
              const b = this.getScaledCoordinates(m, n);
              if (y.index) {
                const P = y.index.range(b.x - u, b.y - u, b.x + u, b.y + u).sort();
                for (const M of P) {
                  const L = y.crossTileIDs[M];
                  if (!s[L]) {
                    s[L] = !0, m.crossTileID = L;
                    break
                  }
                }
              } else if (y.positions)
                for (let P = 0; P < y.positions.length; P++) {
                  const M = y.positions[P],
                    L = y.crossTileIDs[P];
                  if (Math.abs(M.x - b.x) <= u && Math.abs(M.y - b.y) <= u && !s[L]) {
                    s[L] = !0, m.crossTileID = L;
                    break
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({
              crossTileIDs: e
            }) => e))
          }
        }
        class ei {
          constructor() {
            this.maxCrossTileID = 0
          }
          generate() {
            return ++this.maxCrossTileID
          }
        }
        class ri {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
          }
          handleWrapJump(e) {
            const n = Math.round((e - this.lng) / 360);
            if (n !== 0)
              for (const s in this.indexes) {
                const u = this.indexes[s],
                  d = {};
                for (const m in u) {
                  const y = u[m];
                  y.tileID = y.tileID.unwrapTo(y.tileID.wrap + n), d[y.tileID.key] = y
                }
                this.indexes[s] = d
              }
            this.lng = e
          }
          addBucket(e, n, s) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === n.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
            }
            for (let d = 0; d < n.symbolInstances.length; d++) n.symbolInstances.get(d).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const u = this.usedCrossTileIDs[e.overscaledZ];
            for (const d in this.indexes) {
              const m = this.indexes[d];
              if (Number(d) > e.overscaledZ)
                for (const y in m) {
                  const b = m[y];
                  b.tileID.isChildOf(e) && b.findMatches(n.symbolInstances, e, u)
                } else {
                  const y = m[e.scaledTo(Number(d)).key];
                  y && y.findMatches(n.symbolInstances, e, u)
                }
            }
            for (let d = 0; d < n.symbolInstances.length; d++) {
              const m = n.symbolInstances.get(d);
              m.crossTileID || (m.crossTileID = s.generate(), u[m.crossTileID] = !0)
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Gt(e, n.symbolInstances, n.bucketInstanceId), !0
          }
          removeBucketCrossTileIDs(e, n) {
            for (const s of n.getCrossTileIDsLists())
              for (const u of s) delete this.usedCrossTileIDs[e][u]
          }
          removeStaleBuckets(e) {
            let n = !1;
            for (const s in this.indexes) {
              const u = this.indexes[s];
              for (const d in u) e[u[d].bucketInstanceId] || (this.removeBucketCrossTileIDs(s, u[d]), delete u[d], n = !0)
            }
            return n
          }
        }
        class gi {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new ei, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
          }
          addLayer(e, n, s) {
            let u = this.layerIndexes[e.id];
            u === void 0 && (u = this.layerIndexes[e.id] = new ri);
            let d = !1;
            const m = {};
            u.handleWrapJump(s);
            for (const y of n) {
              const b = y.getBucket(e);
              b && e.id === b.layerIds[0] && (b.bucketInstanceId || (b.bucketInstanceId = ++this.maxBucketInstanceId), u.addBucket(y.tileID, b, this.crossTileIDs) && (d = !0), m[b.bucketInstanceId] = !0)
            }
            return u.removeStaleBuckets(m) && (d = !0), d
          }
          pruneUnusedLayers(e) {
            const n = {};
            e.forEach((s => {
              n[s] = !0
            }));
            for (const s in this.layerIndexes) n[s] || delete this.layerIndexes[s]
          }
        }
        var ui = "void main() {fragColor=vec4(1.0);}";
        const fi = {
          prelude: Ar(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
          projectionMercator: Ar("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
          projectionGlobe: Ar("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
          background: Ar(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          backgroundPattern: Ar(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
          circle: Ar(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
          clippingMask: Ar(ui, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          heatmap: Ar(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
          heatmapTexture: Ar(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
          collisionBox: Ar("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
          collisionCircle: Ar("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
          colorRelief: Ar(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          debug: Ar("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
          depth: Ar(ui, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
          fill: Ar(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
          fillOutline: Ar(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillOutlinePattern: Ar(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillPattern: Ar(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
          fillExtrusion: Ar(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
          fillExtrusionPattern: Ar(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
          hillshadePrepare: Ar(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
          hillshade: Ar(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          line: Ar(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          lineGradient: Ar(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          linePattern: Ar(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
          lineSDF: Ar(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`),
          raster: Ar(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
          symbolIcon: Ar(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
          symbolSDF: Ar(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
          symbolTextAndIcon: Ar(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
          terrain: Ar("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
          terrainDepth: Ar("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
          terrainCoords: Ar("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
          projectionErrorMeasurement: Ar("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
          atmosphere: Ar(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
          sky: Ar("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
        };

        function Ar(h, e) {
          const n = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            s = e.match(/in ([\w]+) ([\w]+)/g),
            u = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            d = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            m = d ? d.concat(u) : u,
            y = {};
          return {
            fragmentSource: h = h.replace(n, ((b, P, M, L, z) => (y[z] = !0, P === "define" ? `
#ifndef HAS_UNIFORM_u_${z}
in ${M} ${L} ${z};
#else
uniform ${M} ${L} u_${z};
#endif
` : `
#ifdef HAS_UNIFORM_u_${z}
    ${M} ${L} ${z} = u_${z};
#endif
`))),
            vertexSource: e = e.replace(n, ((b, P, M, L, z) => {
              const B = L === "float" ? "vec2" : "vec4",
                U = z.match(/color/) ? "color" : B;
              return y[z] ? P === "define" ? `
#ifndef HAS_UNIFORM_u_${z}
uniform lowp float u_${z}_t;
in ${M} ${B} a_${z};
out ${M} ${L} ${z};
#else
uniform ${M} ${L} u_${z};
#endif
` : U === "vec4" ? `
#ifndef HAS_UNIFORM_u_${z}
    ${z} = a_${z};
#else
    ${M} ${L} ${z} = u_${z};
#endif
` : `
#ifndef HAS_UNIFORM_u_${z}
    ${z} = unpack_mix_${U}(a_${z}, u_${z}_t);
#else
    ${M} ${L} ${z} = u_${z};
#endif
` : P === "define" ? `
#ifndef HAS_UNIFORM_u_${z}
uniform lowp float u_${z}_t;
in ${M} ${B} a_${z};
#else
uniform ${M} ${L} u_${z};
#endif
` : U === "vec4" ? `
#ifndef HAS_UNIFORM_u_${z}
    ${M} ${L} ${z} = a_${z};
#else
    ${M} ${L} ${z} = u_${z};
#endif
` : `
#ifndef HAS_UNIFORM_u_${z}
    ${M} ${L} ${z} = unpack_mix_${U}(a_${z}, u_${z}_t);
#else
    ${M} ${L} ${z} = u_${z};
#endif
`
            })),
            staticAttributes: s,
            staticUniforms: m
          }
        }
        class Bi {
          constructor(e, n, s) {
            this.vertexBuffer = e, this.indexBuffer = n, this.segments = s
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null
          }
        }
        var hi = o.aJ([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }]);
        const Jr = "#define PROJECTION_MERCATOR",
          ti = "mercator";
        class br {
          constructor() {
            this._cachedMesh = null
          }
          get name() {
            return "mercator"
          }
          get useSubdivision() {
            return !1
          }
          get shaderVariantName() {
            return ti
          }
          get shaderDefine() {
            return Jr
          }
          get shaderPreludeCode() {
            return fi.projectionMercator
          }
          get vertexShaderPreludeCode() {
            return fi.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return o.aK.noSubdivision
          }
          get useGlobeControls() {
            return !1
          }
          get transitionState() {
            return 0
          }
          get latitudeErrorCorrectionRadians() {
            return 0
          }
          destroy() {}
          updateGPUdependent(e) {}
          getMeshFromTileID(e, n, s, u, d) {
            if (this._cachedMesh) return this._cachedMesh;
            const m = new o.aL;
            m.emplaceBack(0, 0), m.emplaceBack(o.$, 0), m.emplaceBack(0, o.$), m.emplaceBack(o.$, o.$);
            const y = e.createVertexBuffer(m, hi.members),
              b = o.aM.simpleSegment(0, 0, 4, 2),
              P = new o.aN;
            P.emplaceBack(1, 0, 2), P.emplaceBack(1, 2, 3);
            const M = e.createIndexBuffer(P);
            return this._cachedMesh = new Bi(y, M, b), this._cachedMesh
          }
          recalculate() {}
          hasTransition() {
            return !1
          }
          setErrorQueryLatitudeDegrees(e) {}
        }
        class Yi {
          constructor(e = 0, n = 0, s = 0, u = 0) {
            if (isNaN(e) || e < 0 || isNaN(n) || n < 0 || isNaN(s) || s < 0 || isNaN(u) || u < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = n, this.left = s, this.right = u
          }
          interpolate(e, n, s) {
            return n.top != null && e.top != null && (this.top = o.C.number(e.top, n.top, s)), n.bottom != null && e.bottom != null && (this.bottom = o.C.number(e.bottom, n.bottom, s)), n.left != null && e.left != null && (this.left = o.C.number(e.left, n.left, s)), n.right != null && e.right != null && (this.right = o.C.number(e.right, n.right, s)), this
          }
          getCenter(e, n) {
            const s = o.ah((this.left + e - this.right) / 2, 0, e),
              u = o.ah((this.top + n - this.bottom) / 2, 0, n);
            return new o.P(s, u)
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
          }
          clone() {
            return new Yi(this.top, this.bottom, this.left, this.right)
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right
            }
          }
        }

        function Ni(h, e) {
          if (!h.renderWorldCopies || h.lngRange) return;
          const n = e.lng - h.center.lng;
          e.lng += n > 180 ? -360 : n < -180 ? 360 : 0
        }

        function cn(h) {
          return Math.max(0, Math.floor(h))
        }
        class Ji {
          constructor(e, n, s, u, d, m) {
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = m === void 0 || !!m, this._minZoom = n || 0, this._maxZoom = s || 22, this._minPitch = u ?? 0, this._maxPitch = d ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new o.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = cn(this._zoom), this._scale = o.af(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Yi, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0
          }
          apply(e, n, s) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = cn(this._zoom), this._scale = o.af(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new Yi(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !s && e.autoCalculateNearFarZ, n && this._constrain(), this._calcMatrices()
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e
          }
          get tileSize() {
            return this._tileSize
          }
          get tileZoom() {
            return this._tileZoom
          }
          get scale() {
            return this._scale
          }
          get width() {
            return this._width
          }
          get height() {
            return this._height
          }
          get bearingInRadians() {
            return this._bearingInRadians
          }
          get lngRange() {
            return this._lngRange
          }
          get latRange() {
            return this._latRange
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits
          }
          get minZoom() {
            return this._minZoom
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
          }
          get maxZoom() {
            return this._maxZoom
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
          }
          get minPitch() {
            return this._minPitch
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)))
          }
          get maxPitch() {
            return this._maxPitch
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)))
          }
          get renderWorldCopies() {
            return this._renderWorldCopies
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e
          }
          get worldSize() {
            return this._tileSize * this._scale
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2))
          }
          get size() {
            return new o.P(this._width, this._height)
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180
          }
          setBearing(e) {
            const n = o.aO(e, -180, 180) * Math.PI / 180;
            var s, u, d, m, y, b, P, M, L;
            this._bearingInRadians !== n && (this._unmodified = !1, this._bearingInRadians = n, this._calcMatrices(), this._rotationMatrix = W(), s = this._rotationMatrix, d = -this._bearingInRadians, m = (u = this._rotationMatrix)[0], y = u[1], b = u[2], P = u[3], M = Math.sin(d), L = Math.cos(d), s[0] = m * L + b * M, s[1] = y * L + P * M, s[2] = m * -M + b * L, s[3] = y * -M + P * L)
          }
          get rotationMatrix() {
            return this._rotationMatrix
          }
          get pitchInRadians() {
            return this._pitchInRadians
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180
          }
          setPitch(e) {
            const n = o.ah(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== n && (this._unmodified = !1, this._pitchInRadians = n, this._calcMatrices())
          }
          get rollInRadians() {
            return this._rollInRadians
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180
          }
          setRoll(e) {
            const n = e / 180 * Math.PI;
            this._rollInRadians !== n && (this._unmodified = !1, this._rollInRadians = n, this._calcMatrices())
          }
          get fovInRadians() {
            return this._fovInRadians
          }
          get fov() {
            return o.aP(this._fovInRadians)
          }
          setFov(e) {
            e = o.ah(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = o.ae(e), this._calcMatrices())
          }
          get zoom() {
            return this._zoom
          }
          setZoom(e) {
            const n = this.getConstrained(this._center, e).zoom;
            this._zoom !== n && (this._unmodified = !1, this._zoom = n, this._tileZoom = Math.max(0, Math.floor(n)), this._scale = o.af(n), this._constrain(), this._calcMatrices())
          }
          get center() {
            return this._center
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices())
          }
          get elevation() {
            return this._elevation
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices())
          }
          get padding() {
            return this._edgeInsets.toJSON()
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices())
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height)
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter
          }
          get unmodified() {
            return this._unmodified
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance
          }
          get nearZ() {
            return this._nearZ
          }
          get farZ() {
            return this._farZ
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ
          }
          overrideNearFarZ(e, n) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = n, this._calcMatrices()
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices()
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e)
          }
          interpolatePadding(e, n, s) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, n, s), this._constrain(), this._calcMatrices()
          }
          resize(e, n, s = !0) {
            this._width = e, this._height = n, s && this._constrain(), this._calcMatrices()
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new ht([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-o.ai, o.ai])
          }
          getConstrained(e, n) {
            return this._callbacks.getConstrained(e, n)
          }
          getCameraQueryGeometry(e, n) {
            if (n.length === 1) return [n[0], e];
            {
              const {
                minX: s,
                minY: u,
                maxX: d,
                maxY: m
              } = o.a2.fromPoints(n).extend(e);
              return [new o.P(s, u), new o.P(d, u), new o.P(d, m), new o.P(s, m), new o.P(s, u)]
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified,
              {
                center: n,
                zoom: s
              } = this.getConstrained(this.center, this.zoom);
            this.setCenter(n), this.setZoom(s), this._unmodified = e, this._constraining = !1
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = o.ag(new Float64Array(16));
              o.N(e, e, [this._width / 2, -this._height / 2, 1]), o.M(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = o.ag(new Float64Array(16)), o.N(e, e, [1, -1, 1]), o.M(e, e, [-1, -1, 0]), o.N(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
            }
            this._callbacks.calcMatrices()
          }
          calculateCenterFromCameraLngLatAlt(e, n, s, u) {
            const d = s !== void 0 ? s : this.bearing,
              m = u = u !== void 0 ? u : this.pitch,
              y = o.a1.fromLngLat(e, n),
              b = -Math.cos(o.ae(m)),
              P = Math.sin(o.ae(m)),
              M = P * Math.sin(o.ae(d)),
              L = -P * Math.cos(o.ae(d));
            let z = this.elevation;
            const B = n - z;
            let U;
            b * B >= 0 || Math.abs(b) < .1 ? (U = 1e4, z = n + U * b) : U = -B / b;
            let Q, J, re = o.aQ(1, y.y),
              se = 0;
            do {
              if (se += 1, se > 10) break;
              J = U / re, Q = new o.a1(y.x + M * J, y.y + L * J), re = 1 / Q.meterInMercatorCoordinateUnits()
            } while (Math.abs(U - J * re) > 1e-12);
            return {
              center: Q.toLngLat(),
              elevation: z,
              zoom: o.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / J / this.tileSize)
            }
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const n = o.aj(1, this.center.lat) * this.worldSize,
              s = this.cameraToCenterDistance / n,
              u = o.a1.fromLngLat(this.center, this.elevation),
              d = Ee(this.center, this.elevation, this.pitch, this.bearing, s);
            this._elevation = e;
            const m = this.calculateCenterFromCameraLngLatAlt(d.toLngLat(), o.aQ(d.z, u.y), this.bearing, this.pitch);
            this._elevation = m.elevation, this._center = m.center, this.setZoom(m.zoom)
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new o.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)))
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
          }
          getCameraLngLat() {
            const e = o.aj(1, this.center.lat) * this.worldSize;
            return Ee(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const n = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / n, e.canonical.y / n, 1 / n / o.$, 1 / n / o.$]
          }
        }
        class Ui {
          constructor(e, n) {
            this.min = e, this.max = n, this.center = o.aR([], o.aS([], this.min, this.max), .5)
          }
          quadrant(e) {
            const n = [e % 2 == 0, e < 2],
              s = o.aT(this.min),
              u = o.aT(this.max);
            for (let d = 0; d < n.length; d++) s[d] = n[d] ? this.min[d] : this.center[d], u[d] = n[d] ? this.center[d] : this.max[d];
            return u[2] = this.max[2], new Ui(s, u)
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
          }
          intersectsFrustum(e) {
            let n = !0;
            for (let s = 0; s < e.planes.length; s++) {
              const u = this.intersectsPlane(e.planes[s]);
              if (u === 0) return 0;
              u === 1 && (n = !1)
            }
            return n ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
          }
          intersectsPlane(e) {
            let n = e[3],
              s = e[3];
            for (let u = 0; u < 3; u++) e[u] > 0 ? (n += e[u] * this.min[u], s += e[u] * this.max[u]) : (s += e[u] * this.min[u], n += e[u] * this.max[u]);
            return n >= 0 ? 2 : s < 0 ? 0 : 1
          }
        }
        class Qi {
          distanceToTile2d(e, n, s, u) {
            const d = u.distanceX([e, n]),
              m = u.distanceY([e, n]);
            return Math.hypot(d, m)
          }
          getWrap(e, n, s) {
            return s
          }
          getTileBoundingVolume(e, n, s, u) {
            var d, m;
            let y = 0,
              b = 0;
            if (u != null && u.terrain) {
              const M = new o.Z(e.z, n, e.z, e.x, e.y),
                L = u.terrain.getMinMaxElevation(M);
              y = (d = L.minElevation) !== null && d !== void 0 ? d : Math.min(0, s), b = (m = L.maxElevation) !== null && m !== void 0 ? m : Math.max(0, s)
            }
            const P = 1 << e.z;
            return new Ui([n + e.x / P, e.y / P, y], [n + (e.x + 1) / P, (e.y + 1) / P, b])
          }
          allowVariableZoom(e, n) {
            const s = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height,
              u = o.ah(78.5 - s / 2, 0, 60);
            return !!n.terrain || e.pitch > u
          }
          allowWorldCopies() {
            return !0
          }
          prepareNextFrame() {}
        }
        class Ci {
          constructor(e, n, s) {
            this.points = e, this.planes = n, this.aabb = s
          }
          static fromInvProjectionMatrix(e, n = 1, s = 0, u, d) {
            const m = d ? [
                [6, 5, 4],
                [0, 1, 2],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ] : [
                [0, 1, 2],
                [6, 5, 4],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ],
              y = Math.pow(2, s),
              b = [
                [-1, 1, -1, 1],
                [1, 1, -1, 1],
                [1, -1, -1, 1],
                [-1, -1, -1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, -1, 1, 1],
                [-1, -1, 1, 1]
              ].map((z => (function(B, U, Q, J) {
                const re = o.aw([], B, U),
                  se = 1 / re[3] / Q * J;
                return o.aY(re, re, [se, se, 1 / re[3], se])
              })(z, e, n, y)));
            u && (function(z, B, U, Q) {
              const J = Q ? 4 : 0,
                re = Q ? 0 : 4;
              let se = 0;
              const de = [],
                ue = [];
              for (let he = 0; he < 4; he++) {
                const ze = o.aU([], z[he + re], z[he + J]),
                  He = o.aZ(ze);
                o.aR(ze, ze, 1 / He), de.push(He), ue.push(ze)
              }
              for (let he = 0; he < 4; he++) {
                const ze = o.a_(z[he + J], ue[he], U);
                se = ze !== null && ze >= 0 ? Math.max(se, ze) : Math.max(se, de[he])
              }
              const ge = (function(he, ze) {
                  const He = o.aU([], he[ze[0]], he[ze[1]]),
                    Ne = o.aU([], he[ze[2]], he[ze[1]]),
                    qe = [0, 0, 0, 0];
                  return o.aV(qe, o.aW([], He, Ne)), qe[3] = -o.aX(qe, he[ze[0]]), qe
                })(z, B),
                we = (function(he, ze) {
                  const He = o.a$(he),
                    Ne = o.b0([], he, 1 / He),
                    qe = o.aU([], ze, o.aR([], Ne, o.aX(ze, Ne))),
                    Ge = o.a$(qe);
                  if (Ge > 0) {
                    const Dt = Math.sqrt(1 - Ne[3] * Ne[3]),
                      Ft = o.aR([], Ne, -Ne[3]),
                      vt = o.aS([], Ft, o.aR([], qe, Dt / Ge));
                    return o.b1(ze, vt)
                  }
                  return null
                })(U, ge);
              if (we !== null) {
                const he = we / o.aX(ue[0], ge);
                se = Math.min(se, he)
              }
              for (let he = 0; he < 4; he++) {
                const ze = Math.min(se, de[he]);
                z[he + re] = [z[he + J][0] + ue[he][0] * ze, z[he + J][1] + ue[he][1] * ze, z[he + J][2] + ue[he][2] * ze, 1]
              }
            })(b, m[0], u, d);
            const P = m.map((z => {
                const B = o.aU([], b[z[0]], b[z[1]]),
                  U = o.aU([], b[z[2]], b[z[1]]),
                  Q = o.aV([], o.aW([], B, U)),
                  J = -o.aX(Q, b[z[1]]);
                return Q.concat(J)
              })),
              M = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
              L = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const z of b)
              for (let B = 0; B < 3; B++) M[B] = Math.min(M[B], z[B]), L[B] = Math.max(L[B], z[B]);
            return new Ci(b, P, new Ui(M, L))
          }
        }
        class ci {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, n, s) {
            return this._helper.interpolatePadding(e, n, s)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, n, s = !0) {
            this._helper.resize(e, n, s)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          overrideNearFarZ(e, n) {
            this._helper.overrideNearFarZ(e, n)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e, n) {}
          constructor(e, n, s, u, d) {
            this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this._helper = new Ji({
              calcMatrices: () => {
                this._calcMatrices()
              },
              getConstrained: (m, y) => this.getConstrained(m, y)
            }, e, n, s, u, d), this._coveringTilesDetailsProvider = new Qi
          }
          clone() {
            const e = new ci;
            return e.apply(this), e
          }
          apply(e, n, s) {
            this._helper.apply(e, n, s)
          }
          get cameraPosition() {
            return this._cameraPosition
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix
          }
          get mercatorMatrix() {
            return this._mercatorMatrix
          }
          getVisibleUnwrappedCoordinates(e) {
            const n = [new o.b2(0, e)];
            if (this._helper._renderWorldCopies) {
              const s = this.screenPointToMercatorCoordinate(new o.P(0, 0)),
                u = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, 0)),
                d = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, this._helper._height)),
                m = this.screenPointToMercatorCoordinate(new o.P(0, this._helper._height)),
                y = Math.floor(Math.min(s.x, u.x, d.x, m.x)),
                b = Math.floor(Math.max(s.x, u.x, d.x, m.x)),
                P = 1;
              for (let M = y - P; M <= b + P; M++) M !== 0 && n.push(new o.b2(M, e))
            }
            return n
          }
          getCameraFrustum() {
            return Ci.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
          }
          getClippingPlane() {
            return null
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            const n = this.screenPointToLocation(this.centerPoint, e),
              s = e ? e.getElevationForLngLatZoom(n, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(s)
          }
          setLocationAtPoint(e, n) {
            const s = o.aj(this.elevation, this.center.lat),
              u = this.screenPointToMercatorCoordinateAtZ(n, s),
              d = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, s),
              m = o.a1.fromLngLat(e),
              y = new o.a1(m.x - (u.x - d.x), m.y - (u.y - d.y));
            this.setCenter(y == null ? void 0 : y.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
          }
          locationToScreenPoint(e, n) {
            return n ? this.coordinatePoint(o.a1.fromLngLat(e), n.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(o.a1.fromLngLat(e))
          }
          screenPointToLocation(e, n) {
            var s;
            return (s = this.screenPointToMercatorCoordinate(e, n)) === null || s === void 0 ? void 0 : s.toLngLat()
          }
          screenPointToMercatorCoordinate(e, n) {
            if (n) {
              const s = n.pointCoordinate(e);
              if (s != null) return s
            }
            return this.screenPointToMercatorCoordinateAtZ(e)
          }
          screenPointToMercatorCoordinateAtZ(e, n) {
            const s = n || 0,
              u = [e.x, e.y, 0, 1],
              d = [e.x, e.y, 1, 1];
            o.aw(u, u, this._pixelMatrixInverse), o.aw(d, d, this._pixelMatrixInverse);
            const m = u[3],
              y = d[3],
              b = u[1] / m,
              P = d[1] / y,
              M = u[2] / m,
              L = d[2] / y,
              z = M === L ? 0 : (s - M) / (L - M);
            return new o.a1(o.C.number(u[0] / m, d[0] / y, z) / this.worldSize, o.C.number(b, P, z) / this.worldSize, s)
          }
          coordinatePoint(e, n = 0, s = this._pixelMatrix) {
            const u = [e.x * this.worldSize, e.y * this.worldSize, n, 1];
            return o.aw(u, u, s), new o.P(u[0] / u[3], u[1] / u[3])
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - oe(this));
            return new ht().extend(this.screenPointToLocation(new o.P(0, e))).extend(this.screenPointToLocation(new o.P(this._helper._width, e))).extend(this.screenPointToLocation(new o.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new o.P(0, this._helper._height)))
          }
          isPointOnMapSurface(e, n) {
            return n ? n.pointCoordinate(e) != null : e.y > this.height / 2 - oe(this)
          }
          calculatePosMatrix(e, n = !1, s) {
            var u;
            const d = (u = e.key) !== null && u !== void 0 ? u : o.b3(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y),
              m = n ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (m.has(d)) {
              const P = m.get(d);
              return s ? P.f32 : P.f64
            }
            const y = me(e, this.worldSize);
            o.O(y, n ? this._alignedProjMatrix : this._viewProjMatrix, y);
            const b = {
              f64: y,
              f32: new Float32Array(y)
            };
            return m.set(d, b), s ? b.f32 : b.f64
          }
          calculateFogMatrix(e) {
            const n = e.key,
              s = this._fogMatrixCacheF32;
            if (s.has(n)) return s.get(n);
            const u = me(e, this.worldSize);
            return o.O(u, this._fogMatrix, u), s.set(n, new Float32Array(u)), s.get(n)
          }
          getConstrained(e, n) {
            n = o.ah(+n, this.minZoom, this.maxZoom);
            const s = {
              center: new o.S(e.lng, e.lat),
              zoom: n
            };
            let u = this._helper._lngRange;
            if (!this._helper._renderWorldCopies && u === null) {
              const de = 179.9999999999;
              u = [-de, de]
            }
            const d = this.tileSize * o.af(s.zoom);
            let m = 0,
              y = d,
              b = 0,
              P = d,
              M = 0,
              L = 0;
            const {
              x: z,
              y: B
            } = this.size;
            if (this._helper._latRange) {
              const de = this._helper._latRange;
              m = o.U(de[1]) * d, y = o.U(de[0]) * d, y - m < B && (M = B / (y - m))
            }
            u && (b = o.aO(o.V(u[0]) * d, 0, d), P = o.aO(o.V(u[1]) * d, 0, d), P < b && (P += d), P - b < z && (L = z / (P - b)));
            const {
              x: U,
              y: Q
            } = $(d, e);
            let J, re;
            const se = Math.max(L || 0, M || 0);
            if (se) {
              const de = new o.P(L ? (P + b) / 2 : U, M ? (y + m) / 2 : Q);
              return s.center = X(d, de).wrap(), s.zoom += o.ak(se), s
            }
            if (this._helper._latRange) {
              const de = B / 2;
              Q - de < m && (re = m + de), Q + de > y && (re = y - de)
            }
            if (u) {
              const de = (b + P) / 2;
              let ue = U;
              this._helper._renderWorldCopies && (ue = o.aO(U, de - d / 2, de + d / 2));
              const ge = z / 2;
              ue - ge < b && (J = b + ge), ue + ge > P && (J = P - ge)
            }
            if (J !== void 0 || re !== void 0) {
              const de = new o.P(J ?? U, re ?? Q);
              s.center = X(d, de).wrap()
            }
            return s
          }
          calculateCenterFromCameraLngLatAlt(e, n, s, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, n, s, u)
          }
          _calculateNearFarZIfNeeded(e, n, s) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const u = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100),
              d = e - u * this._helper._pixelPerMeter / Math.cos(n),
              m = u < 0 ? d : e,
              y = Math.PI / 2 + this.pitchInRadians,
              b = o.ae(this.fov) * (Math.abs(Math.cos(o.ae(this.roll))) * this.height + Math.abs(Math.sin(o.ae(this.roll))) * this.width) / this.height * (.5 + s.y / this.height),
              P = Math.sin(b) * m / Math.sin(o.ah(Math.PI - y - b, .01, Math.PI - .01)),
              M = oe(this),
              L = Math.atan(M / this._helper.cameraToCenterDistance),
              z = o.ae(.75),
              B = L > z ? 2 * L * (.5 + s.y / (2 * M)) : z,
              U = Math.sin(B) * m / Math.sin(o.ah(Math.PI - y - B, .01, Math.PI - .01)),
              Q = Math.min(P, U);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - n) * Q + m), this._helper._nearZ = this._helper._height / 50
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset,
              n = $(this.worldSize, this.center),
              s = n.x,
              u = n.y;
            this._helper._pixelPerMeter = o.aj(1, this.center.lat) * this.worldSize;
            const d = o.ae(Math.min(this.pitch, q)),
              m = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(d));
            let y;
            this._calculateNearFarZIfNeeded(m, d, e), y = new Float64Array(16), o.b4(y, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), o.aq(this._invProjMatrix, y), y[8] = 2 * -e.x / this._helper._width, y[9] = 2 * e.y / this._helper._height, this._projectionMatrix = o.b5(y), o.N(y, y, [1, -1, 1]), o.M(y, y, [0, 0, -this._helper.cameraToCenterDistance]), o.b6(y, y, -this.rollInRadians), o.b7(y, y, this.pitchInRadians), o.b6(y, y, -this.bearingInRadians), o.M(y, y, [-s, -u, 0]), this._mercatorMatrix = o.N([], y, [this.worldSize, this.worldSize, this.worldSize]), o.N(y, y, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, y), o.M(y, y, [0, 0, -this.elevation]), this._viewProjMatrix = y, this._invViewProjMatrix = o.aq([], y);
            const b = [0, 0, -1, 1];
            o.aw(b, b, this._invViewProjMatrix), this._cameraPosition = [b[0] / b[3], b[1] / b[3], b[2] / b[3]], this._fogMatrix = new Float64Array(16), o.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, m, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, o.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]), o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), o.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), o.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), o.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), o.M(this._fogMatrix, this._fogMatrix, [-s, -u, 0]), o.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, y);
            const P = this._helper._width % 2 / 2,
              M = this._helper._height % 2 / 2,
              L = Math.cos(this.bearingInRadians),
              z = Math.sin(-this.bearingInRadians),
              B = s - Math.round(s) + L * P + z * M,
              U = u - Math.round(u) + L * M + z * P,
              Q = new Float64Array(y);
            if (o.M(Q, Q, [B > .5 ? B - 1 : B, U > .5 ? U - 1 : U, 0]), this._alignedProjMatrix = Q, y = o.aq(new Float64Array(16), this._pixelMatrix), !y) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = y, this._clearMatrixCaches()
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear()
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new o.P(0, 0)),
              n = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return o.aw(n, n, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            const e = o.aj(1, this.center.lat) * this.worldSize;
            return Ee(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
          }
          lngLatToCameraDepth(e, n) {
            const s = o.a1.fromLngLat(e),
              u = [s.x * this.worldSize, s.y * this.worldSize, n, 1];
            return o.aw(u, u, this._viewProjMatrix), u[2] / u[3]
          }
          getProjectionData(e) {
            const {
              overscaledTileID: n,
              aligned: s,
              applyTerrainMatrix: u
            } = e, d = this._helper.getMercatorTileCoordinates(n), m = n ? this.calculatePosMatrix(n, s, !0) : null;
            let y;
            return y = n && n.terrainRttPosMatrix32f && u ? n.terrainRttPosMatrix32f : m || o.b8(), {
              mainMatrix: y,
              tileMercatorCoords: d,
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: y
            }
          }
          isLocationOccluded(e) {
            return !1
          }
          getPixelScale() {
            return 1
          }
          getCircleRadiusCorrection() {
            return 1
          }
          getPitchedTextCorrection(e, n, s) {
            return 1
          }
          transformLightDirection(e) {
            return o.aT(e)
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.")
          }
          projectTileCoordinates(e, n, s, u) {
            const d = this.calculatePosMatrix(s);
            let m;
            u ? (m = [e, n, u(e, n), 1], o.aw(m, m, d)) : (m = [e, n, 0, 1], Di(m, m, d));
            const y = m[3];
            return {
              point: new o.P(m[0] / y, m[1] / y),
              signedDistanceFromCamera: y,
              isOccluded: !1
            }
          }
          populateCache(e) {
            for (const n of e) this.calculatePosMatrix(n)
          }
          getMatrixForModel(e, n) {
            const s = o.a1.fromLngLat(e, n),
              u = s.meterInMercatorCoordinateUnits(),
              d = o.b9();
            return o.M(d, d, [s.x, s.y, s.z]), o.b6(d, d, Math.PI), o.b7(d, d, Math.PI / 2), o.N(d, d, [-u, u, u]), d
          }
          getProjectionDataForCustomLayer(e = !0) {
            const n = new o.Z(0, 0, 0, 0, 0),
              s = this.getProjectionData({
                overscaledTileID: n,
                applyGlobeMatrix: e
              }),
              u = me(n, this.worldSize);
            o.O(u, this._viewProjMatrix, u), s.tileMercatorCoords = [0, 0, 1, 1];
            const d = [o.$, o.$, this.worldSize / this._helper.pixelsPerMeter],
              m = o.ba();
            return o.N(m, u, d), s.fallbackMatrix = m, s.mainMatrix = m, s
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e)
          }
        }

        function Ko() {
          o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
        }

        function un(h) {
          if (h.useSlerp)
            if (h.k < 1) {
              const e = o.bb(h.startEulerAngles.roll, h.startEulerAngles.pitch, h.startEulerAngles.bearing),
                n = o.bb(h.endEulerAngles.roll, h.endEulerAngles.pitch, h.endEulerAngles.bearing),
                s = new Float64Array(4);
              o.bc(s, e, n, h.k);
              const u = o.bd(s);
              h.tr.setRoll(u.roll), h.tr.setPitch(u.pitch), h.tr.setBearing(u.bearing)
            } else h.tr.setRoll(h.endEulerAngles.roll), h.tr.setPitch(h.endEulerAngles.pitch), h.tr.setBearing(h.endEulerAngles.bearing);
          else h.tr.setRoll(o.C.number(h.startEulerAngles.roll, h.endEulerAngles.roll, h.k)), h.tr.setPitch(o.C.number(h.startEulerAngles.pitch, h.endEulerAngles.pitch, h.k)), h.tr.setBearing(o.C.number(h.startEulerAngles.bearing, h.endEulerAngles.bearing, h.k))
        }

        function Nn(h, e, n, s, u) {
          const d = u.padding,
            m = $(u.worldSize, n.getNorthWest()),
            y = $(u.worldSize, n.getNorthEast()),
            b = $(u.worldSize, n.getSouthEast()),
            P = $(u.worldSize, n.getSouthWest()),
            M = o.ae(-s),
            L = m.rotate(M),
            z = y.rotate(M),
            B = b.rotate(M),
            U = P.rotate(M),
            Q = new o.P(Math.max(L.x, z.x, U.x, B.x), Math.max(L.y, z.y, U.y, B.y)),
            J = new o.P(Math.min(L.x, z.x, U.x, B.x), Math.min(L.y, z.y, U.y, B.y)),
            re = Q.sub(J),
            se = (u.width - (d.left + d.right + e.left + e.right)) / re.x,
            de = (u.height - (d.top + d.bottom + e.top + e.bottom)) / re.y;
          if (de < 0 || se < 0) return void Ko();
          const ue = Math.min(o.ak(u.scale * Math.min(se, de)), h.maxZoom),
            ge = o.P.convert(h.offset),
            we = new o.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(o.ae(s)),
            he = ge.add(we).mult(u.scale / o.af(ue));
          return {
            center: X(u.worldSize, m.add(b).div(2).sub(he)),
            zoom: ue,
            bearing: s
          }
        }
        class hn {
          get useGlobeControls() {
            return !1
          }
          handlePanInertia(e, n) {
            return {
              easingOffset: e,
              easingCenter: n.center
            }
          }
          handleMapControlsRollPitchBearingZoom(e, n) {
            e.bearingDelta && n.setBearing(n.bearing + e.bearingDelta), e.pitchDelta && n.setPitch(n.pitch + e.pitchDelta), e.rollDelta && n.setRoll(n.roll + e.rollDelta), e.zoomDelta && n.setZoom(n.zoom + e.zoomDelta)
          }
          handleMapControlsPan(e, n, s) {
            e.around.distSqr(n.centerPoint) < .01 || n.setLocationAtPoint(s, e.around)
          }
          cameraForBoxAndBearing(e, n, s, u, d) {
            return Nn(e, n, s, u, d)
          }
          handleJumpToCenterZoom(e, n) {
            e.zoom !== (n.zoom !== void 0 ? +n.zoom : e.zoom) && e.setZoom(+n.zoom), n.center !== void 0 && e.setCenter(o.S.convert(n.center))
          }
          handleEaseTo(e, n) {
            const s = e.zoom,
              u = e.padding,
              d = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              m = {
                roll: n.roll === void 0 ? e.roll : n.roll,
                pitch: n.pitch === void 0 ? e.pitch : n.pitch,
                bearing: n.bearing === void 0 ? e.bearing : n.bearing
              },
              y = n.zoom !== void 0,
              b = !e.isPaddingEqual(n.padding);
            let P = !1;
            const M = y ? +n.zoom : e.zoom;
            let L = e.centerPoint.add(n.offsetAsPoint);
            const z = e.screenPointToLocation(L),
              {
                center: B,
                zoom: U
              } = e.getConstrained(o.S.convert(n.center || z), M ?? s);
            Ni(e, B);
            const Q = $(e.worldSize, z),
              J = $(e.worldSize, B).sub(Q),
              re = o.af(U - s);
            return P = U !== s, {
              easeFunc: se => {
                if (P && e.setZoom(o.C.number(s, U, se)), o.be(d, m) || un({
                    startEulerAngles: d,
                    endEulerAngles: m,
                    tr: e,
                    k: se,
                    useSlerp: d.roll != m.roll
                  }), b && (e.interpolatePadding(u, n.padding, se), L = e.centerPoint.add(n.offsetAsPoint)), n.around) e.setLocationAtPoint(n.around, n.aroundPoint);
                else {
                  const de = o.af(e.zoom - s),
                    ue = U > s ? Math.min(2, re) : Math.max(.5, re),
                    ge = Math.pow(ue, 1 - se),
                    we = X(e.worldSize, Q.add(J.mult(se * ge)).mult(de));
                  e.setLocationAtPoint(e.renderWorldCopies ? we.wrap() : we, L)
                }
              },
              isZooming: P,
              elevationCenter: B
            }
          }
          handleFlyTo(e, n) {
            const s = n.zoom !== void 0,
              u = e.zoom,
              d = e.getConstrained(o.S.convert(n.center || n.locationAtOffset), s ? +n.zoom : u),
              m = d.center,
              y = d.zoom;
            Ni(e, m);
            const b = $(e.worldSize, n.locationAtOffset),
              P = $(e.worldSize, m).sub(b),
              M = P.mag(),
              L = o.af(y - u);
            let z;
            if (n.minZoom !== void 0) {
              const B = Math.min(+n.minZoom, u, y),
                U = e.getConstrained(m, B).zoom;
              z = o.af(U - u)
            }
            return {
              easeFunc: (B, U, Q, J) => {
                e.setZoom(B === 1 ? y : u + o.ak(U));
                const re = B === 1 ? m : X(e.worldSize, b.add(P.mult(Q)).mult(U));
                e.setLocationAtPoint(e.renderWorldCopies ? re.wrap() : re, J)
              },
              scaleOfZoom: L,
              targetCenter: m,
              scaleOfMinZoom: z,
              pixelPathLength: M
            }
          }
        }
        class Si {
          constructor(e, n, s) {
            this.blendFunction = e, this.blendColor = n, this.mask = s
          }
        }
        Si.Replace = [1, 0], Si.disabled = new Si(Si.Replace, o.bf.transparent, [!1, !1, !1, !1]), Si.unblended = new Si(Si.Replace, o.bf.transparent, [!0, !0, !0, !0]), Si.alphaBlended = new Si([1, 771], o.bf.transparent, [!0, !0, !0, !0]);
        const Ua = 2305;
        class wr {
          constructor(e, n, s) {
            this.enable = e, this.mode = n, this.frontFace = s
          }
        }
        wr.disabled = new wr(!1, 1029, Ua), wr.backCCW = new wr(!0, 1029, Ua), wr.frontCCW = new wr(!0, 1028, Ua);
        class Ur {
          constructor(e, n, s) {
            this.func = e, this.mask = n, this.range = s
          }
        }
        Ur.ReadOnly = !1, Ur.ReadWrite = !0, Ur.disabled = new Ur(519, Ur.ReadOnly, [0, 1]);
        const ga = 7680;
        class di {
          constructor(e, n, s, u, d, m) {
            this.test = e, this.ref = n, this.mask = s, this.fail = u, this.depthFail = d, this.pass = m
          }
        }
        di.disabled = new di({
          func: 519,
          mask: 0
        }, 0, 0, ga, ga, ga);
        const ra = new WeakMap;

        function Da(h) {
          var e;
          if (ra.has(h)) return ra.get(h);
          {
            const n = (e = h.getParameter(h.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return ra.set(h, n), n
          }
        }
        class Ra {
          get awaitingQuery() {
            return !!this._readbackQueue
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const n = e.context,
              s = n.gl;
            this._texFormat = s.RGBA, this._texType = s.UNSIGNED_BYTE;
            const u = new o.aL;
            u.emplaceBack(-1, -1), u.emplaceBack(2, -1), u.emplaceBack(-1, 2);
            const d = new o.aN;
            d.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Bi(n.createVertexBuffer(u, hi.members), n.createIndexBuffer(d), o.aM.simpleSegment(0, 0, u.length, d.length)), this._resultBuffer = new Uint8Array(4), n.activeTexture.set(s.TEXTURE1);
            const m = s.createTexture();
            s.bindTexture(s.TEXTURE_2D, m), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST), s.texImage2D(s.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = n.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(m), Da(s) && (this._pbo = s.createBuffer(), s.bindBuffer(s.PIXEL_PACK_BUFFER, this._pbo), s.bufferData(s.PIXEL_PACK_BUFFER, 4, s.STREAM_READ), s.bindBuffer(s.PIXEL_PACK_BUFFER, null))
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null
          }
          updateErrorLoop(e, n) {
            const s = this._updateCount;
            return this._readbackQueue ? s >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : s >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, n), this._updateCount++, this._measuredError
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context,
              n = e.gl;
            e.activeTexture.set(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer)
          }
          _renderErrorTexture(e, n) {
            const s = this._cachedRenderContext.context,
              u = s.gl;
            if (this._bindFramebuffer(), s.viewport.set([0, 0, this._texWidth, this._texHeight]), s.clear({
                color: o.bf.transparent
              }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(s, u.TRIANGLES, Ur.disabled, di.disabled, Si.unblended, wr.disabled, ((d, m) => ({
                u_input: d,
                u_output_expected: m
              }))(e, n), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Da(u)) {
              u.bindBuffer(u.PIXEL_PACK_BUFFER, this._pbo), u.readBuffer(u.COLOR_ATTACHMENT0), u.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), u.bindBuffer(u.PIXEL_PACK_BUFFER, null);
              const d = u.fenceSync(u.SYNC_GPU_COMMANDS_COMPLETE, 0);
              u.flush(), this._readbackQueue = {
                frameNumberIssued: this._updateCount,
                sync: d
              }
            } else this._readbackQueue = {
              frameNumberIssued: this._updateCount,
              sync: null
            }
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Da(e)) {
              const n = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (n === e.WAIT_FAILED) return o.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void(this._lastReadbackFrame = this._updateCount);
              if (n === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = Ra._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount
          }
          static _parseRGBA8float(e) {
            let n = 0;
            return n += e[0] / 256, n += e[1] / 65536, n += e[2] / 16777216, e[3] < 127 && (n = -n), n / 128
          }
        }
        const Yo = o.$ / 128;

        function fc(h, e) {
          const n = h.granularity !== void 0 ? Math.max(h.granularity, 1) : 1,
            s = n + (h.generateBorders ? 2 : 0),
            u = n + (h.extendToNorthPole || h.generateBorders ? 1 : 0) + (h.extendToSouthPole || h.generateBorders ? 1 : 0),
            d = s + 1,
            m = u + 1,
            y = h.generateBorders ? -1 : 0,
            b = h.generateBorders || h.extendToNorthPole ? -1 : 0,
            P = n + (h.generateBorders ? 1 : 0),
            M = n + (h.generateBorders || h.extendToSouthPole ? 1 : 0),
            L = d * m,
            z = s * u * 6,
            B = d * m > 65536;
          if (B && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const U = B || e === "32bit",
            Q = new Int16Array(2 * L);
          let J = 0;
          for (let de = b; de <= M; de++)
            for (let ue = y; ue <= P; ue++) {
              let ge = ue / n * o.$;
              ue === -1 && (ge = -Yo), ue === n + 1 && (ge = o.$ + Yo);
              let we = de / n * o.$;
              de === -1 && (we = h.extendToNorthPole ? o.bh : -Yo), de === n + 1 && (we = h.extendToSouthPole ? o.bi : o.$ + Yo), Q[J++] = ge, Q[J++] = we
            }
          const re = U ? new Uint32Array(z) : new Uint16Array(z);
          let se = 0;
          for (let de = 0; de < u; de++)
            for (let ue = 0; ue < s; ue++) {
              const ge = ue + 1 + de * d,
                we = ue + (de + 1) * d,
                he = ue + 1 + (de + 1) * d;
              re[se++] = ue + de * d, re[se++] = we, re[se++] = ge, re[se++] = ge, re[se++] = we, re[se++] = he
            }
          return {
            vertices: Q.buffer.slice(0),
            indices: re.buffer.slice(0),
            uses32bitIndices: U
          }
        }
        const Rs = new o.aK({
          fill: new o.bj(128, 2),
          line: new o.bj(512, 0),
          tile: new o.bj(128, 32),
          stencil: new o.bj(128, 1),
          circle: 3
        });
        class uo {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3
          }
          get name() {
            return "vertical-perspective"
          }
          get transitionState() {
            return 1
          }
          get useSubdivision() {
            return !0
          }
          get shaderVariantName() {
            return "globe"
          }
          get shaderDefine() {
            return "#define GLOBE"
          }
          get shaderPreludeCode() {
            return fi.projectionGlobe
          }
          get vertexShaderPreludeCode() {
            return fi.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return Rs
          }
          get useGlobeControls() {
            return !0
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy()
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new Ra(e));
            const n = o.U(this._errorQueryLatitudeDegrees),
              s = 2 * Math.atan(Math.exp(Math.PI - n * Math.PI * 2)) - .5 * Math.PI,
              u = this._errorMeasurement.updateErrorLoop(n, s),
              d = xe.now();
            u !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = u, this._errorMeasurementLastChangeTime = d);
            const m = Math.min(Math.max((d - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
            this._errorCorrectionUsable = o.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, o.bl(m))
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders?"b":""}${e.extendToNorthPole?"n":""}${e.extendToSouthPole?"s":""}`
          }
          getMeshFromTileID(e, n, s, u, d) {
            const m = (d === "stencil" ? Rs.stencil : Rs.tile).getGranularityForZoomLevel(n.z);
            return this._getMesh(e, {
              granularity: m,
              generateBorders: s,
              extendToNorthPole: n.y === 0 && u,
              extendToSouthPole: n.y === (1 << n.z) - 1 && u
            })
          }
          _getMesh(e, n) {
            const s = this._getMeshKey(n);
            if (s in this._tileMeshCache) return this._tileMeshCache[s];
            const u = (function(d, m) {
              const y = fc(m, "16bit"),
                b = o.aL.deserialize({
                  arrayBuffer: y.vertices,
                  length: y.vertices.byteLength / 2 / 2
                }),
                P = o.aN.deserialize({
                  arrayBuffer: y.indices,
                  length: y.indices.byteLength / 2 / 3
                });
              return new Bi(d.createVertexBuffer(b, hi.members), d.createIndexBuffer(P), o.aM.simpleSegment(0, 0, b.length, P.length))
            })(e, n);
            return this._tileMeshCache[s] = u, u
          }
          recalculate(e) {}
          hasTransition() {
            const e = xe.now();
            let n = !1;
            return n = n || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, n = n || this._errorMeasurement && this._errorMeasurement.awaitingQuery, n
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e
          }
        }
        const Jo = new o.r({
          type: new o.D(o.v.projection.type)
        });
        class Qo extends o.E {
          constructor(e) {
            super(), this._transitionable = new o.t(Jo), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.F(0)), this._mercatorProjection = new br, this._verticalPerspectiveProjection = new uo
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof o.bm) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition
            }
            return 1
          }
          get useGlobeRendering() {
            return this.transitionState > 0
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
          }
          get name() {
            return "globe"
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity
          }
          get useGlobeControls() {
            return this.transitionState > 0
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy()
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e)
          }
          getMeshFromTileID(e, n, s, u, d) {
            return this.currentProjection.getMeshFromTileID(e, n, s, u, d)
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator")
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
          }
        }

        function el(h) {
          const e = Bs(h.worldSize, h.center.lat);
          return 2 * Math.PI * e
        }

        function va(h, e, n, s, u) {
          const d = 1 / (1 << u),
            m = e / o.$ * d + s * d,
            y = o.bo((h / o.$ * d + n * d) * Math.PI * 2 + Math.PI, 2 * Math.PI),
            b = 2 * Math.atan(Math.exp(Math.PI - m * Math.PI * 2)) - .5 * Math.PI,
            P = Math.cos(b),
            M = new Float64Array(3);
          return M[0] = Math.sin(y) * P, M[1] = Math.sin(b), M[2] = Math.cos(y) * P, M
        }

        function yn(h) {
          return (function(e, n) {
            const s = Math.cos(n),
              u = new Float64Array(3);
            return u[0] = Math.sin(e) * s, u[1] = Math.sin(n), u[2] = Math.cos(e) * s, u
          })(h.lng * Math.PI / 180, h.lat * Math.PI / 180)
        }

        function Bs(h, e) {
          return h / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
        }

        function ho(h) {
          const e = Math.asin(h[1]) / Math.PI * 180,
            n = Math.sqrt(h[0] * h[0] + h[2] * h[2]);
          if (n > 1e-6) {
            const s = h[0] / n,
              u = Math.acos(h[2] / n),
              d = (s > 0 ? u : -u) / Math.PI * 180;
            return new o.S(o.aO(d, -180, 180), e)
          }
          return new o.S(0, e)
        }

        function ps(h) {
          return Math.cos(h * Math.PI / 180)
        }

        function Wi(h, e) {
          const n = ps(h),
            s = ps(e);
          return o.ak(s / n)
        }

        function fh(h, e) {
          const n = h.rotate(e.bearingInRadians),
            s = e.zoom + Wi(e.center.lat, 0),
            u = o.bk(1 / ps(e.center.lat), 1 / ps(Math.min(Math.abs(e.center.lat), 60)), o.bn(s, 7, 3, 0, 1)),
            d = 360 / el({
              worldSize: e.worldSize,
              center: {
                lat: e.center.lat
              }
            });
          return new o.S(e.center.lng - n.x * d * u, o.ah(e.center.lat + n.y * d, -o.ai, o.ai))
        }

        function po(h) {
          const e = .5 * h,
            n = Math.sin(e),
            s = Math.cos(e);
          return Math.log(n + s) - Math.log(s - n)
        }

        function mc(h, e, n, s) {
          const u = h.lat + n * s;
          if (Math.abs(n) > 1) {
            const d = (Math.sign(h.lat + n) !== Math.sign(h.lat) ? -Math.abs(h.lat) : Math.abs(h.lat)) * Math.PI / 180,
              m = Math.abs(h.lat + n) * Math.PI / 180,
              y = po(d + s * (m - d)),
              b = po(d),
              P = po(m);
            return new o.S(h.lng + e * ((y - b) / (P - b)), u)
          }
          return new o.S(h.lng + e * s, u)
        }
        class Gd {
          constructor(e) {
            this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._boundingVolumeFactory = e
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1
          }
          getTileBoundingVolume(e, n, s, u) {
            const d = `${e.z}_${e.x}_${e.y}_${u!=null&&u.terrain?"t":""}`,
              m = this._cache.get(d);
            if (m) return m;
            const y = this._cachePrevious.get(d);
            if (y) return this._cache.set(d, y), y;
            const b = this._boundingVolumeFactory(e, n, s, u);
            return this._cache.set(d, b), this._hadAnyChanges = !0, b
          }
        }
        class Fs {
          constructor(e, n, s, u) {
            this.min = s, this.max = u, this.points = e, this.planes = n
          }
          static fromAabb(e, n) {
            const s = [];
            for (let u = 0; u < 8; u++) s.push([1 & ~u ? e[0] : n[0], (u >> 1 & 1) == 1 ? n[1] : e[1], (u >> 2 & 1) == 1 ? n[2] : e[2]]);
            return new Fs(s, [
              [-1, 0, 0, n[0]],
              [1, 0, 0, -e[0]],
              [0, -1, 0, n[1]],
              [0, 1, 0, -e[1]],
              [0, 0, -1, n[2]],
              [0, 0, 1, -e[2]]
            ], e, n)
          }
          static fromCenterSizeAngles(e, n, s) {
            const u = o.br([], s[0], s[1], s[2]),
              d = o.bs([], [n[0], 0, 0], u),
              m = o.bs([], [0, n[1], 0], u),
              y = o.bs([], [0, 0, n[2]], u),
              b = [...e],
              P = [...e];
            for (let L = 0; L < 8; L++)
              for (let z = 0; z < 3; z++) {
                const B = e[z] + d[z] * (1 & ~L ? -1 : 1) + m[z] * ((L >> 1 & 1) == 1 ? 1 : -1) + y[z] * ((L >> 2 & 1) == 1 ? 1 : -1);
                b[z] = Math.min(b[z], B), P[z] = Math.max(P[z], B)
              }
            const M = [];
            for (let L = 0; L < 8; L++) {
              const z = [...e];
              o.aS(z, z, o.aR([], d, 1 & ~L ? -1 : 1)), o.aS(z, z, o.aR([], m, (L >> 1 & 1) == 1 ? 1 : -1)), o.aS(z, z, o.aR([], y, (L >> 2 & 1) == 1 ? 1 : -1)), M.push(z)
            }
            return new Fs(M, [
              [...d, -o.aX(d, M[0])],
              [...m, -o.aX(m, M[0])],
              [...y, -o.aX(y, M[0])],
              [-d[0], -d[1], -d[2], -o.aX(d, M[7])],
              [-m[0], -m[1], -m[2], -o.aX(m, M[7])],
              [-y[0], -y[1], -y[2], -o.aX(y, M[7])]
            ], b, P)
          }
          intersectsFrustum(e) {
            let n = !0;
            const s = this.points.length,
              u = this.planes.length,
              d = e.planes.length,
              m = e.points.length;
            for (let y = 0; y < d; y++) {
              const b = e.planes[y];
              let P = 0;
              for (let M = 0; M < s; M++) {
                const L = this.points[M];
                b[0] * L[0] + b[1] * L[1] + b[2] * L[2] + b[3] >= 0 && P++
              }
              if (P === 0) return 0;
              P < s && (n = !1)
            }
            if (n) return 2;
            for (let y = 0; y < u; y++) {
              const b = this.planes[y];
              let P = 0;
              for (let M = 0; M < m; M++) {
                const L = e.points[M];
                b[0] * L[0] + b[1] * L[1] + b[2] * L[2] + b[3] >= 0 && P++
              }
              if (P === 0) return 0
            }
            return 1
          }
          intersectsPlane(e) {
            const n = this.points.length;
            let s = 0;
            for (let u = 0; u < n; u++) {
              const d = this.points[u];
              e[0] * d[0] + e[1] * d[1] + e[2] * d[2] + e[3] >= 0 && s++
            }
            return s === n ? 2 : s === 0 ? 0 : 1
          }
        }

        function Mn(h, e, n) {
          const s = h - e;
          return s < 0 ? -s : Math.max(0, s - n)
        }

        function fo(h, e, n, s, u) {
          const d = h - n;
          let m;
          return m = d < 0 ? Math.min(-d, 1 + d - u) : d > 1 ? Math.min(Math.max(d - u, 0), 1 - d) : 0, Math.max(m, Mn(e, s, u))
        }
        class Ba {
          constructor() {
            this._boundingVolumeCache = new Gd(this._computeTileBoundingVolume)
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers()
          }
          distanceToTile2d(e, n, s, u) {
            const d = 1 << s.z,
              m = 1 / d,
              y = s.x / d,
              b = s.y / d;
            let P = 2;
            return P = Math.min(P, fo(e, n, y, b, m)), P = Math.min(P, fo(e, n, y + .5, -b - m, m)), P = Math.min(P, fo(e, n, y + .5, 2 - b - m, m)), P
          }
          getWrap(e, n, s) {
            const u = 1 << n.z,
              d = 1 / u,
              m = n.x / u,
              y = Mn(e.x, m, d),
              b = Mn(e.x, m - 1, d),
              P = Mn(e.x, m + 1, d),
              M = Math.min(y, b, P);
            return M === P ? 1 : M === b ? -1 : 0
          }
          allowVariableZoom(e, n) {
            return kt(e, n) > 4
          }
          allowWorldCopies() {
            return !1
          }
          getTileBoundingVolume(e, n, s, u) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, n, s, u)
          }
          _computeTileBoundingVolume(e, n, s, u) {
            var d, m;
            let y = 0,
              b = 0;
            if (u != null && u.terrain) {
              const P = new o.Z(e.z, n, e.z, e.x, e.y),
                M = u.terrain.getMinMaxElevation(P);
              y = (d = M.minElevation) !== null && d !== void 0 ? d : Math.min(0, s), b = (m = M.maxElevation) !== null && m !== void 0 ? m : Math.max(0, s)
            }
            if (y /= o.bu, b /= o.bu, y += 1, b += 1, e.z <= 0) return Fs.fromAabb([-b, -b, -b], [b, b, b]);
            if (e.z === 1) return Fs.fromAabb([e.x === 0 ? -b : 0, e.y === 0 ? 0 : -b, -b], [e.x === 0 ? 0 : b, e.y === 0 ? b : 0, b]);
            {
              const P = [va(0, 0, e.x, e.y, e.z), va(o.$, 0, e.x, e.y, e.z), va(o.$, o.$, e.x, e.y, e.z), va(0, o.$, e.x, e.y, e.z)],
                M = [];
              for (const qe of P) M.push(o.aR([], qe, b));
              if (b !== y)
                for (const qe of P) M.push(o.aR([], qe, y));
              e.y === 0 && M.push([0, 1, 0]), e.y === (1 << e.z) - 1 && M.push([0, -1, 0]);
              const L = [1, 1, 1],
                z = [-1, -1, -1];
              for (const qe of M)
                for (let Ge = 0; Ge < 3; Ge++) L[Ge] = Math.min(L[Ge], qe[Ge]), z[Ge] = Math.max(z[Ge], qe[Ge]);
              const B = va(o.$ / 2, o.$ / 2, e.x, e.y, e.z),
                U = o.aW([], [0, 1, 0], B);
              o.aV(U, U);
              const Q = o.aW([], B, U);
              o.aV(Q, Q);
              const J = o.aW([], P[2], P[1]);
              o.aV(J, J);
              const re = o.aW([], P[0], P[3]);
              o.aV(re, re), M.push(o.aR([], B, b)), e.y >= (1 << e.z) / 2 && M.push(o.aR([], va(o.$ / 2, 0, e.x, e.y, e.z), b)), e.y < (1 << e.z) / 2 && M.push(o.aR([], va(o.$ / 2, o.$, e.x, e.y, e.z), b));
              const se = mo(B, M),
                de = mo(Q, M),
                ue = [-B[0], -B[1], -B[2], se.max],
                ge = [B[0], B[1], B[2], -se.min],
                we = [-Q[0], -Q[1], -Q[2], de.max],
                he = [Q[0], Q[1], Q[2], -de.min],
                ze = [...J, 0],
                He = [...re, 0],
                Ne = [];
              return e.y === 0 ? Ne.push(o.bt(He, ze, ue), o.bt(He, ze, ge)) : Ne.push(o.bt(we, ze, ue), o.bt(we, ze, ge), o.bt(we, He, ue), o.bt(we, He, ge)), e.y === (1 << e.z) - 1 ? Ne.push(o.bt(He, ze, ue), o.bt(He, ze, ge)) : Ne.push(o.bt(he, ze, ue), o.bt(he, ze, ge), o.bt(he, He, ue), o.bt(he, He, ge)), new Fs(Ne, [ue, ge, we, he, ze, He], L, z)
            }
          }
        }

        function mo(h, e) {
          let n = 1 / 0,
            s = -1 / 0;
          for (const u of e) {
            const d = o.aX(h, u);
            n = Math.min(n, d), s = Math.max(s, d)
          }
          return {
            min: n,
            max: s
          }
        }
        class _o {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, n, s) {
            return this._helper.interpolatePadding(e, n, s)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, n) {
            this._helper.resize(e, n)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          overrideNearFarZ(e, n) {
            this._helper.overrideNearFarZ(e, n)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e) {}
          constructor() {
            this._cachedClippingPlane = o.bv(), this._projectionMatrix = o.b9(), this._globeViewProjMatrix32f = o.b8(), this._globeViewProjMatrixNoCorrection = o.b9(), this._globeViewProjMatrixNoCorrectionInverted = o.b9(), this._globeProjMatrixInverted = o.b9(), this._cameraPosition = o.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new Ji({
              calcMatrices: () => {
                this._calcMatrices()
              },
              getConstrained: (e, n) => this.getConstrained(e, n)
            }), this._coveringTilesDetailsProvider = new Ba
          }
          clone() {
            const e = new _o;
            return e.apply(this), e
          }
          apply(e, n) {
            this._globeLatitudeErrorCorrectionRadians = n || 0, this._helper.apply(e)
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted
          }
          get cameraPosition() {
            const e = o.bp();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          getProjectionData(e) {
            const {
              overscaledTileID: n,
              applyGlobeMatrix: s
            } = e, u = this._helper.getMercatorTileCoordinates(n);
            return {
              mainMatrix: this._globeViewProjMatrix32f,
              tileMercatorCoords: u,
              clippingPlane: this._cachedClippingPlane,
              projectionTransition: s ? 1 : 0,
              fallbackMatrix: this._globeViewProjMatrix32f
            }
          }
          _computeClippingPlane(e) {
            const n = this.pitchInRadians,
              s = this.cameraToCenterDistance / e,
              u = Math.sin(n) * s,
              d = Math.cos(n) * s + 1,
              m = 1 / Math.sqrt(u * u + d * d) * 1;
            let y = -u,
              b = d;
            const P = Math.sqrt(y * y + b * b);
            y /= P, b /= P;
            const M = [0, y, b];
            o.bw(M, M, [0, 0, 0], -this.bearingInRadians), o.bx(M, M, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), o.by(M, M, [0, 0, 0], this.center.lng * Math.PI / 180);
            const L = 1 / o.aZ(M);
            return o.aR(M, M, L), [...M, -m * L]
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(yn(e))
          }
          transformLightDirection(e) {
            const n = this._helper._center.lng * Math.PI / 180,
              s = this._helper._center.lat * Math.PI / 180,
              u = Math.cos(s),
              d = [Math.sin(n) * u, Math.sin(s), Math.cos(n) * u],
              m = [d[2], 0, -d[0]],
              y = [0, 0, 0];
            o.aW(y, m, d), o.aV(m, m), o.aV(y, y);
            const b = [0, 0, 0];
            return o.aV(b, [m[0] * e[0] + y[0] * e[1] + d[0] * e[2], m[1] * e[0] + y[1] * e[1] + d[1] * e[2], m[2] * e[0] + y[2] * e[1] + d[2] * e[2]]), b
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getPitchedTextCorrection(e, n, s) {
            const u = (function(y, b, P) {
                const M = 1 / (1 << P.z);
                return new o.a1(y / o.$ * M + P.x * M, b / o.$ * M + P.y * M)
              })(e, n, s.canonical),
              d = (m = u.y, [o.bo(u.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - m * Math.PI * 2)) - .5 * Math.PI]);
            var m;
            return this.getCircleRadiusCorrection() / Math.cos(d[1])
          }
          projectTileCoordinates(e, n, s, u) {
            const d = s.canonical,
              m = va(e, n, d.x, d.y, d.z),
              y = 1 + (u ? u(e, n) : 0) / o.bu,
              b = [m[0] * y, m[1] * y, m[2] * y, 1];
            o.aw(b, b, this._globeViewProjMatrixNoCorrection);
            const P = this._cachedClippingPlane,
              M = P[0] * m[0] + P[1] * m[1] + P[2] * m[2] + P[3] < 0;
            return {
              point: new o.P(b[0] / b[3], b[1] / b[3]),
              signedDistanceFromCamera: b[3],
              isOccluded: M
            }
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = Bs(this.worldSize, this.center.lat),
              n = o.ba(),
              s = o.ba();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), o.b4(n, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const u = this.centerOffset;
            n[8] = 2 * -u.x / this._helper._width, n[9] = 2 * u.y / this._helper._height, this._projectionMatrix = o.b5(n), this._globeProjMatrixInverted = o.ba(), o.aq(this._globeProjMatrixInverted, n), o.M(n, n, [0, 0, -this.cameraToCenterDistance]), o.b6(n, n, this.rollInRadians), o.b7(n, n, -this.pitchInRadians), o.b6(n, n, this.bearingInRadians), o.M(n, n, [0, 0, -e]);
            const d = o.bp();
            d[0] = e, d[1] = e, d[2] = e, o.b7(s, n, this.center.lat * Math.PI / 180), o.bz(s, s, -this.center.lng * Math.PI / 180), o.N(s, s, d), this._globeViewProjMatrixNoCorrection = s, o.b7(n, n, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), o.bz(n, n, -this.center.lng * Math.PI / 180), o.N(n, n, d), this._globeViewProjMatrix32f = new Float32Array(n), this._globeViewProjMatrixNoCorrectionInverted = o.ba(), o.aq(this._globeViewProjMatrixNoCorrectionInverted, s);
            const m = o.bp();
            this._cameraPosition = o.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / e, o.bw(this._cameraPosition, this._cameraPosition, m, -this.rollInRadians), o.bx(this._cameraPosition, this._cameraPosition, m, this.pitchInRadians), o.bw(this._cameraPosition, this._cameraPosition, m, -this.bearingInRadians), o.aS(this._cameraPosition, this._cameraPosition, [0, 0, 1]), o.bx(this._cameraPosition, this._cameraPosition, m, -this.center.lat * Math.PI / 180), o.by(this._cameraPosition, this._cameraPosition, m, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const y = o.b5(this._globeViewProjMatrixNoCorrectionInverted);
            o.N(y, y, [1, 1, -1]), this._cachedFrustum = Ci.fromInvProjectionMatrix(y, 1, 0, this._cachedClippingPlane, !0)
          }
          calculateFogMatrix(e) {
            o.w("calculateFogMatrix is not supported on globe projection.");
            const n = o.ba();
            return o.ag(n), n
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new o.b2(0, e)]
          }
          getCameraFrustum() {
            return this._cachedFrustum
          }
          getClippingPlane() {
            return this._cachedClippingPlane
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            e && o.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0)
          }
          maxPitchScaleFactor() {
            return 1
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, n) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const s = yn(e);
            o.aR(s, s, 1 + n / o.bu);
            const u = o.bv();
            return o.aw(u, [s[0], s[1], s[2], 1], this._globeViewProjMatrixNoCorrection), u[2] / u[3]
          }
          populateCache(e) {}
          getBounds() {
            const e = .5 * this.width,
              n = .5 * this.height,
              s = [new o.P(0, 0), new o.P(e, 0), new o.P(this.width, 0), new o.P(this.width, n), new o.P(this.width, this.height), new o.P(e, this.height), new o.P(0, this.height), new o.P(0, n)],
              u = [];
            for (const L of s) u.push(this.unprojectScreenPoint(L));
            let d = 0,
              m = 0,
              y = 0,
              b = 0;
            const P = this.center;
            for (const L of u) {
              const z = o.bA(P.lng, L.lng),
                B = o.bA(P.lat, L.lat);
              z < m && (m = z), z > d && (d = z), B < b && (b = B), B > y && (y = B)
            }
            const M = [P.lng + m, P.lat + b, P.lng + d, P.lat + y];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (M[3] = 90, M[0] = -180, M[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (M[1] = -90, M[0] = -180, M[2] = 180), new ht(M)
          }
          getConstrained(e, n) {
            const s = o.ah(e.lat, -o.ai, o.ai),
              u = o.ah(+n, this.minZoom + Wi(0, s), this.maxZoom);
            return {
              center: new o.S(e.lng, s),
              zoom: u
            }
          }
          calculateCenterFromCameraLngLatAlt(e, n, s, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, n, s, u)
          }
          setLocationAtPoint(e, n) {
            const s = yn(this.unprojectScreenPoint(n)),
              u = yn(e),
              d = o.bp();
            o.bB(d);
            const m = o.bp();
            o.by(m, s, d, -this.center.lng * Math.PI / 180), o.bx(m, m, d, this.center.lat * Math.PI / 180);
            const y = u[0] * u[0] + u[2] * u[2],
              b = m[0] * m[0];
            if (y < b) return;
            const P = Math.sqrt(y - b),
              M = -P,
              L = o.bC(u[0], u[2], m[0], P),
              z = o.bC(u[0], u[2], m[0], M),
              B = o.bp();
            o.by(B, u, d, -L);
            const U = o.bC(B[1], B[2], m[1], m[2]),
              Q = o.bp();
            o.by(Q, u, d, -z);
            const J = o.bC(Q[1], Q[2], m[1], m[2]),
              re = .5 * Math.PI,
              se = U >= -re && U <= re,
              de = J >= -re && J <= re;
            let ue, ge;
            if (se && de) {
              const He = this.center.lng * Math.PI / 180,
                Ne = this.center.lat * Math.PI / 180;
              o.bD(L, He) + o.bD(U, Ne) < o.bD(z, He) + o.bD(J, Ne) ? (ue = L, ge = U) : (ue = z, ge = J)
            } else if (se) ue = L, ge = U;
            else {
              if (!de) return;
              ue = z, ge = J
            }
            const we = ue / Math.PI * 180,
              he = ge / Math.PI * 180,
              ze = this.center.lat;
            this.setCenter(new o.S(we, o.ah(he, -90, 90))), this.setZoom(this.zoom + Wi(ze, this.center.lat))
          }
          locationToScreenPoint(e, n) {
            const s = yn(e);
            if (n) {
              const u = n.getElevationForLngLatZoom(e, this._helper._tileZoom);
              o.aR(s, s, 1 + u / o.bu)
            }
            return this._projectSurfacePointToScreen(s)
          }
          _projectSurfacePointToScreen(e) {
            const n = o.bv();
            return o.aw(n, [...e, 1], this._globeViewProjMatrixNoCorrection), n[0] /= n[3], n[1] /= n[3], new o.P((.5 * n[0] + .5) * this.width, (.5 * -n[1] + .5) * this.height)
          }
          screenPointToMercatorCoordinate(e, n) {
            if (n) {
              const s = n.pointCoordinate(e);
              if (s) return s
            }
            return o.a1.fromLngLat(this.unprojectScreenPoint(e))
          }
          screenPointToLocation(e, n) {
            var s;
            return (s = this.screenPointToMercatorCoordinate(e, n)) === null || s === void 0 ? void 0 : s.toLngLat()
          }
          isPointOnMapSurface(e, n) {
            const s = this._cameraPosition,
              u = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(s, u)
          }
          getRayDirectionFromPixel(e) {
            const n = o.bv();
            n[0] = e.x / this.width * 2 - 1, n[1] = -1 * (e.y / this.height * 2 - 1), n[2] = 1, n[3] = 1, o.aw(n, n, this._globeViewProjMatrixNoCorrectionInverted), n[0] /= n[3], n[1] /= n[3], n[2] /= n[3];
            const s = o.bp();
            s[0] = n[0] - this._cameraPosition[0], s[1] = n[1] - this._cameraPosition[1], s[2] = n[2] - this._cameraPosition[2];
            const u = o.bp();
            return o.aV(u, s), u
          }
          isSurfacePointVisible(e) {
            const n = this._cachedClippingPlane;
            return n[0] * e[0] + n[1] * e[1] + n[2] * e[2] + n[3] >= 0
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const n = o.bv();
            return o.aw(n, [...e, 1], this._globeViewProjMatrixNoCorrection), n[0] /= n[3], n[1] /= n[3], n[2] /= n[3], n[0] > -1 && n[0] < 1 && n[1] > -1 && n[1] < 1 && n[2] > -1 && n[2] < 1
          }
          rayPlanetIntersection(e, n) {
            const s = o.aX(e, n),
              u = o.bp(),
              d = o.bp();
            o.aR(d, n, s), o.aU(u, e, d);
            const m = 1 - o.aX(u, u);
            if (m < 0) return null;
            const y = o.aX(e, e) - 1,
              b = -s + (s < 0 ? 1 : -1) * Math.sqrt(m),
              P = y / b,
              M = b;
            return {
              tMin: Math.min(P, M),
              tMax: Math.max(P, M)
            }
          }
          unprojectScreenPoint(e) {
            const n = this._cameraPosition,
              s = this.getRayDirectionFromPixel(e),
              u = this.rayPlanetIntersection(n, s);
            if (u) {
              const M = o.bp();
              o.aS(M, n, [s[0] * u.tMin, s[1] * u.tMin, s[2] * u.tMin]);
              const L = o.bp();
              return o.aV(L, M), ho(L)
            }
            const d = this._cachedClippingPlane,
              m = d[0] * s[0] + d[1] * s[1] + d[2] * s[2],
              y = -o.b1(d, n) / m,
              b = o.bp();
            if (y > 0) o.aS(b, n, [s[0] * y, s[1] * y, s[2] * y]);
            else {
              const M = o.bp();
              o.aS(M, n, [2 * s[0], 2 * s[1], 2 * s[2]]);
              const L = o.b1(this._cachedClippingPlane, M);
              o.aU(b, M, [this._cachedClippingPlane[0] * L, this._cachedClippingPlane[1] * L, this._cachedClippingPlane[2] * L])
            }
            const P = (function(M) {
              const L = o.bp();
              return L[0] = M[0] * -M[3], L[1] = M[1] * -M[3], L[2] = M[2] * -M[3], {
                center: L,
                radius: Math.sqrt(1 - M[3] * M[3])
              }
            })(d);
            return ho((function(M, L, z) {
              const B = o.bp();
              o.aU(B, z, M);
              const U = o.bp();
              return o.bq(U, M, B, L / o.a$(B)), U
            })(P.center, P.radius, b))
          }
          getMatrixForModel(e, n) {
            const s = o.S.convert(e),
              u = 1 / o.bu,
              d = o.b9();
            return o.bz(d, d, s.lng / 180 * Math.PI), o.b7(d, d, -s.lat / 180 * Math.PI), o.M(d, d, [0, 0, 1 + n / o.bu]), o.b7(d, d, .5 * Math.PI), o.N(d, d, [u, u, u]), d
          }
          getProjectionDataForCustomLayer(e = !0) {
            const n = this.getProjectionData({
              overscaledTileID: new o.Z(0, 0, 0, 0, 0),
              applyGlobeMatrix: e
            });
            return n.tileMercatorCoords = [0, 0, 1, 1], n
          }
          getFastPathSimpleProjectionMatrix(e) {}
        }
        class go {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, n, s) {
            return this._helper.interpolatePadding(e, n, s)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, n, s = !0) {
            this._helper.resize(e, n, s)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          overrideNearFarZ(e, n) {
            this._helper.overrideNearFarZ(e, n)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          get isGlobeRendering() {
            return this._globeness > 0
          }
          setTransitionState(e, n) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = n, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new Ji({
              calcMatrices: () => {
                this._calcMatrices()
              },
              getConstrained: (e, n) => this.getConstrained(e, n)
            }), this._globeness = 1, this._mercatorTransform = new ci, this._verticalPerspectiveTransform = new _o
          }
          clone() {
            const e = new go;
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition
          }
          getProjectionData(e) {
            const n = this._mercatorTransform.getProjectionData(e),
              s = this._verticalPerspectiveTransform.getProjectionData(e);
            return {
              mainMatrix: this.isGlobeRendering ? s.mainMatrix : n.mainMatrix,
              clippingPlane: s.clippingPlane,
              tileMercatorCoords: s.tileMercatorCoords,
              projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
              fallbackMatrix: n.fallbackMatrix
            }
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e)
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e)
          }
          getPixelScale() {
            return o.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
          }
          getCircleRadiusCorrection() {
            return o.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
          }
          getPitchedTextCorrection(e, n, s) {
            const u = this._mercatorTransform.getPitchedTextCorrection(e, n, s),
              d = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, n, s);
            return o.bk(u, d, this._globeness)
          }
          projectTileCoordinates(e, n, s, u) {
            return this.currentTransform.projectTileCoordinates(e, n, s, u)
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ)
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e)
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e)
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum()
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane()
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider()
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor()
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, n) {
            return this.currentTransform.lngLatToCameraDepth(e, n)
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e)
          }
          getBounds() {
            return this.currentTransform.getBounds()
          }
          getConstrained(e, n) {
            return this.currentTransform.getConstrained(e, n)
          }
          calculateCenterFromCameraLngLatAlt(e, n, s, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, n, s, u)
          }
          setLocationAtPoint(e, n) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, n), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, n), this.apply(this._verticalPerspectiveTransform)
          }
          locationToScreenPoint(e, n) {
            return this.currentTransform.locationToScreenPoint(e, n)
          }
          screenPointToMercatorCoordinate(e, n) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, n)
          }
          screenPointToLocation(e, n) {
            return this.currentTransform.screenPointToLocation(e, n)
          }
          isPointOnMapSurface(e, n) {
            return this.currentTransform.isPointOnMapSurface(e, n)
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
          }
          getMatrixForModel(e, n) {
            return this.currentTransform.getMatrixForModel(e, n)
          }
          getProjectionDataForCustomLayer(e = !0) {
            const n = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return n;
            const s = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return s.fallbackMatrix = n.mainMatrix, s
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
          }
        }
        class Rn {
          get useGlobeControls() {
            return !0
          }
          handlePanInertia(e, n) {
            const s = fh(e, n);
            return Math.abs(s.lng - n.center.lng) > 180 && (s.lng = n.center.lng + 179.5 * Math.sign(s.lng - n.center.lng)), {
              easingCenter: s,
              easingOffset: new o.P(0, 0)
            }
          }
          handleMapControlsRollPitchBearingZoom(e, n) {
            const s = e.around,
              u = n.screenPointToLocation(s);
            e.bearingDelta && n.setBearing(n.bearing + e.bearingDelta), e.pitchDelta && n.setPitch(n.pitch + e.pitchDelta), e.rollDelta && n.setRoll(n.roll + e.rollDelta);
            const d = n.zoom;
            e.zoomDelta && n.setZoom(n.zoom + e.zoomDelta);
            const m = n.zoom - d;
            if (m === 0) return;
            const y = o.bA(n.center.lng, u.lng),
              b = y / (Math.abs(y / 180) + 1),
              P = o.bA(n.center.lat, u.lat),
              M = n.getRayDirectionFromPixel(s),
              L = n.cameraPosition,
              z = -1 * o.aX(L, M),
              B = o.bp();
            o.aS(B, L, [M[0] * z, M[1] * z, M[2] * z]);
            const U = o.aZ(B) - 1,
              Q = Math.exp(.5 * -Math.max(U - .3, 0)),
              J = Bs(n.worldSize, n.center.lat) / Math.min(n.width, n.height),
              re = o.bn(J, .9, .5, 1, .25),
              se = (1 - o.af(-m)) * Math.min(Q, re),
              de = n.center.lat,
              ue = n.zoom,
              ge = new o.S(n.center.lng + b * se, o.ah(n.center.lat + P * se, -o.ai, o.ai));
            n.setLocationAtPoint(u, s);
            const we = n.center,
              he = o.bn(Math.abs(y), 45, 85, 0, 1),
              ze = o.bn(J, .75, .35, 0, 1),
              He = Math.pow(Math.max(he, ze), .25),
              Ne = o.bA(we.lng, ge.lng),
              qe = o.bA(we.lat, ge.lat);
            n.setCenter(new o.S(we.lng + Ne * He, we.lat + qe * He).wrap()), n.setZoom(ue + Wi(de, n.center.lat))
          }
          handleMapControlsPan(e, n, s) {
            if (!e.panDelta) return;
            const u = n.center.lat,
              d = n.zoom;
            n.setCenter(fh(e.panDelta, n).wrap()), n.setZoom(d + Wi(u, n.center.lat))
          }
          cameraForBoxAndBearing(e, n, s, u, d) {
            const m = Nn(e, n, s, u, d),
              y = n.left / d.width * 2 - 1,
              b = (d.width - n.right) / d.width * 2 - 1,
              P = n.top / d.height * -2 + 1,
              M = (d.height - n.bottom) / d.height * -2 + 1,
              L = o.bA(s.getWest(), s.getEast()) < 0,
              z = L ? s.getEast() : s.getWest(),
              B = L ? s.getWest() : s.getEast(),
              U = Math.max(s.getNorth(), s.getSouth()),
              Q = Math.min(s.getNorth(), s.getSouth()),
              J = z + .5 * o.bA(z, B),
              re = U + .5 * o.bA(U, Q),
              se = d.clone();
            se.setCenter(m.center), se.setBearing(m.bearing), se.setPitch(0), se.setRoll(0), se.setZoom(m.zoom);
            const de = se.modelViewProjectionMatrix,
              ue = [yn(s.getNorthWest()), yn(s.getNorthEast()), yn(s.getSouthWest()), yn(s.getSouthEast()), yn(new o.S(B, re)), yn(new o.S(z, re)), yn(new o.S(J, U)), yn(new o.S(J, Q))],
              ge = yn(m.center);
            let we = Number.POSITIVE_INFINITY;
            for (const he of ue) y < 0 && (we = Rn.getLesserNonNegativeNonNull(we, Rn.solveVectorScale(he, ge, de, "x", y))), b > 0 && (we = Rn.getLesserNonNegativeNonNull(we, Rn.solveVectorScale(he, ge, de, "x", b))), P > 0 && (we = Rn.getLesserNonNegativeNonNull(we, Rn.solveVectorScale(he, ge, de, "y", P))), M < 0 && (we = Rn.getLesserNonNegativeNonNull(we, Rn.solveVectorScale(he, ge, de, "y", M)));
            if (Number.isFinite(we) && we !== 0) return m.zoom = se.zoom + o.ak(we), m;
            Ko()
          }
          handleJumpToCenterZoom(e, n) {
            const s = e.center.lat,
              u = e.getConstrained(n.center ? o.S.convert(n.center) : e.center, e.zoom).center;
            e.setCenter(u.wrap());
            const d = n.zoom !== void 0 ? +n.zoom : e.zoom + Wi(s, u.lat);
            e.zoom !== d && e.setZoom(d)
          }
          handleEaseTo(e, n) {
            const s = e.zoom,
              u = e.center,
              d = e.padding,
              m = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              y = {
                roll: n.roll === void 0 ? e.roll : n.roll,
                pitch: n.pitch === void 0 ? e.pitch : n.pitch,
                bearing: n.bearing === void 0 ? e.bearing : n.bearing
              },
              b = n.zoom !== void 0,
              P = !e.isPaddingEqual(n.padding);
            let M = !1;
            const L = n.center ? o.S.convert(n.center) : u,
              z = e.getConstrained(L, s).center;
            Ni(e, z);
            const B = e.clone();
            B.setCenter(z), B.setZoom(b ? +n.zoom : s + Wi(u.lat, L.lat)), B.setBearing(n.bearing);
            const U = new o.P(o.ah(e.centerPoint.x + n.offsetAsPoint.x, 0, e.width), o.ah(e.centerPoint.y + n.offsetAsPoint.y, 0, e.height));
            B.setLocationAtPoint(z, U);
            const Q = (n.offset && n.offsetAsPoint.mag()) > 0 ? B.center : z,
              J = b ? +n.zoom : s + Wi(u.lat, Q.lat),
              re = s + Wi(u.lat, 0),
              se = J + Wi(Q.lat, 0),
              de = o.bA(u.lng, Q.lng),
              ue = o.bA(u.lat, Q.lat),
              ge = o.af(se - re);
            return M = J !== s, {
              easeFunc: we => {
                if (o.be(m, y) || un({
                    startEulerAngles: m,
                    endEulerAngles: y,
                    tr: e,
                    k: we,
                    useSlerp: m.roll != y.roll
                  }), P && e.interpolatePadding(d, n.padding, we), n.around) o.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(n.around, n.aroundPoint);
                else {
                  const he = se > re ? Math.min(2, ge) : Math.max(.5, ge),
                    ze = Math.pow(he, 1 - we),
                    He = mc(u, de, ue, we * ze);
                  e.setCenter(He.wrap())
                }
                if (M) {
                  const he = o.C.number(re, se, we) + Wi(0, e.center.lat);
                  e.setZoom(he)
                }
              },
              isZooming: M,
              elevationCenter: Q
            }
          }
          handleFlyTo(e, n) {
            const s = n.zoom !== void 0,
              u = e.center,
              d = e.zoom,
              m = e.padding,
              y = !e.isPaddingEqual(n.padding),
              b = e.getConstrained(o.S.convert(n.center || n.locationAtOffset), d).center,
              P = s ? +n.zoom : e.zoom + Wi(e.center.lat, b.lat),
              M = e.clone();
            M.setCenter(b), M.setZoom(P), M.setBearing(n.bearing);
            const L = new o.P(o.ah(e.centerPoint.x + n.offsetAsPoint.x, 0, e.width), o.ah(e.centerPoint.y + n.offsetAsPoint.y, 0, e.height));
            M.setLocationAtPoint(b, L);
            const z = M.center;
            Ni(e, z);
            const B = (function(ue, ge, we) {
                const he = yn(ge),
                  ze = yn(we),
                  He = o.aX(he, ze),
                  Ne = Math.acos(He),
                  qe = el(ue);
                return Ne / (2 * Math.PI) * qe
              })(e, u, z),
              U = d + Wi(u.lat, 0),
              Q = P + Wi(z.lat, 0),
              J = o.af(Q - U);
            let re;
            if (typeof n.minZoom == "number") {
              const ue = +n.minZoom + Wi(z.lat, 0),
                ge = Math.min(ue, U, Q) + Wi(0, z.lat),
                we = e.getConstrained(z, ge).zoom + Wi(z.lat, 0);
              re = o.af(we - U)
            }
            const se = o.bA(u.lng, z.lng),
              de = o.bA(u.lat, z.lat);
            return {
              easeFunc: (ue, ge, we, he) => {
                const ze = mc(u, se, de, we);
                y && e.interpolatePadding(m, n.padding, ue);
                const He = ue === 1 ? z : ze;
                e.setCenter(He.wrap());
                const Ne = U + o.ak(ge);
                e.setZoom(ue === 1 ? P : Ne + Wi(0, He.lat))
              },
              scaleOfZoom: J,
              targetCenter: z,
              scaleOfMinZoom: re,
              pixelPathLength: B
            }
          }
          static solveVectorScale(e, n, s, u, d) {
            const m = u === "x" ? [s[0], s[4], s[8], s[12]] : [s[1], s[5], s[9], s[13]],
              y = [s[3], s[7], s[11], s[15]],
              b = e[0] * m[0] + e[1] * m[1] + e[2] * m[2],
              P = e[0] * y[0] + e[1] * y[1] + e[2] * y[2],
              M = n[0] * m[0] + n[1] * m[1] + n[2] * m[2],
              L = n[0] * y[0] + n[1] * y[1] + n[2] * y[2];
            return M + d * P === b + d * L || y[3] * (b - M) + m[3] * (L - P) + b * L == M * P ? null : (M + m[3] - d * L - d * y[3]) / (M - b - d * L + d * P)
          }
          static getLesserNonNegativeNonNull(e, n) {
            return n !== null && n >= 0 && n < e ? n : e
          }
        }
        class mh {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new hn, this._verticalPerspectiveCameraHelper = new Rn
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
          }
          handlePanInertia(e, n) {
            return this.currentHelper.handlePanInertia(e, n)
          }
          handleMapControlsRollPitchBearingZoom(e, n) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, n)
          }
          handleMapControlsPan(e, n, s) {
            this.currentHelper.handleMapControlsPan(e, n, s)
          }
          cameraForBoxAndBearing(e, n, s, u, d) {
            return this.currentHelper.cameraForBoxAndBearing(e, n, s, u, d)
          }
          handleJumpToCenterZoom(e, n) {
            this.currentHelper.handleJumpToCenterZoom(e, n)
          }
          handleEaseTo(e, n) {
            return this.currentHelper.handleEaseTo(e, n)
          }
          handleFlyTo(e, n) {
            return this.currentHelper.handleFlyTo(e, n)
          }
        }
        const tl = (h, e) => o.y(h, e && e.filter((n => n.identifier !== "source.canvas"))),
          Hd = o.bE();
        class _c extends o.E {
          constructor(e, n = {}) {
            super(), this._rtlPluginLoaded = () => {
              for (const s in this.sourceCaches) {
                const u = this.sourceCaches[s].getSource().type;
                u !== "vector" && u !== "geojson" || this.sourceCaches[s].reload()
              }
            }, this.map = e, this.dispatcher = new Nt(zt(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((s, u) => this.getGlyphs(s, u))), this.dispatcher.registerMessageHandler("GI", ((s, u) => this.getImages(s, u))), this.imageManager = new tt, this.imageManager.setEventedParent(this), this.glyphManager = new Qe(e._requestManager, n.localIdeographFontFamily), this.lineAtlas = new ie(256, 512), this.crossTileSymbolIndex = new gi, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new o.bF, this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", o.bG()), Mr().on(ur, this._rtlPluginLoaded), this.on("data", (s => {
              if (s.dataType !== "source" || s.sourceDataType !== "metadata") return;
              const u = this.sourceCaches[s.sourceId];
              if (!u) return;
              const d = u.getSource();
              if (d && d.vectorLayerIds)
                for (const m in this._layers) {
                  const y = this._layers[m];
                  y.source === d.id && this._validateLayer(y)
                }
            }))
          }
          setGlobalStateProperty(e, n) {
            var s, u, d;
            this._checkLoaded();
            const m = n === null ? (d = (u = (s = this.stylesheet.state) === null || s === void 0 ? void 0 : s[e]) === null || u === void 0 ? void 0 : u.default) !== null && d !== void 0 ? d : null : n;
            if (o.bH(m, this._globalState[e])) return this;
            this._globalState[e] = m;
            const y = this._findGlobalStateAffectedSources([e]);
            for (const b in this.sourceCaches) y.has(b) && (this._reloadSource(b), this._changed = !0)
          }
          getGlobalState() {
            return this._globalState
          }
          setGlobalState(e) {
            this._checkLoaded();
            const n = [];
            for (const u in e) !o.bH(this._globalState[u], e[u].default) && (n.push(u), this._globalState[u] = e[u].default);
            const s = this._findGlobalStateAffectedSources(n);
            for (const u in this.sourceCaches) s.has(u) && (this._reloadSource(u), this._changed = !0)
          }
          _findGlobalStateAffectedSources(e) {
            if (e.length === 0) return new Set;
            const n = new Set;
            for (const s in this._layers) {
              const u = this._layers[s],
                d = u.getLayoutAffectingGlobalStateRefs();
              for (const m of e) d.has(m) && n.add(u.source)
            }
            return n
          }
          loadURL(e, n = {}, s) {
            this.fire(new o.l("dataloading", {
              dataType: "style"
            })), n.validate = typeof n.validate != "boolean" || n.validate;
            const u = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController;
            const d = this._loadStyleRequest;
            o.j(u, this._loadStyleRequest).then((m => {
              this._loadStyleRequest = null, this._load(m.data, n, s)
            })).catch((m => {
              this._loadStyleRequest = null, m && !d.signal.aborted && this.fire(new o.k(m))
            }))
          }
          loadJSON(e, n = {}, s) {
            this.fire(new o.l("dataloading", {
              dataType: "style"
            })), this._frameRequest = new AbortController, xe.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, n.validate = n.validate !== !1, this._load(e, n, s)
            })).catch((() => {}))
          }
          loadEmpty() {
            this.fire(new o.l("dataloading", {
              dataType: "style"
            })), this._load(Hd, {
              validate: !1
            })
          }
          _load(e, n, s) {
            var u, d, m;
            const y = n.transformStyle ? n.transformStyle(s, e) : e;
            if (!n.validate || !tl(this, o.z(y))) {
              this._loaded = !0, this.stylesheet = y;
              for (const b in y.sources) this.addSource(b, y.sources[b], {
                validate: !1
              });
              y.sprite ? this._loadSprite(y.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(y.glyphs), this._createLayers(), this.light = new ee(this.stylesheet.light), this._setProjectionInternal(((u = this.stylesheet.projection) === null || u === void 0 ? void 0 : u.type) || "mercator"), this.sky = new fe(this.stylesheet.sky), this.map.setTerrain((d = this.stylesheet.terrain) !== null && d !== void 0 ? d : null), this.setGlobalState((m = this.stylesheet.state) !== null && m !== void 0 ? m : null), this.fire(new o.l("data", {
                dataType: "style"
              })), this.fire(new o.l("style.load"))
            }
          }
          _createLayers() {
            const e = o.bI(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", e), this._order = e.map((n => n.id)), this._layers = {}, this._serializedLayers = null;
            for (const n of e) {
              const s = o.bJ(n);
              s.setEventedParent(this, {
                layer: {
                  id: n.id
                }
              }), this._layers[n.id] = s
            }
          }
          _loadSprite(e, n = !1, s = void 0) {
            let u;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController, (function(d, m, y, b) {
              return o._(this, void 0, void 0, (function*() {
                const P = ut(d),
                  M = y > 1 ? "@2x" : "",
                  L = {},
                  z = {};
                for (const {
                    id: B,
                    url: U
                  }
                  of P) {
                  const Q = m.transformRequest(Ke(U, M, ".json"), "SpriteJSON");
                  L[B] = o.j(Q, b);
                  const J = m.transformRequest(Ke(U, M, ".png"), "SpriteImage");
                  z[B] = Fe.getImage(J, b)
                }
                return yield Promise.all([...Object.values(L), ...Object.values(z)]), (function(B, U) {
                  return o._(this, void 0, void 0, (function*() {
                    const Q = {};
                    for (const J in B) {
                      Q[J] = {};
                      const re = xe.getImageCanvasContext((yield U[J]).data),
                        se = (yield B[J]).data;
                      for (const de in se) {
                        const {
                          width: ue,
                          height: ge,
                          x: we,
                          y: he,
                          sdf: ze,
                          pixelRatio: He,
                          stretchX: Ne,
                          stretchY: qe,
                          content: Ge,
                          textFitWidth: Dt,
                          textFitHeight: Ft
                        } = se[de];
                        Q[J][de] = {
                          data: null,
                          pixelRatio: He,
                          sdf: ze,
                          stretchX: Ne,
                          stretchY: qe,
                          content: Ge,
                          textFitWidth: Dt,
                          textFitHeight: Ft,
                          spriteData: {
                            width: ue,
                            height: ge,
                            x: we,
                            y: he,
                            context: re
                          }
                        }
                      }
                    }
                    return Q
                  }))
                })(L, z)
              }))
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((d => {
              if (this._spriteRequest = null, d)
                for (const m in d) {
                  this._spritesImagesIds[m] = [];
                  const y = this._spritesImagesIds[m] ? this._spritesImagesIds[m].filter((b => !(b in d))) : [];
                  for (const b of y) this.imageManager.removeImage(b), this._changedImages[b] = !0;
                  for (const b in d[m]) {
                    const P = m === "default" ? b : `${m}:${b}`;
                    this._spritesImagesIds[m].push(P), P in this.imageManager.images ? this.imageManager.updateImage(P, d[m][b], !1) : this.imageManager.addImage(P, d[m][b]), n && (this._changedImages[P] = !0)
                  }
                }
            })).catch((d => {
              this._spriteRequest = null, u = d, this.fire(new o.k(u))
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), n && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", {
                dataType: "style"
              })), s && s(u)
            }))
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", {
              dataType: "style"
            }))
          }
          _validateLayer(e) {
            const n = this.sourceCaches[e.source];
            if (!n) return;
            const s = e.sourceLayer;
            if (!s) return;
            const u = n.getSource();
            (u.type === "geojson" || u.vectorLayerIds && u.vectorLayerIds.indexOf(s) === -1) && this.fire(new o.k(new Error(`Source layer "${s}" does not exist on source "${u.id}" as specified by style layer "${e.id}".`)))
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.sourceCaches)
              if (!this.sourceCaches[e].loaded()) return !1;
            return !!this.imageManager.isLoaded()
          }
          _serializeByIds(e, n = !1) {
            const s = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(n ? o.bK(s) : s);
            const u = [];
            for (const d of e)
              if (s[d]) {
                const m = n ? o.bK(s[d]) : s[d];
                u.push(m)
              } return u
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const n = Object.keys(this._layers);
            for (const s of n) {
              const u = this._layers[s];
              u.type !== "custom" && (e[s] = u.serialize())
            }
            return e
          }
          hasTransitions() {
            var e, n, s;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((n = this.sky) === null || n === void 0) && n.hasTransition() || !((s = this.projection) === null || s === void 0) && s.hasTransition()) return !0;
            for (const u in this.sourceCaches)
              if (this.sourceCaches[u].hasTransition()) return !0;
            for (const u in this._layers)
              if (this._layers[u].hasTransition()) return !0;
            return !1
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.")
          }
          update(e) {
            if (!this._loaded) return;
            const n = this._changed;
            if (n) {
              const u = Object.keys(this._updatedLayers),
                d = Object.keys(this._removedLayers);
              (u.length || d.length) && this._updateWorkerLayers(u, d);
              for (const m in this._updatedSources) {
                const y = this._updatedSources[m];
                if (y === "reload") this._reloadSource(m);
                else {
                  if (y !== "clear") throw new Error(`Invalid action ${y}`);
                  this._clearSource(m)
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const m in this._updatedPaintProps) this._layers[m].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates()
            }
            const s = {};
            for (const u in this.sourceCaches) {
              const d = this.sourceCaches[u];
              s[u] = d.used, d.used = !1
            }
            for (const u of this._order) {
              const d = this._layers[u];
              d.recalculate(e, this._availableImages), !d.isHidden(e.zoom) && d.source && (this.sourceCaches[d.source].used = !0)
            }
            for (const u in s) {
              const d = this.sourceCaches[u];
              !!s[u] != !!d.used && d.fire(new o.l("data", {
                sourceDataType: "visibility",
                dataType: "source",
                sourceId: u
              }))
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, n && this.fire(new o.l("data", {
              dataType: "style"
            }))
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const n in this.sourceCaches) this.sourceCaches[n].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {}
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1
            }
          }
          _updateWorkerLayers(e, n) {
            this.dispatcher.broadcast("UL", {
              layers: this._serializeByIds(e, !1),
              removedIds: n
            })
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1
          }
          setState(e, n = {}) {
            var s;
            this._checkLoaded();
            const u = this.serialize();
            if (e = n.transformStyle ? n.transformStyle(u, e) : e, ((s = n.validate) === null || s === void 0 || s) && tl(this, o.z(e))) return !1;
            (e = o.bK(e)).layers = o.bI(e.layers);
            const d = o.bL(u, e),
              m = this._getOperationsToPerform(d);
            if (m.unimplemented.length > 0) throw new Error(`Unimplemented: ${m.unimplemented.join(", ")}.`);
            if (m.operations.length === 0) return !1;
            for (const y of m.operations) y();
            return this.stylesheet = e, this._serializedLayers = null, !0
          }
          _getOperationsToPerform(e) {
            const n = [],
              s = [];
            for (const u of e) switch (u.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                n.push((() => this.addLayer.apply(this, u.args)));
                break;
              case "removeLayer":
                n.push((() => this.removeLayer.apply(this, u.args)));
                break;
              case "setPaintProperty":
                n.push((() => this.setPaintProperty.apply(this, u.args)));
                break;
              case "setLayoutProperty":
                n.push((() => this.setLayoutProperty.apply(this, u.args)));
                break;
              case "setFilter":
                n.push((() => this.setFilter.apply(this, u.args)));
                break;
              case "addSource":
                n.push((() => this.addSource.apply(this, u.args)));
                break;
              case "removeSource":
                n.push((() => this.removeSource.apply(this, u.args)));
                break;
              case "setLayerZoomRange":
                n.push((() => this.setLayerZoomRange.apply(this, u.args)));
                break;
              case "setLight":
                n.push((() => this.setLight.apply(this, u.args)));
                break;
              case "setGeoJSONSourceData":
                n.push((() => this.setGeoJSONSourceData.apply(this, u.args)));
                break;
              case "setGlyphs":
                n.push((() => this.setGlyphs.apply(this, u.args)));
                break;
              case "setSprite":
                n.push((() => this.setSprite.apply(this, u.args)));
                break;
              case "setTerrain":
                n.push((() => this.map.setTerrain.apply(this, u.args)));
                break;
              case "setSky":
                n.push((() => this.setSky.apply(this, u.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, u.args);
                break;
              case "setGlobalState":
                n.push((() => this.setGlobalState.apply(this, u.args)));
                break;
              case "setTransition":
                n.push((() => {}));
                break;
              default:
                s.push(u.command)
            }
            return {
              operations: n,
              unimplemented: s
            }
          }
          addImage(e, n) {
            if (this.getImage(e)) return this.fire(new o.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, n), this._afterImageUpdated(e)
          }
          updateImage(e, n) {
            this.imageManager.updateImage(e, n)
          }
          getImage(e) {
            return this.imageManager.getImage(e)
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new o.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e)
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", {
              dataType: "style"
            }))
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages()
          }
          addSource(e, n, s = {}) {
            if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!n.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(n).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(n.type) >= 0 && this._validate(o.z.source, `sources.${e}`, n, null, s)) return;
            this.map && this.map._collectResourceTiming && (n.collectResourceTiming = !0);
            const u = this.sourceCaches[e] = new Ht(e, n, this.dispatcher);
            u.style = this, u.setEventedParent(this, (() => ({
              isSourceLoaded: u.loaded(),
              source: u.serialize(),
              sourceId: e
            }))), u.onAdd(this.map), this._changed = !0
          }
          removeSource(e) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
            for (const s in this._layers)
              if (this._layers[s].source === e) return this.fire(new o.k(new Error(`Source "${e}" cannot be removed while layer "${s}" is using it.`)));
            const n = this.sourceCaches[e];
            delete this.sourceCaches[e], delete this._updatedSources[e], n.fire(new o.l("data", {
              sourceDataType: "metadata",
              dataType: "source",
              sourceId: e
            })), n.setEventedParent(null), n.onRemove(this.map), this._changed = !0
          }
          setGeoJSONSourceData(e, n) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const s = this.sourceCaches[e].getSource();
            if (s.type !== "geojson") throw new Error(`geojsonSource.type is ${s.type}, which is !== 'geojson`);
            s.setData(n), this._changed = !0
          }
          getSource(e) {
            return this.sourceCaches[e] && this.sourceCaches[e].getSource()
          }
          addLayer(e, n, s = {}) {
            this._checkLoaded();
            const u = e.id;
            if (this.getLayer(u)) return void this.fire(new o.k(new Error(`Layer "${u}" already exists on this map.`)));
            let d;
            if (e.type === "custom") {
              if (tl(this, o.bM(e))) return;
              d = o.bJ(e)
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(u, e.source), e = o.bK(e), e = o.e(e, {
                  source: u
                })), this._validate(o.z.layer, `layers.${u}`, e, {
                  arrayIndex: -1
                }, s)) return;
              d = o.bJ(e), this._validateLayer(d), d.setEventedParent(this, {
                layer: {
                  id: u
                }
              })
            }
            const m = n ? this._order.indexOf(n) : this._order.length;
            if (n && m === -1) this.fire(new o.k(new Error(`Cannot add layer "${u}" before non-existing layer "${n}".`)));
            else {
              if (this._order.splice(m, 0, u), this._layerOrderChanged = !0, this._layers[u] = d, this._removedLayers[u] && d.source && d.type !== "custom") {
                const y = this._removedLayers[u];
                delete this._removedLayers[u], y.type !== d.type ? this._updatedSources[d.source] = "clear" : (this._updatedSources[d.source] = "reload", this.sourceCaches[d.source].pause())
              }
              this._updateLayer(d), d.onAdd && d.onAdd(this.map)
            }
          }
          moveLayer(e, n) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new o.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === n) return;
            const s = this._order.indexOf(e);
            this._order.splice(s, 1);
            const u = n ? this._order.indexOf(n) : this._order.length;
            n && u === -1 ? this.fire(new o.k(new Error(`Cannot move layer "${e}" before non-existing layer "${n}".`))) : (this._order.splice(u, 0, e), this._layerOrderChanged = !0)
          }
          removeLayer(e) {
            this._checkLoaded();
            const n = this._layers[e];
            if (!n) return void this.fire(new o.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            n.setEventedParent(null);
            const s = this._order.indexOf(e);
            this._order.splice(s, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = n, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], n.onRemove && n.onRemove(this.map)
          }
          getLayer(e) {
            return this._layers[e]
          }
          getLayersOrder() {
            return [...this._order]
          }
          hasLayer(e) {
            return e in this._layers
          }
          setLayerZoomRange(e, n, s) {
            this._checkLoaded();
            const u = this.getLayer(e);
            u ? u.minzoom === n && u.maxzoom === s || (n != null && (u.minzoom = n), s != null && (u.maxzoom = s), this._updateLayer(u)) : this.fire(new o.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
          }
          setFilter(e, n, s = {}) {
            this._checkLoaded();
            const u = this.getLayer(e);
            if (u) {
              if (!o.bH(u.filter, n)) return n == null ? (u.setFilter(void 0), void this._updateLayer(u)) : void(this._validate(o.z.filter, `layers.${u.id}.filter`, n, null, s) || (u.setFilter(o.bK(n)), this._updateLayer(u)))
            } else this.fire(new o.k(new Error(`Cannot filter non-existing layer "${e}".`)))
          }
          getFilter(e) {
            return o.bK(this.getLayer(e).filter)
          }
          setLayoutProperty(e, n, s, u = {}) {
            this._checkLoaded();
            const d = this.getLayer(e);
            d ? o.bH(d.getLayoutProperty(n), s) || (d.setLayoutProperty(n, s, u), this._updateLayer(d)) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getLayoutProperty(e, n) {
            const s = this.getLayer(e);
            if (s) return s.getLayoutProperty(n);
            this.fire(new o.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
          }
          setPaintProperty(e, n, s, u = {}) {
            this._checkLoaded();
            const d = this.getLayer(e);
            d ? o.bH(d.getPaintProperty(n), s) || (d.setPaintProperty(n, s, u) && this._updateLayer(d), this._changed = !0, this._updatedPaintProps[e] = !0, this._serializedLayers = null) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getPaintProperty(e, n) {
            return this.getLayer(e).getPaintProperty(n)
          }
          setFeatureState(e, n) {
            this._checkLoaded();
            const s = e.source,
              u = e.sourceLayer,
              d = this.sourceCaches[s];
            if (d === void 0) return void this.fire(new o.k(new Error(`The source '${s}' does not exist in the map's style.`)));
            const m = d.getSource().type;
            m === "geojson" && u ? this.fire(new o.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : m !== "vector" || u ? (e.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))), d.setFeatureState(u, e.id, n)) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          removeFeatureState(e, n) {
            this._checkLoaded();
            const s = e.source,
              u = this.sourceCaches[s];
            if (u === void 0) return void this.fire(new o.k(new Error(`The source '${s}' does not exist in the map's style.`)));
            const d = u.getSource().type,
              m = d === "vector" ? e.sourceLayer : void 0;
            d !== "vector" || m ? n && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new o.k(new Error("A feature id is required to remove its specific state property."))) : u.removeFeatureState(m, e.id, n) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          getFeatureState(e) {
            this._checkLoaded();
            const n = e.source,
              s = e.sourceLayer,
              u = this.sourceCaches[n];
            if (u !== void 0) return u.getSource().type !== "vector" || s ? (e.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))), u.getFeatureState(s, e.id)) : void this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new o.k(new Error(`The source '${n}' does not exist in the map's style.`)))
          }
          getTransition() {
            return o.e({
              duration: 300,
              delay: 0
            }, this.stylesheet && this.stylesheet.transition)
          }
          serialize() {
            if (!this._loaded) return;
            const e = o.bN(this.sourceCaches, (d => d.serialize())),
              n = this._serializeByIds(this._order, !0),
              s = this.map.getTerrain() || void 0,
              u = this.stylesheet;
            return o.bO({
              version: u.version,
              name: u.name,
              metadata: u.metadata,
              light: u.light,
              sky: u.sky,
              center: u.center,
              zoom: u.zoom,
              bearing: u.bearing,
              pitch: u.pitch,
              sprite: u.sprite,
              glyphs: u.glyphs,
              transition: u.transition,
              projection: u.projection,
              sources: e,
              layers: n,
              terrain: s
            }, (d => d !== void 0))
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0
          }
          _flattenAndSortRenderedFeatures(e) {
            const n = m => this._layers[m].type === "fill-extrusion",
              s = {},
              u = [];
            for (let m = this._order.length - 1; m >= 0; m--) {
              const y = this._order[m];
              if (n(y)) {
                s[y] = m;
                for (const b of e) {
                  const P = b[y];
                  if (P)
                    for (const M of P) u.push(M)
                }
              }
            }
            u.sort(((m, y) => y.intersectionZ - m.intersectionZ));
            const d = [];
            for (let m = this._order.length - 1; m >= 0; m--) {
              const y = this._order[m];
              if (n(y))
                for (let b = u.length - 1; b >= 0; b--) {
                  const P = u[b].feature;
                  if (s[P.layer.id] < m) break;
                  d.push(P), u.pop()
                } else
                  for (const b of e) {
                    const P = b[y];
                    if (P)
                      for (const M of P) d.push(M.feature)
                  }
            }
            return d
          }
          queryRenderedFeatures(e, n, s) {
            n && n.filter && this._validate(o.z.filter, "queryRenderedFeatures.filter", n.filter, null, n);
            const u = {};
            if (n && n.layers) {
              if (!(Array.isArray(n.layers) || n.layers instanceof Set)) return this.fire(new o.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const P of n.layers) {
                const M = this._layers[P];
                if (!M) return this.fire(new o.k(new Error(`The layer '${P}' does not exist in the map's style and cannot be queried for features.`))), [];
                u[M.source] = !0
              }
            }
            const d = [];
            n.availableImages = this._availableImages;
            const m = this._serializedAllLayers(),
              y = n.layers instanceof Set ? n.layers : Array.isArray(n.layers) ? new Set(n.layers) : null,
              b = Object.assign(Object.assign({}, n), {
                layers: y
              });
            for (const P in this.sourceCaches) n.layers && !u[P] || d.push(Ct(this.sourceCaches[P], this._layers, m, e, b, s, this.map.terrain ? (M, L, z) => this.map.terrain.getElevation(M, L, z) : void 0));
            return this.placement && d.push((function(P, M, L, z, B, U, Q) {
              const J = {},
                re = U.queryRenderedSymbols(z),
                se = [];
              for (const de of Object.keys(re).map(Number)) se.push(Q[de]);
              se.sort(yt);
              for (const de of se) {
                const ue = de.featureIndex.lookupSymbolFeatures(re[de.bucketInstanceId], M, de.bucketIndex, de.sourceLayerIndex, B.filter, B.layers, B.availableImages, P);
                for (const ge in ue) {
                  const we = J[ge] = J[ge] || [],
                    he = ue[ge];
                  he.sort(((ze, He) => {
                    const Ne = de.featureSortOrder;
                    if (Ne) {
                      const qe = Ne.indexOf(ze.featureIndex);
                      return Ne.indexOf(He.featureIndex) - qe
                    }
                    return He.featureIndex - ze.featureIndex
                  }));
                  for (const ze of he) we.push(ze)
                }
              }
              return (function(de, ue, ge) {
                for (const we in de)
                  for (const he of de[we]) Mt(he, ge[ue[we].source]);
                return de
              })(J, P, L)
            })(this._layers, m, this.sourceCaches, e, b, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(d)
          }
          querySourceFeatures(e, n) {
            n && n.filter && this._validate(o.z.filter, "querySourceFeatures.filter", n.filter, null, n);
            const s = this.sourceCaches[e];
            return s ? (function(u, d) {
              const m = u.getRenderableIds().map((P => u.getTileByID(P))),
                y = [],
                b = {};
              for (let P = 0; P < m.length; P++) {
                const M = m[P],
                  L = M.tileID.canonical.key;
                b[L] || (b[L] = !0, M.querySourceFeatures(y, d))
              }
              return y
            })(s, n) : []
          }
          getLight() {
            return this.light.getLight()
          }
          setLight(e, n = {}) {
            this._checkLoaded();
            const s = this.light.getLight();
            let u = !1;
            for (const m in e)
              if (!o.bH(e[m], s[m])) {
                u = !0;
                break
              } if (!u) return;
            const d = {
              now: xe.now(),
              transition: o.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.light.setLight(e, n), this.light.updateTransitions(d)
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type)
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
          }
          setSky(e, n = {}) {
            this._checkLoaded();
            const s = this.getSky();
            let u = !1;
            if (!e && !s) return;
            if (e && !s) u = !0;
            else if (!e && s) u = !0;
            else
              for (const m in e)
                if (!o.bH(e[m], s[m])) {
                  u = !0;
                  break
                } if (!u) return;
            const d = {
              now: xe.now(),
              transition: o.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.stylesheet.sky = e, this.sky.setSky(e, n), this.sky.updateTransitions(d)
          }
          _setProjectionInternal(e) {
            const n = (function(s) {
              if (Array.isArray(s)) {
                const u = new Qo({
                  type: s
                });
                return {
                  projection: u,
                  transform: new go,
                  cameraHelper: new mh(u)
                }
              }
              switch (s) {
                case "mercator":
                  return {
                    projection: new br, transform: new ci, cameraHelper: new hn
                  };
                case "globe": {
                  const u = new Qo({
                    type: ["interpolate", ["linear"],
                      ["zoom"], 11, "vertical-perspective", 12, "mercator"
                    ]
                  });
                  return {
                    projection: u,
                    transform: new go,
                    cameraHelper: new mh(u)
                  }
                }
                case "vertical-perspective":
                  return {
                    projection: new uo, transform: new _o, cameraHelper: new Rn
                  };
                default:
                  return o.w(`Unknown projection name: ${s}. Falling back to mercator projection.`), {
                    projection: new br,
                    transform: new ci,
                    cameraHelper: new hn
                  }
              }
            })(e);
            this.projection = n.projection, this.map.migrateProjection(n.transform, n.cameraHelper);
            for (const s in this.sourceCaches) this.sourceCaches[s].reload()
          }
          _validate(e, n, s, u, d = {}) {
            return (!d || d.validate !== !1) && tl(this, e.call(o.z, o.e({
              key: n,
              style: this.serialize(),
              value: s,
              styleSpec: o.v
            }, u)))
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Mr().off(ur, this._rtlPluginLoaded);
            for (const n in this._layers) this._layers[n].setEventedParent(null);
            for (const n in this.sourceCaches) {
              const s = this.sourceCaches[n];
              s.setEventedParent(null), s.onRemove(this.map)
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e)
          }
          _clearSource(e) {
            this.sourceCaches[e].clearTiles()
          }
          _reloadSource(e) {
            this.sourceCaches[e].resume(), this.sourceCaches[e].reload()
          }
          _updateSources(e) {
            for (const n in this.sourceCaches) this.sourceCaches[n].update(e, this.map.terrain)
          }
          _generateCollisionBoxes() {
            for (const e in this.sourceCaches) this._reloadSource(e)
          }
          _updatePlacement(e, n, s, u, d = !1) {
            let m = !1,
              y = !1;
            const b = {};
            for (const P of this._order) {
              const M = this._layers[P];
              if (M.type !== "symbol") continue;
              if (!b[M.source]) {
                const z = this.sourceCaches[M.source];
                b[M.source] = z.getRenderableIds(!0).map((B => z.getTileByID(B))).sort(((B, U) => U.tileID.overscaledZ - B.tileID.overscaledZ || (B.tileID.isLessThan(U.tileID) ? -1 : 1)))
              }
              const L = this.crossTileSymbolIndex.addLayer(M, b[M.source], e.center.lng);
              m = m || L
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((d = d || this._layerOrderChanged || s === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(xe.now(), e.zoom)) && (this.pauseablePlacement = new vn(e, this.map.terrain, this._order, d, n, s, u, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, b), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(xe.now()), y = !0), m && this.pauseablePlacement.placement.setStale()), y || m)
              for (const P of this._order) {
                const M = this._layers[P];
                M.type === "symbol" && this.placement.updateLayerOpacities(M, b[M.source])
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(xe.now())
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles()
          }
          getImages(e, n) {
            return o._(this, void 0, void 0, (function*() {
              const s = yield this.imageManager.getImages(n.icons);
              this._updateTilesForChangedImages();
              const u = this.sourceCaches[n.source];
              return u && u.setDependencies(n.tileID.key, n.type, n.icons), s
            }))
          }
          getGlyphs(e, n) {
            return o._(this, void 0, void 0, (function*() {
              const s = yield this.glyphManager.getGlyphs(n.stacks), u = this.sourceCaches[n.source];
              return u && u.setDependencies(n.tileID.key, n.type, [""]), s
            }))
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null
          }
          setGlyphs(e, n = {}) {
            this._checkLoaded(), e && this._validate(o.z.glyphs, "glyphs", e, null, n) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e))
          }
          addSprite(e, n, s = {}, u) {
            this._checkLoaded();
            const d = [{
                id: e,
                url: n
              }],
              m = [...ut(this.stylesheet.sprite), ...d];
            this._validate(o.z.sprite, "sprite", m, null, s) || (this.stylesheet.sprite = m, this._loadSprite(d, !0, u))
          }
          removeSprite(e) {
            this._checkLoaded();
            const n = ut(this.stylesheet.sprite);
            if (n.find((s => s.id === e))) {
              if (this._spritesImagesIds[e])
                for (const s of this._spritesImagesIds[e]) this.imageManager.removeImage(s), this._changedImages[s] = !0;
              n.splice(n.findIndex((s => s.id === e)), 1), this.stylesheet.sprite = n.length > 0 ? n : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", {
                dataType: "style"
              }))
            } else this.fire(new o.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
          }
          getSprite() {
            return ut(this.stylesheet.sprite)
          }
          setSprite(e, n = {}, s) {
            this._checkLoaded(), e && this._validate(o.z.sprite, "sprite", e, null, n) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, s) : (this._unloadSprite(), s && s(null)))
          }
        }
        var Wd = o.aJ([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }, {
          name: "a_texture_pos",
          type: "Int16",
          components: 2
        }]);
        class Xd {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null
          }
          bind(e, n, s, u, d, m, y, b, P) {
            this.context = e;
            let M = this.boundPaintVertexBuffers.length !== u.length;
            for (let L = 0; !M && L < u.length; L++) this.boundPaintVertexBuffers[L] !== u[L] && (M = !0);
            !this.vao || this.boundProgram !== n || this.boundLayoutVertexBuffer !== s || M || this.boundIndexBuffer !== d || this.boundVertexOffset !== m || this.boundDynamicVertexBuffer !== y || this.boundDynamicVertexBuffer2 !== b || this.boundDynamicVertexBuffer3 !== P ? this.freshBind(n, s, u, d, m, y, b, P) : (e.bindVertexArray.set(this.vao), y && y.bind(), d && d.dynamicDraw && d.bind(), b && b.bind(), P && P.bind())
          }
          freshBind(e, n, s, u, d, m, y, b) {
            const P = e.numAttributes,
              M = this.context,
              L = M.gl;
            this.vao && this.destroy(), this.vao = M.createVertexArray(), M.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = n, this.boundPaintVertexBuffers = s, this.boundIndexBuffer = u, this.boundVertexOffset = d, this.boundDynamicVertexBuffer = m, this.boundDynamicVertexBuffer2 = y, this.boundDynamicVertexBuffer3 = b, n.enableAttributes(L, e);
            for (const z of s) z.enableAttributes(L, e);
            m && m.enableAttributes(L, e), y && y.enableAttributes(L, e), b && b.enableAttributes(L, e), n.bind(), n.setVertexAttribPointers(L, e, d);
            for (const z of s) z.bind(), z.setVertexAttribPointers(L, e, d);
            m && (m.bind(), m.setVertexAttribPointers(L, e, d)), u && u.bind(), y && (y.bind(), y.setVertexAttribPointers(L, e, d)), b && (b.bind(), b.setVertexAttribPointers(L, e, d)), M.currentNumAttributes = P
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null)
          }
        }
        const rl = (h, e, n, s, u) => ({
            u_texture: 0,
            u_ele_delta: h,
            u_fog_matrix: e,
            u_fog_color: n ? n.properties.get("fog-color") : o.bf.white,
            u_fog_ground_blend: n ? n.properties.get("fog-ground-blend") : 1,
            u_fog_ground_blend_opacity: u ? 0 : n ? n.calculateFogBlendOpacity(s) : 0,
            u_horizon_color: n ? n.properties.get("horizon-color") : o.bf.white,
            u_horizon_fog_blend: n ? n.properties.get("horizon-fog-blend") : 1,
            u_is_globe_mode: u ? 1 : 0
          }),
          gc = {
            mainMatrix: "u_projection_matrix",
            tileMercatorCoords: "u_projection_tile_mercator_coords",
            clippingPlane: "u_projection_clipping_plane",
            projectionTransition: "u_projection_transition",
            fallbackMatrix: "u_projection_fallback_matrix"
          };

        function fs(h) {
          const e = [];
          for (let n = 0; n < h.length; n++) {
            if (h[n] === null) continue;
            const s = h[n].split(" ");
            e.push(s.pop())
          }
          return e
        }
        class vc {
          constructor(e, n, s, u, d, m, y, b, P = []) {
            const M = e.gl;
            this.program = M.createProgram();
            const L = fs(n.staticAttributes),
              z = s ? s.getBinderAttributes() : [],
              B = L.concat(z),
              U = fi.prelude.staticUniforms ? fs(fi.prelude.staticUniforms) : [],
              Q = y.staticUniforms ? fs(y.staticUniforms) : [],
              J = n.staticUniforms ? fs(n.staticUniforms) : [],
              re = s ? s.getBinderUniforms() : [],
              se = U.concat(Q).concat(J).concat(re),
              de = [];
            for (const Ne of se) de.indexOf(Ne) < 0 && de.push(Ne);
            const ue = s ? s.defines() : [];
            Da(M) && ue.unshift("#version 300 es"), d && ue.push("#define OVERDRAW_INSPECTOR;"), m && ue.push("#define TERRAIN3D;"), b && ue.push(b), P && ue.push(...P);
            let ge = ue.concat(fi.prelude.fragmentSource, y.fragmentSource, n.fragmentSource).join(`
`),
              we = ue.concat(fi.prelude.vertexSource, y.vertexSource, n.vertexSource).join(`
`);
            Da(M) || (ge = (function(Ne) {
              return Ne.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
            })(ge), we = (function(Ne) {
              return Ne.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
            })(we));
            const he = M.createShader(M.FRAGMENT_SHADER);
            if (M.isContextLost()) return void(this.failedToCreate = !0);
            if (M.shaderSource(he, ge), M.compileShader(he), !M.getShaderParameter(he, M.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${M.getShaderInfoLog(he)}`);
            M.attachShader(this.program, he);
            const ze = M.createShader(M.VERTEX_SHADER);
            if (M.isContextLost()) return void(this.failedToCreate = !0);
            if (M.shaderSource(ze, we), M.compileShader(ze), !M.getShaderParameter(ze, M.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${M.getShaderInfoLog(ze)}`);
            M.attachShader(this.program, ze), this.attributes = {};
            const He = {};
            this.numAttributes = B.length;
            for (let Ne = 0; Ne < this.numAttributes; Ne++) B[Ne] && (M.bindAttribLocation(this.program, Ne, B[Ne]), this.attributes[B[Ne]] = Ne);
            if (M.linkProgram(this.program), !M.getProgramParameter(this.program, M.LINK_STATUS)) throw new Error(`Program failed to link: ${M.getProgramInfoLog(this.program)}`);
            M.deleteShader(ze), M.deleteShader(he);
            for (let Ne = 0; Ne < de.length; Ne++) {
              const qe = de[Ne];
              if (qe && !He[qe]) {
                const Ge = M.getUniformLocation(this.program, qe);
                Ge && (He[qe] = Ge)
              }
            }
            this.fixedUniforms = u(e, He), this.terrainUniforms = ((Ne, qe) => ({
              u_depth: new o.bP(Ne, qe.u_depth),
              u_terrain: new o.bP(Ne, qe.u_terrain),
              u_terrain_dim: new o.bg(Ne, qe.u_terrain_dim),
              u_terrain_matrix: new o.bR(Ne, qe.u_terrain_matrix),
              u_terrain_unpack: new o.bS(Ne, qe.u_terrain_unpack),
              u_terrain_exaggeration: new o.bg(Ne, qe.u_terrain_exaggeration)
            }))(e, He), this.projectionUniforms = ((Ne, qe) => ({
              u_projection_matrix: new o.bR(Ne, qe.u_projection_matrix),
              u_projection_tile_mercator_coords: new o.bS(Ne, qe.u_projection_tile_mercator_coords),
              u_projection_clipping_plane: new o.bS(Ne, qe.u_projection_clipping_plane),
              u_projection_transition: new o.bg(Ne, qe.u_projection_transition),
              u_projection_fallback_matrix: new o.bR(Ne, qe.u_projection_fallback_matrix)
            }))(e, He), this.binderUniforms = s ? s.getUniforms(e, He) : []
          }
          draw(e, n, s, u, d, m, y, b, P, M, L, z, B, U, Q, J, re, se, de) {
            const ue = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(s), e.setStencilMode(u), e.setColorMode(d), e.setCullFace(m), b) {
              e.activeTexture.set(ue.TEXTURE2), ue.bindTexture(ue.TEXTURE_2D, b.depthTexture), e.activeTexture.set(ue.TEXTURE3), ue.bindTexture(ue.TEXTURE_2D, b.texture);
              for (const we in this.terrainUniforms) this.terrainUniforms[we].set(b[we])
            }
            if (P)
              for (const we in P) this.projectionUniforms[gc[we]].set(P[we]);
            if (y)
              for (const we in this.fixedUniforms) this.fixedUniforms[we].set(y[we]);
            J && J.setUniforms(e, this.binderUniforms, U, {
              zoom: Q
            });
            let ge = 0;
            switch (n) {
              case ue.LINES:
                ge = 2;
                break;
              case ue.TRIANGLES:
                ge = 3;
                break;
              case ue.LINE_STRIP:
                ge = 1
            }
            for (const we of B.get()) {
              const he = we.vaos || (we.vaos = {});
              (he[M] || (he[M] = new Xd)).bind(e, this, L, J ? J.getPaintVertexBuffers() : [], z, we.vertexOffset, re, se, de), ue.drawElements(n, we.primitiveLength * ge, ue.UNSIGNED_SHORT, we.primitiveOffset * ge * 2)
            }
          }
        }

        function il(h, e, n) {
          const s = 1 / o.aC(n, 1, e.transform.tileZoom),
            u = Math.pow(2, n.tileID.overscaledZ),
            d = n.tileSize * Math.pow(2, e.transform.tileZoom) / u,
            m = d * (n.tileID.canonical.x + n.tileID.wrap * u),
            y = d * n.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: n.imageAtlasTexture.size,
            u_scale: [s, h.fromScale, h.toScale],
            u_fade: h.t,
            u_pixel_coord_upper: [m >> 16, y >> 16],
            u_pixel_coord_lower: [65535 & m, 65535 & y]
          }
        }
        const ya = (h, e, n, s) => {
            const u = h.style.light,
              d = u.properties.get("position"),
              m = [d.x, d.y, d.z],
              y = o.bV();
            u.properties.get("anchor") === "viewport" && o.bW(y, h.transform.bearingInRadians), o.bX(m, m, y);
            const b = h.transform.transformLightDirection(m),
              P = u.properties.get("color");
            return {
              u_lightpos: m,
              u_lightpos_globe: b,
              u_lightintensity: u.properties.get("intensity"),
              u_lightcolor: [P.r, P.g, P.b],
              u_vertical_gradient: +e,
              u_opacity: n,
              u_fill_translate: s
            }
          },
          Kd = (h, e, n, s, u, d, m) => o.e(ya(h, e, n, s), il(d, h, m), {
            u_height_factor: -Math.pow(2, u.overscaledZ) / m.tileSize / 8
          }),
          nl = (h, e, n, s) => o.e(il(e, h, n), {
            u_fill_translate: s
          }),
          vo = (h, e) => ({
            u_world: h,
            u_fill_translate: e
          }),
          yo = (h, e, n, s, u) => o.e(nl(h, e, n, u), {
            u_world: s
          }),
          Yd = (h, e, n, s, u) => {
            const d = h.transform;
            let m, y, b = 0;
            if (n.paint.get("circle-pitch-alignment") === "map") {
              const P = o.aC(e, 1, d.zoom);
              m = !0, y = [P, P], b = P / (o.$ * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * u
            } else m = !1, y = d.pixelsToGLUnits;
            return {
              u_camera_to_center_distance: d.cameraToCenterDistance,
              u_scale_with_map: +(n.paint.get("circle-pitch-scale") === "map"),
              u_pitch_with_map: +m,
              u_device_pixel_ratio: h.pixelRatio,
              u_extrude_scale: y,
              u_globe_extrude_scale: b,
              u_translate: s
            }
          },
          al = h => ({
            u_pixel_extrude_scale: [1 / h.width, 1 / h.height]
          }),
          Jd = h => ({
            u_viewport_size: [h.width, h.height]
          }),
          ms = (h, e = 1) => ({
            u_color: h,
            u_overlay: 0,
            u_overlay_scale: e
          }),
          _h = (h, e, n, s) => {
            const u = o.aC(h, 1, e) / (o.$ * Math.pow(2, h.tileID.overscaledZ)) * 2 * Math.PI * s;
            return {
              u_extrude_scale: o.aC(h, 1, e),
              u_intensity: n,
              u_globe_extrude_scale: u
            }
          },
          yc = (h, e, n, s) => {
            const u = o.L();
            o.bY(u, 0, h.width, h.height, 0, 0, 1);
            const d = h.context.gl;
            return {
              u_matrix: u,
              u_world: [d.drawingBufferWidth, d.drawingBufferHeight],
              u_image: n,
              u_color_ramp: s,
              u_opacity: e.paint.get("heatmap-opacity")
            }
          },
          Qd = (h, e, n) => {
            const s = n.paint.get("hillshade-accent-color");
            let u;
            switch (n.paint.get("hillshade-method")) {
              case "basic":
                u = 4;
                break;
              case "combined":
                u = 1;
                break;
              case "igor":
                u = 2;
                break;
              case "multidirectional":
                u = 3;
                break;
              default:
                u = 0
            }
            const d = n.getIlluminationProperties();
            for (let m = 0; m < d.directionRadians.length; m++) n.paint.get("hillshade-illumination-anchor") === "viewport" && (d.directionRadians[m] += h.transform.bearingInRadians);
            return {
              u_image: 0,
              u_latrange: xc(0, e.tileID),
              u_exaggeration: n.paint.get("hillshade-exaggeration"),
              u_altitudes: d.altitudeRadians,
              u_azimuths: d.directionRadians,
              u_accent: s,
              u_method: u,
              u_highlights: d.highlightColor,
              u_shadows: d.shadowColor
            }
          },
          gh = (h, e) => {
            const n = e.stride,
              s = o.L();
            return o.bY(s, 0, o.$, -o.$, 0, 0, 1), o.M(s, s, [0, -o.$, 0]), {
              u_matrix: s,
              u_image: 1,
              u_dimension: [n, n],
              u_zoom: h.overscaledZ,
              u_unpack: e.getUnpackVector()
            }
          };

        function xc(h, e) {
          const n = Math.pow(2, e.canonical.z),
            s = e.canonical.y;
          return [new o.a1(0, s / n).toLngLat().lat, new o.a1(0, (s + 1) / n).toLngLat().lat]
        }
        const vh = (h, e, n = 0) => ({
            u_image: 0,
            u_unpack: e.getUnpackVector(),
            u_dimension: [e.stride, e.stride],
            u_elevation_stops: 1,
            u_color_stops: 4,
            u_color_ramp_size: n,
            u_opacity: h.paint.get("color-relief-opacity")
          }),
          sl = (h, e, n, s) => {
            const u = h.transform;
            return {
              u_translation: wc(h, e, n),
              u_ratio: s / o.aC(e, 1, u.zoom),
              u_device_pixel_ratio: h.pixelRatio,
              u_units_to_pixels: [1 / u.pixelsToGLUnits[0], 1 / u.pixelsToGLUnits[1]]
            }
          },
          yh = (h, e, n, s, u) => o.e(sl(h, e, n, s), {
            u_image: 0,
            u_image_height: u
          }),
          xh = (h, e, n, s, u) => {
            const d = h.transform,
              m = bc(e, d);
            return {
              u_translation: wc(h, e, n),
              u_texsize: e.imageAtlasTexture.size,
              u_ratio: s / o.aC(e, 1, d.zoom),
              u_device_pixel_ratio: h.pixelRatio,
              u_image: 0,
              u_scale: [m, u.fromScale, u.toScale],
              u_fade: u.t,
              u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]]
            }
          },
          _s = (h, e, n, s, u, d) => {
            const m = h.lineAtlas,
              y = bc(e, h.transform),
              b = n.layout.get("line-cap") === "round",
              P = m.getDash(u.from, b),
              M = m.getDash(u.to, b),
              L = P.width * d.fromScale,
              z = M.width * d.toScale;
            return o.e(sl(h, e, n, s), {
              u_patternscale_a: [y / L, -P.height / 2],
              u_patternscale_b: [y / z, -M.height / 2],
              u_sdfgamma: m.width / (256 * Math.min(L, z) * h.pixelRatio) / 2,
              u_image: 0,
              u_tex_y_a: P.y,
              u_tex_y_b: M.y,
              u_mix: d.t
            })
          };

        function bc(h, e) {
          return 1 / o.aC(h, 1, e.tileZoom)
        }

        function wc(h, e, n) {
          return o.aD(h.transform, e, n.paint.get("line-translate"), n.paint.get("line-translate-anchor"))
        }
        const xo = (h, e, n, s, u) => {
          return {
            u_tl_parent: h,
            u_scale_parent: e,
            u_buffer_scale: 1,
            u_fade_t: n.mix,
            u_opacity: n.opacity * s.paint.get("raster-opacity"),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: s.paint.get("raster-brightness-min"),
            u_brightness_high: s.paint.get("raster-brightness-max"),
            u_saturation_factor: (m = s.paint.get("raster-saturation"), m > 0 ? 1 - 1 / (1.001 - m) : -m),
            u_contrast_factor: (d = s.paint.get("raster-contrast"), d > 0 ? 1 / (1 - d) : 1 + d),
            u_spin_weights: ep(s.paint.get("raster-hue-rotate")),
            u_coords_top: [u[0].x, u[0].y, u[1].x, u[1].y],
            u_coords_bottom: [u[3].x, u[3].y, u[2].x, u[2].y]
          };
          var d, m
        };

        function ep(h) {
          h *= Math.PI / 180;
          const e = Math.sin(h),
            n = Math.cos(h);
          return [(2 * n + 1) / 3, (-Math.sqrt(3) * e - n + 1) / 3, (Math.sqrt(3) * e - n + 1) / 3]
        }
        const bo = (h, e, n, s, u, d, m, y, b, P, M, L, z) => {
            const B = m.transform;
            return {
              u_is_size_zoom_constant: +(h === "constant" || h === "source"),
              u_is_size_feature_constant: +(h === "constant" || h === "camera"),
              u_size_t: e ? e.uSizeT : 0,
              u_size: e ? e.uSize : 0,
              u_camera_to_center_distance: B.cameraToCenterDistance,
              u_pitch: B.pitch / 360 * 2 * Math.PI,
              u_rotate_symbol: +n,
              u_aspect_ratio: B.width / B.height,
              u_fade_change: m.options.fadeDuration ? m.symbolFadeChange : 1,
              u_label_plane_matrix: y,
              u_coord_matrix: b,
              u_is_text: +M,
              u_pitch_with_map: +s,
              u_is_along_line: u,
              u_is_variable_anchor: d,
              u_texsize: L,
              u_texture: 0,
              u_translation: P,
              u_pitched_scale: z
            }
          },
          bh = (h, e, n, s, u, d, m, y, b, P, M, L, z, B) => {
            const U = m.transform;
            return o.e(bo(h, e, n, s, u, d, m, y, b, P, M, L, B), {
              u_gamma_scale: s ? Math.cos(U.pitch * Math.PI / 180) * U.cameraToCenterDistance : 1,
              u_device_pixel_ratio: m.pixelRatio,
              u_is_halo: 1
            })
          },
          tp = (h, e, n, s, u, d, m, y, b, P, M, L, z) => o.e(bh(h, e, n, s, u, d, m, y, b, P, !0, M, 0, z), {
            u_texsize_icon: L,
            u_texture_icon: 1
          }),
          wh = (h, e) => ({
            u_opacity: h,
            u_color: e
          }),
          Th = (h, e, n, s, u) => o.e((function(d, m, y, b) {
            const P = y.imageManager.getPattern(d.from.toString()),
              M = y.imageManager.getPattern(d.to.toString()),
              {
                width: L,
                height: z
              } = y.imageManager.getPixelSize(),
              B = Math.pow(2, b.tileID.overscaledZ),
              U = b.tileSize * Math.pow(2, y.transform.tileZoom) / B,
              Q = U * (b.tileID.canonical.x + b.tileID.wrap * B),
              J = U * b.tileID.canonical.y;
            return {
              u_image: 0,
              u_pattern_tl_a: P.tl,
              u_pattern_br_a: P.br,
              u_pattern_tl_b: M.tl,
              u_pattern_br_b: M.br,
              u_texsize: [L, z],
              u_mix: m.t,
              u_pattern_size_a: P.displaySize,
              u_pattern_size_b: M.displaySize,
              u_scale_a: m.fromScale,
              u_scale_b: m.toScale,
              u_tile_units_to_pixels: 1 / o.aC(b, 1, y.transform.tileZoom),
              u_pixel_coord_upper: [Q >> 16, J >> 16],
              u_pixel_coord_lower: [65535 & Q, 65535 & J]
            }
          })(n, u, e, s), {
            u_opacity: h
          }),
          Tc = (h, e) => {},
          Cc = {
            fillExtrusion: (h, e) => ({
              u_lightpos: new o.bT(h, e.u_lightpos),
              u_lightpos_globe: new o.bT(h, e.u_lightpos_globe),
              u_lightintensity: new o.bg(h, e.u_lightintensity),
              u_lightcolor: new o.bT(h, e.u_lightcolor),
              u_vertical_gradient: new o.bg(h, e.u_vertical_gradient),
              u_opacity: new o.bg(h, e.u_opacity),
              u_fill_translate: new o.bU(h, e.u_fill_translate)
            }),
            fillExtrusionPattern: (h, e) => ({
              u_lightpos: new o.bT(h, e.u_lightpos),
              u_lightpos_globe: new o.bT(h, e.u_lightpos_globe),
              u_lightintensity: new o.bg(h, e.u_lightintensity),
              u_lightcolor: new o.bT(h, e.u_lightcolor),
              u_vertical_gradient: new o.bg(h, e.u_vertical_gradient),
              u_height_factor: new o.bg(h, e.u_height_factor),
              u_opacity: new o.bg(h, e.u_opacity),
              u_fill_translate: new o.bU(h, e.u_fill_translate),
              u_image: new o.bP(h, e.u_image),
              u_texsize: new o.bU(h, e.u_texsize),
              u_pixel_coord_upper: new o.bU(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new o.bU(h, e.u_pixel_coord_lower),
              u_scale: new o.bT(h, e.u_scale),
              u_fade: new o.bg(h, e.u_fade)
            }),
            fill: (h, e) => ({
              u_fill_translate: new o.bU(h, e.u_fill_translate)
            }),
            fillPattern: (h, e) => ({
              u_image: new o.bP(h, e.u_image),
              u_texsize: new o.bU(h, e.u_texsize),
              u_pixel_coord_upper: new o.bU(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new o.bU(h, e.u_pixel_coord_lower),
              u_scale: new o.bT(h, e.u_scale),
              u_fade: new o.bg(h, e.u_fade),
              u_fill_translate: new o.bU(h, e.u_fill_translate)
            }),
            fillOutline: (h, e) => ({
              u_world: new o.bU(h, e.u_world),
              u_fill_translate: new o.bU(h, e.u_fill_translate)
            }),
            fillOutlinePattern: (h, e) => ({
              u_world: new o.bU(h, e.u_world),
              u_image: new o.bP(h, e.u_image),
              u_texsize: new o.bU(h, e.u_texsize),
              u_pixel_coord_upper: new o.bU(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new o.bU(h, e.u_pixel_coord_lower),
              u_scale: new o.bT(h, e.u_scale),
              u_fade: new o.bg(h, e.u_fade),
              u_fill_translate: new o.bU(h, e.u_fill_translate)
            }),
            circle: (h, e) => ({
              u_camera_to_center_distance: new o.bg(h, e.u_camera_to_center_distance),
              u_scale_with_map: new o.bP(h, e.u_scale_with_map),
              u_pitch_with_map: new o.bP(h, e.u_pitch_with_map),
              u_extrude_scale: new o.bU(h, e.u_extrude_scale),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_globe_extrude_scale: new o.bg(h, e.u_globe_extrude_scale),
              u_translate: new o.bU(h, e.u_translate)
            }),
            collisionBox: (h, e) => ({
              u_pixel_extrude_scale: new o.bU(h, e.u_pixel_extrude_scale)
            }),
            collisionCircle: (h, e) => ({
              u_viewport_size: new o.bU(h, e.u_viewport_size)
            }),
            debug: (h, e) => ({
              u_color: new o.bQ(h, e.u_color),
              u_overlay: new o.bP(h, e.u_overlay),
              u_overlay_scale: new o.bg(h, e.u_overlay_scale)
            }),
            depth: Tc,
            clippingMask: Tc,
            heatmap: (h, e) => ({
              u_extrude_scale: new o.bg(h, e.u_extrude_scale),
              u_intensity: new o.bg(h, e.u_intensity),
              u_globe_extrude_scale: new o.bg(h, e.u_globe_extrude_scale)
            }),
            heatmapTexture: (h, e) => ({
              u_matrix: new o.bR(h, e.u_matrix),
              u_world: new o.bU(h, e.u_world),
              u_image: new o.bP(h, e.u_image),
              u_color_ramp: new o.bP(h, e.u_color_ramp),
              u_opacity: new o.bg(h, e.u_opacity)
            }),
            hillshade: (h, e) => ({
              u_image: new o.bP(h, e.u_image),
              u_latrange: new o.bU(h, e.u_latrange),
              u_exaggeration: new o.bg(h, e.u_exaggeration),
              u_altitudes: new o.b_(h, e.u_altitudes),
              u_azimuths: new o.b_(h, e.u_azimuths),
              u_accent: new o.bQ(h, e.u_accent),
              u_method: new o.bP(h, e.u_method),
              u_shadows: new o.bZ(h, e.u_shadows),
              u_highlights: new o.bZ(h, e.u_highlights)
            }),
            hillshadePrepare: (h, e) => ({
              u_matrix: new o.bR(h, e.u_matrix),
              u_image: new o.bP(h, e.u_image),
              u_dimension: new o.bU(h, e.u_dimension),
              u_zoom: new o.bg(h, e.u_zoom),
              u_unpack: new o.bS(h, e.u_unpack)
            }),
            colorRelief: (h, e) => ({
              u_image: new o.bP(h, e.u_image),
              u_unpack: new o.bS(h, e.u_unpack),
              u_dimension: new o.bU(h, e.u_dimension),
              u_elevation_stops: new o.bP(h, e.u_elevation_stops),
              u_color_stops: new o.bP(h, e.u_color_stops),
              u_color_ramp_size: new o.bP(h, e.u_color_ramp_size),
              u_opacity: new o.bg(h, e.u_opacity)
            }),
            line: (h, e) => ({
              u_translation: new o.bU(h, e.u_translation),
              u_ratio: new o.bg(h, e.u_ratio),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new o.bU(h, e.u_units_to_pixels)
            }),
            lineGradient: (h, e) => ({
              u_translation: new o.bU(h, e.u_translation),
              u_ratio: new o.bg(h, e.u_ratio),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new o.bU(h, e.u_units_to_pixels),
              u_image: new o.bP(h, e.u_image),
              u_image_height: new o.bg(h, e.u_image_height)
            }),
            linePattern: (h, e) => ({
              u_translation: new o.bU(h, e.u_translation),
              u_texsize: new o.bU(h, e.u_texsize),
              u_ratio: new o.bg(h, e.u_ratio),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_image: new o.bP(h, e.u_image),
              u_units_to_pixels: new o.bU(h, e.u_units_to_pixels),
              u_scale: new o.bT(h, e.u_scale),
              u_fade: new o.bg(h, e.u_fade)
            }),
            lineSDF: (h, e) => ({
              u_translation: new o.bU(h, e.u_translation),
              u_ratio: new o.bg(h, e.u_ratio),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new o.bU(h, e.u_units_to_pixels),
              u_patternscale_a: new o.bU(h, e.u_patternscale_a),
              u_patternscale_b: new o.bU(h, e.u_patternscale_b),
              u_sdfgamma: new o.bg(h, e.u_sdfgamma),
              u_image: new o.bP(h, e.u_image),
              u_tex_y_a: new o.bg(h, e.u_tex_y_a),
              u_tex_y_b: new o.bg(h, e.u_tex_y_b),
              u_mix: new o.bg(h, e.u_mix)
            }),
            raster: (h, e) => ({
              u_tl_parent: new o.bU(h, e.u_tl_parent),
              u_scale_parent: new o.bg(h, e.u_scale_parent),
              u_buffer_scale: new o.bg(h, e.u_buffer_scale),
              u_fade_t: new o.bg(h, e.u_fade_t),
              u_opacity: new o.bg(h, e.u_opacity),
              u_image0: new o.bP(h, e.u_image0),
              u_image1: new o.bP(h, e.u_image1),
              u_brightness_low: new o.bg(h, e.u_brightness_low),
              u_brightness_high: new o.bg(h, e.u_brightness_high),
              u_saturation_factor: new o.bg(h, e.u_saturation_factor),
              u_contrast_factor: new o.bg(h, e.u_contrast_factor),
              u_spin_weights: new o.bT(h, e.u_spin_weights),
              u_coords_top: new o.bS(h, e.u_coords_top),
              u_coords_bottom: new o.bS(h, e.u_coords_bottom)
            }),
            symbolIcon: (h, e) => ({
              u_is_size_zoom_constant: new o.bP(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new o.bP(h, e.u_is_size_feature_constant),
              u_size_t: new o.bg(h, e.u_size_t),
              u_size: new o.bg(h, e.u_size),
              u_camera_to_center_distance: new o.bg(h, e.u_camera_to_center_distance),
              u_pitch: new o.bg(h, e.u_pitch),
              u_rotate_symbol: new o.bP(h, e.u_rotate_symbol),
              u_aspect_ratio: new o.bg(h, e.u_aspect_ratio),
              u_fade_change: new o.bg(h, e.u_fade_change),
              u_label_plane_matrix: new o.bR(h, e.u_label_plane_matrix),
              u_coord_matrix: new o.bR(h, e.u_coord_matrix),
              u_is_text: new o.bP(h, e.u_is_text),
              u_pitch_with_map: new o.bP(h, e.u_pitch_with_map),
              u_is_along_line: new o.bP(h, e.u_is_along_line),
              u_is_variable_anchor: new o.bP(h, e.u_is_variable_anchor),
              u_texsize: new o.bU(h, e.u_texsize),
              u_texture: new o.bP(h, e.u_texture),
              u_translation: new o.bU(h, e.u_translation),
              u_pitched_scale: new o.bg(h, e.u_pitched_scale)
            }),
            symbolSDF: (h, e) => ({
              u_is_size_zoom_constant: new o.bP(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new o.bP(h, e.u_is_size_feature_constant),
              u_size_t: new o.bg(h, e.u_size_t),
              u_size: new o.bg(h, e.u_size),
              u_camera_to_center_distance: new o.bg(h, e.u_camera_to_center_distance),
              u_pitch: new o.bg(h, e.u_pitch),
              u_rotate_symbol: new o.bP(h, e.u_rotate_symbol),
              u_aspect_ratio: new o.bg(h, e.u_aspect_ratio),
              u_fade_change: new o.bg(h, e.u_fade_change),
              u_label_plane_matrix: new o.bR(h, e.u_label_plane_matrix),
              u_coord_matrix: new o.bR(h, e.u_coord_matrix),
              u_is_text: new o.bP(h, e.u_is_text),
              u_pitch_with_map: new o.bP(h, e.u_pitch_with_map),
              u_is_along_line: new o.bP(h, e.u_is_along_line),
              u_is_variable_anchor: new o.bP(h, e.u_is_variable_anchor),
              u_texsize: new o.bU(h, e.u_texsize),
              u_texture: new o.bP(h, e.u_texture),
              u_gamma_scale: new o.bg(h, e.u_gamma_scale),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_is_halo: new o.bP(h, e.u_is_halo),
              u_translation: new o.bU(h, e.u_translation),
              u_pitched_scale: new o.bg(h, e.u_pitched_scale)
            }),
            symbolTextAndIcon: (h, e) => ({
              u_is_size_zoom_constant: new o.bP(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new o.bP(h, e.u_is_size_feature_constant),
              u_size_t: new o.bg(h, e.u_size_t),
              u_size: new o.bg(h, e.u_size),
              u_camera_to_center_distance: new o.bg(h, e.u_camera_to_center_distance),
              u_pitch: new o.bg(h, e.u_pitch),
              u_rotate_symbol: new o.bP(h, e.u_rotate_symbol),
              u_aspect_ratio: new o.bg(h, e.u_aspect_ratio),
              u_fade_change: new o.bg(h, e.u_fade_change),
              u_label_plane_matrix: new o.bR(h, e.u_label_plane_matrix),
              u_coord_matrix: new o.bR(h, e.u_coord_matrix),
              u_is_text: new o.bP(h, e.u_is_text),
              u_pitch_with_map: new o.bP(h, e.u_pitch_with_map),
              u_is_along_line: new o.bP(h, e.u_is_along_line),
              u_is_variable_anchor: new o.bP(h, e.u_is_variable_anchor),
              u_texsize: new o.bU(h, e.u_texsize),
              u_texsize_icon: new o.bU(h, e.u_texsize_icon),
              u_texture: new o.bP(h, e.u_texture),
              u_texture_icon: new o.bP(h, e.u_texture_icon),
              u_gamma_scale: new o.bg(h, e.u_gamma_scale),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_is_halo: new o.bP(h, e.u_is_halo),
              u_translation: new o.bU(h, e.u_translation),
              u_pitched_scale: new o.bg(h, e.u_pitched_scale)
            }),
            background: (h, e) => ({
              u_opacity: new o.bg(h, e.u_opacity),
              u_color: new o.bQ(h, e.u_color)
            }),
            backgroundPattern: (h, e) => ({
              u_opacity: new o.bg(h, e.u_opacity),
              u_image: new o.bP(h, e.u_image),
              u_pattern_tl_a: new o.bU(h, e.u_pattern_tl_a),
              u_pattern_br_a: new o.bU(h, e.u_pattern_br_a),
              u_pattern_tl_b: new o.bU(h, e.u_pattern_tl_b),
              u_pattern_br_b: new o.bU(h, e.u_pattern_br_b),
              u_texsize: new o.bU(h, e.u_texsize),
              u_mix: new o.bg(h, e.u_mix),
              u_pattern_size_a: new o.bU(h, e.u_pattern_size_a),
              u_pattern_size_b: new o.bU(h, e.u_pattern_size_b),
              u_scale_a: new o.bg(h, e.u_scale_a),
              u_scale_b: new o.bg(h, e.u_scale_b),
              u_pixel_coord_upper: new o.bU(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new o.bU(h, e.u_pixel_coord_lower),
              u_tile_units_to_pixels: new o.bg(h, e.u_tile_units_to_pixels)
            }),
            terrain: (h, e) => ({
              u_texture: new o.bP(h, e.u_texture),
              u_ele_delta: new o.bg(h, e.u_ele_delta),
              u_fog_matrix: new o.bR(h, e.u_fog_matrix),
              u_fog_color: new o.bQ(h, e.u_fog_color),
              u_fog_ground_blend: new o.bg(h, e.u_fog_ground_blend),
              u_fog_ground_blend_opacity: new o.bg(h, e.u_fog_ground_blend_opacity),
              u_horizon_color: new o.bQ(h, e.u_horizon_color),
              u_horizon_fog_blend: new o.bg(h, e.u_horizon_fog_blend),
              u_is_globe_mode: new o.bg(h, e.u_is_globe_mode)
            }),
            terrainDepth: (h, e) => ({
              u_ele_delta: new o.bg(h, e.u_ele_delta)
            }),
            terrainCoords: (h, e) => ({
              u_texture: new o.bP(h, e.u_texture),
              u_terrain_coords_id: new o.bg(h, e.u_terrain_coords_id),
              u_ele_delta: new o.bg(h, e.u_ele_delta)
            }),
            projectionErrorMeasurement: (h, e) => ({
              u_input: new o.bg(h, e.u_input),
              u_output_expected: new o.bg(h, e.u_output_expected)
            }),
            atmosphere: (h, e) => ({
              u_sun_pos: new o.bT(h, e.u_sun_pos),
              u_atmosphere_blend: new o.bg(h, e.u_atmosphere_blend),
              u_globe_position: new o.bT(h, e.u_globe_position),
              u_globe_radius: new o.bg(h, e.u_globe_radius),
              u_inv_proj_matrix: new o.bR(h, e.u_inv_proj_matrix)
            }),
            sky: (h, e) => ({
              u_sky_color: new o.bQ(h, e.u_sky_color),
              u_horizon_color: new o.bQ(h, e.u_horizon_color),
              u_horizon: new o.bU(h, e.u_horizon),
              u_horizon_normal: new o.bU(h, e.u_horizon_normal),
              u_sky_horizon_blend: new o.bg(h, e.u_sky_horizon_blend),
              u_sky_blend: new o.bg(h, e.u_sky_blend)
            })
          };
        class Ch {
          constructor(e, n, s) {
            this.context = e;
            const u = e.gl;
            this.buffer = u.createBuffer(), this.dynamicDraw = !!s, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), u.bufferData(u.ELEMENT_ARRAY_BUFFER, n.arrayBuffer, this.dynamicDraw ? u.DYNAMIC_DRAW : u.STATIC_DRAW), this.dynamicDraw || delete n.arrayBuffer
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer)
          }
          updateData(e) {
            const n = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), n.bufferSubData(n.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        const ol = {
          Int8: "BYTE",
          Uint8: "UNSIGNED_BYTE",
          Int16: "SHORT",
          Uint16: "UNSIGNED_SHORT",
          Int32: "INT",
          Uint32: "UNSIGNED_INT",
          Float32: "FLOAT"
        };
        class Za {
          constructor(e, n, s, u) {
            this.length = n.length, this.attributes = s, this.itemSize = n.bytesPerElement, this.dynamicDraw = u, this.context = e;
            const d = e.gl;
            this.buffer = d.createBuffer(), e.bindVertexBuffer.set(this.buffer), d.bufferData(d.ARRAY_BUFFER, n.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW), this.dynamicDraw || delete n.arrayBuffer
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer)
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const n = this.context.gl;
            this.bind(), n.bufferSubData(n.ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          enableAttributes(e, n) {
            for (let s = 0; s < this.attributes.length; s++) {
              const u = n.attributes[this.attributes[s].name];
              u !== void 0 && e.enableVertexAttribArray(u)
            }
          }
          setVertexAttribPointers(e, n, s) {
            for (let u = 0; u < this.attributes.length; u++) {
              const d = this.attributes[u],
                m = n.attributes[d.name];
              m !== void 0 && e.vertexAttribPointer(m, d.components, e[ol[d.type]], !1, this.itemSize, d.offset + this.itemSize * (s || 0))
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        class xi {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
          }
          get() {
            return this.current
          }
          set(e) {}
          getDefault() {
            return this.default
          }
          setDefault() {
            this.set(this.default)
          }
        }
        class Sc extends xi {
          getDefault() {
            return o.bf.transparent
          }
          set(e) {
            const n = this.current;
            (e.r !== n.r || e.g !== n.g || e.b !== n.b || e.a !== n.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Pc extends xi {
          getDefault() {
            return 1
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1)
          }
        }
        class Sh extends xi {
          getDefault() {
            return 0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1)
          }
        }
        class Ic extends xi {
          getDefault() {
            return [!0, !0, !0, !0]
          }
          set(e) {
            const n = this.current;
            (e[0] !== n[0] || e[1] !== n[1] || e[2] !== n[2] || e[3] !== n[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class gs extends xi {
          getDefault() {
            return !0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Mc extends xi {
          getDefault() {
            return 255
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1)
          }
        }
        class rp extends xi {
          getDefault() {
            return {
              func: this.gl.ALWAYS,
              ref: 0,
              mask: 255
            }
          }
          set(e) {
            const n = this.current;
            (e.func !== n.func || e.ref !== n.ref || e.mask !== n.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1)
          }
        }
        class ip extends xi {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP]
          }
          set(e) {
            const n = this.current;
            (e[0] !== n[0] || e[1] !== n[1] || e[2] !== n[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1)
          }
        }
        class np extends xi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            e ? n.enable(n.STENCIL_TEST) : n.disable(n.STENCIL_TEST), this.current = e, this.dirty = !1
          }
        }
        class ap extends xi {
          getDefault() {
            return [0, 1]
          }
          set(e) {
            const n = this.current;
            (e[0] !== n[0] || e[1] !== n[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Ph extends xi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            e ? n.enable(n.DEPTH_TEST) : n.disable(n.DEPTH_TEST), this.current = e, this.dirty = !1
          }
        }
        class sp extends xi {
          getDefault() {
            return this.gl.LESS
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1)
          }
        }
        class Ih extends xi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            e ? n.enable(n.BLEND) : n.disable(n.BLEND), this.current = e, this.dirty = !1
          }
        }
        class ll extends xi {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO]
          }
          set(e) {
            const n = this.current;
            (e[0] !== n[0] || e[1] !== n[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class cl extends xi {
          getDefault() {
            return o.bf.transparent
          }
          set(e) {
            const n = this.current;
            (e.r !== n.r || e.g !== n.g || e.b !== n.b || e.a !== n.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class ul extends xi {
          getDefault() {
            return this.gl.FUNC_ADD
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1)
          }
        }
        class Ac extends xi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            e ? n.enable(n.CULL_FACE) : n.disable(n.CULL_FACE), this.current = e, this.dirty = !1
          }
        }
        class vs extends xi {
          getDefault() {
            return this.gl.BACK
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1)
          }
        }
        class wo extends xi {
          getDefault() {
            return this.gl.CCW
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1)
          }
        }
        class Os extends xi {
          getDefault() {
            return null
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1)
          }
        }
        class ca extends xi {
          getDefault() {
            return this.gl.TEXTURE0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1)
          }
        }
        class Mh extends xi {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
          }
          set(e) {
            const n = this.current;
            (e[0] !== n[0] || e[1] !== n[1] || e[2] !== n[2] || e[3] !== n[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class Ah extends xi {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindFramebuffer(n.FRAMEBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class kc extends xi {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindRenderbuffer(n.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class ys extends xi {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindTexture(n.TEXTURE_2D, e), this.current = e, this.dirty = !1
          }
        }
        class hl extends xi {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindBuffer(n.ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class dl extends xi {
          getDefault() {
            return null
          }
          set(e) {
            const n = this.gl;
            n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class To extends xi {
          getDefault() {
            return null
          }
          set(e) {
            var n;
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            Da(s) ? s.bindVertexArray(e) : (n = s.getExtension("OES_vertex_array_object")) === null || n === void 0 || n.bindVertexArrayOES(e), this.current = e, this.dirty = !1
          }
        }
        class pl extends xi {
          getDefault() {
            return 4
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.pixelStorei(n.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1
          }
        }
        class kh extends xi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class Ns extends xi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class ts extends xi {
          constructor(e, n) {
            super(e), this.context = e, this.parent = n
          }
          getDefault() {
            return null
          }
        }
        class Eh extends ts {
          setDirty() {
            this.dirty = !0
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const n = this.gl;
            n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1
          }
        }
        class Ec extends ts {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const n = this.gl;
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class ii extends ts {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const n = this.gl;
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        const Co = "Framebuffer is not complete";
        class op {
          constructor(e, n, s, u, d) {
            this.context = e, this.width = n, this.height = s;
            const m = e.gl,
              y = this.framebuffer = m.createFramebuffer();
            if (this.colorAttachment = new Eh(e, y), u) this.depthAttachment = d ? new ii(e, y) : new Ec(e, y);
            else if (d) throw new Error("Stencil cannot be set without depth");
            if (m.checkFramebufferStatus(m.FRAMEBUFFER) !== m.FRAMEBUFFER_COMPLETE) throw new Error(Co)
          }
          destroy() {
            const e = this.context.gl,
              n = this.colorAttachment.get();
            if (n && e.deleteTexture(n), this.depthAttachment) {
              const s = this.depthAttachment.get();
              s && e.deleteRenderbuffer(s)
            }
            e.deleteFramebuffer(this.framebuffer)
          }
        }
        class zh {
          constructor(e) {
            var n, s;
            if (this.gl = e, this.clearColor = new Sc(this), this.clearDepth = new Pc(this), this.clearStencil = new Sh(this), this.colorMask = new Ic(this), this.depthMask = new gs(this), this.stencilMask = new Mc(this), this.stencilFunc = new rp(this), this.stencilOp = new ip(this), this.stencilTest = new np(this), this.depthRange = new ap(this), this.depthTest = new Ph(this), this.depthFunc = new sp(this), this.blend = new Ih(this), this.blendFunc = new ll(this), this.blendColor = new cl(this), this.blendEquation = new ul(this), this.cullFace = new Ac(this), this.cullFaceSide = new vs(this), this.frontFace = new wo(this), this.program = new Os(this), this.activeTexture = new ca(this), this.viewport = new Mh(this), this.bindFramebuffer = new Ah(this), this.bindRenderbuffer = new kc(this), this.bindTexture = new ys(this), this.bindVertexBuffer = new hl(this), this.bindElementBuffer = new dl(this), this.bindVertexArray = new To(this), this.pixelStoreUnpack = new pl(this), this.pixelStoreUnpackPremultiplyAlpha = new kh(this), this.pixelStoreUnpackFlipY = new Ns(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Da(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const u = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (n = e.RGBA16F) !== null && n !== void 0 ? n : u == null ? void 0 : u.RGBA16F_EXT, this.RGB16F = (s = e.RGB16F) !== null && s !== void 0 ? s : u == null ? void 0 : u.RGB16F_EXT, e.getExtension("EXT_color_buffer_float")
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const u = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = u == null ? void 0 : u.HALF_FLOAT_OES
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
          }
          createIndexBuffer(e, n) {
            return new Ch(this, e, n)
          }
          createVertexBuffer(e, n, s) {
            return new Za(this, e, n, s)
          }
          createRenderbuffer(e, n, s) {
            const u = this.gl,
              d = u.createRenderbuffer();
            return this.bindRenderbuffer.set(d), u.renderbufferStorage(u.RENDERBUFFER, e, n, s), this.bindRenderbuffer.set(null), d
          }
          createFramebuffer(e, n, s, u) {
            return new op(this, e, n, s, u)
          }
          clear({
            color: e,
            depth: n,
            stencil: s
          }) {
            const u = this.gl;
            let d = 0;
            e && (d |= u.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), n !== void 0 && (d |= u.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(n), this.depthMask.set(!0)), s !== void 0 && (d |= u.STENCIL_BUFFER_BIT, this.clearStencil.set(s), this.stencilMask.set(255)), u.clear(d)
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace))
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1)
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
              func: e.test.func,
              ref: e.ref,
              mask: e.test.mask
            })) : this.stencilTest.set(!1)
          }
          setColorMode(e) {
            o.bH(e.blendFunction, Si.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask)
          }
          createVertexArray() {
            var e;
            return Da(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
          }
          deleteVertexArray(e) {
            var n;
            return Da(this.gl) ? this.gl.deleteVertexArray(e) : (n = this.gl.getExtension("OES_vertex_array_object")) === null || n === void 0 ? void 0 : n.deleteVertexArrayOES(e)
          }
          unbindVAO() {
            this.bindVertexArray.set(null)
          }
        }
        let rs;

        function Lh(h, e, n, s, u) {
          const d = h.context,
            m = h.transform,
            y = d.gl,
            b = h.useProgram("collisionBox"),
            P = [];
          let M = 0,
            L = 0;
          for (let re = 0; re < s.length; re++) {
            const se = s[re],
              de = e.getTile(se).getBucket(n);
            if (!de) continue;
            const ue = u ? de.textCollisionBox : de.iconCollisionBox,
              ge = de.collisionCircleArray;
            ge.length > 0 && (P.push({
              circleArray: ge,
              circleOffset: L,
              coord: se
            }), M += ge.length / 4, L = M), ue && b.draw(d, y.LINES, Ur.disabled, di.disabled, h.colorModeForRenderPass(), wr.disabled, al(h.transform), h.style.map.terrain && h.style.map.terrain.getTerrainData(se), m.getProjectionData({
              overscaledTileID: se,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }), n.id, ue.layoutVertexBuffer, ue.indexBuffer, ue.segments, null, h.transform.zoom, null, null, ue.collisionVertexBuffer)
          }
          if (!u || !P.length) return;
          const z = h.useProgram("collisionCircle"),
            B = new o.b$;
          B.resize(4 * M), B._trim();
          let U = 0;
          for (const re of P)
            for (let se = 0; se < re.circleArray.length / 4; se++) {
              const de = 4 * se,
                ue = re.circleArray[de + 0],
                ge = re.circleArray[de + 1],
                we = re.circleArray[de + 2],
                he = re.circleArray[de + 3];
              B.emplace(U++, ue, ge, we, he, 0), B.emplace(U++, ue, ge, we, he, 1), B.emplace(U++, ue, ge, we, he, 2), B.emplace(U++, ue, ge, we, he, 3)
            }(!rs || rs.length < 2 * M) && (rs = (function(re) {
              const se = 2 * re,
                de = new o.c1;
              de.resize(se), de._trim();
              for (let ue = 0; ue < se; ue++) {
                const ge = 6 * ue;
                de.uint16[ge + 0] = 4 * ue + 0, de.uint16[ge + 1] = 4 * ue + 1, de.uint16[ge + 2] = 4 * ue + 2, de.uint16[ge + 3] = 4 * ue + 2, de.uint16[ge + 4] = 4 * ue + 3, de.uint16[ge + 5] = 4 * ue + 0
              }
              return de
            })(M));
          const Q = d.createIndexBuffer(rs, !0),
            J = d.createVertexBuffer(B, o.c0.members, !0);
          for (const re of P) {
            const se = Jd(h.transform);
            z.draw(d, y.TRIANGLES, Ur.disabled, di.disabled, h.colorModeForRenderPass(), wr.disabled, se, h.style.map.terrain && h.style.map.terrain.getTerrainData(re.coord), null, n.id, J, Q, o.aM.simpleSegment(0, 2 * re.circleOffset, re.circleArray.length, re.circleArray.length / 2), null, h.transform.zoom, null, null, null)
          }
          J.destroy(), Q.destroy()
        }
        const lp = o.ag(new Float32Array(16));

        function Dh(h, e, n, s, u, d) {
          const {
            horizontalAlign: m,
            verticalAlign: y
          } = o.aH(h);
          return new o.P((-(m - .5) * e / u + s[0]) * d, (-(y - .5) * n / u + s[1]) * d)
        }

        function cp(h, e, n, s, u, d) {
          const m = e.tileAnchorPoint.add(new o.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let y = s.mult(d);
            n || (y = y.rotate(-u));
            const b = m.add(y);
            return ai(b.x, b.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
          }
          if (n) {
            const y = zr(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(h),
              b = Math.atan(y.y / y.x) + (y.x < 0 ? Math.PI : 0);
            return h.add(s.rotate(b))
          }
          return h.add(s)
        }

        function zc(h, e, n, s, u, d, m, y, b, P, M, L) {
          const z = h.text.placedSymbolArray,
            B = h.text.dynamicLayoutVertexArray,
            U = h.icon.dynamicLayoutVertexArray,
            Q = {};
          B.clear();
          for (let J = 0; J < z.length; J++) {
            const re = z.get(J),
              se = re.hidden || !re.crossTileID || h.allowVerticalPlacement && !re.placedOrientation ? null : s[re.crossTileID];
            if (se) {
              const de = new o.P(re.anchorX, re.anchorY),
                ue = {
                  getElevation: L,
                  width: u.width,
                  height: u.height,
                  pitchedLabelPlaneMatrix: d,
                  pitchWithMap: n,
                  transform: u,
                  tileAnchorPoint: de,
                  translation: P,
                  unwrappedTileID: M
                },
                ge = n ? li(de.x, de.y, ue) : zr(de.x, de.y, ue),
                we = ft(u.cameraToCenterDistance, ge.signedDistanceFromCamera);
              let he = o.ap(h.textSizeData, y, re) * we / o.aB;
              n && (he *= h.tilePixelRatio / m);
              const {
                width: ze,
                height: He,
                anchor: Ne,
                textOffset: qe,
                textBoxScale: Ge
              } = se, Dt = Dh(Ne, ze, He, qe, Ge, he), Ft = u.getPitchedTextCorrection(de.x + P[0], de.y + P[1], M), vt = cp(ge.point, ue, e, Dt, -u.bearingInRadians, Ft), sr = h.allowVerticalPlacement && re.placedOrientation === o.ao.vertical ? Math.PI / 2 : 0;
              for (let Kr = 0; Kr < re.numGlyphs; Kr++) o.av(B, vt, sr);
              b && re.associatedIconIndex >= 0 && (Q[re.associatedIconIndex] = {
                shiftedAnchor: vt,
                angle: sr
              })
            } else mi(re.numGlyphs, B)
          }
          if (b) {
            U.clear();
            const J = h.icon.placedSymbolArray;
            for (let re = 0; re < J.length; re++) {
              const se = J.get(re);
              if (se.hidden) mi(se.numGlyphs, U);
              else {
                const de = Q[re];
                if (de)
                  for (let ue = 0; ue < se.numGlyphs; ue++) o.av(U, de.shiftedAnchor, de.angle);
                else mi(se.numGlyphs, U)
              }
            }
            h.icon.dynamicLayoutVertexBuffer.updateData(U)
          }
          h.text.dynamicLayoutVertexBuffer.updateData(B)
        }

        function fl(h, e, n) {
          return n.iconsInText && e ? "symbolTextAndIcon" : h ? "symbolSDF" : "symbolIcon"
        }

        function So(h, e, n, s, u, d, m, y, b, P, M, L, z) {
          const B = h.context,
            U = B.gl,
            Q = h.transform,
            J = y === "map",
            re = b === "map",
            se = y !== "viewport" && n.layout.get("symbol-placement") !== "point",
            de = J && !re && !se,
            ue = !n.layout.get("symbol-sort-key").isConstant();
          let ge = !1;
          const we = h.getDepthModeForSublayer(0, Ur.ReadOnly),
            he = n._unevaluatedLayout.hasValue("text-variable-anchor") || n._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
            ze = [],
            He = Q.getCircleRadiusCorrection();
          for (const Ne of s) {
            const qe = e.getTile(Ne),
              Ge = qe.getBucket(n);
            if (!Ge) continue;
            const Dt = u ? Ge.text : Ge.icon;
            if (!Dt || !Dt.segments.get().length || !Dt.hasVisibleVertices) continue;
            const Ft = Dt.programConfigurations.get(n.id),
              vt = u || Ge.sdfIcons,
              sr = u ? Ge.textSizeData : Ge.iconSizeData,
              Kr = re || Q.pitch !== 0,
              wi = h.useProgram(fl(vt, u, Ge), Ft),
              ki = o.an(sr, Q.zoom),
              Ii = h.style.map.terrain && h.style.map.terrain.getTerrainData(Ne);
            let qi, $i, Xr, Ei, nn = [0, 0],
              dn = null;
            if (u) $i = qe.glyphAtlasTexture, Xr = U.LINEAR, qi = qe.glyphAtlasTexture.size, Ge.iconsInText && (nn = qe.imageAtlasTexture.size, dn = qe.imageAtlasTexture, Ei = Kr || h.options.rotating || h.options.zooming || sr.kind === "composite" || sr.kind === "camera" ? U.LINEAR : U.NEAREST);
            else {
              const an = n.layout.get("icon-size").constantOr(0) !== 1 || Ge.iconsNeedLinear;
              $i = qe.imageAtlasTexture, Xr = vt || h.options.rotating || h.options.zooming || an || Kr ? U.LINEAR : U.NEAREST, qi = qe.imageAtlasTexture.size
            }
            const xn = o.aC(qe, 1, h.transform.zoom),
              qn = Gr(J, h.transform, xn),
              Sa = o.L();
            o.aq(Sa, qn);
            const ns = mr(re, J, h.transform, xn),
              as = o.aD(Q, qe, d, m),
              Ys = Q.getProjectionData({
                overscaledTileID: Ne,
                applyGlobeMatrix: !z,
                applyTerrainMatrix: !0
              }),
              Js = he && Ge.hasTextData(),
              Ps = n.layout.get("icon-text-fit") !== "none" && Js && Ge.hasIconData();
            if (se) {
              const an = h.style.map.terrain ? (da, sn) => h.style.map.terrain.getElevation(Ne, da, sn) : null,
                pn = n.layout.get("text-rotation-alignment") === "map";
              pi(Ge, h, u, qn, Sa, re, P, pn, Ne.toUnwrapped(), Q.width, Q.height, as, an)
            }
            const Is = u && he || Ps,
              Yn = se || Is ? lp : re ? qn : h.transform.clipSpaceToPixelsMatrix,
              Pa = vt && n.paint.get(u ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Vn;
            Vn = vt ? Ge.iconsInText ? tp(sr.kind, ki, de, re, se, Is, h, Yn, ns, as, qi, nn, He) : bh(sr.kind, ki, de, re, se, Is, h, Yn, ns, as, u, qi, 0, He) : bo(sr.kind, ki, de, re, se, Is, h, Yn, ns, as, u, qi, He);
            const ss = {
              program: wi,
              buffers: Dt,
              uniformValues: Vn,
              projectionData: Ys,
              atlasTexture: $i,
              atlasTextureIcon: dn,
              atlasInterpolation: Xr,
              atlasInterpolationIcon: Ei,
              isSDF: vt,
              hasHalo: Pa
            };
            if (ue && Ge.canOverlap) {
              ge = !0;
              const an = Dt.segments.get();
              for (const pn of an) ze.push({
                segments: new o.aM([pn]),
                sortKey: pn.sortKey,
                state: ss,
                terrainData: Ii
              })
            } else ze.push({
              segments: Dt.segments,
              sortKey: 0,
              state: ss,
              terrainData: Ii
            })
          }
          ge && ze.sort(((Ne, qe) => Ne.sortKey - qe.sortKey));
          for (const Ne of ze) {
            const qe = Ne.state;
            if (B.activeTexture.set(U.TEXTURE0), qe.atlasTexture.bind(qe.atlasInterpolation, U.CLAMP_TO_EDGE), qe.atlasTextureIcon && (B.activeTexture.set(U.TEXTURE1), qe.atlasTextureIcon && qe.atlasTextureIcon.bind(qe.atlasInterpolationIcon, U.CLAMP_TO_EDGE)), qe.isSDF) {
              const Ge = qe.uniformValues;
              qe.hasHalo && (Ge.u_is_halo = 1, Po(qe.buffers, Ne.segments, n, h, qe.program, we, M, L, Ge, qe.projectionData, Ne.terrainData)), Ge.u_is_halo = 0
            }
            Po(qe.buffers, Ne.segments, n, h, qe.program, we, M, L, qe.uniformValues, qe.projectionData, Ne.terrainData)
          }
        }

        function Po(h, e, n, s, u, d, m, y, b, P, M) {
          const L = s.context;
          u.draw(L, L.gl.TRIANGLES, d, m, y, wr.backCCW, b, M, P, n.id, h.layoutVertexBuffer, h.indexBuffer, e, n.paint, s.transform.zoom, h.programConfigurations.get(n.id), h.dynamicLayoutVertexBuffer, h.opacityVertexBuffer)
        }

        function Lc(h, e, n, s, u) {
          const d = h.context,
            m = d.gl,
            y = di.disabled,
            b = new Si([m.ONE, m.ONE], o.bf.transparent, [!0, !0, !0, !0]),
            P = e.getBucket(n);
          if (!P) return;
          const M = s.key;
          let L = n.heatmapFbos.get(M);
          L || (L = Io(d, e.tileSize, e.tileSize), n.heatmapFbos.set(M, L)), d.bindFramebuffer.set(L.framebuffer), d.viewport.set([0, 0, e.tileSize, e.tileSize]), d.clear({
            color: o.bf.transparent
          });
          const z = P.programConfigurations.get(n.id),
            B = h.useProgram("heatmap", z, !u),
            U = h.transform.getProjectionData({
              overscaledTileID: e.tileID,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }),
            Q = h.style.map.terrain.getTerrainData(s);
          B.draw(d, m.TRIANGLES, Ur.disabled, y, b, wr.disabled, _h(e, h.transform.zoom, n.paint.get("heatmap-intensity"), 1), Q, U, n.id, P.layoutVertexBuffer, P.indexBuffer, P.segments, n.paint, h.transform.zoom, z)
        }

        function Rh(h, e, n, s, u) {
          const d = h.context,
            m = d.gl,
            y = h.transform;
          d.setColorMode(h.colorModeForRenderPass());
          const b = Mo(d, e),
            P = n.key,
            M = e.heatmapFbos.get(P);
          if (!M) return;
          d.activeTexture.set(m.TEXTURE0), m.bindTexture(m.TEXTURE_2D, M.colorAttachment.get()), d.activeTexture.set(m.TEXTURE1), b.bind(m.LINEAR, m.CLAMP_TO_EDGE);
          const L = y.getProjectionData({
            overscaledTileID: n,
            applyTerrainMatrix: u,
            applyGlobeMatrix: !s
          });
          h.useProgram("heatmapTexture").draw(d, m.TRIANGLES, Ur.disabled, di.disabled, h.colorModeForRenderPass(), wr.disabled, yc(h, e, 0, 1), null, L, e.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments, e.paint, y.zoom), M.destroy(), e.heatmapFbos.delete(P)
        }

        function Io(h, e, n) {
          var s, u;
          const d = h.gl,
            m = d.createTexture();
          d.bindTexture(d.TEXTURE_2D, m), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR);
          const y = (s = h.HALF_FLOAT) !== null && s !== void 0 ? s : d.UNSIGNED_BYTE,
            b = (u = h.RGBA16F) !== null && u !== void 0 ? u : d.RGBA;
          d.texImage2D(d.TEXTURE_2D, 0, b, e, n, 0, d.RGBA, y, null);
          const P = h.createFramebuffer(e, n, !1, !1);
          return P.colorAttachment.set(m), P
        }

        function Mo(h, e) {
          return e.colorRampTexture || (e.colorRampTexture = new o.T(h, e.colorRamp, h.gl.RGBA)), e.colorRampTexture
        }

        function Ao(h, e, n, s, u) {
          if (!n || !s || !s.imageAtlas) return;
          const d = s.imageAtlas.patternPositions;
          let m = d[n.to.toString()],
            y = d[n.from.toString()];
          if (!m && y && (m = y), !y && m && (y = m), !m || !y) {
            const b = u.getPaintProperty(e);
            m = d[b], y = d[b]
          }
          m && y && h.setConstantPatternPositions(m, y)
        }

        function ml(h, e, n, s, u, d, m, y) {
          const b = h.context.gl,
            P = "fill-pattern",
            M = n.paint.get(P),
            L = M && M.constantOr(1),
            z = n.getCrossfadeParameters();
          let B, U, Q, J, re;
          const se = h.transform,
            de = n.paint.get("fill-translate"),
            ue = n.paint.get("fill-translate-anchor");
          m ? (U = L && !n.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", B = b.LINES) : (U = L ? "fillPattern" : "fill", B = b.TRIANGLES);
          const ge = M.constantOr(null);
          for (const we of s) {
            const he = e.getTile(we);
            if (L && !he.patternsLoaded()) continue;
            const ze = he.getBucket(n);
            if (!ze) continue;
            const He = ze.programConfigurations.get(n.id),
              Ne = h.useProgram(U, He),
              qe = h.style.map.terrain && h.style.map.terrain.getTerrainData(we);
            L && (h.context.activeTexture.set(b.TEXTURE0), he.imageAtlasTexture.bind(b.LINEAR, b.CLAMP_TO_EDGE), He.updatePaintBuffers(z)), Ao(He, P, ge, he, n);
            const Ge = se.getProjectionData({
                overscaledTileID: we,
                applyGlobeMatrix: !y,
                applyTerrainMatrix: !0
              }),
              Dt = o.aD(se, he, de, ue);
            if (m) {
              J = ze.indexBuffer2, re = ze.segments2;
              const vt = [b.drawingBufferWidth, b.drawingBufferHeight];
              Q = U === "fillOutlinePattern" && L ? yo(h, z, he, vt, Dt) : vo(vt, Dt)
            } else J = ze.indexBuffer, re = ze.segments, Q = L ? nl(h, z, he, Dt) : {
              u_fill_translate: Dt
            };
            const Ft = h.stencilModeForClipping(we);
            Ne.draw(h.context, B, u, Ft, d, wr.backCCW, Q, qe, Ge, n.id, ze.layoutVertexBuffer, J, re, n.paint, h.transform.zoom, He)
          }
        }

        function Dc(h, e, n, s, u, d, m, y) {
          const b = h.context,
            P = b.gl,
            M = "fill-extrusion-pattern",
            L = n.paint.get(M),
            z = L.constantOr(1),
            B = n.getCrossfadeParameters(),
            U = n.paint.get("fill-extrusion-opacity"),
            Q = L.constantOr(null),
            J = h.transform;
          for (const re of s) {
            const se = e.getTile(re),
              de = se.getBucket(n);
            if (!de) continue;
            const ue = h.style.map.terrain && h.style.map.terrain.getTerrainData(re),
              ge = de.programConfigurations.get(n.id),
              we = h.useProgram(z ? "fillExtrusionPattern" : "fillExtrusion", ge);
            z && (h.context.activeTexture.set(P.TEXTURE0), se.imageAtlasTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE), ge.updatePaintBuffers(B));
            const he = J.getProjectionData({
              overscaledTileID: re,
              applyGlobeMatrix: !y,
              applyTerrainMatrix: !0
            });
            Ao(ge, M, Q, se, n);
            const ze = o.aD(J, se, n.paint.get("fill-extrusion-translate"), n.paint.get("fill-extrusion-translate-anchor")),
              He = n.paint.get("fill-extrusion-vertical-gradient"),
              Ne = z ? Kd(h, He, U, ze, re, B, se) : ya(h, He, U, ze);
            we.draw(b, b.gl.TRIANGLES, u, d, m, wr.backCCW, Ne, ue, he, n.id, de.layoutVertexBuffer, de.indexBuffer, de.segments, n.paint, h.transform.zoom, ge, h.style.map.terrain && de.centroidVertexBuffer)
          }
        }

        function xs(h, e, n, s, u, d, m, y, b) {
          var P;
          const M = h.style.projection,
            L = h.context,
            z = h.transform,
            B = L.gl,
            U = [`#define NUM_ILLUMINATION_SOURCES ${n.paint.get("hillshade-highlight-color").values.length}`],
            Q = h.useProgram("hillshade", null, !1, U),
            J = !h.options.moving;
          for (const re of s) {
            const se = e.getTile(re),
              de = se.fbo;
            if (!de) continue;
            const ue = M.getMeshFromTileID(L, re.canonical, y, !0, "raster"),
              ge = (P = h.style.map.terrain) === null || P === void 0 ? void 0 : P.getTerrainData(re);
            L.activeTexture.set(B.TEXTURE0), B.bindTexture(B.TEXTURE_2D, de.colorAttachment.get());
            const we = z.getProjectionData({
              overscaledTileID: re,
              aligned: J,
              applyGlobeMatrix: !b,
              applyTerrainMatrix: !0
            });
            Q.draw(L, B.TRIANGLES, d, u[re.overscaledZ], m, wr.backCCW, Qd(h, se, n), ge, we, n.id, ue.vertexBuffer, ue.indexBuffer, ue.segments)
          }
        }

        function Rc(h, e, n, s, u, d, m, y, b) {
          var P;
          const M = h.style.projection,
            L = h.context,
            z = h.transform,
            B = L.gl,
            U = h.useProgram("colorRelief"),
            Q = !h.options.moving;
          let J = !0,
            re = 0;
          for (const se of s) {
            const de = e.getTile(se),
              ue = de.dem;
            if (J) {
              const Ne = B.getParameter(B.MAX_TEXTURE_SIZE),
                {
                  elevationTexture: qe,
                  colorTexture: Ge
                } = n.getColorRampTextures(L, Ne, ue.getUnpackVector());
              L.activeTexture.set(B.TEXTURE1), qe.bind(B.NEAREST, B.CLAMP_TO_EDGE), L.activeTexture.set(B.TEXTURE4), Ge.bind(B.LINEAR, B.CLAMP_TO_EDGE), J = !1, re = qe.size[0]
            }
            if (!ue || !ue.data) continue;
            const ge = ue.stride,
              we = ue.getPixels();
            if (L.activeTexture.set(B.TEXTURE0), L.pixelStoreUnpackPremultiplyAlpha.set(!1), de.demTexture = de.demTexture || h.getTileTexture(ge), de.demTexture) {
              const Ne = de.demTexture;
              Ne.update(we, {
                premultiply: !1
              }), Ne.bind(B.LINEAR, B.CLAMP_TO_EDGE)
            } else de.demTexture = new o.T(L, we, B.RGBA, {
              premultiply: !1
            }), de.demTexture.bind(B.LINEAR, B.CLAMP_TO_EDGE);
            const he = M.getMeshFromTileID(L, se.canonical, y, !0, "raster"),
              ze = (P = h.style.map.terrain) === null || P === void 0 ? void 0 : P.getTerrainData(se),
              He = z.getProjectionData({
                overscaledTileID: se,
                aligned: Q,
                applyGlobeMatrix: !b,
                applyTerrainMatrix: !0
              });
            U.draw(L, B.TRIANGLES, d, u[se.overscaledZ], m, wr.backCCW, vh(n, de.dem, re), ze, He, n.id, he.vertexBuffer, he.indexBuffer, he.segments)
          }
        }
        const _l = [new o.P(0, 0), new o.P(o.$, 0), new o.P(o.$, o.$), new o.P(0, o.$)];

        function bs(h, e, n, s, u, d, m, y, b = !1, P = !1) {
          const M = s[s.length - 1].overscaledZ,
            L = h.context,
            z = L.gl,
            B = h.useProgram("raster"),
            U = h.transform,
            Q = h.style.projection,
            J = h.colorModeForRenderPass(),
            re = !h.options.moving;
          for (const se of s) {
            const de = h.getDepthModeForSublayer(se.overscaledZ - M, n.paint.get("raster-opacity") === 1 ? Ur.ReadWrite : Ur.ReadOnly, z.LESS),
              ue = e.getTile(se);
            ue.registerFadeDuration(n.paint.get("raster-fade-duration"));
            const ge = e.findLoadedParent(se, 0),
              we = e.findLoadedSibling(se),
              he = Bc(ue, ge || we || null, e, n, h.transform, h.style.map.terrain);
            let ze, He;
            const Ne = n.paint.get("raster-resampling") === "nearest" ? z.NEAREST : z.LINEAR;
            L.activeTexture.set(z.TEXTURE0), ue.texture.bind(Ne, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST), L.activeTexture.set(z.TEXTURE1), ge ? (ge.texture.bind(Ne, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST), ze = Math.pow(2, ge.tileID.overscaledZ - ue.tileID.overscaledZ), He = [ue.tileID.canonical.x * ze % 1, ue.tileID.canonical.y * ze % 1]) : ue.texture.bind(Ne, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST), ue.texture.useMipmap && L.extTextureFilterAnisotropic && h.transform.pitch > 20 && z.texParameterf(z.TEXTURE_2D, L.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, L.extTextureFilterAnisotropicMax);
            const qe = h.style.map.terrain && h.style.map.terrain.getTerrainData(se),
              Ge = U.getProjectionData({
                overscaledTileID: se,
                aligned: re,
                applyGlobeMatrix: !P,
                applyTerrainMatrix: !0
              }),
              Dt = xo(He || [0, 0], ze || 1, he, n, y),
              Ft = Q.getMeshFromTileID(L, se.canonical, d, m, "raster");
            B.draw(L, z.TRIANGLES, de, u ? u[se.overscaledZ] : di.disabled, J, b ? wr.frontCCW : wr.backCCW, Dt, qe, Ge, n.id, Ft.vertexBuffer, Ft.indexBuffer, Ft.segments)
          }
        }

        function Bc(h, e, n, s, u, d) {
          const m = s.paint.get("raster-fade-duration");
          if (!d && m > 0) {
            const y = xe.now(),
              b = (y - h.timeAdded) / m,
              P = e ? (y - e.timeAdded) / m : -1,
              M = n.getSource(),
              L = kt(u, {
                tileSize: M.tileSize,
                roundZoom: M.roundZoom
              }),
              z = !e || Math.abs(e.tileID.overscaledZ - L) > Math.abs(h.tileID.overscaledZ - L),
              B = z && h.refreshedUponExpiration ? 1 : o.ah(z ? b : 1 - P, 0, 1);
            return h.refreshedUponExpiration && b >= 1 && (h.refreshedUponExpiration = !1), e ? {
              opacity: 1,
              mix: 1 - B
            } : {
              opacity: B,
              mix: 0
            }
          }
          return {
            opacity: 1,
            mix: 0
          }
        }
        const Bh = new o.bf(1, 0, 0, 1),
          Fh = new o.bf(0, 1, 0, 1),
          gl = new o.bf(0, 0, 1, 1),
          Fc = new o.bf(1, 0, 1, 1),
          up = new o.bf(0, 1, 1, 1);

        function Oc(h, e, n, s) {
          Fa(h, 0, e + n / 2, h.transform.width, n, s)
        }

        function Zi(h, e, n, s) {
          Fa(h, e - n / 2, 0, n, h.transform.height, s)
        }

        function Fa(h, e, n, s, u, d) {
          const m = h.context,
            y = m.gl;
          y.enable(y.SCISSOR_TEST), y.scissor(e * h.pixelRatio, n * h.pixelRatio, s * h.pixelRatio, u * h.pixelRatio), m.clear({
            color: d
          }), y.disable(y.SCISSOR_TEST)
        }

        function ua(h, e, n) {
          const s = h.context,
            u = s.gl,
            d = h.useProgram("debug"),
            m = Ur.disabled,
            y = di.disabled,
            b = h.colorModeForRenderPass(),
            P = "$debug",
            M = h.style.map.terrain && h.style.map.terrain.getTerrainData(n);
          s.activeTexture.set(u.TEXTURE0);
          const L = e.getTileByID(n.key).latestRawTileData,
            z = Math.floor((L && L.byteLength || 0) / 1024),
            B = e.getTile(n).tileSize,
            U = 512 / Math.min(B, 512) * (n.overscaledZ / h.transform.zoom) * .5;
          let Q = n.canonical.toString();
          n.overscaledZ !== n.canonical.z && (Q += ` => ${n.overscaledZ}`), (function(re, se) {
            re.initDebugOverlayCanvas();
            const de = re.debugOverlayCanvas,
              ue = re.context.gl,
              ge = re.debugOverlayCanvas.getContext("2d");
            ge.clearRect(0, 0, de.width, de.height), ge.shadowColor = "white", ge.shadowBlur = 2, ge.lineWidth = 1.5, ge.strokeStyle = "white", ge.textBaseline = "top", ge.font = "bold 36px Open Sans, sans-serif", ge.fillText(se, 5, 5), ge.strokeText(se, 5, 5), re.debugOverlayTexture.update(de), re.debugOverlayTexture.bind(ue.LINEAR, ue.CLAMP_TO_EDGE)
          })(h, `${Q} ${z}kB`);
          const J = h.transform.getProjectionData({
            overscaledTileID: n,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0
          });
          d.draw(s, u.TRIANGLES, m, y, Si.alphaBlended, wr.disabled, ms(o.bf.transparent, U), null, J, P, h.debugBuffer, h.quadTriangleIndexBuffer, h.debugSegments), d.draw(s, u.LINE_STRIP, m, y, b, wr.disabled, ms(o.bf.red), M, J, P, h.debugBuffer, h.tileBorderIndexBuffer, h.debugSegments)
        }

        function vl(h, e, n, s) {
          const {
            isRenderingGlobe: u
          } = s, d = h.context, m = d.gl, y = h.transform, b = h.colorModeForRenderPass(), P = h.getDepthModeFor3D(), M = h.useProgram("terrain");
          d.bindFramebuffer.set(null), d.viewport.set([0, 0, h.width, h.height]);
          for (const L of n) {
            const z = e.getTerrainMesh(L.tileID),
              B = h.renderToTexture.getTexture(L),
              U = e.getTerrainData(L.tileID);
            d.activeTexture.set(m.TEXTURE0), m.bindTexture(m.TEXTURE_2D, B.texture);
            const Q = e.getMeshFrameDelta(y.zoom),
              J = y.calculateFogMatrix(L.tileID.toUnwrapped()),
              re = rl(Q, J, h.style.sky, y.pitch, u),
              se = y.getProjectionData({
                overscaledTileID: L.tileID,
                applyTerrainMatrix: !1,
                applyGlobeMatrix: !0
              });
            M.draw(d, m.TRIANGLES, P, di.disabled, b, wr.backCCW, re, U, se, "terrain", z.vertexBuffer, z.indexBuffer, z.segments)
          }
        }

        function ko(h, e) {
          if (!e.mesh) {
            const n = new o.aL;
            n.emplaceBack(-1, -1), n.emplaceBack(1, -1), n.emplaceBack(1, 1), n.emplaceBack(-1, 1);
            const s = new o.aN;
            s.emplaceBack(0, 1, 2), s.emplaceBack(0, 2, 3), e.mesh = new Bi(h.createVertexBuffer(n, hi.members), h.createIndexBuffer(s), o.aM.simpleSegment(0, 0, n.length, s.length))
          }
          return e.mesh
        }
        class Oh {
          constructor(e, n) {
            this.context = new zh(e), this.transform = n, this._tileTextures = {}, this.terrainFacilitator = {
              dirty: !0,
              matrix: o.ag(new Float64Array(16)),
              renderTime: 0
            }, this.setup(), this.numSublayers = Ht.maxUnderzooming + Ht.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new gi
          }
          resize(e, n, s) {
            if (this.width = Math.floor(e * s), this.height = Math.floor(n * s), this.pixelRatio = s, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const u of this.style._order) this.style._layers[u].resize()
          }
          setup() {
            const e = this.context,
              n = new o.aL;
            n.emplaceBack(0, 0), n.emplaceBack(o.$, 0), n.emplaceBack(0, o.$), n.emplaceBack(o.$, o.$), this.tileExtentBuffer = e.createVertexBuffer(n, hi.members), this.tileExtentSegments = o.aM.simpleSegment(0, 0, 4, 2);
            const s = new o.aL;
            s.emplaceBack(0, 0), s.emplaceBack(o.$, 0), s.emplaceBack(0, o.$), s.emplaceBack(o.$, o.$), this.debugBuffer = e.createVertexBuffer(s, hi.members), this.debugSegments = o.aM.simpleSegment(0, 0, 4, 5);
            const u = new o.c6;
            u.emplaceBack(0, 0, 0, 0), u.emplaceBack(o.$, 0, o.$, 0), u.emplaceBack(0, o.$, 0, o.$), u.emplaceBack(o.$, o.$, o.$, o.$), this.rasterBoundsBuffer = e.createVertexBuffer(u, Wd.members), this.rasterBoundsSegments = o.aM.simpleSegment(0, 0, 4, 2);
            const d = new o.aL;
            d.emplaceBack(0, 0), d.emplaceBack(o.$, 0), d.emplaceBack(0, o.$), d.emplaceBack(o.$, o.$), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(d, hi.members), this.rasterBoundsSegmentsPosOnly = o.aM.simpleSegment(0, 0, 4, 5);
            const m = new o.aL;
            m.emplaceBack(0, 0), m.emplaceBack(1, 0), m.emplaceBack(0, 1), m.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(m, hi.members), this.viewportSegments = o.aM.simpleSegment(0, 0, 4, 2);
            const y = new o.c7;
            y.emplaceBack(0), y.emplaceBack(1), y.emplaceBack(3), y.emplaceBack(2), y.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(y);
            const b = new o.aN;
            b.emplaceBack(1, 0, 2), b.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(b);
            const P = this.context.gl;
            this.stencilClearMode = new di({
              func: P.ALWAYS,
              mask: 0
            }, 0, 255, P.ZERO, P.ZERO, P.ZERO), this.tileExtentMesh = new Bi(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments)
          }
          clearStencil() {
            const e = this.context,
              n = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const s = o.L();
            o.bY(s, 0, this.width, this.height, 0, 0, 1), o.N(s, s, [n.drawingBufferWidth, n.drawingBufferHeight, 0]);
            const u = {
              mainMatrix: s,
              tileMercatorCoords: [0, 0, 1, 1],
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: s
            };
            this.useProgram("clippingMask", null, !0).draw(e, n.TRIANGLES, Ur.disabled, this.stencilClearMode, Si.disabled, wr.disabled, null, null, u, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
          }
          _renderTileClippingMasks(e, n, s) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !n || !n.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + n.length > 256 && this.clearStencil();
            const u = this.context;
            u.setColorMode(Si.disabled), u.setDepthMode(Ur.disabled);
            const d = {};
            for (const m of n) d[m.key] = this.nextStencilID++;
            this._renderTileMasks(d, n, s, !0), this._renderTileMasks(d, n, s, !1), this._tileClippingMaskIDs = d
          }
          _renderTileMasks(e, n, s, u) {
            const d = this.context,
              m = d.gl,
              y = this.style.projection,
              b = this.transform,
              P = this.useProgram("clippingMask");
            for (const M of n) {
              const L = e[M.key],
                z = this.style.map.terrain && this.style.map.terrain.getTerrainData(M),
                B = y.getMeshFromTileID(this.context, M.canonical, u, !0, "stencil"),
                U = b.getProjectionData({
                  overscaledTileID: M,
                  applyGlobeMatrix: !s,
                  applyTerrainMatrix: !0
                });
              P.draw(d, m.TRIANGLES, Ur.disabled, new di({
                func: m.ALWAYS,
                mask: 0
              }, L, 255, m.KEEP, m.KEEP, m.REPLACE), Si.disabled, s ? wr.disabled : wr.backCCW, null, z, U, "$clipping", B.vertexBuffer, B.indexBuffer, B.segments)
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context,
              n = e.gl,
              s = this.style.projection,
              u = this.transform,
              d = this.useProgram("depth"),
              m = this.getDepthModeFor3D(),
              y = ye(u, {
                tileSize: u.tileSize
              });
            for (const b of y) {
              const P = this.style.map.terrain && this.style.map.terrain.getTerrainData(b),
                M = s.getMeshFromTileID(this.context, b.canonical, !0, !0, "raster"),
                L = u.getProjectionData({
                  overscaledTileID: b,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0
                });
              d.draw(e, n.TRIANGLES, m, di.disabled, Si.disabled, wr.backCCW, null, P, L, "$clipping", M.vertexBuffer, M.indexBuffer, M.segments)
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++,
              n = this.context.gl;
            return new di({
              func: n.NOTEQUAL,
              mask: 255
            }, e, 255, n.KEEP, n.KEEP, n.REPLACE)
          }
          stencilModeForClipping(e) {
            const n = this.context.gl;
            return new di({
              func: n.EQUAL,
              mask: 255
            }, this._tileClippingMaskIDs[e.key], 0, n.KEEP, n.KEEP, n.REPLACE)
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const n = this.context.gl,
              s = e.sort(((m, y) => y.overscaledZ - m.overscaledZ)),
              u = s[s.length - 1].overscaledZ,
              d = s[0].overscaledZ - u + 1;
            if (d > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + d > 256 && this.clearStencil();
              const m = {};
              for (let y = 0; y < d; y++) m[y + u] = new di({
                func: n.GEQUAL,
                mask: 255
              }, y + this.nextStencilID, 255, n.KEEP, n.KEEP, n.REPLACE);
              return this.nextStencilID += d, [m, s]
            }
            return [{
              [u]: di.disabled
            }, s]
          }
          stencilConfigForOverlapTwoPass(e) {
            const n = this.context.gl,
              s = e.sort(((m, y) => y.overscaledZ - m.overscaledZ)),
              u = s[s.length - 1].overscaledZ,
              d = s[0].overscaledZ - u + 1;
            if (this.clearStencil(), d > 1) {
              const m = {},
                y = {};
              for (let b = 0; b < d; b++) m[b + u] = new di({
                func: n.GREATER,
                mask: 255
              }, d + 1 + b, 255, n.KEEP, n.KEEP, n.REPLACE), y[b + u] = new di({
                func: n.GREATER,
                mask: 255
              }, 1 + b, 255, n.KEEP, n.KEEP, n.REPLACE);
              return this.nextStencilID = 2 * d + 1, [m, y, s]
            }
            return this.nextStencilID = 3, [{
              [u]: new di({
                func: n.GREATER,
                mask: 255
              }, 2, 255, n.KEEP, n.KEEP, n.REPLACE)
            }, {
              [u]: new di({
                func: n.GREATER,
                mask: 255
              }, 1, 255, n.KEEP, n.KEEP, n.REPLACE)
            }, s]
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new Si([e.CONSTANT_COLOR, e.ONE], new o.bf(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Si.unblended : Si.alphaBlended
          }
          getDepthModeForSublayer(e, n, s) {
            if (!this.opaquePassEnabledForLayer()) return Ur.disabled;
            const u = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new Ur(s || this.context.gl.LEQUAL, n, [u, u])
          }
          getDepthModeFor3D() {
            return new Ur(this.context.gl.LEQUAL, Ur.ReadWrite, this.depthRangeFor3D)
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff
          }
          render(e, n) {
            var s, u;
            this.style = e, this.options = n, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(xe.now()), this.imageManager.beginFrame();
            const d = this.style._order,
              m = this.style.sourceCaches,
              y = {},
              b = {},
              P = {},
              M = {
                isRenderingToTexture: !1,
                isRenderingGlobe: ((s = e.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0
              };
            for (const z in m) {
              const B = m[z];
              B.used && B.prepare(this.context), y[z] = B.getVisibleCoordinates(!1), b[z] = y[z].slice().reverse(), P[z] = B.getVisibleCoordinates(!0).reverse()
            }
            this.opaquePassCutoff = 1 / 0;
            for (let z = 0; z < d.length; z++)
              if (this.style._layers[d[z]].is3D()) {
                this.opaquePassCutoff = z;
                break
              } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const z of d) {
              const B = this.style._layers[z];
              if (!B.hasOffscreenPass() || B.isHidden(this.transform.zoom)) continue;
              const U = b[B.source];
              (B.type === "custom" || U.length) && this.renderLayer(this, m[B.source], B, U, M)
            }
            if ((u = this.style.projection) === null || u === void 0 || u.updateGPUdependent({
                context: this.context,
                useProgram: z => this.useProgram(z)
              }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({
                color: n.showOverdrawInspector ? o.bf.black : o.bf.transparent,
                depth: 1
              }), this.clearStencil(), this.style.sky && (function(z, B) {
                const U = z.context,
                  Q = U.gl,
                  J = ((we, he, ze) => {
                    const He = Math.cos(he.rollInRadians),
                      Ne = Math.sin(he.rollInRadians),
                      qe = oe(he),
                      Ge = he.getProjectionData({
                        overscaledTileID: null,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                      }).projectionTransition;
                    return {
                      u_sky_color: we.properties.get("sky-color"),
                      u_horizon_color: we.properties.get("horizon-color"),
                      u_horizon: [(he.width / 2 - qe * Ne) * ze, (he.height / 2 + qe * He) * ze],
                      u_horizon_normal: [-Ne, He],
                      u_sky_horizon_blend: we.properties.get("sky-horizon-blend") * he.height / 2 * ze,
                      u_sky_blend: Ge
                    }
                  })(B, z.style.map.transform, z.pixelRatio),
                  re = new Ur(Q.LEQUAL, Ur.ReadWrite, [0, 1]),
                  se = di.disabled,
                  de = z.colorModeForRenderPass(),
                  ue = z.useProgram("sky"),
                  ge = ko(U, B);
                ue.draw(U, Q.TRIANGLES, re, se, de, wr.disabled, J, null, void 0, "sky", ge.vertexBuffer, ge.indexBuffer, ge.segments)
              })(this, this.style.sky), this._showOverdrawInspector = n.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = d.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const z = this.style._layers[d[this.currentLayer]],
                  B = m[z.source],
                  U = y[z.source];
                this._renderTileClippingMasks(z, U, !1), this.renderLayer(this, B, z, U, M)
              }
            this.renderPass = "translucent";
            let L = !1;
            for (this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {
              const z = this.style._layers[d[this.currentLayer]],
                B = m[z.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(z, M)) continue;
              this.opaquePassEnabledForLayer() || L || (L = !0, M.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const U = (z.type === "symbol" ? P : b)[z.source];
              this._renderTileClippingMasks(z, y[z.source], !!this.renderToTexture), this.renderLayer(this, B, z, U, M)
            }
            if (M.isRenderingGlobe && (function(z, B, U) {
                const Q = z.context,
                  J = Q.gl,
                  re = z.useProgram("atmosphere"),
                  se = new Ur(J.LEQUAL, Ur.ReadOnly, [0, 1]),
                  de = z.transform,
                  ue = (function(Ge, Dt) {
                    const Ft = Ge.properties.get("position"),
                      vt = [-Ft.x, -Ft.y, -Ft.z],
                      sr = o.ag(new Float64Array(16));
                    return Ge.properties.get("anchor") === "map" && (o.b6(sr, sr, Dt.rollInRadians), o.b7(sr, sr, -Dt.pitchInRadians), o.b6(sr, sr, Dt.bearingInRadians), o.b7(sr, sr, Dt.center.lat * Math.PI / 180), o.bz(sr, sr, -Dt.center.lng * Math.PI / 180)), o.c5(vt, vt, sr), vt
                  })(U, z.transform),
                  ge = de.getProjectionData({
                    overscaledTileID: null,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0
                  }),
                  we = B.properties.get("atmosphere-blend") * ge.projectionTransition;
                if (we === 0) return;
                const he = Bs(de.worldSize, de.center.lat),
                  ze = de.inverseProjectionMatrix,
                  He = new Float64Array(4);
                He[3] = 1, o.aw(He, He, de.modelViewProjectionMatrix), He[0] /= He[3], He[1] /= He[3], He[2] /= He[3], He[3] = 1, o.aw(He, He, ze), He[0] /= He[3], He[1] /= He[3], He[2] /= He[3], He[3] = 1;
                const Ne = ((Ge, Dt, Ft, vt, sr) => ({
                    u_sun_pos: Ge,
                    u_atmosphere_blend: Dt,
                    u_globe_position: Ft,
                    u_globe_radius: vt,
                    u_inv_proj_matrix: sr
                  }))(ue, we, [He[0], He[1], He[2]], he, ze),
                  qe = ko(Q, B);
                re.draw(Q, J.TRIANGLES, se, di.disabled, Si.alphaBlended, wr.disabled, Ne, null, null, "atmosphere", qe.vertexBuffer, qe.indexBuffer, qe.segments)
              })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const z = (function(B, U) {
                let Q = null;
                const J = Object.values(B._layers).flatMap((ue => ue.source && !ue.isHidden(U) ? [B.sourceCaches[ue.source]] : [])),
                  re = J.filter((ue => ue.getSource().type === "vector")),
                  se = J.filter((ue => ue.getSource().type !== "vector")),
                  de = ue => {
                    (!Q || Q.getSource().maxzoom < ue.getSource().maxzoom) && (Q = ue)
                  };
                return re.forEach((ue => de(ue))), Q || se.forEach((ue => de(ue))), Q
              })(this.style, this.transform.zoom);
              z && (function(B, U, Q) {
                for (let J = 0; J < Q.length; J++) ua(B, U, Q[J])
              })(this, z, z.getVisibleCoordinates())
            }
            this.options.showPadding && (function(z) {
              const B = z.transform.padding;
              Oc(z, z.transform.height - (B.top || 0), 3, Bh), Oc(z, B.bottom || 0, 3, Fh), Zi(z, B.left || 0, 3, gl), Zi(z, z.transform.width - (B.right || 0), 3, Fc);
              const U = z.transform.centerPoint;
              (function(Q, J, re, se) {
                Fa(Q, J - 1, re - 10, 2, 20, se), Fa(Q, J - 10, re - 1, 20, 2, se)
              })(z, U.x, z.transform.height - U.y, up)
            })(this), this.context.setDefault()
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const n = this.terrainFacilitator.matrix,
              s = this.transform.modelViewProjectionMatrix;
            let u = this.terrainFacilitator.dirty;
            u || (u = e ? !o.c8(n, s) : !o.c9(n, s)), u || (u = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), u && (o.ca(n, s), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(d, m) {
              const y = d.context,
                b = y.gl,
                P = d.transform,
                M = Si.unblended,
                L = new Ur(b.LEQUAL, Ur.ReadWrite, [0, 1]),
                z = m.sourceCache.getRenderableTiles(),
                B = d.useProgram("terrainDepth");
              y.bindFramebuffer.set(m.getFramebuffer("depth").framebuffer), y.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]), y.clear({
                color: o.bf.transparent,
                depth: 1
              });
              for (const U of z) {
                const Q = m.getTerrainMesh(U.tileID),
                  J = m.getTerrainData(U.tileID),
                  re = P.getProjectionData({
                    overscaledTileID: U.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  }),
                  se = {
                    u_ele_delta: m.getMeshFrameDelta(P.zoom)
                  };
                B.draw(y, b.TRIANGLES, L, di.disabled, M, wr.backCCW, se, J, re, "terrain", Q.vertexBuffer, Q.indexBuffer, Q.segments)
              }
              y.bindFramebuffer.set(null), y.viewport.set([0, 0, d.width, d.height])
            })(this, this.style.map.terrain), (function(d, m) {
              const y = d.context,
                b = y.gl,
                P = d.transform,
                M = Si.unblended,
                L = new Ur(b.LEQUAL, Ur.ReadWrite, [0, 1]),
                z = m.getCoordsTexture(),
                B = m.sourceCache.getRenderableTiles(),
                U = d.useProgram("terrainCoords");
              y.bindFramebuffer.set(m.getFramebuffer("coords").framebuffer), y.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]), y.clear({
                color: o.bf.transparent,
                depth: 1
              }), m.coordsIndex = [];
              for (const Q of B) {
                const J = m.getTerrainMesh(Q.tileID),
                  re = m.getTerrainData(Q.tileID);
                y.activeTexture.set(b.TEXTURE0), b.bindTexture(b.TEXTURE_2D, z.texture);
                const se = {
                    u_terrain_coords_id: (255 - m.coordsIndex.length) / 255,
                    u_texture: 0,
                    u_ele_delta: m.getMeshFrameDelta(P.zoom)
                  },
                  de = P.getProjectionData({
                    overscaledTileID: Q.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  });
                U.draw(y, b.TRIANGLES, L, di.disabled, M, wr.backCCW, se, re, de, "terrain", J.vertexBuffer, J.indexBuffer, J.segments), m.coordsIndex.push(Q.tileID.key)
              }
              y.bindFramebuffer.set(null), y.viewport.set([0, 0, d.width, d.height])
            })(this, this.style.map.terrain))
          }
          renderLayer(e, n, s, u, d) {
            s.isHidden(this.transform.zoom) || (s.type === "background" || s.type === "custom" || (u || []).length) && (this.id = s.id, o.cb(s) ? (function(m, y, b, P, M, L) {
              if (m.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: z
              } = L, B = di.disabled, U = m.colorModeForRenderPass();
              (b._unevaluatedLayout.hasValue("text-variable-anchor") || b._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(Q, J, re, se, de, ue, ge, we, he) {
                const ze = J.transform,
                  He = J.style.map.terrain,
                  Ne = de === "map",
                  qe = ue === "map";
                for (const Ge of Q) {
                  const Dt = se.getTile(Ge),
                    Ft = Dt.getBucket(re);
                  if (!Ft || !Ft.text || !Ft.text.segments.get().length) continue;
                  const vt = o.an(Ft.textSizeData, ze.zoom),
                    sr = o.aC(Dt, 1, J.transform.zoom),
                    Kr = Gr(Ne, J.transform, sr),
                    wi = re.layout.get("icon-text-fit") !== "none" && Ft.hasIconData();
                  if (vt) {
                    const ki = Math.pow(2, ze.zoom - Dt.tileID.overscaledZ),
                      Ii = He ? (qi, $i) => He.getElevation(Ge, qi, $i) : null;
                    zc(Ft, Ne, qe, he, ze, Kr, ki, vt, wi, o.aD(ze, Dt, ge, we), Ge.toUnwrapped(), Ii)
                  }
                }
              })(P, m, b, y, b.layout.get("text-rotation-alignment"), b.layout.get("text-pitch-alignment"), b.paint.get("text-translate"), b.paint.get("text-translate-anchor"), M), b.paint.get("icon-opacity").constantOr(1) !== 0 && So(m, y, b, P, !1, b.paint.get("icon-translate"), b.paint.get("icon-translate-anchor"), b.layout.get("icon-rotation-alignment"), b.layout.get("icon-pitch-alignment"), b.layout.get("icon-keep-upright"), B, U, z), b.paint.get("text-opacity").constantOr(1) !== 0 && So(m, y, b, P, !0, b.paint.get("text-translate"), b.paint.get("text-translate-anchor"), b.layout.get("text-rotation-alignment"), b.layout.get("text-pitch-alignment"), b.layout.get("text-keep-upright"), B, U, z), y.map.showCollisionBoxes && (Lh(m, y, b, P, !0), Lh(m, y, b, P, !1))
            })(e, n, s, u, this.style.placement.variableOffsets, d) : o.cc(s) ? (function(m, y, b, P, M) {
              if (m.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: L
              } = M, z = b.paint.get("circle-opacity"), B = b.paint.get("circle-stroke-width"), U = b.paint.get("circle-stroke-opacity"), Q = !b.layout.get("circle-sort-key").isConstant();
              if (z.constantOr(1) === 0 && (B.constantOr(1) === 0 || U.constantOr(1) === 0)) return;
              const J = m.context,
                re = J.gl,
                se = m.transform,
                de = m.getDepthModeForSublayer(0, Ur.ReadOnly),
                ue = di.disabled,
                ge = m.colorModeForRenderPass(),
                we = [],
                he = se.getCircleRadiusCorrection();
              for (let ze = 0; ze < P.length; ze++) {
                const He = P[ze],
                  Ne = y.getTile(He),
                  qe = Ne.getBucket(b);
                if (!qe) continue;
                const Ge = b.paint.get("circle-translate"),
                  Dt = b.paint.get("circle-translate-anchor"),
                  Ft = o.aD(se, Ne, Ge, Dt),
                  vt = qe.programConfigurations.get(b.id),
                  sr = m.useProgram("circle", vt),
                  Kr = qe.layoutVertexBuffer,
                  wi = qe.indexBuffer,
                  ki = m.style.map.terrain && m.style.map.terrain.getTerrainData(He),
                  Ii = {
                    programConfiguration: vt,
                    program: sr,
                    layoutVertexBuffer: Kr,
                    indexBuffer: wi,
                    uniformValues: Yd(m, Ne, b, Ft, he),
                    terrainData: ki,
                    projectionData: se.getProjectionData({
                      overscaledTileID: He,
                      applyGlobeMatrix: !L,
                      applyTerrainMatrix: !0
                    })
                  };
                if (Q) {
                  const qi = qe.segments.get();
                  for (const $i of qi) we.push({
                    segments: new o.aM([$i]),
                    sortKey: $i.sortKey,
                    state: Ii
                  })
                } else we.push({
                  segments: qe.segments,
                  sortKey: 0,
                  state: Ii
                })
              }
              Q && we.sort(((ze, He) => ze.sortKey - He.sortKey));
              for (const ze of we) {
                const {
                  programConfiguration: He,
                  program: Ne,
                  layoutVertexBuffer: qe,
                  indexBuffer: Ge,
                  uniformValues: Dt,
                  terrainData: Ft,
                  projectionData: vt
                } = ze.state;
                Ne.draw(J, re.TRIANGLES, de, ue, ge, wr.backCCW, Dt, Ft, vt, b.id, qe, Ge, ze.segments, b.paint, m.transform.zoom, He)
              }
            })(e, n, s, u, d) : o.cd(s) ? (function(m, y, b, P, M) {
              if (b.paint.get("heatmap-opacity") === 0) return;
              const L = m.context,
                {
                  isRenderingToTexture: z,
                  isRenderingGlobe: B
                } = M;
              if (m.style.map.terrain) {
                for (const U of P) {
                  const Q = y.getTile(U);
                  y.hasRenderableParent(U) || (m.renderPass === "offscreen" ? Lc(m, Q, b, U, B) : m.renderPass === "translucent" && Rh(m, b, U, z, B))
                }
                L.viewport.set([0, 0, m.width, m.height])
              } else m.renderPass === "offscreen" ? (function(U, Q, J, re) {
                const se = U.context,
                  de = se.gl,
                  ue = U.transform,
                  ge = di.disabled,
                  we = new Si([de.ONE, de.ONE], o.bf.transparent, [!0, !0, !0, !0]);
                (function(he, ze, He) {
                  const Ne = he.gl;
                  he.activeTexture.set(Ne.TEXTURE1), he.viewport.set([0, 0, ze.width / 4, ze.height / 4]);
                  let qe = He.heatmapFbos.get(o.c2);
                  qe ? (Ne.bindTexture(Ne.TEXTURE_2D, qe.colorAttachment.get()), he.bindFramebuffer.set(qe.framebuffer)) : (qe = Io(he, ze.width / 4, ze.height / 4), He.heatmapFbos.set(o.c2, qe))
                })(se, U, J), se.clear({
                  color: o.bf.transparent
                });
                for (let he = 0; he < re.length; he++) {
                  const ze = re[he];
                  if (Q.hasRenderableParent(ze)) continue;
                  const He = Q.getTile(ze),
                    Ne = He.getBucket(J);
                  if (!Ne) continue;
                  const qe = Ne.programConfigurations.get(J.id),
                    Ge = U.useProgram("heatmap", qe),
                    Dt = ue.getProjectionData({
                      overscaledTileID: ze,
                      applyGlobeMatrix: !0,
                      applyTerrainMatrix: !1
                    }),
                    Ft = ue.getCircleRadiusCorrection();
                  Ge.draw(se, de.TRIANGLES, Ur.disabled, ge, we, wr.backCCW, _h(He, ue.zoom, J.paint.get("heatmap-intensity"), Ft), null, Dt, J.id, Ne.layoutVertexBuffer, Ne.indexBuffer, Ne.segments, J.paint, ue.zoom, qe)
                }
                se.viewport.set([0, 0, U.width, U.height])
              })(m, y, b, P) : m.renderPass === "translucent" && (function(U, Q) {
                const J = U.context,
                  re = J.gl;
                J.setColorMode(U.colorModeForRenderPass());
                const se = Q.heatmapFbos.get(o.c2);
                se && (J.activeTexture.set(re.TEXTURE0), re.bindTexture(re.TEXTURE_2D, se.colorAttachment.get()), J.activeTexture.set(re.TEXTURE1), Mo(J, Q).bind(re.LINEAR, re.CLAMP_TO_EDGE), U.useProgram("heatmapTexture").draw(J, re.TRIANGLES, Ur.disabled, di.disabled, U.colorModeForRenderPass(), wr.disabled, yc(U, Q, 0, 1), null, null, Q.id, U.viewportBuffer, U.quadTriangleIndexBuffer, U.viewportSegments, Q.paint, U.transform.zoom))
              })(m, b)
            })(e, n, s, u, d) : o.ce(s) ? (function(m, y, b, P, M) {
              if (m.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: L
              } = M, z = b.paint.get("line-opacity"), B = b.paint.get("line-width");
              if (z.constantOr(1) === 0 || B.constantOr(1) === 0) return;
              const U = m.getDepthModeForSublayer(0, Ur.ReadOnly),
                Q = m.colorModeForRenderPass(),
                J = b.paint.get("line-dasharray"),
                re = b.paint.get("line-pattern"),
                se = re.constantOr(1),
                de = b.paint.get("line-gradient"),
                ue = b.getCrossfadeParameters(),
                ge = se ? "linePattern" : J ? "lineSDF" : de ? "lineGradient" : "line",
                we = m.context,
                he = we.gl,
                ze = m.transform;
              let He = !0;
              for (const Ne of P) {
                const qe = y.getTile(Ne);
                if (se && !qe.patternsLoaded()) continue;
                const Ge = qe.getBucket(b);
                if (!Ge) continue;
                const Dt = Ge.programConfigurations.get(b.id),
                  Ft = m.context.program.get(),
                  vt = m.useProgram(ge, Dt),
                  sr = He || vt.program !== Ft,
                  Kr = m.style.map.terrain && m.style.map.terrain.getTerrainData(Ne),
                  wi = re.constantOr(null);
                if (wi && qe.imageAtlas) {
                  const Xr = qe.imageAtlas,
                    Ei = Xr.patternPositions[wi.to.toString()],
                    nn = Xr.patternPositions[wi.from.toString()];
                  Ei && nn && Dt.setConstantPatternPositions(Ei, nn)
                }
                const ki = ze.getProjectionData({
                    overscaledTileID: Ne,
                    applyGlobeMatrix: !L,
                    applyTerrainMatrix: !0
                  }),
                  Ii = ze.getPixelScale(),
                  qi = se ? xh(m, qe, b, Ii, ue) : J ? _s(m, qe, b, Ii, J, ue) : de ? yh(m, qe, b, Ii, Ge.lineClipsArray.length) : sl(m, qe, b, Ii);
                if (se) we.activeTexture.set(he.TEXTURE0), qe.imageAtlasTexture.bind(he.LINEAR, he.CLAMP_TO_EDGE), Dt.updatePaintBuffers(ue);
                else if (J && (sr || m.lineAtlas.dirty)) we.activeTexture.set(he.TEXTURE0), m.lineAtlas.bind(we);
                else if (de) {
                  const Xr = Ge.gradients[b.id];
                  let Ei = Xr.texture;
                  if (b.gradientVersion !== Xr.version) {
                    let nn = 256;
                    if (b.stepInterpolant) {
                      const dn = y.getSource().maxzoom,
                        xn = Ne.canonical.z === dn ? Math.ceil(1 << m.transform.maxZoom - Ne.canonical.z) : 1;
                      nn = o.ah(o.c3(Ge.maxLineLength / o.$ * 1024 * xn), 256, we.maxTextureSize)
                    }
                    Xr.gradient = o.c4({
                      expression: b.gradientExpression(),
                      evaluationKey: "lineProgress",
                      resolution: nn,
                      image: Xr.gradient || void 0,
                      clips: Ge.lineClipsArray
                    }), Xr.texture ? Xr.texture.update(Xr.gradient) : Xr.texture = new o.T(we, Xr.gradient, he.RGBA), Xr.version = b.gradientVersion, Ei = Xr.texture
                  }
                  we.activeTexture.set(he.TEXTURE0), Ei.bind(b.stepInterpolant ? he.NEAREST : he.LINEAR, he.CLAMP_TO_EDGE)
                }
                const $i = m.stencilModeForClipping(Ne);
                vt.draw(we, he.TRIANGLES, U, $i, Q, wr.disabled, qi, Kr, ki, b.id, Ge.layoutVertexBuffer, Ge.indexBuffer, Ge.segments, b.paint, m.transform.zoom, Dt, Ge.layoutVertexBuffer2), He = !1
              }
            })(e, n, s, u, d) : o.cf(s) ? (function(m, y, b, P, M) {
              const L = b.paint.get("fill-color"),
                z = b.paint.get("fill-opacity");
              if (z.constantOr(1) === 0) return;
              const {
                isRenderingToTexture: B
              } = M, U = m.colorModeForRenderPass(), Q = b.paint.get("fill-pattern"), J = m.opaquePassEnabledForLayer() && !Q.constantOr(1) && L.constantOr(o.bf.transparent).a === 1 && z.constantOr(0) === 1 ? "opaque" : "translucent";
              if (m.renderPass === J) {
                const re = m.getDepthModeForSublayer(1, m.renderPass === "opaque" ? Ur.ReadWrite : Ur.ReadOnly);
                ml(m, y, b, P, re, U, !1, B)
              }
              if (m.renderPass === "translucent" && b.paint.get("fill-antialias")) {
                const re = m.getDepthModeForSublayer(b.getPaintProperty("fill-outline-color") ? 2 : 0, Ur.ReadOnly);
                ml(m, y, b, P, re, U, !0, B)
              }
            })(e, n, s, u, d) : o.cg(s) ? (function(m, y, b, P, M) {
              const L = b.paint.get("fill-extrusion-opacity");
              if (L === 0) return;
              const {
                isRenderingToTexture: z
              } = M;
              if (m.renderPass === "translucent") {
                const B = new Ur(m.context.gl.LEQUAL, Ur.ReadWrite, m.depthRangeFor3D);
                if (L !== 1 || b.paint.get("fill-extrusion-pattern").constantOr(1)) Dc(m, y, b, P, B, di.disabled, Si.disabled, z), Dc(m, y, b, P, B, m.stencilModeFor3D(), m.colorModeForRenderPass(), z);
                else {
                  const U = m.colorModeForRenderPass();
                  Dc(m, y, b, P, B, di.disabled, U, z)
                }
              }
            })(e, n, s, u, d) : o.ch(s) ? (function(m, y, b, P, M) {
              if (m.renderPass !== "offscreen" && m.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: L
              } = M, z = m.context, B = m.style.projection.useSubdivision, U = m.getDepthModeForSublayer(0, Ur.ReadOnly), Q = m.colorModeForRenderPass();
              if (m.renderPass === "offscreen")(function(J, re, se, de, ue, ge, we) {
                const he = J.context,
                  ze = he.gl;
                for (const He of se) {
                  const Ne = re.getTile(He),
                    qe = Ne.dem;
                  if (!qe || !qe.data || !Ne.needsHillshadePrepare) continue;
                  const Ge = qe.dim,
                    Dt = qe.stride,
                    Ft = qe.getPixels();
                  if (he.activeTexture.set(ze.TEXTURE1), he.pixelStoreUnpackPremultiplyAlpha.set(!1), Ne.demTexture = Ne.demTexture || J.getTileTexture(Dt), Ne.demTexture) {
                    const sr = Ne.demTexture;
                    sr.update(Ft, {
                      premultiply: !1
                    }), sr.bind(ze.NEAREST, ze.CLAMP_TO_EDGE)
                  } else Ne.demTexture = new o.T(he, Ft, ze.RGBA, {
                    premultiply: !1
                  }), Ne.demTexture.bind(ze.NEAREST, ze.CLAMP_TO_EDGE);
                  he.activeTexture.set(ze.TEXTURE0);
                  let vt = Ne.fbo;
                  if (!vt) {
                    const sr = new o.T(he, {
                      width: Ge,
                      height: Ge,
                      data: null
                    }, ze.RGBA);
                    sr.bind(ze.LINEAR, ze.CLAMP_TO_EDGE), vt = Ne.fbo = he.createFramebuffer(Ge, Ge, !0, !1), vt.colorAttachment.set(sr.texture)
                  }
                  he.bindFramebuffer.set(vt.framebuffer), he.viewport.set([0, 0, Ge, Ge]), J.useProgram("hillshadePrepare").draw(he, ze.TRIANGLES, ue, ge, we, wr.disabled, gh(Ne.tileID, qe), null, null, de.id, J.rasterBoundsBuffer, J.quadTriangleIndexBuffer, J.rasterBoundsSegments), Ne.needsHillshadePrepare = !1
                }
              })(m, y, P, b, U, di.disabled, Q), z.viewport.set([0, 0, m.width, m.height]);
              else if (m.renderPass === "translucent")
                if (B) {
                  const [J, re, se] = m.stencilConfigForOverlapTwoPass(P);
                  xs(m, y, b, se, J, U, Q, !1, L), xs(m, y, b, se, re, U, Q, !0, L)
                } else {
                  const [J, re] = m.getStencilConfigForOverlapAndUpdateStencilID(P);
                  xs(m, y, b, re, J, U, Q, !1, L)
                }
            })(e, n, s, u, d) : o.ci(s) ? (function(m, y, b, P, M) {
              if (m.renderPass !== "translucent" || !P.length) return;
              const {
                isRenderingToTexture: L
              } = M, z = m.style.projection.useSubdivision, B = m.getDepthModeForSublayer(0, Ur.ReadOnly), U = m.colorModeForRenderPass();
              if (z) {
                const [Q, J, re] = m.stencilConfigForOverlapTwoPass(P);
                Rc(m, y, b, re, Q, B, U, !1, L), Rc(m, y, b, re, J, B, U, !0, L)
              } else {
                const [Q, J] = m.getStencilConfigForOverlapAndUpdateStencilID(P);
                Rc(m, y, b, J, Q, B, U, !1, L)
              }
            })(e, n, s, u, d) : o.cj(s) ? (function(m, y, b, P, M) {
              if (m.renderPass !== "translucent" || b.paint.get("raster-opacity") === 0 || !P.length) return;
              const {
                isRenderingToTexture: L
              } = M, z = y.getSource(), B = m.style.projection.useSubdivision;
              if (z instanceof Bt) bs(m, y, b, P, null, !1, !1, z.tileCoords, z.flippedWindingOrder, L);
              else if (B) {
                const [U, Q, J] = m.stencilConfigForOverlapTwoPass(P);
                bs(m, y, b, J, U, !1, !0, _l, !1, L), bs(m, y, b, J, Q, !0, !0, _l, !1, L)
              } else {
                const [U, Q] = m.getStencilConfigForOverlapAndUpdateStencilID(P);
                bs(m, y, b, Q, U, !1, !0, _l, !1, L)
              }
            })(e, n, s, u, d) : o.ck(s) ? (function(m, y, b, P, M) {
              const L = b.paint.get("background-color"),
                z = b.paint.get("background-opacity");
              if (z === 0) return;
              const {
                isRenderingToTexture: B
              } = M, U = m.context, Q = U.gl, J = m.style.projection, re = m.transform, se = re.tileSize, de = b.paint.get("background-pattern");
              if (m.isPatternMissing(de)) return;
              const ue = !de && L.a === 1 && z === 1 && m.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (m.renderPass !== ue) return;
              const ge = di.disabled,
                we = m.getDepthModeForSublayer(0, ue === "opaque" ? Ur.ReadWrite : Ur.ReadOnly),
                he = m.colorModeForRenderPass(),
                ze = m.useProgram(de ? "backgroundPattern" : "background"),
                He = P || ye(re, {
                  tileSize: se,
                  terrain: m.style.map.terrain
                });
              de && (U.activeTexture.set(Q.TEXTURE0), m.imageManager.bind(m.context));
              const Ne = b.getCrossfadeParameters();
              for (const qe of He) {
                const Ge = re.getProjectionData({
                    overscaledTileID: qe,
                    applyGlobeMatrix: !B,
                    applyTerrainMatrix: !0
                  }),
                  Dt = de ? Th(z, m, de, {
                    tileID: qe,
                    tileSize: se
                  }, Ne) : wh(z, L),
                  Ft = m.style.map.terrain && m.style.map.terrain.getTerrainData(qe),
                  vt = J.getMeshFromTileID(U, qe.canonical, !1, !0, "raster");
                ze.draw(U, Q.TRIANGLES, we, ge, he, wr.backCCW, Dt, Ft, Ge, b.id, vt.vertexBuffer, vt.indexBuffer, vt.segments)
              }
            })(e, 0, s, u, d) : o.cl(s) && (function(m, y, b, P) {
              const {
                isRenderingGlobe: M
              } = P, L = m.context, z = b.implementation, B = m.style.projection, U = m.transform, Q = U.getProjectionDataForCustomLayer(M), J = {
                farZ: U.farZ,
                nearZ: U.nearZ,
                fov: U.fov * Math.PI / 180,
                modelViewProjectionMatrix: U.modelViewProjectionMatrix,
                projectionMatrix: U.projectionMatrix,
                shaderData: {
                  variantName: B.shaderVariantName,
                  vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${B.shaderPreludeCode.vertexSource}`,
                  define: B.shaderDefine
                },
                defaultProjectionData: Q
              }, re = z.renderingMode ? z.renderingMode : "2d";
              if (m.renderPass === "offscreen") {
                const se = z.prerender;
                se && (m.setCustomLayerDefaults(), L.setColorMode(m.colorModeForRenderPass()), se.call(z, L.gl, J), L.setDirty(), m.setBaseState())
              } else if (m.renderPass === "translucent") {
                m.setCustomLayerDefaults(), L.setColorMode(m.colorModeForRenderPass()), L.setStencilMode(di.disabled);
                const se = re === "3d" ? m.getDepthModeFor3D() : m.getDepthModeForSublayer(0, Ur.ReadOnly);
                L.setDepthMode(se), z.render(L.gl, J), L.setDirty(), m.setBaseState(), L.bindFramebuffer.set(null)
              }
            })(e, 0, s, d))
          }
          saveTileTexture(e) {
            const n = this._tileTextures[e.size[0]];
            n ? n.push(e) : this._tileTextures[e.size[0]] = [e]
          }
          getTileTexture(e) {
            const n = this._tileTextures[e];
            return n && n.length > 0 ? n.pop() : null
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const n = this.imageManager.getPattern(e.from.toString()),
              s = this.imageManager.getPattern(e.to.toString());
            return !n || !s
          }
          useProgram(e, n, s = !1, u = []) {
            this.cache = this.cache || {};
            const d = !!this.style.map.terrain,
              m = this.style.projection,
              y = s ? fi.projectionMercator : m.shaderPreludeCode,
              b = s ? Jr : m.shaderDefine,
              P = e + (n ? n.cacheKey : "") + `/${s?ti:m.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (d ? "/terrain" : "") + (u ? `/${u.join("/")}` : "");
            return this.cache[P] || (this.cache[P] = new vc(this.context, fi[e], n, Cc[e], this._showOverdrawInspector, d, y, b, u)), this.cache[P]
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD)
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new o.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA))
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy()
          }
          overLimit() {
            const {
              drawingBufferWidth: e,
              drawingBufferHeight: n
            } = this.context.gl;
            return this.width !== e || this.height !== n
          }
        }

        function ws(h, e) {
          let n, s = !1,
            u = null,
            d = null;
          const m = () => {
            u = null, s && (h.apply(d, n), u = setTimeout(m, e), s = !1)
          };
          return (...y) => (s = !0, d = this, n = y, u || m(), u)
        }
        class yl {
          constructor(e) {
            this._getCurrentHash = () => {
              const n = window.location.hash.replace("#", "");
              if (this._hashName) {
                let s;
                return n.split("&").map((u => u.split("="))).forEach((u => {
                  u[0] === this._hashName && (s = u)
                })), (s && s[1] || "").split("/")
              }
              return n.split("/")
            }, this._onHashChange = () => {
              const n = this._getCurrentHash();
              if (!this._isValidHash(n)) return !1;
              const s = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(n[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({
                center: [+n[2], +n[1]],
                zoom: +n[0],
                bearing: s,
                pitch: +(n[4] || 0)
              }), !0
            }, this._updateHashUnthrottled = () => {
              const n = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, n)
            }, this._removeHash = () => {
              const n = this._getCurrentHash();
              if (n.length === 0) return;
              const s = n.join("/");
              let u = s;
              u.split("&").length > 0 && (u = u.split("&")[0]), this._hashName && (u = `${this._hashName}=${s}`);
              let d = window.location.hash.replace(u, "");
              d.startsWith("#&") ? d = d.slice(0, 1) + d.slice(2) : d === "#" && (d = "");
              let m = window.location.href.replace(/(#.+)?$/, d);
              m = m.replace("&&", "&"), window.history.replaceState(window.history.state, null, m)
            }, this._updateHash = ws(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e)
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this
          }
          getHashString(e) {
            const n = this._map.getCenter(),
              s = Math.round(100 * this._map.getZoom()) / 100,
              u = Math.ceil((s * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
              d = Math.pow(10, u),
              m = Math.round(n.lng * d) / d,
              y = Math.round(n.lat * d) / d,
              b = this._map.getBearing(),
              P = this._map.getPitch();
            let M = "";
            if (M += e ? `/${m}/${y}/${s}` : `${s}/${y}/${m}`, (b || P) && (M += "/" + Math.round(10 * b) / 10), P && (M += `/${Math.round(P)}`), this._hashName) {
              const L = this._hashName;
              let z = !1;
              const B = window.location.hash.slice(1).split("&").map((U => {
                const Q = U.split("=")[0];
                return Q === L ? (z = !0, `${Q}=${M}`) : U
              })).filter((U => U));
              return z || B.push(`${L}=${M}`), `#${B.join("&")}`
            }
            return `#${M}`
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new o.S(+e[2], +e[1])
            } catch {
              return !1
            }
            const n = +e[0],
              s = +(e[3] || 0),
              u = +(e[4] || 0);
            return n >= this._map.getMinZoom() && n <= this._map.getMaxZoom() && s >= -180 && s <= 180 && u >= this._map.getMinPitch() && u <= this._map.getMaxPitch()
          }
        }
        const $a = {
            linearity: .3,
            easing: o.cm(0, 0, .3, 1)
          },
          Nc = o.e({
            deceleration: 2500,
            maxSpeed: 1400
          }, $a),
          Nh = o.e({
            deceleration: 20,
            maxSpeed: 1400
          }, $a),
          jh = o.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, $a),
          qh = o.e({
            deceleration: 1e3,
            maxSpeed: 90
          }, $a),
          Vh = o.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, $a);
        class Uh {
          constructor(e) {
            this._map = e, this.clear()
          }
          clear() {
            this._inertiaBuffer = []
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({
              time: xe.now(),
              settings: e
            })
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer,
              n = xe.now();
            for (; e.length > 0 && n - e[0].time > 160;) e.shift()
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const n = {
              zoom: 0,
              bearing: 0,
              pitch: 0,
              roll: 0,
              pan: new o.P(0, 0),
              pinchAround: void 0,
              around: void 0
            };
            for (const {
                settings: d
              }
              of this._inertiaBuffer) n.zoom += d.zoomDelta || 0, n.bearing += d.bearingDelta || 0, n.pitch += d.pitchDelta || 0, n.roll += d.rollDelta || 0, d.panDelta && n.pan._add(d.panDelta), d.around && (n.around = d.around), d.pinchAround && (n.pinchAround = d.pinchAround);
            const s = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
              u = {};
            if (n.pan.mag()) {
              const d = js(n.pan.mag(), s, o.e({}, Nc, e || {})),
                m = n.pan.mult(d.amount / n.pan.mag()),
                y = this._map.cameraHelper.handlePanInertia(m, this._map.transform);
              u.center = y.easingCenter, u.offset = y.easingOffset, xa(u, d)
            }
            if (n.zoom) {
              const d = js(n.zoom, s, Nh);
              u.zoom = this._map.transform.zoom + d.amount, xa(u, d)
            }
            if (n.bearing) {
              const d = js(n.bearing, s, jh);
              u.bearing = this._map.transform.bearing + o.ah(d.amount, -179, 179), xa(u, d)
            }
            if (n.pitch) {
              const d = js(n.pitch, s, qh);
              u.pitch = this._map.transform.pitch + d.amount, xa(u, d)
            }
            if (n.roll) {
              const d = js(n.roll, s, Vh);
              u.roll = this._map.transform.roll + o.ah(d.amount, -179, 179), xa(u, d)
            }
            if (u.zoom || u.bearing) {
              const d = n.pinchAround === void 0 ? n.around : n.pinchAround;
              u.around = d ? this._map.unproject(d) : this._map.getCenter()
            }
            return this.clear(), o.e(u, {
              noMoveStart: !0
            })
          }
        }

        function xa(h, e) {
          (!h.duration || h.duration < e.duration) && (h.duration = e.duration, h.easing = e.easing)
        }

        function js(h, e, n) {
          const {
            maxSpeed: s,
            linearity: u,
            deceleration: d
          } = n, m = o.ah(h * u / (e / 1e3), -s, s), y = Math.abs(m) / (d * u);
          return {
            easing: n.easing,
            duration: 1e3 * y,
            amount: m * (y / 2)
          }
        }
        class Xn extends o.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, n, s, u = {}) {
            s = s instanceof MouseEvent ? s : new MouseEvent(e, s);
            const d = K.mousePos(n.getCanvas(), s),
              m = n.unproject(d);
            super(e, o.e({
              point: d,
              lngLat: m,
              originalEvent: s
            }, u)), this._defaultPrevented = !1, this.target = n
          }
        }
        class qs extends o.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, n, s) {
            const u = e === "touchend" ? s.changedTouches : s.touches,
              d = K.touchPos(n.getCanvasContainer(), u),
              m = d.map((b => n.unproject(b))),
              y = d.reduce(((b, P, M, L) => b.add(P.div(L.length))), new o.P(0, 0));
            super(e, {
              points: d,
              point: y,
              lngLats: m,
              lngLat: n.unproject(y),
              originalEvent: s
            }), this._defaultPrevented = !1
          }
        }
        class jc extends o.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, n, s) {
            super(e, {
              originalEvent: s
            }), this._defaultPrevented = !1
          }
        }
        class Zh {
          constructor(e, n) {
            this._map = e, this._clickTolerance = n.clickTolerance
          }
          reset() {
            delete this._mousedownPos
          }
          wheel(e) {
            return this._firePreventable(new jc(e.type, this._map, e))
          }
          mousedown(e, n) {
            return this._mousedownPos = n, this._firePreventable(new Xn(e.type, this._map, e))
          }
          mouseup(e) {
            this._map.fire(new Xn(e.type, this._map, e))
          }
          click(e, n) {
            this._mousedownPos && this._mousedownPos.dist(n) >= this._clickTolerance || this._map.fire(new Xn(e.type, this._map, e))
          }
          dblclick(e) {
            return this._firePreventable(new Xn(e.type, this._map, e))
          }
          mouseover(e) {
            this._map.fire(new Xn(e.type, this._map, e))
          }
          mouseout(e) {
            this._map.fire(new Xn(e.type, this._map, e))
          }
          touchstart(e) {
            return this._firePreventable(new qs(e.type, this._map, e))
          }
          touchmove(e) {
            this._map.fire(new qs(e.type, this._map, e))
          }
          touchend(e) {
            this._map.fire(new qs(e.type, this._map, e))
          }
          touchcancel(e) {
            this._map.fire(new qs(e.type, this._map, e))
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {}
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class $h {
          constructor(e) {
            this._map = e
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent
          }
          mousemove(e) {
            this._map.fire(new Xn(e.type, this._map, e))
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Xn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Xn(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault()
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class Vs {
          constructor(e) {
            this._map = e
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat
            }
          }
          get zoom() {
            return this.transform.zoom
          }
          get pitch() {
            return this.transform.pitch
          }
          get bearing() {
            return this.transform.bearing
          }
          unproject(e) {
            return this.transform.screenPointToLocation(o.P.convert(e), this._map.terrain)
          }
        }
        class qc {
          constructor(e, n) {
            this._map = e, this._tr = new Vs(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = n.clickTolerance || 1
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
          enable() {
            this.isEnabled() || (this._enabled = !0)
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          mousedown(e, n) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (K.disableDrag(), this._startPos = this._lastPos = n, this._active = !0)
          }
          mousemoveWindow(e, n) {
            if (!this._active) return;
            const s = n;
            if (this._lastPos.equals(s) || !this._box && s.dist(this._startPos) < this._clickTolerance) return;
            const u = this._startPos;
            this._lastPos = s, this._box || (this._box = K.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const d = Math.min(u.x, s.x),
              m = Math.max(u.x, s.x),
              y = Math.min(u.y, s.y),
              b = Math.max(u.y, s.y);
            K.setTransform(this._box, `translate(${d}px,${y}px)`), this._box.style.width = m - d + "px", this._box.style.height = b - y + "px"
          }
          mouseupWindow(e, n) {
            if (!this._active || e.button !== 0) return;
            const s = this._startPos,
              u = n;
            if (this.reset(), K.suppressClick(), s.x !== u.x || s.y !== u.y) return this._map.fire(new o.l("boxzoomend", {
              originalEvent: e
            })), {
              cameraAnimation: d => d.fitScreenCoordinates(s, u, this._tr.bearing, {
                linear: !0
              })
            };
            this._fireEvent("boxzoomcancel", e)
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e))
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (K.remove(this._box), this._box = null), K.enableDrag(), delete this._startPos, delete this._lastPos
          }
          _fireEvent(e, n) {
            return this._map.fire(new o.l(e, {
              originalEvent: n
            }))
          }
        }

        function Us(h, e) {
          if (h.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${h.length}, points ${e.length}`);
          const n = {};
          for (let s = 0; s < h.length; s++) n[h[s].identifier] = e[s];
          return n
        }
        class Gh {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1
          }
          touchstart(e, n, s) {
            (this.centroid || s.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), s.length === this.numTouches && (this.centroid = (function(u) {
              const d = new o.P(0, 0);
              for (const m of u) d._add(m);
              return d.div(u.length)
            })(n), this.touches = Us(s, n)))
          }
          touchmove(e, n, s) {
            if (this.aborted || !this.centroid) return;
            const u = Us(s, n);
            for (const d in this.touches) {
              const m = u[d];
              (!m || m.dist(this.touches[d]) > 30) && (this.aborted = !0)
            }
          }
          touchend(e, n, s) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), s.length === 0) {
              const u = !this.aborted && this.centroid;
              if (this.reset(), u) return u
            }
          }
        }
        class Kn {
          constructor(e) {
            this.singleTap = new Gh(e), this.numTaps = e.numTaps, this.reset()
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset()
          }
          touchstart(e, n, s) {
            this.singleTap.touchstart(e, n, s)
          }
          touchmove(e, n, s) {
            this.singleTap.touchmove(e, n, s)
          }
          touchend(e, n, s) {
            const u = this.singleTap.touchend(e, n, s);
            if (u) {
              const d = e.timeStamp - this.lastTime < 500,
                m = !this.lastTap || this.lastTap.dist(u) < 30;
              if (d && m || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = u, this.count === this.numTaps) return this.reset(), u
            }
          }
        }
        class ba {
          constructor(e) {
            this._tr = new Vs(e), this._zoomIn = new Kn({
              numTouches: 1,
              numTaps: 2
            }), this._zoomOut = new Kn({
              numTouches: 2,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
          }
          touchstart(e, n, s) {
            this._zoomIn.touchstart(e, n, s), this._zoomOut.touchstart(e, n, s)
          }
          touchmove(e, n, s) {
            this._zoomIn.touchmove(e, n, s), this._zoomOut.touchmove(e, n, s)
          }
          touchend(e, n, s) {
            const u = this._zoomIn.touchend(e, n, s),
              d = this._zoomOut.touchend(e, n, s),
              m = this._tr;
            return u ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: y => y.easeTo({
                duration: 300,
                zoom: m.zoom + 1,
                around: m.unproject(u)
              }, {
                originalEvent: e
              })
            }) : d ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: y => y.easeTo({
                duration: 300,
                zoom: m.zoom - 1,
                around: m.unproject(d)
              }, {
                originalEvent: e
              })
            }) : void 0
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Zs {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset()
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e)
          }
          _move(...e) {
            const n = this._moveFunction(...e);
            if (n.bearingDelta || n.pitchDelta || n.rollDelta || n.around || n.panDelta) return this._active = !0, n
          }
          dragStart(e, n) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(n) ? n[0] : n, this._activateOnStart && this._lastPoint && (this._active = !0))
          }
          dragMove(e, n) {
            if (!this.isEnabled()) return;
            const s = this._lastPoint;
            if (!s) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const u = Array.isArray(n) ? n[0] : n;
            return !this._moved && u.dist(s) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = u, this._move(s, u))
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && K.suppressClick(), this.reset(e))
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          getClickTolerance() {
            return this._clickTolerance
          }
        }
        const wa = 0,
          $s = 2,
          hp = {
            [wa]: 1,
            [$s]: 2
          };
        class Eo {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent
          }
          startMove(e) {
            const n = K.mouseButton(e);
            this._eventButton = n
          }
          endMove(e) {
            delete this._eventButton
          }
          isValidStartEvent(e) {
            return this._correctEvent(e)
          }
          isValidMoveEvent(e) {
            return !(function(n, s) {
              const u = hp[s];
              return n.buttons === void 0 || (n.buttons & u) !== u
            })(e, this._eventButton)
          }
          isValidEndEvent(e) {
            return K.mouseButton(e) === this._eventButton
          }
        }
        class dp {
          constructor() {
            this._firstTouch = void 0
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier
          }
          endMove(e) {
            delete this._firstTouch
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e)
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
        }
        class pp {
          constructor(e = new Eo({
            checkCorrectEvent: () => !0
          }), n = new dp) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = n
          }
          _executeRelevantHandler(e, n, s) {
            return e instanceof MouseEvent ? n(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? s(e) : void 0
          }
          startMove(e) {
            this._executeRelevantHandler(e, (n => this.mouseMoveStateManager.startMove(n)), (n => this.oneFingerTouchMoveStateManager.startMove(n)))
          }
          endMove(e) {
            this._executeRelevantHandler(e, (n => this.mouseMoveStateManager.endMove(n)), (n => this.oneFingerTouchMoveStateManager.endMove(n)))
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, (n => this.mouseMoveStateManager.isValidStartEvent(n)), (n => this.oneFingerTouchMoveStateManager.isValidStartEvent(n)))
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, (n => this.mouseMoveStateManager.isValidMoveEvent(n)), (n => this.oneFingerTouchMoveStateManager.isValidMoveEvent(n)))
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, (n => this.mouseMoveStateManager.isValidEndEvent(n)), (n => this.oneFingerTouchMoveStateManager.isValidEndEvent(n)))
          }
        }
        const zo = h => {
          h.mousedown = h.dragStart, h.mousemoveWindow = h.dragMove, h.mouseup = h.dragEnd, h.contextmenu = e => {
            e.preventDefault()
          }
        };
        class Lo {
          constructor(e, n) {
            this._clickTolerance = e.clickTolerance || 1, this._map = n, this.reset()
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new o.P(0, 0)
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
          }
          touchstart(e, n, s) {
            return this._calculateTransform(e, n, s)
          }
          touchmove(e, n, s) {
            if (this._active) {
              if (!this._shouldBePrevented(s.length)) return e.preventDefault(), this._calculateTransform(e, n, s);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
            }
          }
          touchend(e, n, s) {
            this._calculateTransform(e, n, s), this._active && this._shouldBePrevented(s.length) && this.reset()
          }
          touchcancel() {
            this.reset()
          }
          _calculateTransform(e, n, s) {
            s.length > 0 && (this._active = !0);
            const u = Us(s, n),
              d = new o.P(0, 0),
              m = new o.P(0, 0);
            let y = 0;
            for (const P in u) {
              const M = u[P],
                L = this._touches[P];
              L && (d._add(M), m._add(M.sub(L)), y++, u[P] = M)
            }
            if (this._touches = u, this._shouldBePrevented(y) || !m.mag()) return;
            const b = m.div(y);
            return this._sum._add(b), this._sum.mag() < this._clickTolerance ? void 0 : {
              around: d.div(y),
              panDelta: b
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Ta {
          constructor() {
            this.reset()
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches
          }
          touchstart(e, n, s) {
            this._firstTwoTouches || s.length < 2 || (this._firstTwoTouches = [s[0].identifier, s[1].identifier], this._start([n[0], n[1]]))
          }
          touchmove(e, n, s) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [u, d] = this._firstTwoTouches, m = Wt(s, n, u), y = Wt(s, n, d);
            if (!m || !y) return;
            const b = this._aroundCenter ? null : m.add(y).div(2);
            return this._move([m, y], b, e)
          }
          touchend(e, n, s) {
            if (!this._firstTwoTouches) return;
            const [u, d] = this._firstTwoTouches, m = Wt(s, n, u), y = Wt(s, n, d);
            m && y || (this._active && K.suppressClick(), this.reset())
          }
          touchcancel() {
            this.reset()
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center"
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
        }

        function Wt(h, e, n) {
          for (let s = 0; s < h.length; s++)
            if (h[s].identifier === n) return e[s]
        }

        function Vc(h, e) {
          return Math.log(h / e) / Math.LN2
        }
        class xl extends Ta {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1])
          }
          _move(e, n) {
            const s = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Vc(this._distance, this._startDistance)) < .1)) return this._active = !0, {
              zoomDelta: Vc(this._distance, s),
              pinchAround: n
            }
          }
        }

        function Uc(h, e) {
          return 180 * h.angleWith(e) / Math.PI
        }
        class Gs extends Ta {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1])
          }
          _move(e, n, s) {
            const u = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
              bearingDelta: Uc(this._vector, u),
              pinchAround: n
            }
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const n = 25 / (Math.PI * this._minDiameter) * 360,
              s = Uc(e, this._startVector);
            return Math.abs(s) < n
          }
        }

        function Ts(h) {
          return Math.abs(h.y) > Math.abs(h.x)
        }
        class bl extends Ta {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints
          }
          touchstart(e, n, s) {
            super.touchstart(e, n, s), this._currentTouchCount = s.length
          }
          _start(e) {
            this._lastPoints = e, Ts(e[0].sub(e[1])) && (this._valid = !1)
          }
          _move(e, n, s) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const u = e[0].sub(this._lastPoints[0]),
              d = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(u, d, s.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, {
              pitchDelta: (u.y + d.y) / 2 * -.5
            }) : void 0
          }
          gestureBeginsVertically(e, n, s) {
            if (this._valid !== void 0) return this._valid;
            const u = e.mag() >= 2,
              d = n.mag() >= 2;
            if (!u && !d) return;
            if (!u || !d) return this._firstMove === void 0 && (this._firstMove = s), s - this._firstMove < 100 && void 0;
            const m = e.y > 0 == n.y > 0;
            return Ts(e) && Ts(n) && m
          }
        }
        const si = {
          panStep: 100,
          bearingStep: 15,
          pitchStep: 10
        };
        class wl {
          constructor(e) {
            this._tr = new Vs(e);
            const n = si;
            this._panStep = n.panStep, this._bearingStep = n.bearingStep, this._pitchStep = n.pitchStep, this._rotationDisabled = !1
          }
          reset() {
            this._active = !1
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let n = 0,
              s = 0,
              u = 0,
              d = 0,
              m = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                n = 1;
                break;
              case 189:
              case 109:
              case 173:
                n = -1;
                break;
              case 37:
                e.shiftKey ? s = -1 : (e.preventDefault(), d = -1);
                break;
              case 39:
                e.shiftKey ? s = 1 : (e.preventDefault(), d = 1);
                break;
              case 38:
                e.shiftKey ? u = 1 : (e.preventDefault(), m = -1);
                break;
              case 40:
                e.shiftKey ? u = -1 : (e.preventDefault(), m = 1);
                break;
              default:
                return
            }
            return this._rotationDisabled && (s = 0, u = 0), {
              cameraAnimation: y => {
                const b = this._tr;
                y.easeTo({
                  duration: 300,
                  easeId: "keyboardHandler",
                  easing: fp,
                  zoom: n ? Math.round(b.zoom) + n * (e.shiftKey ? 2 : 1) : b.zoom,
                  bearing: b.bearing + s * this._bearingStep,
                  pitch: b.pitch + u * this._pitchStep,
                  offset: [-d * this._panStep, -m * this._panStep],
                  center: b.center
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          disableRotation() {
            this._rotationDisabled = !0
          }
          enableRotation() {
            this._rotationDisabled = !1
          }
        }

        function fp(h) {
          return h * (2 - h)
        }
        const Tl = 4.000244140625,
          mp = 1 / 450;
        class Hh {
          constructor(e, n) {
            this._onTimeout = s => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(s)
            }, this._map = e, this._tr = new Vs(e), this._triggerRenderFrame = n, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = mp
          }
          setZoomRate(e) {
            this._defaultZoomRate = e
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0
          }
          isZooming() {
            return !!this._zooming
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center")
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let n = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const s = xe.now(),
              u = s - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = s, n !== 0 && n % Tl == 0 ? this._type = "wheel" : n !== 0 && Math.abs(n) < 4 ? this._type = "trackpad" : u > 400 ? (this._type = null, this._lastValue = n, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(u * n) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, n += this._lastValue)), e.shiftKey && n && (n /= 4), this._type && (this._lastWheelEvent = e, this._delta -= n, this._active || this._start(e)), e.preventDefault()
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const n = K.mousePos(this._map.getCanvas(), e),
              s = this._tr;
            this._aroundPoint = this._aroundCenter ? s.transform.locationToScreenPoint(o.S.convert(s.center)) : n, this._frameId || (this._frameId = !0, this._triggerRenderFrame())
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const y = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += y), typeof this._targetZoom == "number" && (this._targetZoom += y)
            }
            if (this._delta !== 0) {
              const y = this._type === "wheel" && Math.abs(this._delta) > Tl ? this._wheelZoomRate : this._defaultZoomRate;
              let b = 2 / (1 + Math.exp(-Math.abs(this._delta * y)));
              this._delta < 0 && b !== 0 && (b = 1 / b);
              const P = typeof this._targetZoom != "number" ? e.scale : o.af(this._targetZoom);
              this._targetZoom = e.getConstrained(e.getCameraLngLat(), o.ak(P * b)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0
            }
            const n = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom,
              s = this._startZoom,
              u = this._easing;
            let d, m = !1;
            if (this._type === "wheel" && s && u) {
              const y = xe.now() - this._lastWheelEventTime,
                b = Math.min((y + 5) / 200, 1),
                P = u(b);
              d = o.C.number(s, n, P), b < 1 ? this._frameId || (this._frameId = !0) : m = !0
            } else d = n, m = !0;
            return this._active = !0, m && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout
            }), 200)), this._lastExpectedZoom = d, {
              noInertia: !0,
              needsRenderFrame: !m,
              zoomDelta: d - e.zoom,
              around: this._aroundPoint,
              originalEvent: this._lastWheelEvent
            }
          }
          _smoothOutEasing(e) {
            let n = o.co;
            if (this._prevEase) {
              const s = this._prevEase,
                u = (xe.now() - s.start) / s.duration,
                d = s.easing(u + .01) - s.easing(u),
                m = .27 / Math.sqrt(d * d + 1e-4) * .01,
                y = Math.sqrt(.0729 - m * m);
              n = o.cm(m, y, .25, 1)
            }
            return this._prevEase = {
              start: xe.now(),
              duration: e,
              easing: n
            }, n
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout)
          }
        }
        class Zc {
          constructor(e, n) {
            this._clickZoom = e, this._tapZoom = n
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable()
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable()
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive()
          }
        }
        class $c {
          constructor(e) {
            this._tr = new Vs(e), this.reset()
          }
          reset() {
            this._active = !1
          }
          dblclick(e, n) {
            return e.preventDefault(), {
              cameraAnimation: s => {
                s.easeTo({
                  duration: 300,
                  zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                  around: this._tr.unproject(n)
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Wh {
          constructor() {
            this._tap = new Kn({
              numTouches: 1,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset()
          }
          touchstart(e, n, s) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const u = n[0],
                  d = e.timeStamp - this._tapTime < 500,
                  m = this._tapPoint.dist(u) < 30;
                d && m ? s.length > 0 && (this._swipePoint = u, this._swipeTouch = s[0].identifier) : this.reset()
              } else this._tap.touchstart(e, n, s)
          }
          touchmove(e, n, s) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (s[0].identifier !== this._swipeTouch) return;
                const u = n[0],
                  d = u.y - this._swipePoint.y;
                return this._swipePoint = u, e.preventDefault(), this._active = !0, {
                  zoomDelta: d / 128
                }
              }
            } else this._tap.touchmove(e, n, s)
          }
          touchend(e, n, s) {
            if (this._tapTime) this._swipePoint && s.length === 0 && this.reset();
            else {
              const u = this._tap.touchend(e, n, s);
              u && (this._tapTime = e.timeStamp, this._tapPoint = u)
            }
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Xh {
          constructor(e, n, s) {
            this._el = e, this._mousePan = n, this._touchPan = s
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan")
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan")
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled()
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive()
          }
        }
        class Gc {
          constructor(e, n, s, u) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = n, this._mousePitch = s, this._mouseRoll = u
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable()
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable()
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
          }
        }
        class Kh {
          constructor(e, n, s, u) {
            this._el = e, this._touchZoom = n, this._touchRotate = s, this._tapDragZoom = u, this._rotationDisabled = !1, this._enabled = !0
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate")
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate")
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable()
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
          }
        }
        class Yh {
          constructor(e, n) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = n, this._enabled = !1
          }
          isActive() {
            return !1
          }
          reset() {}
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = K.create("div", "maplibregl-cooperative-gesture-screen", e);
            let n = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (n = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const s = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"),
              u = document.createElement("div");
            u.className = "maplibregl-desktop-message", u.textContent = n, this._container.appendChild(u);
            const d = document.createElement("div");
            d.className = "maplibregl-mobile-message", d.textContent = s, this._container.appendChild(d), this._container.setAttribute("aria-hidden", "true")
          }
          _destroyUI() {
            this._container && (K.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container
          }
          enable() {
            this._setupUI(), this._enabled = !0
          }
          disable() {
            this._enabled = !1, this._destroyUI()
          }
          isEnabled() {
            return this._enabled
          }
          isBypassed(e) {
            return e[this._bypassKey]
          }
          notifyGestureBlocked(e, n) {
            this._enabled && (this._map.fire(new o.l("cooperativegestureprevented", {
              gestureType: e,
              originalEvent: n
            })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show")
            }), 100))
          }
        }
        const Ca = h => h.zoom || h.drag || h.roll || h.pitch || h.rotate;
        class ji extends o.l {}

        function Hs(h) {
          return h.panDelta && h.panDelta.mag() || h.zoomDelta || h.bearingDelta || h.pitchDelta || h.rollDelta
        }
        class Hc {
          constructor(e, n) {
            this.handleWindowEvent = u => {
              this.handleEvent(u, `${u.type}Window`)
            }, this.handleEvent = (u, d) => {
              if (u.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const m = u.type === "renderFrame" ? void 0 : u,
                y = {
                  needsRenderFrame: !1
                },
                b = {},
                P = {};
              for (const {
                  handlerName: z,
                  handler: B,
                  allowed: U
                }
                of this._handlers) {
                if (!B.isEnabled()) continue;
                let Q;
                if (this._blockedByActive(P, U, z)) B.reset();
                else if (B[d || u.type]) {
                  if (o.cp(u, d || u.type)) {
                    const J = K.mousePos(this._map.getCanvas(), u);
                    Q = B[d || u.type](u, J)
                  } else if (o.cq(u, d || u.type)) {
                    const J = this._getMapTouches(u.touches),
                      re = K.touchPos(this._map.getCanvas(), J);
                    Q = B[d || u.type](u, re, J)
                  } else o.cr(d || u.type) || (Q = B[d || u.type](u));
                  this.mergeHandlerResult(y, b, Q, z, m), Q && Q.needsRenderFrame && this._triggerRenderFrame()
                }(Q || B.isActive()) && (P[z] = B)
              }
              const M = {};
              for (const z in this._previousActiveHandlers) P[z] || (M[z] = m);
              this._previousActiveHandlers = P, (Object.keys(M).length || Hs(y)) && (this._changes.push([y, b, M]), this._triggerRenderFrame()), (Object.keys(P).length || Hs(y)) && this._map._stop(!0), this._updatingCamera = !1;
              const {
                cameraAnimation: L
              } = y;
              L && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], L(this._map))
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Uh(e), this._bearingSnap = n.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(n);
            const s = this._el;
            this._listeners = [
              [s, "touchstart", {
                passive: !0
              }],
              [s, "touchmove", {
                passive: !1
              }],
              [s, "touchend", void 0],
              [s, "touchcancel", void 0],
              [s, "mousedown", void 0],
              [s, "mousemove", void 0],
              [s, "mouseup", void 0],
              [document, "mousemove", {
                capture: !0
              }],
              [document, "mouseup", void 0],
              [s, "mouseover", void 0],
              [s, "mouseout", void 0],
              [s, "dblclick", void 0],
              [s, "click", void 0],
              [s, "keydown", {
                capture: !1
              }],
              [s, "keyup", void 0],
              [s, "wheel", {
                passive: !1
              }],
              [s, "contextmenu", void 0],
              [window, "blur", void 0]
            ];
            for (const [u, d, m] of this._listeners) K.addEventListener(u, d, u === document ? this.handleWindowEvent : this.handleEvent, m)
          }
          destroy() {
            for (const [e, n, s] of this._listeners) K.removeEventListener(e, n, e === document ? this.handleWindowEvent : this.handleEvent, s)
          }
          _addDefaultHandlers(e) {
            const n = this._map,
              s = n.getCanvasContainer();
            this._add("mapEvent", new Zh(n, e));
            const u = n.boxZoom = new qc(n, e);
            this._add("boxZoom", u), e.interactive && e.boxZoom && u.enable();
            const d = n.cooperativeGestures = new Yh(n, e.cooperativeGestures);
            this._add("cooperativeGestures", d), e.cooperativeGestures && d.enable();
            const m = new ba(n),
              y = new $c(n);
            n.doubleClickZoom = new Zc(y, m), this._add("tapZoom", m), this._add("clickZoom", y), e.interactive && e.doubleClickZoom && n.doubleClickZoom.enable();
            const b = new Wh;
            this._add("tapDragZoom", b);
            const P = n.touchPitch = new bl(n);
            this._add("touchPitch", P), e.interactive && e.touchPitch && n.touchPitch.enable(e.touchPitch);
            const M = () => n.project(n.getCenter()),
              L = (function({
                enable: ue,
                clickTolerance: ge,
                aroundCenter: we = !0,
                minPixelCenterThreshold: he = 100,
                rotateDegreesPerPixelMoved: ze = .8
              }, He) {
                const Ne = new Eo({
                  checkCorrectEvent: qe => K.mouseButton(qe) === 0 && qe.ctrlKey || K.mouseButton(qe) === 2 && !qe.ctrlKey
                });
                return new Zs({
                  clickTolerance: ge,
                  move: (qe, Ge) => {
                    const Dt = He();
                    if (we && Math.abs(Dt.y - qe.y) > he) return {
                      bearingDelta: o.cn(new o.P(qe.x, Ge.y), Ge, Dt)
                    };
                    let Ft = (Ge.x - qe.x) * ze;
                    return we && Ge.y < Dt.y && (Ft = -Ft), {
                      bearingDelta: Ft
                    }
                  },
                  moveStateManager: Ne,
                  enable: ue,
                  assignEvents: zo
                })
              })(e, M),
              z = (function({
                enable: ue,
                clickTolerance: ge,
                pitchDegreesPerPixelMoved: we = -.5
              }) {
                const he = new Eo({
                  checkCorrectEvent: ze => K.mouseButton(ze) === 0 && ze.ctrlKey || K.mouseButton(ze) === 2
                });
                return new Zs({
                  clickTolerance: ge,
                  move: (ze, He) => ({
                    pitchDelta: (He.y - ze.y) * we
                  }),
                  moveStateManager: he,
                  enable: ue,
                  assignEvents: zo
                })
              })(e),
              B = (function({
                enable: ue,
                clickTolerance: ge,
                rollDegreesPerPixelMoved: we = .3
              }, he) {
                const ze = new Eo({
                  checkCorrectEvent: He => K.mouseButton(He) === 2 && He.ctrlKey
                });
                return new Zs({
                  clickTolerance: ge,
                  move: (He, Ne) => {
                    const qe = he();
                    let Ge = (Ne.x - He.x) * we;
                    return Ne.y < qe.y && (Ge = -Ge), {
                      rollDelta: Ge
                    }
                  },
                  moveStateManager: ze,
                  enable: ue,
                  assignEvents: zo
                })
              })(e, M);
            n.dragRotate = new Gc(e, L, z, B), this._add("mouseRotate", L, ["mousePitch"]), this._add("mousePitch", z, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", B, ["mousePitch"]), e.interactive && e.dragRotate && n.dragRotate.enable();
            const U = (function({
                enable: ue,
                clickTolerance: ge
              }) {
                const we = new Eo({
                  checkCorrectEvent: he => K.mouseButton(he) === 0 && !he.ctrlKey
                });
                return new Zs({
                  clickTolerance: ge,
                  move: (he, ze) => ({
                    around: ze,
                    panDelta: ze.sub(he)
                  }),
                  activateOnStart: !0,
                  moveStateManager: we,
                  enable: ue,
                  assignEvents: zo
                })
              })(e),
              Q = new Lo(e, n);
            n.dragPan = new Xh(s, U, Q), this._add("mousePan", U), this._add("touchPan", Q, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && n.dragPan.enable(e.dragPan);
            const J = new Gs,
              re = new xl;
            n.touchZoomRotate = new Kh(s, re, J, b), this._add("touchRotate", J, ["touchPan", "touchZoom"]), this._add("touchZoom", re, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && n.touchZoomRotate.enable(e.touchZoomRotate);
            const se = n.scrollZoom = new Hh(n, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", se, ["mousePan"]), e.interactive && e.scrollZoom && n.scrollZoom.enable(e.scrollZoom);
            const de = n.keyboard = new wl(n);
            this._add("keyboard", de), e.interactive && e.keyboard && n.keyboard.enable(), this._add("blockableMapEvent", new $h(n))
          }
          _add(e, n, s) {
            this._handlers.push({
              handlerName: e,
              handler: n,
              allowed: s
            }), this._handlersById[e] = n
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const {
                  handler: n
                }
                of this._handlers) n.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = []
            }
          }
          isActive() {
            for (const {
                handler: e
              }
              of this._handlers)
              if (e.isActive()) return !0;
            return !1
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
          }
          isRotating() {
            return !!this._eventsInProgress.rotate
          }
          isMoving() {
            return !!Ca(this._eventsInProgress) || this.isZooming()
          }
          _blockedByActive(e, n, s) {
            for (const u in e)
              if (u !== s && (!n || n.indexOf(u) < 0)) return !0;
            return !1
          }
          _getMapTouches(e) {
            const n = [];
            for (const s of e) this._el.contains(s.target) && n.push(s);
            return n
          }
          mergeHandlerResult(e, n, s, u, d) {
            if (!s) return;
            o.e(e, s);
            const m = {
              handlerName: u,
              originalEvent: s.originalEvent || d
            };
            s.zoomDelta !== void 0 && (n.zoom = m), s.panDelta !== void 0 && (n.drag = m), s.rollDelta !== void 0 && (n.roll = m), s.pitchDelta !== void 0 && (n.pitch = m), s.bearingDelta !== void 0 && (n.rotate = m)
          }
          _applyChanges() {
            const e = {},
              n = {},
              s = {};
            for (const [u, d, m] of this._changes) u.panDelta && (e.panDelta = (e.panDelta || new o.P(0, 0))._add(u.panDelta)), u.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + u.zoomDelta), u.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + u.bearingDelta), u.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + u.pitchDelta), u.rollDelta && (e.rollDelta = (e.rollDelta || 0) + u.rollDelta), u.around !== void 0 && (e.around = u.around), u.pinchAround !== void 0 && (e.pinchAround = u.pinchAround), u.noInertia && (e.noInertia = u.noInertia), o.e(n, d), o.e(s, m);
            this._updateMapTransform(e, n, s), this._changes = []
          }
          _updateMapTransform(e, n, s) {
            const u = this._map,
              d = u._getTransformForUpdate(),
              m = u.terrain;
            if (!(Hs(e) || m && this._terrainMovement)) return this._fireEvents(n, s, !0);
            u._stop(!0);
            let {
              panDelta: y,
              zoomDelta: b,
              bearingDelta: P,
              pitchDelta: M,
              rollDelta: L,
              around: z,
              pinchAround: B
            } = e;
            B !== void 0 && (z = B), z = z || u.transform.centerPoint, m && !d.isPointOnMapSurface(z) && (z = d.centerPoint);
            const U = {
              panDelta: y,
              zoomDelta: b,
              rollDelta: L,
              pitchDelta: M,
              bearingDelta: P,
              around: z
            };
            this._map.cameraHelper.useGlobeControls && !d.isPointOnMapSurface(z) && (z = d.centerPoint);
            const Q = z.distSqr(d.centerPoint) < .01 ? d.center : d.screenPointToLocation(y ? z.sub(y) : z);
            m ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(U, d), this._terrainMovement || !n.drag && !n.zoom ? n.drag && this._terrainMovement ? d.setCenter(d.screenPointToLocation(d.centerPoint.sub(y))) : this._map.cameraHelper.handleMapControlsPan(U, d, Q) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan(U, d, Q))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(U, d), this._map.cameraHelper.handleMapControlsPan(U, d, Q)), u._applyUpdatedTransform(d), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(n, s, !0)
          }
          _fireEvents(e, n, s) {
            const u = Ca(this._eventsInProgress),
              d = Ca(e),
              m = {};
            for (const L in e) {
              const {
                originalEvent: z
              } = e[L];
              this._eventsInProgress[L] || (m[`${L}start`] = z), this._eventsInProgress[L] = e[L]
            }!u && d && this._fireEvent("movestart", d.originalEvent);
            for (const L in m) this._fireEvent(L, m[L]);
            d && this._fireEvent("move", d.originalEvent);
            for (const L in e) {
              const {
                originalEvent: z
              } = e[L];
              this._fireEvent(L, z)
            }
            const y = {};
            let b;
            for (const L in this._eventsInProgress) {
              const {
                handlerName: z,
                originalEvent: B
              } = this._eventsInProgress[L];
              this._handlersById[z].isActive() || (delete this._eventsInProgress[L], b = n[z] || B, y[`${L}end`] = b)
            }
            for (const L in y) this._fireEvent(L, y[L]);
            const P = Ca(this._eventsInProgress),
              M = (u || d) && !P;
            if (M && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const L = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && L.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(L)
            }
            if (s && M) {
              this._updatingCamera = !0;
              const L = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                z = B => B !== 0 && -this._bearingSnap < B && B < this._bearingSnap;
              !L || !L.essential && xe.prefersReducedMotion ? (this._map.fire(new o.l("moveend", {
                originalEvent: b
              })), z(this._map.getBearing()) && this._map.resetNorth()) : (z(L.bearing || this._map.getBearing()) && (L.bearing = 0), L.freezeElevation = !0, this._map.easeTo(L, {
                originalEvent: b
              })), this._updatingCamera = !1
            }
          }
          _fireEvent(e, n) {
            this._map.fire(new o.l(e, n ? {
              originalEvent: n
            } : {}))
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e => {
              delete this._frameId, this.handleEvent(new ji("renderFrame", {
                timeStamp: e
              })), this._applyChanges()
            }))
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame())
          }
        }
        class Jh extends o.E {
          constructor(e, n, s) {
            super(), this._renderFrameCallback = () => {
              const u = Math.min((xe.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(u)), u < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = s.bearingSnap, this.cameraHelper = n, this.on("moveend", (() => {
              delete this._requestedCameraState
            }))
          }
          migrateProjection(e, n) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = n
          }
          getCenter() {
            return new o.S(this.transform.center.lng, this.transform.center.lat)
          }
          setCenter(e, n) {
            return this.jumpTo({
              center: e
            }, n)
          }
          getCenterElevation() {
            return this.transform.elevation
          }
          setCenterElevation(e, n) {
            return this.jumpTo({
              elevation: e
            }, n), this
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e
          }
          panBy(e, n, s) {
            return e = o.P.convert(e).mult(-1), this.panTo(this.transform.center, o.e({
              offset: e
            }, n), s)
          }
          panTo(e, n, s) {
            return this.easeTo(o.e({
              center: e
            }, n), s)
          }
          getZoom() {
            return this.transform.zoom
          }
          setZoom(e, n) {
            return this.jumpTo({
              zoom: e
            }, n), this
          }
          zoomTo(e, n, s) {
            return this.easeTo(o.e({
              zoom: e
            }, n), s)
          }
          zoomIn(e, n) {
            return this.zoomTo(this.getZoom() + 1, e, n), this
          }
          zoomOut(e, n) {
            return this.zoomTo(this.getZoom() - 1, e, n), this
          }
          getVerticalFieldOfView() {
            return this.transform.fov
          }
          setVerticalFieldOfView(e, n) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new o.l("movestart", n)).fire(new o.l("move", n)).fire(new o.l("moveend", n))), this
          }
          getBearing() {
            return this.transform.bearing
          }
          setBearing(e, n) {
            return this.jumpTo({
              bearing: e
            }, n), this
          }
          getPadding() {
            return this.transform.padding
          }
          setPadding(e, n) {
            return this.jumpTo({
              padding: e
            }, n), this
          }
          rotateTo(e, n, s) {
            return this.easeTo(o.e({
              bearing: e
            }, n), s)
          }
          resetNorth(e, n) {
            return this.rotateTo(0, o.e({
              duration: 1e3
            }, e), n), this
          }
          resetNorthPitch(e, n) {
            return this.easeTo(o.e({
              bearing: 0,
              pitch: 0,
              roll: 0,
              duration: 1e3
            }, e), n), this
          }
          snapToNorth(e, n) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, n) : this
          }
          getPitch() {
            return this.transform.pitch
          }
          setPitch(e, n) {
            return this.jumpTo({
              pitch: e
            }, n), this
          }
          getRoll() {
            return this.transform.roll
          }
          setRoll(e, n) {
            return this.jumpTo({
              roll: e
            }, n), this
          }
          cameraForBounds(e, n) {
            e = ht.convert(e).adjustAntiMeridian();
            const s = n && n.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), s, n)
          }
          _cameraForBoxAndBearing(e, n, s, u) {
            const d = {
              top: 0,
              bottom: 0,
              right: 0,
              left: 0
            };
            if (typeof(u = o.e({
                padding: d,
                offset: [0, 0],
                maxZoom: this.transform.maxZoom
              }, u)).padding == "number") {
              const P = u.padding;
              u.padding = {
                top: P,
                bottom: P,
                right: P,
                left: P
              }
            }
            const m = o.e(d, u.padding);
            u.padding = m;
            const y = this.transform,
              b = new ht(e, n);
            return this.cameraHelper.cameraForBoxAndBearing(u, m, b, s, y)
          }
          fitBounds(e, n, s) {
            return this._fitInternal(this.cameraForBounds(e, n), n, s)
          }
          fitScreenCoordinates(e, n, s, u, d) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(o.P.convert(e)), this.transform.screenPointToLocation(o.P.convert(n)), s, u), u, d)
          }
          _fitInternal(e, n, s) {
            return e ? (delete(n = o.e(e, n)).padding, n.linear ? this.easeTo(n, s) : this.flyTo(n, s)) : this
          }
          jumpTo(e, n) {
            this.stop();
            const s = this._getTransformForUpdate();
            let u = !1,
              d = !1,
              m = !1;
            const y = s.zoom;
            this.cameraHelper.handleJumpToCenterZoom(s, e);
            const b = s.zoom !== y;
            return "elevation" in e && s.elevation !== +e.elevation && s.setElevation(+e.elevation), "bearing" in e && s.bearing !== +e.bearing && (u = !0, s.setBearing(+e.bearing)), "pitch" in e && s.pitch !== +e.pitch && (d = !0, s.setPitch(+e.pitch)), "roll" in e && s.roll !== +e.roll && (m = !0, s.setRoll(+e.roll)), e.padding == null || s.isPaddingEqual(e.padding) || s.setPadding(e.padding), this._applyUpdatedTransform(s), this.fire(new o.l("movestart", n)).fire(new o.l("move", n)), b && this.fire(new o.l("zoomstart", n)).fire(new o.l("zoom", n)).fire(new o.l("zoomend", n)), u && this.fire(new o.l("rotatestart", n)).fire(new o.l("rotate", n)).fire(new o.l("rotateend", n)), d && this.fire(new o.l("pitchstart", n)).fire(new o.l("pitch", n)).fire(new o.l("pitchend", n)), m && this.fire(new o.l("rollstart", n)).fire(new o.l("roll", n)).fire(new o.l("rollend", n)), this.fire(new o.l("moveend", n))
          }
          calculateCameraOptionsFromTo(e, n, s, u = 0) {
            const d = o.a1.fromLngLat(e, n),
              m = o.a1.fromLngLat(s, u),
              y = m.x - d.x,
              b = m.y - d.y,
              P = m.z - d.z,
              M = Math.hypot(y, b, P);
            if (M === 0) throw new Error("Can't calculate camera options with same From and To");
            const L = Math.hypot(y, b),
              z = o.ak(this.transform.cameraToCenterDistance / M / this.transform.tileSize),
              B = 180 * Math.atan2(y, -b) / Math.PI;
            let U = 180 * Math.acos(L / M) / Math.PI;
            return U = P < 0 ? 90 - U : 90 + U, {
              center: m.toLngLat(),
              elevation: u,
              zoom: z,
              pitch: U,
              bearing: B
            }
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, n, s, u, d) {
            const m = this.transform.calculateCenterFromCameraLngLatAlt(e, n, s, u);
            return {
              center: m.center,
              elevation: m.elevation,
              zoom: m.zoom,
              bearing: s,
              pitch: u,
              roll: d
            }
          }
          easeTo(e, n) {
            this._stop(!1, e.easeId), ((e = o.e({
              offset: [0, 0],
              duration: 500,
              easing: o.co
            }, e)).animate === !1 || !e.essential && xe.prefersReducedMotion) && (e.duration = 0);
            const s = this._getTransformForUpdate(),
              u = this.getBearing(),
              d = s.pitch,
              m = s.roll,
              y = "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
              b = "pitch" in e ? +e.pitch : d,
              P = "roll" in e ? this._normalizeBearing(e.roll, m) : m,
              M = "padding" in e ? e.padding : s.padding,
              L = o.P.convert(e.offset);
            let z, B;
            e.around && (z = o.S.convert(e.around), B = s.locationToScreenPoint(z));
            const U = {
                moving: this._moving,
                zooming: this._zooming,
                rotating: this._rotating,
                pitching: this._pitching,
                rolling: this._rolling
              },
              Q = this.cameraHelper.handleEaseTo(s, {
                bearing: y,
                pitch: b,
                roll: P,
                padding: M,
                around: z,
                aroundPoint: B,
                offsetAsPoint: L,
                offset: e.offset,
                zoom: e.zoom,
                center: e.center
              });
            return this._rotating = this._rotating || u !== y, this._pitching = this._pitching || b !== d, this._rolling = this._rolling || P !== m, this._padding = !s.isPaddingEqual(M), this._zooming = this._zooming || Q.isZooming, this._easeId = e.easeId, this._prepareEase(n, e.noMoveStart, U), this.terrain && this._prepareElevation(Q.elevationCenter), this._ease((J => {
              Q.easeFunc(J), this.terrain && !e.freezeElevation && this._updateElevation(J), this._applyUpdatedTransform(s), this._fireMoveEvents(n)
            }), (J => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(n, J)
            }), e), this
          }
          _prepareEase(e, n, s = {}) {
            this._moving = !0, n || s.moving || this.fire(new o.l("movestart", e)), this._zooming && !s.zooming && this.fire(new o.l("zoomstart", e)), this._rotating && !s.rotating && this.fire(new o.l("rotatestart", e)), this._pitching && !s.pitching && this.fire(new o.l("pitchstart", e)), this._rolling && !s.rolling && this.fire(new o.l("rollstart", e))
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0
          }
          _updateElevation(e) {
            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const n = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && n !== this._elevationTarget) {
              const s = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (s - (n - (s * e + this._elevationStart)) / (1 - e)), this._elevationTarget = n
            }
            this.transform.setElevation(o.C.number(this._elevationStart, this._elevationTarget, e))
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const n = e.getCameraLngLat(),
              s = e.getCameraAltitude(),
              u = this.terrain ? this.terrain.getElevationForLngLatZoom(n, e.zoom) : 0;
            if (s < u) {
              const d = this.calculateCameraOptionsFromTo(n, u, e.center, e.elevation);
              return {
                pitch: d.pitch,
                zoom: d.zoom
              }
            }
            return {}
          }
          _applyUpdatedTransform(e) {
            const n = [];
            if (n.push((u => this._elevateCameraIfInsideTerrain(u))), this.transformCameraUpdate && n.push((u => this.transformCameraUpdate(u))), !n.length) return;
            const s = e.clone();
            for (const u of n) {
              const d = s.clone(),
                {
                  center: m,
                  zoom: y,
                  roll: b,
                  pitch: P,
                  bearing: M,
                  elevation: L
                } = u(d);
              m && d.setCenter(m), L !== void 0 && d.setElevation(L), y !== void 0 && d.setZoom(y), b !== void 0 && d.setRoll(b), P !== void 0 && d.setPitch(P), M !== void 0 && d.setBearing(M), s.apply(d)
            }
            this.transform.apply(s)
          }
          _fireMoveEvents(e) {
            this.fire(new o.l("move", e)), this._zooming && this.fire(new o.l("zoom", e)), this._rotating && this.fire(new o.l("rotate", e)), this._pitching && this.fire(new o.l("pitch", e)), this._rolling && this.fire(new o.l("roll", e))
          }
          _afterEase(e, n) {
            if (this._easeId && n && this._easeId === n) return;
            delete this._easeId;
            const s = this._zooming,
              u = this._rotating,
              d = this._pitching,
              m = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, s && this.fire(new o.l("zoomend", e)), u && this.fire(new o.l("rotateend", e)), d && this.fire(new o.l("pitchend", e)), m && this.fire(new o.l("rollend", e)), this.fire(new o.l("moveend", e))
          }
          flyTo(e, n) {
            if (!e.essential && xe.prefersReducedMotion) {
              const Ge = o.Q(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(Ge, n)
            }
            this.stop(), e = o.e({
              offset: [0, 0],
              speed: 1.2,
              curve: 1.42,
              easing: o.co
            }, e);
            const s = this._getTransformForUpdate(),
              u = s.bearing,
              d = s.pitch,
              m = s.roll,
              y = s.padding,
              b = "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
              P = "pitch" in e ? +e.pitch : d,
              M = "roll" in e ? this._normalizeBearing(e.roll, m) : m,
              L = "padding" in e ? e.padding : s.padding,
              z = o.P.convert(e.offset);
            let B = s.centerPoint.add(z);
            const U = s.screenPointToLocation(B),
              Q = this.cameraHelper.handleFlyTo(s, {
                bearing: b,
                pitch: P,
                roll: M,
                padding: L,
                locationAtOffset: U,
                offsetAsPoint: z,
                center: e.center,
                minZoom: e.minZoom,
                zoom: e.zoom
              });
            let J = e.curve;
            const re = Math.max(s.width, s.height),
              se = re / Q.scaleOfZoom,
              de = Q.pixelPathLength;
            typeof Q.scaleOfMinZoom == "number" && (J = Math.sqrt(re / Q.scaleOfMinZoom / de * 2));
            const ue = J * J;

            function ge(Ge) {
              const Dt = (se * se - re * re + (Ge ? -1 : 1) * ue * ue * de * de) / (2 * (Ge ? se : re) * ue * de);
              return Math.log(Math.sqrt(Dt * Dt + 1) - Dt)
            }

            function we(Ge) {
              return (Math.exp(Ge) - Math.exp(-Ge)) / 2
            }

            function he(Ge) {
              return (Math.exp(Ge) + Math.exp(-Ge)) / 2
            }
            const ze = ge(!1);
            let He = function(Ge) {
                return he(ze) / he(ze + J * Ge)
              },
              Ne = function(Ge) {
                return re * ((he(ze) * (we(Dt = ze + J * Ge) / he(Dt)) - we(ze)) / ue) / de;
                var Dt
              },
              qe = (ge(!0) - ze) / J;
            if (Math.abs(de) < 2e-6 || !isFinite(qe)) {
              if (Math.abs(re - se) < 1e-6) return this.easeTo(e, n);
              const Ge = se < re ? -1 : 1;
              qe = Math.abs(Math.log(se / re)) / J, Ne = () => 0, He = Dt => Math.exp(Ge * J * Dt)
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * qe / ("screenSpeed" in e ? +e.screenSpeed / J : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = u !== b, this._pitching = P !== d, this._rolling = M !== m, this._padding = !s.isPaddingEqual(L), this._prepareEase(n, !1), this.terrain && this._prepareElevation(Q.targetCenter), this._ease((Ge => {
              const Dt = Ge * qe,
                Ft = 1 / He(Dt),
                vt = Ne(Dt);
              this._rotating && s.setBearing(o.C.number(u, b, Ge)), this._pitching && s.setPitch(o.C.number(d, P, Ge)), this._rolling && s.setRoll(o.C.number(m, M, Ge)), this._padding && (s.interpolatePadding(y, L, Ge), B = s.centerPoint.add(z)), Q.easeFunc(Ge, Ft, vt, B), this.terrain && !e.freezeElevation && this._updateElevation(Ge), this._applyUpdatedTransform(s), this._fireMoveEvents(n)
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(n)
            }), e), this
          }
          isEasing() {
            return !!this._easeFrameId
          }
          stop() {
            return this._stop()
          }
          _stop(e, n) {
            var s;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const u = this._onEaseEnd;
              delete this._onEaseEnd, u.call(this, n)
            }
            return e || (s = this.handlers) === null || s === void 0 || s.stop(!1), this
          }
          _ease(e, n, s) {
            s.animate === !1 || s.duration === 0 ? (e(1), n()) : (this._easeStart = xe.now(), this._easeOptions = s, this._onEaseFrame = e, this._onEaseEnd = n, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
          }
          _normalizeBearing(e, n) {
            e = o.aO(e, -180, 180);
            const s = Math.abs(e - n);
            return Math.abs(e - 360 - n) < s && (e -= 360), Math.abs(e + 360 - n) < s && (e += 360), e
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(o.S.convert(e), this.transform.tileZoom) : null
          }
        }
        const Wc = {
          compact: !0,
          customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
        };
        class Xc {
          constructor(e = Wc) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")))
            }, this._updateData = n => {
              !n || n.sourceDataType !== "metadata" && n.sourceDataType !== "visibility" && n.dataType !== "style" && n.type !== "terrain" || this._updateAttributions()
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-right"
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = K.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = K.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = K.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container
          }
          onRemove() {
            K.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0
          }
          _setElementTitle(e, n) {
            const s = this._map._getUIString(`AttributionControl.${n}`);
            e.title = s, e.setAttribute("aria-label", s)
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((u => typeof u != "string" ? "" : u))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const u = this._map.style.stylesheet;
              this.styleOwner = u.owner, this.styleId = u.id
            }
            const n = this._map.style.sourceCaches;
            for (const u in n) {
              const d = n[u];
              if (d.used || d.usedForTerrain) {
                const m = d.getSource();
                m.attribution && e.indexOf(m.attribution) < 0 && e.push(m.attribution)
              }
            }
            e = e.filter((u => String(u).trim())), e.sort(((u, d) => u.length - d.length)), e = e.filter(((u, d) => {
              for (let m = d + 1; m < e.length; m++)
                if (e[m].indexOf(u) >= 0) return !1;
              return !0
            }));
            const s = e.join(" | ");
            s !== this._attribHTML && (this._attribHTML = s, e.length ? (this._innerContainer.innerHTML = K.sanitize(s), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null)
          }
        }
        class Qh {
          constructor(e = {}) {
            this._updateCompact = () => {
              const n = this._container.children;
              if (n.length) {
                const s = n[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && s.classList.add("maplibregl-compact") : s.classList.remove("maplibregl-compact")
              }
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = K.create("div", "maplibregl-ctrl");
            const n = K.create("a", "maplibregl-ctrl-logo");
            return n.target = "_blank", n.rel = "noopener nofollow", n.href = "https://maplibre.org/", n.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), n.setAttribute("rel", "noopener nofollow"), this._container.appendChild(n), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
          }
          onRemove() {
            K.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0
          }
        }
        class Oa {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
          }
          add(e) {
            const n = ++this._id;
            return this._queue.push({
              callback: e,
              id: n,
              cancelled: !1
            }), n
          }
          remove(e) {
            const n = this._currentlyRunning,
              s = n ? this._queue.concat(n) : this._queue;
            for (const u of s)
              if (u.id === e) return void(u.cancelled = !0)
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const n = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const s of n)
              if (!s.cancelled && (s.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = []
          }
        }
        var Cl = o.aJ([{
          name: "a_pos3d",
          type: "Int16",
          components: 3
        }]);
        class hr extends o.E {
          constructor(e) {
            super(), this._lastTilesetChange = xe.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize
          }
          destruct() {
            this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null
          }
          update(e, n) {
            this.sourceCache.update(e, n), this._renderableTilesKeys = [];
            const s = {};
            for (const u of ye(e, {
                tileSize: this.tileSize,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                reparseOverscaled: !1,
                terrain: n,
                calculateTileZoom: this.sourceCache._source.calculateTileZoom
              })) s[u.key] = !0, this._renderableTilesKeys.push(u.key), this._tiles[u.key] || (u.terrainRttPosMatrix32f = new Float64Array(16), o.bY(u.terrainRttPosMatrix32f, 0, o.$, o.$, 0, 0, 1), this._tiles[u.key] = new Nr(u, this.tileSize), this._lastTilesetChange = xe.now());
            for (const u in this._tiles) s[u] || delete this._tiles[u]
          }
          freeRtt(e) {
            for (const n in this._tiles) {
              const s = this._tiles[n];
              (!e || s.tileID.equals(e) || s.tileID.isChildOf(e) || e.isChildOf(s.tileID)) && (s.rtt = [])
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e => this.getTileByID(e)))
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          getTerrainCoords(e, n) {
            return n ? this._getTerrainCoordsForTileRanges(e, n) : this._getTerrainCoordsForRegularTile(e)
          }
          _getTerrainCoordsForRegularTile(e) {
            const n = {};
            for (const s of this._renderableTilesKeys) {
              const u = this._tiles[s].tileID,
                d = e.clone(),
                m = o.ba();
              if (u.canonical.equals(e.canonical)) o.bY(m, 0, o.$, o.$, 0, 0, 1);
              else if (u.canonical.isChildOf(e.canonical)) {
                const y = u.canonical.z - e.canonical.z,
                  b = u.canonical.x - (u.canonical.x >> y << y),
                  P = u.canonical.y - (u.canonical.y >> y << y),
                  M = o.$ >> y;
                o.bY(m, 0, M, M, 0, 0, 1), o.M(m, m, [-b * M, -P * M, 0])
              } else {
                if (!e.canonical.isChildOf(u.canonical)) continue;
                {
                  const y = e.canonical.z - u.canonical.z,
                    b = e.canonical.x - (e.canonical.x >> y << y),
                    P = e.canonical.y - (e.canonical.y >> y << y),
                    M = o.$ >> y;
                  o.bY(m, 0, o.$, o.$, 0, 0, 1), o.M(m, m, [b * M, P * M, 0]), o.N(m, m, [1 / 2 ** y, 1 / 2 ** y, 0])
                }
              }
              d.terrainRttPosMatrix32f = new Float32Array(m), n[s] = d
            }
            return n
          }
          _getTerrainCoordsForTileRanges(e, n) {
            const s = {};
            for (const u of this._renderableTilesKeys) {
              const d = this._tiles[u].tileID;
              if (!this._isWithinTileRanges(d, n)) continue;
              const m = e.clone(),
                y = o.ba();
              if (d.canonical.z === e.canonical.z) {
                const b = e.canonical.x - d.canonical.x,
                  P = e.canonical.y - d.canonical.y;
                o.bY(y, 0, o.$, o.$, 0, 0, 1), o.M(y, y, [b * o.$, P * o.$, 0])
              } else if (d.canonical.z > e.canonical.z) {
                const b = d.canonical.z - e.canonical.z,
                  P = d.canonical.x - (d.canonical.x >> b << b),
                  M = d.canonical.y - (d.canonical.y >> b << b),
                  L = e.canonical.x - (d.canonical.x >> b),
                  z = e.canonical.y - (d.canonical.y >> b),
                  B = o.$ >> b;
                o.bY(y, 0, B, B, 0, 0, 1), o.M(y, y, [-P * B + L * o.$, -M * B + z * o.$, 0])
              } else {
                const b = e.canonical.z - d.canonical.z,
                  P = e.canonical.x - (e.canonical.x >> b << b),
                  M = e.canonical.y - (e.canonical.y >> b << b),
                  L = (e.canonical.x >> b) - d.canonical.x,
                  z = (e.canonical.y >> b) - d.canonical.y,
                  B = o.$ << b;
                o.bY(y, 0, B, B, 0, 0, 1), o.M(y, y, [P * o.$ + L * B, M * o.$ + z * B, 0])
              }
              m.terrainRttPosMatrix32f = new Float32Array(y), s[u] = m
            }
            return s
          }
          getSourceTile(e, n) {
            const s = this.sourceCache._source;
            let u = e.overscaledZ - this.deltaZoom;
            if (u > s.maxzoom && (u = s.maxzoom), u < s.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(u).key);
            let d = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
            if ((!d || !d.dem) && n)
              for (; u >= s.minzoom && (!d || !d.dem);) d = this.sourceCache.getTileByID(e.scaledTo(u--).key);
            return d
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e
          }
          _isWithinTileRanges(e, n) {
            return n[e.canonical.z] && e.canonical.x >= n[e.canonical.z].minTileX && e.canonical.x <= n[e.canonical.z].maxTileX && e.canonical.y >= n[e.canonical.z].minTileY && e.canonical.y <= n[e.canonical.z].maxTileY
          }
        }
        class Lr {
          constructor(e, n, s) {
            this._meshCache = {}, this.painter = e, this.sourceCache = new hr(n), this.options = s, this.exaggeration = typeof s.exaggeration == "number" ? s.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024
          }
          getDEMElevation(e, n, s, u = o.$) {
            var d;
            if (!(n >= 0 && n < u && s >= 0 && s < u)) return 0;
            const m = this.getTerrainData(e),
              y = (d = m.tile) === null || d === void 0 ? void 0 : d.dem;
            if (!y) return 0;
            const b = o.cs([], [n / u * o.$, s / u * o.$], m.u_terrain_matrix),
              P = [b[0] * y.dim, b[1] * y.dim],
              M = Math.floor(P[0]),
              L = Math.floor(P[1]),
              z = P[0] - M,
              B = P[1] - L;
            return y.get(M, L) * (1 - z) * (1 - B) + y.get(M + 1, L) * z * (1 - B) + y.get(M, L + 1) * (1 - z) * B + y.get(M + 1, L + 1) * z * B
          }
          getElevationForLngLatZoom(e, n) {
            if (!o.ct(n, e.wrap())) return 0;
            const {
              tileID: s,
              mercatorX: u,
              mercatorY: d
            } = this._getOverscaledTileIDFromLngLatZoom(e, n);
            return this.getElevation(s, u % o.$, d % o.$, o.$)
          }
          getElevation(e, n, s, u = o.$) {
            return this.getDEMElevation(e, n, s, u) * this.exaggeration
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const u = this.painter.context,
                d = new o.R({
                  width: 1,
                  height: 1
                }, new Uint8Array(4));
              this._emptyDepthTexture = new o.T(u, d, u.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new o.T(u, new o.R({
                width: 1,
                height: 1
              }), u.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = o.ag([])
            }
            const n = this.sourceCache.getSourceTile(e, !0);
            if (n && n.dem && (!n.demTexture || n.needsTerrainPrepare)) {
              const u = this.painter.context;
              n.demTexture = this.painter.getTileTexture(n.dem.stride), n.demTexture ? n.demTexture.update(n.dem.getPixels(), {
                premultiply: !1
              }) : n.demTexture = new o.T(u, n.dem.getPixels(), u.gl.RGBA, {
                premultiply: !1
              }), n.demTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), n.needsTerrainPrepare = !1
            }
            const s = n && n + n.tileID.key + e.key;
            if (s && !this._demMatrixCache[s]) {
              const u = this.sourceCache.sourceCache._source.maxzoom;
              let d = e.canonical.z - n.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= u ? d = e.canonical.z - u : o.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const m = e.canonical.x - (e.canonical.x >> d << d),
                y = e.canonical.y - (e.canonical.y >> d << d),
                b = o.cu(new Float64Array(16), [1 / (o.$ << d), 1 / (o.$ << d), 0]);
              o.M(b, b, [m * o.$, y * o.$, 0]), this._demMatrixCache[e.key] = {
                matrix: b,
                coord: e
              }
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: n && n.dem && n.dem.dim || 1,
              u_terrain_matrix: s ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
              u_terrain_unpack: n && n.dem && n.dem.getUnpackVector() || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: (n && n.demTexture || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
              tile: n
            }
          }
          getFramebuffer(e) {
            const n = this.painter,
              s = n.width / devicePixelRatio,
              u = n.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === s && this._fbo.height === u || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new o.T(n.context, {
              width: s,
              height: u,
              data: null
            }, n.context.gl.RGBA, {
              premultiply: !1
            }), this._fboCoordsTexture.bind(n.context.gl.NEAREST, n.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new o.T(n.context, {
              width: s,
              height: u,
              data: null
            }, n.context.gl.RGBA, {
              premultiply: !1
            }), this._fboDepthTexture.bind(n.context.gl.NEAREST, n.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = n.context.createFramebuffer(s, u, !0, !1), this._fbo.depthAttachment.set(n.context.createRenderbuffer(n.context.gl.DEPTH_COMPONENT16, s, u))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const n = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let d = 0, m = 0; d < this._coordsTextureSize; d++)
              for (let y = 0; y < this._coordsTextureSize; y++, m += 4) n[m + 0] = 255 & y, n[m + 1] = 255 & d, n[m + 2] = y >> 8 << 4 | d >> 8, n[m + 3] = 0;
            const s = new o.R({
                width: this._coordsTextureSize,
                height: this._coordsTextureSize
              }, new Uint8Array(n.buffer)),
              u = new o.T(e, s, e.gl.RGBA, {
                premultiply: !1
              });
            return u.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = u, u
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const n = new Uint8Array(4),
              s = this.painter.context,
              u = s.gl,
              d = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio),
              m = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio),
              y = Math.round(this.painter.height / devicePixelRatio);
            s.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), u.readPixels(d, y - m - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, n), s.bindFramebuffer.set(null);
            const b = n[0] + (n[2] >> 4 << 8),
              P = n[1] + ((15 & n[2]) << 8),
              M = this.coordsIndex[255 - n[3]],
              L = M && this.sourceCache.getTileByID(M);
            if (!L) return null;
            const z = this._coordsTextureSize,
              B = (1 << L.tileID.canonical.z) * z;
            return new o.a1((L.tileID.canonical.x * z + b) / B + L.tileID.wrap, (L.tileID.canonical.y * z + P) / B, this.getElevation(L.tileID, b, P, z))
          }
          depthAtPoint(e) {
            const n = new Uint8Array(4),
              s = this.painter.context,
              u = s.gl;
            return s.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), u.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, n), s.bindFramebuffer.set(null), (n[0] / 16777216 + n[1] / 65536 + n[2] / 256 + n[3]) / 256
          }
          getTerrainMesh(e) {
            var n;
            const s = ((n = this.painter.style.projection) === null || n === void 0 ? void 0 : n.transitionState) > 0,
              u = s && e.canonical.y === 0,
              d = s && e.canonical.y === (1 << e.canonical.z) - 1,
              m = `m_${u?"n":""}_${d?"s":""}`;
            if (this._meshCache[m]) return this._meshCache[m];
            const y = this.painter.context,
              b = new o.cv,
              P = new o.aN,
              M = this.meshSize,
              L = o.$ / M,
              z = M * M;
            for (let he = 0; he <= M; he++)
              for (let ze = 0; ze <= M; ze++) b.emplaceBack(ze * L, he * L, 0);
            for (let he = 0; he < z; he += M + 1)
              for (let ze = 0; ze < M; ze++) P.emplaceBack(ze + he, M + ze + he + 1, M + ze + he + 2), P.emplaceBack(ze + he, M + ze + he + 2, ze + he + 1);
            const B = b.length,
              U = B + (M + 1),
              Q = (M + 1) * M,
              J = u ? o.bh : 0,
              re = u ? 0 : 1,
              se = d ? o.bi : o.$,
              de = d ? 0 : 1;
            for (let he = 0; he <= M; he++) b.emplaceBack(he * L, J, re);
            for (let he = 0; he <= M; he++) b.emplaceBack(he * L, se, de);
            for (let he = 0; he < M; he++) P.emplaceBack(Q + he, U + he, U + he + 1), P.emplaceBack(Q + he, U + he + 1, Q + he + 1), P.emplaceBack(0 + he, B + he + 1, B + he), P.emplaceBack(0 + he, 0 + he + 1, B + he + 1);
            const ue = b.length,
              ge = ue + 2 * (M + 1);
            for (const he of [0, 1])
              for (let ze = 0; ze <= M; ze++)
                for (const He of [0, 1]) b.emplaceBack(he * o.$, ze * L, He);
            for (let he = 0; he < 2 * M; he += 2) P.emplaceBack(ue + he, ue + he + 1, ue + he + 3), P.emplaceBack(ue + he, ue + he + 3, ue + he + 2), P.emplaceBack(ge + he, ge + he + 3, ge + he + 1), P.emplaceBack(ge + he, ge + he + 2, ge + he + 3);
            const we = new Bi(y.createVertexBuffer(b, Cl.members), y.createIndexBuffer(P), o.aM.simpleSegment(0, 0, b.length, P.length));
            return this._meshCache[m] = we, we
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * o.bu / Math.pow(2, Math.max(e, 0)) / 5
          }
          getMinTileElevationForLngLatZoom(e, n) {
            var s;
            const {
              tileID: u
            } = this._getOverscaledTileIDFromLngLatZoom(e, n);
            return (s = this.getMinMaxElevation(u).minElevation) !== null && s !== void 0 ? s : 0
          }
          getMinMaxElevation(e) {
            const n = this.getTerrainData(e).tile,
              s = {
                minElevation: null,
                maxElevation: null
              };
            return n && n.dem && (s.minElevation = n.dem.min * this.exaggeration, s.maxElevation = n.dem.max * this.exaggeration), s
          }
          _getOverscaledTileIDFromLngLatZoom(e, n) {
            const s = o.a1.fromLngLat(e.wrap()),
              u = (1 << n) * o.$,
              d = s.x * u,
              m = s.y * u,
              y = Math.floor(d / o.$),
              b = Math.floor(m / o.$);
            return {
              tileID: new o.Z(n, 0, n, y, b),
              mercatorX: d,
              mercatorY: m
            }
          }
        }
        class Sl {
          constructor(e, n, s) {
            this._context = e, this._size = n, this._tileSize = s, this._objects = [], this._recentlyUsed = [], this._stamp = 0
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy()
          }
          _createObject(e) {
            const n = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0),
              s = new o.T(this._context, {
                width: this._tileSize,
                height: this._tileSize,
                data: null
              }, this._context.gl.RGBA);
            return s.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), n.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), n.colorAttachment.set(s.texture), {
              id: e,
              fbo: n,
              texture: s,
              stamp: -1,
              inUse: !1
            }
          }
          getObjectForId(e) {
            return this._objects[e]
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((n => e.id !== n)), this._recentlyUsed.push(e.id)
          }
          stampObject(e) {
            e.stamp = ++this._stamp
          }
          getOrCreateFreeObject() {
            for (const n of this._recentlyUsed)
              if (!this._objects[n].inUse) return this._objects[n];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e
          }
          freeObject(e) {
            e.inUse = !1
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e)
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((e => !e.inUse)) === !1
          }
        }
        const is = {
          background: !0,
          fill: !0,
          line: !0,
          raster: !0,
          hillshade: !0,
          "color-relief": !0
        };
        class Pl {
          constructor(e, n) {
            this.painter = e, this.terrain = n, this.pool = new Sl(e.context, 30, n.sourceCache.tileSize * n.qualityFactor)
          }
          destruct() {
            this.pool.destruct()
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
          }
          prepareForRender(e, n) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((s => !e._layers[s].isHidden(n))), this._coordsAscending = {};
            for (const s in e.sourceCaches) {
              this._coordsAscending[s] = {};
              const u = e.sourceCaches[s].getVisibleCoordinates(),
                d = e.sourceCaches[s].getSource(),
                m = d instanceof Bt ? d.terrainTileRanges : null;
              for (const y of u) {
                const b = this.terrain.sourceCache.getTerrainCoords(y, m);
                for (const P in b) this._coordsAscending[s][P] || (this._coordsAscending[s][P] = []), this._coordsAscending[s][P].push(b[P])
              }
            }
            this._coordsAscendingStr = {};
            for (const s of e._order) {
              const u = e._layers[s],
                d = u.source;
              if (is[u.type] && !this._coordsAscendingStr[d]) {
                this._coordsAscendingStr[d] = {};
                for (const m in this._coordsAscending[d]) this._coordsAscendingStr[d][m] = this._coordsAscending[d][m].map((y => y.key)).sort().join()
              }
            }
            for (const s of this._renderableTiles)
              for (const u in this._coordsAscendingStr) {
                const d = this._coordsAscendingStr[u][s.tileID.key];
                d && d !== s.rttCoords[u] && (s.rtt = [])
              }
          }
          renderLayer(e, n) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const s = Object.assign(Object.assign({}, n), {
                isRenderingToTexture: !0
              }),
              u = e.type,
              d = this.painter,
              m = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (is[u] && (this._prevType && is[this._prevType] || this._stacks.push([]), this._prevType = u, this._stacks[this._stacks.length - 1].push(e.id), !m)) return !0;
            if (is[this._prevType] || is[u] && m) {
              this._prevType = u;
              const y = this._stacks.length - 1,
                b = this._stacks[y] || [];
              for (const P of this._renderableTiles) {
                if (this.pool.isFull() && (vl(this.painter, this.terrain, this._rttTiles, s), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(P), P.rtt[y]) {
                  const L = this.pool.getObjectForId(P.rtt[y].id);
                  if (L.stamp === P.rtt[y].stamp) {
                    this.pool.useObject(L);
                    continue
                  }
                }
                const M = this.pool.getOrCreateFreeObject();
                this.pool.useObject(M), this.pool.stampObject(M), P.rtt[y] = {
                  id: M.id,
                  stamp: M.stamp
                }, d.context.bindFramebuffer.set(M.fbo.framebuffer), d.context.clear({
                  color: o.bf.transparent,
                  stencil: 0
                }), d.currentStencilSource = void 0;
                for (let L = 0; L < b.length; L++) {
                  const z = d.style._layers[b[L]],
                    B = z.source ? this._coordsAscending[z.source][P.tileID.key] : [P.tileID];
                  d.context.viewport.set([0, 0, M.fbo.width, M.fbo.height]), d._renderTileClippingMasks(z, B, !0), d.renderLayer(d, d.style.sourceCaches[z.source], z, B, s), z.source && (P.rttCoords[z.source] = this._coordsAscendingStr[z.source][P.tileID.key])
                }
              }
              return vl(this.painter, this.terrain, this._rttTiles, s), this._rttTiles = [], this.pool.freeAllObjects(), is[u]
            }
            return !1
          }
        }
        const jn = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "MapLibre logo",
            "Map.Title": "Map",
            "Marker.Title": "Map marker",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "Popup.Close": "Close popup",
            "ScaleControl.Feet": "ft",
            "ScaleControl.Meters": "m",
            "ScaleControl.Kilometers": "km",
            "ScaleControl.Miles": "mi",
            "ScaleControl.NauticalMiles": "nm",
            "GlobeControl.Enable": "Enable globe",
            "GlobeControl.Disable": "Disable globe",
            "TerrainControl.Enable": "Enable terrain",
            "TerrainControl.Disable": "Disable terrain",
            "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
            "CooperativeGesturesHandler.MacHelpText": "Use âŒ˜ + scroll to zoom the map",
            "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
          },
          ed = G,
          ha = {
            hash: !1,
            interactive: !0,
            bearingSnap: 7,
            attributionControl: Wc,
            maplibreLogo: !1,
            refreshExpiredTiles: !0,
            canvasContextAttributes: {
              antialias: !1,
              preserveDrawingBuffer: !1,
              powerPreference: "high-performance",
              failIfMajorPerformanceCaveat: !1,
              desynchronized: !1,
              contextType: void 0
            },
            scrollZoom: !0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            trackResize: !0,
            center: [0, 0],
            elevation: 0,
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            renderWorldCopies: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: o.a.MAX_TILE_CACHE_ZOOM_LEVELS,
            transformRequest: null,
            transformCameraUpdate: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            clickTolerance: 3,
            localIdeographFontFamily: "sans-serif",
            pitchWithRotate: !0,
            rollEnabled: !1,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096],
            cancelPendingTileRequestsWhileZooming: !0,
            centerClampedToGround: !0
          },
          _p = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1,
            visualizeRoll: !0
          };
        class Do {
          constructor(e, n, s = !1) {
            this.mousedown = d => {
              this.startMove(d, K.mousePos(this.element, d)), K.addEventListener(window, "mousemove", this.mousemove), K.addEventListener(window, "mouseup", this.mouseup)
            }, this.mousemove = d => {
              this.move(d, K.mousePos(this.element, d))
            }, this.mouseup = d => {
              this._rotatePitchHandler.dragEnd(d), this.offTemp()
            }, this.touchstart = d => {
              d.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = K.touchPos(this.element, d.targetTouches)[0], this.startMove(d, this._startPos), K.addEventListener(window, "touchmove", this.touchmove, {
                passive: !1
              }), K.addEventListener(window, "touchend", this.touchend))
            }, this.touchmove = d => {
              d.targetTouches.length !== 1 ? this.reset() : (this._lastPos = K.touchPos(this.element, d.targetTouches)[0], this.move(d, this._lastPos))
            }, this.touchend = d => {
              d.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this._clickTolerance = 10, this.element = n;
            const u = new pp;
            this._rotatePitchHandler = new Zs({
              clickTolerance: 3,
              move: (d, m) => {
                const y = n.getBoundingClientRect(),
                  b = new o.P((y.bottom - y.top) / 2, (y.right - y.left) / 2);
                return {
                  bearingDelta: o.cn(new o.P(d.x, m.y), m, b),
                  pitchDelta: s ? -.5 * (m.y - d.y) : void 0
                }
              },
              moveStateManager: u,
              enable: !0,
              assignEvents: () => {}
            }), this.map = e, K.addEventListener(n, "mousedown", this.mousedown), K.addEventListener(n, "touchstart", this.touchstart, {
              passive: !1
            }), K.addEventListener(n, "touchcancel", this.reset)
          }
          startMove(e, n) {
            this._rotatePitchHandler.dragStart(e, n), K.disableDrag()
          }
          move(e, n) {
            const s = this.map,
              {
                bearingDelta: u,
                pitchDelta: d
              } = this._rotatePitchHandler.dragMove(e, n) || {};
            u && s.setBearing(s.getBearing() + u), d && s.setPitch(s.getPitch() + d)
          }
          off() {
            const e = this.element;
            K.removeEventListener(e, "mousedown", this.mousedown), K.removeEventListener(e, "touchstart", this.touchstart, {
              passive: !1
            }), K.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), K.removeEventListener(window, "touchend", this.touchend), K.removeEventListener(e, "touchcancel", this.reset), this.offTemp()
          }
          offTemp() {
            K.enableDrag(), K.removeEventListener(window, "mousemove", this.mousemove), K.removeEventListener(window, "mouseup", this.mouseup), K.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), K.removeEventListener(window, "touchend", this.touchend)
          }
        }
        let Ai;

        function Xi(h, e, n, s = !1) {
          if (s || !n.getCoveringTilesDetailsProvider().allowWorldCopies()) return h == null ? void 0 : h.wrap();
          const u = new o.S(h.lng, h.lat);
          if (h = new o.S(h.lng, h.lat), e) {
            const d = new o.S(h.lng - 360, h.lat),
              m = new o.S(h.lng + 360, h.lat),
              y = n.locationToScreenPoint(h).distSqr(e);
            n.locationToScreenPoint(d).distSqr(e) < y ? h = d : n.locationToScreenPoint(m).distSqr(e) < y && (h = m)
          }
          for (; Math.abs(h.lng - n.center.lng) > 180;) {
            const d = n.locationToScreenPoint(h);
            if (d.x >= 0 && d.y >= 0 && d.x <= n.width && d.y <= n.height) break;
            h.lng > n.center.lng ? h.lng -= 360 : h.lng += 360
          }
          return h.lng !== u.lng && n.isPointOnMapSurface(n.locationToScreenPoint(h)) ? h : u
        }
        const Il = {
          center: "translate(-50%,-50%)",
          top: "translate(-50%,0)",
          "top-left": "translate(0,0)",
          "top-right": "translate(-100%,0)",
          bottom: "translate(-50%,-100%)",
          "bottom-left": "translate(0,-100%)",
          "bottom-right": "translate(-100%,-100%)",
          left: "translate(0,-50%)",
          right: "translate(-100%,-50%)"
        };

        function Ws(h, e, n) {
          const s = h.classList;
          for (const u in Il) s.remove(`maplibregl-${n}-anchor-${u}`);
          s.add(`maplibregl-${n}-anchor-${e}`)
        }
        class Xs extends o.E {
          constructor(e) {
            if (super(), this._onKeyPress = n => {
                const s = n.code,
                  u = n.charCode || n.keyCode;
                s !== "Space" && s !== "Enter" && u !== 32 && u !== 13 || this.togglePopup()
              }, this._onMapClick = n => {
                const s = n.originalEvent.target,
                  u = this._element;
                this._popup && (s === u || u.contains(s)) && this.togglePopup()
              }, this._update = n => {
                if (!this._map) return;
                const s = this._map.loaded() && !this._map.isMoving();
                ((n == null ? void 0 : n.type) === "terrain" || (n == null ? void 0 : n.type) === "render" && !s) && this._map.once("render", this._update), this._lngLat = Xi(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                let u = "";
                this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? u = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (u = `rotateZ(${this._rotation-this._map.getBearing()}deg)`);
                let d = "";
                this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? d = "rotateX(0deg)" : this._pitchAlignment === "map" && (d = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || n && n.type !== "moveend" || (this._pos = this._pos.round()), K.setTransform(this._element, `${Il[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${d} ${u}`), xe.frameAsync(new AbortController).then((() => {
                  this._updateOpacity(n && n.type === "moveend")
                })).catch((() => {}))
              }, this._onMove = n => {
                if (!this._isDragging) {
                  const s = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = n.point.dist(this._pointerdownPos) >= s
                }
                this._isDragging && (this._pos = n.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.l("dragstart"))), this.fire(new o.l("drag")))
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new o.l("dragend")), this._state = "inactive"
              }, this._addDragHandler = n => {
                this._element.contains(n.originalEvent.target) && (n.preventDefault(), this._positionDelta = n.point.sub(this._pos).add(this._offset), this._pointerdownPos = n.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp))
              }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = o.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = K.create("div");
              const n = K.createNS("http://www.w3.org/2000/svg", "svg"),
                s = 41,
                u = 27;
              n.setAttributeNS(null, "display", "block"), n.setAttributeNS(null, "height", `${s}px`), n.setAttributeNS(null, "width", `${u}px`), n.setAttributeNS(null, "viewBox", `0 0 ${u} ${s}`);
              const d = K.createNS("http://www.w3.org/2000/svg", "g");
              d.setAttributeNS(null, "stroke", "none"), d.setAttributeNS(null, "stroke-width", "1"), d.setAttributeNS(null, "fill", "none"), d.setAttributeNS(null, "fill-rule", "evenodd");
              const m = K.createNS("http://www.w3.org/2000/svg", "g");
              m.setAttributeNS(null, "fill-rule", "nonzero");
              const y = K.createNS("http://www.w3.org/2000/svg", "g");
              y.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), y.setAttributeNS(null, "fill", "#000000");
              const b = [{
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "9.5",
                ry: "4.77275007"
              }, {
                rx: "8.5",
                ry: "4.29549936"
              }, {
                rx: "7.5",
                ry: "3.81822308"
              }, {
                rx: "6.5",
                ry: "3.34094679"
              }, {
                rx: "5.5",
                ry: "2.86367051"
              }, {
                rx: "4.5",
                ry: "2.38636864"
              }];
              for (const re of b) {
                const se = K.createNS("http://www.w3.org/2000/svg", "ellipse");
                se.setAttributeNS(null, "opacity", "0.04"), se.setAttributeNS(null, "cx", "10.5"), se.setAttributeNS(null, "cy", "5.80029008"), se.setAttributeNS(null, "rx", re.rx), se.setAttributeNS(null, "ry", re.ry), y.appendChild(se)
              }
              const P = K.createNS("http://www.w3.org/2000/svg", "g");
              P.setAttributeNS(null, "fill", this._color);
              const M = K.createNS("http://www.w3.org/2000/svg", "path");
              M.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), P.appendChild(M);
              const L = K.createNS("http://www.w3.org/2000/svg", "g");
              L.setAttributeNS(null, "opacity", "0.25"), L.setAttributeNS(null, "fill", "#000000");
              const z = K.createNS("http://www.w3.org/2000/svg", "path");
              z.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), L.appendChild(z);
              const B = K.createNS("http://www.w3.org/2000/svg", "g");
              B.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), B.setAttributeNS(null, "fill", "#FFFFFF");
              const U = K.createNS("http://www.w3.org/2000/svg", "g");
              U.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const Q = K.createNS("http://www.w3.org/2000/svg", "circle");
              Q.setAttributeNS(null, "fill", "#000000"), Q.setAttributeNS(null, "opacity", "0.25"), Q.setAttributeNS(null, "cx", "5.5"), Q.setAttributeNS(null, "cy", "5.5"), Q.setAttributeNS(null, "r", "5.4999962");
              const J = K.createNS("http://www.w3.org/2000/svg", "circle");
              J.setAttributeNS(null, "fill", "#FFFFFF"), J.setAttributeNS(null, "cx", "5.5"), J.setAttributeNS(null, "cy", "5.5"), J.setAttributeNS(null, "r", "5.4999962"), U.appendChild(Q), U.appendChild(J), m.appendChild(y), m.appendChild(P), m.appendChild(L), m.appendChild(B), m.appendChild(U), n.appendChild(m), n.setAttributeNS(null, "height", s * this._scale + "px"), n.setAttributeNS(null, "width", u * this._scale + "px"), this._element.appendChild(n), this._offset = o.P.convert(e && e.offset || [0, -14])
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (n => {
                n.preventDefault()
              })), this._element.addEventListener("mousedown", (n => {
                n.preventDefault()
              })), Ws(this._element, this._anchor, "marker"), e && e.className)
              for (const n of e.className.split(" ")) this._element.classList.add(n);
            this._popup = null
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), K.remove(this._element), this._popup && this._popup.remove(), this
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(e) {
            return this._lngLat = o.S.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this
          }
          getElement() {
            return this._element
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const u = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? {
                  top: [0, 0],
                  "top-left": [0, 0],
                  "top-right": [0, 0],
                  bottom: [0, -38.1],
                  "bottom-left": [u, -1 * (38.1 - 13.5 + u)],
                  "bottom-right": [-u, -1 * (38.1 - 13.5 + u)],
                  left: [13.5, -1 * (38.1 - 13.5)],
                  right: [-13.5, -1 * (38.1 - 13.5)]
                } : this._offset
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress)
            }
            return this
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this
          }
          getPopup() {
            return this._popup
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this
          }
          _updateOpacity(e = !1) {
            var n, s;
            const u = (n = this._map) === null || n === void 0 ? void 0 : n.terrain,
              d = this._map.transform.isLocationOccluded(this._lngLat);
            if (!u || d) {
              const B = d ? this._opacityWhenCovered : this._opacity;
              return void(this._element.style.opacity !== B && (this._element.style.opacity = B))
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null
              }), 100)
            }
            const m = this._map,
              y = m.terrain.depthAtPoint(this._pos),
              b = m.terrain.getElevationForLngLatZoom(this._lngLat, m.transform.tileZoom);
            if (m.transform.lngLatToCameraDepth(this._lngLat, b) - y < .006) return void(this._element.style.opacity = this._opacity);
            const P = -this._offset.y / m.transform.pixelsPerMeter,
              M = Math.sin(m.getPitch() * Math.PI / 180) * P,
              L = m.terrain.depthAtPoint(new o.P(this._pos.x, this._pos.y - this._offset.y)),
              z = m.transform.lngLatToCameraDepth(this._lngLat, b + M) - L > .006;
            !((s = this._popup) === null || s === void 0) && s.isOpen() && z && this._popup.remove(), this._element.style.opacity = z ? this._opacityWhenCovered : this._opacity
          }
          getOffset() {
            return this._offset
          }
          setOffset(e) {
            return this._offset = o.P.convert(e), this._update(), this
          }
          addClassName(e) {
            this._element.classList.add(e)
          }
          removeClassName(e) {
            this._element.classList.remove(e)
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e)
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this
          }
          isDraggable() {
            return this._draggable
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this
          }
          getRotation() {
            return this._rotation
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this
          }
          getRotationAlignment() {
            return this._rotationAlignment
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this
          }
          getPitchAlignment() {
            return this._pitchAlignment
          }
          setOpacity(e, n) {
            return (this._opacity === void 0 || e === void 0 && n === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), n !== void 0 && (this._opacityWhenCovered = n), this._map && this._updateOpacity(!0), this
          }
        }
        const Kc = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3
          },
          fitBoundsOptions: {
            maxZoom: 15
          },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0
        };
        let Ks = 0,
          Cs = !1;
        const Ro = {
          maxWidth: 100,
          unit: "metric"
        };

        function Ml(h, e, n) {
          const s = n && n.maxWidth || 100,
            u = h._container.clientHeight / 2,
            d = h._container.clientWidth / 2,
            m = h.unproject([d - s / 2, u]),
            y = h.unproject([d + s / 2, u]),
            b = Math.round(h.project(y).x - h.project(m).x),
            P = Math.min(s, b, h._container.clientWidth),
            M = m.distanceTo(y);
          if (n && n.unit === "imperial") {
            const L = 3.2808 * M;
            L > 5280 ? Ss(e, P, L / 5280, h._getUIString("ScaleControl.Miles")) : Ss(e, P, L, h._getUIString("ScaleControl.Feet"))
          } else n && n.unit === "nautical" ? Ss(e, P, M / 1852, h._getUIString("ScaleControl.NauticalMiles")) : M >= 1e3 ? Ss(e, P, M / 1e3, h._getUIString("ScaleControl.Kilometers")) : Ss(e, P, M, h._getUIString("ScaleControl.Meters"))
        }

        function Ss(h, e, n, s) {
          const u = (function(d) {
            const m = Math.pow(10, `${Math.floor(d)}`.length - 1);
            let y = d / m;
            return y = y >= 10 ? 10 : y >= 5 ? 5 : y >= 3 ? 3 : y >= 2 ? 2 : y >= 1 ? 1 : (function(b) {
              const P = Math.pow(10, Math.ceil(-Math.log(b) / Math.LN10));
              return Math.round(b * P) / P
            })(y), m * y
          })(n);
          h.style.width = e * (u / n) + "px", h.innerHTML = `${u}&nbsp;${s}`
        }
        const Yc = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            subpixelPositioning: !1,
            locationOccludedOpacity: void 0
          },
          Jc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

        function Al(h) {
          if (h) {
            if (typeof h == "number") {
              const e = Math.round(Math.abs(h) / Math.SQRT2);
              return {
                center: new o.P(0, 0),
                top: new o.P(0, h),
                "top-left": new o.P(e, e),
                "top-right": new o.P(-e, e),
                bottom: new o.P(0, -h),
                "bottom-left": new o.P(e, -e),
                "bottom-right": new o.P(-e, -e),
                left: new o.P(h, 0),
                right: new o.P(-h, 0)
              }
            }
            if (h instanceof o.P || Array.isArray(h)) {
              const e = o.P.convert(h);
              return {
                center: e,
                top: e,
                "top-left": e,
                "top-right": e,
                bottom: e,
                "bottom-left": e,
                "bottom-right": e,
                left: e,
                right: e
              }
            }
            return {
              center: o.P.convert(h.center || [0, 0]),
              top: o.P.convert(h.top || [0, 0]),
              "top-left": o.P.convert(h["top-left"] || [0, 0]),
              "top-right": o.P.convert(h["top-right"] || [0, 0]),
              bottom: o.P.convert(h.bottom || [0, 0]),
              "bottom-left": o.P.convert(h["bottom-left"] || [0, 0]),
              "bottom-right": o.P.convert(h["bottom-right"] || [0, 0]),
              left: o.P.convert(h.left || [0, 0]),
              right: o.P.convert(h.right || [0, 0])
            }
          }
          return Al(new o.P(0, 0))
        }
        const Qc = G;
        T.AJAXError = o.cz, T.Event = o.l, T.Evented = o.E, T.LngLat = o.S, T.MercatorCoordinate = o.a1, T.Point = o.P, T.addProtocol = o.cA, T.config = o.a, T.removeProtocol = o.cB, T.AttributionControl = Xc, T.BoxZoomHandler = qc, T.CanvasSource = gr, T.CooperativeGesturesHandler = Yh, T.DoubleClickZoomHandler = Zc, T.DragPanHandler = Xh, T.DragRotateHandler = Gc, T.EdgeInsets = Yi, T.FullscreenControl = class extends o.E {
          constructor(h = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let n = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = n == null ? void 0 : n.shadowRoot) === null || e === void 0) && e.fullscreenElement;) n = n.shadowRoot.fullscreenElement;
              n === this._container !== this._fullscreen && this._handleFullscreenChange()
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
            }, this._fullscreen = !1, h && h.container && (h.container instanceof HTMLElement ? this._container = h.container : o.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange")
          }
          onAdd(h) {
            return this._map = h, this._container || (this._container = this._map.getContainer()), this._controlContainer = K.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer
          }
          onRemove() {
            K.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _setupUI() {
            const h = this._fullscreenButton = K.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            K.create("span", "maplibregl-ctrl-icon", h).setAttribute("aria-hidden", "true"), h.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _updateTitle() {
            const h = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", h), this._fullscreenButton.title = h
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
          }
          _isFullscreen() {
            return this._fullscreen
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new o.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new o.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize()
          }
        }, T.GeoJSONSource = nr, T.GeolocateControl = class extends o.E {
          constructor(h) {
            super(), this._onSuccess = e => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new o.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`)
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new o.l("geolocate", e)), this._finish()
              }
            }, this._updateCamera = e => {
              const n = new o.S(e.coords.longitude, e.coords.latitude),
                s = e.coords.accuracy,
                u = this._map.getBearing(),
                d = o.e({
                  bearing: u
                }, this.options.fitBoundsOptions),
                m = ht.fromLngLat(n, s);
              this._map.fitBounds(m, d, {
                geolocateSource: !0
              })
            }, this._updateMarker = e => {
              if (e) {
                const n = new o.S(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(n).addTo(this._map), this._userLocationDotMarker.setLngLat(n).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
            }, this._onError = e => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n), this._geolocationWatchID !== void 0 && this._clearWatch()
                } else {
                  if (e.code === 3 && Cs) return;
                  this.options.trackUserLocation && this._setErrorState()
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new o.l("error", e)), this._finish()
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e => e.preventDefault())), this._geolocateButton = K.create("button", "maplibregl-ctrl-geolocate", this._container), K.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0)
            }, this._finishSetupUI = e => {
              if (this._map) {
                if (e === !1) {
                  o.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n)
                } else {
                  const n = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n)
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = K.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Xs({
                  element: this._dotElement
                }), this._circleElement = K.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Xs({
                  element: this._circleElement,
                  pitchAlignment: "map"
                }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (n => {
                  const s = (n == null ? void 0 : n[0]) instanceof ResizeObserverEntry;
                  n.geolocateSource || this._watchState !== "ACTIVE_LOCK" || s || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new o.l("trackuserlocationend")), this.fire(new o.l("userlocationlostfocus")))
                }))
              }
            }, this.options = o.e({}, Kc, h)
          }
          onAdd(h) {
            return this._map = h, this._container = K.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return o._(this, arguments, void 0, (function*(e = !1) {
                if (Ai !== void 0 && !e) return Ai;
                if (window.navigator.permissions === void 0) return Ai = !!window.navigator.geolocation, Ai;
                try {
                  Ai = (yield window.navigator.permissions.query({
                    name: "geolocation"
                  })).state !== "denied"
                } catch {
                  Ai = !!window.navigator.geolocation
                }
                return Ai
              }))
            })().then((e => this._finishSetupUI(e))), this._container
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), K.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ks = 0, Cs = !1
          }
          _isOutOfMapMaxBounds(h) {
            const e = this._map.getMaxBounds(),
              n = h.coords;
            return e && (n.longitude < e.getWest() || n.longitude > e.getEast() || n.latitude < e.getSouth() || n.latitude > e.getNorth())
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`)
            }
          }
          _updateCircleRadius() {
            const h = this._map.getBounds(),
              e = h.getSouthEast(),
              n = h.getNorthEast(),
              s = e.distanceTo(n),
              u = Math.ceil(this._accuracy / (s / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${u}px`, this._circleElement.style.height = `${u}px`
          }
          trigger() {
            if (!this._setup) return o.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new o.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Ks--, Cs = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new o.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.l("trackuserlocationstart")), this.fire(new o.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let h;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ks++, Ks > 1 ? (h = {
                  maximumAge: 6e5,
                  timeout: 0
                }, Cs = !0) : (h = this.options.positionOptions, Cs = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, h)
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
          }
        }, T.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var h;
              const e = (h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type;
              this._map.setProjection(e !== "mercator" && e ? {
                type: "mercator"
              } : {
                type: "globe"
              }), this._updateGlobeIcon()
            }, this._updateGlobeIcon = () => {
              var h;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
            }
          }
          onAdd(h) {
            return this._map = h, this._container = K.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = K.create("button", "maplibregl-ctrl-globe", this._container), K.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container
          }
          onRemove() {
            K.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0
          }
        }, T.Hash = yl, T.ImageSource = Bt, T.KeyboardHandler = wl, T.LngLatBounds = ht, T.LogoControl = Qh, T.Map = class extends Jh {
          constructor(h) {
            var e, n;
            o.cw.mark(o.cx.create);
            const s = Object.assign(Object.assign(Object.assign({}, ha), h), {
              canvasContextAttributes: Object.assign(Object.assign({}, ha.canvasContextAttributes), h.canvasContextAttributes)
            });
            if (s.minZoom != null && s.maxZoom != null && s.minZoom > s.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (s.minPitch != null && s.maxPitch != null && s.minPitch > s.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (s.minPitch != null && s.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (s.maxPitch != null && s.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const u = new ci,
              d = new hn;
            if (s.minZoom !== void 0 && u.setMinZoom(s.minZoom), s.maxZoom !== void 0 && u.setMaxZoom(s.maxZoom), s.minPitch !== void 0 && u.setMinPitch(s.minPitch), s.maxPitch !== void 0 && u.setMaxPitch(s.maxPitch), s.renderWorldCopies !== void 0 && u.setRenderWorldCopies(s.renderWorldCopies), super(u, d, {
                bearingSnap: s.bearingSnap
              }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Oa, this._controls = [], this._mapId = o.a7(), this._contextLost = y => {
                y.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new o.l("webglcontextlost", {
                  originalEvent: y
                }))
              }, this._contextRestored = y => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new o.l("webglcontextrestored", {
                  originalEvent: y
                }))
              }, this._onMapScroll = y => {
                if (y.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
              }, this._onWindowOnline = () => {
                this._update()
              }, this._interactive = s.interactive, this._maxTileCacheSize = s.maxTileCacheSize, this._maxTileCacheZoomLevels = s.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, s.canvasContextAttributes), this._trackResize = s.trackResize === !0, this._bearingSnap = s.bearingSnap, this._centerClampedToGround = s.centerClampedToGround, this._refreshExpiredTiles = s.refreshExpiredTiles === !0, this._fadeDuration = s.fadeDuration, this._crossSourceCollisions = s.crossSourceCollisions === !0, this._collectResourceTiming = s.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, jn), s.locale), this._clickTolerance = s.clickTolerance, this._overridePixelRatio = s.pixelRatio, this._maxCanvasSize = s.maxCanvasSize, this.transformCameraUpdate = s.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = s.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Fe.addThrottleControl((() => this.isMoving())), this._requestManager = new mt(s.transformRequest), typeof s.container == "string") {
              if (this._container = document.getElementById(s.container), !this._container) throw new Error(`Container '${s.container}' not found.`)
            } else {
              if (!(s.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = s.container
            }
            if (s.maxBounds && this.setMaxBounds(s.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
                this.painter.terrainFacilitator.dirty = !0, this._update(!0)
              })), this.once("idle", (() => {
                this._idleTriggered = !0
              })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let y = !1;
              const b = ws((P => {
                this._trackResize && !this._removed && (this.resize(P), this.redraw())
              }), 50);
              this._resizeObserver = new ResizeObserver((P => {
                y ? b(P) : y = !0
              })), this._resizeObserver.observe(this._container)
            }
            this.handlers = new Hc(this, s), this._hash = s.hash && new yl(typeof s.hash == "string" && s.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
              center: s.center,
              elevation: s.elevation,
              zoom: s.zoom,
              bearing: s.bearing,
              pitch: s.pitch,
              roll: s.roll
            }), s.bounds && (this.resize(), this.fitBounds(s.bounds, o.e({}, s.fitBoundsOptions, {
              duration: 0
            }))));
            const m = typeof s.style == "string" || ((n = (e = s.style) === null || e === void 0 ? void 0 : e.projection) === null || n === void 0 ? void 0 : n.type) !== "globe";
            this.resize(null, m), this._localIdeographFontFamily = s.localIdeographFontFamily, this._validateStyle = s.validateStyle, s.style && this.setStyle(s.style, {
              localIdeographFontFamily: s.localIdeographFontFamily
            }), s.attributionControl && this.addControl(new Xc(typeof s.attributionControl == "boolean" ? void 0 : s.attributionControl)), s.maplibreLogo && this.addControl(new Qh, s.logoPosition), this.on("style.load", (() => {
              if (m || this._resizeTransform(), this.transform.unmodified) {
                const y = o.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(y)
              }
            })), this.on("data", (y => {
              this._update(y.dataType === "style"), this.fire(new o.l(`${y.dataType}data`, y))
            })), this.on("dataloading", (y => {
              this.fire(new o.l(`${y.dataType}dataloading`, y))
            })), this.on("dataabort", (y => {
              this.fire(new o.l("sourcedataabort", y))
            }))
          }
          _getMapId() {
            return this._mapId
          }
          setGlobalStateProperty(h, e) {
            return this.style.setGlobalStateProperty(h, e), this._update(!0)
          }
          getGlobalState() {
            return this.style.getGlobalState()
          }
          addControl(h, e) {
            if (e === void 0 && (e = h.getDefaultPosition ? h.getDefaultPosition() : "top-right"), !h || !h.onAdd) return this.fire(new o.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const n = h.onAdd(this);
            this._controls.push(h);
            const s = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? s.insertBefore(n, s.firstChild) : s.appendChild(n), this
          }
          removeControl(h) {
            if (!h || !h.onRemove) return this.fire(new o.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(h);
            return e > -1 && this._controls.splice(e, 1), h.onRemove(this), this
          }
          hasControl(h) {
            return this._controls.indexOf(h) > -1
          }
          calculateCameraOptionsFromTo(h, e, n, s) {
            return s == null && this.terrain && (s = this.terrain.getElevationForLngLatZoom(n, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(h, e, n, s)
          }
          resize(h, e = !0) {
            const [n, s] = this._containerDimensions(), u = this._getClampedPixelRatio(n, s);
            if (this._resizeCanvas(n, s, u), this.painter.resize(n, s, u), this.painter.overLimit()) {
              const m = this.painter.context.gl;
              this._maxCanvasSize = [m.drawingBufferWidth, m.drawingBufferHeight];
              const y = this._getClampedPixelRatio(n, s);
              this._resizeCanvas(n, s, y), this.painter.resize(n, s, y)
            }
            this._resizeTransform(e);
            const d = !this._moving;
            return d && (this.stop(), this.fire(new o.l("movestart", h)).fire(new o.l("move", h))), this.fire(new o.l("resize", h)), d && this.fire(new o.l("moveend", h)), this
          }
          _resizeTransform(h = !0) {
            var e;
            const [n, s] = this._containerDimensions();
            this.transform.resize(n, s, h), (e = this._requestedCameraState) === null || e === void 0 || e.resize(n, s, h)
          }
          _getClampedPixelRatio(h, e) {
            const {
              0: n,
              1: s
            } = this._maxCanvasSize, u = this.getPixelRatio(), d = h * u, m = e * u;
            return Math.min(d > n ? n / d : 1, m > s ? s / m : 1) * u
          }
          getPixelRatio() {
            var h;
            return (h = this._overridePixelRatio) !== null && h !== void 0 ? h : devicePixelRatio
          }
          setPixelRatio(h) {
            this._overridePixelRatio = h, this.resize()
          }
          getBounds() {
            return this.transform.getBounds()
          }
          getMaxBounds() {
            return this.transform.getMaxBounds()
          }
          setMaxBounds(h) {
            return this.transform.setMaxBounds(ht.convert(h)), this._update()
          }
          setMinZoom(h) {
            if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom) return this.transform.setMinZoom(h), this._update(), this.getZoom() < h && this.setZoom(h), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
          }
          getMinZoom() {
            return this.transform.minZoom
          }
          setMaxZoom(h) {
            if ((h = h ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(h), this._update(), this.getZoom() > h && this.setZoom(h), this;
            throw new Error("maxZoom must be greater than the current minZoom")
          }
          getMaxZoom() {
            return this.transform.maxZoom
          }
          setMinPitch(h) {
            if ((h = h ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (h >= 0 && h <= this.transform.maxPitch) return this.transform.setMinPitch(h), this._update(), this.getPitch() < h && this.setPitch(h), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
          }
          getMinPitch() {
            return this.transform.minPitch
          }
          setMaxPitch(h) {
            if ((h = h ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (h >= this.transform.minPitch) return this.transform.setMaxPitch(h), this._update(), this.getPitch() > h && this.setPitch(h), this;
            throw new Error("maxPitch must be greater than the current minPitch")
          }
          getMaxPitch() {
            return this.transform.maxPitch
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies
          }
          setRenderWorldCopies(h) {
            return this.transform.setRenderWorldCopies(h), this._update()
          }
          project(h) {
            return this.transform.locationToScreenPoint(o.S.convert(h), this.style && this.terrain)
          }
          unproject(h) {
            return this.transform.screenPointToLocation(o.P.convert(h), this.terrain)
          }
          isMoving() {
            var h;
            return this._moving || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isMoving())
          }
          isZooming() {
            var h;
            return this._zooming || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isZooming())
          }
          isRotating() {
            var h;
            return this._rotating || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isRotating())
          }
          _createDelegatedListener(h, e, n) {
            if (h === "mouseenter" || h === "mouseover") {
              let s = !1;
              return {
                layers: e,
                listener: n,
                delegates: {
                  mousemove: d => {
                    const m = e.filter((b => this.getLayer(b))),
                      y = m.length !== 0 ? this.queryRenderedFeatures(d.point, {
                        layers: m
                      }) : [];
                    y.length ? s || (s = !0, n.call(this, new Xn(h, this, d.originalEvent, {
                      features: y
                    }))) : s = !1
                  },
                  mouseout: () => {
                    s = !1
                  }
                }
              }
            }
            if (h === "mouseleave" || h === "mouseout") {
              let s = !1;
              return {
                layers: e,
                listener: n,
                delegates: {
                  mousemove: m => {
                    const y = e.filter((b => this.getLayer(b)));
                    (y.length !== 0 ? this.queryRenderedFeatures(m.point, {
                      layers: y
                    }) : []).length ? s = !0 : s && (s = !1, n.call(this, new Xn(h, this, m.originalEvent)))
                  },
                  mouseout: m => {
                    s && (s = !1, n.call(this, new Xn(h, this, m.originalEvent)))
                  }
                }
              }
            } {
              const s = u => {
                const d = e.filter((y => this.getLayer(y))),
                  m = d.length !== 0 ? this.queryRenderedFeatures(u.point, {
                    layers: d
                  }) : [];
                m.length && (u.features = m, n.call(this, u), delete u.features)
              };
              return {
                layers: e,
                listener: n,
                delegates: {
                  [h]: s
                }
              }
            }
          }
          _saveDelegatedListener(h, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[h] = this._delegatedListeners[h] || [], this._delegatedListeners[h].push(e)
          }
          _removeDelegatedListener(h, e, n) {
            if (!this._delegatedListeners || !this._delegatedListeners[h]) return;
            const s = this._delegatedListeners[h];
            for (let u = 0; u < s.length; u++) {
              const d = s[u];
              if (d.listener === n && d.layers.length === e.length && d.layers.every((m => e.includes(m)))) {
                for (const m in d.delegates) this.off(m, d.delegates[m]);
                return void s.splice(u, 1)
              }
            }
          }
          on(h, e, n) {
            if (n === void 0) return super.on(h, e);
            const s = typeof e == "string" ? [e] : e,
              u = this._createDelegatedListener(h, s, n);
            this._saveDelegatedListener(h, u);
            for (const d in u.delegates) this.on(d, u.delegates[d]);
            return {
              unsubscribe: () => {
                this._removeDelegatedListener(h, s, n)
              }
            }
          }
          once(h, e, n) {
            if (n === void 0) return super.once(h, e);
            const s = typeof e == "string" ? [e] : e,
              u = this._createDelegatedListener(h, s, n);
            for (const d in u.delegates) {
              const m = u.delegates[d];
              u.delegates[d] = (...y) => {
                this._removeDelegatedListener(h, s, n), m(...y)
              }
            }
            this._saveDelegatedListener(h, u);
            for (const d in u.delegates) this.once(d, u.delegates[d]);
            return this
          }
          off(h, e, n) {
            return n === void 0 ? super.off(h, e) : (this._removeDelegatedListener(h, typeof e == "string" ? [e] : e, n), this)
          }
          queryRenderedFeatures(h, e) {
            if (!this.style) return [];
            let n;
            const s = h instanceof o.P || Array.isArray(h),
              u = s ? h : [
                [0, 0],
                [this.transform.width, this.transform.height]
              ];
            if (e = e || (s ? {} : h) || {}, u instanceof o.P || typeof u[0] == "number") n = [o.P.convert(u)];
            else {
              const d = o.P.convert(u[0]),
                m = o.P.convert(u[1]);
              n = [d, new o.P(m.x, d.y), m, new o.P(d.x, m.y), d]
            }
            return this.style.queryRenderedFeatures(n, e, this.transform)
          }
          querySourceFeatures(h, e) {
            return this.style.querySourceFeatures(h, e)
          }
          setStyle(h, e) {
            return (e = o.e({}, {
              localIdeographFontFamily: this._localIdeographFontFamily,
              validate: this._validateStyle
            }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && h ? (this._diffStyle(h, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(h, e))
          }
          setTransformRequest(h) {
            return this._requestManager.setTransformRequest(h), this
          }
          _getUIString(h) {
            const e = this._locale[h];
            if (e == null) throw new Error(`Missing UI string '${h}'`);
            return e
          }
          _updateStyle(h, e) {
            var n, s;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(h, e)));
            const u = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!h)), h ? (this.style = new _c(this, e || {}), this.style.setEventedParent(this, {
              style: this.style
            }), typeof h == "string" ? this.style.loadURL(h, e, u) : this.style.loadJSON(h, e, u), this) : ((s = (n = this.style) === null || n === void 0 ? void 0 : n.projection) === null || s === void 0 || s.destroy(), delete this.style, this)
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new _c(this, {}), this.style.setEventedParent(this, {
              style: this.style
            }), this.style.loadEmpty())
          }
          _diffStyle(h, e) {
            if (typeof h == "string") {
              const n = this._requestManager.transformRequest(h, "Style");
              o.j(n, new AbortController).then((s => {
                this._updateDiff(s.data, e)
              })).catch((s => {
                s && this.fire(new o.k(s))
              }))
            } else typeof h == "object" && this._updateDiff(h, e)
          }
          _updateDiff(h, e) {
            try {
              this.style.setState(h, e) && this._update(!0)
            } catch (n) {
              o.w(`Unable to perform style diff: ${n.message||n.error||n}.  Rebuilding the style from scratch.`), this._updateStyle(h, e)
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize()
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : o.w("There is no style added to the map.")
          }
          addSource(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(h, e), this._update(!0)
          }
          isSourceLoaded(h) {
            const e = this.style && this.style.sourceCaches[h];
            if (e !== void 0) return e.loaded();
            this.fire(new o.k(new Error(`There is no source with ID '${h}'`)))
          }
          setTerrain(h) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), h) {
              const e = this.style.sourceCaches[h.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${h.source}`);
              this.terrain === null && e.reload();
              for (const n in this.style._layers) {
                const s = this.style._layers[n];
                s.type === "hillshade" && s.source === h.source && o.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), s.type === "color-relief" && s.source === h.source && o.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
              }
              this.terrain = new Lr(this.painter, e, h), this.painter.renderToTexture = new Pl(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = n => {
                var s;
                n.dataType === "style" ? this.terrain.sourceCache.freeRtt() : n.dataType === "source" && n.tile && (n.sourceId !== h.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((s = n.source) === null || s === void 0 ? void 0 : s.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(n.tile.tileID))
              }, this.style.on("data", this._terrainDataCallback)
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new o.l("terrain", {
              terrain: h
            })), this
          }
          getTerrain() {
            var h, e;
            return (e = (h = this.terrain) === null || h === void 0 ? void 0 : h.options) !== null && e !== void 0 ? e : null
          }
          areTilesLoaded() {
            const h = this.style && this.style.sourceCaches;
            for (const e in h) {
              const n = h[e]._tiles;
              for (const s in n) {
                const u = n[s];
                if (u.state !== "loaded" && u.state !== "errored") return !1
              }
            }
            return !0
          }
          removeSource(h) {
            return this.style.removeSource(h), this._update(!0)
          }
          getSource(h) {
            return this.style.getSource(h)
          }
          setSourceTileLodParams(h, e, n) {
            if (n) {
              const s = this.getSource(n);
              if (!s) throw new Error(`There is no source with ID "${n}", cannot set LOD parameters`);
              s.calculateTileZoom = it(Math.max(1, h), Math.max(1, e))
            } else
              for (const s in this.style.sourceCaches) this.style.sourceCaches[s].getSource().calculateTileZoom = it(Math.max(1, h), Math.max(1, e));
            return this._update(!0), this
          }
          refreshTiles(h, e) {
            const n = this.style.sourceCaches[h];
            if (!n) throw new Error(`There is no source cache with ID "${h}", cannot refresh tile`);
            e === void 0 ? n.reload(!0) : n.refreshTiles(e.map((s => new o.a4(s.z, s.x, s.y))))
          }
          addImage(h, e, n = {}) {
            const {
              pixelRatio: s = 1,
              sdf: u = !1,
              stretchX: d,
              stretchY: m,
              content: y,
              textFitWidth: b,
              textFitHeight: P
            } = n;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || o.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new o.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const {
                  width: M,
                  height: L,
                  data: z
                } = e, B = e;
                return this.style.addImage(h, {
                  data: new o.R({
                    width: M,
                    height: L
                  }, new Uint8Array(z)),
                  pixelRatio: s,
                  stretchX: d,
                  stretchY: m,
                  content: y,
                  textFitWidth: b,
                  textFitHeight: P,
                  sdf: u,
                  version: 0,
                  userImage: B
                }), B.onAdd && B.onAdd(this, h), this
              }
            } {
              const {
                width: M,
                height: L,
                data: z
              } = xe.getImageData(e);
              this.style.addImage(h, {
                data: new o.R({
                  width: M,
                  height: L
                }, z),
                pixelRatio: s,
                stretchX: d,
                stretchY: m,
                content: y,
                textFitWidth: b,
                textFitHeight: P,
                sdf: u,
                version: 0
              })
            }
          }
          updateImage(h, e) {
            const n = this.style.getImage(h);
            if (!n) return this.fire(new o.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const s = e instanceof HTMLImageElement || o.b(e) ? xe.getImageData(e) : e,
              {
                width: u,
                height: d,
                data: m
              } = s;
            if (u === void 0 || d === void 0) return this.fire(new o.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (u !== n.data.width || d !== n.data.height) return this.fire(new o.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const y = !(e instanceof HTMLImageElement || o.b(e));
            return n.data.replace(m, y), this.style.updateImage(h, n), this
          }
          getImage(h) {
            return this.style.getImage(h)
          }
          hasImage(h) {
            return h ? !!this.style.getImage(h) : (this.fire(new o.k(new Error("Missing required image id"))), !1)
          }
          removeImage(h) {
            this.style.removeImage(h)
          }
          loadImage(h) {
            return Fe.getImage(this._requestManager.transformRequest(h, "Image"), new AbortController)
          }
          listImages() {
            return this.style.listImages()
          }
          addLayer(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(h, e), this._update(!0)
          }
          moveLayer(h, e) {
            return this.style.moveLayer(h, e), this._update(!0)
          }
          removeLayer(h) {
            return this.style.removeLayer(h), this._update(!0)
          }
          getLayer(h) {
            return this.style.getLayer(h)
          }
          getLayersOrder() {
            return this.style.getLayersOrder()
          }
          setLayerZoomRange(h, e, n) {
            return this.style.setLayerZoomRange(h, e, n), this._update(!0)
          }
          setFilter(h, e, n = {}) {
            return this.style.setFilter(h, e, n), this._update(!0)
          }
          getFilter(h) {
            return this.style.getFilter(h)
          }
          setPaintProperty(h, e, n, s = {}) {
            return this.style.setPaintProperty(h, e, n, s), this._update(!0)
          }
          getPaintProperty(h, e) {
            return this.style.getPaintProperty(h, e)
          }
          setLayoutProperty(h, e, n, s = {}) {
            return this.style.setLayoutProperty(h, e, n, s), this._update(!0)
          }
          getLayoutProperty(h, e) {
            return this.style.getLayoutProperty(h, e)
          }
          setGlyphs(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(h, e), this._update(!0)
          }
          getGlyphs() {
            return this.style.getGlyphsUrl()
          }
          addSprite(h, e, n = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(h, e, n, (s => {
              s || this._update(!0)
            })), this
          }
          removeSprite(h) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(h), this._update(!0)
          }
          getSprite() {
            return this.style.getSprite()
          }
          setSprite(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(h, e, (n => {
              n || this._update(!0)
            })), this
          }
          setLight(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(h, e), this._update(!0)
          }
          getLight() {
            return this.style.getLight()
          }
          setSky(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(h, e), this._update(!0)
          }
          getSky() {
            return this.style.getSky()
          }
          setFeatureState(h, e) {
            return this.style.setFeatureState(h, e), this._update()
          }
          removeFeatureState(h, e) {
            return this.style.removeFeatureState(h, e), this._update()
          }
          getFeatureState(h) {
            return this.style.getFeatureState(h)
          }
          getContainer() {
            return this._container
          }
          getCanvasContainer() {
            return this._canvasContainer
          }
          getCanvas() {
            return this._canvas
          }
          _containerDimensions() {
            let h = 0,
              e = 0;
            return this._container && (h = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [h, e]
          }
          _setupContainer() {
            const h = this._container;
            h.classList.add("maplibregl-map");
            const e = this._canvasContainer = K.create("div", "maplibregl-canvas-container", h);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = K.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const n = this._containerDimensions(),
              s = this._getClampedPixelRatio(n[0], n[1]);
            this._resizeCanvas(n[0], n[1], s);
            const u = this._controlContainer = K.create("div", "maplibregl-control-container", h),
              d = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((m => {
              d[m] = K.create("div", `maplibregl-ctrl-${m} `, u)
            })), this._container.addEventListener("scroll", this._onMapScroll, !1)
          }
          _resizeCanvas(h, e, n) {
            this._canvas.width = Math.floor(n * h), this._canvas.height = Math.floor(n * e), this._canvas.style.width = `${h}px`, this._canvas.style.height = `${e}px`
          }
          _setupPainter() {
            const h = Object.assign(Object.assign({}, this._canvasContextAttributes), {
              alpha: !0,
              depth: !0,
              stencil: !0,
              premultipliedAlpha: !0
            });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", (s => {
              e = {
                requestedAttributes: h
              }, s && (e.statusMessage = s.statusMessage, e.type = s.type)
            }), {
              once: !0
            });
            let n = null;
            if (n = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, h) : this._canvas.getContext("webgl2", h) || this._canvas.getContext("webgl", h), !n) {
              const s = "Failed to initialize WebGL";
              throw e ? (e.message = s, new Error(JSON.stringify(e))) : new Error(s)
            }
            this.painter = new Oh(n, this.transform), Ie.testSupport(n)
          }
          migrateProjection(h, e) {
            super.migrateProjection(h, e), this.painter.transform = h, this.fire(new o.l("projectiontransition", {
              newProjection: this.style.projection.name
            }))
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
          }
          _update(h) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || h, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
          }
          _requestRenderFrame(h) {
            return this._update(), this._renderTaskQueue.add(h)
          }
          _cancelRenderFrame(h) {
            this._renderTaskQueue.remove(h)
          }
          _render(h) {
            var e, n, s, u, d;
            const m = this._idleTriggered ? this._fadeDuration : 0,
              y = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(h), this._removed) return;
            let b = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const L = this.transform.zoom,
                z = xe.now();
              this.style.zoomHistory.update(L, z);
              const B = new o.F(L, {
                  now: z,
                  fadeDuration: m,
                  zoomHistory: this.style.zoomHistory,
                  transition: this.style.getTransition(),
                  globalState: this.style.getGlobalState()
                }),
                U = B.crossFadingFactor();
              U === 1 && U === this._crossFadingFactor || (b = !0, this._crossFadingFactor = U), this.style.update(B)
            }
            const P = ((n = this.style.projection) === null || n === void 0 ? void 0 : n.transitionState) > 0 !== y;
            (s = this.style.projection) === null || s === void 0 || s.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((u = this.style.projection) === null || u === void 0 ? void 0 : u.transitionState, (d = this.style.projection) === null || d === void 0 ? void 0 : d.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || P) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, m, this._crossSourceCollisions, P), this.painter.render(this.style, {
              showTileBoundaries: this.showTileBoundaries,
              showOverdrawInspector: this._showOverdrawInspector,
              rotating: this.isRotating(),
              zooming: this.isZooming(),
              moving: this.isMoving(),
              fadeDuration: m,
              showPadding: this.showPadding
            }), this.fire(new o.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, o.cw.mark(o.cx.load), this.fire(new o.l("load"))), this.style && (this.style.hasTransitions() || b) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const M = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return M || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.l("idle")), !this._loaded || this._fullyLoaded || M || (this._fullyLoaded = !0, o.cw.mark(o.cx.fullLoad)), this
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this
          }
          remove() {
            var h;
            this._hash && this._hash.remove();
            for (const n of this._controls) n.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Fe.removeThrottleControl(this._imageQueueHandle), (h = this._resizeObserver) === null || h === void 0 || h.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), K.remove(this._canvasContainer), K.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), o.cw.clearMetrics(), this._removed = !0, this.fire(new o.l("remove"))
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController, xe.frame(this._frameRequest, (h => {
              o.cw.frame(h), this._frameRequest = null;
              try {
                this._render(h)
              } catch (e) {
                if (!o.cy(e) && !(function(n) {
                    return n.message === Co
                  })(e)) throw e
              }
            }), (() => {})))
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries
          }
          set showTileBoundaries(h) {
            this._showTileBoundaries !== h && (this._showTileBoundaries = h, this._update())
          }
          get showPadding() {
            return !!this._showPadding
          }
          set showPadding(h) {
            this._showPadding !== h && (this._showPadding = h, this._update())
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes
          }
          set showCollisionBoxes(h) {
            this._showCollisionBoxes !== h && (this._showCollisionBoxes = h, h ? this.style._generateCollisionBoxes() : this._update())
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector
          }
          set showOverdrawInspector(h) {
            this._showOverdrawInspector !== h && (this._showOverdrawInspector = h, this._update())
          }
          get repaint() {
            return !!this._repaint
          }
          set repaint(h) {
            this._repaint !== h && (this._repaint = h, this.triggerRepaint())
          }
          get vertices() {
            return !!this._vertices
          }
          set vertices(h) {
            this._vertices = h, this._update()
          }
          get version() {
            return ed
          }
          getCameraTargetElevation() {
            return this.transform.elevation
          }
          getProjection() {
            return this.style.getProjection()
          }
          setProjection(h) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(h), this._update(!0)
          }
        }, T.MapMouseEvent = Xn, T.MapTouchEvent = qs, T.MapWheelEvent = jc, T.Marker = Xs, T.NavigationControl = class {
          constructor(h) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(),
                n = e === this._map.getMaxZoom(),
                s = e === this._map.getMinZoom();
              this._zoomInButton.disabled = n, this._zoomOutButton.disabled = s, this._zoomInButton.setAttribute("aria-disabled", n.toString()), this._zoomOutButton.setAttribute("aria-disabled", s.toString())
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing-this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
            }, this._setButtonTitle = (e, n) => {
              const s = this._map._getUIString(`NavigationControl.${n}`);
              e.title = s, e.setAttribute("aria-label", s)
            }, this.options = o.e({}, _p, h), this._container = K.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e => this._map.zoomIn({}, {
              originalEvent: e
            }))), K.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e => this._map.zoomOut({}, {
              originalEvent: e
            }))), K.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                originalEvent: e
              }) : this._map.resetNorth({}, {
                originalEvent: e
              })
            })), this._compassIcon = K.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"))
          }
          onAdd(h) {
            return this._map = h, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Do(this._map, this._compass, this.options.visualizePitch)), this._container
          }
          onRemove() {
            K.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map
          }
          _createButton(h, e) {
            const n = K.create("button", h, this._container);
            return n.type = "button", n.addEventListener("click", e), n
          }
        }, T.Popup = class extends o.E {
          constructor(h) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
            }, this.remove = () => (this._content && K.remove(this._content), this._container && (K.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new o.l("close"))), this), this._onMouseUp = e => {
              this._update(e.point)
            }, this._onMouseMove = e => {
              this._update(e.point)
            }, this._onDrag = e => {
              this._update(e.point)
            }, this._update = e => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = K.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = K.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const m of this.options.className.split(" ")) this._container.classList.add(m);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Xi(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const n = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let s = this.options.anchor;
              const u = Al(this.options.offset);
              if (!s) {
                const m = this._container.offsetWidth,
                  y = this._container.offsetHeight;
                let b;
                b = n.y + u.bottom.y < y ? ["top"] : n.y > this._map.transform.height - y ? ["bottom"] : [], n.x < m / 2 ? b.push("left") : n.x > this._map.transform.width - m / 2 && b.push("right"), s = b.length === 0 ? "bottom" : b.join("-")
              }
              let d = n.add(u[s]);
              this.options.subpixelPositioning || (d = d.round()), K.setTransform(this._container, `${Il[s]} translate(${d.x}px,${d.y}px)`), Ws(this._container, s, "popup"), this._updateOpacity()
            }, this._onClose = () => {
              this.remove()
            }, this.options = o.e(Object.create(Yc), h)
          }
          addTo(h) {
            return this._map && this.remove(), this._map = h, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new o.l("open")), this
          }
          isOpen() {
            return !!this._map
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(h) {
            return this._lngLat = o.S.convert(h), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this
          }
          getElement() {
            return this._container
          }
          setText(h) {
            return this.setDOMContent(document.createTextNode(h))
          }
          setHTML(h) {
            const e = document.createDocumentFragment(),
              n = document.createElement("body");
            let s;
            for (n.innerHTML = h; s = n.firstChild, s;) e.appendChild(s);
            return this.setDOMContent(e)
          }
          getMaxWidth() {
            var h;
            return (h = this._container) === null || h === void 0 ? void 0 : h.style.maxWidth
          }
          setMaxWidth(h) {
            return this.options.maxWidth = h, this._update(), this
          }
          setDOMContent(h) {
            if (this._content)
              for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = K.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(h), this._createCloseButton(), this._update(), this._focusFirstElement(), this
          }
          addClassName(h) {
            return this._container && this._container.classList.add(h), this
          }
          removeClassName(h) {
            return this._container && this._container.classList.remove(h), this
          }
          setOffset(h) {
            return this.options.offset = h, this._update(), this
          }
          toggleClassName(h) {
            if (this._container) return this._container.classList.toggle(h)
          }
          setSubpixelPositioning(h) {
            this.options.subpixelPositioning = h
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = K.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose))
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const h = this._container.querySelector(Jc);
            h && h.focus()
          }
        }, T.RasterDEMTileSource = dr, T.RasterTileSource = Jt, T.ScaleControl = class {
          constructor(h) {
            this._onMove = () => {
              Ml(this._map, this._container, this.options)
            }, this.setUnit = e => {
              this.options.unit = e, Ml(this._map, this._container, this.options)
            }, this.options = Object.assign(Object.assign({}, Ro), h)
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(h) {
            return this._map = h, this._container = K.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", h.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container
          }
          onRemove() {
            K.remove(this._container), this._map.off("move", this._onMove), this._map = void 0
          }
        }, T.ScrollZoomHandler = Hh, T.Style = _c, T.TerrainControl = class {
          constructor(h) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon()
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
            }, this.options = h
          }
          onAdd(h) {
            return this._map = h, this._container = K.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = K.create("button", "maplibregl-ctrl-terrain", this._container), K.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container
          }
          onRemove() {
            K.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0
          }
        }, T.TwoFingersTouchPitchHandler = bl, T.TwoFingersTouchRotateHandler = Gs, T.TwoFingersTouchZoomHandler = xl, T.TwoFingersTouchZoomRotateHandler = Kh, T.VectorTileSource = tr, T.VideoSource = pr, T.addSourceType = (h, e) => o._(void 0, void 0, void 0, (function*() {
          if (Vr(h)) throw new Error(`A source type called "${h}" already exists.`);
          ((n, s) => {
            Sr[n] = s
          })(h, e)
        })), T.clearPrewarmedResources = function() {
          const h = Ye;
          h && (h.isPreloaded() && h.numActive() === 1 ? (h.release(Se), Ye = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
        }, T.createTileMesh = fc, T.getMaxParallelImageRequests = function() {
          return o.a.MAX_PARALLEL_IMAGE_REQUESTS
        }, T.getRTLTextPluginStatus = function() {
          return Mr().getRTLTextPluginStatus()
        }, T.getVersion = function() {
          return Qc
        }, T.getWorkerCount = function() {
          return Me.workerCount
        }, T.getWorkerUrl = function() {
          return o.a.WORKER_URL
        }, T.importScriptInWorkers = function(h) {
          return st().broadcast("IS", h)
        }, T.prewarm = function() {
          zt().acquire(Se)
        }, T.setMaxParallelImageRequests = function(h) {
          o.a.MAX_PARALLEL_IMAGE_REQUESTS = h
        }, T.setRTLTextPlugin = function(h, e) {
          return Mr().setRTLTextPlugin(h, e)
        }, T.setWorkerCount = function(h) {
          Me.workerCount = h
        }, T.setWorkerUrl = function(h) {
          o.a.WORKER_URL = h
        }
      }));
      var N = g;
      return N
    }))
  })(Td)), Td.exports
}
var qS = jS();
const yd = im(qS);
class pg {
  constructor(l) {
    lr(this, "gm");
    lr(this, "markers", new Map);
    lr(this, "canvases", new Map);
    lr(this, "canvasSize");
    lr(this, "canvasOpacity", .8);
    this.input = l, this.gm = new uc(this.input.tileSize);
    const g = tv(l.img);
    this.canvasSize = Math.ceil(2e3 / g)
  }
  place([l, g]) {
    const C = this.gm.latLonToPixelsFloor(l, g, this.input.zoom),
      D = this.getMarkerId(C),
      N = this.gm.latLonToPixelBoundsLatLon(l, g, this.input.zoom),
      T = this.input.map;
    if (this.input.markerFn && !this.markers.has(D)) {
      const _e = this.input.markerFn();
      _e.setLngLat({
        lat: N.min[0],
        lng: (N.max[1] + N.min[1]) / 2
      }).addTo(T), this.markers.set(D, _e)
    }
    const {
      key: o,
      pos: G,
      innerPos: W
    } = this.getCanvasPos(C);
    let ae = this.canvases.get(o);
    if (!ae) {
      const _e = this.canvasSize,
        xe = G.x * _e,
        K = G.y * _e,
        Ie = xe + _e - 1,
        Ce = K + _e - 1,
        De = this.gm.pixelsToLatLon(xe, Ce + 1, this.input.zoom),
        Be = this.gm.pixelsToLatLon(Ie + 1, K, this.input.zoom);
      ae = new VS({
        id: `${this.input.id}-${o}`,
        img: this.input.img,
        canvasSize: this.canvasSize,
        coordinates: tm({
          min: De,
          max: Be
        }),
        layerPaint: {
          "raster-resampling": "nearest",
          "raster-opacity": this.canvasOpacity
        }
      }), ae.addTo(this.input.map), this.canvases.set(o, ae)
    }
    ae.place(W.x, W.y)
  }
  clear() {
    const l = this.input.map;
    for (const g of this.canvases.values()) g.removeFrom(l), g.removeDOM();
    this.canvases.clear();
    for (const g of this.markers.values()) g.remove();
    this.markers.clear()
  }
  clearAndPlace(l) {
    this.clear(), this.place(l)
  }
  remove([l, g]) {
    let C = !1;
    const D = this.gm.latLonToPixelsFloor(l, g, this.input.zoom),
      {
        key: N,
        innerPos: T
      } = this.getCanvasPos(D),
      o = this.canvases.get(N);
    o && (C = o.remove(T.x, T.y), o.annotationsCount() === 0 && (this.canvases.delete(N), o.removeFrom(this.input.map), o.removeDOM()));
    const G = this.getMarkerId(D),
      W = this.markers.get(G);
    return W == null || W.remove(), this.markers.delete(G), C
  }
  setCanvasOpacity(l) {
    this.canvasOpacity = l;
    for (const g of this.canvases.values()) g.setOpacity(l)
  }
  getMarkerId([l, g]) {
    return `${this.input.id}:${l},${g}`
  }
  getCanvasPos([l, g]) {
    const C = {
        x: Math.floor(l / this.canvasSize),
        y: Math.floor(g / this.canvasSize)
      },
      D = {
        x: l % this.canvasSize,
        y: g % this.canvasSize
      },
      N = `${C.x},${C.y}`;
    return {
      pos: C,
      innerPos: D,
      key: N
    }
  }
}
class VS {
  constructor(l) {
    lr(this, "annotations", new Set);
    lr(this, "canvas");
    lr(this, "imgSize");
    lr(this, "maps", new Set);
    this.input = l, this.imgSize = tv(l.img), this.canvas = document.createElement("canvas"), this.canvas.width = this.input.canvasSize * this.imgSize, this.canvas.height = this.input.canvasSize * this.imgSize
  }
  place(l, g) {
    const C = this.getPixelKey(l, g);
    if (this.annotations.has(C)) return !1;
    const D = this.canvas.getContext("2d");
    if (D) {
      const N = l * this.imgSize,
        T = g * this.imgSize;
      D.drawImage(this.input.img, N, T)
    }
    return this.annotations.add(C), !0
  }
  remove(l, g) {
    const C = this.getPixelKey(l, g);
    if (!this.annotations.has(C)) return !1;
    const D = this.canvas.getContext("2d");
    if (D) {
      const N = l * this.imgSize,
        T = g * this.imgSize;
      D.clearRect(N, T, this.imgSize, this.imgSize)
    }
    return this.annotations.delete(C), !0
  }
  addTo(l) {
    const g = this.input.id;
    l.getSource(g) || l.addSource(g, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), l.getLayer(g) || l.addLayer({
      id: g,
      type: "raster",
      source: g,
      paint: this.input.layerPaint
    }), this.maps.add(l)
  }
  removeFrom(l) {
    const {
      id: g
    } = this.input;
    l.getLayer(g) && l.removeLayer(g), l.getSource(g) && l.removeSource(g), this.maps.delete(l)
  }
  removeDOM() {
    this.canvas.remove()
  }
  annotationsCount() {
    return this.annotations.size
  }
  setOpacity(l) {
    for (const g of this.maps.values()) g.setPaintProperty(this.input.id, "raster-opacity", l)
  }
  getPixelKey(l, g) {
    return `${l},${g}`
  }
}

function tv(w) {
  return Math.max(w.naturalWidth, w.naturalHeight)
}

function US() {
  return window.matchMedia("(display-mode: standalone)").matches || "standalone" in window.navigator && window.navigator.standalone === !0
}

function Ad(w, l) {
  return l.includes(w)
}

function ZS(w) {
  const l = {
      opaque: !0
    },
    g = w.searchParams.get("lat"),
    C = w.searchParams.get("lng");
  g && C && (l.pos = {
    lat: parseFloat(g),
    lng: parseFloat(C)
  });
  const D = w.searchParams.get("zoom");
  D && (l.zoom = parseFloat(D));
  const N = w.searchParams.get("season");
  N && (l.season = parseInt(N));
  const T = w.searchParams.get("opaque");
  return T && (l.opaque = T !== "0"), w.searchParams.get("select") && (l.select = !0), l.newUser = !!w.searchParams.get("new-user"), l.alliance = !!w.searchParams.get("alliance"), l
}

function $S(w, l) {
  return w = new URL(w), l.pos !== void 0 && (w.searchParams.set("lat", l.pos.lat.toString()), w.searchParams.set("lng", l.pos.lng.toString())), l.zoom !== void 0 && w.searchParams.set("zoom", l.zoom.toString()), l.season !== void 0 && w.searchParams.set("season", l.season.toString()), l.opaque !== void 0 && w.searchParams.set("opaque", l.opaque ? "1" : "0"), l.newUser !== void 0 && w.searchParams.set("new-user", l.newUser ? "1" : "0"), l.alliance !== void 0 && w.searchParams.set("alliance", l.alliance ? "1" : "0"), l.select && w.searchParams.set("alliance", "1"), w
}
const Cd = Ln({
  shouldReload: !0
});
var GS = (w, l) => {
    var g;
    (g = l()) == null || g.close()
  },
  HS = Pe('<dialog class="modal"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function WS(w, l) {
  Dr(l, !0);
  let g = At(l, "ref", 15),
    C = at(!1),
    D = at(Ln(l.description)),
    N = at(void 0);
  zi(() => {
    const je = Le => {
      var Fe;
      Le.key === "Escape" && ((Fe = g()) == null || Fe.close())
    };
    return document.addEventListener("keydown", je), () => document.removeEventListener("keydown", je)
  });
  var T = HS(),
    o = k(T),
    G = k(o),
    W = k(G, !0);
  A(G);
  var ae = V(G, 2),
    _e = k(ae),
    xe = k(_e);
  {
    let je = lt(() => Xg());
    Hy(xe, {
      class: "h-24 rounded-lg",
      get placeholder() {
        return x(je)
      },
      max: 512,
      get value() {
        return x(D)
      },
      set value(Le) {
        le(D, Le, !0)
      },
      get validate() {
        return x(N)
      },
      set validate(Le) {
        le(N, Le, !0)
      }
    })
  }
  A(_e);
  var K = V(_e, 2),
    Ie = k(K);
  Ie.__click = [GS, g];
  var Ce = k(Ie, !0);
  A(Ie);
  var De = V(Ie, 2),
    Be = k(De, !0);
  A(De), A(K), A(ae), A(o), vi(2), A(T), Ds(T, je => g(je), () => g()), Xe((je, Le, Fe) => {
    ve(W, je), Ie.disabled = x(C), ve(Ce, Le), De.disabled = x(C), ve(Be, Fe)
  }, [() => Qy(), () => Uf(), () => xT()]), Pn("submit", ae, async () => {
    var je, Le, Fe;
    try {
      if (!((je = x(N)) != null && je())) return;
      le(C, !0), l.description !== x(D) && await ni.updateAllianceDescription(x(D)), await ((Le = l.onsuccess) == null ? void 0 : Le.call(l, x(D))), (Fe = g()) == null || Fe.close()
    } catch (mt) {
      $r.error(mt.message)
    } finally {
      le(C, !1)
    }
  }), H(w, T), Rr()
}
rn(["click"]);
var XS = (w, l, g) => {
    navigator.clipboard.writeText(x(l).toString()), le(g, !0), setTimeout(() => {
      le(g, !1)
    }, 1e3)
  },
  KS = Pe('<span class="loading loading-spinner loading-md center-absolute absolute"></span>'),
  YS = Pe('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function JS(w, l) {
  Dr(l, !0);
  let g = At(l, "open", 15),
    C = at(""),
    D = at(!1);
  const N = lt(() => fa.url.origin + `/join?id=${x(C)}`);
  Hr(() => {
    g() && ni.getAllianceInvites().then(ut => {
      le(C, ut[0], !0)
    }).catch(ut => {
      $r.error(ut.message)
    })
  }), zi(() => {
    const ut = Ke => {
      Ke.key === "Escape" && g(!1)
    };
    return document.addEventListener("keydown", ut), () => document.removeEventListener("keydown", ut)
  });
  var T = YS(),
    o = k(T),
    G = V(k(o), 2),
    W = k(G, !0);
  A(G);
  var ae = V(G, 2),
    _e = k(ae, !0);
  A(ae);
  var xe = V(ae, 2),
    K = k(xe);
  let Ie;
  var Ce = k(K);
  es(Ce);
  var De = V(Ce, 2),
    Be = k(De);
  let je;
  Be.__click = [XS, N, D];
  var Le = k(Be, !0);
  A(Be), A(De), A(K);
  var Fe = V(K, 2);
  {
    var mt = ut => {
      var Ke = KS();
      H(ut, Ke)
    };
    Ue(Fe, ut => {
      x(C) || ut(mt)
    })
  }
  A(xe), A(o), vi(2), A(T), Gn(T, () => ut => {
    Hr(() => {
      g() ? ut.show() : ut.close()
    })
  }), Xe((ut, Ke, ct, tt, Re, ot) => {
    ve(W, ut), ve(_e, Ke), Ie = Or(K, 1, "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5", null, Ie, ct), Eg(Ce, tt), je = Or(Be, 1, "btn btn-primary", null, je, Re), ve(Le, ot)
  }, [() => _5(), () => y5(), () => ({
    invisible: !x(C)
  }), () => x(N).toString(), () => ({
    "btn-success": x(D)
  }), () => x(D) ? Kf() : mf()]), Pn("close", T, () => g(!1)), H(w, T), Rr()
}
rn(["click"]);
var QS = Cr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>');

function nm(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = QS();
  er(C, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    ...g
  })), H(w, C)
}
var eP = async (w, l) => {
  await navigator.clipboard.writeText(l.username), $r.info(E3())
}, tP = Pe('<span class="tooltip h-4"><button><!></button></span>');

function hh(w, l) {
  Dr(l, !0);
  var g = tP(),
    C = k(g);
  C.__click = [eP, l];
  var D = k(C);
  nm(D, {
    class: "size-4 opacity-70"
  }), A(C), A(g), Xe(() => kr(g, "data-tip", `Discord: ${l.username}`)), H(w, g), Rr()
}
rn(["click"]);
var rP = Pe('<input type="radio" class="tab max-[380px]:px-3"/>'),
  iP = Pe('<div class="tabs tabs-border w-max font-medium"></div>');

function am(w, l) {
  Dr(l, !0);
  const g = [];
  let C = At(l, "value", 15, "today"),
    D = [{
      value: "today",
      label: Ud()
    }, {
      value: "week",
      label: L5()
    }, {
      value: "month",
      label: B5()
    }, {
      value: "all-time",
      label: N5()
    }];
  var N = iP();
  gn(N, 21, () => D, T => T.value, (T, o) => {
    var G = rP();
    es(G);
    var W;
    Xe(() => {
      kr(G, "aria-label", x(o).label), W !== (W = x(o).value) && (G.value = (G.__value = x(o).value) ?? "")
    }), $f(g, [], G, () => (x(o).value, C()), C), H(T, G)
  }), A(N), H(w, N), Rr()
}
const nP = typeof window < "u" ? window : void 0;

function aP(w) {
  let l = w.activeElement;
  for (; l != null && l.shadowRoot;) {
    const g = l.shadowRoot.activeElement;
    if (g === l) break;
    l = g
  }
  return l
}
var tc, ku, Ig;
let sP = (Ig = class {
  constructor(l = {}) {
    xr(this, tc);
    xr(this, ku);
    const {
      window: g = nP,
      document: C = g == null ? void 0 : g.document
    } = l;
    g !== void 0 && (Qn(this, tc, C), Qn(this, ku, zg(D => {
      const N = Tu(g, "focusin", D),
        T = Tu(g, "focusout", D);
      return () => {
        N(), T()
      }
    })))
  }
  get current() {
    var l;
    return (l = Je(this, ku)) == null || l.call(this), Je(this, tc) ? aP(Je(this, tc)) : null
  }
}, tc = new WeakMap, ku = new WeakMap, Ig);
new sP;

function oP(w, l) {
  switch (w) {
    case "post":
      Hr(l);
      break;
    case "pre":
      Vf(l);
      break
  }
}

function rv(w, l, g, C = {}) {
  const {
    lazy: D = !1
  } = C;
  let N = !D,
    T = Array.isArray(w) ? [] : void 0;
  oP(l, () => {
    const o = Array.isArray(w) ? w.map(W => W()) : w();
    if (!N) {
      N = !0, T = o;
      return
    }
    const G = Go(() => g(o, T));
    return T = o, G
  })
}

function hc(w, l, g) {
  rv(w, "post", l, g)
}

function lP(w, l, g) {
  rv(w, "pre", l, g)
}
hc.pre = lP;
var cP = Pe('<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>'),
  uP = Pe('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  hP = Pe('<span class="font-flag tooltip ml-0.5"> </span>'),
  dP = (w, l, g) => {
    l.onlastpixelclick({
      lat: x(g).lastLatitude ?? 0,
      lng: x(g).lastLongitude ?? 0
    })
  },
  pP = Pe("<button><!></button>"),
  fP = Pe('<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>'),
  mP = Pe('<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>'),
  _P = Pe('<div><!> <div class="mt-4"><!></div></div>');

function gP(w, l) {
  Dr(l, !0);
  let g = At(l, "reload", 15),
    C = at(!0),
    D = at([]),
    N = at(0),
    T = at("today"),
    o = {};
  g(G);

  function G() {
    const Ce = x(T);
    ni.allianceLeaderboard(Ce).then(De => {
      le(D, De), o = {
        [Ce]: De
      }, le(C, !1)
    }).catch(De => {
      $r.error(De.message)
    })
  }
  hc(() => [x(T)], () => {
    const Ce = x(T),
      De = o[Ce];
    if (De) {
      le(D, De), le(C, !1);
      return
    }
    le(C, !0), ni.allianceLeaderboard(Ce).then(Be => {
      le(D, Be), o[Ce] = Be, le(C, !1)
    }).catch(Be => {
      $r.error(Be.message)
    })
  });
  var W = _P(),
    ae = k(W);
  am(ae, {
    get value() {
      return x(T)
    },
    set value(Ce) {
      le(T, Ce, !0)
    }
  });
  var _e = V(ae, 2),
    xe = k(_e);
  {
    var K = Ce => {
        var De = cP();
        H(Ce, De)
      },
      Ie = Ce => {
        var De = Kt(),
          Be = It(De);
        {
          var je = Fe => {
              var mt = uP(),
                ut = k(mt),
                Ke = V(ut);
              {
                var ct = Re => {
                    var ot = On();
                    Xe(rt => ve(ot, rt), [() => Ud().toLowerCase()]), H(Re, ot)
                  },
                  tt = Re => {
                    var ot = Kt(),
                      rt = It(ot);
                    {
                      var Qe = gt => {
                          var ee = On();
                          Xe(te => ve(ee, te), [() => Jf()]), H(gt, ee)
                        },
                        Ae = gt => {
                          var ee = Kt(),
                            te = It(ee);
                          {
                            var fe = ie => {
                              var Se = On();
                              Xe(Me => ve(Se, Me), [() => Qf()]), H(ie, Se)
                            };
                            Ue(te, ie => {
                              x(T) === "month" && ie(fe)
                            }, !0)
                          }
                          H(gt, ee)
                        };
                      Ue(rt, gt => {
                        x(T) === "week" ? gt(Qe) : gt(Ae, !1)
                      }, !0)
                    }
                    H(Re, ot)
                  };
                Ue(Ke, Re => {
                  x(T) === "today" ? Re(ct) : Re(tt, !1)
                })
              }
              A(mt), Xe(Re => ve(ut, `${Re??""} `), [() => Yf()]), H(Fe, mt)
            },
            Le = Fe => {
              var mt = mP(),
                ut = k(mt),
                Ke = k(ut),
                ct = V(k(Ke)),
                tt = k(ct, !0);
              A(ct);
              var Re = V(ct),
                ot = k(Re, !0);
              A(Re), A(Ke), A(ut);
              var rt = V(ut);
              gn(rt, 31, () => x(D), Qe => Qe.userId, (Qe, Ae, gt) => {
                const ee = lt(() => {
                  var Jt;
                  return ((Jt = Et.data) == null ? void 0 : Jt.id) === x(Ae).userId
                });
                var te = fP();
                let fe;
                var ie = k(te),
                  Se = k(ie, !0);
                A(ie);
                var Me = V(ie),
                  nt = k(Me),
                  Ye = k(nt);
                ds(Ye, {
                  class: "size-10 border",
                  get userId() {
                    return x(Ae).userId
                  },
                  get pictureUrl() {
                    return x(Ae).picture
                  }
                });
                var wt = V(Ye, 2),
                  zt = k(wt),
                  Nt = V(zt),
                  st = k(Nt);
                A(Nt), A(wt);
                var Tt = V(wt, 2);
                {
                  var Ct = Jt => {
                    const dr = lt(() => hs(x(Ae).equippedFlag));
                    var nr = hP(),
                      Bt = k(nr, !0);
                    A(nr), Xe(() => {
                      kr(nr, "data-tip", x(dr).name), ve(Bt, x(dr).flag)
                    }), H(Jt, nr)
                  };
                  Ue(Tt, Jt => {
                    x(Ae).equippedFlag && Jt(Ct)
                  })
                }
                var yt = V(Tt, 2);
                {
                  var Mt = Jt => {
                    hh(Jt, {
                      get username() {
                        return x(Ae).discord
                      }
                    })
                  };
                  Ue(yt, Jt => {
                    x(Ae).discord && Jt(Mt)
                  })
                }
                A(nt), A(Me);
                var St = V(Me),
                  ht = k(St),
                  Lt = V(ht);
                {
                  var tr = Jt => {
                    var dr = pP();
                    let nr;
                    dr.__click = [dP, l, Ae];
                    var Bt = k(dr);
                    Zf(Bt, {
                      class: "size-4"
                    }), A(dr), Xe((pr, gr) => {
                      nr = Or(dr, 1, "btn btn-sm btn-ghost absolute -right-2 top-1/2 !-translate-y-1/2 sm:right-4", null, nr, pr), kr(dr, "data-tip", gr)
                    }, [() => ({
                      tooltip: x(N) > 640
                    }), () => W5()]), H(Jt, dr)
                  };
                  Ue(Lt, Jt => {
                    x(Ae).lastLatitude && x(Ae).lastLongitude && Jt(tr)
                  })
                }
                A(St), A(te), Xe((Jt, dr, nr) => {
                  var Bt;
                  fe = Or(te, 1, "", null, fe, Jt), ve(Se, x(gt) + 1), Or(wt, 1, `font-semibold ${dr??""} flex gap-1`), ve(zt, `${(x(ee)?((Bt=Et.data)==null?void 0:Bt.name)??x(Ae).name:x(Ae).name)??""} `), ve(st, `#${x(Ae).userId??""}`), ve(ht, `${nr??""} `)
                }, [() => ({
                  "bg-base-200": x(ee)
                }), () => Zn(x(Ae).userId), () => x(Ae).pixelsPainted.toLocaleString("en-US")]), Zo(te, () => $o, () => ({
                  duration: 200
                })), H(Qe, te)
              }), A(rt), A(mt), Xe((Qe, Ae) => {
                ve(tt, Qe), ve(ot, Ae)
              }, [() => em(), () => Hf()]), H(Fe, mt)
            };
          Ue(Be, Fe => {
            x(D).length === 0 ? Fe(je) : Fe(Le, !1)
          }, !0)
        }
        H(Ce, De)
      };
    Ue(xe, Ce => {
      x(C) ? Ce(K) : Ce(Ie, !1)
    })
  }
  A(_e), A(W), jd("innerWidth", Ce => le(N, Ce, !0)), H(w, W), Rr()
}
rn(["click"]);
var vP = Cr('<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>');

function sm(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = vP();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var yP = (w, l) => l.onclickback(),
  xP = Pe('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>'),
  bP = async (w, l) => {
    try {
      x(l).loading = !0, await ni.giveAllianceAdmin(x(l).id), x(l).role = "admin"
    } catch {
      $r.error(tC())
    } finally {
      x(l).loading = !1
    }
  }, wP = async (w, l, g) => {
    try {
      x(l).loading = !0, await ni.banAllianceUser(x(l).id), g.data = g.data.filter(C => C.id !== x(l).id)
    } catch {
      $r.error(TT())
    } finally {
      x(l).loading = !1
    }
  }, TP = Pe('<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>', 1), CP = Pe('<li><button class="btn btn-ghost text-base-content/80"> </button></li>'), SP = Pe('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>'), PP = Pe('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'), IP = (w, l, g) => {
    ni.unbanAllianceUser(x(l).id).then(() => {
      g.data = g.data.filter(C => C.id !== x(l).id)
    }).catch(C => $r.error(C.message)).finally(() => {
      x(l).loading = !1
    })
  }, MP = Pe('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>'), AP = Pe('<div class="text-base-content/80 mt-4 flex justify-center"> </div>'), kP = Pe('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'), EP = Pe('<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>');

function zP(w, l) {
  Dr(l, !0);
  let g = Ln({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    }),
    C = Ln({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    });
  var D = EP(),
    N = k(D),
    T = k(N);
  T.__click = [yP, l];
  var o = k(T);
  ax(o, {
    class: "size-5"
  }), A(T);
  var G = V(T, 2),
    W = k(G, !0);
  A(G), A(N);
  var ae = V(N, 2),
    _e = k(ae);
  es(_e);
  var xe = V(_e, 2),
    K = k(xe),
    Ie = k(K);
  gn(Ie, 21, () => g.data, tt => tt.id, (tt, Re, ot) => {
    const rt = lt(() => {
      var Ct;
      return ((Ct = Et.data) == null ? void 0 : Ct.id) === x(Re).id
    });
    var Qe = SP(),
      Ae = k(Qe),
      gt = k(Ae),
      ee = k(gt);
    ds(ee, {
      class: "size-10 border",
      get userId() {
        return x(Re).id
      },
      get pictureUrl() {
        return x(Re).picture
      }
    });
    var te = V(ee, 2),
      fe = k(te);
    A(te);
    var ie = V(te, 2);
    {
      var Se = Ct => {
        var yt = xP();
        H(Ct, yt)
      };
      Ue(ie, Ct => {
        x(Re).role === "admin" && Ct(Se)
      })
    }
    A(gt), A(Ae);
    var Me = V(Ae),
      nt = k(Me),
      Ye = k(nt),
      wt = k(Ye);
    sm(wt, {
      class: "size-4"
    }), A(Ye);
    var zt = V(Ye, 2),
      Nt = k(zt);
    {
      var st = Ct => {
          var yt = TP(),
            Mt = It(yt),
            St = k(Mt);
          St.__click = [bP, Re];
          var ht = k(St, !0);
          A(St), A(Mt);
          var Lt = V(Mt, 2),
            tr = k(Lt);
          tr.__click = [wP, Re, g];
          var Jt = k(tr, !0);
          A(tr), A(Lt), Xe((dr, nr) => {
            St.disabled = x(Re).loading, ve(ht, dr), tr.disabled = x(Re).loading, ve(Jt, nr)
          }, [() => sT(), () => Kg()]), H(Ct, yt)
        },
        Tt = Ct => {
          var yt = CP(),
            Mt = k(yt);
          Mt.disabled = !0;
          var St = k(Mt, !0);
          A(Mt), A(yt), Xe(ht => ve(St, ht), [() => hT()]), H(Ct, yt)
        };
      Ue(Nt, Ct => {
        x(Re).role === "member" ? Ct(st) : Ct(Tt, !1)
      })
    }
    A(zt), A(nt), A(Me), A(Qe), Xe(Ct => {
      var yt;
      Or(te, 1, `font-semibold ${Ct??""}`), ve(fe, `${(x(rt)?((yt=Et.data)==null?void 0:yt.name)??x(Re).name:x(Re).name)??""} #${x(Re).id??""}`)
    }, [() => Zn(x(Re).id)]), H(tt, Qe)
  }), A(Ie), A(K);
  var Ce = V(K, 2);
  {
    var De = tt => {
      var Re = Kt(),
        ot = It(Re);
      Cu(ot, () => g.page, rt => {
        var Qe = PP();
        Gn(Qe, () => Ae => {
          const gt = new IntersectionObserver(ee => {
            ee[0].isIntersecting && !g.loading && (g.loading = !0, ni.getAllianceMembers(g.page).then(te => {
              g.data = [...g.data, ...te.data], g.hasNextPage = te.hasNext, g.page++
            }).catch(te => {
              $r.error(te.message)
            }).finally(() => {
              g.loading = !1
            }))
          });
          return gt.observe(Ae), () => {
            gt.disconnect()
          }
        }), H(rt, Qe)
      }), H(tt, Re)
    };
    Ue(Ce, tt => {
      g.hasNextPage && tt(De)
    })
  }
  A(xe);
  var Be = V(xe, 2),
    je = V(Be, 2),
    Le = k(je),
    Fe = k(Le);
  gn(Fe, 21, () => C.data, tt => tt.id, (tt, Re, ot) => {
    var rt = MP(),
      Qe = k(rt),
      Ae = k(Qe),
      gt = k(Ae);
    ds(gt, {
      class: "size-10 border",
      get userId() {
        return x(Re).id
      },
      get pictureUrl() {
        return x(Re).picture
      }
    });
    var ee = V(gt, 2),
      te = k(ee);
    A(ee), A(Ae), A(Qe);
    var fe = V(Qe),
      ie = k(fe);
    ie.__click = [IP, Re, C];
    var Se = k(ie, !0);
    A(ie), A(fe), A(rt), Xe((Me, nt) => {
      Or(ee, 1, `font-semibold ${Me??""}`), ve(te, `${x(Re).name??""} #${x(Re).id??""}`), ie.disabled = x(Re).loading, ve(Se, nt)
    }, [() => Zn(x(Re).id), () => fT()]), H(tt, rt)
  }), A(Fe), A(Le);
  var mt = V(Le, 2);
  {
    var ut = tt => {
      var Re = AP(),
        ot = k(Re, !0);
      A(Re), Xe(rt => ve(ot, rt), [() => gT()]), H(tt, Re)
    };
    Ue(mt, tt => {
      !C.hasNextPage && C.data.length === 0 && tt(ut)
    })
  }
  var Ke = V(mt, 2);
  {
    var ct = tt => {
      var Re = Kt(),
        ot = It(Re);
      Cu(ot, () => C.page, rt => {
        var Qe = kP();
        Gn(Qe, () => Ae => {
          const gt = new IntersectionObserver(ee => {
            ee[0].isIntersecting && !C.loading && (C.loading = !0, ni.getAllianceBannedMembers(C.page).then(te => {
              C.data = [...C.data, ...te.data], C.hasNextPage = te.hasNext, C.page++
            }).catch(te => {
              $r.error(te.message)
            }).finally(() => {
              C.loading = !1
            }))
          });
          return gt.observe(Ae), () => {
            gt.disconnect()
          }
        }), H(rt, Qe)
      }), H(tt, Re)
    };
    Ue(Ke, tt => {
      C.hasNextPage && tt(ct)
    })
  }
  A(je), A(ae), A(D), Xe((tt, Re, ot) => {
    ve(W, tt), kr(_e, "aria-label", Re), kr(Be, "aria-label", ot)
  }, [() => Wg(), () => PT(), () => AT()]), H(w, D), Rr()
}
rn(["click"]);
var LP = Pe('<span class="label"> </span>'),
  DP = Pe('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>'),
  RP = Pe('<p class="text-error ml-3 text-sm"> </p>'),
  BP = Pe('<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>');

function vf(w, l) {
  Dr(l, !0);
  let g = At(l, "value", 15),
    C = At(l, "validate", 15),
    D = at("");
  const N = lt(() => {
    var Be;
    return ((Be = g()) == null ? void 0 : Be.length) ?? 0
  });
  C(T);

  function T() {
    return l.min !== void 0 && x(N) < l.min ? (le(D, x(N) === 0 ? "Required" : `Min. characters: ${l.min}`, !0), !1) : l.max !== void 0 && x(N) > l.max ? (le(D, `Max. characters: ${l.max}`), !1) : !0
  }
  Hr(() => {
    var Be;
    l.max !== void 0 && x(N) > l.max && g((Be = g()) == null ? void 0 : Be.substring(0, l.max))
  });
  var o = BP(),
    G = k(o);
  let W;
  var ae = k(G);
  {
    var _e = Be => {
      var je = LP(),
        Le = k(je, !0);
      A(je), Xe(() => ve(Le, l.label)), H(Be, je)
    };
    Ue(ae, Be => {
      l.label && Be(_e)
    })
  }
  var xe = V(ae, 2);
  es(xe);
  var K = V(xe, 2);
  {
    var Ie = Be => {
      var je = DP(),
        Le = k(je, !0);
      A(je), Xe(() => ve(Le, l.max - x(N))), H(Be, je)
    };
    Ue(K, Be => {
      l.max !== void 0 && Be(Ie)
    })
  }
  A(G);
  var Ce = V(G, 2);
  {
    var De = Be => {
      var je = RP(),
        Le = k(je, !0);
      A(je), Xe(() => ve(Le, x(D))), H(Be, je)
    };
    Ue(Ce, Be => {
      x(D) && Be(De)
    })
  }
  A(o), Xe(Be => {
    W = Or(G, 1, "input w-full", null, W, Be), kr(xe, "placeholder", l.placeholder), kr(xe, "maxlength", l.max)
  }, [() => ({
    "input-error": !!x(D)
  })]), Gf(xe, g), H(w, o), Rr()
}
var FP = (w, l) => {
    var g;
    (g = l()) == null || g.close()
  },
  OP = Pe('<dialog class="modal"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function NP(w, l) {
  Dr(l, !0);
  let g = At(l, "ref", 15),
    C = at(!1),
    D = at(""),
    N = at(void 0);
  zi(() => {
    const je = Le => {
      var Fe;
      Le.key === "Escape" && ((Fe = g()) == null || Fe.close())
    };
    return document.addEventListener("keydown", je), () => document.removeEventListener("keydown", je)
  });
  var T = OP(),
    o = k(T),
    G = k(o),
    W = k(G, !0);
  A(G);
  var ae = V(G, 2),
    _e = k(ae),
    xe = k(_e);
  {
    let je = lt(() => _f()),
      Le = lt(() => eT());
    vf(xe, {
      get label() {
        return x(je)
      },
      get placeholder() {
        return x(Le)
      },
      min: 1,
      max: 16,
      get value() {
        return x(D)
      },
      set value(Fe) {
        le(D, Fe, !0)
      },
      get validate() {
        return x(N)
      },
      set validate(Fe) {
        le(N, Fe, !0)
      }
    })
  }
  A(_e);
  var K = V(_e, 2),
    Ie = k(K);
  Ie.__click = [FP, g];
  var Ce = k(Ie, !0);
  A(Ie);
  var De = V(Ie, 2),
    Be = k(De, !0);
  A(De), A(K), A(ae), A(o), vi(2), A(T), Ds(T, je => g(je), () => g()), Xe((je, Le, Fe) => {
    ve(W, je), Ie.disabled = x(C), ve(Ce, Le), De.disabled = x(C), ve(Be, Fe)
  }, [() => Y5(), () => Uf(), () => iT()]), Pn("submit", ae, async () => {
    var je, Le;
    try {
      if (!((je = x(N)) != null && je())) return;
      le(C, !0);
      const {
        id: Fe
      } = await ni.createAlliance(x(D));
      await l.onsuccess(Fe), (Le = g()) == null || Le.close()
    } catch (Fe) {
      $r.error(Fe.message)
    } finally {
      le(C, !1)
    }
  }), H(w, T), Rr()
}
rn(["click"]);
var jP = Cr('<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>');

function dh(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = jP();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var qP = Cr('<svg><path d="M160-160v-100.77l527.23-527.77q6.15-5.48 13.57-8.47 7.43-2.99 15.49-2.99t15.62 2.54q7.55 2.54 13.94 9.15l42.69 42.93q6.61 6.38 9.04 14 2.42 7.63 2.42 15.25 0 8.13-2.74 15.56-2.74 7.42-8.72 13.57L260.77-160H160Zm540.15-496.46L760-715.54 715.54-760l-59.08 59.85 43.69 43.69Z"></path></svg>'),
  VP = Cr('<svg><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"></path></svg>');

function yf(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var C = Kt(),
    D = It(C);
  {
    var N = o => {
        var G = qP();
        er(G, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...g
        })), H(o, G)
      },
      T = o => {
        var G = VP();
        er(G, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...g
        })), H(o, G)
      };
    Ue(D, o => {
      l.filled ? o(N) : o(T, !1)
    })
  }
  H(w, C)
}
var UP = Cr('<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');

function ZP(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = UP();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var $P = Cr('<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>');

function GP(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = $P();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var HP = Cr('<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>');

function WP(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = HP();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var XP = Cr('<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>');

function Zd(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = XP();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}

function KP(w, l = "_blank") {
  return w.replaceAll(/https?:\/\/[^\s]+/g, g => `<a href="${g}"${l?` target="${l}"`:""}>${g}</a>`)
}
var YP = Pe('<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>'),
  JP = async (w, l, g, C) => {
    try {
      le(l, !0), await ni.leaveAlliance(), le(g, !0), await C()
    } catch (D) {
      $r.error(D.message)
    } finally {
      le(l, !1)
    }
  }, QP = (w, l) => {
    le(l, !0)
  }, eI = Pe('<div class="tooltip"><button class="btn"><!></button></div>'), tI = (w, l) => {
    var g;
    (g = x(l)) == null || g.show()
  }, rI = Pe('<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>'), iI = Pe('<section class="text-base-content/80 highlight-link"><!> <!></section>'), nI = Pe('<span class="font-semibold"> </span>'), aI = (w, l) => le(l, !0), sI = Pe('<button class="text-primary font-semibold underline"> </button>'), oI = (w, l, g) => {
    var C;
    (C = x(l)) != null && C.hq ? g.onhqclick({
      lat: x(l).hq.latitude,
      lng: x(l).hq.longitude
    }) : g.onhqchange()
  }, lI = Pe('<span class="text-primary underline"> </span>'), cI = Pe('<span class="text-primary underline"> </span>'), uI = Pe('<button class="text-base-content/80 p-1"><!></button>'), hI = Pe('<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>'), dI = Pe('<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>', 1), pI = (w, l) => {
    var g;
    (g = x(l)) == null || g.show()
  }, fI = Pe('<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>', 1), mI = Pe('<div class="h-full"><!></div>');

function _I(w, l) {
  Dr(l, !0);
  let g = at(void 0),
    C = at(!0),
    D = at(void 0),
    N = at(!1),
    T = at(void 0),
    o = at(!1),
    G = at(!1),
    W = at(() => {});
  hc(() => l.open, () => {
    l.open && Cd.shouldReload && ae()
  }), zi(() => {
    const Ce = setInterval(() => {
      Cd.shouldReload = !0
    }, 1e4);
    return () => {
      clearTimeout(Ce)
    }
  });
  async function ae() {
    try {
      le(g, await ni.getAlliance(), !0), x(g) && x(W)(), le(C, !1), Cd.shouldReload = !1
    } catch (Ce) {
      $r.error(Ce.message)
    }
  }
  var _e = mI(),
    xe = k(_e);
  {
    var K = Ce => {
        var De = YP();
        H(Ce, De)
      },
      Ie = Ce => {
        var De = Kt(),
          Be = It(De);
        {
          var je = Fe => {
              zP(Fe, {
                onclickback: () => le(G, !1)
              })
            },
            Le = Fe => {
              var mt = Kt(),
                ut = It(mt);
              {
                var Ke = tt => {
                    var Re = dI(),
                      ot = It(Re),
                      rt = k(ot),
                      Qe = k(rt, !0);
                    A(rt);
                    var Ae = V(rt, 2),
                      gt = k(Ae),
                      ee = k(gt),
                      te = k(ee);
                    sm(te, {
                      class: "size-4"
                    }), A(ee);
                    var fe = V(ee, 2),
                      ie = k(fe),
                      Se = k(ie);
                    Se.__click = [JP, N, C, ae];
                    var Me = k(Se, !0);
                    A(Se), A(ie), A(fe), A(gt);
                    var nt = V(gt, 2);
                    {
                      var Ye = ce => {
                        var F = eI(),
                          q = k(F);
                        q.__click = [QP, o];
                        var $ = k(q);
                        WP($, {
                          class: "size-4"
                        }), A(q), A(F), Xe(X => kr(F, "data-tip", X), [() => P5()]), H(ce, F)
                      };
                      Ue(nt, ce => {
                        x(g).role == "admin" && ce(Ye)
                      })
                    }
                    A(Ae), A(ot);
                    var wt = V(ot, 2);
                    {
                      var zt = ce => {
                        var F = iI(),
                          q = k(F);
                        Gy(q, () => KP(x(g).description || Xg()));
                        var $ = V(q, 2);
                        {
                          var X = oe => {
                            var me = rI();
                            me.__click = [tI, T];
                            var Ee = k(me);
                            yf(Ee, {
                              class: "size-4"
                            }), A(me), H(oe, me)
                          };
                          Ue($, oe => {
                            x(g).role === "admin" && oe(X)
                          })
                        }
                        A(F), H(ce, F)
                      };
                      Ue(wt, ce => {
                        (x(g).description || x(g).role === "admin") && ce(zt)
                      })
                    }
                    var Nt = V(wt, 2),
                      st = k(Nt),
                      Tt = k(st);
                    dh(Tt, {
                      class: "inline size-4"
                    });
                    var Ct = V(Tt, 2),
                      yt = k(Ct),
                      Mt = V(yt),
                      St = k(Mt, !0);
                    A(Mt), A(Ct), A(st);
                    var ht = V(st, 2),
                      Lt = k(ht);
                    Zd(Lt, {
                      class: "inline size-4"
                    });
                    var tr = V(Lt, 2),
                      Jt = k(tr),
                      dr = V(Jt);
                    {
                      var nr = ce => {
                          var F = nI(),
                            q = k(F, !0);
                          A(F), Xe($ => ve(q, $), [() => x(g).members.toLocaleString("en-US")]), H(ce, F)
                        },
                        Bt = ce => {
                          var F = sI();
                          F.__click = [aI, G];
                          var q = k(F, !0);
                          A(F), Xe($ => ve(q, $), [() => x(g).members.toLocaleString("en-US")]), H(ce, F)
                        };
                      Ue(dr, ce => {
                        x(g).role === "member" ? ce(nr) : ce(Bt, !1)
                      })
                    }
                    A(tr), A(ht);
                    var pr = V(ht, 2);
                    {
                      var gr = ce => {
                        var F = hI(),
                          q = k(F);
                        ZP(q, {
                          class: "inline size-4"
                        });
                        var $ = V(q, 2),
                          X = k($),
                          oe = V(X);
                        oe.__click = [oI, g, l];
                        var me = k(oe);
                        {
                          var Ee = $e => {
                              var kt = lI(),
                                ye = k(kt);
                              A(kt), Xe((Xt, Ht) => ve(ye, `${Xt??""}, ${Ht??""}`), [() => x(g).hq.latitude.toFixed(3), () => x(g).hq.longitude.toFixed(3)]), H($e, kt)
                            },
                            Te = $e => {
                              var kt = cI(),
                                ye = k(kt, !0);
                              A(kt), Xe(Xt => ve(ye, Xt), [() => t5()]), H($e, kt)
                            };
                          Ue(me, $e => {
                            x(g).hq ? $e(Ee) : $e(Te, !1)
                          })
                        }
                        A(oe), A($);
                        var Ze = V($, 2);
                        {
                          var it = $e => {
                            var kt = uI();
                            kt.__click = function(...Xt) {
                              var Ht;
                              (Ht = l.onhqchange) == null || Ht.apply(this, Xt)
                            };
                            var ye = k(kt);
                            yf(ye, {
                              class: "text-base-content/50 size-4"
                            }), A(kt), H($e, kt)
                          };
                          Ue(Ze, $e => {
                            x(g).role === "admin" && $e(it)
                          })
                        }
                        A(F), Xe($e => ve(X, `${$e??""}: `), [() => Jw()]), H(ce, F)
                      };
                      Ue(pr, ce => {
                        (x(g).hq || x(g).role === "admin") && ce(gr)
                      })
                    }
                    A(Nt);
                    var Sr = V(Nt, 2),
                      Vr = k(Sr),
                      ur = k(Vr, !0);
                    A(Vr);
                    var Pr = V(Vr, 2),
                      Ir = k(Pr);
                    gP(Ir, {
                      get allianceId() {
                        return x(g).id
                      },
                      get onlastpixelclick() {
                        return l.onlastpixelclick
                      },
                      get reload() {
                        return x(W)
                      },
                      set reload(ce) {
                        le(W, ce, !0)
                      }
                    }), A(Pr), A(Sr);
                    var Mr = V(Sr, 2);
                    WS(Mr, {
                      get description() {
                        return x(g).description
                      },
                      onsuccess: async ce => {
                        x(g) && (x(g).description = ce)
                      },
                      get ref() {
                        return x(T)
                      },
                      set ref(ce) {
                        le(T, ce, !0)
                      }
                    });
                    var Nr = V(Mr, 2);
                    JS(Nr, {
                      get open() {
                        return x(o)
                      },
                      set open(ce) {
                        le(o, ce, !0)
                      }
                    }), Xe((ce, F, q, $, X) => {
                      ve(Qe, x(g).name), Se.disabled = x(N), ve(Me, ce), ve(yt, `${F??""}: `), ve(St, q), ve(Jt, `${$??""}: `), ve(ur, X)
                    }, [() => Hw(), () => Hf(), () => x(g).pixelsPainted.toLocaleString("en-US"), () => Wg(), () => Xf()]), H(tt, Re)
                  },
                  ct = tt => {
                    var Re = fI(),
                      ot = It(Re),
                      rt = k(ot),
                      Qe = k(rt);
                    A(rt);
                    var Ae = V(rt, 2),
                      gt = k(Ae);
                    GP(gt, {
                      class: "size-5"
                    });
                    var ee = V(gt, 1, !0);
                    A(Ae);
                    var te = V(Ae, 2),
                      fe = k(te),
                      ie = k(fe, !0);
                    A(fe), A(te);
                    var Se = V(te, 2);
                    Se.__click = [pI, D];
                    var Me = k(Se);
                    Og(Me, {
                      class: "size-6"
                    });
                    var nt = V(Me);
                    A(Se), A(ot);
                    var Ye = V(ot, 2);
                    NP(Ye, {
                      onsuccess: ae,
                      get ref() {
                        return x(D)
                      },
                      set ref(wt) {
                        le(D, wt, !0)
                      }
                    }), Xe((wt, zt, Nt, st) => {
                      ve(Qe, `${wt??""}:`), ve(ee, zt), ve(ie, Nt), ve(nt, ` ${st??""}`)
                    }, [() => n5(), () => o5(), () => u5(), () => p5()]), H(tt, Re)
                  };
                Ue(ut, tt => {
                  x(g) ? tt(Ke) : tt(ct, !1)
                }, !0)
              }
              H(Fe, mt)
            };
          Ue(Be, Fe => {
            x(G) ? Fe(je) : Fe(Le, !1)
          }, !0)
        }
        H(Ce, De)
      };
    Ue(xe, Ce => {
      x(C) ? Ce(K) : Ce(Ie, !1)
    })
  }
  A(_e), H(w, _e), Rr()
}
rn(["click"]);
var gI = Cr('<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>');

function $d(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = gI();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var vI = Pe('<dialog class="modal"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function yI(w, l) {
  Dr(l, !0);
  let g = At(l, "open", 15);
  zi(() => {
    const _e = xe => {
      xe.key === "Escape" && g(!1)
    };
    return document.addEventListener("keydown", _e), () => document.removeEventListener("keydown", _e)
  });
  var C = vI(),
    D = k(C),
    N = V(k(D), 2),
    T = k(N);
  $d(T, {
    class: "size-5 max-sm:size-6"
  });
  var o = V(T, 2),
    G = k(o, !0);
  A(o), A(N);
  var W = V(N, 2),
    ae = k(W);
  _I(ae, {
    get open() {
      return g()
    },
    get onhqchange() {
      return l.onhqchange
    },
    get onhqclick() {
      return l.onhqclick
    },
    get onlastpixelclick() {
      return l.onlastpixelclick
    }
  }), A(W), A(D), vi(2), A(C), Gn(C, () => _e => {
    Hr(() => {
      g() ? (_e.show(), fa.url.searchParams.get("alliance") && (fa.url.searchParams.delete("alliance"), Lg(fa.url.toString()))) : _e.close()
    })
  }), Xe(_e => ve(G, _e), [() => qd()]), Pn("close", C, () => g(!1)), zn(2, W, () => ea, () => ({
    duration: 300
  })), H(w, C), Rr()
}

function xI(w, l, g) {
  return new Promise((C, D) => {
    w.once("render", () => {
      const N = w.getCanvas().toDataURL(),
        T = document.createElement("img");
      T.src = N, T.onload = () => {
        const o = document.createElement("canvas");
        o.width = T.width, o.height = T.height;
        const G = o.getContext("2d");
        if (G) {
          G.drawImage(T, 0, 0);
          const [W, ae, _e, xe] = G.getImageData(l, g, 1, 1).data;
          C([W, ae, _e, xe])
        } else D(new Error("Could not get 2d context from canvas"));
        T.remove(), o.remove()
      }
    }), w.triggerRepaint()
  })
}

function iv(w, l) {
  return new Promise((g, C) => {
    w.once("render", () => {
      const D = w.getCanvas();
      let N = D;
      if (l != null && l.maxWidth || l != null && l.maxHeight) {
        const T = D.width,
          o = D.height,
          G = (l == null ? void 0 : l.maxWidth) ?? T,
          W = (l == null ? void 0 : l.maxHeight) ?? o;
        N = document.createElement("canvas");
        const ae = Math.min(G / T, W / o);
        N.width = Math.floor(T * ae), N.height = Math.floor(o * ae);
        const _e = N.getContext("2d");
        _e && _e.drawImage(D, 0, 0, N.width, N.height)
      }
      try {
        N.toBlob(T => {
          T && g(T)
        }, (l == null ? void 0 : l.type) ?? "image/png", (l == null ? void 0 : l.quality) ?? 1)
      } catch (T) {
        C(T)
      } finally {
        N !== D && N.remove()
      }
    })
  })
}
var bI = Cr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>');

function wI(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = bI();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var TI = Cr('<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>');

function nv(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = TI();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
const Yl = {
  hour: 3600 * 1e3,
  min: 60 * 1e3,
  sec: 1e3
};

function kd(w) {
  const l = Math.floor(w / Yl.hour);
  w -= l * Yl.hour;
  const g = Math.floor(w / Yl.min);
  w -= g * Yl.min;
  const D = Math.floor(w / Yl.sec).toString().padStart(2, "0");
  return l > 0 ? `${l}:${g.toString().padStart(2,"0")}:${D}` : `${g}:${D}`
}

function CI(w) {
  const l = new Date,
    g = l.getFullYear(),
    C = String(l.getMonth() + 1).padStart(2, "0"),
    D = String(l.getDate()).padStart(2, "0"),
    N = String(l.getHours()).padStart(2, "0"),
    T = String(l.getMinutes()).padStart(2, "0"),
    o = String(l.getSeconds()).padStart(2, "0");
  return `${g}-${C}-${D} ${N}:${T}:${o}`
}
var SI = (w, l, g) => {
    navigator.clipboard.writeText(l.url.toString()), le(g, !0), setTimeout(() => {
      le(g, !1)
    }, 1e3)
  },
  PI = Pe('<img class="border-base-content/20 border" alt="Screenshot"/>'),
  II = Pe('<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>'),
  MI = async (w, l) => {
    x(l) && (await navigator.clipboard.write([new ClipboardItem({
      "image/png": x(l)
    })]), $r.info(XC()))
  }, AI = Pe('<div><h3 class="mb-1 mt-5 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>'), kI = Pe('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function EI(w, l) {
  Dr(l, !0);
  let g = At(l, "open", 15),
    C = at(!1);
  zi(() => {
    const Le = Fe => {
      Fe.key === "Escape" && g(!1)
    };
    return document.addEventListener("keydown", Le), () => document.removeEventListener("keydown", Le)
  });
  let D = at(null),
    N = at("");
  Hr(() => {
    g() ? (l.hideHover(), setTimeout(async () => {
      iv(l.map).then(Le => {
        le(D, Le, !0), le(N, URL.createObjectURL(x(D)), !0)
      }).finally(() => {
        l.showHover()
      })
    }, 500)) : x(N) && (URL.revokeObjectURL(x(N)), le(D, null), le(N, ""))
  });
  var T = kI(),
    o = k(T),
    G = V(k(o), 2),
    W = k(G);
  nv(W, {
    class: "size-5"
  });
  var ae = V(W);
  A(G);
  var _e = V(G, 2),
    xe = k(_e);
  es(xe);
  var K = V(xe, 2),
    Ie = k(K);
  let Ce;
  Ie.__click = [SI, l, C];
  var De = k(Ie, !0);
  A(Ie), A(K), A(_e);
  var Be = V(_e, 2);
  {
    var je = Le => {
      const Fe = lt(() => {
        var ie;
        return (ie = l.map) == null ? void 0 : ie.getCanvas()
      });
      var mt = AI(),
        ut = k(mt),
        Ke = k(ut);
      wI(Ke, {
        class: "inline size-5"
      });
      var ct = V(Ke);
      A(ut);
      var tt = V(ut, 2);
      {
        var Re = ie => {
            var Se = PI();
            Xe(() => {
              kr(Se, "src", x(N)), kr(Se, "width", x(Fe).width), kr(Se, "height", x(Fe).height)
            }), H(ie, Se)
          },
          ot = ie => {
            var Se = II();
            Xe(() => cc(Se, `aspect-ratio: ${x(Fe).width/x(Fe).height}`)), H(ie, Se)
          };
        Ue(tt, ie => {
          x(N) ? ie(Re) : ie(ot, !1)
        })
      }
      var rt = V(tt, 2),
        Qe = k(rt);
      Qe.__click = [MI, D];
      var Ae = k(Qe);
      Bg(Ae, {
        class: "size-5"
      });
      var gt = V(Ae);
      A(Qe);
      var ee = V(Qe, 2),
        te = k(ee);
      Dg(te, {
        class: "size-5"
      });
      var fe = V(te);
      A(ee), A(rt), A(mt), Xe((ie, Se, Me, nt) => {
        ve(ct, ` ${ie??""}`), ve(gt, ` ${Se??""}`), kr(ee, "href", x(N)), kr(ee, "download", `wplace_${Me??""}.png`), ve(fe, ` ${nt??""}`)
      }, [() => UC(), () => mf(), () => CI().replaceAll(" ", "_").replaceAll(":", "-"), () => GC()]), zn(2, mt, () => ea, () => ({
        duration: 300
      })), H(Le, mt)
    };
    Ue(Be, Le => {
      g() && Le(je)
    })
  }
  A(o), vi(2), A(T), Gn(T, () => Le => {
    Hr(() => {
      g() ? Le.show() : Le.close()
    })
  }), Xe((Le, Fe, mt, ut) => {
    ve(ae, ` ${Le??""}`), Eg(xe, Fe), Ce = Or(Ie, 1, "btn btn-primary", null, Ce, mt), ve(De, ut)
  }, [() => _3(), () => l.url.toString(), () => ({
    "btn-success": x(C)
  }), () => x(C) ? Kf() : mf()]), Pn("close", T, () => g(!1)), H(w, T), Rr()
}
rn(["click"]);
var zI = Cr('<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>');

function LI(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = zI();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var DI = Pe('<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>'),
  RI = Pe('<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p></div></div>');

function om(w, l) {
  Dr(l, !1);
  const g = [I2(), C2(), k2(), L2(), B2(), N2(), V2()];
  qg();
  var C = RI(),
    D = k(C),
    N = k(D);
  LI(N, {
    class: "size-5"
  });
  var T = V(N, 2),
    o = k(T),
    G = V(o),
    W = k(G, !0);
  A(G), A(T), A(D);
  var ae = V(D, 2),
    _e = k(ae);
  gn(_e, 5, () => g, Od, (Ie, Ce) => {
    var De = DI(),
      Be = k(De, !0);
    A(De), Xe(() => ve(Be, x(Ce))), H(Ie, De)
  }), A(_e);
  var xe = V(_e, 2),
    K = k(xe, !0);
  A(xe), A(ae), A(C), Xe((Ie, Ce, De) => {
    ve(o, `${Ie??""} `), ve(W, Ce), ve(K, De)
  }, [() => v2(), () => b2(), () => $2()]), H(w, C), Rr()
}
var BI = (w, l) => {
    l(!1)
  },
  FI = Pe('<dialog class="modal"><div class="modal-box sm:max-h-11/12"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex h-full flex-col gap-6"><h2 class="text-xl font-semibold">ðŸ“‘ Updated rules</h2> <section><!></section> <button class="btn btn-primary">Close</button></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function OI(w, l) {
  Dr(l, !0);
  let g = At(l, "open", 15);
  zi(() => {
    const W = ae => {
      ae.key === "Escape" && g(!1)
    };
    return document.addEventListener("keydown", W), () => document.removeEventListener("keydown", W)
  });
  var C = FI(),
    D = k(C),
    N = V(k(D), 2),
    T = V(k(N), 2),
    o = k(T);
  om(o, {}), A(T);
  var G = V(T, 2);
  G.__click = [BI, g], A(N), A(D), vi(2), A(C), Gn(C, () => W => {
    Hr(() => {
      g() ? W.show() : W.close()
    })
  }), Pn("close", C, () => g(!1)), H(w, C), Rr()
}
rn(["click"]);
var NI = () => {
    fa.url.searchParams.delete("new-user"), Lg(fa.url.toString())
  },
  jI = Pe('<dialog class="modal"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>');

function qI(w, l) {
  Dr(l, !0);
  let g = At(l, "open", 15);
  zi(() => {
    const Ce = De => {
      De.key === "Escape" && g(!1)
    };
    return document.addEventListener("keydown", Ce), () => document.removeEventListener("keydown", Ce)
  });
  var C = jI(),
    D = k(C),
    N = k(D),
    T = k(N),
    o = k(T),
    G = k(o, !0);
  A(o);
  var W = V(o, 2);
  Vg(W, {
    hasText: !0,
    size: "medium"
  }), A(T), A(N);
  var ae = V(N, 2),
    _e = k(ae);
  om(_e, {}), A(ae);
  var xe = V(ae, 2),
    K = k(xe);
  K.__click = [NI];
  var Ie = k(K, !0);
  A(K), A(xe), A(D), A(C), Gn(C, () => Ce => {
    Hr(() => {
      g() ? Ce.show() : Ce.close()
    })
  }), Xe((Ce, De) => {
    ve(G, Ce), ve(Ie, De)
  }, [() => m2(), () => W2()]), Pn("close", C, () => g(!1)), H(w, C), Rr()
}
rn(["click"]);

function VI() {
  const w = navigator.userAgent,
    l = navigator.vendor;
  return /Chrome/.test(w) && /Google Inc/.test(l) ? "Chrome" : /Safari/.test(w) && /Apple Computer/.test(l) ? "Safari" : /Firefox/.test(w) ? "Firefox" : /Edge/.test(w) ? "Edge" : /Opera|OPR/.test(w) ? "Opera" : "Unknown"
}
var UI = Cr('<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>');

function ZI(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = UI();
  er(C, () => ({
    viewBox: "0 0 512 512",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...g
  })), H(w, C)
}
var $I = Cr('<svg><path fill="#0A0A08" d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>');

function GI(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = $I();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    viewBox: "0 0 256 256",
    ...g
  })), H(w, C)
}
var HI = Cr('<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>');

function Ed(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = HI();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var WI = Pe(' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>', 1),
  XI = Pe('<span class="link cursor-auto">chrome://settings/system</span>.', 1),
  KI = Pe('<span class="link cursor-auto">edge://settings/system/manageSystem</span>.', 1),
  YI = Pe(' <kbd class="kbd kbd-sm"> </kbd> <!>', 1),
  JI = Pe('<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a class="link" href="https://www.reddit.com/r/WplaceLive/comments/1lhzmmq/bug_reports_and_feature_requests/" target="_blank"> </a> <span class="mx-0.5">|</span> <a href="https://discord.gg/wplacelive" target="_blank"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank"><!> <span class="link">Instagram</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span> Â· <a class="link" href="https://wplace.live/terms/terms-of-service" target="_blank"> </a> Â· <a class="link" href="https://wplace.live/terms/privacy" target="_blank"> </a></section></div>'),
  QI = Pe('<dialog class="modal"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function eM(w, l) {
  Dr(l, !0);
  let g = At(l, "open", 15);
  zi(() => {
    const _e = xe => {
      xe.key === "Escape" && g(!1)
    };
    return document.addEventListener("keydown", _e), () => document.removeEventListener("keydown", _e)
  });
  const C = VI();
  var D = QI(),
    N = k(D),
    T = V(k(N), 2);
  {
    var o = _e => {
      var xe = JI(),
        K = k(xe),
        Ie = k(K);
      Vg(Ie, {
        hasText: !0,
        size: "medium"
      });
      var Ce = V(Ie, 2),
        De = k(Ce),
        Be = V(De, 4);
      vi(), A(Ce);
      var je = V(Ce, 2),
        Le = k(je),
        Fe = k(Le),
        mt = k(Fe, !0);
      A(Fe);
      var ut = V(Fe, 4),
        Ke = k(ut);
      nm(Ke, {
        class: "mr-0.5 inline size-4"
      }), vi(2), A(ut);
      var ct = V(ut, 4),
        tt = k(ct);
      ZI(tt, {
        class: "mr-0.5 inline size-4"
      }), vi(2), A(ct);
      var Re = V(ct, 4),
        ot = k(Re);
      GI(ot, {
        class: "mr-0.5 inline size-4"
      }), vi(2), A(Re), A(Le), A(je), A(K);
      var rt = V(K, 2),
        Qe = k(rt),
        Ae = k(Qe, !0);
      A(Qe);
      var gt = V(Qe, 2);
      A(rt);
      var ee = V(rt, 2),
        te = k(ee),
        fe = k(te, !0);
      A(te);
      var ie = V(te, 2),
        Se = k(ie),
        Me = V(Se),
        nt = k(Me);
      Ed(nt, {
        class: "size-5"
      }), A(Me);
      var Ye = V(Me);
      A(ie);
      var wt = V(ie, 2),
        zt = k(wt),
        Nt = V(zt),
        st = k(Nt, !0);
      A(Nt);
      var Tt = V(Nt);
      A(wt), A(ee);
      var Ct = V(ee, 2),
        yt = k(Ct),
        Mt = k(yt, !0);
      A(yt);
      var St = V(yt, 2),
        ht = k(St);
      {
        var Lt = Vr => {
            var ur = WI(),
              Pr = It(ur);
            vi(), Xe(Ir => ve(Pr, `${Ir??""}: `), [() => uS()]), H(Vr, ur)
          },
          tr = Vr => {
            var ur = YI(),
              Pr = It(ur),
              Ir = V(Pr),
              Mr = k(Ir, !0);
            A(Ir);
            var Nr = V(Ir),
              ce = V(Nr);
            {
              var F = $ => {
                  var X = XI();
                  vi(), H($, X)
                },
                q = $ => {
                  var X = Kt(),
                    oe = It(X);
                  {
                    var me = Ee => {
                      var Te = KI();
                      vi(), H(Ee, Te)
                    };
                    Ue(oe, Ee => {
                      C === "Edge" && Ee(me)
                    }, !0)
                  }
                  H($, X)
                };
              Ue(ce, $ => {
                C === "Chrome" ? $(F) : $(q, !1)
              })
            }
            Xe(($, X, oe) => {
              ve(Pr, `${$??""} `), ve(Mr, X), ve(Nr, ` ${oe??""} `)
            }, [() => tS(), () => nS(), () => oS()]), H(Vr, ur)
          };
        Ue(ht, Vr => {
          C !== "Chrome" && C !== "Edge" ? Vr(Lt) : Vr(tr, !1)
        })
      }
      A(St), A(Ct);
      var Jt = V(Ct, 2),
        dr = k(Jt);
      om(dr, {}), A(Jt);
      var nr = V(Jt, 4),
        Bt = V(k(nr), 2),
        pr = k(Bt, !0);
      A(Bt);
      var gr = V(Bt, 2),
        Sr = k(gr, !0);
      A(gr), A(nr), A(xe), Xe((Vr, ur, Pr, Ir, Mr, Nr, ce, F, q, $, X, oe, me) => {
        ve(De, `${Vr??""} `), ve(Be, ` Â©
						${ur??""} `), ve(mt, Pr), ve(Ae, Ir), kr(gt, "src", oa.language === "pt" ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9" : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"), ve(fe, Mr), ve(Se, `${Nr??""} `), ve(Ye, ` ${ce??""}`), ve(zt, `${F??""} `), ve(st, q), ve(Tt, ` ${$??""}`), ve(Mt, X), ve(pr, oe), ve(Sr, me)
      }, [() => c1(), () => d1(), () => m1(), () => v1(), () => b1(), () => C1(), () => I1(), () => k1(), () => L1(), () => B1(), () => JC(), () => _S(), () => yS()]), zn(2, xe, () => ea, () => ({
        duration: 300
      })), H(_e, xe)
    };
    Ue(T, _e => {
      g() && _e(o)
    })
  }
  A(N);
  var G = V(N, 2),
    W = k(G),
    ae = k(W, !0);
  A(W), A(G), A(D), Gn(D, () => _e => {
    Hr(() => {
      g() ? _e.show() : _e.close()
    })
  }), Xe(_e => ve(ae, _e), [() => ec()]), Pn("close", D, () => g(!1)), H(w, D), Rr()
}

function tM(w) {
  return typeof w == "function"
}

function ph(w) {
  return w !== null && typeof w == "object"
}
const rM = ["string", "number", "bigint", "boolean"];

function xf(w) {
  return w == null || rM.includes(typeof w) ? !0 : Array.isArray(w) ? w.every(l => xf(l)) : typeof w == "object" ? Object.getPrototypeOf(w) === Object.prototype : !1
}
const Su = Symbol("box"),
  lm = Symbol("is-writable");

function iM(w) {
  return ph(w) && Su in w
}

function nM(w) {
  return cr.isBox(w) && lm in w
}

function cr(w) {
  let l = at(Ln(w));
  return {
    [Su]: !0,
    [lm]: !0,
    get current() {
      return x(l)
    },
    set current(g) {
      le(l, g, !0)
    }
  }
}

function aM(w, l) {
  const g = lt(w);
  return l ? {
    [Su]: !0,
    [lm]: !0,
    get current() {
      return x(g)
    },
    set current(C) {
      l(C)
    }
  } : {
    [Su]: !0,
    get current() {
      return w()
    }
  }
}

function sM(w) {
  return cr.isBox(w) ? w : tM(w) ? cr.with(w) : cr(w)
}

function oM(w) {
  return Object.entries(w).reduce((l, [g, C]) => cr.isBox(C) ? (cr.isWritableBox(C) ? Object.defineProperty(l, g, {
    get() {
      return C.current
    },
    set(D) {
      C.current = D
    }
  }) : Object.defineProperty(l, g, {
    get() {
      return C.current
    }
  }), l) : Object.assign(l, {
    [g]: C
  }), {})
}

function lM(w) {
  return cr.isWritableBox(w) ? {
    [Su]: !0,
    get current() {
      return w.current
    }
  } : w
}
cr.from = sM;
cr.with = aM;
cr.flatten = oM;
cr.readonly = lM;
cr.isBox = iM;
cr.isWritableBox = nM;

function cM(...w) {
  return function(l) {
    var g;
    for (const C of w)
      if (C) {
        if (l.defaultPrevented) return;
        typeof C == "function" ? C.call(this, l) : (g = C.current) == null || g.call(this, l)
      }
  }
}
var Hl = {},
  sf, fg;

function uM() {
  if (fg) return sf;
  fg = 1;
  var w = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
    l = /\n/g,
    g = /^\s*/,
    C = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
    D = /^:\s*/,
    N = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
    T = /^[;\s]*/,
    o = /^\s+|\s+$/g,
    G = `
`,
    W = "/",
    ae = "*",
    _e = "",
    xe = "comment",
    K = "declaration";
  sf = function(Ce, De) {
    if (typeof Ce != "string") throw new TypeError("First argument must be a string");
    if (!Ce) return [];
    De = De || {};
    var Be = 1,
      je = 1;

    function Le(Qe) {
      var Ae = Qe.match(l);
      Ae && (Be += Ae.length);
      var gt = Qe.lastIndexOf(G);
      je = ~gt ? Qe.length - gt : je + Qe.length
    }

    function Fe() {
      var Qe = {
        line: Be,
        column: je
      };
      return function(Ae) {
        return Ae.position = new mt(Qe), ct(), Ae
      }
    }

    function mt(Qe) {
      this.start = Qe, this.end = {
        line: Be,
        column: je
      }, this.source = De.source
    }
    mt.prototype.content = Ce;

    function ut(Qe) {
      var Ae = new Error(De.source + ":" + Be + ":" + je + ": " + Qe);
      if (Ae.reason = Qe, Ae.filename = De.source, Ae.line = Be, Ae.column = je, Ae.source = Ce, !De.silent) throw Ae
    }

    function Ke(Qe) {
      var Ae = Qe.exec(Ce);
      if (Ae) {
        var gt = Ae[0];
        return Le(gt), Ce = Ce.slice(gt.length), Ae
      }
    }

    function ct() {
      Ke(g)
    }

    function tt(Qe) {
      var Ae;
      for (Qe = Qe || []; Ae = Re();) Ae !== !1 && Qe.push(Ae);
      return Qe
    }

    function Re() {
      var Qe = Fe();
      if (!(W != Ce.charAt(0) || ae != Ce.charAt(1))) {
        for (var Ae = 2; _e != Ce.charAt(Ae) && (ae != Ce.charAt(Ae) || W != Ce.charAt(Ae + 1));) ++Ae;
        if (Ae += 2, _e === Ce.charAt(Ae - 1)) return ut("End of comment missing");
        var gt = Ce.slice(2, Ae - 2);
        return je += 2, Le(gt), Ce = Ce.slice(Ae), je += 2, Qe({
          type: xe,
          comment: gt
        })
      }
    }

    function ot() {
      var Qe = Fe(),
        Ae = Ke(C);
      if (Ae) {
        if (Re(), !Ke(D)) return ut("property missing ':'");
        var gt = Ke(N),
          ee = Qe({
            type: K,
            property: Ie(Ae[0].replace(w, _e)),
            value: gt ? Ie(gt[0].replace(w, _e)) : _e
          });
        return Ke(T), ee
      }
    }

    function rt() {
      var Qe = [];
      tt(Qe);
      for (var Ae; Ae = ot();) Ae !== !1 && (Qe.push(Ae), tt(Qe));
      return Qe
    }
    return ct(), rt()
  };

  function Ie(Ce) {
    return Ce ? Ce.replace(o, _e) : _e
  }
  return sf
}
var mg;

function hM() {
  if (mg) return Hl;
  mg = 1;
  var w = Hl && Hl.__importDefault || function(C) {
    return C && C.__esModule ? C : {
      default: C
    }
  };
  Object.defineProperty(Hl, "__esModule", {
    value: !0
  }), Hl.default = g;
  var l = w(uM());

  function g(C, D) {
    var N = null;
    if (!C || typeof C != "string") return N;
    var T = (0, l.default)(C),
      o = typeof D == "function";
    return T.forEach(function(G) {
      if (G.type === "declaration") {
        var W = G.property,
          ae = G.value;
        o ? D(W, ae, G) : ae && (N = N || {}, N[W] = ae)
      }
    }), N
  }
  return Hl
}
var dM = hM();
const _g = im(dM),
  pM = _g.default || _g,
  fM = /\d/,
  mM = ["-", "_", "/", "."];

function _M(w = "") {
  if (!fM.test(w)) return w !== w.toLowerCase()
}

function gM(w) {
  const l = [];
  let g = "",
    C, D;
  for (const N of w) {
    const T = mM.includes(N);
    if (T === !0) {
      l.push(g), g = "", C = void 0;
      continue
    }
    const o = _M(N);
    if (D === !1) {
      if (C === !1 && o === !0) {
        l.push(g), g = N, C = o;
        continue
      }
      if (C === !0 && o === !1 && g.length > 1) {
        const G = g.at(-1);
        l.push(g.slice(0, Math.max(0, g.length - 1))), g = G + N, C = o;
        continue
      }
    }
    g += N, C = o, D = T
  }
  return l.push(g), l
}

function av(w) {
  return w ? gM(w).map(l => yM(l)).join("") : ""
}

function vM(w) {
  return xM(av(w || ""))
}

function yM(w) {
  return w ? w[0].toUpperCase() + w.slice(1) : ""
}

function xM(w) {
  return w ? w[0].toLowerCase() + w.slice(1) : ""
}

function xd(w) {
  if (!w) return {};
  const l = {};

  function g(C, D) {
    if (C.startsWith("-moz-") || C.startsWith("-webkit-") || C.startsWith("-ms-") || C.startsWith("-o-")) {
      l[av(C)] = D;
      return
    }
    if (C.startsWith("--")) {
      l[C] = D;
      return
    }
    l[vM(C)] = D
  }
  return pM(w, g), l
}

function bM(...w) {
  return (...l) => {
    for (const g of w) typeof g == "function" && g(...l)
  }
}

function wM(w, l) {
  const g = RegExp(w, "g");
  return C => {
    if (typeof C != "string") throw new TypeError(`expected an argument of type string, but got ${typeof C}`);
    return C.match(g) ? C.replace(g, l) : C
  }
}
const TM = wM(/[A-Z]/, w => `-${w.toLowerCase()}`);

function CM(w) {
  if (!w || typeof w != "object" || Array.isArray(w)) throw new TypeError(`expected an argument of type object, but got ${typeof w}`);
  return Object.keys(w).map(l => `${TM(l)}: ${w[l]};`).join(`
`)
}

function sv(w = {}) {
  return CM(w).replace(`
`, " ")
}
const ov = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
sv(ov);
const SM = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"],
  PM = new Set(SM);

function IM(w) {
  return PM.has(w)
}

function La(...w) {
  const l = {
    ...w[0]
  };
  for (let g = 1; g < w.length; g++) {
    const C = w[g];
    if (C) {
      for (const D of Object.keys(C)) {
        const N = l[D],
          T = C[D],
          o = typeof N == "function",
          G = typeof T == "function";
        if (o && IM(D)) {
          const W = N,
            ae = T;
          l[D] = cM(W, ae)
        } else if (o && G) l[D] = bM(N, T);
        else if (D === "class") {
          const W = xf(N),
            ae = xf(T);
          W && ae ? l[D] = wu(N, T) : W ? l[D] = wu(N) : ae && (l[D] = wu(T))
        } else if (D === "style") {
          const W = typeof N == "object",
            ae = typeof T == "object",
            _e = typeof N == "string",
            xe = typeof T == "string";
          if (W && ae) l[D] = {
            ...N,
            ...T
          };
          else if (W && xe) {
            const K = xd(T);
            l[D] = {
              ...N,
              ...K
            }
          } else if (_e && ae) {
            const K = xd(N);
            l[D] = {
              ...K,
              ...T
            }
          } else if (_e && xe) {
            const K = xd(N),
              Ie = xd(T);
            l[D] = {
              ...K,
              ...Ie
            }
          } else W ? l[D] = N : ae ? l[D] = T : _e ? l[D] = N : xe && (l[D] = T)
        } else l[D] = T !== void 0 ? T : N
      }
      for (const D of Object.getOwnPropertySymbols(C)) {
        const N = l[D],
          T = C[D];
        l[D] = T !== void 0 ? T : N
      }
    }
  }
  return typeof l.style == "object" && (l.style = sv(l.style).replaceAll(`
`, " ")), l.hidden !== !0 && (l.hidden = void 0, delete l.hidden), l.disabled !== !0 && (l.disabled = void 0, delete l.disabled), l
}
const MM = typeof window < "u" ? window : void 0;

function AM(w) {
  let l = w.activeElement;
  for (; l != null && l.shadowRoot;) {
    const g = l.shadowRoot.activeElement;
    if (g === l) break;
    l = g
  }
  return l
}
var rc, Eu;
class kM {
  constructor(l = {}) {
    xr(this, rc);
    xr(this, Eu);
    const {
      window: g = MM,
      document: C = g == null ? void 0 : g.document
    } = l;
    g !== void 0 && (Qn(this, rc, C), Qn(this, Eu, zg(D => {
      const N = Tu(g, "focusin", D),
        T = Tu(g, "focusout", D);
      return () => {
        N(), T()
      }
    })))
  }
  get current() {
    var l;
    return (l = Je(this, Eu)) == null || l.call(this), Je(this, rc) ? AM(Je(this, rc)) : null
  }
}
rc = new WeakMap, Eu = new WeakMap;
new kM;
var zu, Es;
class cm {
  constructor(l) {
    xr(this, zu);
    xr(this, Es);
    Qn(this, zu, l), Qn(this, Es, Symbol(l))
  }
  get key() {
    return Je(this, Es)
  }
  exists() {
    return Ry(Je(this, Es))
  }
  get() {
    const l = ng(Je(this, Es));
    if (l === void 0) throw new Error(`Context "${Je(this,zu)}" not found`);
    return l
  }
  getOr(l) {
    const g = ng(Je(this, Es));
    return g === void 0 ? l : g
  }
  set(l) {
    return By(Je(this, Es), l)
  }
}
zu = new WeakMap, Es = new WeakMap;

function EM(w, l) {
  switch (w) {
    case "post":
      Hr(l);
      break;
    case "pre":
      Vf(l);
      break
  }
}

function lv(w, l, g, C = {}) {
  const {
    lazy: D = !1
  } = C;
  let N = !D,
    T = Array.isArray(w) ? [] : void 0;
  EM(l, () => {
    const o = Array.isArray(w) ? w.map(W => W()) : w();
    if (!N) {
      N = !0, T = o;
      return
    }
    const G = Go(() => g(o, T));
    return T = o, G
  })
}

function lo(w, l, g) {
  lv(w, "post", l, g)
}

function zM(w, l, g) {
  lv(w, "pre", l, g)
}
lo.pre = zM;
var ic;
class LM {
  constructor(l, g) {
    xr(this, ic, at(void 0));
    g !== void 0 && le(Je(this, ic), g, !0), lo(() => l(), (C, D) => {
      le(Je(this, ic), D, !0)
    })
  }
  get current() {
    return x(Je(this, ic))
  }
}
ic = new WeakMap;

function DM(w, l) {
  return setTimeout(l, w)
}

function Wl(w) {
  Mg().then(w)
}
const RM = 1,
  BM = 9,
  FM = 11;

function OM(w) {
  return ph(w) && w.nodeType === RM && typeof w.nodeName == "string"
}

function cv(w) {
  return ph(w) && w.nodeType === BM
}

function NM(w) {
  var l;
  return ph(w) && ((l = w.constructor) == null ? void 0 : l.name) === "VisualViewport"
}

function jM(w) {
  return ph(w) && w.nodeType !== void 0
}

function qM(w) {
  return jM(w) && w.nodeType === FM && "host" in w
}

function VM(w) {
  return cv(w) ? w : NM(w) ? w.document : (w == null ? void 0 : w.ownerDocument) ?? document
}

function uv(w) {
  var l;
  return qM(w) ? uv(w.host) : cv(w) ? w.defaultView ?? window : OM(w) ? ((l = w.ownerDocument) == null ? void 0 : l.defaultView) ?? window : window
}

function UM(w) {
  let l = w.activeElement;
  for (; l != null && l.shadowRoot;) {
    const g = l.shadowRoot.activeElement;
    if (g === l) break;
    l = g
  }
  return l
}
var Lu;
class ZM {
  constructor(l) {
    lr(this, "element");
    xr(this, Lu, lt(() => this.element.current ? this.element.current.getRootNode() ?? document : document));
    lr(this, "getDocument", () => VM(this.root));
    lr(this, "getWindow", () => this.getDocument().defaultView ?? window);
    lr(this, "getActiveElement", () => UM(this.root));
    lr(this, "isActiveElement", l => l === this.getActiveElement());
    lr(this, "querySelector", l => this.root ? this.root.querySelector(l) : null);
    lr(this, "querySelectorAll", l => this.root ? this.root.querySelectorAll(l) : []);
    lr(this, "setTimeout", (l, g) => this.getWindow().setTimeout(l, g));
    lr(this, "clearTimeout", l => this.getWindow().clearTimeout(l));
    typeof l == "function" ? this.element = cr.with(l) : this.element = l
  }
  get root() {
    return x(Je(this, Lu))
  }
  set root(l) {
    le(Je(this, Lu), l)
  }
  getElementById(l) {
    return this.root.getElementById(l)
  }
}
Lu = new WeakMap;

function qa(w, l) {
  return {
    [yx()]: g => cr.isBox(w) ? (w.current = g, Go(() => l == null ? void 0 : l(g)), () => {
      "isConnected" in g && g.isConnected || (w.current = null, l == null || l(null))
    }) : (w(g), Go(() => l == null ? void 0 : l(g)), () => {
      "isConnected" in g && g.isConnected || (w(null), l == null || l(null))
    })
  }
}

function $M(w) {
  return w ? "true" : "false"
}

function GM(w) {
  return w ? "true" : "false"
}

function HM(w) {
  return w ? "" : void 0
}

function WM(w) {
  return w ? "true" : "false"
}

function XM(w) {
  return w ? "" : void 0
}

function KM(w) {
  return w ? !0 : void 0
}
var nc, Du;
class YM {
  constructor(l) {
    xr(this, nc);
    xr(this, Du);
    lr(this, "attrs");
    Qn(this, nc, l.getVariant ? l.getVariant() : null), Qn(this, Du, Je(this, nc) ? `data-${Je(this,nc)}-` : `data-${l.component}-`), this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(l.parts.map(g => [g, this.getAttr(g)]))
  }
  getAttr(l, g) {
    return g ? `data-${g}-${l}` : `${Je(this,Du)}${l}`
  }
  selector(l, g) {
    return `[${this.getAttr(l,g)}]`
  }
}
nc = new WeakMap, Du = new WeakMap;

function hv(w) {
  const l = new YM(w);
  return {
    ...l.attrs,
    selector: l.selector,
    getAttr: l.getAttr
  }
}
const JM = "ArrowDown",
  QM = "ArrowLeft",
  e4 = "ArrowRight",
  t4 = "ArrowUp",
  r4 = "End",
  i4 = "Enter",
  n4 = "Home",
  a4 = "p",
  s4 = "n",
  o4 = "j",
  l4 = "k",
  c4 = "h",
  u4 = "l";

function Pu() {}

function Va(w, l) {
  return `bits-${w}`
}

function h4(w) {
  if (!w) return null;
  for (const l of w.childNodes)
    if (l.nodeType !== Node.COMMENT_NODE) return l;
  return null
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = {
  current: 0
});

function d4(w = "bits") {
  return globalThis.bitsIdCounter.current++, `${w}-${globalThis.bitsIdCounter.current}`
}

function p4(w, l) {
  let g = w.nextElementSibling;
  for (; g;) {
    if (g.matches(l)) return g;
    g = g.nextElementSibling
  }
}

function f4(w, l) {
  let g = w.previousElementSibling;
  for (; g;) {
    if (g.matches(l)) return g;
    g = g.previousElementSibling
  }
}

function dv(w) {
  if (typeof CSS < "u" && typeof CSS.escape == "function") return CSS.escape(w);
  const l = w.length;
  let g = -1,
    C, D = "";
  const N = w.charCodeAt(0);
  if (l === 1 && N === 45) return "\\" + w;
  for (; ++g < l;) {
    if (C = w.charCodeAt(g), C === 0) {
      D += "ï¿½";
      continue
    }
    if (C >= 1 && C <= 31 || C === 127 || g === 0 && C >= 48 && C <= 57 || g === 1 && C >= 48 && C <= 57 && N === 45) {
      D += "\\" + C.toString(16) + " ";
      continue
    }
    if (C >= 128 || C === 45 || C === 95 || C >= 48 && C <= 57 || C >= 65 && C <= 90 || C >= 97 && C <= 122) {
      D += w.charAt(g);
      continue
    }
    D += "\\" + w.charAt(g)
  }
  return D
}
const Uo = "data-value",
  _a = hv({
    component: "command",
    parts: ["root", "list", "input", "separator", "loading", "empty", "group", "group-items", "group-heading", "item", "viewport", "input-label"]
  }),
  Xl = _a.selector("group"),
  of = _a.selector("group-items"),
  gg = _a.selector("group-heading"),
  pv = _a.selector("item"),
  lf = `${_a.selector("item")}:not([aria-disabled="true"])`,
  Xo = new cm("Command.Root"),
  m4 = new cm("Command.List"),
  Iu = new cm("Command.Group"),
  vg = {
    search: "",
    value: "",
    filtered: {
      count: 0,
      items: new Map,
      groups: new Set
    }
  };
var ac, Ru, Bu, Fu, Ou, Nu, ju, qu, ir, fv, Sd, wf, Pd, Id, Md, no, mv, _v, Tf, vu, Cf, Sf, gv, yu, Pf, If, vv, xu, bu, Vu;
const dm = class dm {
  constructor(l) {
    xr(this, ir);
    lr(this, "opts");
    lr(this, "attachment");
    xr(this, ac, !1);
    xr(this, Ru, !0);
    lr(this, "sortAfterTick", !1);
    lr(this, "sortAndFilterAfterTick", !1);
    lr(this, "allItems", new Set);
    lr(this, "allGroups", new Map);
    lr(this, "allIds", new Map);
    xr(this, Bu, at(0));
    xr(this, Fu, at(null));
    xr(this, Ou, at(null));
    xr(this, Nu, at(null));
    xr(this, ju, at(vg));
    xr(this, qu, at(Ln(vg)));
    xr(this, Vu, lt(() => ({
      id: this.opts.id.current,
      role: "application",
      [_a.root]: "",
      tabindex: -1,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = l, this.attachment = qa(this.opts.ref);
    const g = {
      ...this._commandState,
      value: this.opts.value.current ?? ""
    };
    this._commandState = g, this.commandState = g, this.onkeydown = this.onkeydown.bind(this)
  }
  static create(l) {
    return Xo.set(new dm(l))
  }
  get key() {
    return x(Je(this, Bu))
  }
  set key(l) {
    le(Je(this, Bu), l, !0)
  }
  get viewportNode() {
    return x(Je(this, Fu))
  }
  set viewportNode(l) {
    le(Je(this, Fu), l, !0)
  }
  get inputNode() {
    return x(Je(this, Ou))
  }
  set inputNode(l) {
    le(Je(this, Ou), l, !0)
  }
  get labelNode() {
    return x(Je(this, Nu))
  }
  set labelNode(l) {
    le(Je(this, Nu), l, !0)
  }
  get commandState() {
    return x(Je(this, ju))
  }
  set commandState(l) {
    le(Je(this, ju), l)
  }
  get _commandState() {
    return x(Je(this, qu))
  }
  set _commandState(l) {
    le(Je(this, qu), l, !0)
  }
  setState(l, g, C) {
    Object.is(this._commandState[l], g) || (this._commandState[l] = g, l === "search" ? (Fr(this, ir, Md).call(this), Fr(this, ir, Pd).call(this)) : l === "value" && (C || Fr(this, ir, mv).call(this)), Fr(this, ir, Sd).call(this))
  }
  setValue(l, g) {
    l !== this.opts.value.current && l === "" && Wl(() => {
      this.key++
    }), this.setState("value", l, g), this.opts.value.current = l
  }
  getValidItems() {
    const l = this.opts.ref.current;
    return l ? Array.from(l.querySelectorAll(lf)).filter(C => !!C) : []
  }
  getVisibleItems() {
    const l = this.opts.ref.current;
    return l ? Array.from(l.querySelectorAll(pv)).filter(C => !!C) : []
  }
  get itemsGrid() {
    var o, G, W, ae;
    if (!this.isGrid) return [];
    const l = this.opts.columns.current ?? 1,
      g = this.getVisibleItems(),
      C = [
        []
      ];
    let D = (o = g[0]) == null ? void 0 : o.getAttribute("data-group"),
      N = 0,
      T = 0;
    for (let _e = 0; _e < g.length; _e++) {
      const xe = g[_e],
        K = xe == null ? void 0 : xe.getAttribute("data-group");
      D !== K ? (D = K, N = 1, T++, C.push([{
        index: _e,
        firstRowOfGroup: !0,
        ref: xe
      }])) : (N++, N > l && (T++, N = 1, C.push([])), (ae = C[T]) == null || ae.push({
        index: _e,
        firstRowOfGroup: ((W = (G = C[T]) == null ? void 0 : G[0]) == null ? void 0 : W.firstRowOfGroup) ?? _e === 0,
        ref: xe
      }))
    }
    return C
  }
  updateSelectedToIndex(l) {
    const g = this.getValidItems()[l];
    g && this.setValue(g.getAttribute(Uo) ?? "")
  }
  updateSelectedByItem(l) {
    const g = Fr(this, ir, no).call(this),
      C = this.getValidItems(),
      D = C.findIndex(T => T === g);
    let N = C[D + l];
    this.opts.loop.current && (N = D + l < 0 ? C[C.length - 1] : D + l === C.length ? C[0] : C[D + l]), N && this.setValue(N.getAttribute(Uo) ?? "")
  }
  updateSelectedByGroup(l) {
    const g = Fr(this, ir, no).call(this);
    let C = g == null ? void 0 : g.closest(Xl),
      D;
    for (; C && !D;) C = l > 0 ? p4(C, Xl) : f4(C, Xl), D = C == null ? void 0 : C.querySelector(lf);
    D ? this.setValue(D.getAttribute(Uo) ?? "") : this.updateSelectedByItem(l)
  }
  registerValue(l, g) {
    var C;
    return l && l === ((C = this.allIds.get(l)) == null ? void 0 : C.value) || this.allIds.set(l, {
      value: l,
      keywords: g
    }), this._commandState.filtered.items.set(l, Fr(this, ir, wf).call(this, l, g)), this.sortAfterTick || (this.sortAfterTick = !0, Wl(() => {
      Fr(this, ir, Pd).call(this), this.sortAfterTick = !1
    })), () => {
      this.allIds.delete(l)
    }
  }
  registerItem(l, g) {
    return this.allItems.add(l), g && (this.allGroups.has(g) ? this.allGroups.get(g).add(l) : this.allGroups.set(g, new Set([l]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, Wl(() => {
      Fr(this, ir, Md).call(this), Fr(this, ir, Pd).call(this), this.sortAndFilterAfterTick = !1
    })), Fr(this, ir, Sd).call(this), () => {
      const C = Fr(this, ir, no).call(this);
      this.allIds.delete(l), this.allItems.delete(l), this.commandState.filtered.items.delete(l), Fr(this, ir, Md).call(this), (C == null ? void 0 : C.getAttribute("id")) === l && Fr(this, ir, Id).call(this), Fr(this, ir, Sd).call(this)
    }
  }
  registerGroup(l) {
    return this.allGroups.has(l) || this.allGroups.set(l, new Set), () => {
      this.allIds.delete(l), this.allGroups.delete(l)
    }
  }
  get isGrid() {
    return this.opts.columns.current !== null
  }
  onkeydown(l) {
    const g = this.opts.vimBindings.current && l.ctrlKey;
    switch (l.key) {
      case s4:
      case o4: {
        g && (this.isGrid ? Fr(this, ir, Cf).call(this, l) : Fr(this, ir, vu).call(this, l));
        break
      }
      case u4: {
        g && this.isGrid && Fr(this, ir, vu).call(this, l);
        break
      }
      case JM:
        this.isGrid ? Fr(this, ir, Cf).call(this, l) : Fr(this, ir, vu).call(this, l);
        break;
      case e4:
        if (!this.isGrid) break;
        Fr(this, ir, vu).call(this, l);
        break;
      case a4:
      case l4: {
        g && (this.isGrid ? Fr(this, ir, If).call(this, l) : Fr(this, ir, bu).call(this, l));
        break
      }
      case c4: {
        g && this.isGrid && Fr(this, ir, bu).call(this, l);
        break
      }
      case t4:
        this.isGrid ? Fr(this, ir, If).call(this, l) : Fr(this, ir, bu).call(this, l);
        break;
      case QM:
        if (!this.isGrid) break;
        Fr(this, ir, bu).call(this, l);
        break;
      case n4:
        l.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case r4:
        l.preventDefault(), Fr(this, ir, Tf).call(this);
        break;
      case i4:
        if (!l.isComposing && l.keyCode !== 229) {
          l.preventDefault();
          const C = Fr(this, ir, no).call(this);
          C && (C == null || C.click())
        }
    }
  }
  get props() {
    return x(Je(this, Vu))
  }
  set props(l) {
    le(Je(this, Vu), l)
  }
};
ac = new WeakMap, Ru = new WeakMap, Bu = new WeakMap, Fu = new WeakMap, Ou = new WeakMap, Nu = new WeakMap, ju = new WeakMap, qu = new WeakMap, ir = new WeakSet, fv = function() {
  return vx(this._commandState)
}, Sd = function() {
  Je(this, ac) || (Qn(this, ac, !0), Wl(() => {
    var C, D;
    Qn(this, ac, !1);
    const l = Fr(this, ir, fv).call(this);
    !Object.is(this.commandState, l) && (this.commandState = l, (D = (C = this.opts.onStateChange) == null ? void 0 : C.current) == null || D.call(C, l))
  }))
}, wf = function(l, g) {
  const C = this.opts.filter.current ?? bv;
  return l ? C(l, this._commandState.search, g) : 0
}, Pd = function() {
  var T;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    Fr(this, ir, Id).call(this);
    return
  }
  const l = this._commandState.filtered.items,
    g = [];
  for (const o of this._commandState.filtered.groups) {
    const G = this.allGroups.get(o);
    let W = 0;
    if (!G) {
      g.push([o, W]);
      continue
    }
    for (const ae of G) {
      const _e = l.get(ae);
      W = Math.max(_e ?? 0, W)
    }
    g.push([o, W])
  }
  const C = this.viewportNode,
    D = this.getValidItems().sort((o, G) => {
      const W = o.getAttribute("data-value"),
        ae = G.getAttribute("data-value"),
        _e = l.get(W) ?? 0;
      return (l.get(ae) ?? 0) - _e
    });
  for (const o of D) {
    const G = o.closest(of);
    if (G) {
      const W = o.parentElement === G ? o : o.closest(`${of} > *`);
      W && G.appendChild(W)
    } else {
      const W = o.parentElement === C ? o : o.closest(`${of} > *`);
      W && (C == null || C.appendChild(W))
    }
  }
  const N = g.sort((o, G) => G[1] - o[1]);
  for (const o of N) {
    const G = C == null ? void 0 : C.querySelector(`${Xl}[${Uo}="${dv(o[0])}"]`);
    (T = G == null ? void 0 : G.parentElement) == null || T.appendChild(G)
  }
  Fr(this, ir, Id).call(this)
}, Id = function() {
  Wl(() => {
    const l = this.getValidItems().find(D => D.getAttribute("aria-disabled") !== "true"),
      g = l == null ? void 0 : l.getAttribute(Uo),
      C = Je(this, Ru) && this.opts.disableInitialScroll.current;
    this.setValue(g ?? "", C), Qn(this, Ru, !1)
  })
}, Md = function() {
  var g, C;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    this._commandState.filtered.count = this.allItems.size;
    return
  }
  this._commandState.filtered.groups = new Set;
  let l = 0;
  for (const D of this.allItems) {
    const N = ((g = this.allIds.get(D)) == null ? void 0 : g.value) ?? "",
      T = ((C = this.allIds.get(D)) == null ? void 0 : C.keywords) ?? [],
      o = Fr(this, ir, wf).call(this, N, T);
    this._commandState.filtered.items.set(D, o), o > 0 && l++
  }
  for (const [D, N] of this.allGroups)
    for (const T of N) {
      const o = this._commandState.filtered.items.get(T);
      if (o && o > 0) {
        this._commandState.filtered.groups.add(D);
        break
      }
    }
  this._commandState.filtered.count = l
}, no = function() {
  const l = this.opts.ref.current;
  if (!l) return;
  const g = l.querySelector(`${lf}[data-selected]`);
  if (g) return g
}, mv = function() {
  Wl(() => {
    var C, D, N, T, o;
    const l = Fr(this, ir, no).call(this);
    if (!l) return;
    const g = (C = l.parentElement) == null ? void 0 : C.parentElement;
    if (g) {
      if (this.isGrid) {
        const G = Fr(this, ir, _v).call(this, l);
        if (l.scrollIntoView({
            block: "nearest"
          }), G) {
          const W = (D = l == null ? void 0 : l.closest(Xl)) == null ? void 0 : D.querySelector(gg);
          W == null || W.scrollIntoView({
            block: "nearest"
          });
          return
        }
      } else {
        const G = h4(g);
        if (G && ((N = G.dataset) == null ? void 0 : N.value) === ((T = l.dataset) == null ? void 0 : T.value)) {
          const W = (o = l == null ? void 0 : l.closest(Xl)) == null ? void 0 : o.querySelector(gg);
          W == null || W.scrollIntoView({
            block: "nearest"
          });
          return
        }
      }
      l.scrollIntoView({
        block: "nearest"
      })
    }
  })
}, _v = function(l) {
  const g = this.itemsGrid;
  if (g.length === 0) return !1;
  for (let C = 0; C < g.length; C++) {
    const D = g[C];
    if (D !== void 0)
      for (let N = 0; N < D.length; N++) {
        const T = D[N];
        if (!(T === void 0 || T.ref !== l)) return T.firstRowOfGroup
      }
  }
  return !1
}, Tf = function() {
  return this.updateSelectedToIndex(this.getValidItems().length - 1)
}, vu = function(l) {
  l.preventDefault(), l.metaKey ? Fr(this, ir, Tf).call(this) : l.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1)
}, Cf = function(l) {
  this.opts.columns.current !== null && (l.preventDefault(), l.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(Fr(this, ir, gv).call(this, l)))
}, Sf = function(l, g) {
  if (g.length === 0) return null;
  for (let C = 0; C < g.length; C++) {
    const D = g[C];
    if (D !== void 0)
      for (let N = 0; N < D.length; N++) {
        const T = D[N];
        if (!(T === void 0 || T.ref !== l)) return {
          columnIndex: N,
          rowIndex: C
        }
      }
  }
  return null
}, gv = function(l) {
  const g = this.itemsGrid,
    C = Fr(this, ir, no).call(this);
  if (!C) return 0;
  const D = Fr(this, ir, Sf).call(this, C, g);
  if (!D) return 0;
  let N = null;
  const T = l.altKey ? 1 : 0;
  if (l.altKey && D.rowIndex === g.length - 2 && !this.opts.loop.current) N = Fr(this, ir, yu).call(this, {
    start: g.length - 1,
    end: g.length,
    expectedColumnIndex: D.columnIndex,
    grid: g
  });
  else if (D.rowIndex === g.length - 1) {
    if (!this.opts.loop.current) return 0;
    N = Fr(this, ir, yu).call(this, {
      start: 0 + T,
      end: D.rowIndex,
      expectedColumnIndex: D.columnIndex,
      grid: g
    })
  } else N = Fr(this, ir, yu).call(this, {
    start: D.rowIndex + 1 + T,
    end: g.length,
    expectedColumnIndex: D.columnIndex,
    grid: g
  }), N === null && this.opts.loop.current && (N = Fr(this, ir, yu).call(this, {
    start: 0,
    end: D.rowIndex,
    expectedColumnIndex: D.columnIndex,
    grid: g
  }));
  return Fr(this, ir, Pf).call(this, C, N)
}, yu = function({
  start: l,
  end: g,
  grid: C,
  expectedColumnIndex: D
}) {
  var T;
  let N = null;
  for (let o = l; o < g; o++) {
    const G = C[o];
    if (N = ((T = G[D]) == null ? void 0 : T.ref) ?? null, N !== null && bd(N)) {
      N = null;
      continue
    }
    if (N === null)
      for (let W = G.length - 1; W >= 0; W--) {
        const ae = G[G.length - 1];
        if (!(ae === void 0 || bd(ae.ref))) {
          N = ae.ref;
          break
        }
      }
    break
  }
  return N
}, Pf = function(l, g) {
  if (g === null) return 0;
  const C = this.getValidItems(),
    D = C.findIndex(T => T === l);
  return C.findIndex(T => T === g) - D
}, If = function(l) {
  this.opts.columns.current !== null && (l.preventDefault(), l.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(Fr(this, ir, vv).call(this, l)))
}, vv = function(l) {
  const g = this.itemsGrid,
    C = Fr(this, ir, no).call(this);
  if (C === void 0) return 0;
  const D = Fr(this, ir, Sf).call(this, C, g);
  if (D === null) return 0;
  let N = null;
  const T = l.altKey ? 1 : 0;
  if (l.altKey && D.rowIndex === 1 && this.opts.loop.current === !1) N = Fr(this, ir, xu).call(this, {
    start: 0,
    end: 0,
    expectedColumnIndex: D.columnIndex,
    grid: g
  });
  else if (D.rowIndex === 0) {
    if (this.opts.loop.current === !1) return 0;
    N = Fr(this, ir, xu).call(this, {
      start: g.length - 1 - T,
      end: D.rowIndex + 1,
      expectedColumnIndex: D.columnIndex,
      grid: g
    })
  } else N = Fr(this, ir, xu).call(this, {
    start: D.rowIndex - 1 - T,
    end: 0,
    expectedColumnIndex: D.columnIndex,
    grid: g
  }), N === null && this.opts.loop.current && (N = Fr(this, ir, xu).call(this, {
    start: g.length - 1,
    end: D.rowIndex + 1,
    expectedColumnIndex: D.columnIndex,
    grid: g
  }));
  return Fr(this, ir, Pf).call(this, C, N)
}, xu = function({
  start: l,
  end: g,
  grid: C,
  expectedColumnIndex: D
}) {
  var T;
  let N = null;
  for (let o = l; o >= g; o--) {
    const G = C[o];
    if (G !== void 0) {
      if (N = ((T = G[D]) == null ? void 0 : T.ref) ?? null, N !== null && bd(N)) {
        N = null;
        continue
      }
      if (N === null)
        for (let W = G.length - 1; W >= 0; W--) {
          const ae = G[G.length - 1];
          if (!(ae === void 0 || bd(ae.ref))) {
            N = ae.ref;
            break
          }
        }
      break
    }
  }
  return N
}, bu = function(l) {
  l.preventDefault(), l.metaKey ? this.updateSelectedToIndex(0) : l.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1)
}, Vu = new WeakMap;
let bf = dm;

function bd(w) {
  return w.getAttribute("aria-disabled") === "true"
}
var Uu, Zu, $u;
const pm = class pm {
  constructor(l, g) {
    lr(this, "opts");
    lr(this, "root");
    lr(this, "attachment");
    xr(this, Uu, lt(() => this.root._commandState.filtered.count === 0 && Je(this, Zu) === !1 || this.opts.forceMount.current));
    xr(this, Zu, !0);
    xr(this, $u, lt(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [_a.empty]: "",
      ...this.attachment
    })));
    this.opts = l, this.root = g, this.attachment = qa(this.opts.ref), Vf(() => {
      Qn(this, Zu, !1)
    })
  }
  static create(l) {
    return new pm(l, Xo.get())
  }
  get shouldRender() {
    return x(Je(this, Uu))
  }
  set shouldRender(l) {
    le(Je(this, Uu), l)
  }
  get props() {
    return x(Je(this, $u))
  }
  set props(l) {
    le(Je(this, $u), l)
  }
};
Uu = new WeakMap, Zu = new WeakMap, $u = new WeakMap;
let Mf = pm;
var Gu, Hu, Wu, Xu;
const fm = class fm {
  constructor(l, g) {
    lr(this, "opts");
    lr(this, "root");
    lr(this, "attachment");
    xr(this, Gu, lt(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue)));
    xr(this, Hu, at(null));
    xr(this, Wu, at(""));
    xr(this, Xu, lt(() => ({
      id: this.opts.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : !0,
      "data-value": this.trueValue,
      [_a.group]: "",
      ...this.attachment
    })));
    this.opts = l, this.root = g, this.attachment = qa(this.opts.ref), this.trueValue = l.value.current ?? l.id.current, lo(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), Hr(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)))
  }
  static create(l) {
    return Iu.set(new fm(l, Xo.get()))
  }
  get shouldRender() {
    return x(Je(this, Gu))
  }
  set shouldRender(l) {
    le(Je(this, Gu), l)
  }
  get headingNode() {
    return x(Je(this, Hu))
  }
  set headingNode(l) {
    le(Je(this, Hu), l, !0)
  }
  get trueValue() {
    return x(Je(this, Wu))
  }
  set trueValue(l) {
    le(Je(this, Wu), l, !0)
  }
  get props() {
    return x(Je(this, Xu))
  }
  set props(l) {
    le(Je(this, Xu), l)
  }
};
Gu = new WeakMap, Hu = new WeakMap, Wu = new WeakMap, Xu = new WeakMap;
let Af = fm;
var Ku;
const mm = class mm {
  constructor(l, g) {
    lr(this, "opts");
    lr(this, "group");
    lr(this, "attachment");
    xr(this, Ku, lt(() => ({
      id: this.opts.id.current,
      [_a["group-heading"]]: "",
      ...this.attachment
    })));
    this.opts = l, this.group = g, this.attachment = qa(this.opts.ref, C => this.group.headingNode = C)
  }
  static create(l) {
    return new mm(l, Iu.get())
  }
  get props() {
    return x(Je(this, Ku))
  }
  set props(l) {
    le(Je(this, Ku), l)
  }
};
Ku = new WeakMap;
let kf = mm;
var Yu;
const _m = class _m {
  constructor(l, g) {
    lr(this, "opts");
    lr(this, "group");
    lr(this, "attachment");
    xr(this, Yu, lt(() => {
      var l;
      return {
        id: this.opts.id.current,
        role: "group",
        [_a["group-items"]]: "",
        "aria-labelledby": ((l = this.group.headingNode) == null ? void 0 : l.id) ?? void 0,
        ...this.attachment
      }
    }));
    this.opts = l, this.group = g, this.attachment = qa(this.opts.ref)
  }
  static create(l) {
    return new _m(l, Iu.get())
  }
  get props() {
    return x(Je(this, Yu))
  }
  set props(l) {
    le(Je(this, Yu), l)
  }
};
Yu = new WeakMap;
let Ef = _m;
var zd, Ju;
const gm = class gm {
  constructor(l, g) {
    lr(this, "opts");
    lr(this, "root");
    lr(this, "attachment");
    xr(this, zd, lt(() => {
      var g;
      const l = (g = this.root.viewportNode) == null ? void 0 : g.querySelector(`${pv}[${Uo}="${dv(this.root.opts.value.current)}"]`);
      if (l != null) return l.getAttribute("id") ?? void 0
    }));
    xr(this, Ju, lt(() => {
      var l, g;
      return {
        id: this.opts.id.current,
        type: "text",
        [_a.input]: "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": GM(!0),
        "aria-controls": ((l = this.root.viewportNode) == null ? void 0 : l.id) ?? void 0,
        "aria-labelledby": ((g = this.root.labelNode) == null ? void 0 : g.id) ?? void 0,
        "aria-activedescendant": x(Je(this, zd)),
        ...this.attachment
      }
    }));
    this.opts = l, this.root = g, this.attachment = qa(this.opts.ref, C => this.root.inputNode = C), lo(() => this.opts.ref.current, () => {
      const C = this.opts.ref.current;
      C && this.opts.autofocus.current && DM(10, () => C.focus())
    }), lo(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current)
    })
  }
  static create(l) {
    return new gm(l, Xo.get())
  }
  get props() {
    return x(Je(this, Ju))
  }
  set props(l) {
    le(Je(this, Ju), l)
  }
};
zd = new WeakMap, Ju = new WeakMap;
let zf = gm;
var so, Ld, Qu, eh, th, Wo, yv, Df, rh;
const vm = class vm {
  constructor(l, g) {
    xr(this, Wo);
    lr(this, "opts");
    lr(this, "root");
    lr(this, "attachment");
    xr(this, so, null);
    xr(this, Ld, lt(() => {
      var l;
      return this.opts.forceMount.current || ((l = Je(this, so)) == null ? void 0 : l.opts.forceMount.current) === !0
    }));
    xr(this, Qu, lt(() => {
      if (this.opts.ref.current, x(Je(this, Ld)) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search) return !0;
      const l = this.root.commandState.filtered.items.get(this.trueValue);
      return l === void 0 ? !1 : l > 0
    }));
    xr(this, eh, lt(() => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
    xr(this, th, at(""));
    xr(this, rh, lt(() => {
      var l;
      return {
        id: this.opts.id.current,
        "aria-disabled": $M(this.opts.disabled.current),
        "aria-selected": WM(this.isSelected),
        "data-disabled": HM(this.opts.disabled.current),
        "data-selected": XM(this.isSelected),
        "data-value": this.trueValue,
        "data-group": (l = Je(this, so)) == null ? void 0 : l.trueValue,
        [_a.item]: "",
        role: "option",
        onpointermove: this.onpointermove,
        onclick: this.onclick,
        ...this.attachment
      }
    }));
    this.opts = l, this.root = g, Qn(this, so, Iu.getOr(null)), this.trueValue = l.value.current, this.attachment = qa(this.opts.ref), lo([() => this.trueValue, () => {
      var C;
      return (C = Je(this, so)) == null ? void 0 : C.trueValue
    }, () => this.opts.forceMount.current], () => {
      var C;
      if (!this.opts.forceMount.current) return this.root.registerItem(this.trueValue, (C = Je(this, so)) == null ? void 0 : C.trueValue)
    }), lo([() => this.opts.value.current, () => this.opts.ref.current], () => {
      var C, D;
      !this.opts.value.current && ((C = this.opts.ref.current) != null && C.textContent) && (this.trueValue = this.opts.ref.current.textContent.trim()), this.root.registerValue(this.trueValue, l.keywords.current.map(N => N.trim())), (D = this.opts.ref.current) == null || D.setAttribute(Uo, this.trueValue)
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this)
  }
  static create(l) {
    const g = Iu.getOr(null);
    return new vm({
      ...l,
      group: g
    }, Xo.get())
  }
  get shouldRender() {
    return x(Je(this, Qu))
  }
  set shouldRender(l) {
    le(Je(this, Qu), l)
  }
  get isSelected() {
    return x(Je(this, eh))
  }
  set isSelected(l) {
    le(Je(this, eh), l)
  }
  get trueValue() {
    return x(Je(this, th))
  }
  set trueValue(l) {
    le(Je(this, th), l, !0)
  }
  onpointermove(l) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || Fr(this, Wo, Df).call(this)
  }
  onclick(l) {
    this.opts.disabled.current || Fr(this, Wo, yv).call(this)
  }
  get props() {
    return x(Je(this, rh))
  }
  set props(l) {
    le(Je(this, rh), l)
  }
};
so = new WeakMap, Ld = new WeakMap, Qu = new WeakMap, eh = new WeakMap, th = new WeakMap, Wo = new WeakSet, yv = function() {
  var l;
  this.opts.disabled.current || (Fr(this, Wo, Df).call(this), (l = this.opts.onSelect) == null || l.current())
}, Df = function() {
  this.opts.disabled.current || this.root.setValue(this.trueValue, !0)
}, rh = new WeakMap;
let Lf = vm;
var ih;
const ym = class ym {
  constructor(l, g) {
    lr(this, "opts");
    lr(this, "root");
    lr(this, "attachment");
    xr(this, ih, lt(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-label": this.opts.ariaLabel.current,
      [_a.list]: "",
      ...this.attachment
    })));
    this.opts = l, this.root = g, this.attachment = qa(this.opts.ref)
  }
  static create(l) {
    return m4.set(new ym(l, Xo.get()))
  }
  get props() {
    return x(Je(this, ih))
  }
  set props(l) {
    le(Je(this, ih), l)
  }
};
ih = new WeakMap;
let Rf = ym;
var nh;
const xm = class xm {
  constructor(l, g) {
    lr(this, "opts");
    lr(this, "root");
    lr(this, "attachment");
    xr(this, nh, lt(() => {
      var l;
      return {
        id: this.opts.id.current,
        [_a["input-label"]]: "",
        for: (l = this.opts.for) == null ? void 0 : l.current,
        style: ov,
        ...this.attachment
      }
    }));
    this.opts = l, this.root = g, this.attachment = qa(this.opts.ref, C => this.root.labelNode = C)
  }
  static create(l) {
    return new xm(l, Xo.get())
  }
  get props() {
    return x(Je(this, nh))
  }
  set props(l) {
    le(Je(this, nh), l)
  }
};
nh = new WeakMap;
let Bf = xm;
var _4 = Pe("<label><!></label>");

function g4(w, l) {
  const g = Qa();
  Dr(l, !0);
  let C = At(l, "id", 19, () => Va(g)),
    D = At(l, "ref", 15, null),
    N = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
  const T = Bf.create({
      id: cr.with(() => C()),
      ref: cr.with(() => D(), ae => D(ae))
    }),
    o = lt(() => La(N, T.props));
  var G = _4();
  er(G, () => ({
    ...x(o)
  }));
  var W = k(G);
  tn(W, () => l.children ?? ma), A(G), H(w, G), Rr()
}
var v4 = Pe("<!> <!>", 1),
  y4 = Pe("<div><!> <!></div>");

function x4(w, l) {
  const g = Qa();
  Dr(l, !0);
  const C = rt => {
    g4(rt, {
      children: (Qe, Ae) => {
        vi();
        var gt = On();
        Xe(() => ve(gt, xe())), H(Qe, gt)
      },
      $$slots: {
        default: !0
      }
    })
  };
  let D = At(l, "id", 19, () => Va(g)),
    N = At(l, "ref", 15, null),
    T = At(l, "value", 15, ""),
    o = At(l, "onValueChange", 3, Pu),
    G = At(l, "onStateChange", 3, Pu),
    W = At(l, "loop", 3, !1),
    ae = At(l, "shouldFilter", 3, !0),
    _e = At(l, "filter", 3, bv),
    xe = At(l, "label", 3, ""),
    K = At(l, "vimBindings", 3, !0),
    Ie = At(l, "disablePointerSelection", 3, !1),
    Ce = At(l, "disableInitialScroll", 3, !1),
    De = At(l, "columns", 3, null),
    Be = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "onValueChange", "onStateChange", "loop", "shouldFilter", "filter", "label", "vimBindings", "disablePointerSelection", "disableInitialScroll", "columns", "children", "child"]);
  const je = bf.create({
      id: cr.with(() => D()),
      ref: cr.with(() => N(), rt => N(rt)),
      filter: cr.with(() => _e()),
      shouldFilter: cr.with(() => ae()),
      loop: cr.with(() => W()),
      value: cr.with(() => T(), rt => {
        T() !== rt && (T(rt), o()(rt))
      }),
      vimBindings: cr.with(() => K()),
      disablePointerSelection: cr.with(() => Ie()),
      disableInitialScroll: cr.with(() => Ce()),
      onStateChange: cr.with(() => G()),
      columns: cr.with(() => De())
    }),
    Le = rt => je.updateSelectedToIndex(rt),
    Fe = rt => je.updateSelectedByGroup(rt),
    mt = rt => je.updateSelectedByItem(rt),
    ut = () => je.getValidItems(),
    Ke = lt(() => La(Be, je.props));
  var ct = Kt(),
    tt = It(ct);
  {
    var Re = rt => {
        var Qe = v4(),
          Ae = It(Qe);
        C(Ae);
        var gt = V(Ae, 2);
        tn(gt, () => l.child, () => ({
          props: x(Ke)
        })), H(rt, Qe)
      },
      ot = rt => {
        var Qe = y4();
        er(Qe, () => ({
          ...x(Ke)
        }));
        var Ae = k(Qe);
        C(Ae);
        var gt = V(Ae, 2);
        tn(gt, () => l.children ?? ma), A(Qe), H(rt, Qe)
      };
    Ue(tt, rt => {
      l.child ? rt(Re) : rt(ot, !1)
    })
  }
  return H(w, ct), Rr({
    updateSelectedToIndex: Le,
    updateSelectedByGroup: Fe,
    updateSelectedByItem: mt,
    getValidItems: ut
  })
}
var b4 = Pe("<div><!></div>");

function w4(w, l) {
  const g = Qa();
  Dr(l, !0);
  let C = At(l, "id", 19, () => Va(g)),
    D = At(l, "ref", 15, null),
    N = At(l, "forceMount", 3, !1),
    T = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child", "forceMount"]);
  const o = Mf.create({
      id: cr.with(() => C()),
      ref: cr.with(() => D(), xe => D(xe)),
      forceMount: cr.with(() => N())
    }),
    G = lt(() => La(o.props, T));
  var W = Kt(),
    ae = It(W);
  {
    var _e = xe => {
      var K = Kt(),
        Ie = It(K);
      {
        var Ce = Be => {
            var je = Kt(),
              Le = It(je);
            tn(Le, () => l.child, () => ({
              props: x(G)
            })), H(Be, je)
          },
          De = Be => {
            var je = b4();
            er(je, () => ({
              ...x(G)
            }));
            var Le = k(je);
            tn(Le, () => l.children ?? ma), A(je), H(Be, je)
          };
        Ue(Ie, Be => {
          l.child ? Be(Ce) : Be(De, !1)
        })
      }
      H(xe, K)
    };
    Ue(ae, xe => {
      o.shouldRender && xe(_e)
    })
  }
  H(w, W), Rr()
}
var T4 = Pe("<div><!></div>");

function C4(w, l) {
  const g = Qa();
  Dr(l, !0);
  let C = At(l, "id", 19, () => Va(g)),
    D = At(l, "ref", 15, null),
    N = At(l, "value", 3, ""),
    T = At(l, "forceMount", 3, !1),
    o = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "forceMount", "children", "child"]);
  const G = Af.create({
      id: cr.with(() => C()),
      ref: cr.with(() => D(), Ie => D(Ie)),
      forceMount: cr.with(() => T()),
      value: cr.with(() => N())
    }),
    W = lt(() => La(o, G.props));
  var ae = Kt(),
    _e = It(ae);
  {
    var xe = Ie => {
        var Ce = Kt(),
          De = It(Ce);
        tn(De, () => l.child, () => ({
          props: x(W)
        })), H(Ie, Ce)
      },
      K = Ie => {
        var Ce = T4();
        er(Ce, () => ({
          ...x(W)
        }));
        var De = k(Ce);
        tn(De, () => l.children ?? ma), A(Ce), H(Ie, Ce)
      };
    Ue(_e, Ie => {
      l.child ? Ie(xe) : Ie(K, !1)
    })
  }
  H(w, ae), Rr()
}
var S4 = Pe("<div><!></div>");

function P4(w, l) {
  const g = Qa();
  Dr(l, !0);
  let C = At(l, "id", 19, () => Va(g)),
    D = At(l, "ref", 15, null),
    N = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const T = kf.create({
      id: cr.with(() => C()),
      ref: cr.with(() => D(), xe => D(xe))
    }),
    o = lt(() => La(N, T.props));
  var G = Kt(),
    W = It(G);
  {
    var ae = xe => {
        var K = Kt(),
          Ie = It(K);
        tn(Ie, () => l.child, () => ({
          props: x(o)
        })), H(xe, K)
      },
      _e = xe => {
        var K = S4();
        er(K, () => ({
          ...x(o)
        }));
        var Ie = k(K);
        tn(Ie, () => l.children ?? ma), A(K), H(xe, K)
      };
    Ue(W, xe => {
      l.child ? xe(ae) : xe(_e, !1)
    })
  }
  H(w, G), Rr()
}
var I4 = Pe("<div><!></div>"),
  M4 = Pe('<div style="display: contents;"><!></div>');

function A4(w, l) {
  const g = Qa();
  Dr(l, !0);
  let C = At(l, "id", 19, () => Va(g)),
    D = At(l, "ref", 15, null),
    N = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const T = Ef.create({
      id: cr.with(() => C()),
      ref: cr.with(() => D(), xe => D(xe))
    }),
    o = lt(() => La(N, T.props));
  var G = M4(),
    W = k(G);
  {
    var ae = xe => {
        var K = Kt(),
          Ie = It(K);
        tn(Ie, () => l.child, () => ({
          props: x(o)
        })), H(xe, K)
      },
      _e = xe => {
        var K = I4();
        er(K, () => ({
          ...x(o)
        }));
        var Ie = k(K);
        tn(Ie, () => l.children ?? ma), A(K), H(xe, K)
      };
    Ue(W, xe => {
      l.child ? xe(ae) : xe(_e, !1)
    })
  }
  A(G), H(w, G), Rr()
}
var k4 = Pe("<input/>");

function E4(w, l) {
  const g = Qa();
  Dr(l, !0);
  let C = At(l, "value", 15, ""),
    D = At(l, "autofocus", 3, !1),
    N = At(l, "id", 19, () => Va(g)),
    T = At(l, "ref", 15, null),
    o = Yt(l, ["$$slots", "$$events", "$$legacy", "value", "autofocus", "id", "ref", "child"]);
  const G = zf.create({
      id: cr.with(() => N()),
      ref: cr.with(() => T(), Ie => T(Ie)),
      value: cr.with(() => C(), Ie => {
        C(Ie)
      }),
      autofocus: cr.with(() => D() ?? !1)
    }),
    W = lt(() => La(o, G.props));
  var ae = Kt(),
    _e = It(ae);
  {
    var xe = Ie => {
        var Ce = Kt(),
          De = It(Ce);
        tn(De, () => l.child, () => ({
          props: x(W)
        })), H(Ie, Ce)
      },
      K = Ie => {
        var Ce = k4();
        es(Ce), er(Ce, () => ({
          ...x(W)
        })), Gf(Ce, C), H(Ie, Ce)
      };
    Ue(_e, Ie => {
      l.child ? Ie(xe) : Ie(K, !1)
    })
  }
  H(w, ae), Rr()
}
var z4 = Pe("<div><!></div>"),
  L4 = Pe('<div style="display: contents;" data-item-wrapper=""><!></div>');

function D4(w, l) {
  const g = Qa();
  Dr(l, !0);
  let C = At(l, "id", 19, () => Va(g)),
    D = At(l, "ref", 15, null),
    N = At(l, "value", 3, ""),
    T = At(l, "disabled", 3, !1),
    o = At(l, "onSelect", 3, Pu),
    G = At(l, "forceMount", 3, !1),
    W = At(l, "keywords", 19, () => []),
    ae = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "disabled", "children", "child", "onSelect", "forceMount", "keywords"]);
  const _e = Lf.create({
      id: cr.with(() => C()),
      ref: cr.with(() => D(), Ce => D(Ce)),
      value: cr.with(() => N()),
      disabled: cr.with(() => T()),
      onSelect: cr.with(() => o()),
      forceMount: cr.with(() => G()),
      keywords: cr.with(() => W())
    }),
    xe = lt(() => La(ae, _e.props));
  var K = Kt(),
    Ie = It(K);
  Cu(Ie, () => _e.root.key, Ce => {
    var De = L4(),
      Be = k(De);
    {
      var je = Le => {
        var Fe = Kt(),
          mt = It(Fe);
        {
          var ut = ct => {
              var tt = Kt(),
                Re = It(tt);
              tn(Re, () => l.child, () => ({
                props: x(xe)
              })), H(ct, tt)
            },
            Ke = ct => {
              var tt = z4();
              er(tt, () => ({
                ...x(xe)
              }));
              var Re = k(tt);
              tn(Re, () => l.children ?? ma), A(tt), H(ct, tt)
            };
          Ue(mt, ct => {
            l.child ? ct(ut) : ct(Ke, !1)
          })
        }
        H(Le, Fe)
      };
      Ue(Be, Le => {
        _e.shouldRender && Le(je)
      })
    }
    A(De), Xe(() => kr(De, "data-value", _e.trueValue)), H(Ce, De)
  }), H(w, K), Rr()
}
var R4 = Pe("<div><!></div>");

function B4(w, l) {
  const g = Qa();
  Dr(l, !0);
  let C = At(l, "id", 19, () => Va(g)),
    D = At(l, "ref", 15, null),
    N = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "aria-label"]);
  const T = Rf.create({
      id: cr.with(() => C()),
      ref: cr.with(() => D(), ae => D(ae)),
      ariaLabel: cr.with(() => l["aria-label"] ?? "Suggestions...")
    }),
    o = lt(() => La(N, T.props));
  var G = Kt(),
    W = It(G);
  Cu(W, () => T.root._commandState.search === "", ae => {
    var _e = Kt(),
      xe = It(_e);
    {
      var K = Ce => {
          var De = Kt(),
            Be = It(De);
          tn(Be, () => l.child, () => ({
            props: x(o)
          })), H(Ce, De)
        },
        Ie = Ce => {
          var De = R4();
          er(De, () => ({
            ...x(o)
          }));
          var Be = k(De);
          tn(Be, () => l.children ?? ma), A(De), H(Ce, De)
        };
      Ue(xe, Ce => {
        l.child ? Ce(K) : Ce(Ie, !1)
      })
    }
    H(ae, _e)
  }), H(w, G), Rr()
}
const yg = 1,
  F4 = .9,
  O4 = .8,
  N4 = .17,
  cf = .1,
  uf = .999,
  j4 = .9999,
  q4 = .99,
  V4 = /[\\/_+.#"@[({&]/,
  U4 = /[\\/_+.#"@[({&]/g,
  Z4 = /[\s-]/,
  xv = /[\s-]/g;

function Ff(w, l, g, C, D, N, T) {
  if (N === l.length) return D === w.length ? yg : q4;
  const o = `${D},${N}`;
  if (T[o] !== void 0) return T[o];
  const G = C.charAt(N);
  let W = g.indexOf(G, D),
    ae = 0,
    _e, xe, K, Ie;
  for (; W >= 0;) _e = Ff(w, l, g, C, W + 1, N + 1, T), _e > ae && (W === D ? _e *= yg : V4.test(w.charAt(W - 1)) ? (_e *= O4, K = w.slice(D, W - 1).match(U4), K && D > 0 && (_e *= uf ** K.length)) : Z4.test(w.charAt(W - 1)) ? (_e *= F4, Ie = w.slice(D, W - 1).match(xv), Ie && D > 0 && (_e *= uf ** Ie.length)) : (_e *= N4, D > 0 && (_e *= uf ** (W - D))), w.charAt(W) !== l.charAt(N) && (_e *= j4)), (_e < cf && g.charAt(W - 1) === C.charAt(N + 1) || C.charAt(N + 1) === C.charAt(N) && g.charAt(W - 1) !== C.charAt(N)) && (xe = Ff(w, l, g, C, W + 1, N + 2, T), xe * cf > _e && (_e = xe * cf)), _e > ae && (ae = _e), W = g.indexOf(G, W + 1);
  return T[o] = ae, ae
}

function xg(w) {
  return w.toLowerCase().replace(xv, " ")
}

function bv(w, l, g) {
  return w = g && g.length > 0 ? `${`${w} ${g==null?void 0:g.join(" ")}`}` : w, Ff(w, l, xg(w), xg(l), 0, 0, {})
}
const $4 = 18,
  wv = 40,
  G4 = `${wv}px`,
  H4 = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");

function W4({
  containerRef: w,
  inputRef: l,
  pushPasswordManagerStrategy: g,
  isFocused: C,
  domContext: D
}) {
  let N = at(!1),
    T = at(!1),
    o = at(!1);

  function G() {
    const ae = g.current;
    return ae === "none" ? !1 : ae === "increase-width" && x(N) && x(T)
  }

  function W() {
    const ae = w.current,
      _e = l.current;
    if (!ae || !_e || x(o) || g.current === "none") return;
    const xe = ae,
      K = xe.getBoundingClientRect().left + xe.offsetWidth,
      Ie = xe.getBoundingClientRect().top + xe.offsetHeight / 2,
      Ce = K - $4,
      De = Ie;
    D.querySelectorAll(H4).length === 0 && D.getDocument().elementFromPoint(Ce, De) === ae || (le(N, !0), le(o, !0))
  }
  return Hr(() => {
    const ae = w.current;
    if (!ae || g.current === "none") return;

    function _e() {
      const Ie = uv(ae).innerWidth - ae.getBoundingClientRect().right;
      le(T, Ie >= wv)
    }
    _e();
    const xe = setInterval(_e, 1e3);
    return () => {
      clearInterval(xe)
    }
  }), Hr(() => {
    const ae = C.current || D.getActiveElement() === l.current;
    if (g.current === "none" || !ae) return;
    const _e = setTimeout(W, 0),
      xe = setTimeout(W, 2e3),
      K = setTimeout(W, 5e3),
      Ie = setTimeout(() => {
        le(o, !0)
      }, 6e3);
    return () => {
      clearTimeout(_e), clearTimeout(xe), clearTimeout(K), clearTimeout(Ie)
    }
  }), {
    get hasPwmBadge() {
      return x(N)
    },
    get willPushPwmBadge() {
      return G()
    },
    PWM_BADGE_SPACE_WIDTH: G4
  }
}
const Tv = hv({
    component: "pin-input",
    parts: ["root", "cell"]
  }),
  X4 = ["Backspace", "Delete", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End", "Escape", "Enter", "Tab", "Shift", "Control", "Meta"];
var Na, sc, zs, za, ja, oc, us, Ls, oo, lc, Dd, ah, sh, Rd, Bd, Cv, oh, lh, Fd, ch;
const bm = class bm {
  constructor(l) {
    xr(this, Bd);
    lr(this, "opts");
    lr(this, "attachment");
    xr(this, Na, cr(null));
    xr(this, sc, at(!1));
    lr(this, "inputAttachment", qa(Je(this, Na)));
    xr(this, zs, cr(!1));
    xr(this, za, at(null));
    xr(this, ja, at(null));
    xr(this, oc, new LM(() => this.opts.value.current ?? ""));
    xr(this, us, lt(() => typeof this.opts.pattern.current == "string" ? new RegExp(this.opts.pattern.current) : this.opts.pattern.current));
    xr(this, Ls, at(Ln({
      prev: [null, null, "none"],
      willSyntheticBlur: !1
    })));
    xr(this, oo);
    xr(this, lc);
    lr(this, "domContext");
    lr(this, "onkeydown", l => {
      const g = l.key;
      X4.includes(g) || l.ctrlKey || l.metaKey || g && x(Je(this, us)) && !x(Je(this, us)).test(g) && l.preventDefault()
    });
    xr(this, Dd, lt(() => ({
      position: "relative",
      cursor: this.opts.disabled.current ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })));
    xr(this, ah, lt(() => ({
      id: this.opts.id.current,
      [Tv.root]: "",
      style: x(Je(this, Dd)),
      ...this.attachment
    })));
    xr(this, sh, lt(() => ({
      style: {
        position: "absolute",
        inset: 0,
        pointerEvents: "none"
      }
    })));
    xr(this, Rd, lt(() => ({
      position: "absolute",
      inset: 0,
      width: Je(this, oo).willPushPwmBadge ? `calc(100% + ${Je(this,oo).PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: Je(this, oo).willPushPwmBadge ? `inset(0 ${Je(this,oo).PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: this.opts.textAlign.current,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--bits-pin-input-root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })));
    xr(this, oh, () => {
      var Ce;
      const l = Je(this, Na).current,
        g = this.opts.ref.current;
      if (!l || !g) return;
      if (this.domContext.getActiveElement() !== l) {
        le(Je(this, za), null), le(Je(this, ja), null);
        return
      }
      const C = l.selectionStart,
        D = l.selectionEnd,
        N = l.selectionDirection ?? "none",
        T = l.maxLength,
        o = l.value,
        G = x(Je(this, Ls)).prev;
      let W = -1,
        ae = -1,
        _e;
      if (o.length !== 0 && C !== null && D !== null) {
        const De = C === D,
          Be = C === o.length && o.length < T;
        if (De && !Be) {
          const je = C;
          if (je === 0) W = 0, ae = 1, _e = "forward";
          else if (je === T) W = je - 1, ae = je, _e = "backward";
          else if (T > 1 && o.length > 1) {
            let Le = 0;
            if (G[0] !== null && G[1] !== null) {
              _e = je < G[0] ? "backward" : "forward";
              const Fe = G[0] === G[1] && G[0] < T;
              _e === "backward" && !Fe && (Le = -1)
            }
            W = Le - je, ae = Le + je + 1
          }
        }
        W !== -1 && ae !== -1 && W !== ae && ((Ce = Je(this, Na).current) == null || Ce.setSelectionRange(W, ae, _e))
      }
      const xe = W !== -1 ? W : C,
        K = ae !== -1 ? ae : D,
        Ie = _e ?? N;
      le(Je(this, za), xe, !0), le(Je(this, ja), K, !0), x(Je(this, Ls)).prev = [xe, K, Ie]
    });
    lr(this, "oninput", l => {
      const g = l.currentTarget.value.slice(0, this.opts.maxLength.current);
      if (g.length > 0 && x(Je(this, us)) && !x(Je(this, us)).test(g)) {
        l.preventDefault();
        return
      }
      typeof Je(this, oc).current == "string" && g.length < Je(this, oc).current.length && this.domContext.getDocument().dispatchEvent(new Event("selectionchange")), this.opts.value.current = g
    });
    lr(this, "onfocus", l => {
      const g = Je(this, Na).current;
      if (g) {
        const C = Math.min(g.value.length, this.opts.maxLength.current - 1),
          D = g.value.length;
        g.setSelectionRange(C, D), le(Je(this, za), C, !0), le(Je(this, ja), D, !0)
      }
      Je(this, zs).current = !0
    });
    lr(this, "onpaste", l => {
      var ae, _e, xe, K;
      const g = Je(this, Na).current;
      if (!g) return;
      const C = Ie => {
          const Ce = g.selectionStart === null ? void 0 : g.selectionStart,
            De = g.selectionEnd === null ? void 0 : g.selectionEnd,
            Be = Ce !== De,
            je = this.opts.value.current;
          return (Be ? je.slice(0, Ce) + Ie + je.slice(De) : je.slice(0, Ce) + Ie + je.slice(Ce)).slice(0, this.opts.maxLength.current)
        },
        D = Ie => Ie.length > 0 && x(Je(this, us)) && !x(Je(this, us)).test(Ie);
      if (!((ae = this.opts.pasteTransformer) != null && ae.current) && (!Je(this, lc).isIOS || !l.clipboardData || !g)) {
        const Ie = C((_e = l.clipboardData) == null ? void 0 : _e.getData("text/plain"));
        D(Ie) && l.preventDefault();
        return
      }
      const N = ((xe = l.clipboardData) == null ? void 0 : xe.getData("text/plain")) ?? "",
        T = (K = this.opts.pasteTransformer) != null && K.current ? this.opts.pasteTransformer.current(N) : N;
      l.preventDefault();
      const o = C(T);
      if (D(o)) return;
      g.value = o, this.opts.value.current = o;
      const G = Math.min(o.length, this.opts.maxLength.current - 1),
        W = o.length;
      g.setSelectionRange(G, W), le(Je(this, za), G, !0), le(Je(this, ja), W, !0)
    });
    lr(this, "onmouseover", l => {
      le(Je(this, sc), !0)
    });
    lr(this, "onmouseleave", l => {
      le(Je(this, sc), !1)
    });
    lr(this, "onblur", l => {
      if (x(Je(this, Ls)).willSyntheticBlur) {
        x(Je(this, Ls)).willSyntheticBlur = !1;
        return
      }
      Je(this, zs).current = !1
    });
    xr(this, lh, lt(() => {
      var l;
      return {
        id: this.opts.inputId.current,
        style: x(Je(this, Rd)),
        autocomplete: this.opts.autocomplete.current || "one-time-code",
        "data-pin-input-input": "",
        "data-pin-input-input-mss": x(Je(this, za)),
        "data-pin-input-input-mse": x(Je(this, ja)),
        inputmode: this.opts.inputmode.current,
        pattern: (l = x(Je(this, us))) == null ? void 0 : l.source,
        maxlength: this.opts.maxLength.current,
        value: this.opts.value.current,
        disabled: KM(this.opts.disabled.current),
        onpaste: this.onpaste,
        oninput: this.oninput,
        onkeydown: this.onkeydown,
        onmouseover: this.onmouseover,
        onmouseleave: this.onmouseleave,
        onfocus: this.onfocus,
        onblur: this.onblur,
        ...this.inputAttachment
      }
    }));
    xr(this, Fd, lt(() => Array.from({
      length: this.opts.maxLength.current
    }).map((l, g) => {
      const C = Je(this, zs).current && x(Je(this, za)) !== null && x(Je(this, ja)) !== null && (x(Je(this, za)) === x(Je(this, ja)) && g === x(Je(this, za)) || g >= x(Je(this, za)) && g < x(Je(this, ja))),
        D = this.opts.value.current[g] !== void 0 ? this.opts.value.current[g] : null;
      return {
        char: D,
        isActive: C,
        hasFakeCaret: C && D === null
      }
    })));
    xr(this, ch, lt(() => ({
      cells: x(Je(this, Fd)),
      isFocused: Je(this, zs).current,
      isHovering: x(Je(this, sc))
    })));
    var g;
    this.opts = l, this.attachment = qa(this.opts.ref), this.domContext = new ZM(l.ref), Qn(this, lc, {
      value: this.opts.value,
      isIOS: typeof window < "u" && ((g = window == null ? void 0 : window.CSS) == null ? void 0 : g.supports("-webkit-touch-callout", "none"))
    }), Qn(this, oo, W4({
      containerRef: this.opts.ref,
      inputRef: Je(this, Na),
      isFocused: Je(this, zs),
      pushPasswordManagerStrategy: this.opts.pushPasswordManagerStrategy,
      domContext: this.domContext
    })), zi(() => {
      const C = Je(this, Na).current,
        D = this.opts.ref.current;
      if (!C || !D) return;
      Je(this, lc).value.current !== C.value && (this.opts.value.current = C.value), x(Je(this, Ls)).prev = [C.selectionStart, C.selectionEnd, C.selectionDirection ?? "none"];
      const N = Tu(this.domContext.getDocument(), "selectionchange", Je(this, oh), {
        capture: !0
      });
      Je(this, oh).call(this), this.domContext.getActiveElement() === C && (Je(this, zs).current = !0), this.domContext.getElementById("pin-input-style") || Fr(this, Bd, Cv).call(this);
      const T = () => {
        D && D.style.setProperty("--bits-pin-input-root-height", `${C.clientHeight}px`)
      };
      T();
      const o = new ResizeObserver(T);
      return o.observe(C), () => {
        N(), o.disconnect()
      }
    }), lo([() => this.opts.value.current, () => Je(this, Na).current], () => {
      K4(() => {
        const C = Je(this, Na).current;
        if (!C) return;
        C.dispatchEvent(new Event("input"));
        const D = C.selectionStart,
          N = C.selectionEnd,
          T = C.selectionDirection ?? "none";
        D !== null && N !== null && (le(Je(this, za), D, !0), le(Je(this, ja), N, !0), x(Je(this, Ls)).prev = [D, N, T])
      }, this.domContext)
    }), Hr(() => {
      const C = this.opts.value.current,
        D = Je(this, oc).current,
        N = this.opts.maxLength.current,
        T = this.opts.onComplete.current;
      D !== void 0 && C !== D && D.length < N && C.length === N && T(C)
    })
  }
  static create(l) {
    return new bm(l)
  }
  get rootProps() {
    return x(Je(this, ah))
  }
  set rootProps(l) {
    le(Je(this, ah), l)
  }
  get inputWrapperProps() {
    return x(Je(this, sh))
  }
  set inputWrapperProps(l) {
    le(Je(this, sh), l)
  }
  get inputProps() {
    return x(Je(this, lh))
  }
  set inputProps(l) {
    le(Je(this, lh), l)
  }
  get snippetProps() {
    return x(Je(this, ch))
  }
  set snippetProps(l) {
    le(Je(this, ch), l)
  }
};
Na = new WeakMap, sc = new WeakMap, zs = new WeakMap, za = new WeakMap, ja = new WeakMap, oc = new WeakMap, us = new WeakMap, Ls = new WeakMap, oo = new WeakMap, lc = new WeakMap, Dd = new WeakMap, ah = new WeakMap, sh = new WeakMap, Rd = new WeakMap, Bd = new WeakSet, Cv = function() {
  const l = this.domContext.getDocument(),
    g = l.createElement("style");
  if (g.id = "pin-input-style", l.head.appendChild(g), g.sheet) {
    const C = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
    gu(g.sheet, "[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }"), gu(g.sheet, `[data-pin-input-input]:autofill { ${C} }`), gu(g.sheet, `[data-pin-input-input]:-webkit-autofill { ${C} }`), gu(g.sheet, "@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), gu(g.sheet, "[data-pin-input-input] + * { pointer-events: all !important; }")
  }
}, oh = new WeakMap, lh = new WeakMap, Fd = new WeakMap, ch = new WeakMap;
let Of = bm;
var uh;
const wm = class wm {
  constructor(l) {
    lr(this, "opts");
    lr(this, "attachment");
    xr(this, uh, lt(() => ({
      id: this.opts.id.current,
      [Tv.cell]: "",
      "data-active": this.opts.cell.current.isActive ? "" : void 0,
      "data-inactive": this.opts.cell.current.isActive ? void 0 : "",
      ...this.attachment
    })));
    this.opts = l, this.attachment = qa(this.opts.ref)
  }
  static create(l) {
    return new wm(l)
  }
  get props() {
    return x(Je(this, uh))
  }
  set props(l) {
    le(Je(this, uh), l)
  }
};
uh = new WeakMap;
let Nf = wm;

function K4(w, l) {
  const g = l.setTimeout(w, 0),
    C = l.setTimeout(w, 10),
    D = l.setTimeout(w, 50);
  return [g, C, D]
}

function gu(w, l) {
  try {
    w.insertRule(l)
  } catch {
    console.error("pin input could not insert CSS rule:", l)
  }
}
var Y4 = Pe("<div><!> <div><input/></div></div>");

function J4(w, l) {
  const g = Qa();
  Dr(l, !0);
  let C = At(l, "id", 19, () => Va(g)),
    D = At(l, "inputId", 19, () => `${Va(g)}-input`),
    N = At(l, "ref", 15, null),
    T = At(l, "maxlength", 3, 6),
    o = At(l, "textalign", 3, "left"),
    G = At(l, "inputmode", 3, "numeric"),
    W = At(l, "onComplete", 3, Pu),
    ae = At(l, "pushPasswordManagerStrategy", 3, "increase-width"),
    _e = At(l, "class", 3, ""),
    xe = At(l, "autocomplete", 3, "one-time-code"),
    K = At(l, "disabled", 3, !1),
    Ie = At(l, "value", 15, ""),
    Ce = At(l, "onValueChange", 3, Pu),
    De = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "inputId", "ref", "maxlength", "textalign", "pattern", "inputmode", "onComplete", "pushPasswordManagerStrategy", "class", "children", "autocomplete", "disabled", "value", "onValueChange", "pasteTransformer"]);
  const Be = Of.create({
      id: cr.with(() => C()),
      ref: cr.with(() => N(), tt => N(tt)),
      inputId: cr.with(() => D()),
      autocomplete: cr.with(() => xe()),
      maxLength: cr.with(() => T()),
      textAlign: cr.with(() => o()),
      disabled: cr.with(() => K()),
      inputmode: cr.with(() => G()),
      pattern: cr.with(() => l.pattern),
      onComplete: cr.with(() => W()),
      value: cr.with(() => Ie(), tt => {
        Ie(tt), Ce()(tt)
      }),
      pushPasswordManagerStrategy: cr.with(() => ae()),
      pasteTransformer: cr.with(() => l.pasteTransformer)
    }),
    je = lt(() => La(De, Be.inputProps)),
    Le = lt(() => La(Be.rootProps, {
      class: _e()
    })),
    Fe = lt(() => La(Be.inputWrapperProps, {}));
  var mt = Y4();
  er(mt, () => ({
    ...x(Le)
  }));
  var ut = k(mt);
  tn(ut, () => l.children ?? ma, () => Be.snippetProps);
  var Ke = V(ut, 2);
  er(Ke, () => ({
    ...x(Fe)
  }));
  var ct = k(Ke);
  es(ct), er(ct, () => ({
    ...x(je)
  })), A(Ke), A(mt), H(w, mt), Rr()
}
var Q4 = Pe("<div><!></div>");

function e6(w, l) {
  const g = Qa();
  Dr(l, !0);
  let C = At(l, "id", 19, () => Va(g)),
    D = At(l, "ref", 15, null),
    N = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "cell", "child", "children"]);
  const T = Nf.create({
      id: cr.with(() => C()),
      ref: cr.with(() => D(), xe => D(xe)),
      cell: cr.with(() => l.cell)
    }),
    o = lt(() => La(N, T.props));
  var G = Kt(),
    W = It(G);
  {
    var ae = xe => {
        var K = Kt(),
          Ie = It(K);
        tn(Ie, () => l.child, () => ({
          props: x(o)
        })), H(xe, K)
      },
      _e = xe => {
        var K = Q4();
        er(K, () => ({
          ...x(o)
        }));
        var Ie = k(K);
        tn(Ie, () => l.children ?? ma), A(K), H(xe, K)
      };
    Ue(W, xe => {
      l.child ? xe(ae) : xe(_e, !1)
    })
  }
  H(w, G), Rr()
}

function dc(...w) {
  return Rg(wu(w))
}

function t6(w, l) {
  Dr(l, !0);
  let g = At(l, "ref", 15, null),
    C = At(l, "value", 15, ""),
    D = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
  var N = Kt(),
    T = It(N);
  {
    let o = lt(() => dc("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", l.class));
    _n(T, () => x4, (G, W) => {
      W(G, co({
        "data-slot": "command",
        get class() {
          return x(o)
        }
      }, () => D, {
        get value() {
          return C()
        },
        set value(ae) {
          C(ae)
        },
        get ref() {
          return g()
        },
        set ref(ae) {
          g(ae)
        }
      }))
    })
  }
  H(w, N), Rr()
}
var r6 = Cr('<svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"></path></svg>');

function pc(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = r6();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}

function i6(w, l) {
  Dr(l, !0);
  let g = At(l, "ref", 15, null),
    C = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var D = Kt(),
    N = It(D);
  {
    let T = lt(() => dc("py-6 text-center text-sm", l.class));
    _n(N, () => w4, (o, G) => {
      G(o, co({
        "data-slot": "command-empty",
        get class() {
          return x(T)
        }
      }, () => C, {
        get ref() {
          return g()
        },
        set ref(W) {
          g(W)
        }
      }))
    })
  }
  H(w, D), Rr()
}
var n6 = Pe("<!> <!>", 1);

function a6(w, l) {
  Dr(l, !0);
  let g = At(l, "ref", 15, null),
    C = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "heading", "value"]);
  var D = Kt(),
    N = It(D);
  {
    let T = lt(() => dc("text-foreground overflow-hidden p-1", l.class)),
      o = lt(() => l.value ?? l.heading ?? `----${d4()}`);
    _n(N, () => C4, (G, W) => {
      W(G, co({
        "data-slot": "command-group",
        get class() {
          return x(T)
        },
        get value() {
          return x(o)
        }
      }, () => C, {
        get ref() {
          return g()
        },
        set ref(ae) {
          g(ae)
        },
        children: (ae, _e) => {
          var xe = n6(),
            K = It(xe);
          {
            var Ie = De => {
              var Be = Kt(),
                je = It(Be);
              _n(je, () => P4, (Le, Fe) => {
                Fe(Le, {
                  class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                  children: (mt, ut) => {
                    vi();
                    var Ke = On();
                    Xe(() => ve(Ke, l.heading)), H(mt, Ke)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), H(De, Be)
            };
            Ue(K, De => {
              l.heading && De(Ie)
            })
          }
          var Ce = V(K, 2);
          _n(Ce, () => A4, (De, Be) => {
            Be(De, {
              get children() {
                return l.children
              }
            })
          }), H(ae, xe)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  H(w, D), Rr()
}

function s6(w, l) {
  Dr(l, !0);
  let g = At(l, "ref", 15, null),
    C = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var D = Kt(),
    N = It(D);
  {
    let T = lt(() => dc("aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", l.class));
    _n(N, () => D4, (o, G) => {
      G(o, co({
        "data-slot": "command-item",
        get class() {
          return x(T)
        }
      }, () => C, {
        get ref() {
          return g()
        },
        set ref(W) {
          g(W)
        }
      }))
    })
  }
  H(w, D), Rr()
}
var o6 = Cr('<svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"></path></svg>');

function l6(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = o6();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var c6 = Pe('<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>');

function u6(w, l) {
  Dr(l, !0);
  let g = At(l, "ref", 15, null),
    C = At(l, "value", 15, ""),
    D = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var N = c6(),
    T = k(N);
  l6(T, {
    class: "size-5 opacity-50"
  });
  var o = V(T, 2);
  {
    let G = lt(() => dc("placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", l.class));
    _n(o, () => E4, (W, ae) => {
      ae(W, co({
        "data-slot": "command-input",
        get class() {
          return x(G)
        }
      }, () => D, {
        get ref() {
          return g()
        },
        set ref(_e) {
          g(_e)
        },
        get value() {
          return C()
        },
        set value(_e) {
          C(_e)
        }
      }))
    })
  }
  A(N), H(w, N), Rr()
}

function h6(w, l) {
  Dr(l, !0);
  let g = At(l, "ref", 15, null),
    C = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var D = Kt(),
    N = It(D);
  {
    let T = lt(() => dc("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", l.class));
    _n(N, () => B4, (o, G) => {
      G(o, co({
        "data-slot": "command-list",
        get class() {
          return x(T)
        }
      }, () => C, {
        get ref() {
          return g()
        },
        set ref(W) {
          g(W)
        }
      }))
    })
  }
  H(w, D), Rr()
}
var d6 = Cr('<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>');

function p6(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = d6();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var f6 = Pe("<span> </span> <!>", 1),
  m6 = Pe('<span class="font-flag ml-0.5"> </span> ', 1),
  _6 = Pe('<span class="flex gap-1.5"><span class="font-flag"> </span> </span>'),
  g6 = Pe("<!> <!>", 1),
  v6 = Pe("<!> <!>", 1),
  y6 = (w, l) => {
    l(0)
  },
  x6 = Pe('<button class="btn btn-xs btn-circle btn-ghost"><!></button>'),
  b6 = Pe('<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>');

function bg(w, l) {
  Dr(l, !0);
  let g = At(l, "countryId", 15, 0),
    C = At(l, "dropdownDirection", 3, "right"),
    D = at(null),
    N = at(null),
    T = at("");

  function o() {
    Mg().then(() => {
      var Le;
      (Le = document.activeElement) == null || Le.blur(), le(T, "")
    })
  }
  var G = b6(),
    W = k(G),
    ae = k(W),
    _e = k(ae);
  {
    var xe = Le => {
        var Fe = f6(),
          mt = It(Fe),
          ut = k(mt, !0);
        A(mt);
        var Ke = V(mt, 2);
        p6(Ke, {
          class: "size-3.5"
        }), Xe(ct => ve(ut, ct), [() => $g()]), H(Le, Fe)
      },
      K = Le => {
        const Fe = lt(() => hs(g()));
        var mt = m6(),
          ut = It(mt),
          Ke = k(ut, !0);
        A(ut);
        var ct = V(ut);
        Xe(() => {
          ve(Ke, x(Fe).flag), ve(ct, ` ${x(Fe).name??""}`)
        }), H(Le, mt)
      };
    Ue(_e, Le => {
      g() === 0 ? Le(xe) : Le(K, !1)
    })
  }
  A(ae);
  var Ie = V(ae, 2);
  let Ce;
  var De = k(Ie);
  _n(De, () => t6, (Le, Fe) => {
    Fe(Le, {
      children: (mt, ut) => {
        var Ke = v6(),
          ct = It(Ke);
        _n(ct, () => u6, (Re, ot) => {
          ot(Re, {
            placeholder: "Country",
            get ref() {
              return x(D)
            },
            set ref(rt) {
              le(D, rt)
            },
            get value() {
              return x(T)
            },
            set value(rt) {
              le(T, rt, !0)
            }
          })
        });
        var tt = V(ct, 2);
        _n(tt, () => h6, (Re, ot) => {
          ot(Re, {
            children: (rt, Qe) => {
              var Ae = g6(),
                gt = It(Ae);
              _n(gt, () => i6, (te, fe) => {
                fe(te, {
                  children: (ie, Se) => {
                    vi();
                    var Me = On();
                    Xe(nt => ve(Me, nt), [() => d2()]), H(ie, Me)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              });
              var ee = V(gt, 2);
              _n(ee, () => a6, (te, fe) => {
                fe(te, {
                  children: (ie, Se) => {
                    var Me = Kt(),
                      nt = It(Me);
                    gn(nt, 17, () => $n.countries, Ye => Ye.id, (Ye, wt) => {
                      var zt = Kt(),
                        Nt = It(zt);
                      _n(Nt, () => s6, (st, Tt) => {
                        Tt(st, {
                          get value() {
                            return x(wt).name
                          },
                          onSelect: () => {
                            g(x(wt).id), o()
                          },
                          children: (Ct, yt) => {
                            var Mt = _6(),
                              St = k(Mt),
                              ht = k(St, !0);
                            A(St);
                            var Lt = V(St);
                            A(Mt), Xe(() => {
                              ve(ht, x(wt).flag), ve(Lt, ` ${x(wt).name??""}`)
                            }), H(Ct, Mt)
                          },
                          $$slots: {
                            default: !0
                          }
                        })
                      }), H(Ye, zt)
                    }), H(ie, Me)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), H(rt, Ae)
            },
            $$slots: {
              default: !0
            }
          })
        }), H(mt, Ke)
      },
      $$slots: {
        default: !0
      }
    })
  }), A(Ie), A(W);
  var Be = V(W, 2);
  {
    var je = Le => {
      var Fe = x6();
      Fe.__click = [y6, g];
      var mt = k(Fe);
      pc(mt, {
        class: "size-3.5"
      }), A(Fe), H(Le, Fe)
    };
    Ue(Be, Le => {
      g() != 0 && Le(je)
    })
  }
  A(G), Ds(G, Le => le(N, Le), () => x(N)), Xe(Le => Ce = Or(Ie, 1, "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm", null, Ce, Le), [() => ({
    "right-1": C() === "left"
  })]), Pn("focus", ae, () => {
    x(D).focus()
  }), H(w, G), Rr()
}
rn(["click"]);
var w6 = Cr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>');

function T6(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = w6();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var C6 = Cr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>'),
  S6 = Cr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function jf(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var C = Kt(),
    D = It(C);
  {
    var N = o => {
        var G = C6();
        er(G, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...g
        })), H(o, G)
      },
      T = o => {
        var G = S6();
        er(G, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...g
        })), H(o, G)
      };
    Ue(D, o => {
      l.filled ? o(N) : o(T, !1)
    })
  }
  H(w, C)
}
var P6 = Pe('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  I6 = Pe('<div class="mb-2"><!></div>'),
  M6 = Pe('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  A6 = (w, l, g) => {
    l.onvisitclick({
      lat: x(g).lastLatitude,
      lng: x(g).lastLongitude
    })
  },
  k6 = Pe('<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>'),
  E6 = Pe('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>'),
  z6 = Pe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  L6 = Pe('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>'),
  D6 = Pe('<span class="font-flag tooltip ml-0.5"> </span>'),
  R6 = Pe("<span> </span>"),
  B6 = Pe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  F6 = Pe('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  O6 = Pe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  N6 = Pe('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  j6 = Pe('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  q6 = Pe('<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>', 1);

function V6(w, l) {
  Dr(l, !0);
  const g = [];
  let C = at(1e3);
  const D = lt(() => x(C) <= 640);
  let N = at("today"),
    T = {
      regions: {
        label: zT(),
        icon: Zf
      },
      countries: {
        label: RT(),
        icon: T6
      },
      players: {
        label: Yg(),
        icon: Zd
      },
      alliances: {
        label: Jg(),
        icon: $d
      }
    },
    o = at("regions"),
    G = at(0),
    W = Ln({
      players: {},
      alliances: {},
      regions: {},
      countries: {}
    }),
    ae = lt(() => {
      var Ke, ct, tt;
      return x(o) === "regions" ? (ct = (Ke = W[x(o)][x(G)]) == null ? void 0 : Ke[x(N)]) == null ? void 0 : ct.entries : (tt = W[x(o)][x(N)]) == null ? void 0 : tt.entries
    });
  const _e = 5 * 1e3;
  Hr(() => {
    var Re;
    if (!l.open) return;
    const Ke = x(N),
      ct = x(o),
      tt = x(G);
    ct === "players" && (!W[ct][Ke] || Date.now() - W[ct][Ke].time > _e) ? ni.leaderboardPlayers(Ke).then(ot => {
      W[ct][Ke] = {
        time: Date.now(),
        entries: ot
      }
    }).catch(ot => $r.error(ot.message)) : ct === "alliances" && (!W[ct][Ke] || Date.now() - W[ct][Ke].time > _e) ? ni.leaderboardAlliances(Ke).then(ot => {
      W[ct][Ke] = {
        time: Date.now(),
        entries: ot
      }
    }).catch(ot => $r.error(ot.message)) : ct === "countries" && (!W[ct][Ke] || Date.now() - W[ct][Ke].time > _e) ? ni.leaderboardCountries(Ke).then(ot => {
      W[ct][Ke] = {
        time: Date.now(),
        entries: ot
      }
    }).catch(ot => $r.error(ot.message)) : ct === "regions" && (!((Re = W[ct][tt]) != null && Re[Ke]) || Date.now() - W[ct][tt][Ke].time > _e) && ni.leaderboardRegions(Ke, tt).then(ot => {
      W[ct][tt] || (W[ct][tt] = {}), W[ct][tt][Ke] = {
        time: Date.now(),
        entries: ot
      }
    }).catch(ot => $r.error(ot.message))
  });
  var xe = q6(),
    K = It(xe);
  gn(K, 21, () => Object.entries(T), ([Ke, {
    label: ct,
    icon: tt
  }]) => Ke, (Ke, ct) => {
    var tt = lt(() => Ag(x(ct), 2));
    let Re = () => x(tt)[0],
      ot = () => x(tt)[1].label,
      rt = () => x(tt)[1].icon;
    const Qe = lt(rt);
    var Ae = P6(),
      gt = k(Ae);
    es(gt);
    var ee, te = V(gt, 2);
    _n(te, () => x(Qe), (ie, Se) => {
      Se(ie, {
        get this() {
          return rt()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var fe = V(te);
    A(Ae), Xe(() => {
      kr(gt, "aria-label", ot()), ee !== (ee = Re()) && (gt.value = (gt.__value = Re()) ?? ""), ve(fe, ` ${ot()??""}`)
    }), $f(g, [], gt, () => (Re(), x(o)), ie => le(o, ie)), H(Ke, Ae)
  }), A(K);
  var Ie = V(K, 2),
    Ce = k(Ie);
  am(Ce, {
    get value() {
      return x(N)
    },
    set value(Ke) {
      le(N, Ke, !0)
    }
  });
  var De = V(Ce, 2);
  {
    var Be = Ke => {
      bg(Ke, {
        dropdownDirection: "left",
        get countryId() {
          return x(G)
        },
        set countryId(ct) {
          le(G, ct, !0)
        }
      })
    };
    Ue(De, Ke => {
      x(o) === "regions" && !x(D) && Ke(Be)
    })
  }
  A(Ie);
  var je = V(Ie, 2);
  {
    var Le = Ke => {
      var ct = I6(),
        tt = k(ct);
      bg(tt, {
        get countryId() {
          return x(G)
        },
        set countryId(Re) {
          le(G, Re, !0)
        }
      }), A(ct), H(Ke, ct)
    };
    Ue(je, Ke => {
      x(o) === "regions" && x(D) && Ke(Le)
    })
  }
  var Fe = V(je, 2);
  {
    var mt = Ke => {
        var ct = M6(),
          tt = k(ct),
          Re = V(tt);
        {
          var ot = Qe => {
              var Ae = On();
              Xe(gt => ve(Ae, gt), [() => Ud().toLowerCase()]), H(Qe, Ae)
            },
            rt = Qe => {
              var Ae = Kt(),
                gt = It(Ae);
              {
                var ee = fe => {
                    var ie = On();
                    Xe(Se => ve(ie, Se), [() => Jf()]), H(fe, ie)
                  },
                  te = fe => {
                    var ie = Kt(),
                      Se = It(ie);
                    {
                      var Me = nt => {
                        var Ye = On();
                        Xe(wt => ve(Ye, wt), [() => Qf()]), H(nt, Ye)
                      };
                      Ue(Se, nt => {
                        x(N) === "month" && nt(Me)
                      }, !0)
                    }
                    H(fe, ie)
                  };
                Ue(gt, fe => {
                  x(N) === "week" ? fe(ee) : fe(te, !1)
                }, !0)
              }
              H(Qe, Ae)
            };
          Ue(Re, Qe => {
            x(N) === "today" ? Qe(ot) : Qe(rt, !1)
          })
        }
        A(ct), Xe(Qe => ve(tt, `${Qe??""} `), [() => Yf()]), H(Ke, ct)
      },
      ut = Ke => {
        var ct = Kt(),
          tt = It(ct);
        {
          var Re = rt => {
              var Qe = Kt(),
                Ae = It(Qe);
              {
                var gt = te => {
                    const fe = lt(() => x(ae));
                    var ie = E6(),
                      Se = k(ie),
                      Me = k(Se),
                      nt = V(k(Me)),
                      Ye = k(nt, !0);
                    A(nt);
                    var wt = V(nt),
                      zt = k(wt),
                      Nt = V(zt, 2),
                      st = V(Nt),
                      Tt = k(st);
                    jf(Tt, {
                      class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                    }), A(st), A(wt), vi(), A(Me), A(Se);
                    var Ct = V(Se);
                    gn(Ct, 31, () => x(fe), yt => yt.id, (yt, Mt, St) => {
                      const ht = lt(() => hs(x(Mt).countryId));
                      var Lt = k6(),
                        tr = k(Lt),
                        Jt = k(tr, !0);
                      A(tr);
                      var dr = V(tr),
                        nr = k(dr),
                        Bt = k(nr, !0);
                      A(nr);
                      var pr = V(nr, 2),
                        gr = k(pr),
                        Sr = V(gr),
                        Vr = k(Sr);
                      A(Sr), A(pr), A(dr);
                      var ur = V(dr),
                        Pr = k(ur, !0);
                      A(ur);
                      var Ir = V(ur),
                        Mr = k(Ir);
                      Mr.__click = [A6, l, Mt];
                      var Nr = k(Mr, !0);
                      A(Mr), A(Ir), A(Lt), Xe((ce, F, q) => {
                        ve(Jt, x(St) + 1), kr(nr, "data-tip", x(ht).name), ve(Bt, x(ht).flag), Or(pr, 1, `font-semibold ${ce??""}`), ve(gr, `${x(Mt).name??""} `), ve(Vr, `#${x(Mt).number??""}`), ve(Pr, F), ve(Nr, q)
                      }, [() => Zn(x(Mt).cityId), () => x(Mt).pixelsPainted.toLocaleString("en-US"), () => JT()]), Zo(Lt, () => $o, () => ({
                        duration: 200
                      })), H(yt, Lt)
                    }), A(Ct), A(ie), Xe((yt, Mt, St, ht) => {
                      ve(Ye, yt), ve(zt, `${Mt??""} `), ve(Nt, `${St??""} `), kr(st, "data-tip", ht)
                    }, [() => VT(), () => Jl(), () => Ql().toLowerCase(), () => XT()]), H(te, ie)
                  },
                  ee = te => {
                    var fe = Kt(),
                      ie = It(fe);
                    {
                      var Se = nt => {
                          var Ye = L6(),
                            wt = k(Ye),
                            zt = k(wt),
                            Nt = V(k(zt)),
                            st = k(Nt, !0);
                          A(Nt);
                          var Tt = V(Nt),
                            Ct = k(Tt),
                            yt = V(Ct, 2),
                            Mt = V(yt),
                            St = k(Mt);
                          jf(St, {
                            class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                          }), A(Mt), A(Tt), A(zt), A(wt);
                          var ht = V(wt);
                          gn(ht, 31, () => x(ae), Lt => Lt.id, (Lt, tr, Jt) => {
                            const dr = lt(() => hs(x(tr).id));
                            var nr = z6(),
                              Bt = k(nr),
                              pr = k(Bt, !0);
                            A(Bt);
                            var gr = V(Bt),
                              Sr = k(gr),
                              Vr = k(Sr, !0);
                            A(Sr);
                            var ur = V(Sr, 2),
                              Pr = k(ur, !0);
                            A(ur), A(gr);
                            var Ir = V(gr),
                              Mr = k(Ir, !0);
                            A(Ir), A(nr), Xe((Nr, ce) => {
                              ve(pr, x(Jt) + 1), kr(Sr, "data-tip", x(dr).name), ve(Vr, x(dr).flag), Or(ur, 1, `font-semibold ${Nr??""}`), ve(Pr, x(dr).name), ve(Mr, ce)
                            }, [() => Zn(x(tr).id), () => x(tr).pixelsPainted.toLocaleString("en-US")]), Zo(nr, () => $o, () => ({
                              duration: 200
                            })), H(Lt, nr)
                          }), A(ht), A(Ye), Xe((Lt, tr, Jt, dr) => {
                            ve(st, Lt), ve(Ct, `${tr??""} `), ve(yt, `${Jt??""} `), kr(Mt, "data-tip", dr)
                          }, [() => $g(), () => Jl(), () => Ql().toLowerCase(), () => M3()]), H(nt, Ye)
                        },
                        Me = nt => {
                          var Ye = Kt(),
                            wt = It(Ye);
                          {
                            var zt = st => {
                                const Tt = lt(() => x(ae));
                                var Ct = F6(),
                                  yt = k(Ct),
                                  Mt = k(yt),
                                  St = V(k(Mt)),
                                  ht = k(St, !0);
                                A(St);
                                var Lt = V(St),
                                  tr = k(Lt),
                                  Jt = V(tr, 2, !0);
                                A(Lt), A(Mt), A(yt);
                                var dr = V(yt);
                                gn(dr, 31, () => x(Tt), nr => nr.id, (nr, Bt, pr) => {
                                  const gr = lt(() => {
                                    var ye;
                                    return ((ye = Et.data) == null ? void 0 : ye.id) === x(Bt).id
                                  });
                                  var Sr = B6();
                                  let Vr;
                                  var ur = k(Sr),
                                    Pr = k(ur, !0);
                                  A(ur);
                                  var Ir = V(ur),
                                    Mr = k(Ir),
                                    Nr = k(Mr);
                                  ds(Nr, {
                                    class: "size-8 border sm:size-10",
                                    get userId() {
                                      return x(Bt).id
                                    },
                                    get pictureUrl() {
                                      return x(Bt).picture
                                    }
                                  });
                                  var ce = V(Nr, 2),
                                    F = k(ce),
                                    q = k(F),
                                    $ = V(q),
                                    X = k($);
                                  A($), A(F);
                                  var oe = V(F, 2);
                                  {
                                    var me = ye => {
                                      const Xt = lt(() => hs(x(Bt).equippedFlag));
                                      var Ht = D6(),
                                        pt = k(Ht, !0);
                                      A(Ht), Xe(() => {
                                        kr(Ht, "data-tip", x(Xt).name), ve(pt, x(Xt).flag)
                                      }), H(ye, Ht)
                                    };
                                    Ue(oe, ye => {
                                      x(Bt).equippedFlag && ye(me)
                                    })
                                  }
                                  var Ee = V(oe, 2);
                                  {
                                    var Te = ye => {
                                      hh(ye, {
                                        get username() {
                                          return x(Bt).discord
                                        }
                                      })
                                    };
                                    Ue(Ee, ye => {
                                      x(Bt).discord && ye(Te)
                                    })
                                  }
                                  var Ze = V(Ee, 2);
                                  {
                                    var it = ye => {
                                      var Xt = R6(),
                                        Ht = k(Xt, !0);
                                      A(Xt), Xe((pt, bt) => {
                                        Or(Xt, 1, `badge badge-sm ml-0.5 border-0 ${pt??""} ${bt??""}`), ve(Ht, x(Bt).allianceName)
                                      }, [() => Wf(x(Bt).allianceId), () => Zn(x(Bt).allianceId)]), H(ye, Xt)
                                    };
                                    Ue(Ze, ye => {
                                      "allianceName" in x(Bt) && x(Bt).allianceName && ye(it)
                                    })
                                  }
                                  A(ce), A(Mr), A(Ir);
                                  var $e = V(Ir),
                                    kt = k($e, !0);
                                  A($e), A(Sr), Xe((ye, Xt, Ht) => {
                                    Vr = Or(Sr, 1, "", null, Vr, ye), ve(Pr, x(pr) + 1), Or(F, 1, `font-semibold max-sm:ml-2 ${Xt??""} flex gap-1`), ve(q, `${x(Bt).name??""} `), ve(X, `#${x(Bt).id??""}`), ve(kt, Ht)
                                  }, [() => ({
                                    "bg-base-200": x(gr)
                                  }), () => Zn(x(Bt).id), () => x(Bt).pixelsPainted.toLocaleString("en-US")]), Zo(Sr, () => $o, () => ({
                                    duration: 200
                                  })), H(nr, Sr)
                                }), A(dr), A(Ct), Xe((nr, Bt, pr) => {
                                  ve(ht, nr), ve(tr, `${Bt??""} `), ve(Jt, pr)
                                }, [() => em(), () => Jl(), () => Ql().toLowerCase()]), H(st, Ct)
                              },
                              Nt = st => {
                                var Tt = Kt(),
                                  Ct = It(Tt);
                                {
                                  var yt = Mt => {
                                    var St = N6(),
                                      ht = k(St),
                                      Lt = k(ht),
                                      tr = V(k(Lt)),
                                      Jt = k(tr, !0);
                                    A(tr);
                                    var dr = V(tr),
                                      nr = k(dr),
                                      Bt = V(nr, 2, !0);
                                    A(dr), A(Lt), A(ht);
                                    var pr = V(ht);
                                    gn(pr, 31, () => x(ae), gr => gr.id, (gr, Sr, Vr) => {
                                      const ur = lt(() => {
                                        var oe;
                                        return ((oe = Et.data) == null ? void 0 : oe.allianceId) === x(Sr).id
                                      });
                                      var Pr = O6();
                                      let Ir;
                                      var Mr = k(Pr),
                                        Nr = k(Mr, !0);
                                      A(Mr);
                                      var ce = V(Mr),
                                        F = k(ce),
                                        q = k(F, !0);
                                      A(F), A(ce);
                                      var $ = V(ce),
                                        X = k($, !0);
                                      A($), A(Pr), Xe((oe, me, Ee) => {
                                        Ir = Or(Pr, 1, "", null, Ir, oe), ve(Nr, x(Vr) + 1), Or(F, 1, `font-semibold ${me??""}`), ve(q, x(Sr).name), ve(X, Ee)
                                      }, [() => ({
                                        "bg-base-200": x(ur)
                                      }), () => Zn(x(Sr).id), () => x(Sr).pixelsPainted.toLocaleString("en-US")]), Zo(Pr, () => $o, () => ({
                                        duration: 200
                                      })), H(gr, Pr)
                                    }), A(pr), A(St), Xe((gr, Sr, Vr) => {
                                      ve(Jt, gr), ve(nr, `${Sr??""} `), ve(Bt, Vr)
                                    }, [() => qd(), () => Jl(), () => Ql().toLowerCase()]), H(Mt, St)
                                  };
                                  Ue(Ct, Mt => {
                                    x(o) === "alliances" && Mt(yt)
                                  }, !0)
                                }
                                H(st, Tt)
                              };
                            Ue(wt, st => {
                              x(o) === "players" ? st(zt) : st(Nt, !1)
                            }, !0)
                          }
                          H(nt, Ye)
                        };
                      Ue(ie, nt => {
                        x(o) === "countries" ? nt(Se) : nt(Me, !1)
                      }, !0)
                    }
                    H(te, fe)
                  };
                Ue(Ae, te => {
                  x(o) === "regions" ? te(gt) : te(ee, !1)
                })
              }
              H(rt, Qe)
            },
            ot = rt => {
              var Qe = j6();
              H(rt, Qe)
            };
          Ue(tt, rt => {
            x(ae) ? rt(Re) : rt(ot, !1)
          }, !0)
        }
        H(Ke, ct)
      };
    Ue(Fe, Ke => {
      x(ae) && x(ae).length === 0 ? Ke(mt) : Ke(ut, !1)
    })
  }
  jd("innerWidth", Ke => le(C, Ke, !0)), H(w, xe), Rr()
}
rn(["click"]);
var U6 = Cr('<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>');

function Sv(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = U6();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var Z6 = Pe('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function $6(w, l) {
  Dr(l, !0);
  let g = At(l, "open", 15);
  zi(() => {
    const _e = xe => {
      xe.key === "Escape" && g(!1)
    };
    return document.addEventListener("keydown", _e), () => document.removeEventListener("keydown", _e)
  });
  var C = Z6(),
    D = k(C),
    N = V(k(D), 2),
    T = k(N);
  Sv(T, {
    class: "size-6"
  });
  var o = V(T, 2),
    G = k(o, !0);
  A(o), A(N);
  var W = V(N, 2),
    ae = k(W);
  V6(ae, {
    get onvisitclick() {
      return l.onvisitclick
    },
    get open() {
      return g()
    }
  }), A(W), A(D), vi(2), A(C), Gn(C, () => _e => {
    Hr(() => {
      g() ? _e.show() : _e.close()
    })
  }), Xe(_e => ve(G, _e), [() => Xf()]), Pn("close", C, () => g(!1)), H(w, C), Rr()
}
var G6 = Pe("<div><!></div>"),
  H6 = Pe('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function W6(w, l) {
  Dr(l, !0);
  let g = At(l, "open", 15);
  zi(() => {
    const o = G => {
      G.key === "Escape" && g(!1)
    };
    return document.addEventListener("keydown", o), () => document.removeEventListener("keydown", o)
  });
  var C = H6(),
    D = k(C),
    N = V(k(D), 2);
  {
    var T = o => {
      var G = G6(),
        W = k(G);
      hx(W, {}), A(G), zn(2, G, () => ea, () => ({
        duration: 300
      })), H(o, G)
    };
    Ue(N, o => {
      g() && o(T)
    })
  }
  A(D), vi(2), A(C), Gn(C, () => o => {
    Hr(() => {
      g() ? o.show() : o.close()
    })
  }), Pn("close", C, () => g(!1)), H(w, C), Rr()
}
var X6 = (w, l, g) => {
    localStorage.setItem(x(l), "true"), le(g, !1)
  },
  K6 = Pe('<span class="indicator-item indicator-bottom indicator-center badge badge-primary badge-xs">new</span>'),
  Y6 = Pe("<div><!> <!></div>");

function hf(w, l) {
  Dr(l, !0);
  let g = at(!1);
  const C = lt(() => "showed:" + l.key);
  zi(() => {
    le(g, !localStorage.getItem(x(C)))
  });
  var D = Y6();
  D.__click = [X6, C, g];
  var N = k(D);
  {
    var T = G => {
      var W = K6();
      zn(3, W, () => ea, () => ({
        duration: 200
      })), H(G, W)
    };
    Ue(N, G => {
      x(g) && G(T)
    })
  }
  var o = V(N, 2);
  tn(o, () => l.children), A(D), Xe(() => Or(D, 1, `indicator ${l.class??""}`)), H(w, D), Rr()
}
rn(["click"]);
var J6 = Pe("<p>You don't have charges to paint. <br/> </p>");

function Q6(w, l) {
  Dr(l, !1), qg();
  var g = J6(),
    C = V(k(g), 2);
  A(g), Xe(D => ve(C, ` Next charge in ${D??""}`), [() => kd(Et.cooldown ?? 0)]), H(w, g), Rr()
}
var eA = Pe("<canvas></canvas>");

function Pv(w, l) {
  Dr(l, !0);
  let g = At(l, "width", 15, 0),
    C = Yt(l, ["$$slots", "$$events", "$$legacy", "value", "fontSize", "color", "weight", "mono", "width"]),
    D = lt(() => Math.ceil(l.fontSize)),
    N = at(null);
  const T = window.devicePixelRatio ?? 1,
    o = '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
    G = '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  Hr(() => {
    const ae = x(N).getContext("2d");
    ae.textBaseline = "top", ae.font = `${l.weight??"normal"} ${l.fontSize}px ${l.mono?G:o}`, ae.fillStyle = l.color ?? "#394e6a", ae.setTransform(T, 0, 0, T, 0, 0), ae.clearRect(0, 0, g(), x(D)), ae.fillText(l.value, 0, 0);
    const _e = ae.measureText(l.value);
    g(Math.ceil(_e.actualBoundingBoxRight)), le(D, _e.actualBoundingBoxDescent)
  });
  var W = eA();
  er(W, () => ({
    width: g() * T,
    height: x(D) * T,
    style: `width: ${g()??""}px; height: ${x(D)??""}px`,
    ...C
  })), Ds(W, ae => le(N, ae), () => x(N)), H(w, W), Rr()
}
var tA = Pe('<span class="w-7 text-xs"> </span>'),
  rA = Pe('<span class="flex items-center gap-1 sm:mt-[1px]"><span><!></span> <!></span>'),
  iA = Pe('<span class="loading loading-spinner center-absolute absolute"></span>'),
  nA = Pe('<button><!> <div class="flex items-center gap-2"> <!></div> <!></button>');

function Iv(w, l) {
  Dr(l, !0);
  let g = Yt(l, ["$$slots", "$$events", "$$legacy", "loading", "charges"]),
    C = at(0);
  var D = nA();
  er(D, () => ({
    ...g,
    class: `btn btn-primary btn-lg sm:btn-xl relative ${l.class??""}`
  }));
  var N = k(D);
  dh(N, {
    class: "size-6"
  });
  var T = V(N, 2),
    o = k(T),
    G = V(o);
  {
    var W = xe => {
      const K = lt(() => `${Math.floor(l.charges)}/${Et.data.charges.max}`);
      var Ie = rA(),
        Ce = k(Ie),
        De = k(Ce);
      {
        let Le = lt(() => l.disabled ? "#394e6a33" : "#ffffff");
        Pv(De, {
          weight: 600,
          fontSize: 16,
          get value() {
            return x(K)
          },
          get color() {
            return x(Le)
          },
          get width() {
            return x(C)
          },
          set width(Fe) {
            le(C, Fe, !0)
          }
        })
      }
      A(Ce);
      var Be = V(Ce, 2);
      {
        var je = Le => {
          var Fe = tA(),
            mt = k(Fe);
          A(Fe), Xe(ut => ve(mt, `(${ut??""})`), [() => kd(Et.cooldown)]), H(Le, Fe)
        };
        Ue(Be, Le => {
          l.charges < Et.data.charges.max && Et.cooldown !== void 0 && Le(je)
        })
      }
      A(Ie), Xe(Le => cc(Ce, `width: ${Le??""}px`), [() => (Math.floor(x(C) / 5) + 1) * 5]), H(xe, Ie)
    };
    Ue(G, xe => {
      l.charges !== void 0 && Et.data && xe(W)
    })
  }
  A(T);
  var ae = V(T, 2);
  {
    var _e = xe => {
      var K = iA();
      H(xe, K)
    };
    Ue(ae, xe => {
      l.loading && xe(_e)
    })
  }
  A(D), Xe(xe => ve(o, `${xe??""} `), [() => Hg()]), H(w, D), Rr()
}
const aA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII=",
  sA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC",
  oA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC",
  lA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
class cA {
  constructor(l) {
    lr(this, "gm");
    lr(this, "opacity", 1);
    lr(this, "id", `paint-preview-${Math.random()}`);
    lr(this, "tiles", new Map);
    this.input = l, this.gm = new uc(this.input.tileSize)
  }
  place([l, g], C) {
    const {
      tile: D,
      pixel: N
    } = this.gm.latLonToTileAndPixel(l, g, this.input.tileZoom), T = this.getTileKey(D[0], D[1]);
    let o = this.tiles.get(T);
    if (!o) {
      const G = this.gm.tileBoundsLatLon(D[0], D[1], this.input.tileZoom),
        W = tm(G, !0),
        ae = new uA({
          coordinates: W,
          id: `${this.id}-${T}`,
          layerPaint: {
            "raster-opacity": this.opacity,
            "raster-resampling": "nearest"
          },
          tileSize: this.input.tileSize,
          beforeLayerId: this.input.beforeLayerId
        });
      ae.addTo(this.input.map), this.tiles.set(T, ae), o = ae
    }
    o.place(N[0], this.input.tileSize - N[1] - 1, C)
  }
  clear() {
    const l = this.input.map;
    for (const g of this.tiles.values()) g.removeFrom(l), g.removeDOM();
    this.tiles.clear()
  }
  clearAndPlace(l, g) {
    this.clear(), this.place(l, g)
  }
  remove([l, g]) {
    const {
      tile: C,
      pixel: D
    } = this.gm.latLonToTileAndPixel(l, g, this.input.tileZoom), N = this.getTileKey(C[0], C[1]), T = this.tiles.get(N);
    T && T.remove(D[0], this.input.tileSize - D[1] - 1)
  }
  setCanvasOpacity(l) {
    this.opacity = l;
    for (const g of this.tiles.values()) g.setOpacity(l)
  }
  getTileKey(l, g) {
    return `${l},${g}`
  }
}
class uA {
  constructor(l) {
    lr(this, "canvas");
    lr(this, "maps", new Set);
    this.input = l;
    const g = this.input.tileSize;
    this.canvas = document.createElement("canvas"), this.canvas.width = g, this.canvas.height = g
  }
  place(l, g, C) {
    var T;
    const D = ((T = $n.colors) == null ? void 0 : T[C]) ?? $n.colors[0],
      N = this.canvas.getContext("2d");
    if (N) {
      const o = N.createImageData(1, 1),
        [G, W, ae] = D.rgb,
        _e = C === 0 ? 0 : 255;
      o.data[0] = G, o.data[1] = W, o.data[2] = ae, o.data[3] = _e, N.putImageData(o, l, g)
    }
  }
  remove(l, g) {
    const C = this.canvas.getContext("2d");
    C && C.clearRect(l, g, 1, 1)
  }
  addTo(l) {
    const g = this.input.id;
    l.getSource(g) || l.addSource(g, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), l.getLayer(g) || (l.addLayer({
      id: g,
      type: "raster",
      source: g,
      paint: this.input.layerPaint
    }), this.input.beforeLayerId && l.moveLayer(g, this.input.beforeLayerId)), this.maps.add(l)
  }
  removeFrom(l) {
    const {
      id: g
    } = this.input;
    l.getLayer(g) && l.removeLayer(g), l.getSource(g) && l.removeSource(g), this.maps.delete(l)
  }
  removeDOM() {
    this.canvas.remove()
  }
  setOpacity(l) {
    for (const g of this.maps.values()) g.setPaintProperty(this.input.id, "raster-opacity", l)
  }
}
var hA = Cr('<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>');

function dA(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = hA();
  er(C, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...g
  })), H(w, C)
}
var pA = Cr('<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>');

function fA(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = pA();
  er(C, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...g
  })), H(w, C)
}
var mA = Pe("<div><!></div>");

function Kl(w, l) {
  Dr(l, !0);
  var g = mA(),
    C = k(g);
  tn(C, () => l.children ?? ma), A(g), Xe(() => Or(g, 1, `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${l.class??""}`)), H(w, g), Rr()
}
var _A = Pe('<div class="confetti svelte-15ksp55"></div>'),
  gA = Pe("<div></div>");

function um(w, l) {
  Dr(l, !0);
  const g = At(l, "size", 3, 10),
    C = At(l, "x", 19, () => [-.5, .5]),
    D = At(l, "y", 19, () => [.25, 1]),
    N = At(l, "duration", 3, 2e3),
    T = At(l, "infinite", 3, !1),
    o = At(l, "delay", 19, () => [0, 50]),
    G = At(l, "colorRange", 19, () => [0, 360]),
    W = At(l, "colorArray", 19, () => []),
    ae = At(l, "amount", 3, 50),
    _e = At(l, "iterationCount", 3, 1),
    xe = At(l, "fallDistance", 3, "100px"),
    K = At(l, "rounded", 3, !1),
    Ie = At(l, "cone", 3, !1),
    Ce = At(l, "noGravity", 3, !1),
    De = At(l, "xSpread", 3, .15),
    Be = At(l, "destroyOnComplete", 3, !0),
    je = At(l, "disableForReducedMotion", 3, !1);
  let Le = at(!1);
  zi(() => {
    !Be() || T() || typeof _e() == "string" || setTimeout(() => le(Le, !0), (N() + o()[1]) * _e())
  });

  function Fe(tt, Re) {
    return Math.random() * (Re - tt) + tt
  }

  function mt() {
    return W().length ? W()[Math.round(Math.random() * (W().length - 1))] : `hsl(${Math.round(Fe(G()[0],G()[1]))}, 75%, 50%)`
  }
  var ut = Kt(),
    Ke = It(ut);
  {
    var ct = tt => {
      var Re = gA();
      let ot;
      gn(Re, 21, () => ({
        length: ae()
      }), Od, (rt, Qe) => {
        var Ae = _A();
        Xe((gt, ee, te, fe, ie, Se, Me, nt, Ye, wt, zt) => cc(Ae, `
        --color: ${gt??""};
        --skew: ${ee??""}deg,${te??""}deg;
        --rotation-xyz: ${fe??""}, ${ie??""}, ${Se??""};
        --rotation-deg: ${Me??""}deg;
        --translate-y-multiplier: ${nt??""};
        --translate-x-multiplier: ${Ye??""};
        --scale: ${wt??""};
        --transition-delay: ${zt??""}ms;
        --transition-duration: ${T()?`calc(${N()}ms * var(--scale))`:`${N()}ms`};`), [mt, () => Fe(-45, 45), () => Fe(-45, 45), () => Fe(-10, 10), () => Fe(-10, 10), () => Fe(-10, 10), () => Fe(0, 360), () => Fe(D()[0], D()[1]), () => Fe(C()[0], C()[1]), () => .1 * Fe(2, 10), () => Fe(o()[0], o()[1])]), H(rt, Ae)
      }), A(Re), Xe(rt => {
        ot = Or(Re, 1, "confetti-holder svelte-15ksp55", null, ot, rt), cc(Re, `
    --fall-distance: ${xe()??""};
    --size: ${g()??""}px;
    --x-spread: ${1-De()};
    --transition-iteration-count: ${(T()?"infinite":_e())??""};`)
      }, [() => ({
        rounded: K(),
        cone: Ie(),
        "no-gravity": Ce(),
        "reduced-motion": je()
      })]), H(tt, Re)
    };
    Ue(Ke, tt => {
      x(Le) || tt(ct)
    })
  }
  H(w, ut), Rr()
}
var vA = async (w, l, g, C) => {
  try {
    le(l, !0), await ni.purchase({
      id: g,
      amount: 1,
      variant: C.colorIdx
    }), await Et.refresh(), pa.notification1.play()
  } catch (D) {
    $r.error(D.message)
  } finally {
    le(l, !1)
  }
}, yA = Pe('<span class="loading loading-spinner center-absolute absolute"></span>'), xA = Pe('<!> <span class="text-sm">Droplets</span>', 1), bA = Pe('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1), wA = (w, l) => l(!1), TA = Pe('<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>'), CA = Pe('<dialog class="modal !bg-black/80"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function SA(w, l) {
  Dr(l, !0);
  let g = At(l, "open", 15);
  const C = lt(() => $n.colors[l.colorIdx]),
    D = lt(() => {
      var K;
      return ((K = Et.data) == null ? void 0 : K.droplets) ?? 0
    });
  let N = at(!1);
  const T = lt(() => (x(N), Et.hasColor(l.colorIdx)));
  zi(() => {
    const K = Ie => {
      Ie.key === "Escape" && g(!1)
    };
    return document.addEventListener("keydown", K), () => document.removeEventListener("keydown", K)
  });
  const o = 100,
    G = $n.products[o];
  var W = CA(),
    ae = k(W),
    _e = V(k(ae), 2);
  {
    var xe = K => {
      var Ie = TA(),
        Ce = k(Ie),
        De = k(Ce),
        Be = k(De);
      Ed(Be, {
        class: "size-6"
      });
      var je = V(Be, 4),
        Le = k(je);
      Ng(Le, {
        get value() {
          return x(D)
        }
      }), A(je), A(De), vi(2), A(Ce);
      var Fe = V(Ce, 2),
        mt = k(Fe),
        ut = k(mt);
      A(mt);
      var Ke = V(mt, 2),
        ct = k(Ke, !0);
      A(Ke);
      var tt = V(Ke, 2),
        Re = k(tt);
      let ot;
      var rt = k(Re);
      rt.__click = [vA, N, o, l];
      var Qe = k(rt);
      {
        var Ae = ie => {
          var Se = yA();
          H(ie, Se)
        };
        Ue(Qe, ie => {
          x(N) && ie(Ae)
        })
      }
      var gt = V(Qe, 2);
      {
        var ee = ie => {
            var Se = xA(),
              Me = It(Se);
            Nd(Me, {
              class: "size-5"
            });
            var nt = V(Me);
            vi(), Xe(Ye => ve(nt, ` ${Ye??""} `), [() => G.price.toLocaleString("en-US")]), H(ie, Se)
          },
          te = ie => {
            var Se = bA(),
              Me = It(Se);
            Ed(Me, {
              class: "size-5"
            });
            var nt = V(Me, 2),
              Ye = k(nt);
            um(Ye, {}), A(nt), H(ie, Se)
          };
        Ue(gt, ie => {
          x(T) ? ie(te, !1) : ie(ee)
        })
      }
      A(rt), A(Re);
      var fe = V(Re, 2);
      fe.__click = [wA, g], A(tt), A(Fe), A(Ie), Xe((ie, Se) => {
        cc(ut, `background: rgb(${x(C).rgb[0]} ${x(C).rgb[1]} ${x(C).rgb[2]})`), kr(ut, "aria-label", x(C).name), ve(ct, x(C).name), kr(Re, "data-tip", ie), ot = Or(Re, 1, "", null, ot, Se), rt.disabled = x(D) < G.price || x(N) || x(T)
      }, [() => Vd(), () => ({
        tooltip: !x(T) && x(D) < G.price
      })]), H(K, Ie)
    };
    Ue(_e, K => {
      Et.data && K(xe)
    })
  }
  A(ae), vi(2), A(W), Gn(W, () => K => {
    Hr(() => {
      g() ? K.show() : K.close()
    })
  }), Pn("close", W, () => g(!1)), H(w, W), Rr()
}
rn(["click"]);
var PA = Cr('<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>');

function wg(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = PA();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var IA = Cr('<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>');

function Tg(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = IA();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var MA = Cr('<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>');

function Mv(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = MA();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var AA = Cr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>'),
  kA = Cr('<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>');

function Av(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var C = Kt(),
    D = It(C);
  {
    var N = o => {
        var G = AA();
        er(G, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...g
        })), H(o, G)
      },
      T = o => {
        var G = kA();
        er(G, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...g
        })), H(o, G)
      };
    Ue(D, o => {
      l.filled ? o(N) : o(T, !1)
    })
  }
  H(w, C)
}
var EA = Cr('<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>');

function qf(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = EA();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var zA = Cr('<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>');

function kv(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = zA();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var LA = Cr('<svg><path d="m356-160-56-56 180-180 180 180-56 56-124-124-124 124Zm124-404L300-744l56-56 124 124 124-124 56 56-180 180Z"></path></svg>');

function DA(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = LA();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var RA = Cr('<svg><path d="M480-120 300-300l58-58 122 122 122-122 58 58-180 180ZM358-598l-58-58 180-180 180 180-58 58-122-122-122 122Z"></path></svg>');

function BA(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = RA();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var FA = Pe("<!> ", 1),
  OA = Pe("<!> ", 1),
  NA = Pe("<!> ", 1),
  jA = Pe('<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ', 1),
  qA = Pe("<!> ", 1),
  VA = Pe("<!> <!>", 1),
  UA = (w, l) => le(l, !x(l)),
  ZA = (w, l) => {
    le(l, "colorpicker")
  },
  $A = (w, l) => {
    l(!l())
  },
  GA = (w, l) => {
    le(l, "cleararea")
  },
  HA = Pe('<div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button><!></button></div>'),
  WA = (w, l) => {
    pa.smallPlop.play(), l()
  },
  XA = (w, l, g) => {
    l(x(g).idx)
  },
  KA = Pe('<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>', 1),
  YA = Pe("<div><button><!></button></div>"),
  JA = (w, l) => {
    le(l, !x(l))
  },
  QA = (w, l) => {
    le(l, x(l) === "eraser" ? "pencil" : "eraser", !0)
  },
  ek = Pe('<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1"><h2 class="select-none text-xl"> <!></h2> <div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip"><button title="Toggle art opacity"><!></button></div> <!></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>', 1);

function tk(w, l) {
  Dr(l, !0);
  let g = At(l, "screenLocked", 15),
    C = At(l, "opaquePixelArt", 15);
  const D = lt(() => new uc(l.tileSize));
  let N = at(1),
    T = at("pencil");
  const o = new Map,
    G = new Map;
  let W = at(0),
    ae = at(!1),
    _e = at(!0),
    xe = lt(() => Et.charges ?? 0),
    K = lt(() => x(xe) - x(W)),
    Ie = at(!1),
    Ce = !1,
    De = at(!1),
    Be = at(Ln([]));
  const je = lt(() => x(T) === "pencil"),
    Le = lt(() => x(T) === "eraser"),
    Fe = lt(() => x(T) === "colorpicker"),
    mt = lt(() => x(T) === "cleararea"),
    ut = lt(() => {
      var Pt, We;
      return Ad((We = (Pt = Et) == null ? void 0 : Pt.data) == null ? void 0 : We.role, ["admin", "global_moderator"])
    });
  let Ke = at(!1),
    ct = at(0),
    tt = at(void 0),
    Re = at(void 0);
  const ot = [1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42, 12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49, 23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52, 61, 62, 63, 58, 59, 60, 0].map(Pt => ({
      ...$n.colors[Pt],
      idx: Pt
    })),
    rt = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0].map(Pt => ({
      ...$n.colors[Pt],
      idx: Pt
    }));
  let Qe = at(!1);
  const Ae = lt(() => x(Qe) ? ot : rt),
    gt = "show-all-colors";
  zi(() => {
    le(Qe, localStorage.getItem(gt) === "true")
  }), Hr(() => {
    localStorage.setItem(gt, x(Qe) ? "true" : "false")
  });
  const ee = "selected-color";
  zi(() => {
    const Pt = Number(localStorage.getItem(ee));
    !isNaN(Pt) && Pt < $n.colors.length && Pt > 0 && le(N, Pt, !0)
  }), Hr(() => {
    localStorage.setItem(ee, x(N).toString())
  });
  const te = new cA({
    map: l.map,
    tileSize: l.tileSize,
    tileZoom: l.tileZoom,
    beforeLayerId: l.hoverLayerId
  });
  Hr(() => {
    const Pt = C() ? 1 : 0;
    te.setCanvasOpacity(Pt)
  }), Hr(() => {
    C() ? ff() : wt([...o.values()])
  });
  let fe = !1;
  zi(() => {
    Ja(l.map.getCenter(), l.map.getZoom());
    const Pt = l.map.on("click", rr => {
      var Qr;
      l.zoom < l.tileZoom + 2 && ((Qr = Et.data) == null ? void 0 : Qr.role) === "user" && l.map.easeTo({
        center: rr.lngLat,
        zoom: 17
      });
      const bi = [rr.lngLat.lat, rr.lngLat.lng];
      if (x(je)) Se([bi], x(N));
      else if (x(Le)) Me([bi]);
      else if (x(Fe)) nt(bi, rr.point);
      else if (x(mt) && (x(Be).push(bi), Se([bi], 0), x(Be).length >= 2)) {
        const [Yr, la] = x(Be), [ln, ta] = x(D).latLonToPixelsFloor(Yr[0], Yr[1], l.tileZoom), [Oi, Ki] = x(D).latLonToPixelsFloor(la[0], la[1], l.tileZoom), Hn = Math.min(ln, Oi), Wn = Math.max(ln, Oi), Dn = Math.min(ta, Ki), _t = Math.max(ta, Ki), jt = [];
        for (let vr = Dn; vr <= _t; vr++) {
          const _i = x(D).pixelsToLatLon(Hn + .5, vr + .5, l.tileZoom),
            Ri = x(D).pixelsToLatLon(Wn + .5, vr + .5, l.tileZoom),
            Hi = We({
              lat: _i[0],
              lng: _i[1]
            }, {
              lat: Ri[0],
              lng: Ri[1]
            }).slice(0, x(K) - jt.length);
          if (jt.push(...Hi), jt.length >= x(K)) break
        }
        Se(jt, 0), le(Be, [], !0), le(T, "pencil")
      }
      le(Ie, !0)
    });

    function We(rr, bi) {
      const Qr = x(D).latLonToPixels(rr.lat, rr.lng, l.tileZoom),
        Yr = bi ? x(D).latLonToPixels(bi.lat, bi.lng, l.tileZoom) : Qr;
      return sx(Qr, Yr).map(ln => x(D).pixelsToLatLon(ln[0] + .5, ln[1] + .5, l.tileZoom))
    }

    function Ot(rr, bi) {
      const Qr = We(rr, bi);
      x(je) ? Se(Qr, x(N)) : x(Le) && Me(Qr), le(Ie, !0)
    }
    let $t;

    function zr(rr) {
      const bi = l.map.unproject([rr.clientX, rr.clientY]);
      if (x(De)) {
        const Qr = We(bi, $t);
        Me(Qr)
      }(fe || Ce) && Ot(bi, $t), $t = bi
    }
    window.addEventListener("mousemove", zr);
    let Wr = !1;
    const li = l.map.on("touchstart", rr => {
        if (rr.points.length == 2) {
          g(!1), Tt(), Wr = !0, setTimeout(() => Wr = !1, 150);
          return
        }
        g() && setTimeout(() => {
          !Wr && Ot(rr.lngLat)
        }, 150), $t = rr.lngLat
      }),
      _r = l.map.on("touchmove", rr => {
        g() && Ot(rr.lngLat, $t), $t = rr.lngLat
      }),
      Ti = rr => {
        rr.code === "Space" && (fe || $t && Ot($t), fe = !0, rr.preventDefault())
      };
    document.addEventListener("keydown", Ti);
    const Pi = rr => {
      rr.code === "Space" && (fe = !1, ie = !1, x(W) === 0 && x(Le) && le(T, "pencil"))
    };
    document.addEventListener("keyup", Pi);

    function Li(rr) {
      if (rr.button === 2) {
        le(De, !0);
        const Qr = l.map.unproject([rr.clientX, rr.clientY]);
        Me([
          [Qr.lat, Qr.lng]
        ])
      }
    }
    document.addEventListener("mousedown", Li);

    function mi(rr) {
      rr.button === 2 && le(De, !1)
    }
    document.addEventListener("mouseup", mi);
    const Di = rr => {
      switch (rr.code) {
        case "KeyE":
          x(W) > 0 && (x(Le) ? le(T, "pencil") : le(T, "eraser"));
          return;
        case "KeyI":
          le(T, "colorpicker");
          return;
        case "KeyC":
          x(ut) && le(T, "cleararea");
          return
      }
    };
    return document.addEventListener("keypress", Di), () => {
      _r.unsubscribe(), li.unsubscribe(), Pt.unsubscribe(), document.removeEventListener("mousemove", zr), document.removeEventListener("keydown", Ti), document.removeEventListener("keyup", Pi), document.removeEventListener("keypress", Di), document.removeEventListener("mousedown", Li), document.removeEventListener("mouseup", mi), zt()
    }
  });
  let ie = !1;

  function Se(Pt, We) {
    let Ot = !1;
    const $t = We === 0;
    for (let zr of Pt) {
      const [Wr, li] = zr, _r = ix(We), {
        tile: Ti,
        pixel: Pi
      } = x(D).latLonToTileAndPixel(Wr, li, l.tileZoom), Li = {
        color: _r,
        tile: Ti,
        pixel: Pi,
        season: l.season,
        colorIdx: We
      }, mi = nf(Li), Di = o.get(mi), rr = x(xe) - o.size;
      if (!Di && rr < 1) {
        if (ie && (fe || g())) continue;
        ie = !0, $r.info(D3());
        continue
      }
      Di && Di.colorIdx === We || (pa.plop.play(), Ot || l.hidePixelHover(), o.set(mi, Li), te.place(zr, We), l.crosshair.place(zr), Ot = !0, $t && G.set(mi, Li))
    }
    le(W, o.size, !0), Ot && !C() ? wt([...o.values()]) : Ot && C() && $t && wt([...G.values()])
  }

  function Me(Pt) {
    let We = !1,
      Ot = !1;
    for (let $t of Pt) {
      const [zr, Wr] = $t, {
        tile: li,
        pixel: _r
      } = x(D).latLonToTileAndPixel(zr, Wr, l.tileZoom), Ti = nf({
        tile: li,
        pixel: _r,
        season: l.season
      }), Pi = o.get(Ti);
      Pi && (pa.plop.play(), l.hidePixelHover(), o.delete(Ti), G.delete(Ti), te.remove([zr, Wr]), l.crosshair.remove($t), We = !0, Pi.colorIdx === 0 && (Ot = !0)), o.size === 0 && !(fe || Ce || g()) && le(T, "pencil")
    }
    le(W, o.size, !0), We && !C() ? wt([...o.values()]) : We && C() && Ot && wt([...G.values()])
  }

  function nt(Pt, We) {
    const {
      tile: Ot,
      pixel: $t
    } = x(D).latLonToTileAndPixel(Pt[0], Pt[1], l.tileZoom), zr = nf({
      tile: Ot,
      pixel: $t,
      season: l.season
    }), Wr = o.get(zr);
    if (Wr) {
      Ct(Wr.colorIdx), requestAnimationFrame(() => {
        var Pi;
        (Pi = document.getElementById(`color-${Wr.colorIdx}`)) == null || Pi.focus()
      });
      return
    }
    const li = window.devicePixelRatio,
      _r = Math.floor(We.x * li),
      Ti = Math.floor(We.y * li);
    l.hidePixelHover(), xI(l.map, _r, Ti).then(([Pi, Li, mi]) => {
      const Di = nx({
        r: Pi,
        g: Li,
        b: mi
      });
      Ct(Di), requestAnimationFrame(() => {
        var rr;
        (rr = document.getElementById(`color-${Di}`)) == null || rr.focus()
      })
    })
  }
  hc(() => x(N), () => {
    l.clickedLatLon && !x(Ie) && (x(N) === void 0 && le(N, 1), Se([l.clickedLatLon], x(N)))
  }), Hr(() => {
    const Pt = x(_e) ? .8 : 0;
    l.crosshair.setCanvasOpacity(Pt)
  });
  let Ye = at(16.5);
  Hr(() => {
    if (x(tt) && x(Re) && l.clickedLatLon) {
      const Pt = l.map.getZoom();
      if (Pt < x(Ye)) {
        const [We, Ot] = l.clickedLatLon, $t = x(D).latLonToPixelBoundsLatLon(We, Ot, l.tileZoom), zr = rm($t), Wr = x(tt) - x(Re).clientHeight, li = x(tt) / 2 - Wr / 2;
        l.map.flyTo({
          center: {
            lat: zr[0],
            lng: zr[1]
          },
          zoom: 17.5,
          offset: Pt > 11 ? [0, -li] : [0, 0]
        })
      }
      le(Ye, l.tileZoom, !0)
    }
  }), zi(() => {
    const Pt = () => {
      !document.hidden && (console.log("Tab visible again"), C() ? wt([...G.values()]) : wt([...o.values()]))
    };
    return document.addEventListener("visibilitychange", Pt), () => document.removeEventListener("visibilitychange", Pt)
  }), Hr(() => {
    switch (x(T)) {
      case "pencil":
        l.map.getCanvas().style.cursor = `url('${oA}') 8 8, default`, l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4);
        return;
      case "colorpicker":
        l.map.getCanvas().style.cursor = `url('${aA}') 0 16, default`, l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", 0);
        return;
      case "eraser":
        l.map.getCanvas().style.cursor = `url('${sA}') 2 14, default`, l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4);
        return
    }
  }), Hr(() => {
    g() ? st() : Tt()
  });
  async function wt(Pt) {
    await Uy(Pt), l.refreshPixelArt()
  }
  async function zt() {
    await ff(), te.clear(), l.refreshPixelArt(), l.crosshair.clear()
  }
  async function Nt() {
    await zt(), Tt(), l.map.getCanvas().style.cursor = "default", l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4), l.onclose()
  }

  function st() {
    l.map.dragPan.disable(), l.map.touchZoomRotate.disable(), document.body.style.overscrollBehavior = "none"
  }

  function Tt() {
    l.map.dragPan.enable(), l.map.touchZoomRotate.enable(), document.body.style.overscrollBehavior = ""
  }

  function Ct(Pt) {
    return Pt >= 32 && le(Qe, !0), Et.hasColor(Pt) ? (pa.smallDropplet.play(), le(N, Pt, !0), le(T, "pencil"), !0) : (pa.smallDropplet.play(), le(Ke, !0), le(ct, Pt, !0), !1)
  }
  $y(Pt => {
    Pt.type === "leave" && x(W) > 0 && Pt.cancel()
  });
  const yt = "show-paint-more-than-one-pixel-msg";
  let Mt = at(!1);
  zi(() => {
    var Pt;
    le(Mt, !localStorage.getItem(yt) && (((Pt = Et.data) == null ? void 0 : Pt.pixelsPainted) ?? 0) < 100, !0)
  }), Hr(() => {
    x(W) > 1 && (le(Mt, !1), localStorage.setItem(yt, "false"))
  });
  const St = "lp";
  zi(() => {
    var We;
    const Pt = localStorage.getItem(St);
    if (Pt) try {
      const Ot = JSON.parse(atob(Pt)),
        $t = (Ot == null ? void 0 : Ot.time) ?? 0,
        zr = 60 * 1e3;
      (Ot == null ? void 0 : Ot.userId) !== ((We = Et.data) == null ? void 0 : We.id) && Date.now() - $t < 30 * zr && !ox && ($r.error(F3()), Nt())
    } catch (Ot) {
      console.error(Ot)
    }
  });

  function ht() {
    var We;
    const Pt = btoa(JSON.stringify({
      userId: (We = Et.data) == null ? void 0 : We.id,
      time: Date.now()
    }));
    localStorage.setItem(St, Pt)
  }
  var Lt = ek(),
    tr = It(Lt),
    Jt = k(tr);
  {
    var dr = Pt => {
        Kl(Pt, {
          children: (We, Ot) => {
            var $t = FA(),
              zr = It($t);
            Mv(zr, {
              class: "inline size-5"
            });
            var Wr = V(zr);
            Xe(li => ve(Wr, ` ${li??""}`), [() => tw()]), H(We, $t)
          },
          $$slots: {
            default: !0
          }
        })
      },
      nr = Pt => {
        var We = Kt(),
          Ot = It(We);
        {
          var $t = Wr => {
              Kl(Wr, {
                class: "not-touchscreen:hidden",
                children: (li, _r) => {
                  var Ti = OA(),
                    Pi = It(Ti);
                  og(Pi, {
                    class: "inline size-5"
                  });
                  var Li = V(Pi);
                  Xe(mi => ve(Li, ` ${mi??""}`), [() => nw()]), H(li, Ti)
                },
                $$slots: {
                  default: !0
                }
              })
            },
            zr = Wr => {
              var li = Kt(),
                _r = It(li);
              {
                var Ti = Li => {
                    Kl(Li, {
                      class: "not-touchscreen:hidden",
                      children: (mi, Di) => {
                        var rr = NA(),
                          bi = It(rr);
                        Tg(bi, {
                          class: "inline size-5"
                        });
                        var Qr = V(bi, 1, !0);
                        Xe(Yr => ve(Qr, Yr), [() => ow()]), H(mi, rr)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  },
                  Pi = Li => {
                    var mi = Kt(),
                      Di = It(mi);
                    {
                      var rr = Qr => {
                          Kl(Qr, {
                            class: "touchscreen:hidden",
                            children: (Yr, la) => {
                              var ln = jA(),
                                ta = It(ln);
                              kv(ta, {
                                class: "inline size-5"
                              });
                              var Oi = V(ta),
                                Ki = k(Oi, !0);
                              A(Oi);
                              var Hn = V(Oi, 2),
                                Wn = k(Hn),
                                Dn = V(Wn),
                                _t = k(Dn, !0);
                              A(Dn), A(Hn);
                              var jt = V(Hn);
                              Xe((vr, _i, Ri, Hi) => {
                                ve(Ki, vr), ve(Wn, `${_i??""} `), ve(_t, Ri), ve(jt, ` ${Hi??""}`)
                              }, [() => uw(), () => _w(), () => pw(), () => yw()]), H(Yr, ln)
                            },
                            $$slots: {
                              default: !0
                            }
                          })
                        },
                        bi = Qr => {
                          var Yr = Kt(),
                            la = It(Yr);
                          {
                            var ln = Oi => {
                                Kl(Oi, {
                                  class: "bg-warning text-warning-content animate-bounce",
                                  children: (Ki, Hn) => {
                                    var Wn = qA(),
                                      Dn = It(Wn);
                                    dh(Dn, {
                                      class: "inline size-5"
                                    });
                                    var _t = V(Dn);
                                    Xe(jt => ve(_t, ` ${jt??""}`), [() => ww()]), H(Ki, Wn)
                                  },
                                  $$slots: {
                                    default: !0
                                  }
                                })
                              },
                              ta = Oi => {
                                var Ki = Kt(),
                                  Hn = It(Ki);
                                {
                                  var Wn = Dn => {
                                    Kl(Dn, {
                                      class: "bg-warning text-warning-content animate-bounce",
                                      children: (_t, jt) => {
                                        var vr = VA(),
                                          _i = It(vr);
                                        wg(_i, {
                                          class: "inline size-5"
                                        });
                                        var Ri = V(_i, 2);
                                        {
                                          var Hi = Tr => {
                                              var vn = On();
                                              Xe(Qt => ve(vn, Qt), [() => SS()]), H(Tr, vn)
                                            },
                                            Mi = Tr => {
                                              var vn = Kt(),
                                                Qt = It(vn);
                                              {
                                                var Gt = ei => {
                                                  var ri = On();
                                                  Xe(gi => ve(ri, gi), [() => MS()]), H(ei, ri)
                                                };
                                                Ue(Qt, ei => {
                                                  x(Be).length === 1 && ei(Gt)
                                                }, !0)
                                              }
                                              H(Tr, vn)
                                            };
                                          Ue(Ri, Tr => {
                                            x(Be).length === 0 ? Tr(Hi) : Tr(Mi, !1)
                                          })
                                        }
                                        H(_t, vr)
                                      },
                                      $$slots: {
                                        default: !0
                                      }
                                    })
                                  };
                                  Ue(Hn, Dn => {
                                    x(mt) && Dn(Wn)
                                  }, !0)
                                }
                                H(Oi, Ki)
                              };
                            Ue(la, Oi => {
                              x(Mt) ? Oi(ln) : Oi(ta, !1)
                            }, !0)
                          }
                          H(Qr, Yr)
                        };
                      Ue(Di, Qr => {
                        x(je) && x(W) === 0 ? Qr(rr) : Qr(bi, !1)
                      }, !0)
                    }
                    H(Li, mi)
                  };
                Ue(_r, Li => {
                  x(Fe) ? Li(Ti) : Li(Pi, !1)
                }, !0)
              }
              H(Wr, li)
            };
          Ue(Ot, Wr => {
            x(Le) ? Wr($t) : Wr(zr, !1)
          }, !0)
        }
        H(Pt, We)
      };
    Ue(Jt, Pt => {
      x(Le) && x(W) === 0 ? Pt(dr) : Pt(nr, !1)
    })
  }
  var Bt = V(Jt, 2),
    pr = k(Bt);
  pr.__click = [UA, _e];
  var gr = k(pr);
  {
    var Sr = Pt => {
        dA(Pt, {
          class: "size-4"
        })
      },
      Vr = Pt => {
        fA(Pt, {
          class: "size-4"
        })
      };
    Ue(gr, Pt => {
      x(_e) ? Pt(Sr) : Pt(Vr, !1)
    })
  }
  A(pr);
  var ur = V(pr, 2),
    Pr = k(ur),
    Ir = k(Pr),
    Mr = V(Ir);
  Pv(Mr, {
    class: "inline",
    fontSize: 14,
    get value() {
      return `(${x(W)??""})`
    },
    mono: !0
  }), A(Pr);
  var Nr = V(Pr, 2),
    ce = k(Nr),
    F = k(ce);
  vi(), A(ce);
  var q = V(ce, 2);
  q.__click = [ZA, T];
  var $ = k(q);
  Tg($, {
    class: "size-4.5"
  }), A(q), A(Nr);
  var X = V(Nr, 2),
    oe = k(X);
  let me;
  oe.__click = [$A, C];
  var Ee = k(oe);
  {
    let Pt = lt(() => !C());
    Av(Ee, {
      class: "size-4.5",
      get filled() {
        return x(Pt)
      }
    })
  }
  A(oe), A(X);
  var Te = V(X, 2);
  {
    var Ze = Pt => {
      var We = HA(),
        Ot = k(We),
        $t = k(Ot);
      vi(), A(Ot);
      var zr = V(Ot, 2);
      zr.__click = [GA, T];
      var Wr = k(zr);
      wg(Wr, {
        class: "size-4.5"
      }), A(zr), A(We), Xe(li => {
        ve($t, `${li??""} `), Or(zr, 1, ao({
          "btn btn-circle btn-sm": !0,
          "btn-ghost": !x(mt),
          "btn-primary": x(mt)
        }))
      }, [() => wS()]), H(Pt, We)
    };
    Ue(Te, Pt => {
      x(ut) && Pt(Ze)
    })
  }
  A(ur);
  var it = V(ur, 2);
  it.__click = [WA, Nt];
  var $e = k(it);
  pc($e, {
    class: "size-4"
  }), A(it), A(Bt);
  var kt = V(Bt, 2),
    ye = k(kt);
  gn(ye, 23, () => x(Ae), Pt => Pt.idx, (Pt, We, Ot) => {
    const $t = lt(() => {
        const [mi, Di, rr] = x(We).rgb;
        return {
          r: mi,
          g: Di,
          b: rr
        }
      }),
      zr = lt(() => x(N) === x(We).idx && x(je)),
      Wr = lt(() => x(We).idx === 0),
      li = lt(() => Et.hasColor(x(We).idx));
    var _r = YA(),
      Ti = k(_r);
    Ti.__click = [XA, Ct, We];
    var Pi = k(Ti);
    {
      var Li = mi => {
        var Di = KA(),
          rr = It(Di);
        qf(rr, {
          class: "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6"
        });
        var bi = V(rr, 2),
          Qr = k(bi);
        qf(Qr, {
          class: "text-base-content/80 size-4"
        }), A(bi), H(mi, Di)
      };
      Ue(Pi, mi => {
        x(li) || mi(Li)
      })
    }
    A(Ti), A(_r), Xe(() => {
      Or(_r, 1, ao({
        tooltip: !0,
        "max-sm:h-6": x(Qe),
        "max-sm:before:translate-x-1/4": x(Ot) % 8 === 0 && x(We).name.length > 7,
        "max-sm:before:-translate-x-1/4": (x(Ot) - 7) % 8 === 0 && x(We).name.length > 7,
        "max-xl:before:translate-x-1/4": x(Ot) % 16 === 0 && x(We).name.length > 7,
        "max-xl:before:-translate-x-1/4": (x(Ot) - 15) % 16 === 0 && x(We).name.length > 7,
        "xl:before:translate-x-1/4": x(Qe) && x(Ot) % 32 === 0 && x(We).name.length > 7,
        "xl:before:-translate-x-1/4": x(Qe) && (x(Ot) - 31) % 32 === 0 && x(We).name.length > 7
      })), kr(_r, "data-tip", x(We).name), Or(Ti, 1, ao({
        "btn relative aspect-square w-full rounded-xl": !0,
        "border-primary ring-primary ring-2": x(zr),
        "border-base-300": !x(zr) && x(Wr),
        "border-base-content/20": !x(zr) && !x(Wr),
        "max-sm:h-6 max-sm:rounded-md": x(Qe)
      })), cc(Ti, x(Wr) ? `background-image: url(${lA}); background-size: cover; image-rendering: pixelated;` : `background: rgb(${x($t).r} ${x($t).g} ${x($t).b})`), kr(Ti, "aria-label", x(We).name), kr(Ti, "id", `color-${x(We).idx??""}`)
    }), Pn("focus", Ti, () => {
      x(li) && (le(N, x(We).idx, !0), le(T, "pencil"))
    }), H(Pt, _r)
  }), A(ye), A(kt);
  var Xt = V(kt, 2),
    Ht = k(Xt);
  Ht.__click = [JA, Qe];
  var pt = k(Ht);
  {
    var bt = Pt => {
        DA(Pt, {
          class: "size-5"
        })
      },
      ar = Pt => {
        BA(Pt, {
          class: "size-5"
        })
      };
    Ue(pt, Pt => {
      x(Qe) ? Pt(bt) : Pt(ar, !1)
    })
  }
  A(Ht);
  var jr = V(Ht, 2),
    qr = k(jr);
  {
    let Pt = lt(() => x(W) > 100 ? "animate-pulse" : ""),
      We = lt(() => x(W) === 0 || x(ae) || x(K) < 0 || !oa.captcha),
      Ot = lt(() => x(ae) || !oa.captcha);
    Iv(qr, {
      get class() {
        return x(Pt)
      },
      get charges() {
        return x(K)
      },
      get disabled() {
        return x(We)
      },
      get loading() {
        return x(Ot)
      },
      onclick: async () => {
        var Wr;
        const $t = (Wr = oa.captcha) == null ? void 0 : Wr.token;
        if (!$t) return;
        pa.droppletAndPlop.play();
        const zr = [...o.values()];
        le(ae, !0);
        try {
          await ni.paint(zr, $t), await Zy(zr), ht(), Et.refresh(), Cd.shouldReload = !0, await Nt()
        } catch (li) {
          $r.error(`${li.message}`, {
            duration: 7e3
          })
        } finally {
          le(ae, !1), oa.captcha = void 0
        }
      }
    })
  }
  A(jr);
  var Gr = V(jr, 2),
    mr = k(Gr),
    Er = k(mr),
    ai = k(Er);
  vi(), A(Er);
  var ft = V(Er, 2);
  let yi;
  ft.__click = [QA, T];
  var pi = k(ft);
  og(pi, {
    class: "size-5",
    get filled() {
      return x(Le)
    }
  }), A(ft), A(mr), A(Gr), A(Xt), A(tr), Ds(tr, Pt => le(Re, Pt), () => x(Re));
  var In = V(tr, 2);
  SA(In, {
    get colorIdx() {
      return x(ct)
    },
    get open() {
      return x(Ke)
    },
    set open(Pt) {
      le(Ke, Pt, !0)
    }
  }), Xe((Pt, We, Ot, $t, zr, Wr) => {
    ve(Ir, `${Pt??""} `), ve(F, `${We??""} `), Or(q, 1, ao({
      "btn btn-circle btn-sm": !0,
      "btn-ghost": !x(Fe),
      "btn-primary": x(Fe)
    })), kr(X, "data-tip", Ot), me = Or(oe, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, me, $t), Or(ye, 1, ao({
      "md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
      "xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": x(Qe),
      "gap-1": !x(Qe)
    })), ve(ai, `${zr??""} `), yi = Or(ft, 1, "btn btn-lg btn-square sm:btn-xl shadow-md", null, yi, Wr), ft.disabled = x(W) === 0
  }, [() => Sw(), () => Mw(), () => Gg(), () => ({
    "text-primary": !C()
  }), () => lx(), () => ({
    "btn-primary": x(Le)
  })]), jd("innerHeight", Pt => le(tt, Pt, !0)), H(w, Lt), Rr()
}
rn(["click"]);

function hm(...w) {
  return Rg(wu(w))
}
var rk = Pe("<div><!></div>");

function ik(w, l) {
  Dr(l, !0);
  let g = At(l, "ref", 15, null),
    C = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]);
  var D = rk();
  er(D, T => ({
    class: T,
    ...C
  }), [() => hm("flex items-center", l.class)]);
  var N = k(D);
  tn(N, () => l.children ?? ma), A(D), Ds(D, T => g(T), () => g()), H(w, D), Rr()
}
var nk = Pe('<div class="pointer-events-none absolute inset-0 flex items-center justify-center"><div class="animate-caret-blink bg-base-content/80 h-4 w-px duration-1000"></div></div>'),
  ak = Pe(" <!>", 1);

function sk(w, l) {
  Dr(l, !0);
  let g = At(l, "ref", 15, null),
    C = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "cell", "class"]);
  var D = Kt(),
    N = It(D);
  {
    let T = lt(() => hm("border-input relative flex size-12 items-center justify-center border-y border-r text-xl transition-all first:rounded-l-md first:border-l last:rounded-r-md", l.cell.isActive && "ring-base-content/40 z-10 ring-2", l.class));
    _n(N, () => e6, (o, G) => {
      G(o, co({
        get cell() {
          return l.cell
        },
        get class() {
          return x(T)
        }
      }, () => C, {
        get ref() {
          return g()
        },
        set ref(W) {
          g(W)
        },
        children: (W, ae) => {
          vi();
          var _e = ak(),
            xe = It(_e),
            K = V(xe);
          {
            var Ie = Ce => {
              var De = nk();
              H(Ce, De)
            };
            Ue(K, Ce => {
              l.cell.hasFakeCaret && Ce(Ie)
            })
          }
          Xe(() => ve(xe, `${l.cell.char??""} `)), H(W, _e)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  H(w, D), Rr()
}

function ok(w, l) {
  Dr(l, !0);
  let g = At(l, "ref", 15, null),
    C = At(l, "value", 15, ""),
    D = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var N = Kt(),
    T = It(N);
  {
    let o = lt(() => hm("flex items-center gap-2 has-[:disabled]:opacity-50 [&_input]:disabled:cursor-not-allowed", l.class));
    _n(T, () => J4, (G, W) => {
      W(G, co({
        get class() {
          return x(o)
        }
      }, () => D, {
        get ref() {
          return g()
        },
        set ref(ae) {
          g(ae)
        },
        get value() {
          return C()
        },
        set value(ae) {
          C(ae)
        }
      }))
    })
  }
  H(w, N), Rr()
}
var df = {
    exports: {}
  },
  Cg;

function lk() {
  return Cg || (Cg = 1, (function(w) {
    (function(l) {
      w.exports ? w.exports = l() : window.intlTelInput = l()
    })(() => {
      var l = (() => {
        var g = Object.defineProperty,
          C = Object.getOwnPropertyDescriptor,
          D = Object.getOwnPropertyNames,
          N = Object.prototype.hasOwnProperty,
          T = (ee, te) => {
            for (var fe in te) g(ee, fe, {
              get: te[fe],
              enumerable: !0
            })
          },
          o = (ee, te, fe, ie) => {
            if (te && typeof te == "object" || typeof te == "function")
              for (let Se of D(te)) !N.call(ee, Se) && Se !== fe && g(ee, Se, {
                get: () => te[Se],
                enumerable: !(ie = C(te, Se)) || ie.enumerable
              });
            return ee
          },
          G = ee => o(g({}, "__esModule", {
            value: !0
          }), ee),
          W = {};
        T(W, {
          Iti: () => rt,
          default: () => gt
        });
        var ae = [
            ["af", "93"],
            ["ax", "358", 1],
            ["al", "355"],
            ["dz", "213"],
            ["as", "1", 5, ["684"]],
            ["ad", "376"],
            ["ao", "244"],
            ["ai", "1", 6, ["264"]],
            ["ag", "1", 7, ["268"]],
            ["ar", "54"],
            ["am", "374"],
            ["aw", "297"],
            ["ac", "247"],
            ["au", "61", 0, null, "0"],
            ["at", "43"],
            ["az", "994"],
            ["bs", "1", 8, ["242"]],
            ["bh", "973"],
            ["bd", "880"],
            ["bb", "1", 9, ["246"]],
            ["by", "375"],
            ["be", "32"],
            ["bz", "501"],
            ["bj", "229"],
            ["bm", "1", 10, ["441"]],
            ["bt", "975"],
            ["bo", "591"],
            ["ba", "387"],
            ["bw", "267"],
            ["br", "55"],
            ["io", "246"],
            ["vg", "1", 11, ["284"]],
            ["bn", "673"],
            ["bg", "359"],
            ["bf", "226"],
            ["bi", "257"],
            ["kh", "855"],
            ["cm", "237"],
            ["ca", "1", 1, ["204", "226", "236", "249", "250", "263", "289", "306", "343", "354", "365", "367", "368", "382", "387", "403", "416", "418", "428", "431", "437", "438", "450", "584", "468", "474", "506", "514", "519", "548", "579", "581", "584", "587", "604", "613", "639", "647", "672", "683", "705", "709", "742", "753", "778", "780", "782", "807", "819", "825", "867", "873", "879", "902", "905"]],
            ["cv", "238"],
            ["bq", "599", 1, ["3", "4", "7"]],
            ["ky", "1", 12, ["345"]],
            ["cf", "236"],
            ["td", "235"],
            ["cl", "56"],
            ["cn", "86"],
            ["cx", "61", 2, ["89164"], "0"],
            ["cc", "61", 1, ["89162"], "0"],
            ["co", "57"],
            ["km", "269"],
            ["cg", "242"],
            ["cd", "243"],
            ["ck", "682"],
            ["cr", "506"],
            ["ci", "225"],
            ["hr", "385"],
            ["cu", "53"],
            ["cw", "599", 0],
            ["cy", "357"],
            ["cz", "420"],
            ["dk", "45"],
            ["dj", "253"],
            ["dm", "1", 13, ["767"]],
            ["do", "1", 2, ["809", "829", "849"]],
            ["ec", "593"],
            ["eg", "20"],
            ["sv", "503"],
            ["gq", "240"],
            ["er", "291"],
            ["ee", "372"],
            ["sz", "268"],
            ["et", "251"],
            ["fk", "500"],
            ["fo", "298"],
            ["fj", "679"],
            ["fi", "358", 0],
            ["fr", "33"],
            ["gf", "594"],
            ["pf", "689"],
            ["ga", "241"],
            ["gm", "220"],
            ["ge", "995"],
            ["de", "49"],
            ["gh", "233"],
            ["gi", "350"],
            ["gr", "30"],
            ["gl", "299"],
            ["gd", "1", 14, ["473"]],
            ["gp", "590", 0],
            ["gu", "1", 15, ["671"]],
            ["gt", "502"],
            ["gg", "44", 1, ["1481", "7781", "7839", "7911"], "0"],
            ["gn", "224"],
            ["gw", "245"],
            ["gy", "592"],
            ["ht", "509"],
            ["hn", "504"],
            ["hk", "852"],
            ["hu", "36"],
            ["is", "354"],
            ["in", "91"],
            ["id", "62"],
            ["ir", "98"],
            ["iq", "964"],
            ["ie", "353"],
            ["im", "44", 2, ["1624", "74576", "7524", "7924", "7624"], "0"],
            ["il", "972"],
            ["it", "39", 0],
            ["jm", "1", 4, ["876", "658"]],
            ["jp", "81"],
            ["je", "44", 3, ["1534", "7509", "7700", "7797", "7829", "7937"], "0"],
            ["jo", "962"],
            ["kz", "7", 1, ["33", "7"], "8"],
            ["ke", "254"],
            ["ki", "686"],
            ["xk", "383"],
            ["kw", "965"],
            ["kg", "996"],
            ["la", "856"],
            ["lv", "371"],
            ["lb", "961"],
            ["ls", "266"],
            ["lr", "231"],
            ["ly", "218"],
            ["li", "423"],
            ["lt", "370"],
            ["lu", "352"],
            ["mo", "853"],
            ["mg", "261"],
            ["mw", "265"],
            ["my", "60"],
            ["mv", "960"],
            ["ml", "223"],
            ["mt", "356"],
            ["mh", "692"],
            ["mq", "596"],
            ["mr", "222"],
            ["mu", "230"],
            ["yt", "262", 1, ["269", "639"], "0"],
            ["mx", "52"],
            ["fm", "691"],
            ["md", "373"],
            ["mc", "377"],
            ["mn", "976"],
            ["me", "382"],
            ["ms", "1", 16, ["664"]],
            ["ma", "212", 0, null, "0"],
            ["mz", "258"],
            ["mm", "95"],
            ["na", "264"],
            ["nr", "674"],
            ["np", "977"],
            ["nl", "31"],
            ["nc", "687"],
            ["nz", "64"],
            ["ni", "505"],
            ["ne", "227"],
            ["ng", "234"],
            ["nu", "683"],
            ["nf", "672"],
            ["kp", "850"],
            ["mk", "389"],
            ["mp", "1", 17, ["670"]],
            ["no", "47", 0],
            ["om", "968"],
            ["pk", "92"],
            ["pw", "680"],
            ["ps", "970"],
            ["pa", "507"],
            ["pg", "675"],
            ["py", "595"],
            ["pe", "51"],
            ["ph", "63"],
            ["pl", "48"],
            ["pt", "351"],
            ["pr", "1", 3, ["787", "939"]],
            ["qa", "974"],
            ["re", "262", 0, null, "0"],
            ["ro", "40"],
            ["ru", "7", 0, null, "8"],
            ["rw", "250"],
            ["ws", "685"],
            ["sm", "378"],
            ["st", "239"],
            ["sa", "966"],
            ["sn", "221"],
            ["rs", "381"],
            ["sc", "248"],
            ["sl", "232"],
            ["sg", "65"],
            ["sx", "1", 21, ["721"]],
            ["sk", "421"],
            ["si", "386"],
            ["sb", "677"],
            ["so", "252"],
            ["za", "27"],
            ["kr", "82"],
            ["ss", "211"],
            ["es", "34"],
            ["lk", "94"],
            ["bl", "590", 1],
            ["sh", "290"],
            ["kn", "1", 18, ["869"]],
            ["lc", "1", 19, ["758"]],
            ["mf", "590", 2],
            ["pm", "508"],
            ["vc", "1", 20, ["784"]],
            ["sd", "249"],
            ["sr", "597"],
            ["sj", "47", 1, ["79"]],
            ["se", "46"],
            ["ch", "41"],
            ["sy", "963"],
            ["tw", "886"],
            ["tj", "992"],
            ["tz", "255"],
            ["th", "66"],
            ["tl", "670"],
            ["tg", "228"],
            ["tk", "690"],
            ["to", "676"],
            ["tt", "1", 22, ["868"]],
            ["tn", "216"],
            ["tr", "90"],
            ["tm", "993"],
            ["tc", "1", 23, ["649"]],
            ["tv", "688"],
            ["ug", "256"],
            ["ua", "380"],
            ["ae", "971"],
            ["gb", "44", 0, null, "0"],
            ["us", "1", 0],
            ["uy", "598"],
            ["vi", "1", 24, ["340"]],
            ["uz", "998"],
            ["vu", "678"],
            ["va", "39", 1, ["06698"]],
            ["ve", "58"],
            ["vn", "84"],
            ["wf", "681"],
            ["eh", "212", 1, ["5288", "5289"], "0"],
            ["ye", "967"],
            ["zm", "260"],
            ["zw", "263"]
          ],
          _e = [];
        for (let ee = 0; ee < ae.length; ee++) {
          const te = ae[ee];
          _e[ee] = {
            name: "",
            iso2: te[0],
            dialCode: te[1],
            priority: te[2] || 0,
            areaCodes: te[3] || null,
            nodeById: {},
            nationalPrefix: te[4] || null
          }
        }
        var xe = _e,
          K = {
            ad: "Andorra",
            ae: "United Arab Emirates",
            af: "Afghanistan",
            ag: "Antigua & Barbuda",
            ai: "Anguilla",
            al: "Albania",
            am: "Armenia",
            ao: "Angola",
            ar: "Argentina",
            as: "American Samoa",
            at: "Austria",
            au: "Australia",
            aw: "Aruba",
            ax: "Ã…land Islands",
            az: "Azerbaijan",
            ba: "Bosnia & Herzegovina",
            bb: "Barbados",
            bd: "Bangladesh",
            be: "Belgium",
            bf: "Burkina Faso",
            bg: "Bulgaria",
            bh: "Bahrain",
            bi: "Burundi",
            bj: "Benin",
            bl: "St. BarthÃ©lemy",
            bm: "Bermuda",
            bn: "Brunei",
            bo: "Bolivia",
            bq: "Caribbean Netherlands",
            br: "Brazil",
            bs: "Bahamas",
            bt: "Bhutan",
            bw: "Botswana",
            by: "Belarus",
            bz: "Belize",
            ca: "Canada",
            cc: "Cocos (Keeling) Islands",
            cd: "Congo - Kinshasa",
            cf: "Central African Republic",
            cg: "Congo - Brazzaville",
            ch: "Switzerland",
            ci: "CÃ´te dâ€™Ivoire",
            ck: "Cook Islands",
            cl: "Chile",
            cm: "Cameroon",
            cn: "China",
            co: "Colombia",
            cr: "Costa Rica",
            cu: "Cuba",
            cv: "Cape Verde",
            cw: "CuraÃ§ao",
            cx: "Christmas Island",
            cy: "Cyprus",
            cz: "Czechia",
            de: "Germany",
            dj: "Djibouti",
            dk: "Denmark",
            dm: "Dominica",
            do: "Dominican Republic",
            dz: "Algeria",
            ec: "Ecuador",
            ee: "Estonia",
            eg: "Egypt",
            eh: "Western Sahara",
            er: "Eritrea",
            es: "Spain",
            et: "Ethiopia",
            fi: "Finland",
            fj: "Fiji",
            fk: "Falkland Islands",
            fm: "Micronesia",
            fo: "Faroe Islands",
            fr: "France",
            ga: "Gabon",
            gb: "United Kingdom",
            gd: "Grenada",
            ge: "Georgia",
            gf: "French Guiana",
            gg: "Guernsey",
            gh: "Ghana",
            gi: "Gibraltar",
            gl: "Greenland",
            gm: "Gambia",
            gn: "Guinea",
            gp: "Guadeloupe",
            gq: "Equatorial Guinea",
            gr: "Greece",
            gt: "Guatemala",
            gu: "Guam",
            gw: "Guinea-Bissau",
            gy: "Guyana",
            hk: "Hong Kong SAR China",
            hn: "Honduras",
            hr: "Croatia",
            ht: "Haiti",
            hu: "Hungary",
            id: "Indonesia",
            ie: "Ireland",
            il: "Israel",
            im: "Isle of Man",
            in: "India",
            io: "British Indian Ocean Territory",
            iq: "Iraq",
            ir: "Iran",
            is: "Iceland",
            it: "Italy",
            je: "Jersey",
            jm: "Jamaica",
            jo: "Jordan",
            jp: "Japan",
            ke: "Kenya",
            kg: "Kyrgyzstan",
            kh: "Cambodia",
            ki: "Kiribati",
            km: "Comoros",
            kn: "St. Kitts & Nevis",
            kp: "North Korea",
            kr: "South Korea",
            kw: "Kuwait",
            ky: "Cayman Islands",
            kz: "Kazakhstan",
            la: "Laos",
            lb: "Lebanon",
            lc: "St. Lucia",
            li: "Liechtenstein",
            lk: "Sri Lanka",
            lr: "Liberia",
            ls: "Lesotho",
            lt: "Lithuania",
            lu: "Luxembourg",
            lv: "Latvia",
            ly: "Libya",
            ma: "Morocco",
            mc: "Monaco",
            md: "Moldova",
            me: "Montenegro",
            mf: "St. Martin",
            mg: "Madagascar",
            mh: "Marshall Islands",
            mk: "North Macedonia",
            ml: "Mali",
            mm: "Myanmar (Burma)",
            mn: "Mongolia",
            mo: "Macao SAR China",
            mp: "Northern Mariana Islands",
            mq: "Martinique",
            mr: "Mauritania",
            ms: "Montserrat",
            mt: "Malta",
            mu: "Mauritius",
            mv: "Maldives",
            mw: "Malawi",
            mx: "Mexico",
            my: "Malaysia",
            mz: "Mozambique",
            na: "Namibia",
            nc: "New Caledonia",
            ne: "Niger",
            nf: "Norfolk Island",
            ng: "Nigeria",
            ni: "Nicaragua",
            nl: "Netherlands",
            no: "Norway",
            np: "Nepal",
            nr: "Nauru",
            nu: "Niue",
            nz: "New Zealand",
            om: "Oman",
            pa: "Panama",
            pe: "Peru",
            pf: "French Polynesia",
            pg: "Papua New Guinea",
            ph: "Philippines",
            pk: "Pakistan",
            pl: "Poland",
            pm: "St. Pierre & Miquelon",
            pr: "Puerto Rico",
            ps: "Palestinian Territories",
            pt: "Portugal",
            pw: "Palau",
            py: "Paraguay",
            qa: "Qatar",
            re: "RÃ©union",
            ro: "Romania",
            rs: "Serbia",
            ru: "Russia",
            rw: "Rwanda",
            sa: "Saudi Arabia",
            sb: "Solomon Islands",
            sc: "Seychelles",
            sd: "Sudan",
            se: "Sweden",
            sg: "Singapore",
            sh: "St. Helena",
            si: "Slovenia",
            sj: "Svalbard & Jan Mayen",
            sk: "Slovakia",
            sl: "Sierra Leone",
            sm: "San Marino",
            sn: "Senegal",
            so: "Somalia",
            sr: "Suriname",
            ss: "South Sudan",
            st: "SÃ£o TomÃ© & PrÃ­ncipe",
            sv: "El Salvador",
            sx: "Sint Maarten",
            sy: "Syria",
            sz: "Eswatini",
            tc: "Turks & Caicos Islands",
            td: "Chad",
            tg: "Togo",
            th: "Thailand",
            tj: "Tajikistan",
            tk: "Tokelau",
            tl: "Timor-Leste",
            tm: "Turkmenistan",
            tn: "Tunisia",
            to: "Tonga",
            tr: "Turkey",
            tt: "Trinidad & Tobago",
            tv: "Tuvalu",
            tw: "Taiwan",
            tz: "Tanzania",
            ua: "Ukraine",
            ug: "Uganda",
            us: "United States",
            uy: "Uruguay",
            uz: "Uzbekistan",
            va: "Vatican City",
            vc: "St. Vincent & Grenadines",
            ve: "Venezuela",
            vg: "British Virgin Islands",
            vi: "U.S. Virgin Islands",
            vn: "Vietnam",
            vu: "Vanuatu",
            wf: "Wallis & Futuna",
            ws: "Samoa",
            ye: "Yemen",
            yt: "Mayotte",
            za: "South Africa",
            zm: "Zambia",
            zw: "Zimbabwe"
          },
          Ie = K,
          Ce = {
            selectedCountryAriaLabel: "Selected country",
            noCountrySelected: "No country selected",
            countryListAriaLabel: "List of countries",
            searchPlaceholder: "Search",
            zeroSearchResults: "No results found",
            oneSearchResult: "1 result found",
            multipleSearchResults: "${count} results found",
            ac: "Ascension Island",
            xk: "Kosovo"
          },
          De = Ce,
          Be = {
            ...Ie,
            ...De
          },
          je = Be;
        for (let ee = 0; ee < xe.length; ee++) xe[ee].name = je[xe[ee].iso2];
        var Le = 0,
          Fe = {
            allowDropdown: !0,
            autoPlaceholder: "polite",
            containerClass: "",
            countryOrder: null,
            countrySearch: !0,
            customPlaceholder: null,
            dropdownContainer: null,
            excludeCountries: [],
            fixDropdownWidth: !0,
            formatAsYouType: !0,
            formatOnDisplay: !0,
            geoIpLookup: null,
            hiddenInput: null,
            i18n: {},
            initialCountry: "",
            loadUtils: null,
            nationalMode: !0,
            onlyCountries: [],
            placeholderNumberType: "MOBILE",
            showFlags: !0,
            separateDialCode: !1,
            strictMode: !1,
            useFullscreenPopup: typeof navigator < "u" && typeof window < "u" ? /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 500 : !1,
            validationNumberTypes: ["MOBILE"]
          },
          mt = ["800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889"],
          ut = ee => ee.replace(/\D/g, ""),
          Ke = (ee = "") => ee.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase(),
          ct = ee => {
            const te = ut(ee);
            if (te.charAt(0) === "1") {
              const fe = te.substr(1, 3);
              return mt.includes(fe)
            }
            return !1
          },
          tt = (ee, te, fe, ie) => {
            if (fe === 0 && !ie) return 0;
            let Se = 0;
            for (let Me = 0; Me < te.length; Me++) {
              if (/[+0-9]/.test(te[Me]) && Se++, Se === ee && !ie) return Me + 1;
              if (ie && Se === ee + 1) return Me
            }
            return te.length
          },
          Re = (ee, te, fe) => {
            const ie = document.createElement(ee);
            return te && Object.entries(te).forEach(([Se, Me]) => ie.setAttribute(Se, Me)), fe && fe.appendChild(ie), ie
          },
          ot = (ee, ...te) => {
            const {
              instances: fe
            } = Ae;
            Object.values(fe).forEach(ie => ie[ee](...te))
          },
          rt = class {
            constructor(ee, te = {}) {
              this.id = Le++, this.telInput = ee, this.highlightedItem = null, this.options = Object.assign({}, Fe, te), this.hadInitialPlaceholder = !!ee.getAttribute("placeholder")
            }
            _init() {
              this.options.useFullscreenPopup && (this.options.fixDropdownWidth = !1), this.options.onlyCountries.length === 1 && (this.options.initialCountry = this.options.onlyCountries[0]), this.options.separateDialCode && (this.options.nationalMode = !1), this.options.allowDropdown && !this.options.showFlags && !this.options.separateDialCode && (this.options.nationalMode = !1), this.options.useFullscreenPopup && !this.options.dropdownContainer && (this.options.dropdownContainer = document.body), this.isAndroid = typeof navigator < "u" ? /Android/i.test(navigator.userAgent) : !1, this.isRTL = !!this.telInput.closest("[dir=rtl]");
              const ee = this.options.allowDropdown || this.options.separateDialCode;
              this.showSelectedCountryOnLeft = this.isRTL ? !ee : ee, this.options.separateDialCode && (this.isRTL ? this.originalPaddingRight = this.telInput.style.paddingRight : this.originalPaddingLeft = this.telInput.style.paddingLeft), this.options.i18n = {
                ...je,
                ...this.options.i18n
              };
              const te = new Promise((ie, Se) => {
                  this.resolveAutoCountryPromise = ie, this.rejectAutoCountryPromise = Se
                }),
                fe = new Promise((ie, Se) => {
                  this.resolveUtilsScriptPromise = ie, this.rejectUtilsScriptPromise = Se
                });
              this.promise = Promise.all([te, fe]), this.selectedCountryData = {}, this._processCountryData(), this._generateMarkup(), this._setInitialState(), this._initListeners(), this._initRequests()
            }
            _processCountryData() {
              this._processAllCountries(), this._processDialCodes(), this._translateCountryNames(), this._sortCountries()
            }
            _sortCountries() {
              this.options.countryOrder && (this.options.countryOrder = this.options.countryOrder.map(ee => ee.toLowerCase())), this.countries.sort((ee, te) => {
                const {
                  countryOrder: fe
                } = this.options;
                if (fe) {
                  const ie = fe.indexOf(ee.iso2),
                    Se = fe.indexOf(te.iso2),
                    Me = ie > -1,
                    nt = Se > -1;
                  if (Me || nt) return Me && nt ? ie - Se : Me ? -1 : 1
                }
                return ee.name.localeCompare(te.name)
              })
            }
            _addToDialCodeMap(ee, te, fe) {
              te.length > this.dialCodeMaxLen && (this.dialCodeMaxLen = te.length), this.dialCodeToIso2Map.hasOwnProperty(te) || (this.dialCodeToIso2Map[te] = []);
              for (let Se = 0; Se < this.dialCodeToIso2Map[te].length; Se++)
                if (this.dialCodeToIso2Map[te][Se] === ee) return;
              const ie = fe !== void 0 ? fe : this.dialCodeToIso2Map[te].length;
              this.dialCodeToIso2Map[te][ie] = ee
            }
            _processAllCountries() {
              const {
                onlyCountries: ee,
                excludeCountries: te
              } = this.options;
              if (ee.length) {
                const fe = ee.map(ie => ie.toLowerCase());
                this.countries = xe.filter(ie => fe.includes(ie.iso2))
              } else if (te.length) {
                const fe = te.map(ie => ie.toLowerCase());
                this.countries = xe.filter(ie => !fe.includes(ie.iso2))
              } else this.countries = xe
            }
            _translateCountryNames() {
              for (let ee = 0; ee < this.countries.length; ee++) {
                const te = this.countries[ee].iso2.toLowerCase();
                this.options.i18n.hasOwnProperty(te) && (this.countries[ee].name = this.options.i18n[te])
              }
            }
            _processDialCodes() {
              this.dialCodes = {}, this.dialCodeMaxLen = 0, this.dialCodeToIso2Map = {};
              for (let ee = 0; ee < this.countries.length; ee++) {
                const te = this.countries[ee];
                this.dialCodes[te.dialCode] || (this.dialCodes[te.dialCode] = !0), this._addToDialCodeMap(te.iso2, te.dialCode, te.priority)
              }
              for (let ee = 0; ee < this.countries.length; ee++) {
                const te = this.countries[ee];
                if (te.areaCodes) {
                  const fe = this.dialCodeToIso2Map[te.dialCode][0];
                  for (let ie = 0; ie < te.areaCodes.length; ie++) {
                    const Se = te.areaCodes[ie];
                    for (let Me = 1; Me < Se.length; Me++) {
                      const nt = Se.substr(0, Me),
                        Ye = te.dialCode + nt;
                      this._addToDialCodeMap(fe, Ye), this._addToDialCodeMap(te.iso2, Ye)
                    }
                    this._addToDialCodeMap(te.iso2, te.dialCode + Se)
                  }
                }
              }
            }
            _generateMarkup() {
              var Tt, Ct, yt;
              this.telInput.classList.add("iti__tel-input"), !this.telInput.hasAttribute("autocomplete") && !(this.telInput.form && this.telInput.form.hasAttribute("autocomplete")) && this.telInput.setAttribute("autocomplete", "off");
              const {
                allowDropdown: ee,
                separateDialCode: te,
                showFlags: fe,
                containerClass: ie,
                hiddenInput: Se,
                dropdownContainer: Me,
                fixDropdownWidth: nt,
                useFullscreenPopup: Ye,
                countrySearch: wt,
                i18n: zt
              } = this.options;
              let Nt = "iti";
              ee && (Nt += " iti--allow-dropdown"), fe && (Nt += " iti--show-flags"), ie && (Nt += ` ${ie}`), Ye || (Nt += " iti--inline-dropdown");
              const st = Re("div", {
                class: Nt
              });
              if ((Tt = this.telInput.parentNode) == null || Tt.insertBefore(st, this.telInput), ee || fe || te) {
                this.countryContainer = Re("div", {
                  class: "iti__country-container"
                }, st), this.showSelectedCountryOnLeft ? this.countryContainer.style.left = "0px" : this.countryContainer.style.right = "0px", ee ? (this.selectedCountry = Re("button", {
                  type: "button",
                  class: "iti__selected-country",
                  "aria-expanded": "false",
                  "aria-label": this.options.i18n.selectedCountryAriaLabel,
                  "aria-haspopup": "true",
                  "aria-controls": `iti-${this.id}__dropdown-content`,
                  role: "combobox"
                }, this.countryContainer), this.telInput.disabled && this.selectedCountry.setAttribute("disabled", "true")) : this.selectedCountry = Re("div", {
                  class: "iti__selected-country"
                }, this.countryContainer);
                const Mt = Re("div", {
                  class: "iti__selected-country-primary"
                }, this.selectedCountry);
                if (this.selectedCountryInner = Re("div", {
                    class: "iti__flag"
                  }, Mt), this.selectedCountryA11yText = Re("span", {
                    class: "iti__a11y-text"
                  }, this.selectedCountryInner), ee && (this.dropdownArrow = Re("div", {
                    class: "iti__arrow",
                    "aria-hidden": "true"
                  }, Mt)), te && (this.selectedDialCode = Re("div", {
                    class: "iti__selected-dial-code"
                  }, this.selectedCountry)), ee) {
                  const St = nt ? "" : "iti--flexible-dropdown-width";
                  if (this.dropdownContent = Re("div", {
                      id: `iti-${this.id}__dropdown-content`,
                      class: `iti__dropdown-content iti__hide ${St}`
                    }), wt && (this.searchInput = Re("input", {
                      type: "text",
                      class: "iti__search-input",
                      placeholder: zt.searchPlaceholder,
                      role: "combobox",
                      "aria-expanded": "true",
                      "aria-label": zt.searchPlaceholder,
                      "aria-controls": `iti-${this.id}__country-listbox`,
                      "aria-autocomplete": "list",
                      autocomplete: "off"
                    }, this.dropdownContent), this.searchResultsA11yText = Re("span", {
                      class: "iti__a11y-text"
                    }, this.dropdownContent)), this.countryList = Re("ul", {
                      class: "iti__country-list",
                      id: `iti-${this.id}__country-listbox`,
                      role: "listbox",
                      "aria-label": zt.countryListAriaLabel
                    }, this.dropdownContent), this._appendListItems(), wt && this._updateSearchResultsText(), Me) {
                    let ht = "iti iti--container";
                    Ye ? ht += " iti--fullscreen-popup" : ht += " iti--inline-dropdown", this.dropdown = Re("div", {
                      class: ht
                    }), this.dropdown.appendChild(this.dropdownContent)
                  } else this.countryContainer.appendChild(this.dropdownContent)
                }
              }
              if (st.appendChild(this.telInput), this._updateInputPadding(), Se) {
                const Mt = this.telInput.getAttribute("name") || "",
                  St = Se(Mt);
                if (St.phone) {
                  const ht = (Ct = this.telInput.form) == null ? void 0 : Ct.querySelector(`input[name="${St.phone}"]`);
                  ht ? this.hiddenInput = ht : (this.hiddenInput = Re("input", {
                    type: "hidden",
                    name: St.phone
                  }), st.appendChild(this.hiddenInput))
                }
                if (St.country) {
                  const ht = (yt = this.telInput.form) == null ? void 0 : yt.querySelector(`input[name="${St.country}"]`);
                  ht ? this.hiddenInputCountry = ht : (this.hiddenInputCountry = Re("input", {
                    type: "hidden",
                    name: St.country
                  }), st.appendChild(this.hiddenInputCountry))
                }
              }
            }
            _appendListItems() {
              for (let ee = 0; ee < this.countries.length; ee++) {
                const te = this.countries[ee],
                  fe = ee === 0 ? "iti__highlight" : "",
                  ie = Re("li", {
                    id: `iti-${this.id}__item-${te.iso2}`,
                    class: `iti__country ${fe}`,
                    tabindex: "-1",
                    role: "option",
                    "data-dial-code": te.dialCode,
                    "data-country-code": te.iso2,
                    "aria-selected": "false"
                  }, this.countryList);
                te.nodeById[this.id] = ie;
                let Se = "";
                this.options.showFlags && (Se += `<div class='iti__flag iti__${te.iso2}'></div>`), Se += `<span class='iti__country-name'>${te.name}</span>`, Se += `<span class='iti__dial-code'>+${te.dialCode}</span>`, ie.insertAdjacentHTML("beforeend", Se)
              }
            }
            _setInitialState(ee = !1) {
              const te = this.telInput.getAttribute("value"),
                fe = this.telInput.value,
                Se = te && te.charAt(0) === "+" && (!fe || fe.charAt(0) !== "+") ? te : fe,
                Me = this._getDialCode(Se),
                nt = ct(Se),
                {
                  initialCountry: Ye,
                  geoIpLookup: wt
                } = this.options,
                zt = Ye === "auto" && wt;
              if (Me && !nt) this._updateCountryFromNumber(Se);
              else if (!zt || ee) {
                const Nt = Ye ? Ye.toLowerCase() : "";
                Nt && this._getCountryData(Nt, !0) ? this._setCountry(Nt) : Me && nt ? this._setCountry("us") : this._setCountry()
              }
              Se && this._updateValFromNumber(Se)
            }
            _initListeners() {
              this._initTelInputListeners(), this.options.allowDropdown && this._initDropdownListeners(), (this.hiddenInput || this.hiddenInputCountry) && this.telInput.form && this._initHiddenInputListener()
            }
            _initHiddenInputListener() {
              var ee;
              this._handleHiddenInputSubmit = () => {
                this.hiddenInput && (this.hiddenInput.value = this.getNumber()), this.hiddenInputCountry && (this.hiddenInputCountry.value = this.getSelectedCountryData().iso2 || "")
              }, (ee = this.telInput.form) == null || ee.addEventListener("submit", this._handleHiddenInputSubmit)
            }
            _initDropdownListeners() {
              this._handleLabelClick = te => {
                this.dropdownContent.classList.contains("iti__hide") ? this.telInput.focus() : te.preventDefault()
              };
              const ee = this.telInput.closest("label");
              ee && ee.addEventListener("click", this._handleLabelClick), this._handleClickSelectedCountry = () => {
                this.dropdownContent.classList.contains("iti__hide") && !this.telInput.disabled && !this.telInput.readOnly && this._openDropdown()
              }, this.selectedCountry.addEventListener("click", this._handleClickSelectedCountry), this._handleCountryContainerKeydown = te => {
                this.dropdownContent.classList.contains("iti__hide") && ["ArrowUp", "ArrowDown", " ", "Enter"].includes(te.key) && (te.preventDefault(), te.stopPropagation(), this._openDropdown()), te.key === "Tab" && this._closeDropdown()
              }, this.countryContainer.addEventListener("keydown", this._handleCountryContainerKeydown)
            }
            _initRequests() {
              let {
                loadUtils: ee,
                initialCountry: te,
                geoIpLookup: fe
              } = this.options;
              ee && !Ae.utils ? (this._handlePageLoad = () => {
                var Se;
                window.removeEventListener("load", this._handlePageLoad), (Se = Ae.attachUtils(ee)) == null || Se.catch(() => {})
              }, Ae.documentReady() ? this._handlePageLoad() : window.addEventListener("load", this._handlePageLoad)) : this.resolveUtilsScriptPromise(), te === "auto" && fe && !this.selectedCountryData.iso2 ? this._loadAutoCountry() : this.resolveAutoCountryPromise()
            }
            _loadAutoCountry() {
              Ae.autoCountry ? this.handleAutoCountry() : Ae.startedLoadingAutoCountry || (Ae.startedLoadingAutoCountry = !0, typeof this.options.geoIpLookup == "function" && this.options.geoIpLookup((ee = "") => {
                const te = ee.toLowerCase();
                te && this._getCountryData(te, !0) ? (Ae.autoCountry = te, setTimeout(() => ot("handleAutoCountry"))) : (this._setInitialState(!0), ot("rejectAutoCountryPromise"))
              }, () => {
                this._setInitialState(!0), ot("rejectAutoCountryPromise")
              }))
            }
            _openDropdownWithPlus() {
              this._openDropdown(), this.searchInput.value = "+", this._filterCountries("", !0)
            }
            _initTelInputListeners() {
              const {
                strictMode: ee,
                formatAsYouType: te,
                separateDialCode: fe,
                formatOnDisplay: ie,
                allowDropdown: Se,
                countrySearch: Me
              } = this.options;
              let nt = !1;
              new RegExp("\\p{L}", "u").test(this.telInput.value) && (nt = !0), this._handleInputEvent = Ye => {
                if (this.isAndroid && (Ye == null ? void 0 : Ye.data) === "+" && fe && Se && Me) {
                  const st = this.telInput.selectionStart || 0,
                    Tt = this.telInput.value.substring(0, st - 1),
                    Ct = this.telInput.value.substring(st);
                  this.telInput.value = Tt + Ct, this._openDropdownWithPlus();
                  return
                }
                this._updateCountryFromNumber(this.telInput.value) && this._triggerCountryChange();
                const wt = (Ye == null ? void 0 : Ye.data) && /[^+0-9]/.test(Ye.data),
                  zt = (Ye == null ? void 0 : Ye.inputType) === "insertFromPaste" && this.telInput.value;
                wt || zt && !ee ? nt = !0 : /[^+0-9]/.test(this.telInput.value) || (nt = !1);
                const Nt = (Ye == null ? void 0 : Ye.detail) && Ye.detail.isSetNumber && !ie;
                if (te && !nt && !Nt) {
                  const st = this.telInput.selectionStart || 0,
                    Ct = this.telInput.value.substring(0, st).replace(/[^+0-9]/g, "").length,
                    yt = (Ye == null ? void 0 : Ye.inputType) === "deleteContentForward",
                    Mt = this._formatNumberAsYouType(),
                    St = tt(Ct, Mt, st, yt);
                  this.telInput.value = Mt, this.telInput.setSelectionRange(St, St)
                }
              }, this.telInput.addEventListener("input", this._handleInputEvent), (ee || fe) && (this._handleKeydownEvent = Ye => {
                if (Ye.key && Ye.key.length === 1 && !Ye.altKey && !Ye.ctrlKey && !Ye.metaKey) {
                  if (fe && Se && Me && Ye.key === "+") {
                    Ye.preventDefault(), this._openDropdownWithPlus();
                    return
                  }
                  if (ee) {
                    const wt = this.telInput.value,
                      zt = wt.charAt(0) === "+",
                      Nt = !zt && this.telInput.selectionStart === 0 && Ye.key === "+",
                      st = /^[0-9]$/.test(Ye.key),
                      Tt = fe ? st : Nt || st,
                      Ct = wt.slice(0, this.telInput.selectionStart) + Ye.key + wt.slice(this.telInput.selectionEnd),
                      yt = this._getFullNumber(Ct),
                      Mt = Ae.utils.getCoreNumber(yt, this.selectedCountryData.iso2),
                      St = this.maxCoreNumberLength && Mt.length > this.maxCoreNumberLength;
                    let ht = !1;
                    if (zt) {
                      const Lt = this.selectedCountryData.iso2;
                      ht = this._getCountryFromNumber(yt) !== Lt
                    }(!Tt || St && !ht && !Nt) && Ye.preventDefault()
                  }
                }
              }, this.telInput.addEventListener("keydown", this._handleKeydownEvent))
            }
            _cap(ee) {
              const te = parseInt(this.telInput.getAttribute("maxlength") || "", 10);
              return te && ee.length > te ? ee.substr(0, te) : ee
            }
            _trigger(ee, te = {}) {
              const fe = new CustomEvent(ee, {
                bubbles: !0,
                cancelable: !0,
                detail: te
              });
              this.telInput.dispatchEvent(fe)
            }
            _openDropdown() {
              const {
                fixDropdownWidth: ee,
                countrySearch: te
              } = this.options;
              if (ee && (this.dropdownContent.style.width = `${this.telInput.offsetWidth}px`), this.dropdownContent.classList.remove("iti__hide"), this.selectedCountry.setAttribute("aria-expanded", "true"), this._setDropdownPosition(), te) {
                const fe = this.countryList.firstElementChild;
                fe && (this._highlightListItem(fe, !1), this.countryList.scrollTop = 0), this.searchInput.focus()
              }
              this._bindDropdownListeners(), this.dropdownArrow.classList.add("iti__arrow--up"), this._trigger("open:countrydropdown")
            }
            _setDropdownPosition() {
              if (this.options.dropdownContainer && this.options.dropdownContainer.appendChild(this.dropdown), !this.options.useFullscreenPopup) {
                const ee = this.telInput.getBoundingClientRect(),
                  te = this.telInput.offsetHeight;
                this.options.dropdownContainer && (this.dropdown.style.top = `${ee.top+te}px`, this.dropdown.style.left = `${ee.left}px`, this._handleWindowScroll = () => this._closeDropdown(), window.addEventListener("scroll", this._handleWindowScroll))
              }
            }
            _bindDropdownListeners() {
              this._handleMouseoverCountryList = ie => {
                var Me;
                const Se = (Me = ie.target) == null ? void 0 : Me.closest(".iti__country");
                Se && this._highlightListItem(Se, !1)
              }, this.countryList.addEventListener("mouseover", this._handleMouseoverCountryList), this._handleClickCountryList = ie => {
                var Me;
                const Se = (Me = ie.target) == null ? void 0 : Me.closest(".iti__country");
                Se && this._selectListItem(Se)
              }, this.countryList.addEventListener("click", this._handleClickCountryList);
              let ee = !0;
              this._handleClickOffToClose = () => {
                ee || this._closeDropdown(), ee = !1
              }, document.documentElement.addEventListener("click", this._handleClickOffToClose);
              let te = "",
                fe = null;
              if (this._handleKeydownOnDropdown = ie => {
                  ["ArrowUp", "ArrowDown", "Enter", "Escape"].includes(ie.key) && (ie.preventDefault(), ie.stopPropagation(), ie.key === "ArrowUp" || ie.key === "ArrowDown" ? this._handleUpDownKey(ie.key) : ie.key === "Enter" ? this._handleEnterKey() : ie.key === "Escape" && this._closeDropdown()), !this.options.countrySearch && /^[a-zA-ZÃ€-Ã¿Ð°-ÑÐ-Ð¯ ]$/.test(ie.key) && (ie.stopPropagation(), fe && clearTimeout(fe), te += ie.key.toLowerCase(), this._searchForCountry(te), fe = setTimeout(() => {
                    te = ""
                  }, 1e3))
                }, document.addEventListener("keydown", this._handleKeydownOnDropdown), this.options.countrySearch) {
                const ie = () => {
                  const Me = this.searchInput.value.trim();
                  Me ? this._filterCountries(Me) : this._filterCountries("", !0)
                };
                let Se = null;
                this._handleSearchChange = () => {
                  Se && clearTimeout(Se), Se = setTimeout(() => {
                    ie(), Se = null
                  }, 100)
                }, this.searchInput.addEventListener("input", this._handleSearchChange), this.searchInput.addEventListener("click", Me => Me.stopPropagation())
              }
            }
            _searchForCountry(ee) {
              for (let te = 0; te < this.countries.length; te++) {
                const fe = this.countries[te];
                if (fe.name.substr(0, ee.length).toLowerCase() === ee) {
                  const Se = fe.nodeById[this.id];
                  this._highlightListItem(Se, !1), this._scrollTo(Se);
                  break
                }
              }
            }
            _filterCountries(ee, te = !1) {
              let fe = !0;
              this.countryList.innerHTML = "";
              const ie = Ke(ee);
              for (let Se = 0; Se < this.countries.length; Se++) {
                const Me = this.countries[Se],
                  nt = Ke(Me.name),
                  Ye = Me.name.split(/[^a-zA-ZÃ€-Ã¿Ð°-ÑÐ-Ð¯]/).map(zt => zt[0]).join("").toLowerCase(),
                  wt = `+${Me.dialCode}`;
                if (te || nt.includes(ie) || wt.includes(ie) || Me.iso2.includes(ie) || Ye.includes(ie)) {
                  const zt = Me.nodeById[this.id];
                  zt && this.countryList.appendChild(zt), fe && (this._highlightListItem(zt, !1), fe = !1)
                }
              }
              fe && this._highlightListItem(null, !1), this.countryList.scrollTop = 0, this._updateSearchResultsText()
            }
            _updateSearchResultsText() {
              const {
                i18n: ee
              } = this.options, te = this.countryList.childElementCount;
              let fe;
              te === 0 ? fe = ee.zeroSearchResults : te === 1 ? fe = ee.oneSearchResult : fe = ee.multipleSearchResults.replace("${count}", te.toString()), this.searchResultsA11yText.textContent = fe
            }
            _handleUpDownKey(ee) {
              var fe, ie;
              let te = ee === "ArrowUp" ? (fe = this.highlightedItem) == null ? void 0 : fe.previousElementSibling : (ie = this.highlightedItem) == null ? void 0 : ie.nextElementSibling;
              !te && this.countryList.childElementCount > 1 && (te = ee === "ArrowUp" ? this.countryList.lastElementChild : this.countryList.firstElementChild), te && (this._scrollTo(te), this._highlightListItem(te, !1))
            }
            _handleEnterKey() {
              this.highlightedItem && this._selectListItem(this.highlightedItem)
            }
            _updateValFromNumber(ee) {
              let te = ee;
              if (this.options.formatOnDisplay && Ae.utils && this.selectedCountryData) {
                const fe = this.options.nationalMode || te.charAt(0) !== "+" && !this.options.separateDialCode,
                  {
                    NATIONAL: ie,
                    INTERNATIONAL: Se
                  } = Ae.utils.numberFormat,
                  Me = fe ? ie : Se;
                te = Ae.utils.formatNumber(te, this.selectedCountryData.iso2, Me)
              }
              te = this._beforeSetNumber(te), this.telInput.value = te
            }
            _updateCountryFromNumber(ee) {
              const te = this._getCountryFromNumber(ee);
              return te !== null ? this._setCountry(te) : !1
            }
            _ensureHasDialCode(ee) {
              const {
                dialCode: te,
                nationalPrefix: fe
              } = this.selectedCountryData;
              if (ee.charAt(0) === "+" || !te) return ee;
              const Me = fe && ee.charAt(0) === fe && !this.options.separateDialCode ? ee.substring(1) : ee;
              return `+${te}${Me}`
            }
            _getCountryFromNumber(ee) {
              const te = ee.indexOf("+");
              let fe = te ? ee.substring(te) : ee;
              const ie = this.selectedCountryData.iso2,
                Se = this.selectedCountryData.dialCode;
              fe = this._ensureHasDialCode(fe);
              const Me = this._getDialCode(fe, !0),
                nt = ut(fe);
              if (Me) {
                const Ye = ut(Me),
                  wt = this.dialCodeToIso2Map[Ye];
                if (!ie && this.defaultCountry && wt.includes(this.defaultCountry)) return this.defaultCountry;
                const zt = ie && wt.includes(ie) && (nt.length === Ye.length || !this.selectedCountryData.areaCodes);
                if (!(Se === "1" && ct(nt)) && !zt) {
                  for (let st = 0; st < wt.length; st++)
                    if (wt[st]) return wt[st]
                }
              } else {
                if (fe.charAt(0) === "+" && nt.length) return "";
                if ((!fe || fe === "+") && !this.selectedCountryData.iso2) return this.defaultCountry
              }
              return null
            }
            _highlightListItem(ee, te) {
              const fe = this.highlightedItem;
              if (fe && (fe.classList.remove("iti__highlight"), fe.setAttribute("aria-selected", "false")), this.highlightedItem = ee, this.highlightedItem) {
                this.highlightedItem.classList.add("iti__highlight"), this.highlightedItem.setAttribute("aria-selected", "true");
                const ie = this.highlightedItem.getAttribute("id") || "";
                this.selectedCountry.setAttribute("aria-activedescendant", ie), this.options.countrySearch && this.searchInput.setAttribute("aria-activedescendant", ie)
              }
              te && this.highlightedItem.focus()
            }
            _getCountryData(ee, te) {
              for (let fe = 0; fe < this.countries.length; fe++)
                if (this.countries[fe].iso2 === ee) return this.countries[fe];
              if (te) return null;
              throw new Error(`No country data for '${ee}'`)
            }
            _setCountry(ee) {
              const {
                separateDialCode: te,
                showFlags: fe,
                i18n: ie
              } = this.options, Se = this.selectedCountryData.iso2 ? this.selectedCountryData : {};
              if (this.selectedCountryData = ee ? this._getCountryData(ee, !1) || {} : {}, this.selectedCountryData.iso2 && (this.defaultCountry = this.selectedCountryData.iso2), this.selectedCountryInner) {
                let Me = "",
                  nt = "";
                ee && fe ? (Me = `iti__flag iti__${ee}`, nt = `${this.selectedCountryData.name} +${this.selectedCountryData.dialCode}`) : (Me = "iti__flag iti__globe", nt = ie.noCountrySelected), this.selectedCountryInner.className = Me, this.selectedCountryA11yText.textContent = nt
              }
              if (this._setSelectedCountryTitleAttribute(ee, te), te) {
                const Me = this.selectedCountryData.dialCode ? `+${this.selectedCountryData.dialCode}` : "";
                this.selectedDialCode.innerHTML = Me, this._updateInputPadding()
              }
              return this._updatePlaceholder(), this._updateMaxLength(), Se.iso2 !== ee
            }
            _updateInputPadding() {
              if (this.selectedCountry) {
                const te = (this.selectedCountry.offsetWidth || this._getHiddenSelectedCountryWidth()) + 6;
                this.showSelectedCountryOnLeft ? this.telInput.style.paddingLeft = `${te}px` : this.telInput.style.paddingRight = `${te}px`
              }
            }
            _updateMaxLength() {
              const {
                strictMode: ee,
                placeholderNumberType: te,
                validationNumberTypes: fe
              } = this.options, {
                iso2: ie
              } = this.selectedCountryData;
              if (ee && Ae.utils)
                if (ie) {
                  const Se = Ae.utils.numberType[te];
                  let Me = Ae.utils.getExampleNumber(ie, !1, Se, !0),
                    nt = Me;
                  for (; Ae.utils.isPossibleNumber(Me, ie, fe);) nt = Me, Me += "0";
                  const Ye = Ae.utils.getCoreNumber(nt, ie);
                  this.maxCoreNumberLength = Ye.length, ie === "by" && (this.maxCoreNumberLength = Ye.length + 1)
                } else this.maxCoreNumberLength = null
            }
            _setSelectedCountryTitleAttribute(ee = null, te) {
              if (!this.selectedCountry) return;
              let fe;
              ee && !te ? fe = `${this.selectedCountryData.name}: +${this.selectedCountryData.dialCode}` : ee ? fe = this.selectedCountryData.name : fe = "Unknown", this.selectedCountry.setAttribute("title", fe)
            }
            _getHiddenSelectedCountryWidth() {
              if (this.telInput.parentNode) {
                const ee = this.telInput.parentNode.cloneNode(!1);
                ee.style.visibility = "hidden", document.body.appendChild(ee);
                const te = this.countryContainer.cloneNode();
                ee.appendChild(te);
                const fe = this.selectedCountry.cloneNode(!0);
                te.appendChild(fe);
                const ie = fe.offsetWidth;
                return document.body.removeChild(ee), ie
              }
              return 0
            }
            _updatePlaceholder() {
              const {
                autoPlaceholder: ee,
                placeholderNumberType: te,
                nationalMode: fe,
                customPlaceholder: ie
              } = this.options, Se = ee === "aggressive" || !this.hadInitialPlaceholder && ee === "polite";
              if (Ae.utils && Se) {
                const Me = Ae.utils.numberType[te];
                let nt = this.selectedCountryData.iso2 ? Ae.utils.getExampleNumber(this.selectedCountryData.iso2, fe, Me) : "";
                nt = this._beforeSetNumber(nt), typeof ie == "function" && (nt = ie(nt, this.selectedCountryData)), this.telInput.setAttribute("placeholder", nt)
              }
            }
            _selectListItem(ee) {
              const te = this._setCountry(ee.getAttribute("data-country-code"));
              this._closeDropdown(), this._updateDialCode(ee.getAttribute("data-dial-code")), this.telInput.focus(), te && this._triggerCountryChange()
            }
            _closeDropdown() {
              this.dropdownContent.classList.add("iti__hide"), this.selectedCountry.setAttribute("aria-expanded", "false"), this.selectedCountry.removeAttribute("aria-activedescendant"), this.highlightedItem && this.highlightedItem.setAttribute("aria-selected", "false"), this.options.countrySearch && this.searchInput.removeAttribute("aria-activedescendant"), this.dropdownArrow.classList.remove("iti__arrow--up"), document.removeEventListener("keydown", this._handleKeydownOnDropdown), this.options.countrySearch && this.searchInput.removeEventListener("input", this._handleSearchChange), document.documentElement.removeEventListener("click", this._handleClickOffToClose), this.countryList.removeEventListener("mouseover", this._handleMouseoverCountryList), this.countryList.removeEventListener("click", this._handleClickCountryList), this.options.dropdownContainer && (this.options.useFullscreenPopup || window.removeEventListener("scroll", this._handleWindowScroll), this.dropdown.parentNode && this.dropdown.parentNode.removeChild(this.dropdown)), this._handlePageLoad && window.removeEventListener("load", this._handlePageLoad), this._trigger("close:countrydropdown")
            }
            _scrollTo(ee) {
              const te = this.countryList,
                fe = document.documentElement.scrollTop,
                ie = te.offsetHeight,
                Se = te.getBoundingClientRect().top + fe,
                Me = Se + ie,
                nt = ee.offsetHeight,
                Ye = ee.getBoundingClientRect().top + fe,
                wt = Ye + nt,
                zt = Ye - Se + te.scrollTop;
              if (Ye < Se) te.scrollTop = zt;
              else if (wt > Me) {
                const Nt = ie - nt;
                te.scrollTop = zt - Nt
              }
            }
            _updateDialCode(ee) {
              const te = this.telInput.value,
                fe = `+${ee}`;
              let ie;
              if (te.charAt(0) === "+") {
                const Se = this._getDialCode(te);
                Se ? ie = te.replace(Se, fe) : ie = fe, this.telInput.value = ie
              }
            }
            _getDialCode(ee, te) {
              let fe = "";
              if (ee.charAt(0) === "+") {
                let ie = "";
                for (let Se = 0; Se < ee.length; Se++) {
                  const Me = ee.charAt(Se);
                  if (!isNaN(parseInt(Me, 10))) {
                    if (ie += Me, te) this.dialCodeToIso2Map[ie] && (fe = ee.substr(0, Se + 1));
                    else if (this.dialCodes[ie]) {
                      fe = ee.substr(0, Se + 1);
                      break
                    }
                    if (ie.length === this.dialCodeMaxLen) break
                  }
                }
              }
              return fe
            }
            _getFullNumber(ee) {
              const te = ee || this.telInput.value.trim(),
                {
                  dialCode: fe
                } = this.selectedCountryData;
              let ie;
              const Se = ut(te);
              return this.options.separateDialCode && te.charAt(0) !== "+" && fe && Se ? ie = `+${fe}` : ie = "", ie + te
            }
            _beforeSetNumber(ee) {
              let te = ee;
              if (this.options.separateDialCode) {
                let fe = this._getDialCode(te);
                if (fe) {
                  fe = `+${this.selectedCountryData.dialCode}`;
                  const ie = te[fe.length] === " " || te[fe.length] === "-" ? fe.length + 1 : fe.length;
                  te = te.substr(ie)
                }
              }
              return this._cap(te)
            }
            _triggerCountryChange() {
              this._trigger("countrychange")
            }
            _formatNumberAsYouType() {
              const ee = this._getFullNumber(),
                te = Ae.utils ? Ae.utils.formatNumberAsYouType(ee, this.selectedCountryData.iso2) : ee,
                {
                  dialCode: fe
                } = this.selectedCountryData;
              return this.options.separateDialCode && this.telInput.value.charAt(0) !== "+" && te.includes(`+${fe}`) ? (te.split(`+${fe}`)[1] || "").trim() : te
            }
            handleAutoCountry() {
              this.options.initialCountry === "auto" && Ae.autoCountry && (this.defaultCountry = Ae.autoCountry, this.selectedCountryData.iso2 || this.selectedCountryInner.classList.contains("iti__globe") || this.setCountry(this.defaultCountry), this.resolveAutoCountryPromise())
            }
            handleUtils() {
              Ae.utils && (this.telInput.value && this._updateValFromNumber(this.telInput.value), this.selectedCountryData.iso2 && (this._updatePlaceholder(), this._updateMaxLength())), this.resolveUtilsScriptPromise()
            }
            destroy() {
              var Se, Me;
              const {
                allowDropdown: ee,
                separateDialCode: te
              } = this.options;
              if (ee) {
                this._closeDropdown(), this.selectedCountry.removeEventListener("click", this._handleClickSelectedCountry), this.countryContainer.removeEventListener("keydown", this._handleCountryContainerKeydown);
                const nt = this.telInput.closest("label");
                nt && nt.removeEventListener("click", this._handleLabelClick)
              }
              const {
                form: fe
              } = this.telInput;
              this._handleHiddenInputSubmit && fe && fe.removeEventListener("submit", this._handleHiddenInputSubmit), this.telInput.removeEventListener("input", this._handleInputEvent), this._handleKeydownEvent && this.telInput.removeEventListener("keydown", this._handleKeydownEvent), this.telInput.removeAttribute("data-intl-tel-input-id"), te && (this.isRTL ? this.telInput.style.paddingRight = this.originalPaddingRight : this.telInput.style.paddingLeft = this.originalPaddingLeft);
              const ie = this.telInput.parentNode;
              (Se = ie == null ? void 0 : ie.parentNode) == null || Se.insertBefore(this.telInput, ie), (Me = ie == null ? void 0 : ie.parentNode) == null || Me.removeChild(ie), delete Ae.instances[this.id]
            }
            getExtension() {
              return Ae.utils ? Ae.utils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2) : ""
            }
            getNumber(ee) {
              if (Ae.utils) {
                const {
                  iso2: te
                } = this.selectedCountryData;
                return Ae.utils.formatNumber(this._getFullNumber(), te, ee)
              }
              return ""
            }
            getNumberType() {
              return Ae.utils ? Ae.utils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2) : -99
            }
            getSelectedCountryData() {
              return this.selectedCountryData
            }
            getValidationError() {
              if (Ae.utils) {
                const {
                  iso2: ee
                } = this.selectedCountryData;
                return Ae.utils.getValidationError(this._getFullNumber(), ee)
              }
              return -99
            }
            isValidNumber() {
              if (!this.selectedCountryData.iso2) return !1;
              const ee = this._getFullNumber(),
                te = ee.search(new RegExp("\\p{L}", "u"));
              if (te > -1) {
                const fe = ee.substring(0, te),
                  ie = this._utilsIsPossibleNumber(fe),
                  Se = this._utilsIsPossibleNumber(ee);
                return ie && Se
              }
              return this._utilsIsPossibleNumber(ee)
            }
            _utilsIsPossibleNumber(ee) {
              return Ae.utils ? Ae.utils.isPossibleNumber(ee, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
            }
            isValidNumberPrecise() {
              if (!this.selectedCountryData.iso2) return !1;
              const ee = this._getFullNumber(),
                te = ee.search(new RegExp("\\p{L}", "u"));
              if (te > -1) {
                const fe = ee.substring(0, te),
                  ie = this._utilsIsValidNumber(fe),
                  Se = this._utilsIsValidNumber(ee);
                return ie && Se
              }
              return this._utilsIsValidNumber(ee)
            }
            _utilsIsValidNumber(ee) {
              return Ae.utils ? Ae.utils.isValidNumber(ee, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
            }
            setCountry(ee) {
              const te = ee == null ? void 0 : ee.toLowerCase(),
                fe = this.selectedCountryData.iso2;
              (ee && te !== fe || !ee && fe) && (this._setCountry(te), this._updateDialCode(this.selectedCountryData.dialCode), this._triggerCountryChange())
            }
            setNumber(ee) {
              const te = this._updateCountryFromNumber(ee);
              this._updateValFromNumber(ee), te && this._triggerCountryChange(), this._trigger("input", {
                isSetNumber: !0
              })
            }
            setPlaceholderNumberType(ee) {
              this.options.placeholderNumberType = ee, this._updatePlaceholder()
            }
            setDisabled(ee) {
              this.telInput.disabled = ee, ee ? this.selectedCountry.setAttribute("disabled", "true") : this.selectedCountry.removeAttribute("disabled")
            }
          },
          Qe = ee => {
            if (!Ae.utils && !Ae.startedLoadingUtilsScript) {
              let te;
              if (typeof ee == "function") try {
                te = Promise.resolve(ee())
              } catch (fe) {
                return Promise.reject(fe)
              } else return Promise.reject(new TypeError(`The argument passed to attachUtils must be a function that returns a promise for the utilities module, not ${typeof ee}`));
              return Ae.startedLoadingUtilsScript = !0, te.then(fe => {
                const ie = fe == null ? void 0 : fe.default;
                if (!ie || typeof ie != "object") throw new TypeError("The loader function passed to attachUtils did not resolve to a module object with utils as its default export.");
                return Ae.utils = ie, ot("handleUtils"), !0
              }).catch(fe => {
                throw ot("rejectUtilsScriptPromise", fe), fe
              })
            }
            return null
          },
          Ae = Object.assign((ee, te) => {
            const fe = new rt(ee, te);
            return fe._init(), ee.setAttribute("data-intl-tel-input-id", fe.id.toString()), Ae.instances[fe.id] = fe, fe
          }, {
            defaults: Fe,
            documentReady: () => document.readyState === "complete",
            getCountryData: () => xe,
            getInstance: ee => {
              const te = ee.getAttribute("data-intl-tel-input-id");
              return te ? Ae.instances[te] : null
            },
            instances: {},
            attachUtils: Qe,
            startedLoadingUtilsScript: !1,
            startedLoadingAutoCountry: !1,
            version: "25.3.2"
          }),
          gt = Ae;
        return G(W)
      })();
      return l.default
    })
  })(df)), df.exports
}
var ck = lk();
const uk = im(ck);
var hk = Pe('<div><span class="loading loading-spinner loading-xl"></span></div>'),
  dk = Pe('<span class="w-8"> </span>'),
  pk = Pe('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="text-base-content/80 mt-0.5 text-sm"> </p></div> <form class="mt-8 flex w-full flex-col gap-3"><input class="input pl-12! w-full" type="tel" id="phone"/> <button class="btn btn-primary w-full"> <!></button></form>', 1),
  fk = async (w, l, g) => {
    await l(x(g))
  }, mk = Pe('<span class="w-8"> </span>'), _k = (w, l) => {
    le(l, "")
  }, gk = Pe('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="mt-0.5 text-sm"> </p></div> <div class="mt-4"><!></div> <div class="mt-3 flex flex-col items-center gap-1"><button class="btn btn-ghost w-max"> <!></button> <button class="text-primary cursor-pointer text-xs"> </button></div>', 1), vk = Pe('<div class="flex h-full w-full flex-col items-center justify-center"><!></div>');

function yk(w, l) {
  Dr(l, !0);
  let g = at(!0),
    C = at(""),
    D = at(0),
    N = at(!1);
  const T = lt(() => x(D) > 0 || x(N));
  let o = at(!1),
    G = at(""),
    W = at(void 0);
  const ae = lt(() => {
    var De;
    return `phone:${(De=Et.data)==null?void 0:De.id}`
  });
  Hr(() => {
    const De = localStorage.getItem(x(ae));
    De && le(C, De, !0)
  }), zi(() => {
    ni.getOtpCooldown().then(je => {
      le(D, je.cooldownMs, !0)
    }).catch(je => {
      $r.error(je.message)
    }).finally(() => {
      le(g, !1)
    });
    const De = 1e3,
      Be = setInterval(() => {
        le(D, Math.max(0, x(D) - De), !0)
      }, De);
    return () => {
      clearInterval(Be)
    }
  });
  async function _e(De) {
    try {
      le(N, !0);
      const Be = await ni.sendOtp(De);
      $r.info(`${j3()} ${Be.phone}`), le(C, Be.phone, !0), le(D, Be.cooldownMs, !0), localStorage.setItem(x(ae), x(C))
    } catch (Be) {
      $r.error(Be.message)
    } finally {
      le(N, !1)
    }
  }
  Hr(() => {
    x(G).length === 6 && (le(o, !0), (async () => {
      try {
        await ni.verifyOtp(x(G)), await Et.refresh(), $r.success(U3()), localStorage.removeItem(x(ae)), l.onsuccess(x(C))
      } catch (De) {
        $r.error(De.message)
      } finally {
        le(G, ""), le(o, !1)
      }
    })())
  });
  var xe = vk(),
    K = k(xe);
  {
    var Ie = De => {
        var Be = hk();
        H(De, Be)
      },
      Ce = De => {
        var Be = Kt(),
          je = It(Be);
        {
          var Le = mt => {
              var ut = pk(),
                Ke = It(ut),
                ct = k(Ke),
                tt = k(ct, !0);
              A(ct);
              var Re = V(ct, 2),
                ot = k(Re, !0);
              A(Re), A(Ke);
              var rt = V(Ke, 2),
                Qe = k(rt);
              Gn(Qe, () => fe => (le(W, uk(fe, {
                strictMode: !0,
                initialCountry: "br",
                loadUtils: () => px(() => import("../chunks/1FgtjJRR.js"), [], import.meta.url),
                containerClass: "w-full",
                dropdownContainer: document.body
              })), () => {
                var ie;
                (ie = x(W)) == null || ie.destroy()
              }));
              var Ae = V(Qe, 2),
                gt = k(Ae),
                ee = V(gt);
              {
                var te = fe => {
                  var ie = dk(),
                    Se = k(ie);
                  A(ie), Xe(Me => ve(Se, `(${Me??""})`), [() => kd(x(D))]), H(fe, ie)
                };
                Ue(ee, fe => {
                  x(D) > 0 && fe(te)
                })
              }
              A(Ae), A(rt), Xe((fe, ie, Se) => {
                ve(tt, fe), ve(ot, ie), Ae.disabled = x(T), ve(gt, `${Se??""} `)
              }, [() => yC(), () => wC(), () => SC()]), Pn("submit", rt, async () => {
                var ie;
                if (x(T)) return;
                if (!((ie = x(W)) != null && ie.isValidNumber())) {
                  $r.error(G3());
                  return
                }
                const fe = x(W).getNumber();
                await _e(fe)
              }), H(mt, ut)
            },
            Fe = mt => {
              var ut = gk(),
                Ke = It(ut),
                ct = k(Ke),
                tt = k(ct, !0);
              A(ct);
              var Re = V(ct, 2),
                ot = k(Re);
              A(Re), A(Ke);
              var rt = V(Ke, 2),
                Qe = k(rt);
              {
                const Me = (nt, Ye) => {
                  let wt = () => Ye == null ? void 0 : Ye().cells;
                  var zt = Kt(),
                    Nt = It(zt);
                  _n(Nt, () => ik, (st, Tt) => {
                    Tt(st, {
                      class: "border-primary",
                      children: (Ct, yt) => {
                        var Mt = Kt(),
                          St = It(Mt);
                        gn(St, 16, wt, ht => ht, (ht, Lt) => {
                          var tr = Kt(),
                            Jt = It(tr);
                          _n(Jt, () => sk, (dr, nr) => {
                            nr(dr, {
                              get cell() {
                                return Lt
                              },
                              class: "border-base-content/20 size-11 sm:size-12"
                            })
                          }), H(ht, tr)
                        }), H(Ct, Mt)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  }), H(nt, zt)
                };
                _n(Qe, () => ok, (nt, Ye) => {
                  Ye(nt, {
                    maxlength: 6,
                    class: "mx-auto w-max",
                    get disabled() {
                      return x(o)
                    },
                    get value() {
                      return x(G)
                    },
                    set value(wt) {
                      le(G, wt, !0)
                    },
                    children: Me,
                    $$slots: {
                      default: !0
                    }
                  })
                })
              }
              A(rt);
              var Ae = V(rt, 2),
                gt = k(Ae);
              gt.__click = [fk, _e, C];
              var ee = k(gt),
                te = V(ee);
              {
                var fe = Me => {
                  var nt = mk(),
                    Ye = k(nt);
                  A(nt), Xe(wt => ve(Ye, `(${wt??""})`), [() => kd(x(D))]), H(Me, nt)
                };
                Ue(te, Me => {
                  x(D) > 0 && Me(fe)
                })
              }
              A(gt);
              var ie = V(gt, 2);
              ie.__click = [_k, C];
              var Se = k(ie, !0);
              A(ie), A(Ae), Xe((Me, nt, Ye, wt) => {
                ve(tt, Me), ve(ot, `${nt??""} ${x(C)??""}`), gt.disabled = x(T), ve(ee, `${Ye??""} `), ve(Se, wt)
              }, [() => MC(), () => EC(), () => DC(), () => FC()]), H(mt, ut)
            };
          Ue(je, mt => {
            x(C) ? mt(Fe, !1) : mt(Le)
          }, !0)
        }
        H(De, Be)
      };
    Ue(K, De => {
      x(g) ? De(Ie) : De(Ce, !1)
    })
  }
  A(xe), H(w, xe), Rr()
}
rn(["click"]);
var xk = Pe('<dialog class="modal"><div class="modal-box h-72 max-w-sm"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div></dialog>');

function bk(w, l) {
  Dr(l, !0);
  let g = At(l, "open", 15);
  var C = xk(),
    D = k(C),
    N = V(k(D), 2);
  {
    var T = o => {
      yk(o, {
        onsuccess: () => g(!1)
      })
    };
    Ue(N, o => {
      g() && o(T)
    })
  }
  A(D), A(C), Gn(C, () => o => {
    Hr(() => {
      g() ? o.show() : o.close()
    })
  }), Pn("close", C, () => g(!1)), H(w, C), Rr()
}
var wk = (w, l) => {
    l()
  },
  Tk = Pe('<span class="center-absolute loading loading-spinner absolute"></span>'),
  Ck = Pe('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  Sk = (w, l, g) => {
    l(x(g).id)
  },
  Pk = Pe('<span class="center-absolute loading loading-spinner absolute"></span>'),
  Ik = Pe('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  Mk = Pe('<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>'),
  Ak = (w, l) => {
    var g;
    (g = x(l)) == null || g.show()
  },
  kk = (w, l) => {
    l(!1)
  },
  Ek = (w, l) => {
    var g;
    (g = x(l)) == null || g.close()
  },
  zk = async (w, l) => {
    try {
      le(l, !0), await ni.deleteMe(), $r.warning(oC()), await Et.logout()
    } catch (g) {
      $r.error(g.message)
    } finally {
      le(l, !1)
    }
  }, Lk = Pe('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative w-max"><!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <!></div> <div class="flex w-full flex-col gap-3"><!> <!> <label class="label text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="mt-4 flex w-full items-center justify-between"><button type="button" class="btn btn-error btn-soft btn-sm w-max"> </button> <div class="flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <div class="mt-4 flex justify-end gap-2"><button class="btn btn-soft"> </button> <button class="btn btn-error"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function Dk(w, l) {
  Dr(l, !0);
  let g = At(l, "open", 15),
    C = at(Ln(l.userData.name)),
    D = at(Ln(l.userData.discord)),
    N = at(Ln(l.userData.showLastPixel)),
    T = at(!1),
    o = at(void 0),
    G = at(void 0);
  zi(() => {
    const Bt = pr => {
      pr.key === "Escape" && g(!1)
    };
    return document.addEventListener("keydown", Bt), () => document.removeEventListener("keydown", Bt)
  });
  let W = at(void 0),
    ae = at(void 0);
  Hr(() => {
    le(C, l.userData.name, !0), le(N, l.userData.showLastPixel, !0)
  }), Hr(() => {
    g() && !x(G) && ni.getMyProfilePictures().then(Bt => {
      le(G, Bt, !0)
    }).catch(Bt => {
      $r.error(Bt.message)
    })
  });
  let _e = at(!1);
  async function xe(Bt) {
    try {
      le(_e, !0), await ni.changeProfilePicture(Bt), await Et.refresh()
    } finally {
      le(_e, !1)
    }
  }
  var K = Lk(),
    Ie = It(K),
    Ce = k(Ie),
    De = V(k(Ce), 2),
    Be = k(De, !0);
  A(De);
  var je = V(De, 2),
    Le = k(je),
    Fe = k(Le),
    mt = k(Fe),
    ut = k(mt);
  ds(ut, {
    class: "size-30",
    get userId() {
      return l.userData.id
    },
    get pictureUrl() {
      return l.userData.picture
    }
  });
  var Ke = V(ut, 2),
    ct = k(Ke);
  Og(ct, {
    class: "size-5"
  }), A(Ke), A(mt);
  var tt = V(mt, 2);
  {
    var Re = Bt => {
      var pr = Mk(),
        gr = k(pr),
        Sr = k(gr, !0);
      A(gr);
      var Vr = V(gr, 2),
        ur = k(Vr);
      {
        var Pr = Mr => {
          var Nr = Ck();
          Nr.__click = [wk, xe];
          var ce = k(Nr);
          ds(ce, {
            class: "size-10 border",
            get userId() {
              return l.userData.id
            }
          });
          var F = V(ce, 2);
          {
            var q = $ => {
              var X = Tk();
              H($, X)
            };
            Ue(F, $ => {
              x(_e) && $(q)
            })
          }
          A(Nr), Xe(() => Nr.disabled = x(_e)), H(Mr, Nr)
        };
        Ue(ur, Mr => {
          l.userData.picture && Mr(Pr)
        })
      }
      var Ir = V(ur, 2);
      gn(Ir, 17, () => x(G), Mr => Mr.id, (Mr, Nr) => {
        var ce = Kt(),
          F = It(ce);
        {
          var q = $ => {
            var X = Ik();
            X.__click = [Sk, xe, Nr];
            var oe = k(X);
            ds(oe, {
              class: "size-10 border",
              get userId() {
                return l.userData.id
              },
              get pictureUrl() {
                return x(Nr).url
              }
            });
            var me = V(oe, 2);
            {
              var Ee = Te => {
                var Ze = Pk();
                H(Te, Ze)
              };
              Ue(me, Te => {
                x(_e) && Te(Ee)
              })
            }
            A(X), Xe(() => X.disabled = x(_e)), H($, X)
          };
          Ue(F, $ => {
            l.userData.picture !== x(Nr).url && $(q)
          })
        }
        H(Mr, ce)
      }), A(Vr), A(pr), Xe(Mr => ve(Sr, Mr), [() => zb()]), H(Bt, pr)
    };
    Ue(tt, Bt => {
      var pr;
      (pr = x(G)) != null && pr.length && Bt(Re)
    })
  }
  A(Fe);
  var ot = V(Fe, 2),
    rt = k(ot);
  {
    let Bt = lt(() => _f()),
      pr = lt(() => _f());
    vf(rt, {
      get label() {
        return x(Bt)
      },
      get placeholder() {
        return x(pr)
      },
      min: 1,
      max: 16,
      get value() {
        return x(C)
      },
      set value(gr) {
        le(C, gr, !0)
      },
      get validate() {
        return x(W)
      },
      set validate(gr) {
        le(W, gr, !0)
      }
    })
  }
  var Qe = V(rt, 2);
  {
    let Bt = lt(() => Bw());
    vf(Qe, {
      label: "Discord",
      get placeholder() {
        return x(Bt)
      },
      max: 32,
      get value() {
        return x(D)
      },
      set value(pr) {
        le(D, pr, !0)
      },
      get validate() {
        return x(ae)
      },
      set validate(pr) {
        le(ae, pr, !0)
      }
    })
  }
  var Ae = V(Qe, 2),
    gt = k(Ae);
  es(gt);
  var ee = V(gt);
  A(Ae), A(ot), A(Le);
  var te = V(Le, 2),
    fe = k(te);
  fe.__click = [Ak, o];
  var ie = k(fe, !0);
  A(fe);
  var Se = V(fe, 2),
    Me = k(Se);
  Me.__click = [kk, g];
  var nt = k(Me, !0);
  A(Me);
  var Ye = V(Me, 2),
    wt = k(Ye, !0);
  A(Ye), A(Se), A(te), A(je), A(Ce), A(Ie), Gn(Ie, () => Bt => {
    Hr(() => {
      g() ? Bt.show() : Bt.close()
    })
  });
  var zt = V(Ie, 2),
    Nt = k(zt),
    st = V(k(Nt), 2),
    Tt = k(st, !0);
  A(st);
  var Ct = V(st, 2),
    yt = k(Ct, !0);
  A(Ct);
  var Mt = V(Ct, 2),
    St = k(Mt);
  St.__click = [Ek, o];
  var ht = k(St, !0);
  A(St);
  var Lt = V(St, 2);
  Lt.__click = [zk, T];
  var tr = k(Lt, !0);
  A(Lt), A(Mt), A(Nt);
  var Jt = V(Nt, 2),
    dr = k(Jt),
    nr = k(dr, !0);
  A(dr), A(Jt), A(zt), Ds(zt, Bt => le(o, Bt), () => x(o)), Xe((Bt, pr, gr, Sr, Vr, ur, Pr, Ir, Mr, Nr, ce) => {
    ve(Be, Bt), kr(Ke, "data-tip", pr), ve(ee, ` ${gr??""}`), ve(ie, Sr), Me.disabled = x(T), ve(nt, Vr), Ye.disabled = x(T), ve(wt, ur), ve(Tt, Pr), ve(yt, Ir), ve(ht, Mr), Lt.disabled = x(T), ve(tr, Nr), ve(nr, ce)
  }, [() => jC(), () => cx(), () => Rb(), () => cg(), () => ec(), () => jb(), () => Ub(), () => Gb(), () => Uf(), () => cg(), () => ec()]), Pn("close", Ie, () => g(!1)), Pn("submit", je, async () => {
    var Bt, pr;
    try {
      if (!((Bt = x(W)) != null && Bt()) || !((pr = x(ae)) != null && pr())) return;
      le(T, !0), await ni.updateMe({
        name: x(C),
        showLastPixel: x(N),
        discord: x(D)
      }), Et.refresh(), $r.success(nC()), g(!1)
    } catch (gr) {
      $r.error(gr.message)
    } finally {
      le(T, !1)
    }
  }), tx(gt, () => x(N), Bt => le(N, Bt)), H(w, K), Rr()
}
rn(["click"]);
var Rk = Cr('<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>');

function Bk(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = Rk();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var Fk = Cr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>');

function Ev(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = Fk();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var Ok = Cr('<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>');

function Nk(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = Ok();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var jk = Cr('<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>');

function qk(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = jk();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    viewBox: "0 0 216 216",
    ...g
  }), void 0, void 0, "svelte-1977t4s"), H(w, C)
}
var Vk = Cr('<svg><path d="M480-440q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0-80q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0 440q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-400Zm0-315-240 90v189q0 54 15 105t41 96q42-21 88-33t96-12q50 0 96 12t88 33q26-45 41-96t15-105v-189l-240-90Zm0 515q-36 0-70 8t-65 22q29 30 63 52t72 34q38-12 72-34t63-52q-31-14-65-22t-70-8Z"></path></svg>');

function Sg(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = Vk();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var Uk = Cr('<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>');

function Zk(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = Uk();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var $k = Cr('<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>');

function Gk(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = $k();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var Hk = Cr('<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>');

function Wk(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = Hk();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var Xk = (w, l) => {
    le(l, !0)
  },
  Kk = Pe('<span class="tooltip font-flag ml-0.5"> </span>'),
  Yk = Pe('<div class="mt-1"><!></div>'),
  Jk = (w, l, g) => {
    localStorage.setItem(Jy, x(l).key), le(g, x(l).key, !0), location.reload()
  },
  Qk = Pe('<span class="center-absolute loading loading-spinner loading-xs absolute"></span>'),
  eE = Pe("<li><button><!> </button></li>"),
  tE = async (w, l) => {
    var g;
    try {
      const C = await ((g = x(l)) == null ? void 0 : g.prompt());
      (C == null ? void 0 : C.outcome) === "accepted" && le(l, void 0)
    } catch (C) {
      $r.error(gb({
        error: C.message
      }))
    }
  }, rE = Pe('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>'), iE = Pe('<a class="btn w-full" target="_blank"><!> </a>'), nE = Pe('<a class="btn w-full" target="_blank"><!> </a>'), aE = Pe('<form class="w-full" method="POST"><button class="btn w-full"><!> Purchases</button></form>'), sE = async (w, l, g, C) => {
    var D;
    try {
      le(l, !0), await g.user.logout(), C(), $r.warning(uC(), {
        icon: Ev
      }), (D = g.onlogout) == null || D.call(g)
    } catch {
      $r.error(pC())
    } finally {
      le(l, !1)
    }
  }, oE = Pe('<div class="dropdown"><div tabindex="0" role="button" class="btn size-12 p-0 shadow-md"><!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 relative right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="0"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 w-max rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div></div></div>  <!> <!> <!> <a class="btn w-full" href="https://www.twitch.tv/directory/category/wplace" target="_blank"><!> </a> <a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> Discord</a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> Reddit</a> <!> <button class="btn"><!> </button></section></div></div> <!>', 1);

function lE(w, l) {
  Dr(l, !0);
  let g = at(!1),
    C = at(!1);

  function D() {
    var _e;
    (_e = document.activeElement) == null || _e.blur()
  }
  const N = [{
    label: "ðŸ‡ºðŸ‡¸ English",
    key: "en"
  }, {
    label: "ðŸ‡§ðŸ‡· PortuguÃªs",
    key: "pt"
  }];
  let T = at(""),
    o = at(void 0);
  var G = Kt(),
    W = It(G);
  {
    var ae = _e => {
      var xe = oE(),
        K = It(xe),
        Ie = k(K),
        Ce = k(Ie);
      jg(Ce, {
        get userId() {
          return l.user.data.id
        },
        get level() {
          return l.user.data.level
        },
        get pictureUrl() {
          return l.user.data.picture
        }
      }), A(Ie);
      var De = V(Ie, 2),
        Be = k(De);
      Be.__click = D;
      var je = k(Be);
      pc(je, {
        class: "size-5"
      }), A(Be);
      var Le = V(Be, 2),
        Fe = k(Le),
        mt = k(Fe);
      ds(mt, {
        get userId() {
          return l.user.data.id
        },
        get pictureUrl() {
          return l.user.data.picture
        }
      });
      var ut = V(mt, 2);
      ut.__click = [Xk, g];
      var Ke = k(ut);
      yf(Ke, {
        class: "size-4"
      }), A(ut), A(Fe);
      var ct = V(Fe, 2),
        tt = k(ct),
        Re = k(tt),
        ot = k(Re, !0);
      A(Re);
      var rt = V(Re, 2),
        Qe = k(rt);
      A(rt);
      var Ae = V(rt, 2);
      {
        var gt = pt => {
          const bt = lt(() => hs(l.user.data.equippedFlag));
          var ar = Kk(),
            jr = k(ar, !0);
          A(ar), Xe(() => {
            kr(ar, "data-tip", x(bt).name), ve(jr, x(bt).flag)
          }), H(pt, ar)
        };
        Ue(Ae, pt => {
          l.user.data.equippedFlag && pt(gt)
        })
      }
      var ee = V(Ae, 2);
      {
        var te = pt => {
          var bt = Yk(),
            ar = k(bt);
          hh(ar, {
            get username() {
              return l.user.data.discord
            }
          }), A(bt), H(pt, bt)
        };
        Ue(ee, pt => {
          l.user.data.discord && pt(te)
        })
      }
      A(tt);
      var fe = V(tt, 2),
        ie = k(fe);
      dh(ie, {
        class: "inline size-4"
      });
      var Se = V(ie, 2),
        Me = k(Se),
        nt = V(Me),
        Ye = k(nt, !0);
      A(nt), A(Se), A(fe);
      var wt = V(fe, 2),
        zt = k(wt);
      Bk(zt, {
        class: "inline size-4"
      });
      var Nt = V(zt, 2),
        st = k(Nt),
        Tt = k(st);
      A(st);
      var Ct = V(st),
        yt = V(Ct),
        Mt = k(yt);
      jf(Mt, {
        class: "mb-0.5 inline size-4 opacity-50"
      }), A(yt), A(Nt), A(wt), A(ct), A(Le);
      var St = V(Le, 2),
        ht = k(St),
        Lt = k(ht),
        tr = k(Lt, !0);
      A(Lt);
      var Jt = V(Lt, 2),
        dr = k(Jt),
        nr = k(dr),
        Bt = k(nr);
      Zk(Bt, {
        class: "size-4"
      }), A(nr);
      var pr = V(nr, 2);
      gn(pr, 21, () => N, Od, (pt, bt) => {
        const ar = lt(() => x(T) === x(bt).key);
        var jr = eE(),
          qr = k(jr);
        let Gr;
        qr.__click = [Jk, bt, T];
        var mr = k(qr);
        {
          var Er = ft => {
            var yi = Qk();
            H(ft, yi)
          };
          Ue(mr, ft => {
            x(ar) && ft(Er)
          })
        }
        var ai = V(mr);
        A(qr), A(jr), Xe(ft => {
          Gr = Or(qr, 1, "font-flag relative font-medium", null, Gr, ft), ve(ai, ` ${x(bt).label??""}`)
        }, [() => ({
          "bg-base-200": x(ar)
        })]), H(pt, jr)
      }), A(pr), A(dr);
      var gr = V(dr, 2),
        Sr = k(gr);
      Sr.__click = () => {
        oa.muted = !oa.muted
      };
      var Vr = k(Sr);
      {
        var ur = pt => {
            Gk(pt, {
              class: "size-4"
            })
          },
          Pr = pt => {
            Wk(pt, {
              class: "size-4"
            })
          };
        Ue(Vr, pt => {
          oa.muted ? pt(ur) : pt(Pr, !1)
        })
      }
      A(Sr), A(gr), A(Jt), A(ht);
      var Ir = V(ht, 2);
      {
        var Mr = pt => {
          var bt = rE();
          bt.__click = [tE, o];
          var ar = k(bt);
          Dg(ar, {
            class: "size-5"
          });
          var jr = V(ar);
          A(bt), Xe(qr => ve(jr, ` ${qr??""}`), [() => xb()]), H(pt, bt)
        };
        Ue(Ir, pt => {
          x(o) && pt(Mr)
        })
      }
      var Nr = V(Ir, 2);
      {
        var ce = pt => {
          var bt = iE(),
            ar = k(bt);
          Sg(ar, {
            class: "size-5"
          });
          var jr = V(ar);
          A(bt), Xe(qr => {
            kr(bt, "href", `${fa.url.origin??""}/admin/dashboard`), ve(jr, ` ${qr??""}`)
          }, [() => ES()]), H(pt, bt)
        };
        Ue(Nr, pt => {
          var bt;
          ((bt = l.user.data) == null ? void 0 : bt.role) === "admin" && pt(ce)
        })
      }
      var F = V(Nr, 2);
      {
        var q = pt => {
          var bt = nE(),
            ar = k(bt);
          Sg(ar, {
            class: "size-5"
          });
          var jr = V(ar);
          A(bt), Xe(qr => {
            kr(bt, "href", `${fa.url.origin??""}/moderation`), ve(jr, ` ${qr??""}`)
          }, [() => pS()]), H(pt, bt)
        };
        Ue(F, pt => {
          var bt;
          (bt = l.user.data) != null && bt.role && l.user.data.role !== "user" && pt(q)
        })
      }
      var $ = V(F, 2),
        X = k($);
      Ug(X, {
        class: "size-5"
      });
      var oe = V(X);
      A($);
      var me = V($, 2),
        Ee = k(me);
      nm(Ee, {
        class: "size-5"
      }), vi(), A(me);
      var Te = V(me, 2),
        Ze = k(Te);
      qk(Ze, {
        class: "size-5"
      }), vi(), A(Te);
      var it = V(Te, 2);
      {
        var $e = pt => {
          var bt = aE(),
            ar = k(bt),
            jr = k(ar);
          Nk(jr, {
            class: "size-5"
          }), vi(), A(ar), A(bt), Xe(() => kr(bt, "action", `${Ny}/payment/create-portal-session`)), H(pt, bt)
        };
        Ue(it, pt => {
          var bt;
          (bt = l.user.data) != null && bt.isCustomer && pt($e)
        })
      }
      var kt = V(it, 2);
      kt.__click = [sE, C, l, D];
      var ye = k(kt);
      Ev(ye, {
        class: "size-5"
      });
      var Xt = V(ye);
      A(kt), A(St), A(De), A(K);
      var Ht = V(K, 2);
      Dk(Ht, {
        get userData() {
          return l.user.data
        },
        get open() {
          return x(g)
        },
        set open(pt) {
          le(g, pt, !0)
        }
      }), Xe((pt, bt, ar, jr, qr, Gr, mr, Er, ai, ft, yi) => {
        kr(Ie, "title", pt), kr(Re, "title", l.user.data.name), ve(ot, l.user.data.name), Or(rt, 1, bt), ve(Qe, `#${l.user.data.id??""}`), ve(Me, `${ar??""}: `), ve(Ye, jr), ve(Tt, `Level ${qr??""}`), ve(Ct, ` (${Gr??""}%) `), kr(yt, "data-tip", mr), ve(tr, Er), kr(gr, "data-tip", ai), ve(oe, ` ${ft??""}`), kt.disabled = x(C), ve(Xt, ` ${yi??""}`)
      }, [() => hb(), () => ao(Zn(l.user.data.id)), () => Hf(), () => l.user.data.pixelsPainted.toLocaleString("en-US"), () => Math.floor(l.user.data.level), () => Math.floor(l.user.data.level % 1 * 100), () => Ew(), () => fb(), () => oa.muted ? w3() : y3(), () => Tb(), () => Pb()]), Pn("focus", Ie, () => {
        le(o, window.pwaInstallPrompt, !0)
      }), H(_e, xe)
    };
    Ue(W, _e => {
      l.user.data && l.user.charges !== void 0 && _e(ae)
    })
  }
  H(w, G), Rr()
}
rn(["click"]);
var cE = Cr('<svg><path d="M100-240v-480l360 240-360 240Zm400 0v-480l360 240-360 240ZM180-480Zm400 0Zm-400 90 136-90-136-90v180Zm400 0 136-90-136-90v180Z"></path></svg>');

function uE(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = cE();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var hE = Cr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>');

function dE(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = hE();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var pE = async (w, l, g, C, D, N) => {
  if (x(l)) {
    g.map.easeTo(x(l)), le(l, void 0);
    return
  }
  le(C, !0);
  try {
    Ja(g.map.getCenter(), g.map.getZoom());
    const T = new uc(x(D)),
      {
        tile: o,
        pixel: G
      } = await ni.getRandomTile(g.season),
      W = o.x * x(D) + G.x,
      ae = o.y * x(D) + G.y,
      [_e, xe] = T.pixelsToLatLon(W, ae, x(N)),
      K = {
        lat: _e,
        lng: xe
      },
      Ie = x(N) + 2;
    le(l, {
      zoom: Ie,
      center: K
    }, !0), g.map.flyTo(x(l)), Ho.isEmpty() && Ho.push({
      pos: g.map.getCenter(),
      zoom: g.map.getZoom()
    }), setTimeout(() => {
      le(l, void 0)
    }, 2500), Ho.push({
      pos: K,
      zoom: Ie
    })
  } catch (T) {
    $r.error(T.message)
  } finally {
    le(C, !1)
  }
}, fE = Pe('<button class="btn btn-square shadow-md"><!></button>');

function mE(w, l) {
  Dr(l, !0);
  const g = lt(() => $n.seasons[l.season].tileSize),
    C = lt(() => $n.seasons[l.season].zoom);
  let D = at(!1),
    N = at(void 0);
  var T = fE();
  T.__click = [pE, N, l, D, g, C];
  var o = k(T);
  {
    var G = ae => {
        dE(ae, {
          class: "size-5"
        })
      },
      W = ae => {
        uE(ae, {
          class: "size-5"
        })
      };
    Ue(o, ae => {
      x(N) ? ae(W, !1) : ae(G)
    })
  }
  A(T), Xe(ae => {
    kr(T, "title", ae), T.disabled = x(D)
  }, [() => N1()]), H(w, T), Rr()
}
rn(["click"]);
var _E = Pe('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  gE = Pe('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  vE = Pe('<span class="font-flag tooltip ml-0.5"> </span>'),
  yE = Pe("<span> </span>"),
  xE = Pe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  bE = Pe('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  wE = Pe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  TE = Pe('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  CE = Pe('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  SE = Pe('<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>', 1);

function PE(w, l) {
  Dr(l, !0);
  const g = [];
  let C = at("today"),
    D = {
      players: {
        label: Yg(),
        icon: Zd
      },
      alliances: {
        label: Jg(),
        icon: $d
      }
    },
    N = at("players"),
    T = Ln({
      players: {},
      alliances: {}
    });
  const o = lt(() => T[x(N)][x(C)]);
  Hr(() => {
    if (x(o)) return;
    const Ce = x(C),
      De = x(N);
    De === "players" ? ni.leaderboardRegionPlayers(l.regionId, Ce).then(Be => {
      T[De][Ce] = Be
    }).catch(Be => {
      $r.error(Be.message)
    }) : De === "alliances" && ni.leaderboardRegionAlliances(l.regionId, Ce).then(Be => {
      T[De][Ce] = Be
    }).catch(Be => {
      $r.error(Be.message)
    })
  });
  var G = SE(),
    W = It(G);
  gn(W, 21, () => Object.entries(D), ([Ce, {
    label: De,
    icon: Be
  }]) => Ce, (Ce, De) => {
    var Be = lt(() => Ag(x(De), 2));
    let je = () => x(Be)[0],
      Le = () => x(Be)[1].label,
      Fe = () => x(Be)[1].icon;
    const mt = lt(Fe);
    var ut = _E(),
      Ke = k(ut);
    es(Ke);
    var ct, tt = V(Ke, 2);
    _n(tt, () => x(mt), (ot, rt) => {
      rt(ot, {
        get this() {
          return Fe()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var Re = V(tt);
    A(ut), Xe(() => {
      kr(Ke, "aria-label", Le()), ct !== (ct = je()) && (Ke.value = (Ke.__value = je()) ?? ""), ve(Re, ` ${Le()??""}`)
    }), $f(g, [], Ke, () => (je(), x(N)), ot => le(N, ot)), H(Ce, ut)
  }), A(W);
  var ae = V(W, 2),
    _e = k(ae);
  am(_e, {
    get value() {
      return x(C)
    },
    set value(Ce) {
      le(C, Ce, !0)
    }
  }), A(ae);
  var xe = V(ae, 2);
  {
    var K = Ce => {
        var De = gE(),
          Be = k(De),
          je = V(Be);
        {
          var Le = mt => {
              var ut = On();
              Xe(Ke => ve(ut, Ke), [() => Ud().toLowerCase()]), H(mt, ut)
            },
            Fe = mt => {
              var ut = Kt(),
                Ke = It(ut);
              {
                var ct = Re => {
                    var ot = On();
                    Xe(rt => ve(ot, rt), [() => Jf()]), H(Re, ot)
                  },
                  tt = Re => {
                    var ot = Kt(),
                      rt = It(ot);
                    {
                      var Qe = Ae => {
                        var gt = On();
                        Xe(ee => ve(gt, ee), [() => Qf()]), H(Ae, gt)
                      };
                      Ue(rt, Ae => {
                        x(C) === "month" && Ae(Qe)
                      }, !0)
                    }
                    H(Re, ot)
                  };
                Ue(Ke, Re => {
                  x(C) === "week" ? Re(ct) : Re(tt, !1)
                }, !0)
              }
              H(mt, ut)
            };
          Ue(je, mt => {
            x(C) === "today" ? mt(Le) : mt(Fe, !1)
          })
        }
        A(De), Xe(mt => ve(Be, `${mt??""} `), [() => Yf()]), H(Ce, De)
      },
      Ie = Ce => {
        var De = Kt(),
          Be = It(De);
        {
          var je = Fe => {
              var mt = Kt(),
                ut = It(mt);
              {
                var Ke = tt => {
                    const Re = lt(() => x(o));
                    var ot = bE(),
                      rt = k(ot),
                      Qe = k(rt),
                      Ae = V(k(Qe)),
                      gt = k(Ae, !0);
                    A(Ae);
                    var ee = V(Ae),
                      te = k(ee),
                      fe = V(te, 2, !0);
                    A(ee), A(Qe), A(rt);
                    var ie = V(rt);
                    gn(ie, 31, () => x(Re), Se => Se.id, (Se, Me, nt) => {
                      const Ye = lt(() => {
                        var ur;
                        return ((ur = Et.data) == null ? void 0 : ur.id) === x(Me).id
                      });
                      var wt = xE();
                      let zt;
                      var Nt = k(wt),
                        st = k(Nt, !0);
                      A(Nt);
                      var Tt = V(Nt),
                        Ct = k(Tt),
                        yt = k(Ct);
                      ds(yt, {
                        class: "size-10 border",
                        get userId() {
                          return x(Me).id
                        },
                        get pictureUrl() {
                          return x(Me).picture
                        }
                      });
                      var Mt = V(yt, 2),
                        St = k(Mt),
                        ht = k(St),
                        Lt = V(ht),
                        tr = k(Lt);
                      A(Lt), A(St);
                      var Jt = V(St, 2);
                      {
                        var dr = ur => {
                          const Pr = lt(() => hs(x(Me).equippedFlag));
                          var Ir = vE(),
                            Mr = k(Ir, !0);
                          A(Ir), Xe(() => {
                            kr(Ir, "data-tip", x(Pr).name), ve(Mr, x(Pr).flag)
                          }), H(ur, Ir)
                        };
                        Ue(Jt, ur => {
                          "equippedFlag" in x(Me) && x(Me).equippedFlag && ur(dr)
                        })
                      }
                      var nr = V(Jt, 2);
                      {
                        var Bt = ur => {
                          hh(ur, {
                            get username() {
                              return x(Me).discord
                            }
                          })
                        };
                        Ue(nr, ur => {
                          x(Me).discord && ur(Bt)
                        })
                      }
                      var pr = V(nr, 2);
                      {
                        var gr = ur => {
                          var Pr = yE(),
                            Ir = k(Pr, !0);
                          A(Pr), Xe((Mr, Nr) => {
                            Or(Pr, 1, `badge badge-sm ml-0.5 border-0 ${Mr??""} ${Nr??""}`), ve(Ir, x(Me).allianceName)
                          }, [() => Wf(x(Me).allianceId), () => Zn(x(Me).allianceId)]), H(ur, Pr)
                        };
                        Ue(pr, ur => {
                          "allianceName" in x(Me) && x(Me).allianceName && ur(gr)
                        })
                      }
                      A(Mt), A(Ct), A(Tt);
                      var Sr = V(Tt),
                        Vr = k(Sr, !0);
                      A(Sr), A(wt), Xe((ur, Pr, Ir) => {
                        zt = Or(wt, 1, "", null, zt, ur), ve(st, x(nt) + 1), Or(St, 1, `font-semibold max-sm:ml-2 ${Pr??""} flex gap-1`), ve(ht, `${x(Me).name??""} `), ve(tr, `#${x(Me).id??""}`), ve(Vr, Ir)
                      }, [() => ({
                        "bg-base-200": x(Ye)
                      }), () => Zn(x(Me).id), () => x(Me).pixelsPainted.toLocaleString("en-US")]), Zo(wt, () => $o, () => ({
                        duration: 200
                      })), H(Se, wt)
                    }), A(ie), A(ot), Xe((Se, Me, nt) => {
                      ve(gt, Se), ve(te, `${Me??""} `), ve(fe, nt)
                    }, [() => em(), () => Jl(), () => Ql().toLowerCase()]), H(tt, ot)
                  },
                  ct = tt => {
                    var Re = Kt(),
                      ot = It(Re);
                    {
                      var rt = Qe => {
                        var Ae = TE(),
                          gt = k(Ae),
                          ee = k(gt),
                          te = V(k(ee)),
                          fe = k(te, !0);
                        A(te);
                        var ie = V(te),
                          Se = k(ie),
                          Me = V(Se, 2, !0);
                        A(ie), A(ee), A(gt);
                        var nt = V(gt);
                        gn(nt, 31, () => x(o), Ye => Ye.id, (Ye, wt, zt) => {
                          const Nt = lt(() => {
                            var Jt;
                            return ((Jt = Et.data) == null ? void 0 : Jt.allianceId) === x(wt).id
                          });
                          var st = wE();
                          let Tt;
                          var Ct = k(st),
                            yt = k(Ct, !0);
                          A(Ct);
                          var Mt = V(Ct),
                            St = k(Mt),
                            ht = k(St, !0);
                          A(St), A(Mt);
                          var Lt = V(Mt),
                            tr = k(Lt, !0);
                          A(Lt), A(st), Xe((Jt, dr, nr) => {
                            Tt = Or(st, 1, "", null, Tt, Jt), ve(yt, x(zt) + 1), Or(St, 1, `font-semibold ${dr??""}`), ve(ht, x(wt).name), ve(tr, nr)
                          }, [() => ({
                            "bg-base-200": x(Nt)
                          }), () => Zn(x(wt).id), () => x(wt).pixelsPainted.toLocaleString("en-US")]), Zo(st, () => $o, () => ({
                            duration: 200
                          })), H(Ye, st)
                        }), A(nt), A(Ae), Xe((Ye, wt, zt) => {
                          ve(fe, Ye), ve(Se, `${wt??""} `), ve(Me, zt)
                        }, [() => qd(), () => Jl(), () => Ql().toLowerCase()]), H(Qe, Ae)
                      };
                      Ue(ot, Qe => {
                        x(N) === "alliances" && Qe(rt)
                      }, !0)
                    }
                    H(tt, Re)
                  };
                Ue(ut, tt => {
                  x(N) === "players" ? tt(Ke) : tt(ct, !1)
                })
              }
              H(Fe, mt)
            },
            Le = Fe => {
              var mt = CE();
              H(Fe, mt)
            };
          Ue(Be, Fe => {
            x(o) ? Fe(je) : Fe(Le, !1)
          }, !0)
        }
        H(Ce, De)
      };
    Ue(xe, Ce => {
      x(o) && x(o).length === 0 ? Ce(K) : Ce(Ie, !1)
    })
  }
  H(w, G), Rr()
}
var IE = Pe('<div class="mt-5"><!></div>'),
  ME = Pe('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function AE(w, l) {
  Dr(l, !0);
  let g = At(l, "open", 15);
  const C = lt(() => hs(l.region.countryId));
  zi(() => {
    const Ce = De => {
      De.key === "Escape" && g(!1)
    };
    return document.addEventListener("keydown", Ce), () => document.removeEventListener("keydown", Ce)
  });
  var D = ME(),
    N = k(D),
    T = V(k(N), 2),
    o = k(T),
    G = k(o, !0);
  A(o);
  var W = V(o, 2),
    ae = k(W, !0);
  A(W);
  var _e = V(W, 2),
    xe = k(_e);
  A(_e), A(T);
  var K = V(T, 2);
  {
    var Ie = Ce => {
      var De = IE(),
        Be = k(De);
      PE(Be, {
        get regionId() {
          return l.region.id
        }
      }), A(De), zn(2, De, () => ea, () => ({
        duration: 300
      })), H(Ce, De)
    };
    Ue(K, Ce => {
      g() && Ce(Ie)
    })
  }
  A(N), vi(2), A(D), Gn(D, () => Ce => {
    Hr(() => {
      g() ? Ce.show() : Ce.close()
    })
  }), Xe(Ce => {
    Or(T, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${Ce??""}`), kr(o, "data-tip", x(C).name), ve(G, x(C).flag), ve(ae, l.region.name), ve(xe, `#${l.region.number??""}`)
  }, [() => Zn(l.region.cityId)]), Pn("close", D, () => g(!1)), H(w, D), Rr()
}
var kE = Cr('<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>');

function EE(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = kE();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var zE = Cr('<svg><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240ZM330-120 120-330v-300l210-210h300l210 210v300L630-120H330Zm34-80h232l164-164v-232L596-760H364L200-596v232l164 164Zm116-280Z"></path></svg>');

function LE(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = zE();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var DE = Cr('<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>'),
  RE = Cr('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>');

function BE(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var C = Kt(),
    D = It(C);
  {
    var N = o => {
        var G = DE();
        er(G, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...g
        })), H(o, G)
      },
      T = o => {
        var G = RE();
        er(G, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...g
        })), H(o, G)
      };
    Ue(D, o => {
      l.filled ? o(N) : o(T, !1)
    })
  }
  H(w, C)
}
var FE = (w, l, g, C, D) => {
    if (x(l) && x(g)) {
      const N = x(l) - x(g).clientHeight,
        T = x(l) / 2 - N / 2;
      C.map.flyTo({
        center: {
          lat: x(D).center[0],
          lng: x(D).center[1]
        },
        zoom: 17.5,
        offset: [0, -T]
      })
    }
  },
  OE = (w, l, g) => l.onclickregion(x(g)),
  NE = Pe('<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button>'),
  jE = Pe('<div class="skeleton h-5 w-16"></div>'),
  qE = Pe('<div class="skeleton mt-1 h-5 w-32"></div>'),
  VE = Pe('<span class="font-flag tooltip ml-0.5"> </span>'),
  UE = (w, l) => {
    navigator.clipboard.writeText(x(l).allianceId.toString()), $r.success(Kf())
  },
  ZE = Pe("<button><!></button>"),
  $E = Pe("<span> </span> <!>", 1),
  GE = (w, l) => {
    l("report-user")
  },
  HE = Pe("<li><button><!> </button></li>"),
  WE = (w, l) => {
    l("timeout")
  },
  XE = Pe("<li><button><!> </button></li>"),
  KE = (w, l) => {
    l("ban")
  },
  YE = Pe("<li><button><!> </button></li>"),
  JE = async (w, l, g, C, D, N) => {
    le(l, !0);
    try {
      await ni.banAllianceUser(x(g).id), await C({
        ...x(D),
        season: N.season
      })
    } catch (T) {
      $r.error(T.message)
    } finally {
      le(l, !1)
    }
  }, QE = Pe('<li><button class="text-error font-medium"><!> </button></li>'), e8 = Pe('<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left ml-1"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 shadow-sm"></ul></div>'), t8 = Pe('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><!></div> <div class="flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!> <!> <!></div> <!></div>'), r8 = (w, l) => l.onclickpaint(l.latLon), i8 = async (w, l, g, C) => {
    try {
      le(l, !0), x(g) ? (await ni.deleteFavoriteLocation(x(g).id), $r.warning(X3())) : (await ni.favoriteLocation(x(C).center), $r.success(J3())), pa.smallPlop.play(), Et.refresh()
    } catch (D) {
      $r.error(D.message)
    } finally {
      le(l, !1)
    }
  }, n8 = Pe("<button><!> </button>"), a8 = (w, l, g) => l.onclickshare($S(fa.url, {
    pos: {
      lat: x(g).center[0],
      lng: x(g).center[1]
    },
    zoom: l.zoom
  })), s8 = Pe('<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><button class="btn btn-primary"><!> </button> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>');

function o8(w, l) {
  Dr(l, !0);
  let g = at(void 0);
  const C = lt(() => new uc(l.tileSize));
  let D = at(void 0),
    N = at(void 0),
    T = at(!1),
    o = at(!1);
  const G = lt(() => {
      var st, Tt, Ct;
      return !!((Tt = (st = x(g)) == null ? void 0 : st.paintedBy) != null && Tt.id) && ((Ct = Et.data) == null ? void 0 : Ct.id) === x(g).paintedBy.id
    }),
    W = lt(() => {
      const [st, Tt] = l.latLon ?? [0, 0], Ct = x(C).latLonToPixelBoundsLatLon(st, Tt, l.pixelArtZoom), yt = rm(Ct), {
        tile: Mt,
        pixel: St
      } = x(C).latLonToTileAndPixel(st, Tt, l.pixelArtZoom), ht = x(C).latLonToRegionAndPixel(st, Tt, l.pixelArtZoom);
      return {
        bounds: Ct,
        center: yt,
        tile: Mt,
        pixel: St,
        regionPixel: ht.pixel
      }
    });
  Hr(() => {
    pa.plop.play(), l.crosshair.clearAndPlace(l.latLon)
  });
  let ae = 0;
  const _e = ({
    pixel: st,
    tile: Tt,
    season: Ct
  }) => `s${Ct}:p(${st[0]},${st[1]}):t(${Tt[0]},${Tt[1]})`;
  let xe;
  hc(() => [x(W), l.season], () => {
    const st = {
        ...x(W),
        season: l.season
      },
      Tt = _e(st);
    if (le(g, l.pixelInfoCache.get(Tt), !0), x(g) !== void 0) return;
    l.pixelInfoCache.size === 0 && (ae = 0), ae++, ae > 6 ? (clearTimeout(xe), xe = setTimeout(async () => K(st), 500)) : K(st)
  });
  async function K(st) {
    const Tt = await ni.getPixelInfo(st);
    if (Tt.paintedBy !== void 0) {
      const yt = _e(st);
      l.pixelInfoCache.set(yt, Tt)
    }
    const Ct = _e({
      ...x(W),
      season: l.season
    });
    return le(g, l.pixelInfoCache.get(Ct), !0), Tt
  }

  function Ie() {
    l.crosshair.clear(), pa.smallPlop.play(), l.onclose()
  }
  zi(() => {
    const st = Tt => {
      Tt.key === "Escape" && Ie()
    };
    return document.addEventListener("keydown", st), () => document.removeEventListener("keydown", st)
  });
  const Ce = lt(() => {
    var yt, Mt, St, ht, Lt;
    const st = [],
      Tt = (Mt = (yt = Et) == null ? void 0 : yt.data) == null ? void 0 : Mt.role;
    Ad(Tt, ["admin"]) && !x(G) && st.push("ban-user"), Ad(Tt, ["admin", "global_moderator", "moderator"]) && !x(G) && st.push("timeout-user"), st.push("report-user");
    const Ct = (St = x(g)) == null ? void 0 : St.paintedBy;
    return (Ct == null ? void 0 : Ct.allianceId) === ((ht = Et.data) == null ? void 0 : ht.allianceId) && ((Lt = Et.data) == null ? void 0 : Lt.allianceRole) === "admin" && Et.data.id !== (Ct == null ? void 0 : Ct.id) && !x(G) && st.push("ban-alliance"), st
  });

  function De(st) {
    const Tt = (async () => await iv(l.map, {
      maxHeight: 1080,
      maxWidth: 1080,
      quality: .8,
      type: "image/jpeg"
    }))();
    l.onclickmodaction(x(g), Tt, l.latLon, st)
  }
  var Be = s8(),
    je = k(Be),
    Le = k(je),
    Fe = k(Le);
  Fe.__click = [FE, D, N, l, W];
  var mt = k(Fe);
  Zf(mt, {
    class: "fill-primary size-5"
  }), A(Fe);
  var ut = V(Fe, 2),
    Ke = k(ut),
    ct = k(Ke);
  A(Ke);
  var tt = V(Ke, 2);
  {
    var Re = st => {
        const Tt = lt(() => x(g).region),
          Ct = lt(() => hs(x(Tt).countryId));
        var yt = NE();
        yt.__click = [OE, l, Tt];
        var Mt = k(yt),
          St = k(Mt, !0);
        A(Mt);
        var ht = V(Mt, 2),
          Lt = k(ht, !0);
        A(ht);
        var tr = V(ht, 2),
          Jt = k(tr);
        A(tr), A(yt), Xe(dr => {
          Or(yt, 1, `btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${dr??""}`), kr(Mt, "data-tip", x(Ct).name), ve(St, x(Ct).flag), ve(Lt, x(Tt).name), ve(Jt, `#${x(Tt).number??""}`)
        }, [() => Zn(x(Tt).cityId)]), H(st, yt)
      },
      ot = st => {
        var Tt = jE();
        H(st, Tt)
      };
    Ue(tt, st => {
      var Tt;
      (Tt = x(g)) != null && Tt.region ? st(Re) : st(ot, !1)
    })
  }
  A(ut), A(Le);
  var rt = V(Le, 2);
  rt.__click = Ie;
  var Qe = k(rt);
  pc(Qe, {
    class: "size-4"
  }), A(rt), A(je);
  var Ae = V(je, 2),
    gt = k(Ae);
  {
    var ee = st => {
        var Tt = qE();
        H(st, Tt)
      },
      te = st => {
        var Tt = Kt(),
          Ct = It(Tt);
        {
          var yt = St => {
              var ht = On();
              Xe(Lt => ve(ht, Lt), [() => t3()]), H(St, ht)
            },
            Mt = St => {
              const ht = lt(() => x(g).paintedBy);
              var Lt = t8(),
                tr = k(Lt),
                Jt = k(tr);
              A(tr);
              var dr = V(tr, 2),
                nr = k(dr);
              ds(nr, {
                class: "size-5 border-0",
                get userId() {
                  return x(ht).id
                },
                get pictureUrl() {
                  return x(ht).picture
                }
              }), A(dr);
              var Bt = V(dr, 2),
                pr = k(Bt),
                gr = k(pr),
                Sr = k(gr, !0);
              A(gr);
              var Vr = V(gr, 2),
                ur = k(Vr);
              A(Vr), A(pr);
              var Pr = V(pr, 2);
              {
                var Ir = X => {
                  const oe = lt(() => hs(x(ht).equippedFlag));
                  var me = VE(),
                    Ee = k(me, !0);
                  A(me), Xe(() => {
                    kr(me, "data-tip", x(oe).name), ve(Ee, x(oe).flag)
                  }), H(X, me)
                };
                Ue(Pr, X => {
                  x(ht).equippedFlag && X(Ir)
                })
              }
              var Mr = V(Pr, 2);
              {
                var Nr = X => {
                  hh(X, {
                    get username() {
                      return x(ht).discord
                    }
                  })
                };
                Ue(Mr, X => {
                  x(ht).discord && X(Nr)
                })
              }
              var ce = V(Mr, 2);
              {
                var F = X => {
                  var oe = $E(),
                    me = It(oe),
                    Ee = k(me, !0);
                  A(me);
                  var Te = V(me, 2);
                  {
                    var Ze = it => {
                      var $e = ZE();
                      $e.__click = [UE, ht];
                      var kt = k($e);
                      Bg(kt, {
                        class: "size-3"
                      }), A($e), Xe((ye, Xt) => {
                        Or($e, 1, ye), kr($e, "title", Xt)
                      }, [() => ao(Zn(x(ht).allianceId)), () => ex({
                        allianceId: x(ht).allianceId
                      })]), H(it, $e)
                    };
                    Ue(Te, it => {
                      var $e, kt, ye;
                      ((($e = Et.data) == null ? void 0 : $e.role) === "admin" || ((kt = Et.data) == null ? void 0 : kt.role) === "moderator" || ((ye = Et.data) == null ? void 0 : ye.role) === "global_moderator") && it(Ze)
                    })
                  }
                  Xe((it, $e) => {
                    Or(me, 1, `badge badge-sm ml-0.5 border-0 ${it??""} ${$e??""}`), ve(Ee, x(ht).allianceName)
                  }, [() => Wf(x(ht).allianceId), () => Zn(x(ht).allianceId)]), H(X, oe)
                };
                Ue(ce, X => {
                  x(ht).allianceId && X(F)
                })
              }
              A(Bt);
              var q = V(Bt, 2);
              {
                var $ = X => {
                  var oe = e8(),
                    me = k(oe),
                    Ee = k(me);
                  sm(Ee, {
                    class: "size-4"
                  }), A(me);
                  var Te = V(me, 2);
                  gn(Te, 21, () => x(Ce), Od, (Ze, it) => {
                    var $e = Kt(),
                      kt = It($e);
                    {
                      var ye = Ht => {
                          var pt = HE(),
                            bt = k(pt);
                          let ar;
                          bt.__click = [GE, De];
                          var jr = k(bt);
                          LE(jr, {
                            class: "size-5"
                          });
                          var qr = V(jr);
                          A(bt), A(pt), Xe((Gr, mr) => {
                            ar = Or(bt, 1, "text-error py-2 font-medium", null, ar, Gr), ve(qr, ` ${mr??""}`)
                          }, [() => ({
                            "cursor-not-allowed": x(G)
                          }), () => Wy()]), H(Ht, pt)
                        },
                        Xt = Ht => {
                          var pt = Kt(),
                            bt = It(pt);
                          {
                            var ar = qr => {
                                var Gr = XE(),
                                  mr = k(Gr);
                                let Er;
                                mr.__click = [WE, De];
                                var ai = k(mr);
                                Fg(ai, {
                                  class: "size-5"
                                });
                                var ft = V(ai);
                                A(mr), A(Gr), Xe((yi, pi) => {
                                  Er = Or(mr, 1, "text-error font-medium", null, Er, yi), ve(ft, ` ${pi??""}`)
                                }, [() => ({
                                  "cursor-not-allowed": x(G)
                                }), () => Xy()]), H(qr, Gr)
                              },
                              jr = qr => {
                                var Gr = Kt(),
                                  mr = It(Gr);
                                {
                                  var Er = ft => {
                                      var yi = YE(),
                                        pi = k(yi);
                                      let In;
                                      pi.__click = [KE, De];
                                      var Pt = k(pi);
                                      rx(Pt, {
                                        class: "size-5"
                                      });
                                      var We = V(Pt);
                                      A(pi), A(yi), Xe((Ot, $t) => {
                                        In = Or(pi, 1, "text-error font-medium", null, In, Ot), ve(We, ` ${$t??""}`)
                                      }, [() => ({
                                        "cursor-not-allowed": x(G)
                                      }), () => Ky()]), H(ft, yi)
                                    },
                                    ai = ft => {
                                      var yi = Kt(),
                                        pi = It(yi);
                                      {
                                        var In = Pt => {
                                          var We = QE(),
                                            Ot = k(We);
                                          Ot.__click = [JE, o, ht, K, W, l];
                                          var $t = k(Ot);
                                          EE($t, {
                                            class: "size-5"
                                          });
                                          var zr = V($t);
                                          A(Ot), A(We), Xe(Wr => ve(zr, ` ${Wr??""}`), [() => Kg()]), H(Pt, We)
                                        };
                                        Ue(pi, Pt => {
                                          x(it) === "ban-alliance" && Pt(In)
                                        }, !0)
                                      }
                                      H(ft, yi)
                                    };
                                  Ue(mr, ft => {
                                    x(it) === "ban-user" ? ft(Er) : ft(ai, !1)
                                  }, !0)
                                }
                                H(qr, Gr)
                              };
                            Ue(bt, qr => {
                              x(it) === "timeout-user" ? qr(ar) : qr(jr, !1)
                            }, !0)
                          }
                          H(Ht, pt)
                        };
                      Ue(kt, Ht => {
                        x(it) === "report-user" ? Ht(ye) : Ht(Xt, !1)
                      })
                    }
                    H(Ze, $e)
                  }), A(Te), A(oe), H(X, oe)
                };
                Ue(q, X => {
                  x(Ce).length > 0 && X($)
                })
              }
              A(Lt), Xe((X, oe) => {
                var me;
                ve(Jt, `${X??""}:`), Or(pr, 1, `font-medium ${oe??""} flex gap-1.5`), ve(Sr, ((me = Et.data) == null ? void 0 : me.id) === x(ht).id ? Et.data.name : x(ht).name), ve(ur, `#${x(ht).id??""}`)
              }, [() => n3(), () => Zn(x(ht).id)]), H(St, Lt)
            };
          Ue(Ct, St => {
            x(g).paintedBy.id === 0 ? St(yt) : St(Mt, !1)
          }, !0)
        }
        H(st, Tt)
      };
    Ue(gt, st => {
      x(g) === void 0 ? st(ee) : st(te, !1)
    })
  }
  A(Ae);
  var fe = V(Ae, 2),
    ie = k(fe);
  ie.__click = [r8, l];
  var Se = k(ie);
  dh(Se, {
    class: "size-4.5"
  });
  var Me = V(Se);
  A(ie);
  var nt = V(ie, 2);
  {
    var Ye = st => {
      const Tt = lt(() => Et.data.favoriteLocations.find(Lt => Math.abs(Lt.latitude - x(W).center[0]) < 5e-5 && Math.abs(Lt.longitude - x(W).center[1]) < 5e-5)),
        Ct = lt(() => !x(Tt) && Et.data.favoriteLocations.length >= Et.data.maxFavoriteLocations);
      var yt = n8();
      let Mt;
      yt.__click = [i8, T, Tt, W];
      var St = k(yt);
      {
        let Lt = lt(() => !!x(Tt));
        BE(St, {
          class: "size-4.5",
          get filled() {
            return x(Lt)
          }
        })
      }
      var ht = V(St);
      A(yt), Xe((Lt, tr) => {
        Mt = Or(yt, 1, "btn btn-primary btn-soft", null, Mt, Lt), yt.disabled = x(T) || x(Ct), ve(ht, ` ${tr??""}`)
      }, [() => ({
        "text-yellow-400": !!x(Tt)
      }), () => x(Ct) ? o3() : u3()]), H(st, yt)
    };
    Ue(nt, st => {
      Et.data && st(Ye)
    })
  }
  var wt = V(nt, 2);
  wt.__click = [a8, l, W];
  var zt = k(wt);
  nv(zt, {
    class: "size-4.5"
  });
  var Nt = V(zt);
  A(wt), A(fe), A(Be), Ds(Be, st => le(N, st), () => x(N)), Xe((st, Tt) => {
    ve(ct, `Pixel: ${x(W).regionPixel[0]??""}, ${x(W).regionPixel[1]??""}`), ie.disabled = Et.loading, ve(Me, ` ${st??""}`), ve(Nt, ` ${Tt??""}`)
  }, [() => Hg(), () => p3()]), jd("innerHeight", st => le(D, st, !0)), H(w, Be), Rr()
}
rn(["click"]);

function l8(w) {
  var C;
  const l = document.createElement("div");
  (C = w.parentElement) == null || C.insertBefore(l, w.nextSibling);
  const g = new IntersectionObserver(D => {
    D[0].isIntersecting ? w.classList.remove("stuck") : w.classList.add("stuck")
  }, {
    threshold: 0,
    rootMargin: "0px"
  });
  return g.observe(l), () => {
    l.remove(), g.disconnect()
  }
}
var c8 = Cr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>'),
  u8 = Cr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>');

function h8(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var C = Kt(),
    D = It(C);
  {
    var N = o => {
        var G = c8();
        er(G, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...g
        })), H(o, G)
      },
      T = o => {
        var G = u8();
        er(G, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...g
        })), H(o, G)
      };
    Ue(D, o => {
      l.filled ? o(N) : o(T, !1)
    })
  }
  H(w, C)
}
var d8 = Pe('<span class="loading loading-spinner center-absolute absolute"></span>'),
  p8 = Pe('<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <span class="text-sm">Droplets</span></button>'),
  f8 = Pe('<span class="loading loading-spinner center-absolute absolute"></span>'),
  m8 = Pe('<!> <span class="text-sm"> </span>', 1),
  _8 = Pe('<span class="text-sm"> </span>'),
  g8 = Pe('<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>'),
  v8 = Pe('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <p class="mt-2 text-center text-xl font-bold"> </p> <!> <div><!></div></div>'),
  y8 = (w, l) => {
    le(l, !x(l))
  },
  x8 = Pe('<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium">Flags</h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>');

function b8(w, l) {
  Dr(l, !0);
  const g = (Le, Fe = ma) => {
      const mt = lt(() => {
          var ie;
          return (((ie = Et.data) == null ? void 0 : ie.droplets) ?? 0) >= T.price
        }),
        ut = lt(() => x(G) === Fe().id);
      var Ke = v8(),
        ct = k(Ke),
        tt = k(ct, !0);
      A(ct);
      var Re = V(ct, 2),
        ot = k(Re, !0);
      A(Re);
      var rt = V(Re, 2);
      {
        var Qe = ie => {
          um(ie, {})
        };
        Ue(rt, ie => {
          Fe().id === x(W) && ie(Qe)
        })
      }
      var Ae = V(rt, 2);
      let gt;
      var ee = k(Ae);
      {
        var te = ie => {
            var Se = p8();
            Se.__click = async () => {
              try {
                const zt = Fe().id;
                le(G, zt, !0), await ni.purchase({
                  id: N,
                  amount: 1,
                  variant: zt
                }), Et.refresh(), pa.notification1.play();
                const Nt = D.find(st => st.id === zt);
                Nt && (Nt.owned = !0), le(W, zt, !0)
              } catch (zt) {
                $r.error(zt.message)
              } finally {
                le(G, void 0)
              }
            };
            var Me = k(Se);
            {
              var nt = zt => {
                var Nt = d8();
                H(zt, Nt)
              };
              Ue(Me, zt => {
                x(ut) && zt(nt)
              })
            }
            var Ye = V(Me, 2);
            Nd(Ye, {
              class: "size-4"
            });
            var wt = V(Ye);
            vi(), A(Se), Xe(zt => {
              Se.disabled = !x(mt) || x(ut), ve(wt, ` ${zt??""} `)
            }, [() => T.price.toLocaleString("en-US")]), H(ie, Se)
          },
          fe = ie => {
            const Se = lt(() => {
              var yt;
              return ((yt = Et.data) == null ? void 0 : yt.equippedFlag) === Fe().id
            });
            var Me = g8();
            let nt;
            Me.__click = async () => {
              try {
                le(G, Fe().id, !0);
                const yt = x(Se) ? 0 : Fe().id;
                await ni.equipFlag(yt), Et.data && (Et.data.equippedFlag = yt), Et.refresh()
              } catch (yt) {
                $r.error(yt.message)
              } finally {
                le(G, void 0)
              }
            };
            var Ye = k(Me),
              wt = k(Ye, !0);
            A(Ye);
            var zt = V(Ye, 2);
            {
              var Nt = yt => {
                var Mt = f8();
                H(yt, Mt)
              };
              Ue(zt, yt => {
                x(ut) && yt(Nt)
              })
            }
            var st = V(zt, 2);
            {
              var Tt = yt => {
                  var Mt = m8(),
                    St = It(Mt);
                  pc(St, {
                    class: "size-4"
                  });
                  var ht = V(St, 2),
                    Lt = k(ht, !0);
                  A(ht), Xe(tr => ve(Lt, tr), [() => n2()]), H(yt, Mt)
                },
                Ct = yt => {
                  var Mt = _8(),
                    St = k(Mt, !0);
                  A(Mt), Xe(ht => ve(St, ht), [() => o2()]), H(yt, Mt)
                };
              Ue(st, yt => {
                x(Se) ? yt(Tt) : yt(Ct, !1)
              })
            }
            A(Me), Xe((yt, Mt) => {
              nt = Or(Me, 1, "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10", null, nt, yt), Me.disabled = x(ut), ve(wt, Mt)
            }, [() => ({
              "btn-warning": x(Se)
            }), () => t2()]), H(ie, Me)
          };
        Ue(ee, ie => {
          Fe().owned ? ie(fe, !1) : ie(te)
        })
      }
      A(Ae), A(Ke), Xe((ie, Se) => {
        ve(tt, Fe().flag), ve(ot, Fe().name), gt = Or(Ae, 1, "mt-3", null, gt, ie), kr(Ae, "data-tip", Se)
      }, [() => ({
        tooltip: !x(mt)
      }), () => Vd()]), H(Le, Ke)
    },
    C = $n.countries.map(Le => ({
      ...Le,
      owned: Et.flagsBitmap.get(Le.id)
    }));
  C.sort((Le, Fe) => Number(Fe.owned) - Number(Le.owned));
  const D = Ln(C),
    N = 110,
    T = $n.products[N];
  let o = at(!1),
    G = at(void 0),
    W = at(void 0);
  var ae = x8(),
    _e = k(ae),
    xe = k(_e);
  h8(xe, {
    class: "size-5.5",
    filled: !0
  }), vi(2), A(_e);
  var K = V(_e, 2),
    Ie = k(K, !0);
  A(K);
  var Ce = V(K, 2);
  gn(Ce, 23, () => D, Le => Le.id, (Le, Fe, mt) => {
    var ut = Kt(),
      Ke = It(ut);
    {
      var ct = tt => {
        g(tt, () => x(Fe))
      };
      Ue(Ke, tt => {
        (x(mt) < 8 || x(o)) && tt(ct)
      })
    }
    H(Le, ut)
  }), A(Ce);
  var De = V(Ce, 2),
    Be = k(De);
  Be.__click = [y8, o];
  var je = k(Be, !0);
  A(Be), A(De), A(ae), Xe(Le => {
    ve(Ie, Le), ve(je, x(o) ? "Show less" : "Show more")
  }, [() => Jb()]), H(w, ae), Rr()
}
rn(["click"]);
var w8 = Pe('<p class="mt-1 text-center text-sm"> </p>'),
  T8 = (w, l) => {
    kg(l, -1)
  },
  C8 = (w, l) => {
    kg(l)
  },
  S8 = (w, l, g) => {
    l(x(g))
  },
  P8 = Pe('<button class="text-base-content/80 absolute left-full top-1/2 ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>'),
  I8 = async (w, l, g, C) => {
    try {
      le(l, !0), await ni.purchase({
        id: g.productId,
        amount: C()
      }), pa.notification1.play(), g.onpurchasecompleted(C())
    } catch (D) {
      $r.error(D.message)
    } finally {
      le(l, !1)
    }
  }, M8 = Pe('<span class="loading loading-spinner center-absolute absolute"></span>'), A8 = Pe('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>');

function Pg(w, l) {
  Dr(l, !0);
  let g = At(l, "amount", 15, 1);
  const C = lt(() => g() * l.unitPrice),
    D = lt(() => Math.floor(l.userDroplets / l.unitPrice));
  let N = at(!1);
  Hr(() => {
    g() < 0 && g(0)
  });
  var T = A8(),
    o = k(T),
    G = k(o);
  tn(G, () => l.icon ?? ma), A(o);
  var W = V(o, 2),
    ae = k(W, !0);
  A(W);
  var _e = V(W, 2);
  {
    var xe = Re => {
      var ot = w8(),
        rt = k(ot, !0);
      A(ot), Xe(() => ve(rt, l.subtitle)), H(Re, ot)
    };
    Ue(_e, Re => {
      l.subtitle && Re(xe)
    })
  }
  var K = V(_e, 2),
    Ie = k(K);
  Ie.__click = [T8, g];
  var Ce = V(Ie, 2);
  es(Ce);
  var De = V(Ce, 2);
  De.__click = [C8, g];
  var Be = V(De, 2);
  {
    var je = Re => {
      var ot = P8();
      ot.__click = [S8, g, D], H(Re, ot)
    };
    Ue(Be, Re => {
      g() < x(D) && Re(je)
    })
  }
  A(K);
  var Le = V(K, 2);
  let Fe;
  var mt = k(Le);
  mt.__click = [I8, N, l, g];
  var ut = k(mt);
  {
    var Ke = Re => {
      var ot = M8();
      H(Re, ot)
    };
    Ue(ut, Re => {
      x(N) && Re(Ke)
    })
  }
  var ct = V(ut, 2);
  Nd(ct, {
    class: "size-4"
  });
  var tt = V(ct);
  vi(), A(mt), A(Le), A(T), Xe((Re, ot, rt, Qe) => {
    ve(ae, Re), De.disabled = g() >= x(D), kr(Le, "data-tip", ot), Fe = Or(Le, 1, "", null, Fe, rt), mt.disabled = l.userDroplets < x(C) || x(N) || !g(), ve(tt, ` ${Qe??""} `)
  }, [() => l.title(g()), () => Vd(), () => ({
    tooltip: l.userDroplets < x(C)
  }), () => x(C).toLocaleString("en-US")]), Gf(Ce, g), H(w, T), Rr()
}
rn(["click"]);
var k8 = Cr('<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>');

function E8(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = k8();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var z8 = Cr('<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>');

function zv(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = z8();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var L8 = Cr('<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>');

function D8(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = L8();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var R8 = Cr('<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>');

function B8(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = R8();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var F8 = Pe('<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost">âœ•</button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>'),
  O8 = Pe('<span class="center-absolute absolute"><!></span>'),
  N8 = Pe('<dialog class="modal"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function j8(w, l) {
  Dr(l, !0);
  let g = At(l, "open", 15),
    C = at(void 0),
    D = at(Ln({
      name: ug(),
      prev: 1e3,
      new: 1e5
    }));
  zi(() => {
    const Me = nt => {
      nt.key === "Escape" && g(!1)
    };
    return document.addEventListener("keydown", Me), () => document.removeEventListener("keydown", Me)
  });
  const N = {
      id: 70,
      product: $n.products[70]
    },
    T = {
      id: 80,
      product: $n.products[80]
    },
    o = {
      product: $n.products[120]
    };
  var G = N8(),
    W = It(G),
    ae = k(W),
    _e = k(ae);
  {
    var xe = Me => {
      var nt = F8(),
        Ye = k(nt),
        wt = k(Ye),
        zt = k(wt);
      zv(zt, {
        class: "size-8"
      });
      var Nt = V(zt, 2),
        st = k(Nt, !0);
      A(Nt);
      var Tt = V(Nt, 2),
        Ct = k(Tt);
      {
        let Ht = lt(() => {
          var pt;
          return ((pt = Et.data) == null ? void 0 : pt.droplets) ?? 0
        });
        Ng(Ct, {
          get value() {
            return x(Ht)
          }
        })
      }
      A(Tt), vi(2), A(wt), A(Ye), Gn(Ye, () => l8);
      var yt = V(Ye, 2),
        Mt = k(yt),
        St = k(Mt),
        ht = k(St);
      E8(ht, {
        class: "size-5.5",
        filled: !0
      });
      var Lt = V(ht, 2),
        tr = k(Lt, !0);
      A(Lt), A(St);
      var Jt = V(St, 2),
        dr = k(Jt, !0);
      A(Jt);
      var nr = V(Jt, 2),
        Bt = k(nr);
      {
        const Ht = bt => {
          B8(bt, {
            class: "text-primary size-26"
          })
        };
        let pt = lt(() => eb());
        Pg(Bt, {
          get productId() {
            return N.id
          },
          title: bt => Y1({
            amount: N.product.items[0].amount * bt
          }),
          get subtitle() {
            return x(pt)
          },
          get unitPrice() {
            return N.product.price
          },
          get userDroplets() {
            return Et.data.droplets
          },
          onpurchasecompleted: async bt => {
            var qr, Gr, mr, Er, ai;
            const ar = (Gr = (qr = Et.data) == null ? void 0 : qr.charges) == null ? void 0 : Gr.max;
            await Et.refresh();
            const jr = (Er = (mr = Et.data) == null ? void 0 : mr.charges) == null ? void 0 : Er.max;
            ar !== void 0 && jr !== void 0 && (le(D, {
              name: ug(),
              prev: ar,
              new: jr
            }, !0), (ai = x(C)) == null || ai.show())
          },
          icon: Ht,
          $$slots: {
            icon: !0
          }
        })
      }
      var pr = V(Bt, 2);
      {
        const Ht = bt => {
          Mv(bt, {
            class: "text-primary my-3 size-20"
          })
        };
        let pt = lt(() => V1());
        Pg(pr, {
          get productId() {
            return T.id
          },
          title: bt => Zw({
            amount: T.product.items[0].amount * bt
          }),
          get subtitle() {
            return x(pt)
          },
          get unitPrice() {
            return T.product.price
          },
          get userDroplets() {
            return Et.data.droplets
          },
          onpurchasecompleted: async bt => {
            var jr, qr, Gr;
            const ar = (qr = (jr = Et.data) == null ? void 0 : jr.charges) == null ? void 0 : qr.count;
            await Et.refresh(), ar !== void 0 && (le(D, {
              name: qw(),
              prev: Math.floor(ar),
              new: Math.floor(ar + T.product.items[0].amount * bt)
            }, !0), (Gr = x(C)) == null || Gr.show())
          },
          icon: Ht,
          $$slots: {
            icon: !0
          }
        })
      }
      A(nr), A(Mt);
      var gr = V(Mt, 2),
        Sr = k(gr),
        Vr = k(Sr);
      Zd(Vr, {
        class: "size-5.5",
        filled: !0
      });
      var ur = V(Vr, 2),
        Pr = k(ur, !0);
      A(ur), A(Sr);
      var Ir = V(Sr, 2),
        Mr = k(Ir),
        Nr = k(Mr),
        ce = k(Nr),
        F = k(ce),
        q = k(F);
      jg(q, {
        get userId() {
          return Et.data.id
        },
        get level() {
          return Et.data.level
        },
        get pictureUrl() {
          return Et.data.picture
        }
      }), A(F), A(ce), A(Nr);
      var $ = V(Nr, 2),
        X = k($, !0);
      A($);
      var oe = V($, 2),
        me = k(oe, !0);
      A(oe);
      var Ee = V(oe, 2);
      let Te;
      var Ze = k(Ee),
        it = k(Ze),
        $e = k(it);
      Nd($e, {
        class: "size-4"
      });
      var kt = V($e);
      vi(), A(it), A(Ze), A(Ee), A(Mr), A(Ir), A(gr);
      var ye = V(gr, 2),
        Xt = k(ye);
      b8(Xt, {}), A(ye), A(yt), A(nt), Xe((Ht, pt, bt, ar, jr, qr, Gr, mr, Er) => {
        ve(st, Ht), ve(tr, pt), ve(dr, bt), ve(Pr, ar), ve(X, jr), ve(me, qr), kr(Ee, "data-tip", Gr), Te = Or(Ee, 1, "", null, Te, mr), it.disabled = Et.data.droplets < o.product.price, ve(kt, ` ${Er??""} `)
      }, [() => Zg(), () => $1(), () => W1(), () => Xb(), () => ib(), () => sb(), () => Vd(), () => ({
        tooltip: Et.data.droplets < o.product.price
      }), () => o.product.price.toLocaleString("en-US")]), zn(2, nt, () => ea), H(Me, nt)
    };
    Ue(_e, Me => {
      Et.data && g() && Me(xe)
    })
  }
  A(ae);
  var K = V(ae, 2),
    Ie = k(K),
    Ce = k(Ie, !0);
  A(Ie), A(K), A(W), Gn(W, () => Me => {
    Hr(() => {
      g() ? Me.show() : Me.close()
    })
  });
  var De = V(W, 2),
    Be = k(De),
    je = k(Be),
    Le = k(je),
    Fe = k(Le, !0);
  A(Le);
  var mt = V(Le, 2),
    ut = k(mt),
    Ke = k(ut),
    ct = V(Ke),
    tt = k(ct);
  A(ct), A(ut);
  var Re = V(ut, 2),
    ot = k(Re);
  D8(ot, {
    class: "size-5"
  }), A(Re);
  var rt = V(Re, 2),
    Qe = k(rt, !0);
  A(rt), A(mt);
  var Ae = V(mt, 2),
    gt = k(Ae),
    ee = k(gt),
    te = V(ee);
  Cu(te, () => x(D).new, Me => {
    var nt = O8(),
      Ye = k(nt);
    um(Ye, {}), A(nt), H(Me, nt)
  }), A(gt), A(Ae), A(je), A(Be);
  var fe = V(Be, 2),
    ie = k(fe),
    Se = k(ie, !0);
  A(ie), A(fe), A(De), Ds(De, Me => le(C, Me), () => x(C)), Xe((Me, nt, Ye) => {
    ve(Ce, Me), ve(Fe, x(D).name), ve(Ke, `${x(D).prev??""} `), ve(tt, `(+${x(D).new-x(D).prev})`), ve(Qe, x(D).new), ve(ee, `${nt??""} `), ve(Se, Ye)
  }, [() => ec(), () => ec(), () => ec()]), Pn("close", W, () => g(!1)), H(w, G), Rr()
}
var q8 = Cr('<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>');

function V8(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = q8();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var U8 = Cr('<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>');

function Z8(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = U8();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var $8 = Cr('<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>');

function G8(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = $8();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var H8 = Cr('<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>');

function W8(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = H8();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var X8 = Cr('<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>');

function K8(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = X8();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var Y8 = Cr('<svg><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"></path></svg>');

function J8(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = Y8();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}
var Q8 = Cr('<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>');

function ez(w, l) {
  let g = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var C = Q8();
  er(C, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...g
  })), H(w, C)
}

function pf(w) {
  const l = document.createElement("img");
  return l.src = w, new Promise((g, C) => {
    l.addEventListener("load", () => {
      g(l)
    }), l.addEventListener("error", D => {
      C(D)
    })
  })
}

function tz(w) {
  const l = document.createElement("canvas");
  l.width = w.naturalWidth, l.height = w.naturalHeight;
  const g = l.getContext("2d");
  return g == null || g.drawImage(w, 0, 0), l
}

function rz(w, l, g) {
  return w < l ? l : w > g ? g : w
}

function iz(w, l) {
  const g = 10 ** l;
  return Math.round(w * g) / g
}
var nz = Pe('<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>', 1),
  az = (w, l) => {
    le(l, !x(l))
  },
  sz = Pe("<button><!></button>"),
  oz = async (w, l, g, C) => {
    var D;
    x(l) || le(l, await new Promise((N, T) => {
      navigator.geolocation.getCurrentPosition(o => {
        N(o)
      }, o => {
        T(o)
      })
    })), x(l) && (Ja({
      lat: x(l).coords.latitude,
      lng: x(l).coords.longitude
    }, x(g)), (D = x(C)) == null || D.flyTo({
      center: {
        lat: x(l).coords.latitude,
        lng: x(l).coords.longitude
      },
      zoom: 16.5
    }))
  }, lz = Pe('<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>'), cz = Pe('<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>'), uz = (w, l, g, C) => {
    var D;
    le(l, !0), x(g) && Ja((D = x(g)) == null ? void 0 : D.getCenter(), x(C))
  }, hz = Pe('<button class="btn btn-primary shadow-xl"> </button>'), dz = Pe('<a class="badge badge-secondary absolute -left-2 top-0 -translate-x-full translate-y-1/2 font-semibold" target="_blank"><!></a>'), pz = Pe('<div class="relative"><!> <!></div>'), fz = (w, l, g, C) => {
    var N;
    le(l, !0);
    const D = (N = x(g)) == null ? void 0 : N.getCenter();
    D && Ja(D, x(C))
  }, mz = Pe('<button class="btn btn-square shadow-md"><!></button>'), _z = (w, l) => {
    le(l, !0)
  }, gz = Pe('<button class="btn btn-square relative shadow-md"><!></button>'), vz = (w, l) => {
    le(l, !0)
  }, yz = Pe('<button class="btn btn-square relative shadow-md"><!></button>'), xz = Pe('<div class="flex flex-col items-center gap-3"><!> <!> <!> <!></div>'), bz = (w, l) => {
    le(l, !x(l))
  }, wz = Pe('<div class="flex flex-col gap-3"><button><!></button></div>'), Tz = Pe('<div class="z-100 absolute bottom-1 left-1/2 -translate-x-1/2"><!></div>'), Cz = (w, l) => {
    le(l, !0)
  }, Sz = Pe('<button class="btn btn-sm btn-circle"><!></button>'), Pz = (w, l) => {
    var g;
    (g = x(l)) == null || g.zoomIn()
  }, Iz = (w, l) => {
    var g;
    (g = x(l)) == null || g.zoomOut()
  }, Mz = Pe('<button class="btn btn-sm btn-circle"><!></button>'), Az = () => {
    window.location.replace(fa.url.origin)
  }, kz = Pe('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>'), Ez = (w, l) => {
    x(l) && Ho.goToPrev(x(l))
  }, zz = Pe('<button class="btn btn-sm btn-circle"><!></button>'), Lz = Pe('<div class="btn btn-sm btn-error w-max cursor-auto text-nowrap text-xs sm:text-base"><!> </div>'), Dz = (w, l, g) => {
    var C;
    (C = x(l)) == null || C.flyTo({
      center: x(l).getCenter(),
      zoom: g
    })
  }, Rz = Pe('<button class="btn sm:btn-lg duration text-nowrap text-xs transition-opacity sm:text-base"><!> </button>'), Bz = Pe("<span></span>"), Fz = Pe('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><!></div></div>'), Oz = Pe('<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>'), Nz = (w, l) => {
    le(l, {
      name: "mainMenu"
    }, !0)
  }, jz = Pe('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pb-2 pt-1"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>'), qz = Pe('<div class="disable-pinch-zoom relative h-full overflow-hidden svelte-6wmtgk"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <!> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <div class="max-sm:hidden"><a href="https://www.twitch.tv/directory/category/wplace" class="btn btn-sm btn-circle" target="_blank" title="Livestreams"><!></a></div> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>', 1);

function SL(w, l) {
  Dr(l, !0);
  const g = sg,
    C = jy,
    D = new uc(C),
    N = g - .4,
    T = ZS(fa.url),
    o = T.season ?? ag,
    G = new Map;
  let W = at(void 0),
    ae = at(14.5),
    _e = at(!1);
  const xe = lt(() => {
    var _t;
    return ((_t = Et.data) == null ? void 0 : _t.id) === 401
  });
  let K = at(!1),
    Ie = at(Ln(T.select && T.pos ? {
      name: "pixelSelected",
      latLon: [T.pos.lat, T.pos.lng]
    } : {
      name: "mainMenu"
    }));
  zi(() => {
    De().then(vr => le(W, vr));
    let _t = [0, 0];

    function jt(vr) {
      var _i;
      if (x(W) && x(ae) > g + 1) {
        const {
          lat: Ri,
          lng: Hi
        } = x(W).unproject([vr.clientX, vr.clientY]), Mi = D.latLonToPixels(Ri, Hi, g), Tr = Math.floor(Mi[0]), vn = Math.floor(Mi[1]);
        if (_t[0] !== Tr || _t[1] !== vn) {
          const Qt = D.latLonToPixelBoundsLatLon(Ri, Hi, g),
            Gt = tm(Qt, !0);
          (_i = x(W).getSource(Le)) == null || _i.setCoordinates(Gt), _t = [Tr, vn]
        }
      }
    }
    return window.addEventListener("mousemove", jt), () => {
      var vr;
      (vr = x(W)) == null || vr.remove(), window.removeEventListener("mousemove", jt), Ce && clearInterval(Ce), ff()
    }
  });
  let Ce;
  async function De() {
    const _t = T.pos ? {
      ...T.pos,
      zoom: x(ae)
    } : await DS();
    T.zoom !== void 0 && (_t.zoom = T.zoom);
    const jt = await new Promise(Mi => {
      const Tr = new yd.Map({
        style: "https://maps.wplace.live/styles/liberty",
        center: _t,
        zoom: _t.zoom,
        container: "map",
        dragRotate: !1,
        doubleClickZoom: !1,
        pitch: 0,
        maxPitch: 0,
        attributionControl: !1
      });
      Tr.touchZoomRotate.disableRotation(), Tr.on("style.load", () => {
        Tr == null || Tr.setLayoutProperty("poi_transit", "visibility", "none"), Tr == null || Tr.setLayoutProperty("poi_r20", "visibility", "none"), Tr == null || Tr.setLayoutProperty("poi_r7", "visibility", "none"), Tr == null || Tr.setLayoutProperty("poi_r1", "visibility", "none"), Tr == null || Tr.setLayoutProperty("building", "visibility", "none"), Tr == null || Tr.setLayoutProperty("building-3d", "visibility", "none"), Tr == null || Tr.setLayoutProperty("landuse_pitch", "visibility", "none"), Tr == null || Tr.setLayoutProperty("landuse_hospital", "visibility", "none"), Tr == null || Tr.setLayoutProperty("landuse_school", "visibility", "none"), Tr == null || Tr.setLayoutProperty("landuse_residential", "visibility", "none"), Tr == null || Tr.setLayoutProperty("waterway_tunnel", "visibility", "none"), Tr == null || Tr.setFilter("water", ["all", ["!=", "brunnel", "tunnel"],
          ["!=", "class", "swimming_pool"]
        ]), Mi(Tr)
      })
    });
    je(jt), Ke();
    const vr = $n.refreshIntervalMs;

    function _i() {
      let Mi = x(ae) > g + 1.5 ? vr : 2.5 * vr;
      try {
        document.visibilityState === "visible" && je(jt)
      } finally {
        setTimeout(_i, Mi)
      }
    }
    Ce = setTimeout(_i, vr);
    let Ri = x(ae);
    jt.on("zoom", () => {
      le(ae, jt.getZoom(), !0);
      const Mi = iz(x(ae), 1);
      Mi != Ri && (x(Ae) && x(Ae).setOpacity(gt(Ri)), Ri = Mi)
    });
    let Hi = "default";
    return jt.on("dragstart", () => {
      const Mi = jt.getCanvas();
      Hi = Mi.style.cursor, Mi.style.cursor = "move"
    }), jt.on("dragend", () => {
      jt.getCanvas().style.cursor = Hi
    }), jt.on("mouseout", () => {
      ct()
    }), jt.on("click", async Mi => {
      var ei;
      const Tr = Mi.lngLat.lat,
        vn = Mi.lngLat.lng,
        Qt = [Tr, vn];
      if (x(Ie).name === "paintingPixel") return;
      if (x(Ie).name === "selectHq") {
        x(Ie).hq = Qt, (ei = x(ee)) == null || ei.clearAndPlace(Qt);
        return
      }
      const Gt = jt.getZoom();
      if (Gt < N) {
        $r.info(_C());
        return
      }
      Ja({
        lat: Tr,
        lng: vn
      }, Gt), le(Ie, {
        name: "pixelSelected",
        latLon: Qt
      }, !0)
    }), jt
  }
  const Be = "pixel-art-layer";

  function je(_t) {
    const jt = window.innerWidth,
      vr = `${qy}/s${ag}/tiles/{x}/{y}.png`;
    if (G.clear(), !_t.style) return;
    _t.getSource(Be) ? _t.refreshTiles(Be) : _t.addSource(Be, {
      type: "raster",
      tiles: [vr],
      minzoom: g,
      maxzoom: g,
      tileSize: jt > 640 ? 550 : 400
    }), _t.getLayer(Be) || _t.addLayer({
      id: Be,
      type: "raster",
      source: Be,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": x(Re)
      }
    })
  }
  const Le = "pixel-hover",
    Fe = 1e-5,
    mt = [
      [0, 0],
      [Fe, 0],
      [Fe, -Fe],
      [0, -Fe]
    ],
    ut = .4;
  async function Ke() {
    var _t, jt, vr, _i;
    if (!((_t = x(W)) != null && _t.getSource(Le))) {
      const Ri = tz(await pf(zS));
      (jt = x(W)) == null || jt.addSource(Le, {
        type: "canvas",
        canvas: Ri,
        coordinates: mt
      })
    }(vr = x(W)) != null && vr.getLayer(Le) || (_i = x(W)) == null || _i.addLayer({
      id: Le,
      type: "raster",
      source: Le,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": ut
      }
    })
  }

  function ct() {
    var _t, jt;
    (jt = (_t = x(W)) == null ? void 0 : _t.getSource(Le)) == null || jt.setCoordinates(mt)
  }
  let tt = at(Ln(T.opaque ?? !0)),
    Re = lt(() => x(tt) ? 1 : .1);
  Hr(() => {
    var _t;
    (_t = x(W)) != null && _t.getLayer(Be) && x(W).setPaintProperty(Be, "raster-opacity", x(Re))
  });
  let ot = at(void 0),
    rt = at(void 0),
    Qe = at(void 0);
  zi(() => (navigator.permissions.query({
    name: "geolocation"
  }).then(_t => {
    _t.state === "granted" && le(Qe, navigator.geolocation.watchPosition(jt => {
      le(ot, jt)
    }, jt => {
      le(rt, jt)
    }, {
      enableHighAccuracy: !1,
      maximumAge: 1e3,
      timeout: 6e3
    }), !0)
  }), () => {
    x(Qe) && navigator.geolocation.clearWatch(x(Qe))
  }));
  let Ae = at(void 0);
  hc(() => [x(ot), x(W)], () => {
    var _t, jt;
    if (x(ot) && x(W)) {
      const vr = {
          lat: x(ot).coords.latitude,
          lng: x(ot).coords.longitude
        },
        _i = gt(x(ae));
      if (!x(Ae)) {
        const Ri = document.createElement("div");
        Ri.classList.add("maplibregl-user-location-dot"), Ri.classList.add("cursor-auto"), le(Ae, new yd.Marker({
          element: Ri,
          opacity: _i
        }).setLngLat(vr).addTo(x(W)))
      }(jt = (_t = x(Ae)) == null ? void 0 : _t.setLngLat(vr)) == null || jt.setOpacity(_i)
    }
  });

  function gt(_t) {
    return _t < g ? "1.0" : rz((_t - g) * .2, .5, 1).toFixed(2)
  }
  let ee = at(void 0);
  Hr(() => {
    var _t;
    x(W) && ((_t = Go(() => x(ee))) == null || _t.clear(), pf(hg).then(jt => {
      le(ee, new pg({
        id: "select-crosshair",
        map: x(W),
        tileSize: C,
        zoom: g,
        img: jt,
        markerFn: () => {
          const vr = new yd.Marker({
            color: "#0069ff"
          });
          return vr.addClassName("z-20"), vr
        }
      }))
    }))
  });
  let te = at(void 0);
  Hr(() => {
    var _t;
    x(W) && ((_t = Go(() => x(ee))) == null || _t.clear(), pf(hg).then(jt => {
      le(te, new pg({
        id: "paint-crosshair",
        map: x(W),
        tileSize: C,
        zoom: g,
        img: jt
      }))
    }))
  });
  let fe = at(!1),
    ie = at(!1),
    Se = at(!1),
    Me = at(!!T.newUser),
    nt = at(!1),
    Ye = at(!!T.alliance),
    wt = at(!1);
  const zt = "void-message-2";
  let Nt = at(!1);
  Hr(() => {
    const _t = localStorage.getItem(zt);
    Et.data && !_t && (le(Nt, !0), localStorage.setItem(zt, "true"))
  });
  let st = at(!1),
    Tt = at(Ln(fa.url)),
    Ct = at(Ln({
      cityId: 0,
      countryId: 1,
      id: 0,
      name: "None",
      number: 1
    })),
    yt = at(!1);
  const Mt = "view-rules";
  let St = !1;
  Hr(() => {
    Et.data && (!St && Et.data.pixelsPainted > 1 && (localStorage.getItem(Mt) || (le(yt, !0), localStorage.setItem(Mt, "true"))), St = !0)
  });
  let ht = at(!1);
  Hr(() => {
    var _t;
    le(ht, !!((_t = Et.data) != null && _t.needsPhoneVerification))
  });
  let Lt = at([]),
    tr = lt(() => x(ae) < N ? "1.0" : x(ae) < N + 2 ? "0.5" : "0.3");
  Hr(() => {
    var jt;
    const _t = (jt = Et.data) == null ? void 0 : jt.favoriteLocations;
    if (_t && x(W)) {
      for (const vr of Go(() => x(Lt))) vr.remove();
      le(Lt, _t.map(vr => {
        const _i = document.createElement("div");
        _i.classList.add("text-yellow-400"), _i.classList.add("cursor-pointer"), _i.classList.add("z-10"), _i.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`;
        const Ri = {
          lat: vr.latitude,
          lng: vr.longitude
        };
        return _i.addEventListener("click", Mi => {
          Mi.stopPropagation(), Jt([vr.latitude, vr.longitude])
        }), new yd.Marker({
          element: _i,
          opacity: x(tr)
        }).setLngLat(Ri).addTo(x(W))
      }))
    }
  });

  function Jt(_t) {
    var vr;
    const jt = {
      lat: _t[0],
      lng: _t[1]
    };
    (vr = x(W)) == null || vr.flyTo({
      center: jt,
      zoom: Math.max(x(ae), 15)
    }), Ja(jt, x(ae)), le(Ie, {
      name: "pixelSelected",
      latLon: [jt.lat, jt.lng]
    }, !0)
  }
  Hr(() => {
    if (x(Ie).name === "paintingPixel")
      for (const _t of x(Lt)) _t.addClassName("hidden");
    else
      for (const _t of x(Lt)) _t.removeClassName("hidden"), _t.setOpacity(x(tr))
  });
  let dr = Number.MAX_VALUE;
  Hr(() => {
    if (Et.charges !== void 0 && Et.data) {
      const _t = Et.data.charges.max,
        jt = Et.charges;
      dr < _t && jt >= _t && pa.notification1.play(), dr = Et.charges
    }
  });
  let nr = at(!1),
    Bt = Date.now();
  zi(() => {
    const _t = US(),
      jt = () => {
        var _i;
        if (!document.hidden && Date.now() - Bt > 30 * Yl.min) {
          if (_t) {
            const Hi = (_i = x(W)) == null ? void 0 : _i.getCenter();
            Hi && Ja(Hi, x(ae)), window.location.replace(fa.url.origin)
          } else Et.refresh();
          Bt = Date.now()
        }
      };
    return document.addEventListener("visibilitychange", jt), () => document.removeEventListener("visibilitychange", jt)
  }), zi(() => {
    function _t() {
      ni.online = !0
    }
    window.addEventListener("online", _t);

    function jt() {
      ni.online = !1
    }
    return window.addEventListener("offline", jt), () => {
      window.removeEventListener("online", _t), window.removeEventListener("offline", jt)
    }
  }), Hr(() => {
    if (!ni.online) {
      const _t = setInterval(() => {
        ni.health().then(() => {
          ni.online = !0, !Et.data && !Et.loading && Et.refresh()
        })
      }, 5e3);
      return () => {
        clearInterval(_t)
      }
    }
  }), zi(() => {
    function _t(jt) {
      jt.data.type && x(W) && je(x(W))
    }
    return navigator.serviceWorker.addEventListener("message", _t), () => {
      navigator.serviceWorker.removeEventListener("message", _t)
    }
  });
  let pr = at(!1),
    gr = at("report-user"),
    Sr = at(void 0),
    Vr = at(void 0),
    ur = at(void 0),
    Pr = at(0);
  var Ir = qz();
  Oy(_t => {
    var jt = nz();
    Fy.title = "Wplace - Paint the world", vi(6), H(_t, jt)
  });
  var Mr = It(Ir);
  {
    const _t = Qt => {
        var Gt = sz();
        Gt.__click = [az, tt];
        var ei = k(Gt);
        {
          let ri = lt(() => !x(tt));
          Av(ei, {
            class: "size-5",
            get filled() {
              return x(ri)
            }
          })
        }
        A(Gt), Xe(ri => {
          kr(Gt, "title", ri), Or(Gt, 1, ao({
            "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
            "text-base-content/80": x(tt),
            "btn-primary btn-soft": !x(tt)
          }))
        }, [() => Gg()]), H(Qt, Gt)
      },
      jt = Qt => {
        var Gt = cz();
        Gt.__click = [oz, ot, ae, W];
        var ei = k(Gt);
        {
          var ri = ui => {
              W8(ui, {
                class: "size-5.5 fill-blue-800"
              })
            },
            gi = ui => {
              var fi = lz(),
                Ar = k(fi);
              G8(Ar, {
                class: "size-5.5 fill-red-400"
              }), vi(2), A(fi), H(ui, fi)
            };
          Ue(ei, ui => {
            x(ot) ? ui(ri) : ui(gi, !1)
          })
        }
        A(Gt), Xe(ui => kr(Gt, "title", ui), [() => i1()]), H(Qt, Gt)
      };
    var Nr = V(k(Mr), 2);
    let vr;
    var ce = k(Nr);
    let _i;
    var F = k(ce);
    {
      var q = Qt => {
          var Gt = hz();
          Gt.__click = [uz, fe, W, ae];
          var ei = k(Gt, !0);
          A(Gt), Xe(ri => ve(ei, ri), [() => wx()]), H(Qt, Gt)
        },
        $ = Qt => {
          var Gt = Kt(),
            ei = It(Gt);
          {
            var ri = gi => {
              var ui = pz(),
                fi = k(ui);
              {
                var Ar = hi => {
                  var Jr = dz(),
                    ti = k(Jr);
                  {
                    var br = Ni => {
                        var cn = On("MOD");
                        H(Ni, cn)
                      },
                      Yi = Ni => {
                        var cn = Kt(),
                          Ji = It(cn);
                        {
                          var Ui = Ci => {
                              var ci = On("GM");
                              H(Ci, ci)
                            },
                            Qi = Ci => {
                              var ci = On("ADMIN");
                              H(Ci, ci)
                            };
                          Ue(Ji, Ci => {
                            var ci;
                            ((ci = Et.data) == null ? void 0 : ci.role) === "global_moderator" ? Ci(Ui): Ci(Qi, !1)
                          }, !0)
                        }
                        H(Ni, cn)
                      };
                    Ue(ti, Ni => {
                      var cn;
                      ((cn = Et.data) == null ? void 0 : cn.role) === "moderator" ? Ni(br): Ni(Yi, !1)
                    })
                  }
                  A(Jr), Xe(() => kr(Jr, "href", `${fa.url.origin??""}/moderation`)), H(hi, Jr)
                };
                Ue(fi, hi => {
                  var Jr;
                  Ad((Jr = Et.data) == null ? void 0 : Jr.role, ["admin", "moderator", "global_moderator"]) && hi(Ar)
                })
              }
              var Bi = V(fi, 2);
              lE(Bi, {
                get user() {
                  return Et
                },
                onlogout: () => {
                  le(Ie, {
                    name: "mainMenu"
                  }, !0)
                },
                onclickleaderboard: () => {
                  le(Se, !0)
                },
                onclickshop: () => {
                  var Jr;
                  le(ie, !0);
                  const hi = (Jr = x(W)) == null ? void 0 : Jr.getCenter();
                  hi && Ja(hi, x(ae))
                }
              }), A(ui), zn(3, ui, () => ea, () => ({
                duration: 150
              })), H(gi, ui)
            };
            Ue(ei, gi => {
              Et.data && x(W) && x(Ie).name !== "paintingPixel" && gi(ri)
            }, !0)
          }
          H(Qt, Gt)
        };
      Ue(F, Qt => {
        !Et.loading && !Et.data ? Qt(q) : Qt($, !1)
      })
    }
    var X = V(F, 2);
    {
      var oe = Qt => {
          var Gt = xz(),
            ei = k(Gt);
          {
            var ri = Bi => {
              hf(Bi, {
                key: "shop-profile-picture",
                children: (hi, Jr) => {
                  var ti = mz();
                  ti.__click = [fz, ie, W, ae];
                  var br = k(ti);
                  zv(br, {
                    class: "size-5"
                  }), A(ti), Xe(Yi => kr(ti, "title", Yi), [() => Zg()]), H(hi, ti)
                },
                $$slots: {
                  default: !0
                }
              })
            };
            Ue(ei, Bi => {
              Et.data && Bi(ri)
            })
          }
          var gi = V(ei, 2);
          {
            var ui = Bi => {
              var hi = gz();
              hi.__click = [_z, Ye];
              var Jr = k(hi);
              $d(Jr, {
                class: "size-5"
              }), A(hi), Xe(ti => kr(hi, "title", ti), [() => qd()]), H(Bi, hi)
            };
            Ue(gi, Bi => {
              Et.data && Bi(ui)
            })
          }
          var fi = V(gi, 2);
          mE(fi, {
            get map() {
              return x(W)
            },
            get season() {
              return o
            }
          });
          var Ar = V(fi, 2);
          hf(Ar, {
            key: "region-leaderboard",
            children: (Bi, hi) => {
              var Jr = yz();
              Jr.__click = [vz, Se];
              var ti = k(Jr);
              Sv(ti, {
                class: "size-5"
              }), A(Jr), Xe(br => kr(Jr, "title", br), [() => Xf()]), H(Bi, Jr)
            },
            $$slots: {
              default: !0
            }
          }), A(Gt), zn(3, Gt, () => ea, () => ({
            duration: 150
          })), H(Qt, Gt)
        },
        me = Qt => {
          var Gt = Kt(),
            ei = It(Gt);
          {
            var ri = gi => {
              var ui = wz(),
                fi = k(ui);
              let Ar;
              fi.__click = [bz, _e];
              var Bi = k(fi);
              {
                var hi = ti => {
                    qf(ti, {
                      class: "size-5"
                    })
                  },
                  Jr = ti => {
                    Ed(ti, {
                      class: "size-5"
                    })
                  };
                Ue(Bi, ti => {
                  x(_e) ? ti(hi) : ti(Jr, !1)
                })
              }
              A(fi), A(ui), Xe((ti, br) => {
                kr(fi, "title", ti), Ar = Or(fi, 1, "btn btn-square not-touchscreen:hidden shadow-md", null, Ar, br)
              }, [() => x(_e) ? Ex() : Dx(), () => ({
                "btn-primary": x(_e)
              })]), zn(1, ui, () => ea, () => ({
                delay: 150,
                duration: 150
              })), H(gi, ui)
            };
            Ue(ei, gi => {
              x(W) && x(Ie).name === "paintingPixel" && gi(ri)
            }, !0)
          }
          H(Qt, Gt)
        };
      Ue(X, Qt => {
        x(W) && x(Ie).name !== "paintingPixel" ? Qt(oe) : Qt(me, !1)
      })
    }
    A(ce), A(Nr);
    var Ee = V(Nr, 2);
    {
      var Te = Qt => {
        var Gt = Tz(),
          ei = k(Gt);
        {
          let ri = lt(() => Vy.trim());
          dx(ei, {
            get siteKey() {
              return x(ri)
            },
            refreshExpired: "auto",
            appearance: "interaction-only",
            callback: gi => {
              oa.captcha = {
                token: gi,
                time: Date.now()
              }
            }
          })
        }
        A(Gt), zn(2, Gt, () => ea, () => ({
          duration: 300
        })), H(Qt, Gt)
      };
      Ue(Ee, Qt => {
        (!oa.captcha || oa.now - oa.captcha.time > 180 * 1e3) && Qt(Te)
      })
    }
    var Ze = V(Ee, 2);
    let Ri;
    var it = k(Ze);
    {
      var $e = Qt => {
        hf(Qt, {
          key: "info",
          children: (Gt, ei) => {
            var ri = Sz();
            ri.__click = [Cz, nt];
            var gi = k(ri);
            Z8(gi, {
              class: "size-3.5"
            }), A(ri), Xe(ui => kr(ri, "title", ui), [() => Fx()]), H(Gt, ri)
          },
          $$slots: {
            default: !0
          }
        })
      };
      Ue(it, Qt => {
        x(Ie).name !== "paintingPixel" && Qt($e)
      })
    }
    var kt = V(it, 2),
      ye = k(kt);
    ye.__click = [Pz, W];
    var Xt = V(ye, 2);
    Xt.__click = [Iz, W], A(kt);
    var Ht = V(kt, 2),
      pt = k(Ht),
      bt = k(pt);
    Ug(bt, {
      class: "size-4"
    }), A(pt), A(Ht);
    var ar = V(Ht, 2);
    {
      var jr = Qt => {
        var Gt = Mz(),
          ei = k(Gt);
        ez(ei, {
          class: "size-4",
          onclick: () => {
            le(K, !x(K))
          }
        }), A(Gt), Xe(ri => kr(Gt, "title", ri), [() => Ab()]), H(Qt, Gt)
      };
      Ue(ar, Qt => {
        x(xe) && Qt(jr)
      })
    }
    var qr = V(ar, 2);
    {
      var Gr = Qt => {
        var Gt = kz();
        Gt.__click = [Az];
        var ei = k(Gt);
        fx(ei, {
          class: "size-3"
        }), A(Gt), Xe(ri => kr(Gt, "title", ri), [() => _x()]), H(Qt, Gt)
      };
      Ue(qr, Qt => {
        x(Ie).name !== "paintingPixel" && Qt(Gr)
      })
    }
    var mr = V(qr, 2);
    {
      var Er = Qt => {
        var Gt = zz();
        Gt.__click = [Ez, W];
        var ei = k(Gt);
        J8(ei, {
          class: "size-3"
        }), A(Gt), Xe((ri, gi) => {
          kr(Gt, "title", ri), Gt.disabled = gi
        }, [() => Gx(), () => !Ho.hasPrev()]), zn(1, Gt, () => ea, () => ({
          delay: 1e3,
          duration: 300
        })), zn(2, Gt, () => ea, () => ({
          duration: 300
        })), H(Qt, Gt)
      };
      Ue(mr, Qt => {
        Ho.hasPrev() && x(Ie).name !== "paintingPixel" && Qt(Er)
      })
    }
    A(Ze);
    var ai = V(Ze, 2);
    let Hi;
    var ft = k(ai);
    {
      var yi = Qt => {
        var Gt = Lz(),
          ei = k(Gt);
        mx(ei, {
          class: "size-5"
        });
        var ri = V(ei);
        A(Gt), Xe(gi => ve(ri, ` ${gi??""}`), [() => Xx()]), zn(1, Gt, () => ea, () => ({
          duration: 1e3
        })), zn(2, Gt, () => ea), H(Qt, Gt)
      };
      Ue(ft, Qt => {
        ni.online || Qt(yi)
      })
    }
    var pi = V(ft, 2);
    {
      var In = Qt => {
        var Gt = Rz();
        Gt.__click = [Dz, W, g];
        var ei = k(Gt);
        K8(ei, {
          class: "size-5"
        });
        var ri = V(ei);
        A(Gt), Xe(gi => ve(ri, ` ${gi??""}`), [() => Jx()]), zn(3, Gt, () => ea, () => ({
          duration: 300
        })), H(Qt, Gt)
      };
      Ue(pi, Qt => {
        x(ae) < N && Qt(In)
      })
    }
    A(ai);
    var Pt = V(ai, 2);
    let Mi;
    var We = k(Pt);
    _t(We), A(Pt);
    var Ot = V(Pt, 2);
    let Tr;
    var $t = k(Ot);
    {
      var zr = Qt => {
          Iv(Qt, {
            class: "z-30",
            onclick: () => {
              var Gt;
              (Gt = Et.data) != null && Gt.needsPhoneVerification ? (le(ht, !0), $r.warning(lg())) : Et.charges !== void 0 && Et.charges < 1 ? $r.warning(Q6, {
                icon: Fg
              }) : x(W) && Et.data ? (pa.smallDropplet.play(), le(Ie, {
                name: "paintingPixel"
              }, !0)) : (le(fe, !0), x(W) && Ja(x(W).getCenter(), x(ae)))
            },
            get disabled() {
              return Et.loading
            },
            get loading() {
              return Et.loading
            },
            get charges() {
              return Et.charges
            }
          })
        },
        Wr = Qt => {
          var Gt = Bz();
          H(Qt, Gt)
        };
      Ue($t, Qt => {
        x(Ie).name === "mainMenu" ? Qt(zr) : Qt(Wr, !1)
      })
    }
    A(Ot);
    var li = V(Ot, 2);
    let vn;
    var _r = k(li);
    jt(_r), A(li);
    var Ti = V(li, 2);
    {
      var Pi = Qt => {
        var Gt = Kt(),
          ei = It(Gt);
        {
          var ri = ui => {
              var fi = Fz(),
                Ar = k(fi),
                Bi = k(Ar);
              o8(Bi, {
                get latLon() {
                  return x(Ie).latLon
                },
                get map() {
                  return x(W)
                },
                get crosshair() {
                  return x(ee)
                },
                get pixelInfoCache() {
                  return G
                },
                get season() {
                  return o
                },
                get tileSize() {
                  return C
                },
                get pixelArtZoom() {
                  return g
                },
                get zoom() {
                  return x(ae)
                },
                get opaquePixelArt() {
                  return x(tt)
                },
                onclose: () => le(Ie, {
                  name: "mainMenu"
                }, !0),
                onclickshare: hi => {
                  le(Tt, hi, !0), le(st, !0)
                },
                onclickpaint: ([hi, Jr]) => {
                  var br, Yi, Ni;
                  if (!Et.data) {
                    le(fe, !0);
                    return
                  }
                  if ((br = Et.data) != null && br.needsPhoneVerification) {
                    le(ht, !0), $r.warning(lg());
                    return
                  }
                  if (Et.charges !== void 0 && Et.charges < 1) {
                    $r.warning(s1());
                    return
                  }
                  const ti = rm(D.latLonToPixelBoundsLatLon(hi, Jr, g));
                  (Yi = x(W)) == null || Yi.flyTo({
                    center: {
                      lat: ti[0],
                      lon: ti[1]
                    }
                  }), le(Ie, {
                    name: "paintingPixel",
                    clickedLatLon: [hi, Jr]
                  }, !0), (Ni = x(ee)) == null || Ni.clear()
                },
                onclickregion: hi => {
                  le(Ct, hi, !0), le(wt, !0)
                },
                onclickmodaction: (hi, Jr, ti, br) => {
                  var Yi, Ni, cn;
                  (Yi = x(W)) == null || Yi.setZoom(Math.max(x(ae), g + 2)), (Ni = x(W)) == null || Ni.setCenter({
                    lat: ti[0],
                    lng: ti[1]
                  }), le(Sr, Jr, !0), le(Vr, hi, !0), le(ur, ti, !0), le(Pr, ((cn = x(W)) == null ? void 0 : cn.getZoom()) ?? 0, !0), le(gr, br, !0), le(pr, !0)
                }
              }), A(Ar), A(fi), zn(3, Ar, () => af, () => ({
                duration: 100
              })), H(ui, fi)
            },
            gi = ui => {
              var fi = Kt(),
                Ar = It(fi);
              {
                var Bi = Jr => {
                    var ti = Oz(),
                      br = k(ti),
                      Yi = k(br);
                    tk(Yi, {
                      get map() {
                        return x(W)
                      },
                      get clickedLatLon() {
                        return x(Ie).clickedLatLon
                      },
                      get tileSize() {
                        return C
                      },
                      get tileZoom() {
                        return g
                      },
                      get season() {
                        return o
                      },
                      get zoom() {
                        return x(ae)
                      },
                      get crosshair() {
                        return x(te)
                      },
                      refreshPixelArt: () => x(W) && je(x(W)),
                      hidePixelHover: ct,
                      hoverLayerId: Le,
                      onclose: () => {
                        le(Ie, {
                          name: "mainMenu"
                        }, !0), ct()
                      },
                      get screenLocked() {
                        return x(_e)
                      },
                      set screenLocked(Ni) {
                        le(_e, Ni, !0)
                      },
                      get opaquePixelArt() {
                        return x(tt)
                      },
                      set opaquePixelArt(Ni) {
                        le(tt, Ni, !0)
                      }
                    }), A(br), A(ti), zn(3, br, () => af, () => ({
                      duration: 100
                    })), H(Jr, ti)
                  },
                  hi = Jr => {
                    var ti = Kt(),
                      br = It(ti);
                    {
                      var Yi = Ni => {
                        var cn = jz(),
                          Ji = k(cn),
                          Ui = k(Ji),
                          Qi = k(Ui),
                          Ci = k(Qi),
                          ci = k(Ci);
                        kv(ci, {
                          class: "inline size-4"
                        });
                        var Ko = V(ci);
                        A(Ci);
                        var un = V(Ci, 2);
                        un.__click = [Nz, Ie];
                        var Nn = k(un);
                        pc(Nn, {
                          class: "size-4"
                        }), A(un), A(Qi);
                        var hn = V(Qi, 2),
                          Si = k(hn);
                        Si.__click = async () => {
                          var wr;
                          if (x(Ie).name === "selectHq") {
                            const Ur = x(Ie).hq;
                            if (Ur) try {
                              le(nr, !0), await ni.updateAllianceHeadquarters(Ur[0], Ur[1]), (wr = x(ee)) == null || wr.clear(), le(Ye, !0), le(Ie, {
                                name: "mainMenu"
                              }, !0)
                            } catch (ga) {
                              $r.error(ga.message)
                            } finally {
                              le(nr, !1)
                            }
                          }
                        };
                        var Ua = k(Si);
                        V8(Ua, {
                          class: "size-6"
                        }), A(Si), A(hn), A(Ui), A(Ji), A(cn), Xe(wr => {
                          ve(Ko, ` ${wr??""}`), Si.disabled = x(Ie).hq === void 0 || x(nr)
                        }, [() => S3()]), zn(3, Ji, () => af, () => ({
                          duration: 100
                        })), H(Ni, cn)
                      };
                      Ue(br, Ni => {
                        x(Ie).name === "selectHq" && Ni(Yi)
                      }, !0)
                    }
                    H(Jr, ti)
                  };
                Ue(Ar, Jr => {
                  x(Ie).name === "paintingPixel" && x(te) ? Jr(Bi) : Jr(hi, !1)
                }, !0)
              }
              H(ui, fi)
            };
          Ue(ei, ui => {
            x(Ie).name === "pixelSelected" && x(ee) ? ui(ri) : ui(gi, !1)
          })
        }
        H(Qt, Gt)
      };
      Ue(Ti, Qt => {
        x(W) && Qt(Pi)
      })
    }
    A(Mr), Xe((Qt, Gt, ei, ri, gi, ui, fi, Ar, Bi) => {
      vr = Or(Nr, 1, "absolute right-2 top-2 z-30", null, vr, Qt), _i = Or(ce, 1, "flex flex-col gap-4", null, _i, Gt), Ri = Or(Ze, 1, "absolute left-2 top-2 z-30 flex flex-col gap-3", null, Ri, ei), kr(ye, "title", ri), kr(Xt, "title", gi), Hi = Or(ai, 1, "absolute left-1/2 top-2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2", null, Hi, ui), Mi = Or(Pt, 1, "absolute bottom-3 left-3 z-30", null, Mi, fi), Tr = Or(Ot, 1, "absolute bottom-3 left-1/2 z-30 -translate-x-1/2", null, Tr, Ar), vn = Or(li, 1, "absolute bottom-3 right-3 z-30", null, vn, Bi)
    }, [() => ({
      hidden: x(K)
    }), () => ({
      "items-end": !Et.data,
      "items-center": Et.data
    }), () => ({
      hidden: x(K)
    }), () => jx(), () => Ux(), () => ({
      hidden: x(K)
    }), () => ({
      hidden: x(K)
    }), () => ({
      hidden: x(K)
    }), () => ({
      hidden: x(K)
    })])
  }
  var Li = V(Mr, 2);
  W6(Li, {
    get open() {
      return x(fe)
    },
    set open(_t) {
      le(fe, _t, !0)
    }
  });
  var mi = V(Li, 2);
  j8(mi, {
    get open() {
      return x(ie)
    },
    set open(_t) {
      le(ie, _t, !0)
    }
  });
  var Di = V(mi, 2);
  qI(Di, {
    get open() {
      return x(Me)
    },
    set open(_t) {
      le(Me, _t, !0)
    }
  });
  var rr = V(Di, 2);
  eM(rr, {
    get open() {
      return x(nt)
    },
    set open(_t) {
      le(nt, _t, !0)
    }
  });
  var bi = V(rr, 2);
  OI(bi, {
    get open() {
      return x(yt)
    },
    set open(_t) {
      le(yt, _t, !0)
    }
  });
  var Qr = V(bi, 2);
  $6(Qr, {
    onvisitclick: _t => {
      var jt;
      (jt = x(W)) == null || jt.flyTo({
        center: _t,
        zoom: sg + 1
      }), Ja(_t, x(ae)), Ho.push({
        pos: _t,
        zoom: x(ae)
      }), le(Se, !1)
    },
    get open() {
      return x(Se)
    },
    set open(_t) {
      le(Se, _t, !0)
    }
  });
  var Yr = V(Qr, 2);
  AE(Yr, {
    get region() {
      return x(Ct)
    },
    get open() {
      return x(wt)
    },
    set open(_t) {
      le(wt, _t, !0)
    }
  });
  var la = V(Yr, 2);
  ux(la, {
    get open() {
      return oa.dropletsDialogOpen
    },
    set open(_t) {
      oa.dropletsDialogOpen = _t
    }
  });
  var ln = V(la, 2);
  {
    var ta = _t => {
      yI(_t, {
        onhqchange: () => {
          le(Ie, {
            name: "selectHq"
          }, !0), le(Ye, !1)
        },
        onhqclick: jt => {
          var vr;
          (vr = x(W)) == null || vr.flyTo({
            center: jt,
            zoom: Math.max(x(ae), 15)
          }), le(Ie, {
            name: "pixelSelected",
            latLon: [jt.lat, jt.lng]
          }, !0), le(Ye, !1)
        },
        onlastpixelclick: jt => {
          var vr;
          (vr = x(W)) == null || vr.flyTo({
            center: jt,
            zoom: Math.max(x(ae), 15)
          }), le(Ie, {
            name: "pixelSelected",
            latLon: [jt.lat, jt.lng]
          }, !0), le(Ye, !1)
        },
        get open() {
          return x(Ye)
        },
        set open(jt) {
          le(Ye, jt, !0)
        }
      })
    };
    Ue(ln, _t => {
      x(W) && _t(ta)
    })
  }
  var Oi = V(ln, 2);
  bk(Oi, {
    get open() {
      return x(ht)
    },
    set open(_t) {
      le(ht, _t, !0)
    }
  });
  var Ki = V(Oi, 2);
  {
    var Hn = _t => {
      EI(_t, {
        get url() {
          return x(Tt)
        },
        get map() {
          return x(W)
        },
        hideHover: () => {
          var jt, vr;
          (jt = x(W)) == null || jt.setPaintProperty(Le, "raster-opacity", 0), (vr = x(ee)) == null || vr.setCanvasOpacity(0)
        },
        showHover: () => {
          var jt, vr;
          (jt = x(W)) == null || jt.setPaintProperty(Le, "raster-opacity", ut), (vr = x(ee)) == null || vr.setCanvasOpacity(1)
        },
        get open() {
          return x(st)
        },
        set open(jt) {
          le(st, jt, !0)
        }
      })
    };
    Ue(Ki, _t => {
      x(W) && _t(Hn)
    })
  }
  var Wn = V(Ki, 2);
  {
    var Dn = _t => {
      Yy(_t, {
        get image() {
          return x(Sr)
        },
        get paintedBy() {
          return x(Vr).paintedBy
        },
        get latLon() {
          return x(ur)
        },
        get zoom() {
          return x(Pr)
        },
        get action() {
          return x(gr)
        },
        get open() {
          return x(pr)
        },
        set open(jt) {
          le(pr, jt, !0)
        }
      })
    };
    Ue(Wn, _t => {
      x(Vr) && x(Sr) && x(ur) && _t(Dn)
    })
  }
  H(w, Ir), Rr()
}
rn(["click"]);
export {
  SL as component
};