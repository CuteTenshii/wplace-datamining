var xx = Object.defineProperty;
var bx = Object.getPrototypeOf;
var wx = Reflect.get;
var dv = d => {
  throw TypeError(d)
};
var Cx = (d, a, h) => a in d ? xx(d, a, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: h
}) : d[a] = h;
var Tr = (d, a, h) => Cx(d, typeof a != "symbol" ? a + "" : a, h),
  Jf = (d, a, h) => a.has(d) || dv("Cannot " + h);
var Ye = (d, a, h) => (Jf(d, a, "read from private field"), h ? h.call(d) : a.get(d)),
  Lr = (d, a, h) => a.has(d) ? dv("Cannot add the same private member more than once") : a instanceof WeakSet ? a.add(d) : a.set(d, h),
  ta = (d, a, h, y) => (Jf(d, a, "write to private field"), y ? y.call(d, h) : a.set(d, h), h),
  Nr = (d, a, h) => (Jf(d, a, "access private method"), h);
var pv = (d, a, h) => wx(bx(d), h, a);
import "../chunks/DxmA28w3.js";
import {
  o as An,
  a as Tx,
  s as Hn
} from "../chunks/BEs-7tZm.js";
import {
  ae as Sx,
  b9 as Ix,
  bp as Px,
  bb as kx,
  bq as Mx,
  aJ as Ax,
  br as Ex,
  g as rt,
  bs as fv,
  ac as zx,
  h as x,
  e as re,
  bm as Nu,
  y as di,
  x as Ln,
  p as Ir,
  f as fe,
  d as P,
  r as I,
  s as B,
  u as ht,
  n as en,
  t as Ze,
  z as Zn,
  b as Z,
  c as Pr,
  K as Kr,
  H as xr,
  bn as Hu,
  J as $m,
  L as bl,
  A as or,
  a as pt,
  B as Ii,
  aT as Lx,
  aS as mv,
  aU as Dx,
  aW as r0,
  bt as mo,
  C as ra,
  bu as n0,
  bk as Gm,
  $ as Rx
} from "../chunks/Ceyo7U-X.js";
import {
  s as ce
} from "../chunks/Dvumt-ig.js";
import {
  p as Tt,
  i as Be,
  r as sr,
  s as Ns,
  u as i0
} from "../chunks/DRq6TJot.js";
import {
  h as Bx
} from "../chunks/D9W_UjO4.js";
import {
  r as ya,
  e as pi,
  a as Or,
  g as fp,
  d as lr,
  s as nr,
  f as Bc,
  h as Wu,
  c as ls,
  i as _v
} from "../chunks/DMoiYdRV.js";
import {
  a as yl,
  t as Ni
} from "../chunks/Dx5lPwsl.js";
import {
  g as mp,
  b as Fx
} from "../chunks/CH9wuhnN.js";
import {
  p as ri
} from "../chunks/CepRLJtU.js";
import {
  g as Zi,
  P as Ox,
  b as jx
} from "../chunks/DziFWjYG.js";
import {
  S as Bi,
  a as nn,
  t as Ar,
  u as wt,
  o as Lo,
  p as Nx,
  q as Zx,
  v as Vx,
  y as qx,
  w as Ux,
  e as $x,
  x as Gx,
  z as Wx,
  C as gv,
  P as Xf,
  A as Hx
} from "../chunks/Dmh4HcCd.js";
import {
  c as a0,
  A as Vi,
  a as um,
  g as Yf,
  p as Jx,
  b as Xx
} from "../chunks/DSsyOCd4.js";
import {
  f as xl,
  h as ja,
  t as o0,
  R as s0
} from "../chunks/Dki6XRb-.js";
import {
  h as Pp
} from "../chunks/CHYFRwt3.js";
import {
  b as us
} from "../chunks/1BJpnWZT.js";
import {
  L as l0
} from "../chunks/Daq4qKgz.js";
import {
  g as Fe,
  l as Yx
} from "../chunks/DY2Cg16j.js";
import {
  c as Zh
} from "../chunks/BYYM8cpL.js";
import {
  d as Kx,
  L as Wm,
  p as Hm
} from "../chunks/DW4IdDfD.js";
import {
  c as hm,
  D as c0,
  W as Qx,
  s as eb,
  d as tb,
  l as u0,
  a as rb,
  p as nb,
  r as ib,
  t as ab,
  b as ob,
  R as sb
} from "../chunks/Dzb-jpaL.js";
import {
  e as ai,
  i as kp
} from "../chunks/BOPY34l9.js";
import {
  c as Jm,
  b as Mp,
  a as lb
} from "../chunks/Df63uaVI.js";
import {
  P as fo,
  t as h0
} from "../chunks/qvjTPepg.js";
import {
  l as cb,
  p as Xm,
  m as d0,
  v as ub,
  s as hb
} from "../chunks/IOFa17my.js";
import {
  g as Ri,
  a as Ap,
  c as db,
  b as pb
} from "../chunks/BGU4kMEN.js";
import {
  k as Ju
} from "../chunks/DPMp8fc6.js";
import {
  A as fb,
  c as cs
} from "../chunks/Sj-oIXVQ.js";
import {
  A as p0,
  d as f0,
  D as m0,
  a as Ep,
  r as mb,
  I as vv,
  e as _b,
  c as gb,
  P as _0,
  b as vb
} from "../chunks/DXqJL_AU.js";
import {
  f as va,
  s as ip
} from "../chunks/SVgyMUqc.js";
import {
  C as Ym,
  c as yb
} from "../chunks/CTecLfAZ.js";
import "../chunks/EoCAaXmI.js";
import {
  i as Km
} from "../chunks/CeeJES3w.js";
import {
  L as g0
} from "../chunks/k_ei5sdb.js";
import {
  c as yi
} from "../chunks/DX7bqPRU.js";
import {
  L as xb
} from "../chunks/BoKoTLIS.js";
import {
  _ as bb
} from "../chunks/PcZJNkIF.js";
import {
  c as v0
} from "../chunks/Du_oFhK4.js";
import {
  T as Xu,
  G as _p
} from "../chunks/6OwrfPHz.js";
import {
  C as wb
} from "../chunks/Cr1o1yCt.js";
import {
  R as Cb
} from "../chunks/C8h7hpwP.js";
import {
  W as Tb
} from "../chunks/B4OTSDgm.js";
import {
  r as Sb
} from "../chunks/Bd_M7MTg.js";
(function() {
  try {
    var d = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
    d.SENTRY_RELEASE = {
      id: "1eec49a8880aaf0322f1c231fa7de26d6c5b6e23"
    }
  } catch {}
})();
try {
  (function() {
    var d = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {},
      a = new d.Error().stack;
    a && (d._sentryDebugIds = d._sentryDebugIds || {}, d._sentryDebugIds[a] = "7806bcfe-5cec-4d60-a621-5ad7aa887d37", d._sentryDebugIdIdentifier = "sentry-dbid-7806bcfe-5cec-4d60-a621-5ad7aa887d37")
  })()
} catch {}
const Ib = [];

function Pb(d, a = !1, h = !1) {
  return ap(d, new Map, "", Ib, null, h)
}

function ap(d, a, h, y, k = null, E = !1) {
  if (typeof d == "object" && d !== null) {
    var b = a.get(d);
    if (b !== void 0) return b;
    if (d instanceof Map) return new Map(d);
    if (d instanceof Set) return new Set(d);
    if (Sx(d)) {
      var s = Array(d.length);
      a.set(d, s), k !== null && a.set(k, s);
      for (var F = 0; F < d.length; F += 1) {
        var O = d[F];
        F in d && (s[F] = ap(O, a, h, y, null, E))
      }
      return s
    }
    if (Ix(d) === Px) {
      s = {}, a.set(d, s), k !== null && a.set(k, s);
      for (var G in d) s[G] = ap(d[G], a, h, y, null, E);
      return s
    }
    if (d instanceof Date) return structuredClone(d);
    if (typeof d.toJSON == "function" && !E) return ap(d.toJSON(), a, h, y, d)
  }
  if (d instanceof EventTarget) return d;
  try {
    return structuredClone(d)
  } catch {
    return d
  }
}

function kb() {
  return Symbol(kx)
}

function zp(d, a) {
  Mx(window, ["resize"], () => Ax(() => a(window[d])))
}
const Mb = Ex;
var Mo, Ao, is, xp, po, Vu, op;
const x_ = class x_ extends Map {
  constructor(h) {
    super();
    Lr(this, po);
    Lr(this, Mo, new Map);
    Lr(this, Ao, rt(0));
    Lr(this, is, rt(0));
    Lr(this, xp, fv || -1);
    if (h) {
      for (var [y, k] of h) super.set(y, k);
      Ye(this, is).v = super.size
    }
  }
  has(h) {
    var y = Ye(this, Mo),
      k = y.get(h);
    if (k === void 0) {
      var E = super.get(h);
      if (E !== void 0) k = Nr(this, po, Vu).call(this, 0), y.set(h, k);
      else return x(Ye(this, Ao)), !1
    }
    return x(k), !0
  }
  forEach(h, y) {
    Nr(this, po, op).call(this), super.forEach(h, y)
  }
  get(h) {
    var y = Ye(this, Mo),
      k = y.get(h);
    if (k === void 0) {
      var E = super.get(h);
      if (E !== void 0) k = Nr(this, po, Vu).call(this, 0), y.set(h, k);
      else {
        x(Ye(this, Ao));
        return
      }
    }
    return x(k), super.get(h)
  }
  set(h, y) {
    var X;
    var k = Ye(this, Mo),
      E = k.get(h),
      b = super.get(h),
      s = super.set(h, y),
      F = Ye(this, Ao);
    if (E === void 0) E = Nr(this, po, Vu).call(this, 0), k.set(h, E), re(Ye(this, is), super.size), Nu(F);
    else if (b !== y) {
      Nu(E);
      var O = F.reactions === null ? null : new Set(F.reactions),
        G = O === null || !((X = E.reactions) != null && X.every(Q => O.has(Q)));
      G && Nu(F)
    }
    return s
  }
  delete(h) {
    var y = Ye(this, Mo),
      k = y.get(h),
      E = super.delete(h);
    return k !== void 0 && (y.delete(h), re(Ye(this, is), super.size), re(k, -1), Nu(Ye(this, Ao))), E
  }
  clear() {
    if (super.size !== 0) {
      super.clear();
      var h = Ye(this, Mo);
      re(Ye(this, is), 0);
      for (var y of h.values()) re(y, -1);
      Nu(Ye(this, Ao)), h.clear()
    }
  }
  keys() {
    return x(Ye(this, Ao)), super.keys()
  }
  values() {
    return Nr(this, po, op).call(this), super.values()
  }
  entries() {
    return Nr(this, po, op).call(this), super.entries()
  } [Symbol.iterator]() {
    return this.entries()
  }
  get size() {
    return x(Ye(this, is)), super.size
  }
};
Mo = new WeakMap, Ao = new WeakMap, is = new WeakMap, xp = new WeakMap, po = new WeakSet, Vu = function(h) {
  return fv === Ye(this, xp) ? rt(h) : zx(h)
}, op = function() {
  x(Ye(this, Ao));
  var h = Ye(this, Mo);
  if (Ye(this, is).v !== h.size) {
    for (var y of pv(x_.prototype, this, "keys").call(this))
      if (!h.has(y)) {
        var k = Nr(this, po, Vu).call(this, 0);
        h.set(y, k)
      }
  }
  for ([, k] of Ye(this, Mo)) x(k)
};
let dm = x_;
const Ab = () => "Log in",
  Eb = () => "Entrar",
  zb = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Ab() : Eb(),
  Lb = () => "Store",
  Db = () => "Loja",
  y0 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Lb() : Db(),
  Rb = () => "Alliance",
  Bb = () => "Aliança",
  Lp = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Rb() : Bb(),
  Fb = () => "Leaderboard",
  Ob = () => "Ranking",
  Qm = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Fb() : Ob(),
  jb = () => "Unlock",
  Nb = () => "Destravar",
  Zb = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? jb() : Nb(),
  Vb = () => "Lock",
  qb = () => "Travar",
  Ub = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Vb() : qb(),
  $b = () => "Info",
  Gb = () => "Informações",
  Wb = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? $b() : Gb(),
  Hb = () => "Zoom in",
  Jb = () => "Aumentar zoom",
  Xb = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Hb() : Jb(),
  Yb = () => "Zoom out",
  Kb = () => "Diminuir zoom",
  Qb = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Yb() : Kb(),
  e2 = () => "Previous location",
  t2 = () => "Localização anterior",
  r2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? e2() : t2(),
  n2 = () => "Offline",
  i2 = () => "Offline",
  a2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? n2() : i2(),
  o2 = () => "Zoom in to see the pixels",
  s2 = () => "Amplie para ver os pixels",
  l2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? o2() : s2(),
  c2 = () => "Phone verification required",
  u2 = () => "Verificação de telefone necessária",
  yv = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? c2() : u2(),
  h2 = () => "My location",
  d2 = () => "Minha localização",
  p2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? h2() : d2(),
  f2 = () => "You don't have charges to paint. Wait to recharge.",
  m2 = () => "Você não possui tinta para pintar. Aguarde para carrega-las.",
  _2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? f2() : m2(),
  g2 = () => "Map powered by:",
  v2 = () => "Mapa fornecido por:",
  y2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? g2() : v2(),
  x2 = () => "OpenMapTiles Data from",
  b2 = () => "OpenMapTiles com dados do",
  w2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? x2() : b2(),
  C2 = () => "Overview",
  T2 = () => "Visão Geral",
  S2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? C2() : T2(),
  I2 = () => "How to paint faster",
  P2 = () => "Como pintar mais rápido",
  k2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? I2() : P2(),
  M2 = () => "When painting, click on the button",
  A2 = () => "Quando pintar clique no botão",
  E2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? M2() : A2(),
  z2 = () => "on the top right corner of the screen. This will lock the screen but it'll also enable painting by moving your finger over the map.",
  L2 = () => "no canto superior direito da tela. Isso bloqueará a tela, mas também permitirá pintar movendo o dedo sobre o mapa.",
  D2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? z2() : L2(),
  R2 = () => "Hold",
  B2 = () => "Segure",
  F2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? R2() : B2(),
  O2 = () => "SPACE",
  j2 = () => "Espaço",
  N2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? O2() : j2(),
  Z2 = () => "and move your cursor over the map.",
  V2 = () => "e mova seu cursor sobre o mapa.",
  q2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Z2() : V2(),
  U2 = () => "Explore",
  $2 = () => "Explorar",
  G2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? U2() : $2(),
  W2 = () => "Recharge paint charges",
  H2 = () => "Recarga de tinta",
  J2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? W2() : H2(),
  X2 = () => "Items",
  Y2 = () => "Itens",
  K2 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? X2() : Y2(),
  Q2 = () => "Get more charges",
  ew = () => "Recarregue tinta para pintar",
  tw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Q2() : ew(),
  rw = d => `+${d.amount} Max. Charges`,
  nw = d => `+${d.amount} Tinta máxima`,
  iw = (d, a = {}) => (a.locale ?? Fe()) === "en" ? rw(d) : nw(d),
  aw = () => "Increase your maximum paint charges capacity",
  ow = () => "Aumente sua capacidade máxima de tinta",
  sw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? aw() : ow(),
  lw = () => "Profile picture",
  cw = () => "Imagem de perfil",
  uw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? lw() : cw(),
  hw = () => "Add a new 16x16 profile picture",
  dw = () => "Adicionar uma nova imagem de perfil 16x16",
  pw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? hw() : dw(),
  fw = () => "Not enough droplets",
  mw = () => "Droplets insuficientes",
  Dp = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? fw() : mw(),
  _w = () => "Show profile",
  gw = () => "Exibir perfil",
  vw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? _w() : gw(),
  yw = () => "Menu",
  xw = () => "Menu",
  bw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? yw() : xw(),
  ww = d => `Could not install the app: ${d.error}`,
  Cw = d => `Não pode instalar o app: ${d.error}`,
  Tw = (d, a = {}) => (a.locale ?? Fe()) === "en" ? ww(d) : Cw(d),
  Sw = () => "Install App",
  Iw = () => "Instalar App",
  Pw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Sw() : Iw(),
  kw = () => "Livestreams",
  Mw = () => "Livestreams",
  Aw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? kw() : Mw(),
  Ew = () => "Hide UI",
  zw = () => "Esconder UI",
  Lw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Ew() : zw(),
  Dw = () => "Change picture:",
  Rw = () => "Change picture:",
  Bw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Dw() : Rw(),
  Fw = () => "Show last painted pixel on alliance",
  Ow = () => "Mostrar último pixel pintado na aliança",
  jw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Fw() : Ow(),
  Nw = () => "Delete Account",
  Zw = () => "Deletar Conta",
  pm = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Nw() : Zw(),
  Vw = () => "Are you absolutely sure?",
  qw = () => "Você tem certeza absoluta?",
  Uw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Vw() : qw(),
  $w = () => "This will permanently delete your account and all associated data. This action cannot be undone.",
  Gw = () => "Isso excluirá permanentemente sua conta e todos os dados associados. Esta ação não pode ser desfeita.",
  Ww = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? $w() : Gw(),
  Hw = () => "Profile",
  Jw = () => "Perfil",
  Xw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Hw() : Jw(),
  Yw = () => "Display your country’s flag next to your username. Plus, when painting in regions where you own the corresponding flag, you recover 10% of the charges spent.",
  Kw = () => "Exiba a bandeira do seu país ao lado do seu nome de usuário. Além disso, ao pintar em regiões onde você possui a bandeira correspondente, você recupera 10% das tintas gastas.",
  Qw = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Yw() : Kw(),
  e5 = () => "Does not need to be equipped to provide the bonus",
  t5 = () => "Não precisa estar equipada para obter o bônus",
  r5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? e5() : t5(),
  n5 = () => "Equipped",
  i5 = () => "Equipado",
  a5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? n5() : i5(),
  o5 = () => "Equip",
  s5 = () => "Equipar",
  l5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? o5() : s5(),
  c5 = () => "Country",
  u5 = () => "País",
  x0 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? c5() : u5(),
  h5 = () => "No country found.",
  d5 = () => "País não encontrado.",
  p5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? h5() : d5(),
  f5 = () => "Welcome to",
  m5 = () => "Bem vindo ao",
  _5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? f5() : m5(),
  g5 = () => "Rules",
  v5 = () => "Regras",
  y5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? g5() : v5(),
  x5 = () => "Important",
  b5 = () => "Importante",
  w5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? x5() : b5(),
  C5 = () => "🚫 No inappropriate content (+18, hate speech, inappropriate links, highly suggestive material, ...)",
  T5 = () => "🚫 Conteúdo inapropriado não permitido (+18, discurso de ódio, links inapropriados, conteúdo altamente sugestivo, ...)",
  S5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? C5() : T5(),
  I5 = () => "😈 Do not paint over other artworks using random colors or patterns just to mess things up",
  P5 = () => "😈 Não desenhe por cima de outras artes usando cores ou padrões aleatórios só para bagunçar",
  k5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? I5() : P5(),
  M5 = () => "🧑‍🤝‍🧑 Do not paint with more than one account",
  A5 = () => "🧑‍🤝‍🧑 Não desenhe com mais de uma conta",
  E5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? M5() : A5(),
  z5 = () => "🤖 Use of bots is not allowed",
  L5 = () => "🤖 Usar bots não é permitido",
  D5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? z5() : L5(),
  R5 = () => "🙅 Disclosing other's personal information is not allowed",
  B5 = () => "🙅 Divulgar informações pessoais dos outros não é permitido",
  F5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? R5() : B5(),
  O5 = () => "✅ Painting over other artworks to complement them or create a new drawing is allowed",
  j5 = () => "✅ Desenhar sobre outras artes para complementar ou criar novas artes é permitido",
  N5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? O5() : j5(),
  Z5 = () => "✅ Griefing political party flags or portraits of politicians is allowed",
  V5 = () => "✅ Desenhar sobre bandeiras de partidos e retratos de políticos é permitido",
  q5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Z5() : V5(),
  U5 = () => "Violations of these rules may lead to suspension of your account or removal of drawings.",
  $5 = () => "A violação destas regras pode levar à suspensão da conta ou à remoção de desenhos.",
  G5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? U5() : $5(),
  W5 = () => "Understood",
  H5 = () => "Entendido",
  J5 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? W5() : H5(),
  X5 = () => "Toggle art opacity",
  Y5 = () => "Alterar opacidade",
  b0 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? X5() : Y5(),
  K5 = () => "Paint",
  Q5 = () => "Pintar",
  w0 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? K5() : Q5(),
  e3 = () => "Select a color",
  t3 = () => "Selecione uma color",
  r3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? e3() : t3(),
  n3 = () => "Select a pixel to erase",
  i3 = () => "Selecione um pixel para apagar",
  a3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? n3() : i3(),
  o3 = () => "Pick a color from the map",
  s3 = () => "Escolha uma cor do mapa",
  l3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? o3() : s3(),
  c3 = () => "Click",
  u3 = () => "Clique",
  h3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? c3() : u3(),
  d3 = () => "SPACE",
  p3 = () => "ESPAÇO",
  f3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? d3() : p3(),
  m3 = () => "or hold",
  _3 = () => "ou segure",
  g3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? m3() : _3(),
  v3 = () => "to paint,",
  y3 = () => "para pintar",
  x3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? v3() : y3(),
  b3 = () => "You can paint more than 1 pixel",
  w3 = () => "Você pode pintar mais de 1 pixel",
  C3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? b3() : w3(),
  T3 = () => "Paint pixel",
  S3 = () => "Pintar pixel",
  I3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? T3() : S3(),
  P3 = () => "Color Picker",
  k3 = () => "Conta Gotas",
  M3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? P3() : k3(),
  A3 = () => "+2 max. charge/level",
  E3 = () => "+2 tinta máxima/level",
  z3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? A3() : E3(),
  L3 = () => "Name",
  D3 = () => "Nome",
  fm = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? L3() : D3(),
  R3 = () => "Discord Username",
  B3 = () => "Usuário do Discord",
  F3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? R3() : B3(),
  O3 = () => "Max. Charges",
  j3 = () => "Tinta máxima",
  xv = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? O3() : j3(),
  N3 = () => "Paint Charges",
  Z3 = () => "Tintas",
  V3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? N3() : Z3(),
  q3 = d => `+${d.amount} Paint Charges`,
  U3 = d => `+${d.amount} Tintas`,
  $3 = (d, a = {}) => (a.locale ?? Fe()) === "en" ? q3(d) : U3(d),
  G3 = () => "Leave alliance",
  W3 = () => "Sair da aliança",
  H3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? G3() : W3(),
  J3 = () => "Headquarters",
  X3 = () => "Quartel General",
  Y3 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? J3() : X3(),
  K3 = () => "Not set",
  Q3 = () => "Não configurado",
  eC = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? K3() : Q3(),
  tC = () => "You are not in an alliance",
  rC = () => "Você não está em uma aliança",
  nC = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? tC() : rC(),
  iC = () => "Get invited to an alliance",
  aC = () => "Seja convidado para uma aliança",
  oC = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? iC() : aC(),
  sC = () => "OR",
  lC = () => "OU",
  cC = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? sC() : lC(),
  uC = () => "Create an alliance",
  hC = () => "Crie uma aliança",
  dC = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? uC() : hC(),
  pC = () => "Invite link",
  fC = () => "Link de convite",
  mC = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? pC() : fC(),
  _C = () => "Send the link below to everybody you want to invite to the alliance",
  gC = () => "Envie o link abaixo para quem você deseja convidar para a aliança",
  vC = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? _C() : gC(),
  yC = () => "Copied",
  xC = () => "Copiado",
  e_ = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? yC() : xC(),
  bC = () => "No description",
  wC = () => "Sem descrição",
  C0 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? bC() : wC(),
  CC = () => "Invite",
  TC = () => "Convite",
  SC = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? CC() : TC(),
  IC = () => "No pixels painted",
  PC = () => "Nenhum pixel pintado",
  t_ = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? IC() : PC(),
  kC = () => "Today",
  MC = () => "Hoje",
  Rp = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? kC() : MC(),
  AC = () => "Week",
  EC = () => "Semana",
  zC = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? AC() : EC(),
  LC = () => "Month",
  DC = () => "Mês",
  RC = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? LC() : DC(),
  BC = () => "All time",
  FC = () => "Geral",
  OC = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? BC() : FC(),
  jC = () => "this week",
  NC = () => "nesta semana",
  r_ = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? jC() : NC(),
  ZC = () => "this month",
  VC = () => "neste mês",
  n_ = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? ZC() : VC(),
  qC = () => "Create alliance",
  UC = () => "Criar aliança",
  $C = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? qC() : UC(),
  GC = () => "Alliance Name",
  WC = () => "Nome da aliança",
  HC = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? GC() : WC(),
  JC = () => "Create",
  XC = () => "Criar",
  YC = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? JC() : XC(),
  KC = () => "Give admin",
  QC = () => "Tornar admin",
  eT = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? KC() : QC(),
  tT = () => "Ban from alliance",
  rT = () => "Banir da aliança",
  T0 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? tT() : rT(),
  nT = () => "No action",
  iT = () => "Sem opção",
  aT = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? nT() : iT(),
  oT = () => "Unban",
  sT = () => "Desbanir",
  lT = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? oT() : sT(),
  cT = () => "No banned users",
  uT = () => "Sem usuários banidos",
  hT = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? cT() : uT(),
  dT = () => "Update",
  pT = () => "Atualizar",
  fT = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? dT() : pT(),
  mT = () => "Error giving admin to user",
  _T = () => "Erro ao tornar usuário admin",
  gT = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? mT() : _T(),
  vT = () => "Users",
  yT = () => "Usuários",
  xT = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? vT() : yT(),
  bT = () => "Banned",
  wT = () => "Banido",
  i_ = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? bT() : wT(),
  CT = () => "Regions",
  TT = () => "Regiões",
  ST = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? CT() : TT(),
  IT = () => "Countries",
  PT = () => "Países",
  kT = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? IT() : PT(),
  MT = () => "Players",
  AT = () => "Jogadores",
  S0 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? MT() : AT(),
  ET = () => "Alliances",
  zT = () => "Alianças",
  I0 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? ET() : zT(),
  LT = () => "Region",
  DT = () => "Região",
  RT = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? LT() : DT(),
  BT = () => "Pixels",
  FT = () => "Pixels",
  Ic = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? BT() : FT(),
  OT = () => "Painted",
  jT = () => "Pintados",
  Pc = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? OT() : jT(),
  NT = () => "Pixels painted inside the region",
  ZT = () => "Pixels pintados dentro da região",
  VT = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? NT() : ZT(),
  qT = () => "Not painted",
  UT = () => "Não pintado",
  $T = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? qT() : UT(),
  GT = () => "Painted by",
  WT = () => "Pintado por",
  HT = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? GT() : WT(),
  JT = () => "Limit reached",
  XT = () => "Limite atingido",
  YT = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? JT() : XT(),
  KT = () => "Favorite",
  QT = () => "Favoritar",
  eS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? KT() : QT(),
  tS = () => "Share",
  rS = () => "Compartilhar",
  nS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? tS() : rS(),
  iS = () => "Share place",
  aS = () => "Compartilhar local",
  oS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? iS() : aS(),
  sS = () => "Mute",
  lS = () => "Mutar",
  cS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? sS() : lS(),
  uS = () => "Unmute",
  hS = () => "Desmutar",
  dS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? uS() : hS(),
  pS = () => "Select the headquarters location",
  fS = () => "Selecione a localização do quartel general",
  mS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? pS() : fS(),
  _S = () => "Pixels painted inside the country",
  gS = () => "Pixels pintados dentro do país",
  vS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? _S() : gS(),
  yS = () => "Username copied to clipboard",
  xS = () => "Usuário copiado",
  bS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? yS() : xS(),
  wS = () => "No more charges",
  CS = () => "Acabou a tinta",
  TS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? wS() : CS(),
  SS = () => "You are not allowed to use multiple accounts. Use your main account to paint.",
  IS = () => "Não é permitido usar várias contas. Use sua conta principal para pintar.",
  PS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? SS() : IS(),
  kS = () => "SMS sent to",
  MS = () => "SMS enviado para",
  AS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? kS() : MS(),
  ES = () => "Phone successfully verified",
  zS = () => "Telefone verificado com sucesso",
  LS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? ES() : zS(),
  DS = () => "Not a valid phone number",
  RS = () => "Não é um número válido",
  BS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? DS() : RS(),
  FS = () => "Location unfavorited",
  OS = () => "Localização desfavoritada",
  jS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? FS() : OS(),
  NS = () => "Location favorited",
  ZS = () => "Localização favoritada",
  VS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? NS() : ZS(),
  qS = () => "Giving admin to user",
  US = () => "Tornar usuário um admin",
  $S = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? qS() : US(),
  GS = () => "Profile updated",
  WS = () => "Perfil atualizado",
  HS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? GS() : WS(),
  JS = () => "Successfully linked your Discord account.",
  XS = () => "A sua conta Discord foi conectada com sucesso.",
  YS = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? JS() : XS(),
  KS = () => "Discord unlinked",
  QS = () => "Discord desconectado",
  eI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? KS() : QS(),
  tI = () => "Link your Discord",
  rI = () => "Conectar Discord",
  nI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? tI() : rI(),
  iI = d => `Unlink Discord (${d.username})`,
  aI = d => `Desconectar Discord (${d.username})`,
  oI = (d, a = {}) => (a.locale ?? Fe()) === "en" ? iI(d) : aI(d),
  sI = () => "Account successfully deleted",
  lI = () => "Conta deletada com sucesso",
  cI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? sI() : lI(),
  uI = () => "Logged out",
  hI = () => "Logout feito",
  dI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? uI() : hI(),
  pI = () => "Could not logout. Try refreshing the page.",
  fI = () => "Não foi possível sair da conta. Tente recarregar a página.",
  mI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? pI() : fI(),
  _I = () => "You need to zoom in to select a pixel",
  gI = () => "Dê zoom para selecionar um pixel",
  vI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? _I() : gI(),
  yI = () => "Phone verification",
  xI = () => "Verificação de telefone",
  bI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? yI() : xI(),
  wI = () => "Please verify your phone number to continue playing. This helps us keep bots out and ensure a safe, creative experience for everyone.",
  CI = () => "Por favor, verifique com seu telefone para continuar jogando. Isso nos ajuda a filtrar bots e manter um experiência segura e criativa para todos.",
  TI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? wI() : CI(),
  SI = () => "Send Code",
  II = () => "Enviar o código",
  PI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? SI() : II(),
  kI = () => "Input the code",
  MI = () => "Insira o código",
  AI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? kI() : MI(),
  EI = () => "Sent to",
  zI = () => "Enviar para",
  LI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? EI() : zI(),
  DI = () => "Resend Code",
  RI = () => "Reenviar Código",
  BI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? DI() : RI(),
  FI = () => "Try another number",
  OI = () => "Tentar outro número",
  jI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? FI() : OI(),
  NI = () => "Edit profile",
  ZI = () => "Editar perfil",
  VI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? NI() : ZI(),
  qI = () => "Image",
  UI = () => "Imagem",
  $I = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? qI() : UI(),
  GI = () => "Download",
  WI = () => "Download",
  HI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? GI() : WI(),
  JI = () => "Image copied to clipboard",
  XI = () => "Imagem copiada para a área de transferência",
  YI = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? JI() : XI(),
  KI = () => "My map is lagging",
  QI = () => "Meu mapa está travando",
  eP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? KI() : QI(),
  tP = () => "Verify if",
  rP = () => "Verifique se",
  nP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? tP() : rP(),
  iP = () => "Use hardware acceleration when available",
  aP = () => "Usar aceleração gráfica quando disponível",
  oP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? iP() : aP(),
  sP = () => "is enabled on",
  lP = () => "está habilitado em",
  cP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? sP() : lP(),
  uP = () => "Follow the instructions to enable hardware acceleration",
  hP = () => "Siga a instrução para habilitar a aceleração de hardware",
  dP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? uP() : hP(),
  pP = () => "Moderation",
  fP = () => "Moderação",
  mP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? pP() : fP(),
  _P = () => "Terms",
  gP = () => "Termos",
  vP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? _P() : gP(),
  yP = () => "Privacy",
  xP = () => "Privacidade",
  bP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? yP() : xP(),
  wP = () => "Refund",
  CP = () => "Reembolso",
  P0 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? wP() : CP(),
  TP = () => "Clear area",
  SP = () => "Limpar área",
  IP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? TP() : SP(),
  PP = () => "Select the area's first corner",
  kP = () => "Selecione o primeiro canto da área",
  k0 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? PP() : kP(),
  MP = () => "Select the area's opposite corner",
  AP = () => "Selecione o canto oposto da área",
  M0 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? MP() : AP(),
  EP = () => "Admin",
  zP = () => "Administração",
  LP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? EP() : zP(),
  DP = d => `Reason: ${d.reason}`,
  RP = d => `Motivo: ${d.reason}`,
  BP = (d, a = {}) => (a.locale ?? Fe()) === "en" ? DP(d) : RP(d),
  FP = () => "No corresponding region on the map (cosmetic effect only)",
  OP = () => "Não possui região no mapa (apenas efeito cosmético)",
  jP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? FP() : OP(),
  NP = () => "Flag without region on the map",
  ZP = () => "Bandeira sem região no mapa",
  VP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? NP() : ZP(),
  qP = d => `The flag of <b>${d.country}</b> does not have corresponding areas on the map and will only have cosmetic effects.`,
  UP = d => `A bandeira <b>${d.country}</b> não possui regiões correspondente no mapa e só terá efeito cosmético.`,
  $P = (d, a = {}) => (a.locale ?? Fe()) === "en" ? qP(d) : UP(d),
  GP = () => "Dark mode",
  WP = () => "Modo escuro",
  HP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? GP() : WP(),
  JP = () => "Light mode",
  XP = () => "Modo claro",
  YP = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? JP() : XP(),
  KP = () => "This action will log your account out from all devices.",
  QP = () => "Essa ação ira desconectar sua conta de todos os dispositivos.",
  e4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? KP() : QP(),
  t4 = () => "More",
  r4 = () => "Mais",
  n4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? t4() : r4(),
  i4 = () => "This action is irreversible, do you want to proceed?",
  a4 = () => "Esta ação é irreversível, você deseja prosseguir?",
  o4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? i4() : a4(),
  s4 = () => "Please confirm by entering your username:",
  l4 = () => "Por favor, confirme digitando seu nome de usuário:",
  c4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? s4() : l4(),
  u4 = () => "Type your username",
  h4 = () => "Digite seu nome de usuário",
  d4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? u4() : h4(),
  p4 = () => "This action may take some time to be completed.",
  f4 = () => "Essa ação pode levar algum tempo para ser realizada.",
  m4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? p4() : f4(),
  _4 = () => "Ban appeal",
  g4 = () => "Revisão de banimento",
  A0 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? _4() : g4(),
  v4 = () => "Suggestions",
  y4 = () => "Sugestões",
  x4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? v4() : y4(),
  b4 = () => "Bug report",
  w4 = () => "Reportar bug",
  C4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? b4() : w4(),
  T4 = () => "For more details, see our",
  S4 = () => "Para mais detalhes, veja nossa",
  I4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? T4() : S4(),
  P4 = () => "Account Enforcement Policy and Code of Conduct",
  k4 = () => "Política de Aplicação da Conta e Código de Conduta",
  M4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? P4() : k4(),
  A4 = () => "Community Leader",
  E4 = () => "Líder de Comunidade",
  z4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? A4() : E4(),
  L4 = () => "Your name is how other users will see you in Wplace. It can be changed every 60 days.",
  D4 = () => "Seu nome é como outros usuários o verão no Wplace. Você pode alterá-lo a cada 60 dias.",
  R4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? L4() : D4(),
  B4 = () => "Twitch account migrated successfully.",
  F4 = () => "Conta da Twitch migrada com sucesso.",
  O4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? B4() : F4(),
  j4 = () => "Timeout appeal",
  N4 = () => "Revisão de suspensão",
  Z4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? j4() : N4(),
  V4 = () => `If you believe your suspension was a mistake, you can send one appeal <b>every 90 days</b> to have your case reviewed again.

Please note that submitting an appeal <b>does not guarantee that your suspension will be lifted</b>; however, our team will review your situation.

Reviews usually take up to <b>a week</b>.`,
  q4 = () => `Se você acredita que sua suspensão foi um erro, você pode enviar um apelo <b>a cada 90 dias</b> para que seu caso seja revisado novamente.

Por favor, note que enviar um recurso <b>não garante que sua suspensão será removida</b>; no entanto, nossa equipe analisará a sua situação novamente.

As revisões geralmente levam até <b>uma semana</b>.`,
  U4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? V4() : q4(),
  $4 = () => "Why your suspension should be lifted?",
  G4 = () => "Por que sua suspensão deve ser reconsiderada?",
  W4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? $4() : G4(),
  H4 = () => "Tell us why you think your suspension should be reconsidered",
  J4 = () => "Explique por que você acha que sua suspensão deve ser reconsiderada",
  X4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? H4() : J4(),
  Y4 = () => "Submit",
  K4 = () => "Enviar",
  Q4 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? Y4() : K4(),
  e6 = () => "Appeal sent successfully",
  t6 = () => "Apelo enviado com sucesso",
  r6 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? e6() : t6(),
  n6 = () => "User appeal",
  i6 = () => "Apelo do usuário",
  a6 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? n6() : i6(),
  o6 = d => `You can send another appeal in ${d.days} days`,
  s6 = d => `Você pode enviar outro apelo em ${d.days} dias`,
  l6 = (d, a = {}) => (a.locale ?? Fe()) === "en" ? o6(d) : s6(d),
  c6 = () => "Appeal",
  u6 = () => "Apelar",
  h6 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? c6() : u6(),
  d6 = () => "Notifications",
  p6 = () => "Notificações",
  f6 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? d6() : p6(),
  m6 = () => "No notifications",
  _6 = () => "Nenhuma notificação",
  g6 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? m6() : _6(),
  v6 = () => "Report feedback",
  y6 = () => "Feedback de report",
  bv = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? v6() : y6(),
  x6 = () => "Your report has been reviewed, and a penalty has been applied to the reported player.",
  b6 = () => "Sua denúncia foi analisada e uma penalidade foi aplicada ao jogador denunciado.",
  wv = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? x6() : b6(),
  w6 = () => "Thank you for helping keep the community fair and safe.",
  C6 = () => "Obrigado por ajudar a manter a comunidade justa e segura!",
  T6 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? w6() : C6(),
  S6 = () => "Mark all as read",
  I6 = () => "Marcar tudo como lido",
  P6 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? S6() : I6(),
  k6 = () => "Pumpkin",
  M6 = () => "Abóbora",
  A6 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? k6() : M6(),
  E6 = () => "Claim",
  z6 = () => "Resgatar",
  L6 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? E6() : z6(),
  D6 = () => "Claimed",
  R6 = () => "Resgatado",
  B6 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? D6() : R6(),
  F6 = d => `You received ${d.droplets} droplets!`,
  O6 = d => `Você recebeu ${d.droplets} droplets!`,
  j6 = (d, a = {}) => (a.locale ?? Fe()) === "en" ? F6(d) : O6(d),
  N6 = () => "Event",
  Z6 = () => "Evento",
  V6 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? N6() : Z6(),
  q6 = () => "Default theme",
  U6 = () => "Tema padrão",
  $6 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? q6() : U6(),
  G6 = () => "Event theme",
  W6 = () => "Tema de evento",
  H6 = (d = {}, a = {}) => (a.locale ?? Fe()) === "en" ? G6() : W6(),
  ts = 2 * Math.PI * 6378137 / 2;
class Zs {
  constructor(a = 256) {
    Tr(this, "initialResolution");
    this.tileSize = a, this.initialResolution = 2 * ts / this.tileSize
  }
  latLonToMeters(a, h) {
    const y = h / 180 * ts,
      k = Math.log(Math.tan((90 + a) * Math.PI / 360)) / (Math.PI / 180) * ts / 180;
    return [y, k]
  }
  metersToLatLon(a, h) {
    const y = a / ts * 180;
    let k = h / ts * 180;
    return k = 180 / Math.PI * (2 * Math.atan(Math.exp(k * Math.PI / 180)) - Math.PI / 2), [k, y]
  }
  pixelsToMeters(a, h, y) {
    const k = this.resolution(y),
      E = a * k - ts,
      b = ts - h * k;
    return [E, b]
  }
  pixelsToLatLon(a, h, y) {
    const [k, E] = this.pixelsToMeters(a, h, y);
    return this.metersToLatLon(k, E)
  }
  latLonToPixels(a, h, y) {
    const [k, E] = this.latLonToMeters(a, h);
    return this.metersToPixels(k, E, y)
  }
  latLonToPixelsFloor(a, h, y) {
    const [k, E] = this.latLonToPixels(a, h, y);
    return [Math.floor(k), Math.floor(E)]
  }
  metersToPixels(a, h, y) {
    const k = this.resolution(y),
      E = (a + ts) / k,
      b = (ts - h) / k;
    return [E, b]
  }
  latLonToTile(a, h, y) {
    const [k, E] = this.latLonToMeters(a, h);
    return this.metersToTile(k, E, y)
  }
  metersToTile(a, h, y) {
    const [k, E] = this.metersToPixels(a, h, y);
    return this.pixelsToTile(k, E)
  }
  pixelsToTile(a, h) {
    const y = Math.ceil(a / this.tileSize) - 1,
      k = Math.ceil(h / this.tileSize) - 1;
    return [y, k]
  }
  pixelsToTileLocal(a, h) {
    return {
      tile: this.pixelsToTile(a, h),
      pixel: [Math.floor(a) % this.tileSize, Math.floor(h) % this.tileSize]
    }
  }
  tileBounds(a, h, y) {
    const [k, E] = this.pixelsToMeters(a * this.tileSize, h * this.tileSize, y), [b, s] = this.pixelsToMeters((a + 1) * this.tileSize, (h + 1) * this.tileSize, y);
    return {
      min: [k, E],
      max: [b, s]
    }
  }
  tileBoundsLatLon(a, h, y) {
    const k = this.tileBounds(a, h, y);
    return {
      min: this.metersToLatLon(k.min[0], k.min[1]),
      max: this.metersToLatLon(k.max[0], k.max[1])
    }
  }
  resolution(a) {
    return this.initialResolution / 2 ** a
  }
  latLonToTileAndPixel(a, h, y) {
    const [k, E] = this.latLonToMeters(a, h), [b, s] = this.metersToTile(k, E, y), [F, O] = this.metersToPixels(k, E, y);
    return {
      tile: [b, s],
      pixel: [Math.floor(F) % this.tileSize, Math.floor(O) % this.tileSize]
    }
  }
  pixelBounds(a, h, y) {
    return {
      min: this.pixelsToMeters(a, h, y),
      max: this.pixelsToMeters(a + 1, h + 1, y)
    }
  }
  pixelToBoundsLatLon(a, h, y) {
    const k = this.pixelBounds(a, h, y),
      E = .001885,
      b = (k.max[0] - k.min[0]) * E,
      s = (k.max[1] - k.min[1]) * E;
    return k.min[0] -= b, k.max[0] -= b, k.min[1] -= s, k.max[1] -= s, {
      min: this.metersToLatLon(k.min[0], k.min[1]),
      max: this.metersToLatLon(k.max[0], k.max[1])
    }
  }
  latLonToTileBoundsLatLon(a, h, y) {
    const [k, E] = this.latLonToMeters(a, h), [b, s] = this.metersToTile(k, E, y);
    return this.tileBoundsLatLon(b, s, y)
  }
  latLonToPixelBoundsLatLon(a, h, y) {
    const [k, E] = this.latLonToMeters(a, h), [b, s] = this.metersToPixels(k, E, y);
    return this.pixelToBoundsLatLon(Math.floor(b), Math.floor(s), y)
  }
  latLonToRegionAndPixel(a, h, y, k = Bi.regionSize) {
    const [E, b] = this.latLonToPixelsFloor(a, h, y), s = this.tileSize * k;
    return {
      region: [Math.floor(E / s), Math.floor(b / s)],
      pixel: [E % s, b % s]
    }
  }
}

function a_(d, a = !0) {
  const {
    min: h,
    max: y
  } = d;
  return a ? [
    [h[1], y[0]],
    [y[1], y[0]],
    [y[1], h[0]],
    [h[1], h[0]]
  ] : [
    [h[0], y[1]],
    [y[0], y[1]],
    [y[0], h[1]],
    [h[0], h[1]]
  ]
}

function o_(d) {
  return [(d.min[0] + d.max[0]) / 2, (d.min[1] + d.max[1]) / 2]
}
const rs = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB8AAAAfCAYAAAAfrhY5AAAByUlEQVR4AeyV0VEDMQxEbQqgDEqhFrpg6IJaKIUyaODQ89wqimKf75LM5AOY20harbWyf3gqD/z7N3/I49/j2RfbHFg49t1qvjx/vRVgtocXuMW8GZtp+Xn9JFR+jmCvObeKcI9gHPvkrhklM3OGLMv7S4mwYfAW/Btpss4PkIzMOeQDEQr149sX4dZaCl4aonjL2yyLF1/PvGvKSQwYSp4BT7/H0zOeJSycvmzejE/t+2W9BbL5pts6wDWz2oWDJJr7rXm+iMHZTTqeJ0e8LuvPH83pN6yilvPDYYF6BGmIUZPnqdc1V1NxWZYCqPNgOCAeHYCbYZd5HiIj8bkWP4tD8/hUtdZSa/VZ6slUNYJaa1dLL2NojjAOpQbiZKwoHo3Q49QjbpojYEAEHJhx9NFtYWqum/WGXNvTrGhe8zDVijpEFKcIJ4hTTHxVHc3FtaiDej7VNJUf7XE2Ipv77RkMECtiCiI368W+nfNbW16yOVxbQCYQQENynuuoo8ccYPmZsdVdc3iEF0swGCAA61BS/x/fCvuhB0hXWDj/ejePirMlGBZhQl8w8uT0VljofzNznWpLWJGjUSVzqultYq/55pBrm3/X/BcAAP//XVoCOwAAAAZJREFUAwCtKAFOt0LgOAAAAABJRU5ErkJgggAA",
  J6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==",
  Cv = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=",
  X6 = "data:application/json;base64,ewoJInZlcnNpb24iOiA4LAoJInNvdXJjZXMiOiB7CgkJIm5lMl9zaGFkZWQiOiB7CgkJCSJtYXh6b29tIjogNiwKCQkJInRpbGVTaXplIjogMjU2LAoJCQkidGlsZXMiOiBbCgkJCQkiaHR0cHM6Ly9tYXBzLndwbGFjZS5saXZlL25hdHVyYWxfZWFydGgvbmUyc3Ive3p9L3t4fS97eX0ucG5nIgoJCQldLAoJCQkidHlwZSI6ICJyYXN0ZXIiCgkJfSwKCQkib3Blbm1hcHRpbGVzIjogewoJCQkidHlwZSI6ICJ2ZWN0b3IiLAoJCQkidXJsIjogImh0dHBzOi8vbWFwcy53cGxhY2UubGl2ZS9wbGFuZXQiCgkJfQoJfSwKCSJzcHJpdGUiOiAiaHR0cHM6Ly9tYXBzLndwbGFjZS5saXZlL3Nwcml0ZXMvb2ZtX2YzODQvb2ZtIiwKCSJnbHlwaHMiOiAiaHR0cHM6Ly9tYXBzLndwbGFjZS5saXZlL2ZvbnRzL3tmb250c3RhY2t9L3tyYW5nZX0ucGJmIiwKCSJsYXllcnMiOiBbCgkJewoJCQkiaWQiOiAiYmFja2dyb3VuZCIsCgkJCSJ0eXBlIjogImJhY2tncm91bmQiLAoJCQkicGFpbnQiOiB7CgkJCQkiYmFja2dyb3VuZC1jb2xvciI6ICIjMmIxODBmIgoJCQl9CgkJfSwKCQl7CgkJCSJpZCI6ICJuYXR1cmFsX2VhcnRoIiwKCQkJInR5cGUiOiAicmFzdGVyIiwKCQkJInNvdXJjZSI6ICJuZTJfc2hhZGVkIiwKCQkJIm1heHpvb20iOiA3LAoJCQkicGFpbnQiOiB7CgkJCQkicmFzdGVyLW9wYWNpdHkiOiAwLjE1CgkJCX0KCQl9LAoJCXsKCQkJImlkIjogImxhbmQiLAoJCQkidHlwZSI6ICJmaWxsIiwKCQkJInNvdXJjZSI6ICJvcGVubWFwdGlsZXMiLAoJCQkic291cmNlLWxheWVyIjogImxhbmRjb3ZlciIsCgkJCSJwYWludCI6IHsKCQkJCSJmaWxsLWNvbG9yIjogIiMyZDFhMGUiLAoJCQkJImZpbGwtb3BhY2l0eSI6IDAuOAoJCQl9CgkJfSwKCQl7CgkJCSJpZCI6ICJwYXJrIiwKCQkJInR5cGUiOiAiZmlsbCIsCgkJCSJzb3VyY2UiOiAib3Blbm1hcHRpbGVzIiwKCQkJInNvdXJjZS1sYXllciI6ICJwYXJrIiwKCQkJInBhaW50IjogewoJCQkJImZpbGwtY29sb3IiOiAiIzNhMWYwZSIsCgkJCQkiZmlsbC1vcGFjaXR5IjogMC41LAoJCQkJImZpbGwtb3V0bGluZS1jb2xvciI6ICIjOGU0ZDExIgoJCQl9CgkJfSwKCQl7CgkJCSJpZCI6ICJ3YXRlciIsCgkJCSJ0eXBlIjogImZpbGwiLAoJCQkic291cmNlIjogIm9wZW5tYXB0aWxlcyIsCgkJCSJzb3VyY2UtbGF5ZXIiOiAid2F0ZXIiLAoJCQkicGFpbnQiOiB7CgkJCQkiZmlsbC1jb2xvciI6ICJyZ2JhKDE1LCAzMiwgNTIsIDEpIgoJCQl9CgkJfSwKCQl7CgkJCSJpZCI6ICJsYW5kdXNlX3Jlc2lkZW50aWFsIiwKCQkJInR5cGUiOiAiZmlsbCIsCgkJCSJzb3VyY2UiOiAib3Blbm1hcHRpbGVzIiwKCQkJInNvdXJjZS1sYXllciI6ICJsYW5kdXNlIiwKCQkJImZpbHRlciI6IFsKCQkJCSI9PSIsCgkJCQlbCgkJCQkJImdldCIsCgkJCQkJImNsYXNzIgoJCQkJXSwKCQkJCSJyZXNpZGVudGlhbCIKCQkJXSwKCQkJInBhaW50IjogewoJCQkJImZpbGwtY29sb3IiOiAiIzJiMGYwOCIsCgkJCQkiZmlsbC1vcGFjaXR5IjogMC42CgkJCX0KCQl9LAoJCXsKCQkJImlkIjogInJvYWRfbWFqb3IiLAoJCQkidHlwZSI6ICJsaW5lIiwKCQkJInNvdXJjZSI6ICJvcGVubWFwdGlsZXMiLAoJCQkic291cmNlLWxheWVyIjogInRyYW5zcG9ydGF0aW9uIiwKCQkJImZpbHRlciI6IFsKCQkJCSJtYXRjaCIsCgkJCQlbCgkJCQkJImdldCIsCgkJCQkJImNsYXNzIgoJCQkJXSwKCQkJCVsKCQkJCQkicHJpbWFyeSIsCgkJCQkJInNlY29uZGFyeSIsCgkJCQkJInRydW5rIgoJCQkJXSwKCQkJCXRydWUsCgkJCQlmYWxzZQoJCQldLAoJCQkicGFpbnQiOiB7CgkJCQkibGluZS1jb2xvciI6ICIjZmY3NTE4IiwKCQkJCSJsaW5lLXdpZHRoIjogWwoJCQkJCSJpbnRlcnBvbGF0ZSIsCgkJCQkJWwoJCQkJCQkiZXhwb25lbnRpYWwiLAoJCQkJCQkxLjIKCQkJCQldLAoJCQkJCVsKCQkJCQkJInpvb20iCgkJCQkJXSwKCQkJCQk1LAoJCQkJCTAuNSwKCQkJCQkyMCwKCQkJCQkxMAoJCQkJXQoJCQl9CgkJfSwKCQl7CgkJCSJpZCI6ICJyb2FkX21pbm9yIiwKCQkJInR5cGUiOiAibGluZSIsCgkJCSJzb3VyY2UiOiAib3Blbm1hcHRpbGVzIiwKCQkJInNvdXJjZS1sYXllciI6ICJ0cmFuc3BvcnRhdGlvbiIsCgkJCSJmaWx0ZXIiOiBbCgkJCQkibWF0Y2giLAoJCQkJWwoJCQkJCSJnZXQiLAoJCQkJCSJjbGFzcyIKCQkJCV0sCgkJCQlbCgkJCQkJIm1pbm9yIgoJCQkJXSwKCQkJCXRydWUsCgkJCQlmYWxzZQoJCQldLAoJCQkicGFpbnQiOiB7CgkJCQkibGluZS1jb2xvciI6ICIjYjg1YzAwIiwKCQkJCSJsaW5lLXdpZHRoIjogWwoJCQkJCSJpbnRlcnBvbGF0ZSIsCgkJCQkJWwoJCQkJCQkiZXhwb25lbnRpYWwiLAoJCQkJCQkxLjIKCQkJCQldLAoJCQkJCVsKCQkJCQkJInpvb20iCgkJCQkJXSwKCQkJCQkxMiwKCQkJCQkwLjMsCgkJCQkJMjAsCgkJCQkJNgoJCQkJXQoJCQl9CgkJfSwKCQl7CgkJCSJpZCI6ICJib3VuZGFyeSIsCgkJCSJ0eXBlIjogImxpbmUiLAoJCQkic291cmNlIjogIm9wZW5tYXB0aWxlcyIsCgkJCSJzb3VyY2UtbGF5ZXIiOiAiYm91bmRhcnkiLAoJCQkicGFpbnQiOiB7CgkJCQkibGluZS1jb2xvciI6ICIjYTYzZjAzIiwKCQkJCSJsaW5lLXdpZHRoIjogMSwKCQkJCSJsaW5lLWRhc2hhcnJheSI6IFsKCQkJCQkyLAoJCQkJCTIKCQkJCV0KCQkJfQoJCX0sCgkJewoJCQkiaWQiOiAicGxhY2UtbGFiZWwiLAoJCQkidHlwZSI6ICJzeW1ib2wiLAoJCQkic291cmNlIjogIm9wZW5tYXB0aWxlcyIsCgkJCSJzb3VyY2UtbGF5ZXIiOiAicGxhY2UiLAoJCQkibWluem9vbSI6IDQsCgkJCSJsYXlvdXQiOiB7CgkJCQkidGV4dC1maWVsZCI6IFsKCQkJCQkiZ2V0IiwKCQkJCQkibmFtZV9lbiIKCQkJCV0sCgkJCQkidGV4dC1mb250IjogWwoJCQkJCSJOb3RvIFNhbnMgQm9sZCIKCQkJCV0sCgkJCQkidGV4dC1zaXplIjogWwoJCQkJCSJpbnRlcnBvbGF0ZSIsCgkJCQkJWwoJCQkJCQkibGluZWFyIgoJCQkJCV0sCgkJCQkJWwoJCQkJCQkiem9vbSIKCQkJCQldLAoJCQkJCTQsCgkJCQkJMTAsCgkJCQkJMTIsCgkJCQkJMTYKCQkJCV0KCQkJfSwKCQkJInBhaW50IjogewoJCQkJInRleHQtY29sb3IiOiAiI2Y2ZTU4ZCIsCgkJCQkidGV4dC1oYWxvLWNvbG9yIjogIiMxYTBkMzAiLAoJCQkJInRleHQtaGFsby13aWR0aCI6IDEuMwoJCQl9CgkJfQoJXSwKCSJpZCI6ICJoYWxsb3dlZW4tc3R5bGUiLAoJIm1ldGFkYXRhIjogewoJCSJtYXB1dG5pazpyZW5kZXJlciI6ICJtbGdsanMiCgl9Cn0=";

function Y6(d) {
  return Math.floor(Math.random() * d)
}
const mm = 14.5;
async function K6() {
  const d = tk();
  if (d) return d;
  try {
    if ((await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted") {
      const h = await new Promise((y, k) => navigator.geolocation.getCurrentPosition(E => y(E), E => k(E)));
      return {
        lat: h.coords.latitude,
        lng: h.coords.longitude,
        zoom: mm
      }
    }
  } catch (a) {
    console.error(a)
  }
  return {
    ...Q6().pos,
    zoom: mm
  }
}

function Q6() {
  const d = Object.entries(ek),
    a = Y6(d.length),
    [h, y] = d[a];
  return {
    city: h,
    pos: y
  }
}
const ek = {
    tokyo: {
      lat: 35.677545560719665,
      lng: 139.76394445809638
    },
    paris: {
      lat: 48.8537151734952,
      lng: 2.3484026030630787
    },
    newYork: {
      lat: 40.71283173786517,
      lng: -74.00599771376795
    },
    saoPaulo: {
      lat: -23.550584064565356,
      lng: -46.63339720713918
    },
    sydney: {
      lat: -33.86943325619071,
      lng: 151.2083447239608
    }
  },
  E0 = "location";

function zo(d, a) {
  localStorage.setItem(E0, JSON.stringify({
    ...d,
    zoom: a
  }))
}

function tk() {
  const d = localStorage.getItem(E0);
  if (!d) return;
  const a = JSON.parse(d);
  return a.zoom ?? (a.zoom = mm), a
}
var ih, ah;
class rk {
  constructor() {
    Lr(this, ih, rt(-1));
    Lr(this, ah, rt([]))
  }
  get idx() {
    return x(Ye(this, ih))
  }
  set idx(a) {
    re(Ye(this, ih), a, !0)
  }
  get entries() {
    return x(Ye(this, ah))
  }
  set entries(a) {
    re(Ye(this, ah), a)
  }
  hasNext() {
    return this.idx < this.entries.length - 1
  }
  goToNext(a) {
    const h = this.idx + 1,
      y = this.entries[h];
    y && (this.idx = h, a.flyTo({
      center: y.pos,
      zoom: y.zoom
    }))
  }
  hasPrev() {
    return this.idx > 0
  }
  goToPrev(a) {
    const h = this.idx - 1,
      y = this.entries[h];
    y && (this.idx = h, a.flyTo({
      center: y.pos,
      zoom: y.zoom
    }))
  }
  isEmpty() {
    return this.entries.length === 0
  }
  push(a) {
    this.idx = this.idx + 1, this.entries = [...this.entries.slice(0, this.idx), a]
  }
}
ih = new WeakMap, ah = new WeakMap;
const wl = new rk;

function s_(d) {
  return d && d.__esModule && Object.prototype.hasOwnProperty.call(d, "default") ? d.default : d
}
var sp = {
  exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.6.2/LICENSE.txt
 */
var nk = sp.exports,
  Tv;

function ik() {
  return Tv || (Tv = 1, (function(d, a) {
    (function(h, y) {
      d.exports = y()
    })(nk, (function() {
      var h = {},
        y = {};

      function k(b, s, F) {
        if (y[b] = F, b === "index") {
          var O = "var sharedModule = {}; (" + y.shared + ")(sharedModule); (" + y.worker + ")(sharedModule);",
            G = {};
          return y.shared(G), y.index(h, G), typeof window < "u" && h.setWorkerUrl(window.URL.createObjectURL(new Blob([O], {
            type: "text/javascript"
          }))), h
        }
      }
      k("shared", ["exports"], (function(b) {
        function s(n, t, r, o) {
          return new(r || (r = Promise))((function(c, m) {
            function _(S) {
              try {
                w(o.next(S))
              } catch (A) {
                m(A)
              }
            }

            function v(S) {
              try {
                w(o.throw(S))
              } catch (A) {
                m(A)
              }
            }

            function w(S) {
              var A;
              S.done ? c(S.value) : (A = S.value, A instanceof r ? A : new r((function(L) {
                L(A)
              }))).then(_, v)
            }
            w((o = o.apply(n, t || [])).next())
          }))
        }

        function F(n, t) {
          this.x = n, this.y = t
        }

        function O(n) {
          return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
        }
        var G, X;
        typeof SuppressedError == "function" && SuppressedError, F.prototype = {
          clone() {
            return new F(this.x, this.y)
          },
          add(n) {
            return this.clone()._add(n)
          },
          sub(n) {
            return this.clone()._sub(n)
          },
          multByPoint(n) {
            return this.clone()._multByPoint(n)
          },
          divByPoint(n) {
            return this.clone()._divByPoint(n)
          },
          mult(n) {
            return this.clone()._mult(n)
          },
          div(n) {
            return this.clone()._div(n)
          },
          rotate(n) {
            return this.clone()._rotate(n)
          },
          rotateAround(n, t) {
            return this.clone()._rotateAround(n, t)
          },
          matMult(n) {
            return this.clone()._matMult(n)
          },
          unit() {
            return this.clone()._unit()
          },
          perp() {
            return this.clone()._perp()
          },
          round() {
            return this.clone()._round()
          },
          mag() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
          },
          equals(n) {
            return this.x === n.x && this.y === n.y
          },
          dist(n) {
            return Math.sqrt(this.distSqr(n))
          },
          distSqr(n) {
            const t = n.x - this.x,
              r = n.y - this.y;
            return t * t + r * r
          },
          angle() {
            return Math.atan2(this.y, this.x)
          },
          angleTo(n) {
            return Math.atan2(this.y - n.y, this.x - n.x)
          },
          angleWith(n) {
            return this.angleWithSep(n.x, n.y)
          },
          angleWithSep(n, t) {
            return Math.atan2(this.x * t - this.y * n, this.x * n + this.y * t)
          },
          _matMult(n) {
            const t = n[2] * this.x + n[3] * this.y;
            return this.x = n[0] * this.x + n[1] * this.y, this.y = t, this
          },
          _add(n) {
            return this.x += n.x, this.y += n.y, this
          },
          _sub(n) {
            return this.x -= n.x, this.y -= n.y, this
          },
          _mult(n) {
            return this.x *= n, this.y *= n, this
          },
          _div(n) {
            return this.x /= n, this.y /= n, this
          },
          _multByPoint(n) {
            return this.x *= n.x, this.y *= n.y, this
          },
          _divByPoint(n) {
            return this.x /= n.x, this.y /= n.y, this
          },
          _unit() {
            return this._div(this.mag()), this
          },
          _perp() {
            const n = this.y;
            return this.y = this.x, this.x = -n, this
          },
          _rotate(n) {
            const t = Math.cos(n),
              r = Math.sin(n),
              o = r * this.x + t * this.y;
            return this.x = t * this.x - r * this.y, this.y = o, this
          },
          _rotateAround(n, t) {
            const r = Math.cos(n),
              o = Math.sin(n),
              c = t.y + o * (this.x - t.x) + r * (this.y - t.y);
            return this.x = t.x + r * (this.x - t.x) - o * (this.y - t.y), this.y = c, this
          },
          _round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
          },
          constructor: F
        }, F.convert = function(n) {
          if (n instanceof F) return n;
          if (Array.isArray(n)) return new F(+n[0], +n[1]);
          if (n.x !== void 0 && n.y !== void 0) return new F(+n.x, +n.y);
          throw new Error("Expected [x, y] or {x, y} point format")
        };
        var Q = (function() {
            if (X) return G;

            function n(t, r, o, c) {
              this.cx = 3 * t, this.bx = 3 * (o - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (c - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = o, this.p2y = c
            }
            return X = 1, G = n, n.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var o = t, c = 0; c < 8; c++) {
                  var m = this.sampleCurveX(o) - t;
                  if (Math.abs(m) < r) return o;
                  var _ = this.sampleCurveDerivativeX(o);
                  if (Math.abs(_) < 1e-6) break;
                  o -= m / _
                }
                var v = 0,
                  w = 1;
                for (o = t, c = 0; c < 20 && (m = this.sampleCurveX(o), !(Math.abs(m - t) < r)); c++) t > m ? v = o : w = o, o = .5 * (w - v) + v;
                return o
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, G
          })(),
          W = O(Q);
        let de, _e;

        function Ae() {
          return de == null && (de = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), de
        }

        function xe() {
          if (_e == null && (_e = !1, Ae())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", {
              willReadFrequently: !0
            });
            if (t) {
              for (let o = 0; o < 25; o++) {
                const c = 4 * o;
                t.fillStyle = `rgb(${c},${c+1},${c+2})`, t.fillRect(o % 5, Math.floor(o / 5), 1, 1)
              }
              const r = t.getImageData(0, 0, 5, 5).data;
              for (let o = 0; o < 100; o++)
                if (o % 4 != 3 && r[o] !== o) {
                  _e = !0;
                  break
                }
            }
          }
          return _e || !1
        }
        var Ie = 1e-6,
          Pe = typeof Float32Array < "u" ? Float32Array : Array;

        function De() {
          var n = new Pe(9);
          return Pe != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[0] = 1, n[4] = 1, n[8] = 1, n
        }

        function $e(n) {
          return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n
        }

        function tt() {
          var n = new Pe(3);
          return Pe != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n
        }

        function Ve(n) {
          return Math.hypot(n[0], n[1], n[2])
        }

        function Re(n, t, r) {
          var o = new Pe(3);
          return o[0] = n, o[1] = t, o[2] = r, o
        }

        function Ue(n, t, r) {
          return n[0] = t[0] + r[0], n[1] = t[1] + r[1], n[2] = t[2] + r[2], n
        }

        function Ce(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n
        }

        function We(n, t, r) {
          var o = t[0],
            c = t[1],
            m = t[2],
            _ = r[0],
            v = r[1],
            w = r[2];
          return n[0] = c * w - m * v, n[1] = m * _ - o * w, n[2] = o * v - c * _, n
        }
        Math.hypot || (Math.hypot = function() {
          for (var n = 0, t = arguments.length; t--;) n += arguments[t] * arguments[t];
          return Math.sqrt(n)
        });
        var Je, Ge = Ve;

        function Ee(n, t, r) {
          var o = t[0],
            c = t[1],
            m = t[2],
            _ = t[3];
          return n[0] = r[0] * o + r[4] * c + r[8] * m + r[12] * _, n[1] = r[1] * o + r[5] * c + r[9] * m + r[13] * _, n[2] = r[2] * o + r[6] * c + r[10] * m + r[14] * _, n[3] = r[3] * o + r[7] * c + r[11] * m + r[15] * _, n
        }

        function mt() {
          var n = new Pe(4);
          return Pe != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n[3] = 1, n
        }

        function K(n, t, r, o) {
          var c = .5 * Math.PI / 180;
          t *= c, r *= c, o *= c;
          var m = Math.sin(t),
            _ = Math.cos(t),
            v = Math.sin(r),
            w = Math.cos(r),
            S = Math.sin(o),
            A = Math.cos(o);
          return n[0] = m * w * A - _ * v * S, n[1] = _ * v * A + m * w * S, n[2] = _ * w * S - m * v * A, n[3] = _ * w * A + m * v * S, n
        }

        function ee() {
          var n = new Pe(2);
          return Pe != Float32Array && (n[0] = 0, n[1] = 0), n
        }

        function le(n, t) {
          var r = new Pe(2);
          return r[0] = n, r[1] = t, r
        }
        tt(), Je = new Pe(4), Pe != Float32Array && (Je[0] = 0, Je[1] = 0, Je[2] = 0, Je[3] = 0), tt(), Re(1, 0, 0), Re(0, 1, 0), mt(), mt(), De(), ee();
        const ae = 8192;

        function ke(n, t, r) {
          return t * (ae / (n.tileSize * Math.pow(2, r - n.tileID.overscaledZ)))
        }

        function qe(n, t) {
          return (n % t + t) % t
        }

        function lt(n, t, r) {
          return n * (1 - r) + t * r
        }

        function ot(n) {
          if (n <= 0) return 0;
          if (n >= 1) return 1;
          const t = n * n,
            r = t * n;
          return 4 * (n < .5 ? r : 3 * (n - t) + r - .75)
        }

        function dt(n, t, r, o) {
          const c = new W(n, t, r, o);
          return m => c.solve(m)
        }
        const Pt = dt(.25, .1, .25, 1);

        function Lt(n, t, r) {
          return Math.min(r, Math.max(t, n))
        }

        function He(n, t, r) {
          const o = r - t,
            c = ((n - t) % o + o) % o + t;
          return c === t ? r : c
        }

        function ut(n, ...t) {
          for (const r of t)
            for (const o in r) n[o] = r[o];
          return n
        }
        let gt = 1;

        function St(n, t, r) {
          const o = {};
          for (const c in n) o[c] = t.call(this, n[c], c, n);
          return o
        }

        function vt(n, t, r) {
          const o = {};
          for (const c in n) t.call(this, n[c], c, n) && (o[c] = n[c]);
          return o
        }

        function Ct(n) {
          return Array.isArray(n) ? n.map(Ct) : typeof n == "object" && n ? St(n, Ct) : n
        }
        const At = {};

        function Bt(n) {
          At[n] || (typeof console < "u" && console.warn(n), At[n] = !0)
        }

        function Vt(n, t, r) {
          return (r.y - n.y) * (t.x - n.x) > (t.y - n.y) * (r.x - n.x)
        }

        function Ot(n) {
          return typeof WorkerGlobalScope < "u" && n !== void 0 && n instanceof WorkerGlobalScope
        }
        let Dt = null;

        function Rt(n) {
          return typeof ImageBitmap < "u" && n instanceof ImageBitmap
        }
        const Zt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";

        function Ft(n, t, r, o, c) {
          return s(this, void 0, void 0, (function*() {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const m = new VideoFrame(n, {
              timestamp: 0
            });
            try {
              const _ = m == null ? void 0 : m.format;
              if (!_ || !_.startsWith("BGR") && !_.startsWith("RGB")) throw new Error(`Unrecognized format ${_}`);
              const v = _.startsWith("BGR"),
                w = new Uint8ClampedArray(o * c * 4);
              if (yield m.copyTo(w, (function(S, A, L, j, q) {
                  const $ = 4 * Math.max(-A, 0),
                    J = (Math.max(0, L) - L) * j * 4 + $,
                    te = 4 * j,
                    he = Math.max(0, A),
                    je = Math.max(0, L);
                  return {
                    rect: {
                      x: he,
                      y: je,
                      width: Math.min(S.width, A + j) - he,
                      height: Math.min(S.height, L + q) - je
                    },
                    layout: [{
                      offset: J,
                      stride: te
                    }]
                  }
                })(n, t, r, o, c)), v)
                for (let S = 0; S < w.length; S += 4) {
                  const A = w[S];
                  w[S] = w[S + 2], w[S + 2] = A
                }
              return w
            } finally {
              m.close()
            }
          }))
        }
        let cr, ur;

        function Er(n, t, r, o) {
          return n.addEventListener(t, r, o), {
            unsubscribe: () => {
              n.removeEventListener(t, r, o)
            }
          }
        }

        function dr(n) {
          return n * Math.PI / 180
        }

        function pr(n) {
          return n / Math.PI * 180
        }
        const vr = {
            touchstart: !0,
            touchmove: !0,
            touchmoveWindow: !0,
            touchend: !0,
            touchcancel: !0
          },
          Vr = {
            dblclick: !0,
            click: !0,
            mouseover: !0,
            mouseout: !0,
            mousedown: !0,
            mousemove: !0,
            mousemoveWindow: !0,
            mouseup: !0,
            mouseupWindow: !0,
            contextmenu: !0,
            wheel: !0
          },
          qr = "AbortError";

        function ue() {
          return new Error(qr)
        }
        const V = {
          MAX_PARALLEL_IMAGE_REQUESTS: 16,
          MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
          MAX_TILE_CACHE_ZOOM_LEVELS: 5,
          REGISTERED_PROTOCOLS: {},
          WORKER_URL: ""
        };

        function U(n) {
          return V.REGISTERED_PROTOCOLS[n.substring(0, n.indexOf("://"))]
        }
        const Y = "global-dispatcher";
        class oe extends Error {
          constructor(t, r, o, c) {
            super(`AJAXError: ${r} (${t}): ${o}`), this.status = t, this.statusText = r, this.url = o, this.body = c
          }
        }
        const me = () => Ot(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href,
          Se = function(n, t) {
            if (/:\/\//.test(n.url) && !/^https?:|^file:/.test(n.url)) {
              const o = U(n.url);
              if (o) return o(n, t);
              if (Ot(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: n,
                targetMapId: Y
              }, t)
            }
            if (!(/^file:/.test(r = n.url) || /^file:/.test(me()) && !/^\w+:/.test(r))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(o, c) {
                return s(this, void 0, void 0, (function*() {
                  const m = new Request(o.url, {
                    method: o.method || "GET",
                    body: o.body,
                    credentials: o.credentials,
                    headers: o.headers,
                    cache: o.cache,
                    referrer: me(),
                    signal: c.signal
                  });
                  let _, v;
                  o.type !== "json" || m.headers.has("Accept") || m.headers.set("Accept", "application/json");
                  try {
                    _ = yield fetch(m)
                  } catch (S) {
                    throw new oe(0, S.message, o.url, new Blob)
                  }
                  if (!_.ok) {
                    const S = yield _.blob();
                    throw new oe(_.status, _.statusText, o.url, S)
                  }
                  v = o.type === "arrayBuffer" || o.type === "image" ? _.arrayBuffer() : o.type === "json" ? _.json() : _.text();
                  const w = yield v;
                  if (c.signal.aborted) throw ue();
                  return {
                    data: w,
                    cacheControl: _.headers.get("Cache-Control"),
                    expires: _.headers.get("Expires")
                  }
                }))
              })(n, t);
              if (Ot(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: n,
                mustQueue: !0,
                targetMapId: Y
              }, t)
            }
            var r;
            return (function(o, c) {
              return new Promise(((m, _) => {
                var v;
                const w = new XMLHttpRequest;
                w.open(o.method || "GET", o.url, !0), o.type !== "arrayBuffer" && o.type !== "image" || (w.responseType = "arraybuffer");
                for (const S in o.headers) w.setRequestHeader(S, o.headers[S]);
                o.type === "json" && (w.responseType = "text", !((v = o.headers) === null || v === void 0) && v.Accept || w.setRequestHeader("Accept", "application/json")), w.withCredentials = o.credentials === "include", w.onerror = () => {
                  _(new Error(w.statusText))
                }, w.onload = () => {
                  if (!c.signal.aborted)
                    if ((w.status >= 200 && w.status < 300 || w.status === 0) && w.response !== null) {
                      let S = w.response;
                      if (o.type === "json") try {
                        S = JSON.parse(w.response)
                      } catch (A) {
                        return void _(A)
                      }
                      m({
                        data: S,
                        cacheControl: w.getResponseHeader("Cache-Control"),
                        expires: w.getResponseHeader("Expires")
                      })
                    } else {
                      const S = new Blob([w.response], {
                        type: w.getResponseHeader("Content-Type")
                      });
                      _(new oe(w.status, w.statusText, o.url, S))
                    }
                }, c.signal.addEventListener("abort", (() => {
                  w.abort(), _(ue())
                })), w.send(o.body)
              }))
            })(n, t)
          };

        function Oe(n) {
          if (!n || n.indexOf("://") <= 0 || n.indexOf("data:image/") === 0 || n.indexOf("blob:") === 0) return !0;
          const t = new URL(n),
            r = window.location;
          return t.protocol === r.protocol && t.host === r.host
        }

        function ze(n, t, r) {
          r[n] && r[n].indexOf(t) !== -1 || (r[n] = r[n] || [], r[n].push(t))
        }

        function Ke(n, t, r) {
          if (r && r[n]) {
            const o = r[n].indexOf(t);
            o !== -1 && r[n].splice(o, 1)
          }
        }
        class _t {
          constructor(t, r = {}) {
            ut(this, r), this.type = t
          }
        }
        class it extends _t {
          constructor(t, r = {}) {
            super("error", ut({
              error: t
            }, r))
          }
        }
        class qt {
          on(t, r) {
            return this._listeners = this._listeners || {}, ze(t, r, this._listeners), {
              unsubscribe: () => {
                this.off(t, r)
              }
            }
          }
          off(t, r) {
            return Ke(t, r, this._listeners), Ke(t, r, this._oneTimeListeners), this
          }
          once(t, r) {
            return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, ze(t, r, this._oneTimeListeners), this) : new Promise((o => this.once(t, o)))
          }
          fire(t, r) {
            typeof t == "string" && (t = new _t(t, r || {}));
            const o = t.type;
            if (this.listens(o)) {
              t.target = this;
              const c = this._listeners && this._listeners[o] ? this._listeners[o].slice() : [];
              for (const v of c) v.call(this, t);
              const m = this._oneTimeListeners && this._oneTimeListeners[o] ? this._oneTimeListeners[o].slice() : [];
              for (const v of m) Ke(o, v, this._oneTimeListeners), v.call(this, t);
              const _ = this._eventedParent;
              _ && (ut(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), _.fire(t))
            } else t instanceof it && console.error(t.error);
            return this
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
          }
          setEventedParent(t, r) {
            return this._eventedParent = t, this._eventedParentData = r, this
          }
        }
        var we = {
          $version: 8,
          $root: {
            version: {
              required: !0,
              type: "enum",
              values: [8]
            },
            name: {
              type: "string"
            },
            metadata: {
              type: "*"
            },
            center: {
              type: "array",
              value: "number"
            },
            centerAltitude: {
              type: "number"
            },
            zoom: {
              type: "number"
            },
            bearing: {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees"
            },
            pitch: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            roll: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            state: {
              type: "state",
              default: {}
            },
            light: {
              type: "light"
            },
            sky: {
              type: "sky"
            },
            projection: {
              type: "projection"
            },
            terrain: {
              type: "terrain"
            },
            sources: {
              required: !0,
              type: "sources"
            },
            sprite: {
              type: "sprite"
            },
            glyphs: {
              type: "string"
            },
            transition: {
              type: "transition"
            },
            layers: {
              required: !0,
              type: "array",
              value: "layer"
            }
          },
          sources: {
            "*": {
              type: "source"
            }
          },
          source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
          source_vector: {
            type: {
              required: !0,
              type: "enum",
              values: {
                vector: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            attribution: {
              type: "string"
            },
            promoteId: {
              type: "promoteId"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster: {
            type: {
              required: !0,
              type: "enum",
              values: {
                raster: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            attribution: {
              type: "string"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster_dem: {
            type: {
              required: !0,
              type: "enum",
              values: {
                "raster-dem": {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            attribution: {
              type: "string"
            },
            encoding: {
              type: "enum",
              values: {
                terrarium: {},
                mapbox: {},
                custom: {}
              },
              default: "mapbox"
            },
            redFactor: {
              type: "number",
              default: 1
            },
            blueFactor: {
              type: "number",
              default: 1
            },
            greenFactor: {
              type: "number",
              default: 1
            },
            baseShift: {
              type: "number",
              default: 0
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_geojson: {
            type: {
              required: !0,
              type: "enum",
              values: {
                geojson: {}
              }
            },
            data: {
              required: !0,
              type: "*"
            },
            maxzoom: {
              type: "number",
              default: 18
            },
            attribution: {
              type: "string"
            },
            buffer: {
              type: "number",
              default: 128,
              maximum: 512,
              minimum: 0
            },
            filter: {
              type: "*"
            },
            tolerance: {
              type: "number",
              default: .375
            },
            cluster: {
              type: "boolean",
              default: !1
            },
            clusterRadius: {
              type: "number",
              default: 50,
              minimum: 0
            },
            clusterMaxZoom: {
              type: "number"
            },
            clusterMinPoints: {
              type: "number"
            },
            clusterProperties: {
              type: "*"
            },
            lineMetrics: {
              type: "boolean",
              default: !1
            },
            generateId: {
              type: "boolean",
              default: !1
            },
            promoteId: {
              type: "promoteId"
            }
          },
          source_video: {
            type: {
              required: !0,
              type: "enum",
              values: {
                video: {}
              }
            },
            urls: {
              required: !0,
              type: "array",
              value: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          source_image: {
            type: {
              required: !0,
              type: "enum",
              values: {
                image: {}
              }
            },
            url: {
              required: !0,
              type: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          layer: {
            id: {
              type: "string",
              required: !0
            },
            type: {
              type: "enum",
              values: {
                fill: {},
                line: {},
                symbol: {},
                circle: {},
                heatmap: {},
                "fill-extrusion": {},
                raster: {},
                hillshade: {},
                "color-relief": {},
                background: {}
              },
              required: !0
            },
            metadata: {
              type: "*"
            },
            source: {
              type: "string"
            },
            "source-layer": {
              type: "string"
            },
            minzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            maxzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            filter: {
              type: "filter"
            },
            layout: {
              type: "layout"
            },
            paint: {
              type: "paint"
            }
          },
          layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
          layout_background: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_fill: {
            "fill-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_circle: {
            "circle-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_heatmap: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_fill-extrusion": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_line: {
            "line-cap": {
              type: "enum",
              values: {
                butt: {},
                round: {},
                square: {}
              },
              default: "butt",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-join": {
              type: "enum",
              values: {
                bevel: {},
                round: {},
                miter: {}
              },
              default: "miter",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "line-miter-limit": {
              type: "number",
              default: 2,
              requires: [{
                "line-join": "miter"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-round-limit": {
              type: "number",
              default: 1.05,
              requires: [{
                "line-join": "round"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_symbol: {
            "symbol-placement": {
              type: "enum",
              values: {
                point: {},
                line: {},
                "line-center": {}
              },
              default: "point",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-spacing": {
              type: "number",
              default: 250,
              minimum: 1,
              units: "pixels",
              requires: [{
                "symbol-placement": "line"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-avoid-edges": {
              type: "boolean",
              default: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "symbol-z-order": {
              type: "enum",
              values: {
                auto: {},
                "viewport-y": {},
                source: {}
              },
              default: "auto",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "!": "icon-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-optional": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-size": {
              type: "number",
              default: 1,
              minimum: 0,
              units: "factor of the original icon size",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-text-fit": {
              type: "enum",
              values: {
                none: {},
                width: {},
                height: {},
                both: {}
              },
              default: "none",
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-text-fit-padding": {
              type: "array",
              value: "number",
              length: 4,
              default: [0, 0, 0, 0],
              units: "pixels",
              requires: ["icon-image", "text-field", {
                "icon-text-fit": ["both", "width", "height"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-image": {
              type: "resolvedImage",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-padding": {
              type: "padding",
              default: [2],
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-keep-upright": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "icon-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-offset": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                "viewport-glyph": {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-field": {
              type: "formatted",
              default: "",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-font": {
              type: "array",
              value: "string",
              default: ["Open Sans Regular", "Arial Unicode MS Regular"],
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-size": {
              type: "number",
              default: 16,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-width": {
              type: "number",
              default: 10,
              minimum: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-line-height": {
              type: "number",
              default: 1.2,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-letter-spacing": {
              type: "number",
              default: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-justify": {
              type: "enum",
              values: {
                auto: {},
                left: {},
                center: {},
                right: {}
              },
              default: "center",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-radial-offset": {
              type: "number",
              units: "ems",
              default: 0,
              requires: ["text-field"],
              "property-type": "data-driven",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              }
            },
            "text-variable-anchor": {
              type: "array",
              value: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-variable-anchor-offset": {
              type: "variableAnchorOffsetCollection",
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["text-field", {
                "!": "text-variable-anchor"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-angle": {
              type: "number",
              default: 45,
              units: "degrees",
              requires: ["text-field", {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-writing-mode": {
              type: "array",
              value: "enum",
              values: {
                horizontal: {},
                vertical: {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-padding": {
              type: "number",
              default: 2,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-keep-upright": {
              type: "boolean",
              default: !0,
              requires: ["text-field", {
                "text-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-transform": {
              type: "enum",
              values: {
                none: {},
                uppercase: {},
                lowercase: {}
              },
              default: "none",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-offset": {
              type: "array",
              value: "number",
              units: "ems",
              length: 2,
              default: [0, 0],
              requires: ["text-field", {
                "!": "text-radial-offset"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["text-field", {
                "!": "text-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-optional": {
              type: "boolean",
              default: !1,
              requires: ["text-field", "icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_raster: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_hillshade: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_color-relief": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          filter: {
            type: "array",
            value: "*"
          },
          filter_operator: {
            type: "enum",
            values: {
              "==": {},
              "!=": {},
              ">": {},
              ">=": {},
              "<": {},
              "<=": {},
              in: {},
              "!in": {},
              all: {},
              any: {},
              none: {},
              has: {},
              "!has": {}
            }
          },
          geometry_type: {
            type: "enum",
            values: {
              Point: {},
              LineString: {},
              Polygon: {}
            }
          },
          function: {
            expression: {
              type: "expression"
            },
            stops: {
              type: "array",
              value: "function_stop"
            },
            base: {
              type: "number",
              default: 1,
              minimum: 0
            },
            property: {
              type: "string",
              default: "$zoom"
            },
            type: {
              type: "enum",
              values: {
                identity: {},
                exponential: {},
                interval: {},
                categorical: {}
              },
              default: "exponential"
            },
            colorSpace: {
              type: "enum",
              values: {
                rgb: {},
                lab: {},
                hcl: {}
              },
              default: "rgb"
            },
            default: {
              type: "*",
              required: !1
            }
          },
          function_stop: {
            type: "array",
            minimum: 0,
            maximum: 24,
            value: ["number", "color"],
            length: 2
          },
          expression: {
            type: "array",
            value: "*",
            minimum: 1
          },
          light: {
            anchor: {
              type: "enum",
              default: "viewport",
              values: {
                map: {},
                viewport: {}
              },
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              }
            },
            position: {
              type: "array",
              default: [1.15, 210, 30],
              length: 3,
              value: "number",
              "property-type": "data-constant",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            },
            color: {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            intensity: {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          sky: {
            "sky-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#88C6FC",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-ground-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-fog-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "sky-horizon-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "atmosphere-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          terrain: {
            source: {
              type: "string",
              required: !0
            },
            exaggeration: {
              type: "number",
              minimum: 0,
              default: 1
            }
          },
          projection: {
            type: {
              type: "projectionDefinition",
              default: "mercator",
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            }
          },
          paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
          paint_fill: {
            "fill-antialias": {
              type: "boolean",
              default: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-outline-color": {
              type: "color",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }, {
                "fill-antialias": !0
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            }
          },
          "paint_fill-extrusion": {
            "fill-extrusion-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-extrusion-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-extrusion-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "fill-extrusion-height": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-base": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              requires: ["fill-extrusion-height"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-vertical-gradient": {
              type: "boolean",
              default: !0,
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_line: {
            "line-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["line-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-width": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-gap-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-offset": {
              type: "number",
              default: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-dasharray": {
              type: "array",
              value: "number",
              minimum: 0,
              transition: !0,
              units: "line widths",
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "line-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-gradient": {
              type: "color",
              transition: !1,
              requires: [{
                "!": "line-dasharray"
              }, {
                "!": "line-pattern"
              }, {
                source: "geojson",
                has: {
                  lineMetrics: !0
                }
              }],
              expression: {
                interpolated: !0,
                parameters: ["line-progress"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_circle: {
            "circle-radius": {
              type: "number",
              default: 5,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-blur": {
              type: "number",
              default: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["circle-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-scale": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-stroke-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            }
          },
          paint_heatmap: {
            "heatmap-radius": {
              type: "number",
              default: 30,
              minimum: 1,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-weight": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-intensity": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "heatmap-color": {
              type: "color",
              default: ["interpolate", ["linear"],
                ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"
              ],
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["heatmap-density"]
              },
              "property-type": "color-ramp"
            },
            "heatmap-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_symbol: {
            "icon-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["icon-image", "icon-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              overridable: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["text-field", "text-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_raster: {
            "raster-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-hue-rotate": {
              type: "number",
              default: 0,
              period: 360,
              transition: !0,
              units: "degrees",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-min": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-max": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-saturation": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-contrast": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-resampling": {
              type: "enum",
              values: {
                linear: {},
                nearest: {}
              },
              default: "linear",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-fade-duration": {
              type: "number",
              default: 300,
              minimum: 0,
              transition: !1,
              units: "milliseconds",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_hillshade: {
            "hillshade-illumination-direction": {
              type: "numberArray",
              default: 335,
              minimum: 0,
              maximum: 359,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-altitude": {
              type: "numberArray",
              default: 45,
              minimum: 0,
              maximum: 90,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-exaggeration": {
              type: "number",
              default: .5,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-shadow-color": {
              type: "colorArray",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-highlight-color": {
              type: "colorArray",
              default: "#FFFFFF",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-accent-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-method": {
              type: "enum",
              values: {
                standard: {},
                basic: {},
                combined: {},
                igor: {},
                multidirectional: {}
              },
              default: "standard",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          "paint_color-relief": {
            "color-relief-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "color-relief-color": {
              type: "color",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["elevation"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_background: {
            "background-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "background-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "background-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "background-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          transition: {
            duration: {
              type: "number",
              default: 300,
              minimum: 0,
              units: "milliseconds"
            },
            delay: {
              type: "number",
              default: 0,
              minimum: 0,
              units: "milliseconds"
            }
          },
          "property-type": {
            "data-driven": {
              type: "property-type"
            },
            "cross-faded": {
              type: "property-type"
            },
            "cross-faded-data-driven": {
              type: "property-type"
            },
            "color-ramp": {
              type: "property-type"
            },
            "data-constant": {
              type: "property-type"
            },
            constant: {
              type: "property-type"
            }
          },
          promoteId: {
            "*": {
              type: "string"
            }
          }
        };
        const Mt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];

        function Ut(n, t) {
          const r = {};
          for (const o in n) o !== "ref" && (r[o] = n[o]);
          return Mt.forEach((o => {
            o in t && (r[o] = t[o])
          })), r
        }

        function jt(n, t) {
          if (Array.isArray(n)) {
            if (!Array.isArray(t) || n.length !== t.length) return !1;
            for (let r = 0; r < n.length; r++)
              if (!jt(n[r], t[r])) return !1;
            return !0
          }
          if (typeof n == "object" && n !== null && t !== null) {
            if (typeof t != "object" || Object.keys(n).length !== Object.keys(t).length) return !1;
            for (const r in n)
              if (!jt(n[r], t[r])) return !1;
            return !0
          }
          return n === t
        }

        function fr(n, t) {
          n.push(t)
        }

        function Ur(n, t, r) {
          fr(r, {
            command: "addSource",
            args: [n, t[n]]
          })
        }

        function Dr(n, t, r) {
          fr(t, {
            command: "removeSource",
            args: [n]
          }), r[n] = !0
        }

        function jr(n, t, r, o) {
          Dr(n, r, o), Ur(n, t, r)
        }

        function $r(n, t, r) {
          let o;
          for (o in n[r])
            if (Object.prototype.hasOwnProperty.call(n[r], o) && o !== "data" && !jt(n[r][o], t[r][o])) return !1;
          for (o in t[r])
            if (Object.prototype.hasOwnProperty.call(t[r], o) && o !== "data" && !jt(n[r][o], t[r][o])) return !1;
          return !0
        }

        function Br(n, t, r, o, c, m) {
          n = n || {}, t = t || {};
          for (const _ in n) Object.prototype.hasOwnProperty.call(n, _) && (jt(n[_], t[_]) || r.push({
            command: m,
            args: [o, _, t[_], c]
          }));
          for (const _ in t) Object.prototype.hasOwnProperty.call(t, _) && !Object.prototype.hasOwnProperty.call(n, _) && (jt(n[_], t[_]) || r.push({
            command: m,
            args: [o, _, t[_], c]
          }))
        }

        function Fr(n) {
          return n.id
        }

        function vn(n, t) {
          return n[t.id] = t, n
        }
        class bt {
          constructor(t, r, o, c) {
            this.message = (t ? `${t}: ` : "") + o, c && (this.identifier = c), r != null && r.__line__ && (this.line = r.__line__)
          }
        }

        function bn(n, ...t) {
          for (const r of t)
            for (const o in r) n[o] = r[o];
          return n
        }
        class fn extends Error {
          constructor(t, r) {
            super(r), this.message = r, this.key = t
          }
        }
        class $n {
          constructor(t, r = []) {
            this.parent = t, this.bindings = {};
            for (const [o, c] of r) this.bindings[o] = c
          }
          concat(t) {
            return new $n(this, t)
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`)
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t)
          }
        }
        const zt = {
            kind: "null"
          },
          nt = {
            kind: "number"
          },
          $t = {
            kind: "string"
          },
          Gt = {
            kind: "boolean"
          },
          xt = {
            kind: "color"
          },
          It = {
            kind: "projectionDefinition"
          },
          Wt = {
            kind: "object"
          },
          Nt = {
            kind: "value"
          },
          gr = {
            kind: "collator"
          },
          Qr = {
            kind: "formatted"
          },
          zr = {
            kind: "padding"
          },
          Hr = {
            kind: "colorArray"
          },
          hn = {
            kind: "numberArray"
          },
          Yt = {
            kind: "resolvedImage"
          },
          tn = {
            kind: "variableAnchorOffsetCollection"
          };

        function an(n, t) {
          return {
            kind: "array",
            itemType: n,
            N: t
          }
        }

        function ln(n) {
          if (n.kind === "array") {
            const t = ln(n.itemType);
            return typeof n.N == "number" ? `array<${t}, ${n.N}>` : n.itemType.kind === "value" ? "array" : `array<${t}>`
          }
          return n.kind
        }
        const Pi = [zt, nt, $t, Gt, xt, It, Qr, Wt, an(Nt), zr, hn, Hr, Yt, tn];

        function In(n, t) {
          if (t.kind === "error") return null;
          if (n.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !In(n.itemType, t.itemType)) && (typeof n.N != "number" || n.N === t.N)) return null
          } else {
            if (n.kind === t.kind) return null;
            if (n.kind === "value") {
              for (const r of Pi)
                if (!In(r, t)) return null
            }
          }
          return `Expected ${ln(n)} but found ${ln(t)} instead.`
        }

        function fi(n, t) {
          return t.some((r => r.kind === n.kind))
        }

        function Dn(n, t) {
          return t.some((r => r === "null" ? n === null : r === "array" ? Array.isArray(n) : r === "object" ? n && !Array.isArray(n) && typeof n == "object" : r === typeof n))
        }

        function ni(n, t) {
          return n.kind === "array" && t.kind === "array" ? n.itemType.kind === t.itemType.kind && typeof n.N == "number" : n.kind === t.kind
        }
        const qi = .96422,
          Ui = .82521,
          ki = 4 / 29,
          Mi = 6 / 29,
          $i = 3 * Mi * Mi,
          na = Mi * Mi * Mi,
          ua = Math.PI / 180,
          ba = 180 / Math.PI;

        function wa(n) {
          return (n %= 360) < 0 && (n += 360), n
        }

        function Ca([n, t, r, o]) {
          let c, m;
          const _ = da((.2225045 * (n = ha(n)) + .7168786 * (t = ha(t)) + .0606169 * (r = ha(r))) / 1);
          n === t && t === r ? c = m = _ : (c = da((.4360747 * n + .3850649 * t + .1430804 * r) / qi), m = da((.0139322 * n + .0971045 * t + .7141733 * r) / Ui));
          const v = 116 * _ - 16;
          return [v < 0 ? 0 : v, 500 * (c - _), 200 * (_ - m), o]
        }

        function ha(n) {
          return n <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4)
        }

        function da(n) {
          return n > na ? Math.pow(n, 1 / 3) : n / $i + ki
        }

        function pa([n, t, r, o]) {
          let c = (n + 16) / 116,
            m = isNaN(t) ? c : c + t / 500,
            _ = isNaN(r) ? c : c - r / 200;
          return c = 1 * Za(c), m = qi * Za(m), _ = Ui * Za(_), [go(3.1338561 * m - 1.6168667 * c - .4906146 * _), go(-.9787684 * m + 1.9161415 * c + .033454 * _), go(.0719453 * m - .2289914 * c + 1.4052427 * _), o]
        }

        function go(n) {
          return (n = n <= .00304 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055) < 0 ? 0 : n > 1 ? 1 : n
        }

        function Za(n) {
          return n > Mi ? n * n * n : $i * (n - ki)
        }
        const hs = Object.hasOwn || function(n, t) {
          return Object.prototype.hasOwnProperty.call(n, t)
        };

        function Va(n, t) {
          return hs(n, t) ? n[t] : void 0
        }

        function ft(n) {
          return parseInt(n.padEnd(2, n), 16) / 255
        }

        function Kt(n, t) {
          return er(t ? n / 100 : n, 0, 1)
        }

        function er(n, t, r) {
          return Math.min(Math.max(t, n), r)
        }

        function Cn(n) {
          return !n.some(Number.isNaN)
        }
        const Rn = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        };

        function Qn(n, t, r) {
          return n + r * (t - n)
        }

        function En(n, t, r) {
          return n.map(((o, c) => Qn(o, t[c], r)))
        }
        class kr {
          constructor(t, r, o, c = 1, m = !0) {
            this.r = t, this.g = r, this.b = o, this.a = c, m || (this.r *= c, this.g *= c, this.b *= c, c || this.overwriteGetter("rgb", [t, r, o, c]))
          }
          static parse(t) {
            if (t instanceof kr) return t;
            if (typeof t != "string") return;
            const r = (function(o) {
              if ((o = o.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const c = Va(Rn, o);
              if (c) {
                const [_, v, w] = c;
                return [_ / 255, v / 255, w / 255, 1]
              }
              if (o.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(o)) {
                const _ = o.length < 6 ? 1 : 2;
                let v = 1;
                return [ft(o.slice(v, v += _)), ft(o.slice(v, v += _)), ft(o.slice(v, v += _)), ft(o.slice(v, v + _) || "ff")]
              }
              if (o.startsWith("rgb")) {
                const _ = o.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (_) {
                  const [v, w, S, A, L, j, q, $, J, te, he, je] = _, be = [A || " ", q || " ", te].join("");
                  if (be === "  " || be === "  /" || be === ",," || be === ",,,") {
                    const Me = [S, j, J].join(""),
                      et = Me === "%%%" ? 100 : Me === "" ? 255 : 0;
                    if (et) {
                      const ct = [er(+w / et, 0, 1), er(+L / et, 0, 1), er(+$ / et, 0, 1), he ? Kt(+he, je) : 1];
                      if (Cn(ct)) return ct
                    }
                  }
                  return
                }
              }
              const m = o.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (m) {
                const [_, v, w, S, A, L, j, q, $] = m, J = [w || " ", A || " ", j].join("");
                if (J === "  " || J === "  /" || J === ",," || J === ",,,") {
                  const te = [+v, er(+S, 0, 100), er(+L, 0, 100), q ? Kt(+q, $) : 1];
                  if (Cn(te)) return (function([he, je, be, Me]) {
                    function et(ct) {
                      const Et = (ct + he / 30) % 12,
                        ar = je * Math.min(be, 1 - be);
                      return be - ar * Math.max(-1, Math.min(Et - 3, 9 - Et, 1))
                    }
                    return he = wa(he), je /= 100, be /= 100, [et(0), et(8), et(4), Me]
                  })(te)
                }
              }
            })(t);
            return r ? new kr(...r, !1) : void 0
          }
          get rgb() {
            const {
              r: t,
              g: r,
              b: o,
              a: c
            } = this, m = c || 1 / 0;
            return this.overwriteGetter("rgb", [t / m, r / m, o / m, c])
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [r, o, c, m] = Ca(t), _ = Math.sqrt(o * o + c * c);
              return [Math.round(1e4 * _) ? wa(Math.atan2(c, o) * ba) : NaN, _, r, m]
            })(this.rgb))
          }
          get lab() {
            return this.overwriteGetter("lab", Ca(this.rgb))
          }
          overwriteGetter(t, r) {
            return Object.defineProperty(this, t, {
              value: r
            }), r
          }
          toString() {
            const [t, r, o, c] = this.rgb;
            return `rgba(${[t,r,o].map((m=>Math.round(255*m))).join(",")},${c})`
          }
          static interpolate(t, r, o, c = "rgb") {
            switch (c) {
              case "rgb": {
                const [m, _, v, w] = En(t.rgb, r.rgb, o);
                return new kr(m, _, v, w, !1)
              }
              case "hcl": {
                const [m, _, v, w] = t.hcl, [S, A, L, j] = r.hcl;
                let q, $;
                if (isNaN(m) || isNaN(S)) isNaN(m) ? isNaN(S) ? q = NaN : (q = S, v !== 1 && v !== 0 || ($ = A)) : (q = m, L !== 1 && L !== 0 || ($ = _));
                else {
                  let be = S - m;
                  S > m && be > 180 ? be -= 360 : S < m && m - S > 180 && (be += 360), q = m + o * be
                }
                const [J, te, he, je] = (function([be, Me, et, ct]) {
                  return be = isNaN(be) ? 0 : be * ua, pa([et, Math.cos(be) * Me, Math.sin(be) * Me, ct])
                })([q, $ ?? Qn(_, A, o), Qn(v, L, o), Qn(w, j, o)]);
                return new kr(J, te, he, je, !1)
              }
              case "lab": {
                const [m, _, v, w] = pa(En(t.lab, r.lab, o));
                return new kr(m, _, v, w, !1)
              }
            }
          }
        }
        kr.black = new kr(0, 0, 0, 1), kr.white = new kr(1, 1, 1, 1), kr.transparent = new kr(0, 0, 0, 0), kr.red = new kr(1, 0, 0, 1);
        class Ai {
          constructor(t, r, o) {
            this.sensitivity = t ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = o, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
              sensitivity: this.sensitivity,
              usage: "search"
            })
          }
          compare(t, r) {
            return this.collator.compare(t, r)
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
          }
        }
        const br = ["bottom", "center", "top"];
        class ir {
          constructor(t, r, o, c, m, _) {
            this.text = t, this.image = r, this.scale = o, this.fontStack = c, this.textColor = m, this.verticalAlign = _
          }
        }
        class rn {
          constructor(t) {
            this.sections = t
          }
          static fromString(t) {
            return new rn([new ir(t, null, null, null, null, null)])
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t => t.text.length !== 0 || t.image && t.image.name.length !== 0))
          }
          static factory(t) {
            return t instanceof rn ? t : rn.fromString(t)
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t => t.text)).join("")
          }
        }
        class sn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof sn) return t;
            if (typeof t == "number") return new sn([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const r of t)
                if (typeof r != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]]
              }
              return new sn(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, o) {
            return new sn(En(t.values, r.values, o))
          }
        }
        class yn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof yn) return t;
            if (typeof t == "number") return new yn([t]);
            if (Array.isArray(t)) {
              for (const r of t)
                if (typeof r != "number") return;
              return new yn(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, o) {
            return new yn(En(t.values, r.values, o))
          }
        }
        class cn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof cn) return t;
            if (typeof t == "string") {
              const o = kr.parse(t);
              return o ? new cn([o]) : void 0
            }
            if (!Array.isArray(t)) return;
            const r = [];
            for (const o of t) {
              if (typeof o != "string") return;
              const c = kr.parse(o);
              if (!c) return;
              r.push(c)
            }
            return new cn(r)
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, o, c = "rgb") {
            const m = [];
            if (t.values.length != r.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${r.values.length}), cannot interpolate.`);
            for (let _ = 0; _ < t.values.length; _++) m.push(kr.interpolate(t.values[_], r.values[_], o, c));
            return new cn(m)
          }
        }
        class Jr extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError"
          }
          toJSON() {
            return this.message
          }
        }
        const Jn = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Bn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Bn) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let r = 0; r < t.length; r += 2) {
                const o = t[r],
                  c = t[r + 1];
                if (typeof o != "string" || !Jn.has(o) || !Array.isArray(c) || c.length !== 2 || typeof c[0] != "number" || typeof c[1] != "number") return
              }
              return new Bn(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, o) {
            const c = t.values,
              m = r.values;
            if (c.length !== m.length) throw new Jr(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${r.toString()}`);
            const _ = [];
            for (let v = 0; v < c.length; v += 2) {
              if (c[v] !== m[v]) throw new Jr(`Cannot interpolate values containing mismatched anchors. from[${v}]: ${c[v]}, to[${v}]: ${m[v]}`);
              _.push(c[v]);
              const [w, S] = c[v + 1], [A, L] = m[v + 1];
              _.push([Qn(w, A, o), Qn(S, L, o)])
            }
            return new Bn(_)
          }
        }
        class xn {
          constructor(t) {
            this.name = t.name, this.available = t.available
          }
          toString() {
            return this.name
          }
          static fromString(t) {
            return t ? new xn({
              name: t,
              available: !1
            }) : null
          }
        }
        class pn {
          constructor(t, r, o) {
            this.from = t, this.to = r, this.transition = o
          }
          static interpolate(t, r, o) {
            return new pn(t, r, o)
          }
          static parse(t) {
            return t instanceof pn ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new pn(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new pn(t.from, t.to, t.transition) : typeof t == "string" ? new pn(t, t, 1) : void 0
          }
        }

        function Xr(n, t, r, o) {
          return typeof n == "number" && n >= 0 && n <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? o === void 0 || typeof o == "number" && o >= 0 && o <= 1 ? null : `Invalid rgba value [${[n,t,r,o].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof o=="number"?[n,t,r,o]:[n,t,r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }

        function On(n) {
          if (n === null || typeof n == "string" || typeof n == "boolean" || typeof n == "number" || n instanceof pn || n instanceof kr || n instanceof Ai || n instanceof rn || n instanceof sn || n instanceof yn || n instanceof cn || n instanceof Bn || n instanceof xn) return !0;
          if (Array.isArray(n)) {
            for (const t of n)
              if (!On(t)) return !1;
            return !0
          }
          if (typeof n == "object") {
            for (const t in n)
              if (!On(n[t])) return !1;
            return !0
          }
          return !1
        }

        function mr(n) {
          if (n === null) return zt;
          if (typeof n == "string") return $t;
          if (typeof n == "boolean") return Gt;
          if (typeof n == "number") return nt;
          if (n instanceof kr) return xt;
          if (n instanceof pn) return It;
          if (n instanceof Ai) return gr;
          if (n instanceof rn) return Qr;
          if (n instanceof sn) return zr;
          if (n instanceof yn) return hn;
          if (n instanceof cn) return Hr;
          if (n instanceof Bn) return tn;
          if (n instanceof xn) return Yt;
          if (Array.isArray(n)) {
            const t = n.length;
            let r;
            for (const o of n) {
              const c = mr(o);
              if (r) {
                if (r === c) continue;
                r = Nt;
                break
              }
              r = c
            }
            return an(r || Nt, t)
          }
          return Wt
        }

        function _r(n) {
          const t = typeof n;
          return n === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(n) : n instanceof kr || n instanceof pn || n instanceof rn || n instanceof sn || n instanceof yn || n instanceof cn || n instanceof Bn || n instanceof xn ? n.toString() : JSON.stringify(n)
        }
        class Vn {
          constructor(t, r) {
            this.type = t, this.value = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (!On(t[1])) return r.error("invalid value");
            const o = t[1];
            let c = mr(o);
            const m = r.expectedType;
            return c.kind !== "array" || c.N !== 0 || !m || m.kind !== "array" || typeof m.N == "number" && m.N !== 0 || (c = m), new Vn(c, o)
          }
          evaluate() {
            return this.value
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        const Wr = {
          string: $t,
          number: nt,
          boolean: Gt,
          object: Wt
        };
        class jn {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let o, c = 1;
            const m = t[0];
            if (m === "array") {
              let v, w;
              if (t.length > 2) {
                const S = t[1];
                if (typeof S != "string" || !(S in Wr) || S === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
                v = Wr[S], c++
              } else v = Nt;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2);
                w = t[2], c++
              }
              o = an(v, w)
            } else {
              if (!Wr[m]) throw new Error(`Types doesn't contain name = ${m}`);
              o = Wr[m]
            }
            const _ = [];
            for (; c < t.length; c++) {
              const v = r.parse(t[c], c, Nt);
              if (!v) return null;
              _.push(v)
            }
            return new jn(o, _)
          }
          evaluate(t) {
            for (let r = 0; r < this.args.length; r++) {
              const o = this.args[r].evaluate(t);
              if (!In(this.type, mr(o))) return o;
              if (r === this.args.length - 1) throw new Jr(`Expected value to be of type ${ln(this.type)}, but found ${ln(mr(o))} instead.`)
            }
            throw new Error
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const qn = {
          "to-boolean": Gt,
          "to-color": xt,
          "to-number": nt,
          "to-string": $t
        };
        class oi {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const o = t[0];
            if (!qn[o]) throw new Error(`Can't parse ${o} as it is not part of the known types`);
            if ((o === "to-boolean" || o === "to-string") && t.length !== 2) return r.error("Expected one argument.");
            const c = qn[o],
              m = [];
            for (let _ = 1; _ < t.length; _++) {
              const v = r.parse(t[_], _, Nt);
              if (!v) return null;
              m.push(v)
            }
            return new oi(c, m)
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let r, o;
                for (const c of this.args) {
                  if (r = c.evaluate(t), o = null, r instanceof kr) return r;
                  if (typeof r == "string") {
                    const m = t.parseColor(r);
                    if (m) return m
                  } else if (Array.isArray(r) && (o = r.length < 3 || r.length > 4 ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : Xr(r[0], r[1], r[2], r[3]), !o)) return new kr(r[0] / 255, r[1] / 255, r[2] / 255, r[3])
                }
                throw new Jr(o || `Could not parse color from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "padding": {
                let r;
                for (const o of this.args) {
                  r = o.evaluate(t);
                  const c = sn.parse(r);
                  if (c) return c
                }
                throw new Jr(`Could not parse padding from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "numberArray": {
                let r;
                for (const o of this.args) {
                  r = o.evaluate(t);
                  const c = yn.parse(r);
                  if (c) return c
                }
                throw new Jr(`Could not parse numberArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "colorArray": {
                let r;
                for (const o of this.args) {
                  r = o.evaluate(t);
                  const c = cn.parse(r);
                  if (c) return c
                }
                throw new Jr(`Could not parse colorArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "variableAnchorOffsetCollection": {
                let r;
                for (const o of this.args) {
                  r = o.evaluate(t);
                  const c = Bn.parse(r);
                  if (c) return c
                }
                throw new Jr(`Could not parse variableAnchorOffsetCollection from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "number": {
                let r = null;
                for (const o of this.args) {
                  if (r = o.evaluate(t), r === null) return 0;
                  const c = Number(r);
                  if (!isNaN(c)) return c
                }
                throw new Jr(`Could not convert ${JSON.stringify(r)} to number.`)
              }
              case "formatted":
                return rn.fromString(_r(this.args[0].evaluate(t)));
              case "resolvedImage":
                return xn.fromString(_r(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return _r(this.args[0].evaluate(t))
            }
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const vo = ["Unknown", "Point", "LineString", "Polygon"];
        class Bo {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = new Map, this.availableImages = null, this.canonical = null
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? vo[this.feature.type] : this.feature.type : null
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null
          }
          canonicalID() {
            return this.canonical
          }
          properties() {
            return this.feature && this.feature.properties || {}
          }
          parseColor(t) {
            let r = this._parseColorCache.get(t);
            return r || (r = kr.parse(t), this._parseColorCache.set(t, r)), r
          }
        }
        class Qa {
          constructor(t, r, o = [], c, m = new $n, _ = []) {
            this.registry = t, this.path = o, this.key = o.map((v => `[${v}]`)).join(""), this.scope = m, this.errors = _, this.expectedType = c, this._isConstant = r
          }
          parse(t, r, o, c, m = {}) {
            return r ? this.concat(r, o, c)._parse(t, m) : this._parse(t, m)
          }
          _parse(t, r) {
            function o(c, m, _) {
              return _ === "assert" ? new jn(m, [c]) : _ === "coerce" ? new oi(m, [c]) : c
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const c = t[0];
              if (typeof c != "string") return this.error(`Expression name must be a string, but found ${typeof c} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const m = this.registry[c];
              if (m) {
                let _ = m.parse(t, this);
                if (!_) return null;
                if (this.expectedType) {
                  const v = this.expectedType,
                    w = _.type;
                  if (v.kind !== "string" && v.kind !== "number" && v.kind !== "boolean" && v.kind !== "object" && v.kind !== "array" || w.kind !== "value") {
                    if (v.kind === "projectionDefinition" && ["string", "array"].includes(w.kind) || ["color", "formatted", "resolvedImage"].includes(v.kind) && ["value", "string"].includes(w.kind) || ["padding", "numberArray"].includes(v.kind) && ["value", "number", "array"].includes(w.kind) || v.kind === "colorArray" && ["value", "string", "array"].includes(w.kind) || v.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(w.kind)) _ = o(_, v, r.typeAnnotation || "coerce");
                    else if (this.checkSubtype(v, w)) return null
                  } else _ = o(_, v, r.typeAnnotation || "assert")
                }
                if (!(_ instanceof Vn) && _.type.kind !== "resolvedImage" && this._isConstant(_)) {
                  const v = new Bo;
                  try {
                    _ = new Vn(_.type, _.evaluate(v))
                  } catch (w) {
                    return this.error(w.message), null
                  }
                }
                return _
              }
              return this.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0)
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
          }
          concat(t, r, o) {
            const c = typeof t == "number" ? this.path.concat(t) : this.path,
              m = o ? this.scope.concat(o) : this.scope;
            return new Qa(this.registry, this._isConstant, c, r || null, m, this.errors)
          }
          error(t, ...r) {
            const o = `${this.key}${r.map((c=>`[${c}]`)).join("")}`;
            this.errors.push(new fn(o, t))
          }
          checkSubtype(t, r) {
            const o = In(t, r);
            return o && this.error(o), o
          }
        }
        class eo {
          constructor(t, r) {
            this.type = r.type, this.bindings = [].concat(t), this.result = r
          }
          evaluate(t) {
            return this.result.evaluate(t)
          }
          eachChild(t) {
            for (const r of this.bindings) t(r[1]);
            t(this.result)
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);
            const o = [];
            for (let m = 1; m < t.length - 1; m += 2) {
              const _ = t[m];
              if (typeof _ != "string") return r.error(`Expected string, but found ${typeof _} instead.`, m);
              if (/[^a-zA-Z0-9_]/.test(_)) return r.error("Variable names must contain only alphanumeric characters or '_'.", m);
              const v = r.parse(t[m + 1], m + 1);
              if (!v) return null;
              o.push([_, v])
            }
            const c = r.parse(t[t.length - 1], t.length - 1, r.expectedType, o);
            return c ? new eo(o, c) : null
          }
          outputDefined() {
            return this.result.outputDefined()
          }
        }
        class yo {
          constructor(t, r) {
            this.type = r.type, this.name = t, this.boundExpression = r
          }
          static parse(t, r) {
            if (t.length !== 2 || typeof t[1] != "string") return r.error("'var' expression requires exactly one string literal argument.");
            const o = t[1];
            return r.scope.has(o) ? new yo(o, r.scope.get(o)) : r.error(`Unknown variable "${o}". Make sure "${o}" has been bound in an enclosing "let" expression before using it.`, 1)
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t)
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        class Fo {
          constructor(t, r, o) {
            this.type = t, this.index = r, this.input = o
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const o = r.parse(t[1], 1, nt),
              c = r.parse(t[2], 2, an(r.expectedType || Nt));
            return o && c ? new Fo(c.type.itemType, o, c) : null
          }
          evaluate(t) {
            const r = this.index.evaluate(t),
              o = this.input.evaluate(t);
            if (r < 0) throw new Jr(`Array index out of bounds: ${r} < 0.`);
            if (r >= o.length) throw new Jr(`Array index out of bounds: ${r} > ${o.length-1}.`);
            if (r !== Math.floor(r)) throw new Jr(`Array index must be an integer, but found ${r} instead.`);
            return o[r]
          }
          eachChild(t) {
            t(this.index), t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class ds {
          constructor(t, r) {
            this.type = Gt, this.needle = t, this.haystack = r
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const o = r.parse(t[1], 1, Nt),
              c = r.parse(t[2], 2, Nt);
            return o && c ? fi(o.type, [Gt, $t, nt, zt, Nt]) ? new ds(o, c) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${ln(o.type)} instead`) : null
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              o = this.haystack.evaluate(t);
            if (!o) return !1;
            if (!Dn(r, ["boolean", "string", "number", "null"])) throw new Jr(`Expected first argument to be of type boolean, string, number or null, but found ${ln(mr(r))} instead.`);
            if (!Dn(o, ["string", "array"])) throw new Jr(`Expected second argument to be of type array or string, but found ${ln(mr(o))} instead.`);
            return o.indexOf(r) >= 0
          }
          eachChild(t) {
            t(this.needle), t(this.haystack)
          }
          outputDefined() {
            return !0
          }
        }
        class Gi {
          constructor(t, r, o) {
            this.type = nt, this.needle = t, this.haystack = r, this.fromIndex = o
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);
            const o = r.parse(t[1], 1, Nt),
              c = r.parse(t[2], 2, Nt);
            if (!o || !c) return null;
            if (!fi(o.type, [Gt, $t, nt, zt, Nt])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${ln(o.type)} instead`);
            if (t.length === 4) {
              const m = r.parse(t[3], 3, nt);
              return m ? new Gi(o, c, m) : null
            }
            return new Gi(o, c)
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              o = this.haystack.evaluate(t);
            if (!Dn(r, ["boolean", "string", "number", "null"])) throw new Jr(`Expected first argument to be of type boolean, string, number or null, but found ${ln(mr(r))} instead.`);
            let c;
            if (this.fromIndex && (c = this.fromIndex.evaluate(t)), Dn(o, ["string"])) {
              const m = o.indexOf(r, c);
              return m === -1 ? -1 : [...o.slice(0, m)].length
            }
            if (Dn(o, ["array"])) return o.indexOf(r, c);
            throw new Jr(`Expected second argument to be of type array or string, but found ${ln(mr(o))} instead.`)
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex)
          }
          outputDefined() {
            return !1
          }
        }
        class si {
          constructor(t, r, o, c, m, _) {
            this.inputType = t, this.type = r, this.input = o, this.cases = c, this.outputs = m, this.otherwise = _
          }
          static parse(t, r) {
            if (t.length < 5) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 1) return r.error("Expected an even number of arguments.");
            let o, c;
            r.expectedType && r.expectedType.kind !== "value" && (c = r.expectedType);
            const m = {},
              _ = [];
            for (let S = 2; S < t.length - 1; S += 2) {
              let A = t[S];
              const L = t[S + 1];
              Array.isArray(A) || (A = [A]);
              const j = r.concat(S);
              if (A.length === 0) return j.error("Expected at least one branch label.");
              for (const $ of A) {
                if (typeof $ != "number" && typeof $ != "string") return j.error("Branch labels must be numbers or strings.");
                if (typeof $ == "number" && Math.abs($) > Number.MAX_SAFE_INTEGER) return j.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof $ == "number" && Math.floor($) !== $) return j.error("Numeric branch labels must be integer values.");
                if (o) {
                  if (j.checkSubtype(o, mr($))) return null
                } else o = mr($);
                if (m[String($)] !== void 0) return j.error("Branch labels must be unique.");
                m[String($)] = _.length
              }
              const q = r.parse(L, S, c);
              if (!q) return null;
              c = c || q.type, _.push(q)
            }
            const v = r.parse(t[1], 1, Nt);
            if (!v) return null;
            const w = r.parse(t[t.length - 1], t.length - 1, c);
            return w ? v.type.kind !== "value" && r.concat(1).checkSubtype(o, v.type) ? null : new si(o, c, v, m, _, w) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            return (mr(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(t)
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class to {
          constructor(t, r, o) {
            this.type = t, this.branches = r, this.otherwise = o
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 0) return r.error("Expected an odd number of arguments.");
            let o;
            r.expectedType && r.expectedType.kind !== "value" && (o = r.expectedType);
            const c = [];
            for (let _ = 1; _ < t.length - 1; _ += 2) {
              const v = r.parse(t[_], _, Gt);
              if (!v) return null;
              const w = r.parse(t[_ + 1], _ + 1, o);
              if (!w) return null;
              c.push([v, w]), o = o || w.type
            }
            const m = r.parse(t[t.length - 1], t.length - 1, o);
            if (!m) return null;
            if (!o) throw new Error("Can't infer output type");
            return new to(o, c, m)
          }
          evaluate(t) {
            for (const [r, o] of this.branches)
              if (r.evaluate(t)) return o.evaluate(t);
            return this.otherwise.evaluate(t)
          }
          eachChild(t) {
            for (const [r, o] of this.branches) t(r), t(o);
            t(this.otherwise)
          }
          outputDefined() {
            return this.branches.every((([t, r]) => r.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class qa {
          constructor(t, r, o, c) {
            this.type = t, this.input = r, this.beginIndex = o, this.endIndex = c
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);
            const o = r.parse(t[1], 1, Nt),
              c = r.parse(t[2], 2, nt);
            if (!o || !c) return null;
            if (!fi(o.type, [an(Nt), $t, Nt])) return r.error(`Expected first argument to be of type array or string, but found ${ln(o.type)} instead`);
            if (t.length === 4) {
              const m = r.parse(t[3], 3, nt);
              return m ? new qa(o.type, o, c, m) : null
            }
            return new qa(o.type, o, c)
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              o = this.beginIndex.evaluate(t);
            let c;
            if (this.endIndex && (c = this.endIndex.evaluate(t)), Dn(r, ["string"])) return [...r].slice(o, c).join("");
            if (Dn(r, ["array"])) return r.slice(o, c);
            throw new Jr(`Expected first argument to be of type array or string, but found ${ln(mr(r))} instead.`)
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex)
          }
          outputDefined() {
            return !1
          }
        }

        function ro(n, t) {
          const r = n.length - 1;
          let o, c, m = 0,
            _ = r,
            v = 0;
          for (; m <= _;)
            if (v = Math.floor((m + _) / 2), o = n[v], c = n[v + 1], o <= t) {
              if (v === r || t < c) return v;
              m = v + 1
            } else {
              if (!(o > t)) throw new Jr("Input is not a number.");
              _ = v - 1
            } return 0
        }
        class Fn {
          constructor(t, r, o) {
            this.type = t, this.input = r, this.labels = [], this.outputs = [];
            for (const [c, m] of o) this.labels.push(c), this.outputs.push(m)
          }
          static parse(t, r) {
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            const o = r.parse(t[1], 1, nt);
            if (!o) return null;
            const c = [];
            let m = null;
            r.expectedType && r.expectedType.kind !== "value" && (m = r.expectedType);
            for (let _ = 1; _ < t.length; _ += 2) {
              const v = _ === 1 ? -1 / 0 : t[_],
                w = t[_ + 1],
                S = _,
                A = _ + 1;
              if (typeof v != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', S);
              if (c.length && c[c.length - 1][0] >= v) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', S);
              const L = r.parse(w, A, m);
              if (!L) return null;
              m = m || L.type, c.push([v, L])
            }
            return new Fn(m, o, c)
          }
          evaluate(t) {
            const r = this.labels,
              o = this.outputs;
            if (r.length === 1) return o[0].evaluate(t);
            const c = this.input.evaluate(t);
            if (c <= r[0]) return o[0].evaluate(t);
            const m = r.length;
            return c >= r[m - 1] ? o[m - 1].evaluate(t) : o[ro(r, c)].evaluate(t)
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function ps(n) {
          return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
        }
        var Oo, Oc, Op = (function() {
            if (Oc) return Oo;

            function n(t, r, o, c) {
              this.cx = 3 * t, this.bx = 3 * (o - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (c - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = o, this.p2y = c
            }
            return Oc = 1, Oo = n, n.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var o = t, c = 0; c < 8; c++) {
                  var m = this.sampleCurveX(o) - t;
                  if (Math.abs(m) < r) return o;
                  var _ = this.sampleCurveDerivativeX(o);
                  if (Math.abs(_) < 1e-6) break;
                  o -= m / _
                }
                var v = 0,
                  w = 1;
                for (o = t, c = 0; c < 20 && (m = this.sampleCurveX(o), !(Math.abs(m - t) < r)); c++) t > m ? v = o : w = o, o = .5 * (w - v) + v;
                return o
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, Oo
          })(),
          fs = ps(Op);
        class Ei {
          constructor(t, r, o, c, m) {
            this.type = t, this.operator = r, this.interpolation = o, this.input = c, this.labels = [], this.outputs = [];
            for (const [_, v] of m) this.labels.push(_), this.outputs.push(v)
          }
          static interpolationFactor(t, r, o, c) {
            let m = 0;
            if (t.name === "exponential") m = Vs(r, t.base, o, c);
            else if (t.name === "linear") m = Vs(r, 1, o, c);
            else if (t.name === "cubic-bezier") {
              const _ = t.controlPoints;
              m = new fs(_[0], _[1], _[2], _[3]).solve(Vs(r, 1, o, c))
            }
            return m
          }
          static parse(t, r) {
            let [o, c, m, ..._] = t;
            if (!Array.isArray(c) || c.length === 0) return r.error("Expected an interpolation type expression.", 1);
            if (c[0] === "linear") c = {
              name: "linear"
            };
            else if (c[0] === "exponential") {
              const S = c[1];
              if (typeof S != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1);
              c = {
                name: "exponential",
                base: S
              }
            } else {
              if (c[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(c[0])}`, 1, 0);
              {
                const S = c.slice(1);
                if (S.length !== 4 || S.some((A => typeof A != "number" || A < 0 || A > 1))) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                c = {
                  name: "cubic-bezier",
                  controlPoints: S
                }
              }
            }
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            if (m = r.parse(m, 2, nt), !m) return null;
            const v = [];
            let w = null;
            o !== "interpolate-hcl" && o !== "interpolate-lab" || r.expectedType == Hr ? r.expectedType && r.expectedType.kind !== "value" && (w = r.expectedType) : w = xt;
            for (let S = 0; S < _.length; S += 2) {
              const A = _[S],
                L = _[S + 1],
                j = S + 3,
                q = S + 4;
              if (typeof A != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', j);
              if (v.length && v[v.length - 1][0] >= A) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', j);
              const $ = r.parse(L, q, w);
              if (!$) return null;
              w = w || $.type, v.push([A, $])
            }
            return ni(w, nt) || ni(w, It) || ni(w, xt) || ni(w, zr) || ni(w, hn) || ni(w, Hr) || ni(w, tn) || ni(w, an(nt)) ? new Ei(w, o, c, m, v) : r.error(`Type ${ln(w)} is not interpolatable.`)
          }
          evaluate(t) {
            const r = this.labels,
              o = this.outputs;
            if (r.length === 1) return o[0].evaluate(t);
            const c = this.input.evaluate(t);
            if (c <= r[0]) return o[0].evaluate(t);
            const m = r.length;
            if (c >= r[m - 1]) return o[m - 1].evaluate(t);
            const _ = ro(r, c),
              v = Ei.interpolationFactor(this.interpolation, c, r[_], r[_ + 1]),
              w = o[_].evaluate(t),
              S = o[_ + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Qn(w, S, v);
                  case "color":
                    return kr.interpolate(w, S, v);
                  case "padding":
                    return sn.interpolate(w, S, v);
                  case "colorArray":
                    return cn.interpolate(w, S, v);
                  case "numberArray":
                    return yn.interpolate(w, S, v);
                  case "variableAnchorOffsetCollection":
                    return Bn.interpolate(w, S, v);
                  case "array":
                    return En(w, S, v);
                  case "projectionDefinition":
                    return pn.interpolate(w, S, v)
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return kr.interpolate(w, S, v, "hcl");
                  case "colorArray":
                    return cn.interpolate(w, S, v, "hcl")
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return kr.interpolate(w, S, v, "lab");
                  case "colorArray":
                    return cn.interpolate(w, S, v, "lab")
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function Vs(n, t, r, o) {
          const c = o - r,
            m = n - r;
          return c === 0 ? 0 : t === 1 ? m / c : (Math.pow(t, m) - 1) / (Math.pow(t, c) - 1)
        }
        const Ua = {
          color: kr.interpolate,
          number: Qn,
          padding: sn.interpolate,
          numberArray: yn.interpolate,
          colorArray: cn.interpolate,
          variableAnchorOffsetCollection: Bn.interpolate,
          array: En
        };
        class qs {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let o = null;
            const c = r.expectedType;
            c && c.kind !== "value" && (o = c);
            const m = [];
            for (const v of t.slice(1)) {
              const w = r.parse(v, 1 + m.length, o, void 0, {
                typeAnnotation: "omit"
              });
              if (!w) return null;
              o = o || w.type, m.push(w)
            }
            if (!o) throw new Error("No output type");
            const _ = c && m.some((v => In(c, v.type)));
            return new qs(_ ? Nt : o, m)
          }
          evaluate(t) {
            let r, o = null,
              c = 0;
            for (const m of this.args)
              if (c++, o = m.evaluate(t), o && o instanceof xn && !o.available && (r || (r = o.name), o = null, c === this.args.length && (o = r)), o !== null) break;
            return o
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }

        function Us(n, t) {
          return n === "==" || n === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
        }

        function $s(n, t, r, o) {
          return o.compare(t, r) === 0
        }

        function Fi(n, t, r) {
          const o = n !== "==" && n !== "!=";
          return class z0 {
            constructor(m, _, v) {
              this.type = Gt, this.lhs = m, this.rhs = _, this.collator = v, this.hasUntypedArgument = m.type.kind === "value" || _.type.kind === "value"
            }
            static parse(m, _) {
              if (m.length !== 3 && m.length !== 4) return _.error("Expected two or three arguments.");
              const v = m[0];
              let w = _.parse(m[1], 1, Nt);
              if (!w) return null;
              if (!Us(v, w.type)) return _.concat(1).error(`"${v}" comparisons are not supported for type '${ln(w.type)}'.`);
              let S = _.parse(m[2], 2, Nt);
              if (!S) return null;
              if (!Us(v, S.type)) return _.concat(2).error(`"${v}" comparisons are not supported for type '${ln(S.type)}'.`);
              if (w.type.kind !== S.type.kind && w.type.kind !== "value" && S.type.kind !== "value") return _.error(`Cannot compare types '${ln(w.type)}' and '${ln(S.type)}'.`);
              o && (w.type.kind === "value" && S.type.kind !== "value" ? w = new jn(S.type, [w]) : w.type.kind !== "value" && S.type.kind === "value" && (S = new jn(w.type, [S])));
              let A = null;
              if (m.length === 4) {
                if (w.type.kind !== "string" && S.type.kind !== "string" && w.type.kind !== "value" && S.type.kind !== "value") return _.error("Cannot use collator to compare non-string types.");
                if (A = _.parse(m[3], 3, gr), !A) return null
              }
              return new z0(w, S, A)
            }
            evaluate(m) {
              const _ = this.lhs.evaluate(m),
                v = this.rhs.evaluate(m);
              if (o && this.hasUntypedArgument) {
                const w = mr(_),
                  S = mr(v);
                if (w.kind !== S.kind || w.kind !== "string" && w.kind !== "number") throw new Jr(`Expected arguments for "${n}" to be (string, string) or (number, number), but found (${w.kind}, ${S.kind}) instead.`)
              }
              if (this.collator && !o && this.hasUntypedArgument) {
                const w = mr(_),
                  S = mr(v);
                if (w.kind !== "string" || S.kind !== "string") return t(m, _, v)
              }
              return this.collator ? r(m, _, v, this.collator.evaluate(m)) : t(m, _, v)
            }
            eachChild(m) {
              m(this.lhs), m(this.rhs), this.collator && m(this.collator)
            }
            outputDefined() {
              return !0
            }
          }
        }
        const Hh = Fi("==", (function(n, t, r) {
            return t === r
          }), $s),
          Pl = Fi("!=", (function(n, t, r) {
            return t !== r
          }), (function(n, t, r, o) {
            return !$s(0, t, r, o)
          })),
          jp = Fi("<", (function(n, t, r) {
            return t < r
          }), (function(n, t, r, o) {
            return o.compare(t, r) < 0
          })),
          jc = Fi(">", (function(n, t, r) {
            return t > r
          }), (function(n, t, r, o) {
            return o.compare(t, r) > 0
          })),
          Np = Fi("<=", (function(n, t, r) {
            return t <= r
          }), (function(n, t, r, o) {
            return o.compare(t, r) <= 0
          })),
          Zp = Fi(">=", (function(n, t, r) {
            return t >= r
          }), (function(n, t, r, o) {
            return o.compare(t, r) >= 0
          }));
        class kl {
          constructor(t, r, o) {
            this.type = gr, this.locale = o, this.caseSensitive = t, this.diacriticSensitive = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected one argument.");
            const o = t[1];
            if (typeof o != "object" || Array.isArray(o)) return r.error("Collator options argument must be an object.");
            const c = r.parse(o["case-sensitive"] !== void 0 && o["case-sensitive"], 1, Gt);
            if (!c) return null;
            const m = r.parse(o["diacritic-sensitive"] !== void 0 && o["diacritic-sensitive"], 1, Gt);
            if (!m) return null;
            let _ = null;
            return o.locale && (_ = r.parse(o.locale, 1, $t), !_) ? null : new kl(c, m, _)
          }
          evaluate(t) {
            return new Ai(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null)
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale)
          }
          outputDefined() {
            return !1
          }
        }
        class Nc {
          constructor(t, r, o, c, m) {
            this.type = $t, this.number = t, this.locale = r, this.currency = o, this.minFractionDigits = c, this.maxFractionDigits = m
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error("Expected two arguments.");
            const o = r.parse(t[1], 1, nt);
            if (!o) return null;
            const c = t[2];
            if (typeof c != "object" || Array.isArray(c)) return r.error("NumberFormat options argument must be an object.");
            let m = null;
            if (c.locale && (m = r.parse(c.locale, 1, $t), !m)) return null;
            let _ = null;
            if (c.currency && (_ = r.parse(c.currency, 1, $t), !_)) return null;
            let v = null;
            if (c["min-fraction-digits"] && (v = r.parse(c["min-fraction-digits"], 1, nt), !v)) return null;
            let w = null;
            return c["max-fraction-digits"] && (w = r.parse(c["max-fraction-digits"], 1, nt), !w) ? null : new Nc(o, m, _, v, w)
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
              style: this.currency ? "currency" : "decimal",
              currency: this.currency ? this.currency.evaluate(t) : void 0,
              minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
              maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
            }).format(this.number.evaluate(t))
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits)
          }
          outputDefined() {
            return !1
          }
        }
        class jo {
          constructor(t) {
            this.type = Qr, this.sections = t
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const o = t[1];
            if (!Array.isArray(o) && typeof o == "object") return r.error("First argument must be an image or text section.");
            const c = [];
            let m = !1;
            for (let _ = 1; _ <= t.length - 1; ++_) {
              const v = t[_];
              if (m && typeof v == "object" && !Array.isArray(v)) {
                m = !1;
                let w = null;
                if (v["font-scale"] && (w = r.parse(v["font-scale"], 1, nt), !w)) return null;
                let S = null;
                if (v["text-font"] && (S = r.parse(v["text-font"], 1, an($t)), !S)) return null;
                let A = null;
                if (v["text-color"] && (A = r.parse(v["text-color"], 1, xt), !A)) return null;
                let L = null;
                if (v["vertical-align"]) {
                  if (typeof v["vertical-align"] == "string" && !br.includes(v["vertical-align"])) return r.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${v["vertical-align"]}' instead.`);
                  if (L = r.parse(v["vertical-align"], 1, $t), !L) return null
                }
                const j = c[c.length - 1];
                j.scale = w, j.font = S, j.textColor = A, j.verticalAlign = L
              } else {
                const w = r.parse(t[_], 1, Nt);
                if (!w) return null;
                const S = w.type.kind;
                if (S !== "string" && S !== "value" && S !== "null" && S !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                m = !0, c.push({
                  content: w,
                  scale: null,
                  font: null,
                  textColor: null,
                  verticalAlign: null
                })
              }
            }
            return new jo(c)
          }
          evaluate(t) {
            return new rn(this.sections.map((r => {
              const o = r.content.evaluate(t);
              return mr(o) === Yt ? new ir("", o, null, null, null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null) : new ir(_r(o), null, r.scale ? r.scale.evaluate(t) : null, r.font ? r.font.evaluate(t).join(",") : null, r.textColor ? r.textColor.evaluate(t) : null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null)
            })))
          }
          eachChild(t) {
            for (const r of this.sections) t(r.content), r.scale && t(r.scale), r.font && t(r.font), r.textColor && t(r.textColor), r.verticalAlign && t(r.verticalAlign)
          }
          outputDefined() {
            return !1
          }
        }
        class Zc {
          constructor(t) {
            this.type = Yt, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected two arguments.");
            const o = r.parse(t[1], 1, $t);
            return o ? new Zc(o) : r.error("No image name provided.")
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              o = xn.fromString(r);
            return o && t.availableImages && (o.available = t.availableImages.indexOf(r) > -1), o
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class Ml {
          constructor(t) {
            this.type = nt, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const o = r.parse(t[1], 1);
            return o ? o.type.kind !== "array" && o.type.kind !== "string" && o.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${ln(o.type)} instead.`) : new Ml(o) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            if (typeof r == "string") return [...r].length;
            if (Array.isArray(r)) return r.length;
            throw new Jr(`Expected value to be of type string or array, but found ${ln(mr(r))} instead.`)
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        const Ta = 8192;

        function Vp(n, t) {
          const r = (180 + n[0]) / 360,
            o = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n[1] * Math.PI / 360))) / 360,
            c = Math.pow(2, t.z);
          return [Math.round(r * c * Ta), Math.round(o * c * Ta)]
        }

        function Al(n, t) {
          const r = Math.pow(2, t.z);
          return [(c = (n[0] / Ta + t.x) / r, 360 * c - 180), (o = (n[1] / Ta + t.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * o) * Math.PI / 180)) - 90)];
          var o, c
        }

        function Gs(n, t) {
          n[0] = Math.min(n[0], t[0]), n[1] = Math.min(n[1], t[1]), n[2] = Math.max(n[2], t[0]), n[3] = Math.max(n[3], t[1])
        }

        function Ws(n, t) {
          return !(n[0] <= t[0] || n[2] >= t[2] || n[1] <= t[1] || n[3] >= t[3])
        }

        function qp(n, t, r) {
          const o = n[0] - t[0],
            c = n[1] - t[1],
            m = n[0] - r[0],
            _ = n[1] - r[1];
          return o * _ - m * c == 0 && o * m <= 0 && c * _ <= 0
        }

        function El(n, t, r, o) {
          return (c = [o[0] - r[0], o[1] - r[1]])[0] * (m = [t[0] - n[0], t[1] - n[1]])[1] - c[1] * m[0] != 0 && !(!Xh(n, t, r, o) || !Xh(r, o, n, t));
          var c, m
        }

        function Up(n, t, r) {
          for (const o of r)
            for (let c = 0; c < o.length - 1; ++c)
              if (El(n, t, o[c], o[c + 1])) return !0;
          return !1
        }

        function No(n, t, r = !1) {
          let o = !1;
          for (const v of t)
            for (let w = 0; w < v.length - 1; w++) {
              if (qp(n, v[w], v[w + 1])) return r;
              (m = v[w])[1] > (c = n)[1] != (_ = v[w + 1])[1] > c[1] && c[0] < (_[0] - m[0]) * (c[1] - m[1]) / (_[1] - m[1]) + m[0] && (o = !o)
            }
          var c, m, _;
          return o
        }

        function Jh(n, t) {
          for (const r of t)
            if (No(n, r)) return !0;
          return !1
        }

        function Vc(n, t) {
          for (const r of n)
            if (!No(r, t)) return !1;
          for (let r = 0; r < n.length - 1; ++r)
            if (Up(n[r], n[r + 1], t)) return !1;
          return !0
        }

        function $p(n, t) {
          for (const r of t)
            if (Vc(n, r)) return !0;
          return !1
        }

        function Xh(n, t, r, o) {
          const c = o[0] - r[0],
            m = o[1] - r[1],
            _ = (n[0] - r[0]) * m - c * (n[1] - r[1]),
            v = (t[0] - r[0]) * m - c * (t[1] - r[1]);
          return _ > 0 && v < 0 || _ < 0 && v > 0
        }

        function qc(n, t, r) {
          const o = [];
          for (let c = 0; c < n.length; c++) {
            const m = [];
            for (let _ = 0; _ < n[c].length; _++) {
              const v = Vp(n[c][_], r);
              Gs(t, v), m.push(v)
            }
            o.push(m)
          }
          return o
        }

        function Yh(n, t, r) {
          const o = [];
          for (let c = 0; c < n.length; c++) {
            const m = qc(n[c], t, r);
            o.push(m)
          }
          return o
        }

        function zl(n, t, r, o) {
          if (n[0] < r[0] || n[0] > r[2]) {
            const c = .5 * o;
            let m = n[0] - r[0] > c ? -o : r[0] - n[0] > c ? o : 0;
            m === 0 && (m = n[0] - r[2] > c ? -o : r[2] - n[0] > c ? o : 0), n[0] += m
          }
          Gs(t, n)
        }

        function Kh(n, t, r, o) {
          const c = Math.pow(2, o.z) * Ta,
            m = [o.x * Ta, o.y * Ta],
            _ = [];
          for (const v of n)
            for (const w of v) {
              const S = [w.x + m[0], w.y + m[1]];
              zl(S, t, r, c), _.push(S)
            }
          return _
        }

        function Qh(n, t, r, o) {
          const c = Math.pow(2, o.z) * Ta,
            m = [o.x * Ta, o.y * Ta],
            _ = [];
          for (const w of n) {
            const S = [];
            for (const A of w) {
              const L = [A.x + m[0], A.y + m[1]];
              Gs(t, L), S.push(L)
            }
            _.push(S)
          }
          if (t[2] - t[0] <= c / 2) {
            (v = t)[0] = v[1] = 1 / 0, v[2] = v[3] = -1 / 0;
            for (const w of _)
              for (const S of w) zl(S, t, r, c)
          }
          var v;
          return _
        }
        class Zo {
          constructor(t, r) {
            this.type = Gt, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (On(t[1])) {
              const o = t[1];
              if (o.type === "FeatureCollection") {
                const c = [];
                for (const m of o.features) {
                  const {
                    type: _,
                    coordinates: v
                  } = m.geometry;
                  _ === "Polygon" && c.push(v), _ === "MultiPolygon" && c.push(...v)
                }
                if (c.length) return new Zo(o, {
                  type: "MultiPolygon",
                  coordinates: c
                })
              } else if (o.type === "Feature") {
                const c = o.geometry.type;
                if (c === "Polygon" || c === "MultiPolygon") return new Zo(o, o.geometry)
              } else if (o.type === "Polygon" || o.type === "MultiPolygon") return new Zo(o, o)
            }
            return r.error("'within' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, o) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  m = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  _ = r.canonicalID();
                if (o.type === "Polygon") {
                  const v = qc(o.coordinates, m, _),
                    w = Kh(r.geometry(), c, m, _);
                  if (!Ws(c, m)) return !1;
                  for (const S of w)
                    if (!No(S, v)) return !1
                }
                if (o.type === "MultiPolygon") {
                  const v = Yh(o.coordinates, m, _),
                    w = Kh(r.geometry(), c, m, _);
                  if (!Ws(c, m)) return !1;
                  for (const S of w)
                    if (!Jh(S, v)) return !1
                }
                return !0
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, o) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  m = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  _ = r.canonicalID();
                if (o.type === "Polygon") {
                  const v = qc(o.coordinates, m, _),
                    w = Qh(r.geometry(), c, m, _);
                  if (!Ws(c, m)) return !1;
                  for (const S of w)
                    if (!Vc(S, v)) return !1
                }
                if (o.type === "MultiPolygon") {
                  const v = Yh(o.coordinates, m, _),
                    w = Qh(r.geometry(), c, m, _);
                  if (!Ws(c, m)) return !1;
                  for (const S of w)
                    if (!$p(S, v)) return !1
                }
                return !0
              })(t, this.geometries)
            }
            return !1
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        let Uc = class {
          constructor(n = [], t = (r, o) => r < o ? -1 : r > o ? 1 : 0) {
            if (this.data = n, this.length = this.data.length, this.compare = t, this.length > 0)
              for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r)
          }
          push(n) {
            this.data.push(n), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const n = this.data[0],
              t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), n
          }
          peek() {
            return this.data[0]
          }
          _up(n) {
            const {
              data: t,
              compare: r
            } = this, o = t[n];
            for (; n > 0;) {
              const c = n - 1 >> 1,
                m = t[c];
              if (r(o, m) >= 0) break;
              t[n] = m, n = c
            }
            t[n] = o
          }
          _down(n) {
            const {
              data: t,
              compare: r
            } = this, o = this.length >> 1, c = t[n];
            for (; n < o;) {
              let m = 1 + (n << 1);
              const _ = m + 1;
              if (_ < this.length && r(t[_], t[m]) < 0 && (m = _), r(t[m], c) >= 0) break;
              t[n] = t[m], n = m
            }
            t[n] = c
          }
        };

        function $c(n, t, r = 0, o = n.length - 1, c = Gp) {
          for (; o > r;) {
            if (o - r > 600) {
              const w = o - r + 1,
                S = t - r + 1,
                A = Math.log(w),
                L = .5 * Math.exp(2 * A / 3),
                j = .5 * Math.sqrt(A * L * (w - L) / w) * (S - w / 2 < 0 ? -1 : 1);
              $c(n, t, Math.max(r, Math.floor(t - S * L / w + j)), Math.min(o, Math.floor(t + (w - S) * L / w + j)), c)
            }
            const m = n[t];
            let _ = r,
              v = o;
            for (Hs(n, r, t), c(n[o], m) > 0 && Hs(n, r, o); _ < v;) {
              for (Hs(n, _, v), _++, v--; c(n[_], m) < 0;) _++;
              for (; c(n[v], m) > 0;) v--
            }
            c(n[r], m) === 0 ? Hs(n, r, v) : (v++, Hs(n, v, o)), v <= t && (r = v + 1), t <= v && (o = v - 1)
          }
        }

        function Hs(n, t, r) {
          const o = n[t];
          n[t] = n[r], n[r] = o
        }

        function Gp(n, t) {
          return n < t ? -1 : n > t ? 1 : 0
        }

        function Js(n, t) {
          if (n.length <= 1) return [n];
          const r = [];
          let o, c;
          for (const m of n) {
            const _ = Wp(m);
            _ !== 0 && (m.area = Math.abs(_), c === void 0 && (c = _ < 0), c === _ < 0 ? (o && r.push(o), o = [m]) : o.push(m))
          }
          if (o && r.push(o), t > 1)
            for (let m = 0; m < r.length; m++) r[m].length <= t || ($c(r[m], t, 1, r[m].length - 1, ed), r[m] = r[m].slice(0, t));
          return r
        }

        function ed(n, t) {
          return t.area - n.area
        }

        function Wp(n) {
          let t = 0;
          for (let r, o, c = 0, m = n.length, _ = m - 1; c < m; _ = c++) r = n[c], o = n[_], t += (o.x - r.x) * (r.y + o.y);
          return t
        }
        const td = 1 / 298.257223563,
          rd = td * (2 - td),
          Gc = Math.PI / 180;
        class Wc {
          constructor(t) {
            const r = 6378.137 * Gc * 1e3,
              o = Math.cos(t * Gc),
              c = 1 / (1 - rd * (1 - o * o)),
              m = Math.sqrt(c);
            this.kx = r * m * o, this.ky = r * m * c * (1 - rd)
          }
          distance(t, r) {
            const o = this.wrap(t[0] - r[0]) * this.kx,
              c = (t[1] - r[1]) * this.ky;
            return Math.sqrt(o * o + c * c)
          }
          pointOnLine(t, r) {
            let o, c, m, _, v = 1 / 0;
            for (let w = 0; w < t.length - 1; w++) {
              let S = t[w][0],
                A = t[w][1],
                L = this.wrap(t[w + 1][0] - S) * this.kx,
                j = (t[w + 1][1] - A) * this.ky,
                q = 0;
              L === 0 && j === 0 || (q = (this.wrap(r[0] - S) * this.kx * L + (r[1] - A) * this.ky * j) / (L * L + j * j), q > 1 ? (S = t[w + 1][0], A = t[w + 1][1]) : q > 0 && (S += L / this.kx * q, A += j / this.ky * q)), L = this.wrap(r[0] - S) * this.kx, j = (r[1] - A) * this.ky;
              const $ = L * L + j * j;
              $ < v && (v = $, o = S, c = A, m = w, _ = q)
            }
            return {
              point: [o, c],
              index: m,
              t: Math.max(0, Math.min(1, _))
            }
          }
          wrap(t) {
            for (; t < -180;) t += 360;
            for (; t > 180;) t -= 360;
            return t
          }
        }

        function nd(n, t) {
          return t[0] - n[0]
        }

        function Ll(n) {
          return n[1] - n[0] + 1
        }

        function no(n, t) {
          return n[1] >= n[0] && n[1] < t
        }

        function wn(n, t) {
          if (n[0] > n[1]) return [null, null];
          const r = Ll(n);
          if (t) {
            if (r === 2) return [n, null];
            const c = Math.floor(r / 2);
            return [
              [n[0], n[0] + c],
              [n[0] + c, n[1]]
            ]
          }
          if (r === 1) return [n, null];
          const o = Math.floor(r / 2) - 1;
          return [
            [n[0], n[0] + o],
            [n[0] + o + 1, n[1]]
          ]
        }

        function Hc(n, t) {
          if (!no(t, n.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let o = t[0]; o <= t[1]; ++o) Gs(r, n[o]);
          return r
        }

        function Jc(n) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const r of n)
            for (const o of r) Gs(t, o);
          return t
        }

        function id(n) {
          return n[0] !== -1 / 0 && n[1] !== -1 / 0 && n[2] !== 1 / 0 && n[3] !== 1 / 0
        }

        function Xc(n, t, r) {
          if (!id(n) || !id(t)) return NaN;
          let o = 0,
            c = 0;
          return n[2] < t[0] && (o = t[0] - n[2]), n[0] > t[2] && (o = n[0] - t[2]), n[1] > t[3] && (c = n[1] - t[3]), n[3] < t[1] && (c = t[1] - n[3]), r.distance([0, 0], [o, c])
        }

        function Vo(n, t, r) {
          const o = r.pointOnLine(t, n);
          return r.distance(n, o.point)
        }

        function Yc(n, t, r, o, c) {
          const m = Math.min(Vo(n, [r, o], c), Vo(t, [r, o], c)),
            _ = Math.min(Vo(r, [n, t], c), Vo(o, [n, t], c));
          return Math.min(m, _)
        }

        function Hp(n, t, r, o, c) {
          if (!no(t, n.length) || !no(o, r.length)) return 1 / 0;
          let m = 1 / 0;
          for (let _ = t[0]; _ < t[1]; ++_) {
            const v = n[_],
              w = n[_ + 1];
            for (let S = o[0]; S < o[1]; ++S) {
              const A = r[S],
                L = r[S + 1];
              if (El(v, w, A, L)) return 0;
              m = Math.min(m, Yc(v, w, A, L, c))
            }
          }
          return m
        }

        function Jp(n, t, r, o, c) {
          if (!no(t, n.length) || !no(o, r.length)) return NaN;
          let m = 1 / 0;
          for (let _ = t[0]; _ <= t[1]; ++_)
            for (let v = o[0]; v <= o[1]; ++v)
              if (m = Math.min(m, c.distance(n[_], r[v])), m === 0) return m;
          return m
        }

        function Xp(n, t, r) {
          if (No(n, t, !0)) return 0;
          let o = 1 / 0;
          for (const c of t) {
            const m = c[0],
              _ = c[c.length - 1];
            if (m !== _ && (o = Math.min(o, Vo(n, [_, m], r)), o === 0)) return o;
            const v = r.pointOnLine(c, n);
            if (o = Math.min(o, r.distance(n, v.point)), o === 0) return o
          }
          return o
        }

        function Yp(n, t, r, o) {
          if (!no(t, n.length)) return NaN;
          for (let m = t[0]; m <= t[1]; ++m)
            if (No(n[m], r, !0)) return 0;
          let c = 1 / 0;
          for (let m = t[0]; m < t[1]; ++m) {
            const _ = n[m],
              v = n[m + 1];
            for (const w of r)
              for (let S = 0, A = w.length, L = A - 1; S < A; L = S++) {
                const j = w[L],
                  q = w[S];
                if (El(_, v, j, q)) return 0;
                c = Math.min(c, Yc(_, v, j, q, o))
              }
          }
          return c
        }

        function ad(n, t) {
          for (const r of n)
            for (const o of r)
              if (No(o, t, !0)) return !0;
          return !1
        }

        function Kp(n, t, r, o = 1 / 0) {
          const c = Jc(n),
            m = Jc(t);
          if (o !== 1 / 0 && Xc(c, m, r) >= o) return o;
          if (Ws(c, m)) {
            if (ad(n, t)) return 0
          } else if (ad(t, n)) return 0;
          let _ = 1 / 0;
          for (const v of n)
            for (let w = 0, S = v.length, A = S - 1; w < S; A = w++) {
              const L = v[A],
                j = v[w];
              for (const q of t)
                for (let $ = 0, J = q.length, te = J - 1; $ < J; te = $++) {
                  const he = q[te],
                    je = q[$];
                  if (El(L, j, he, je)) return 0;
                  _ = Math.min(_, Yc(L, j, he, je, r))
                }
            }
          return _
        }

        function od(n, t, r, o, c, m) {
          if (!m) return;
          const _ = Xc(Hc(o, m), c, r);
          _ < t && n.push([_, m, [0, 0]])
        }

        function Dl(n, t, r, o, c, m, _) {
          if (!m || !_) return;
          const v = Xc(Hc(o, m), Hc(c, _), r);
          v < t && n.push([v, m, _])
        }

        function Rl(n, t, r, o, c = 1 / 0) {
          let m = Math.min(o.distance(n[0], r[0][0]), c);
          if (m === 0) return m;
          const _ = new Uc([
              [0, [0, n.length - 1],
                [0, 0]
              ]
            ], nd),
            v = Jc(r);
          for (; _.length > 0;) {
            const w = _.pop();
            if (w[0] >= m) continue;
            const S = w[1],
              A = t ? 50 : 100;
            if (Ll(S) <= A) {
              if (!no(S, n.length)) return NaN;
              if (t) {
                const L = Yp(n, S, r, o);
                if (isNaN(L) || L === 0) return L;
                m = Math.min(m, L)
              } else
                for (let L = S[0]; L <= S[1]; ++L) {
                  const j = Xp(n[L], r, o);
                  if (m = Math.min(m, j), m === 0) return 0
                }
            } else {
              const L = wn(S, t);
              od(_, m, o, n, v, L[0]), od(_, m, o, n, v, L[1])
            }
          }
          return m
        }

        function Bl(n, t, r, o, c, m = 1 / 0) {
          let _ = Math.min(m, c.distance(n[0], r[0]));
          if (_ === 0) return _;
          const v = new Uc([
            [0, [0, n.length - 1],
              [0, r.length - 1]
            ]
          ], nd);
          for (; v.length > 0;) {
            const w = v.pop();
            if (w[0] >= _) continue;
            const S = w[1],
              A = w[2],
              L = t ? 50 : 100,
              j = o ? 50 : 100;
            if (Ll(S) <= L && Ll(A) <= j) {
              if (!no(S, n.length) && no(A, r.length)) return NaN;
              let q;
              if (t && o) q = Hp(n, S, r, A, c), _ = Math.min(_, q);
              else if (t && !o) {
                const $ = n.slice(S[0], S[1] + 1);
                for (let J = A[0]; J <= A[1]; ++J)
                  if (q = Vo(r[J], $, c), _ = Math.min(_, q), _ === 0) return _
              } else if (!t && o) {
                const $ = r.slice(A[0], A[1] + 1);
                for (let J = S[0]; J <= S[1]; ++J)
                  if (q = Vo(n[J], $, c), _ = Math.min(_, q), _ === 0) return _
              } else q = Jp(n, S, r, A, c), _ = Math.min(_, q)
            } else {
              const q = wn(S, t),
                $ = wn(A, o);
              Dl(v, _, c, n, r, q[0], $[0]), Dl(v, _, c, n, r, q[0], $[1]), Dl(v, _, c, n, r, q[1], $[0]), Dl(v, _, c, n, r, q[1], $[1])
            }
          }
          return _
        }

        function Kc(n) {
          return n.type === "MultiPolygon" ? n.coordinates.map((t => ({
            type: "Polygon",
            coordinates: t
          }))) : n.type === "MultiLineString" ? n.coordinates.map((t => ({
            type: "LineString",
            coordinates: t
          }))) : n.type === "MultiPoint" ? n.coordinates.map((t => ({
            type: "Point",
            coordinates: t
          }))) : [n]
        }
        class qo {
          constructor(t, r) {
            this.type = nt, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'distance' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (On(t[1])) {
              const o = t[1];
              if (o.type === "FeatureCollection") return new qo(o, o.features.map((c => Kc(c.geometry))).flat());
              if (o.type === "Feature") return new qo(o, Kc(o.geometry));
              if ("type" in o && "coordinates" in o) return new qo(o, Kc(o))
            }
            return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, o) {
                const c = r.geometry(),
                  m = c.flat().map((w => Al([w.x, w.y], r.canonical)));
                if (c.length === 0) return NaN;
                const _ = new Wc(m[0][1]);
                let v = 1 / 0;
                for (const w of o) {
                  switch (w.type) {
                    case "Point":
                      v = Math.min(v, Bl(m, !1, [w.coordinates], !1, _, v));
                      break;
                    case "LineString":
                      v = Math.min(v, Bl(m, !1, w.coordinates, !0, _, v));
                      break;
                    case "Polygon":
                      v = Math.min(v, Rl(m, !1, w.coordinates, _, v))
                  }
                  if (v === 0) return v
                }
                return v
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, o) {
                const c = r.geometry(),
                  m = c.flat().map((w => Al([w.x, w.y], r.canonical)));
                if (c.length === 0) return NaN;
                const _ = new Wc(m[0][1]);
                let v = 1 / 0;
                for (const w of o) {
                  switch (w.type) {
                    case "Point":
                      v = Math.min(v, Bl(m, !0, [w.coordinates], !1, _, v));
                      break;
                    case "LineString":
                      v = Math.min(v, Bl(m, !0, w.coordinates, !0, _, v));
                      break;
                    case "Polygon":
                      v = Math.min(v, Rl(m, !0, w.coordinates, _, v))
                  }
                  if (v === 0) return v
                }
                return v
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(r, o) {
                const c = r.geometry();
                if (c.length === 0 || c[0].length === 0) return NaN;
                const m = Js(c, 0).map((w => w.map((S => S.map((A => Al([A.x, A.y], r.canonical))))))),
                  _ = new Wc(m[0][0][0][1]);
                let v = 1 / 0;
                for (const w of o)
                  for (const S of m) {
                    switch (w.type) {
                      case "Point":
                        v = Math.min(v, Rl([w.coordinates], !1, S, _, v));
                        break;
                      case "LineString":
                        v = Math.min(v, Rl(w.coordinates, !0, S, _, v));
                        break;
                      case "Polygon":
                        v = Math.min(v, Kp(S, w.coordinates, _, v))
                    }
                    if (v === 0) return v
                  }
                return v
              })(t, this.geometries)
            }
            return NaN
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        class Xs {
          constructor(t) {
            this.type = Nt, this.key = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const o = t[1];
            return o == null ? r.error("Global state property must be defined.") : typeof o != "string" ? r.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Xs(o)
          }
          evaluate(t) {
            var r;
            const o = (r = t.globals) === null || r === void 0 ? void 0 : r.globalState;
            return o && Object.keys(o).length !== 0 ? Va(o, this.key) : null
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        const ms = {
          "==": Hh,
          "!=": Pl,
          ">": jc,
          "<": jp,
          ">=": Zp,
          "<=": Np,
          array: jn,
          at: Fo,
          boolean: jn,
          case: to,
          coalesce: qs,
          collator: kl,
          format: jo,
          image: Zc,
          in: ds,
          "index-of": Gi,
          interpolate: Ei,
          "interpolate-hcl": Ei,
          "interpolate-lab": Ei,
          length: Ml,
          let: eo,
          literal: Vn,
          match: si,
          number: jn,
          "number-format": Nc,
          object: jn,
          slice: qa,
          step: Fn,
          string: jn,
          "to-boolean": oi,
          "to-color": oi,
          "to-number": oi,
          "to-string": oi,
          var: yo,
          within: Zo,
          distance: qo,
          "global-state": Xs
        };
        class fa {
          constructor(t, r, o, c) {
            this.name = t, this.type = r, this._evaluate = o, this.args = c
          }
          evaluate(t) {
            return this._evaluate(t, this.args)
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return !1
          }
          static parse(t, r) {
            const o = t[0],
              c = fa.definitions[o];
            if (!c) return r.error(`Unknown expression "${o}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const m = Array.isArray(c) ? c[0] : c.type,
              _ = Array.isArray(c) ? [
                [c[1], c[2]]
              ] : c.overloads,
              v = _.filter((([S]) => !Array.isArray(S) || S.length === t.length - 1));
            let w = null;
            for (const [S, A] of v) {
              w = new Qa(r.registry, Fl, r.path, null, r.scope);
              const L = [];
              let j = !1;
              for (let q = 1; q < t.length; q++) {
                const $ = t[q],
                  J = Array.isArray(S) ? S[q - 1] : S.type,
                  te = w.parse($, 1 + L.length, J);
                if (!te) {
                  j = !0;
                  break
                }
                L.push(te)
              }
              if (!j)
                if (Array.isArray(S) && S.length !== L.length) w.error(`Expected ${S.length} arguments, but found ${L.length} instead.`);
                else {
                  for (let q = 0; q < L.length; q++) {
                    const $ = Array.isArray(S) ? S[q] : S.type,
                      J = L[q];
                    w.concat(q + 1).checkSubtype($, J.type)
                  }
                  if (w.errors.length === 0) return new fa(o, m, A, L)
                }
            }
            if (v.length === 1) r.errors.push(...w.errors);
            else {
              const S = (v.length ? v : _).map((([L]) => {
                  return j = L, Array.isArray(j) ? `(${j.map(ln).join(", ")})` : `(${ln(j.type)}...)`;
                  var j
                })).join(" | "),
                A = [];
              for (let L = 1; L < t.length; L++) {
                const j = r.parse(t[L], 1 + A.length);
                if (!j) return null;
                A.push(ln(j.type))
              }
              r.error(`Expected arguments of type ${S}, but found (${A.join(", ")}) instead.`)
            }
            return null
          }
          static register(t, r) {
            fa.definitions = r;
            for (const o in r) t[o] = fa
          }
        }

        function sd(n, [t, r, o, c]) {
          t = t.evaluate(n), r = r.evaluate(n), o = o.evaluate(n);
          const m = c ? c.evaluate(n) : 1,
            _ = Xr(t, r, o, m);
          if (_) throw new Jr(_);
          return new kr(t / 255, r / 255, o / 255, m, !1)
        }

        function ld(n, t) {
          return n in t
        }

        function Qc(n, t) {
          const r = t[n];
          return r === void 0 ? null : r
        }

        function Uo(n) {
          return {
            type: n
          }
        }

        function Fl(n) {
          if (n instanceof yo) return Fl(n.boundExpression);
          if (n instanceof fa && n.name === "error" || n instanceof kl || n instanceof Zo || n instanceof qo || n instanceof Xs) return !1;
          const t = n instanceof oi || n instanceof jn;
          let r = !0;
          return n.eachChild((o => {
            r = t ? r && Fl(o) : r && o instanceof Vn
          })), !!r && Ol(n) && jl(n, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
        }

        function Ol(n) {
          if (n instanceof fa && (n.name === "get" && n.args.length === 1 || n.name === "feature-state" || n.name === "has" && n.args.length === 1 || n.name === "properties" || n.name === "geometry-type" || n.name === "id" || /^filter-/.test(n.name)) || n instanceof Zo || n instanceof qo) return !1;
          let t = !0;
          return n.eachChild((r => {
            t && !Ol(r) && (t = !1)
          })), t
        }

        function Ys(n) {
          if (n instanceof fa && n.name === "feature-state") return !1;
          let t = !0;
          return n.eachChild((r => {
            t && !Ys(r) && (t = !1)
          })), t
        }

        function jl(n, t) {
          if (n instanceof fa && t.indexOf(n.name) >= 0) return !1;
          let r = !0;
          return n.eachChild((o => {
            r && !jl(o, t) && (r = !1)
          })), r
        }

        function cd(n) {
          return {
            result: "success",
            value: n
          }
        }

        function _s(n) {
          return {
            result: "error",
            value: n
          }
        }

        function xo(n) {
          return n["property-type"] === "data-driven" || n["property-type"] === "cross-faded-data-driven"
        }

        function ud(n) {
          return !!n.expression && n.expression.parameters.indexOf("zoom") > -1
        }

        function eu(n) {
          return !!n.expression && n.expression.interpolated
        }

        function mn(n) {
          return n instanceof Number ? "number" : n instanceof String ? "string" : n instanceof Boolean ? "boolean" : Array.isArray(n) ? "array" : n === null ? "null" : typeof n
        }

        function Ks(n) {
          return typeof n == "object" && n !== null && !Array.isArray(n) && mr(n) === Wt
        }

        function Qp(n) {
          return n
        }

        function hd(n, t) {
          const r = n.stops && typeof n.stops[0][0] == "object",
            o = r || !(r || n.property !== void 0),
            c = n.type || (eu(t) ? "exponential" : "interval"),
            m = (function(A) {
              switch (A.type) {
                case "color":
                  return kr.parse;
                case "padding":
                  return sn.parse;
                case "numberArray":
                  return yn.parse;
                case "colorArray":
                  return cn.parse;
                default:
                  return null
              }
            })(t);
          if (m && ((n = bn({}, n)).stops && (n.stops = n.stops.map((A => [A[0], m(A[1])]))), n.default = m(n.default ? n.default : t.default)), n.colorSpace && (_ = n.colorSpace) !== "rgb" && _ !== "hcl" && _ !== "lab") throw new Error(`Unknown color space: "${n.colorSpace}"`);
          var _;
          const v = (function(A) {
            switch (A) {
              case "exponential":
                return pd;
              case "interval":
                return ef;
              case "categorical":
                return dd;
              case "identity":
                return tf;
              default:
                throw new Error(`Unknown function type "${A}"`)
            }
          })(c);
          let w, S;
          if (c === "categorical") {
            w = Object.create(null);
            for (const A of n.stops) w[A[0]] = A[1];
            S = typeof n.stops[0][0]
          }
          if (r) {
            const A = {},
              L = [];
            for (let $ = 0; $ < n.stops.length; $++) {
              const J = n.stops[$],
                te = J[0].zoom;
              A[te] === void 0 && (A[te] = {
                zoom: te,
                type: n.type,
                property: n.property,
                default: n.default,
                stops: []
              }, L.push(te)), A[te].stops.push([J[0].value, J[1]])
            }
            const j = [];
            for (const $ of L) j.push([A[$].zoom, hd(A[$], t)]);
            const q = {
              name: "linear"
            };
            return {
              kind: "composite",
              interpolationType: q,
              interpolationFactor: Ei.interpolationFactor.bind(void 0, q),
              zoomStops: j.map(($ => $[0])),
              evaluate: ({
                zoom: $
              }, J) => pd({
                stops: j,
                base: n.base
              }, t, $).evaluate($, J)
            }
          }
          if (o) {
            const A = c === "exponential" ? {
              name: "exponential",
              base: n.base !== void 0 ? n.base : 1
            } : null;
            return {
              kind: "camera",
              interpolationType: A,
              interpolationFactor: Ei.interpolationFactor.bind(void 0, A),
              zoomStops: n.stops.map((L => L[0])),
              evaluate: ({
                zoom: L
              }) => v(n, t, L, w, S)
            }
          }
          return {
            kind: "source",
            evaluate(A, L) {
              const j = L && L.properties ? L.properties[n.property] : void 0;
              return j === void 0 ? bo(n.default, t.default) : v(n, t, j, w, S)
            }
          }
        }

        function bo(n, t, r) {
          return n !== void 0 ? n : t !== void 0 ? t : r !== void 0 ? r : void 0
        }

        function dd(n, t, r, o, c) {
          return bo(typeof r === c ? o[r] : void 0, n.default, t.default)
        }

        function ef(n, t, r) {
          if (mn(r) !== "number") return bo(n.default, t.default);
          const o = n.stops.length;
          if (o === 1 || r <= n.stops[0][0]) return n.stops[0][1];
          if (r >= n.stops[o - 1][0]) return n.stops[o - 1][1];
          const c = ro(n.stops.map((m => m[0])), r);
          return n.stops[c][1]
        }

        function pd(n, t, r) {
          const o = n.base !== void 0 ? n.base : 1;
          if (mn(r) !== "number") return bo(n.default, t.default);
          const c = n.stops.length;
          if (c === 1 || r <= n.stops[0][0]) return n.stops[0][1];
          if (r >= n.stops[c - 1][0]) return n.stops[c - 1][1];
          const m = ro(n.stops.map((A => A[0])), r),
            _ = (function(A, L, j, q) {
              const $ = q - j,
                J = A - j;
              return $ === 0 ? 0 : L === 1 ? J / $ : (Math.pow(L, J) - 1) / (Math.pow(L, $) - 1)
            })(r, o, n.stops[m][0], n.stops[m + 1][0]),
            v = n.stops[m][1],
            w = n.stops[m + 1][1],
            S = Ua[t.type] || Qp;
          return typeof v.evaluate == "function" ? {
            evaluate(...A) {
              const L = v.evaluate.apply(void 0, A),
                j = w.evaluate.apply(void 0, A);
              if (L !== void 0 && j !== void 0) return S(L, j, _, n.colorSpace)
            }
          } : S(v, w, _, n.colorSpace)
        }

        function tf(n, t, r) {
          switch (t.type) {
            case "color":
              r = kr.parse(r);
              break;
            case "formatted":
              r = rn.fromString(r.toString());
              break;
            case "resolvedImage":
              r = xn.fromString(r.toString());
              break;
            case "padding":
              r = sn.parse(r);
              break;
            case "colorArray":
              r = cn.parse(r);
              break;
            case "numberArray":
              r = yn.parse(r);
              break;
            default:
              mn(r) === t.type || t.type === "enum" && t.values[r] || (r = void 0)
          }
          return bo(r, n.default, t.default)
        }
        fa.register(ms, {
          error: [{
              kind: "error"
            },
            [$t], (n, [t]) => {
              throw new Jr(t.evaluate(n))
            }
          ],
          typeof: [$t, [Nt], (n, [t]) => ln(mr(t.evaluate(n)))],
          "to-rgba": [an(nt, 4), [xt], (n, [t]) => {
            const [r, o, c, m] = t.evaluate(n).rgb;
            return [255 * r, 255 * o, 255 * c, m]
          }],
          rgb: [xt, [nt, nt, nt], sd],
          rgba: [xt, [nt, nt, nt, nt], sd],
          has: {
            type: Gt,
            overloads: [
              [
                [$t], (n, [t]) => ld(t.evaluate(n), n.properties())
              ],
              [
                [$t, Wt], (n, [t, r]) => ld(t.evaluate(n), r.evaluate(n))
              ]
            ]
          },
          get: {
            type: Nt,
            overloads: [
              [
                [$t], (n, [t]) => Qc(t.evaluate(n), n.properties())
              ],
              [
                [$t, Wt], (n, [t, r]) => Qc(t.evaluate(n), r.evaluate(n))
              ]
            ]
          },
          "feature-state": [Nt, [$t], (n, [t]) => Qc(t.evaluate(n), n.featureState || {})],
          properties: [Wt, [], n => n.properties()],
          "geometry-type": [$t, [], n => n.geometryType()],
          id: [Nt, [], n => n.id()],
          zoom: [nt, [], n => n.globals.zoom],
          "heatmap-density": [nt, [], n => n.globals.heatmapDensity || 0],
          elevation: [nt, [], n => n.globals.elevation || 0],
          "line-progress": [nt, [], n => n.globals.lineProgress || 0],
          accumulated: [Nt, [], n => n.globals.accumulated === void 0 ? null : n.globals.accumulated],
          "+": [nt, Uo(nt), (n, t) => {
            let r = 0;
            for (const o of t) r += o.evaluate(n);
            return r
          }],
          "*": [nt, Uo(nt), (n, t) => {
            let r = 1;
            for (const o of t) r *= o.evaluate(n);
            return r
          }],
          "-": {
            type: nt,
            overloads: [
              [
                [nt, nt], (n, [t, r]) => t.evaluate(n) - r.evaluate(n)
              ],
              [
                [nt], (n, [t]) => -t.evaluate(n)
              ]
            ]
          },
          "/": [nt, [nt, nt], (n, [t, r]) => t.evaluate(n) / r.evaluate(n)],
          "%": [nt, [nt, nt], (n, [t, r]) => t.evaluate(n) % r.evaluate(n)],
          ln2: [nt, [], () => Math.LN2],
          pi: [nt, [], () => Math.PI],
          e: [nt, [], () => Math.E],
          "^": [nt, [nt, nt], (n, [t, r]) => Math.pow(t.evaluate(n), r.evaluate(n))],
          sqrt: [nt, [nt], (n, [t]) => Math.sqrt(t.evaluate(n))],
          log10: [nt, [nt], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN10],
          ln: [nt, [nt], (n, [t]) => Math.log(t.evaluate(n))],
          log2: [nt, [nt], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN2],
          sin: [nt, [nt], (n, [t]) => Math.sin(t.evaluate(n))],
          cos: [nt, [nt], (n, [t]) => Math.cos(t.evaluate(n))],
          tan: [nt, [nt], (n, [t]) => Math.tan(t.evaluate(n))],
          asin: [nt, [nt], (n, [t]) => Math.asin(t.evaluate(n))],
          acos: [nt, [nt], (n, [t]) => Math.acos(t.evaluate(n))],
          atan: [nt, [nt], (n, [t]) => Math.atan(t.evaluate(n))],
          min: [nt, Uo(nt), (n, t) => Math.min(...t.map((r => r.evaluate(n))))],
          max: [nt, Uo(nt), (n, t) => Math.max(...t.map((r => r.evaluate(n))))],
          abs: [nt, [nt], (n, [t]) => Math.abs(t.evaluate(n))],
          round: [nt, [nt], (n, [t]) => {
            const r = t.evaluate(n);
            return r < 0 ? -Math.round(-r) : Math.round(r)
          }],
          floor: [nt, [nt], (n, [t]) => Math.floor(t.evaluate(n))],
          ceil: [nt, [nt], (n, [t]) => Math.ceil(t.evaluate(n))],
          "filter-==": [Gt, [$t, Nt], (n, [t, r]) => n.properties()[t.value] === r.value],
          "filter-id-==": [Gt, [Nt], (n, [t]) => n.id() === t.value],
          "filter-type-==": [Gt, [$t], (n, [t]) => n.geometryType() === t.value],
          "filter-<": [Gt, [$t, Nt], (n, [t, r]) => {
            const o = n.properties()[t.value],
              c = r.value;
            return typeof o == typeof c && o < c
          }],
          "filter-id-<": [Gt, [Nt], (n, [t]) => {
            const r = n.id(),
              o = t.value;
            return typeof r == typeof o && r < o
          }],
          "filter->": [Gt, [$t, Nt], (n, [t, r]) => {
            const o = n.properties()[t.value],
              c = r.value;
            return typeof o == typeof c && o > c
          }],
          "filter-id->": [Gt, [Nt], (n, [t]) => {
            const r = n.id(),
              o = t.value;
            return typeof r == typeof o && r > o
          }],
          "filter-<=": [Gt, [$t, Nt], (n, [t, r]) => {
            const o = n.properties()[t.value],
              c = r.value;
            return typeof o == typeof c && o <= c
          }],
          "filter-id-<=": [Gt, [Nt], (n, [t]) => {
            const r = n.id(),
              o = t.value;
            return typeof r == typeof o && r <= o
          }],
          "filter->=": [Gt, [$t, Nt], (n, [t, r]) => {
            const o = n.properties()[t.value],
              c = r.value;
            return typeof o == typeof c && o >= c
          }],
          "filter-id->=": [Gt, [Nt], (n, [t]) => {
            const r = n.id(),
              o = t.value;
            return typeof r == typeof o && r >= o
          }],
          "filter-has": [Gt, [Nt], (n, [t]) => t.value in n.properties()],
          "filter-has-id": [Gt, [], n => n.id() !== null && n.id() !== void 0],
          "filter-type-in": [Gt, [an($t)], (n, [t]) => t.value.indexOf(n.geometryType()) >= 0],
          "filter-id-in": [Gt, [an(Nt)], (n, [t]) => t.value.indexOf(n.id()) >= 0],
          "filter-in-small": [Gt, [$t, an(Nt)], (n, [t, r]) => r.value.indexOf(n.properties()[t.value]) >= 0],
          "filter-in-large": [Gt, [$t, an(Nt)], (n, [t, r]) => (function(o, c, m, _) {
            for (; m <= _;) {
              const v = m + _ >> 1;
              if (c[v] === o) return !0;
              c[v] > o ? _ = v - 1 : m = v + 1
            }
            return !1
          })(n.properties()[t.value], r.value, 0, r.value.length - 1)],
          all: {
            type: Gt,
            overloads: [
              [
                [Gt, Gt], (n, [t, r]) => t.evaluate(n) && r.evaluate(n)
              ],
              [Uo(Gt), (n, t) => {
                for (const r of t)
                  if (!r.evaluate(n)) return !1;
                return !0
              }]
            ]
          },
          any: {
            type: Gt,
            overloads: [
              [
                [Gt, Gt], (n, [t, r]) => t.evaluate(n) || r.evaluate(n)
              ],
              [Uo(Gt), (n, t) => {
                for (const r of t)
                  if (r.evaluate(n)) return !0;
                return !1
              }]
            ]
          },
          "!": [Gt, [Gt], (n, [t]) => !t.evaluate(n)],
          "is-supported-script": [Gt, [$t], (n, [t]) => {
            const r = n.globals && n.globals.isSupportedScript;
            return !r || r(t.evaluate(n))
          }],
          upcase: [$t, [$t], (n, [t]) => t.evaluate(n).toUpperCase()],
          downcase: [$t, [$t], (n, [t]) => t.evaluate(n).toLowerCase()],
          concat: [$t, Uo(Nt), (n, t) => t.map((r => _r(r.evaluate(n)))).join("")],
          "resolved-locale": [$t, [gr], (n, [t]) => t.evaluate(n).resolvedLocale()]
        });
        class tu {
          constructor(t, r) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new Bo, this._defaultValue = r ? (function(o) {
              if (o.type === "color" && Ks(o.default)) return new kr(0, 0, 0, 0);
              switch (o.type) {
                case "color":
                  return kr.parse(o.default) || null;
                case "padding":
                  return sn.parse(o.default) || null;
                case "numberArray":
                  return yn.parse(o.default) || null;
                case "colorArray":
                  return cn.parse(o.default) || null;
                case "variableAnchorOffsetCollection":
                  return Bn.parse(o.default) || null;
                case "projectionDefinition":
                  return pn.parse(o.default) || null;
                default:
                  return o.default === void 0 ? null : o.default
              }
            })(r) : null, this._enumValues = r && r.type === "enum" ? r.values : null
          }
          evaluateWithoutErrorHandling(t, r, o, c, m, _) {
            return this._evaluator.globals = t, this._evaluator.feature = r, this._evaluator.featureState = o, this._evaluator.canonical = c, this._evaluator.availableImages = m || null, this._evaluator.formattedSection = _, this.expression.evaluate(this._evaluator)
          }
          evaluate(t, r, o, c, m, _) {
            this._evaluator.globals = t, this._evaluator.feature = r || null, this._evaluator.featureState = o || null, this._evaluator.canonical = c, this._evaluator.availableImages = m || null, this._evaluator.formattedSection = _ || null;
            try {
              const v = this.expression.evaluate(this._evaluator);
              if (v == null || typeof v == "number" && v != v) return this._defaultValue;
              if (this._enumValues && !(v in this._enumValues)) throw new Jr(`Expected value to be one of ${Object.keys(this._enumValues).map((w=>JSON.stringify(w))).join(", ")}, but found ${JSON.stringify(v)} instead.`);
              return v
            } catch (v) {
              return this._warningHistory[v.message] || (this._warningHistory[v.message] = !0, typeof console < "u" && console.warn(v.message)), this._defaultValue
            }
          }
        }

        function Nl(n) {
          return Array.isArray(n) && n.length > 0 && typeof n[0] == "string" && n[0] in ms
        }

        function Qs(n, t) {
          const r = new Qa(ms, Fl, [], t ? (function(c) {
              const m = {
                color: xt,
                string: $t,
                number: nt,
                enum: $t,
                boolean: Gt,
                formatted: Qr,
                padding: zr,
                numberArray: hn,
                colorArray: Hr,
                projectionDefinition: It,
                resolvedImage: Yt,
                variableAnchorOffsetCollection: tn
              };
              return c.type === "array" ? an(m[c.value] || Nt, c.length) : m[c.type]
            })(t) : void 0),
            o = r.parse(n, void 0, void 0, void 0, t && t.type === "string" ? {
              typeAnnotation: "coerce"
            } : void 0);
          return o ? cd(new tu(o, t)) : _s(r.errors)
        }
        class el {
          constructor(t, r) {
            this.kind = t, this._styleExpression = r, this.isStateDependent = t !== "constant" && !Ys(r.expression), this.globalStateRefs = nl(r.expression)
          }
          evaluateWithoutErrorHandling(t, r, o, c, m, _) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, r, o, c, m, _)
          }
          evaluate(t, r, o, c, m, _) {
            return this._styleExpression.evaluate(t, r, o, c, m, _)
          }
        }
        class ru {
          constructor(t, r, o, c) {
            this.kind = t, this.zoomStops = o, this._styleExpression = r, this.isStateDependent = t !== "camera" && !Ys(r.expression), this.globalStateRefs = nl(r.expression), this.interpolationType = c
          }
          evaluateWithoutErrorHandling(t, r, o, c, m, _) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, r, o, c, m, _)
          }
          evaluate(t, r, o, c, m, _) {
            return this._styleExpression.evaluate(t, r, o, c, m, _)
          }
          interpolationFactor(t, r, o) {
            return this.interpolationType ? Ei.interpolationFactor(this.interpolationType, t, r, o) : 0
          }
        }

        function fd(n, t) {
          const r = Qs(n, t);
          if (r.result === "error") return r;
          const o = r.value.expression,
            c = Ol(o);
          if (!c && !xo(t)) return _s([new fn("", "data expressions not supported")]);
          const m = jl(o, ["zoom"]);
          if (!m && !ud(t)) return _s([new fn("", "zoom expressions not supported")]);
          const _ = rl(o);
          return _ || m ? _ instanceof fn ? _s([_]) : _ instanceof Ei && !eu(t) ? _s([new fn("", '"interpolate" expressions cannot be used with this property')]) : cd(_ ? new ru(c ? "camera" : "composite", r.value, _.labels, _ instanceof Ei ? _.interpolation : void 0) : new el(c ? "constant" : "source", r.value)) : _s([new fn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
        }
        class tl {
          constructor(t, r) {
            this._parameters = t, this._specification = r, bn(this, hd(this._parameters, this._specification))
          }
          static deserialize(t) {
            return new tl(t._parameters, t._specification)
          }
          static serialize(t) {
            return {
              _parameters: t._parameters,
              _specification: t._specification
            }
          }
        }

        function rl(n) {
          let t = null;
          if (n instanceof eo) t = rl(n.result);
          else if (n instanceof qs) {
            for (const r of n.args)
              if (t = rl(r), t) break
          } else(n instanceof Fn || n instanceof Ei) && n.input instanceof fa && n.input.name === "zoom" && (t = n);
          return t instanceof fn || n.eachChild((r => {
            const o = rl(r);
            o instanceof fn ? t = o : !t && o ? t = new fn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && o && t !== o && (t = new fn("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
          })), t
        }

        function nl(n, t = new Set) {
          return n instanceof Xs && t.add(n.key), n.eachChild((r => {
            nl(r, t)
          })), t
        }

        function Zl(n) {
          if (n === !0 || n === !1) return !0;
          if (!Array.isArray(n) || n.length === 0) return !1;
          switch (n[0]) {
            case "has":
              return n.length >= 2 && n[1] !== "$id" && n[1] !== "$type";
            case "in":
              return n.length >= 3 && (typeof n[1] != "string" || Array.isArray(n[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return n.length !== 3 || Array.isArray(n[1]) || Array.isArray(n[2]);
            case "any":
            case "all":
              for (const t of n.slice(1))
                if (!Zl(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0
          }
        }
        const nu = {
          type: "boolean",
          default: !1,
          transition: !1,
          "property-type": "data-driven",
          expression: {
            interpolated: !1,
            parameters: ["zoom", "feature"]
          }
        };

        function $o(n) {
          if (n == null) return {
            filter: () => !0,
            needGeometry: !1,
            getGlobalStateRefs: () => new Set
          };
          Zl(n) || (n = Go(n));
          const t = Qs(n, nu);
          if (t.result === "error") throw new Error(t.value.map((r => `${r.key}: ${r.message}`)).join(", "));
          return {
            filter: (r, o, c) => t.value.evaluate(r, o, {}, c),
            needGeometry: Vl(n),
            getGlobalStateRefs: () => nl(t.value.expression)
          }
        }

        function iu(n, t) {
          return n < t ? -1 : n > t ? 1 : 0
        }

        function Vl(n) {
          if (!Array.isArray(n)) return !1;
          if (n[0] === "within" || n[0] === "distance") return !0;
          for (let t = 1; t < n.length; t++)
            if (Vl(n[t])) return !0;
          return !1
        }

        function Go(n) {
          if (!n) return !0;
          const t = n[0];
          return n.length <= 1 ? t !== "any" : t === "==" ? au(n[1], n[2], "==") : t === "!=" ? ql(au(n[1], n[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? au(n[1], n[2], t) : t === "any" ? (r = n.slice(1), ["any"].concat(r.map(Go))) : t === "all" ? ["all"].concat(n.slice(1).map(Go)) : t === "none" ? ["all"].concat(n.slice(1).map(Go).map(ql)) : t === "in" ? md(n[1], n.slice(2)) : t === "!in" ? ql(md(n[1], n.slice(2))) : t === "has" ? _d(n[1]) : t !== "!has" || ql(_d(n[1]));
          var r
        }

        function au(n, t, r) {
          switch (n) {
            case "$type":
              return [`filter-type-${r}`, t];
            case "$id":
              return [`filter-id-${r}`, t];
            default:
              return [`filter-${r}`, n, t]
          }
        }

        function md(n, t) {
          if (t.length === 0) return !1;
          switch (n) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some((r => typeof r != typeof t[0])) ? ["filter-in-large", n, ["literal", t.sort(iu)]] : ["filter-in-small", n, ["literal", t]]
          }
        }

        function _d(n) {
          switch (n) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", n]
          }
        }

        function ql(n) {
          return ["!", n]
        }

        function ou(n) {
          const t = typeof n;
          if (t === "number" || t === "boolean" || t === "string" || n == null) return JSON.stringify(n);
          if (Array.isArray(n)) {
            let c = "[";
            for (const m of n) c += `${ou(m)},`;
            return `${c}]`
          }
          const r = Object.keys(n).sort();
          let o = "{";
          for (let c = 0; c < r.length; c++) o += `${JSON.stringify(r[c])}:${ou(n[r[c]])},`;
          return `${o}}`
        }

        function rf(n) {
          let t = "";
          for (const r of Mt) t += `/${ou(n[r])}`;
          return t
        }

        function su(n) {
          const t = n.value;
          return t ? [new bt(n.key, t, "constants have been deprecated as of v8")] : []
        }

        function Xn(n) {
          return n instanceof Number || n instanceof String || n instanceof Boolean ? n.valueOf() : n
        }

        function $a(n) {
          if (Array.isArray(n)) return n.map($a);
          if (n instanceof Object && !(n instanceof Number || n instanceof String || n instanceof Boolean)) {
            const t = {};
            for (const r in n) t[r] = $a(n[r]);
            return t
          }
          return Xn(n)
        }

        function ma(n) {
          const t = n.key,
            r = n.value,
            o = n.valueSpec || {},
            c = n.objectElementValidators || {},
            m = n.style,
            _ = n.styleSpec,
            v = n.validateSpec;
          let w = [];
          const S = mn(r);
          if (S !== "object") return [new bt(t, r, `object expected, ${S} found`)];
          for (const A in r) {
            const L = A.split(".")[0],
              j = Va(o, L) || o["*"];
            let q;
            if (Va(c, L)) q = c[L];
            else if (Va(o, L)) q = v;
            else if (c["*"]) q = c["*"];
            else {
              if (!o["*"]) {
                w.push(new bt(t, r[A], `unknown property "${A}"`));
                continue
              }
              q = v
            }
            w = w.concat(q({
              key: (t && `${t}.`) + A,
              value: r[A],
              valueSpec: j,
              style: m,
              styleSpec: _,
              object: r,
              objectKey: A,
              validateSpec: v
            }, r))
          }
          for (const A in o) c[A] || o[A].required && o[A].default === void 0 && r[A] === void 0 && w.push(new bt(t, r, `missing required property "${A}"`));
          return w
        }

        function Ul(n) {
          const t = n.value,
            r = n.valueSpec,
            o = n.style,
            c = n.styleSpec,
            m = n.key,
            _ = n.arrayElementValidator || n.validateSpec;
          if (mn(t) !== "array") return [new bt(m, t, `array expected, ${mn(t)} found`)];
          if (r.length && t.length !== r.length) return [new bt(m, t, `array length ${r.length} expected, length ${t.length} found`)];
          if (r["min-length"] && t.length < r["min-length"]) return [new bt(m, t, `array length at least ${r["min-length"]} expected, length ${t.length} found`)];
          let v = {
            type: r.value,
            values: r.values
          };
          c.$version < 7 && (v.function = r.function), mn(r.value) === "object" && (v = r.value);
          let w = [];
          for (let S = 0; S < t.length; S++) w = w.concat(_({
            array: t,
            arrayIndex: S,
            value: t[S],
            valueSpec: v,
            validateSpec: n.validateSpec,
            style: o,
            styleSpec: c,
            key: `${m}[${S}]`
          }));
          return w
        }

        function il(n) {
          const t = n.key,
            r = n.value,
            o = n.valueSpec;
          let c = mn(r);
          return c === "number" && r != r && (c = "NaN"), c !== "number" ? [new bt(t, r, `number expected, ${c} found`)] : "minimum" in o && r < o.minimum ? [new bt(t, r, `${r} is less than the minimum value ${o.minimum}`)] : "maximum" in o && r > o.maximum ? [new bt(t, r, `${r} is greater than the maximum value ${o.maximum}`)] : []
        }

        function gd(n) {
          const t = n.valueSpec,
            r = Xn(n.value.type);
          let o, c, m, _ = {};
          const v = r !== "categorical" && n.value.property === void 0,
            w = !v,
            S = mn(n.value.stops) === "array" && mn(n.value.stops[0]) === "array" && mn(n.value.stops[0][0]) === "object",
            A = ma({
              key: n.key,
              value: n.value,
              valueSpec: n.styleSpec.function,
              validateSpec: n.validateSpec,
              style: n.style,
              styleSpec: n.styleSpec,
              objectElementValidators: {
                stops: function(q) {
                  if (r === "identity") return [new bt(q.key, q.value, 'identity function may not have a "stops" property')];
                  let $ = [];
                  const J = q.value;
                  return $ = $.concat(Ul({
                    key: q.key,
                    value: J,
                    valueSpec: q.valueSpec,
                    validateSpec: q.validateSpec,
                    style: q.style,
                    styleSpec: q.styleSpec,
                    arrayElementValidator: L
                  })), mn(J) === "array" && J.length === 0 && $.push(new bt(q.key, J, "array must have at least one stop")), $
                },
                default: function(q) {
                  return q.validateSpec({
                    key: q.key,
                    value: q.value,
                    valueSpec: t,
                    validateSpec: q.validateSpec,
                    style: q.style,
                    styleSpec: q.styleSpec
                  })
                }
              }
            });
          return r === "identity" && v && A.push(new bt(n.key, n.value, 'missing required property "property"')), r === "identity" || n.value.stops || A.push(new bt(n.key, n.value, 'missing required property "stops"')), r === "exponential" && n.valueSpec.expression && !eu(n.valueSpec) && A.push(new bt(n.key, n.value, "exponential functions not supported")), n.styleSpec.$version >= 8 && (w && !xo(n.valueSpec) ? A.push(new bt(n.key, n.value, "property functions not supported")) : v && !ud(n.valueSpec) && A.push(new bt(n.key, n.value, "zoom functions not supported"))), r !== "categorical" && !S || n.value.property !== void 0 || A.push(new bt(n.key, n.value, '"property" property is required')), A;

          function L(q) {
            let $ = [];
            const J = q.value,
              te = q.key;
            if (mn(J) !== "array") return [new bt(te, J, `array expected, ${mn(J)} found`)];
            if (J.length !== 2) return [new bt(te, J, `array length 2 expected, length ${J.length} found`)];
            if (S) {
              if (mn(J[0]) !== "object") return [new bt(te, J, `object expected, ${mn(J[0])} found`)];
              if (J[0].zoom === void 0) return [new bt(te, J, "object stop key must have zoom")];
              if (J[0].value === void 0) return [new bt(te, J, "object stop key must have value")];
              if (m && m > Xn(J[0].zoom)) return [new bt(te, J[0].zoom, "stop zoom values must appear in ascending order")];
              Xn(J[0].zoom) !== m && (m = Xn(J[0].zoom), c = void 0, _ = {}), $ = $.concat(ma({
                key: `${te}[0]`,
                value: J[0],
                valueSpec: {
                  zoom: {}
                },
                validateSpec: q.validateSpec,
                style: q.style,
                styleSpec: q.styleSpec,
                objectElementValidators: {
                  zoom: il,
                  value: j
                }
              }))
            } else $ = $.concat(j({
              key: `${te}[0]`,
              value: J[0],
              validateSpec: q.validateSpec,
              style: q.style,
              styleSpec: q.styleSpec
            }, J));
            return Nl($a(J[1])) ? $.concat([new bt(`${te}[1]`, J[1], "expressions are not allowed in function stops.")]) : $.concat(q.validateSpec({
              key: `${te}[1]`,
              value: J[1],
              valueSpec: t,
              validateSpec: q.validateSpec,
              style: q.style,
              styleSpec: q.styleSpec
            }))
          }

          function j(q, $) {
            const J = mn(q.value),
              te = Xn(q.value),
              he = q.value !== null ? q.value : $;
            if (o) {
              if (J !== o) return [new bt(q.key, he, `${J} stop domain type must match previous stop domain type ${o}`)]
            } else o = J;
            if (J !== "number" && J !== "string" && J !== "boolean") return [new bt(q.key, he, "stop domain value must be a number, string, or boolean")];
            if (J !== "number" && r !== "categorical") {
              let je = `number expected, ${J} found`;
              return xo(t) && r === void 0 && (je += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new bt(q.key, he, je)]
            }
            return r !== "categorical" || J !== "number" || isFinite(te) && Math.floor(te) === te ? r !== "categorical" && J === "number" && c !== void 0 && te < c ? [new bt(q.key, he, "stop domain values must appear in ascending order")] : (c = te, r === "categorical" && te in _ ? [new bt(q.key, he, "stop domain values must be unique")] : (_[te] = !0, [])) : [new bt(q.key, he, `integer expected, found ${te}`)]
          }
        }

        function Wo(n) {
          const t = (n.expressionContext === "property" ? fd : Qs)($a(n.value), n.valueSpec);
          if (t.result === "error") return t.value.map((o => new bt(`${n.key}${o.key}`, n.value, o.message)));
          const r = t.value.expression || t.value._styleExpression.expression;
          if (n.expressionContext === "property" && n.propertyKey === "text-font" && !r.outputDefined()) return [new bt(n.key, n.value, `Invalid data expression for "${n.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (n.expressionContext === "property" && n.propertyType === "layout" && !Ys(r)) return [new bt(n.key, n.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (n.expressionContext === "filter" && !Ys(r)) return [new bt(n.key, n.value, '"feature-state" data expressions are not supported with filters.')];
          if (n.expressionContext && n.expressionContext.indexOf("cluster") === 0) {
            if (!jl(r, ["zoom", "feature-state"])) return [new bt(n.key, n.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (n.expressionContext === "cluster-initial" && !Ol(r)) return [new bt(n.key, n.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
          }
          return []
        }

        function $l(n) {
          const t = n.key,
            r = n.value,
            o = mn(r);
          return o !== "string" ? [new bt(t, r, `color expected, ${o} found`)] : kr.parse(String(r)) ? [] : [new bt(t, r, `color expected, "${r}" found`)]
        }

        function io(n) {
          const t = n.key,
            r = n.value,
            o = n.valueSpec,
            c = [];
          return Array.isArray(o.values) ? o.values.indexOf(Xn(r)) === -1 && c.push(new bt(t, r, `expected one of [${o.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(o.values).indexOf(Xn(r)) === -1 && c.push(new bt(t, r, `expected one of [${Object.keys(o.values).join(", ")}], ${JSON.stringify(r)} found`)), c
        }

        function lu(n) {
          return Zl($a(n.value)) ? Wo(bn({}, n, {
            expressionContext: "filter",
            valueSpec: {
              value: "boolean"
            }
          })) : vd(n)
        }

        function vd(n) {
          const t = n.value,
            r = n.key;
          if (mn(t) !== "array") return [new bt(r, t, `array expected, ${mn(t)} found`)];
          const o = n.styleSpec;
          let c, m = [];
          if (t.length < 1) return [new bt(r, t, "filter array must have at least 1 element")];
          switch (m = m.concat(io({
              key: `${r}[0]`,
              value: t[0],
              valueSpec: o.filter_operator,
              style: n.style,
              styleSpec: n.styleSpec
            })), Xn(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && Xn(t[1]) === "$type" && m.push(new bt(r, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && m.push(new bt(r, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (c = mn(t[1]), c !== "string" && m.push(new bt(`${r}[1]`, t[1], `string expected, ${c} found`)));
              for (let _ = 2; _ < t.length; _++) c = mn(t[_]), Xn(t[1]) === "$type" ? m = m.concat(io({
                key: `${r}[${_}]`,
                value: t[_],
                valueSpec: o.geometry_type,
                style: n.style,
                styleSpec: n.styleSpec
              })) : c !== "string" && c !== "number" && c !== "boolean" && m.push(new bt(`${r}[${_}]`, t[_], `string, number, or boolean expected, ${c} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let _ = 1; _ < t.length; _++) m = m.concat(vd({
                key: `${r}[${_}]`,
                value: t[_],
                style: n.style,
                styleSpec: n.styleSpec
              }));
              break;
            case "has":
            case "!has":
              c = mn(t[1]), t.length !== 2 ? m.push(new bt(r, t, `filter array for "${t[0]}" operator must have 2 elements`)) : c !== "string" && m.push(new bt(`${r}[1]`, t[1], `string expected, ${c} found`))
          }
          return m
        }

        function yd(n, t) {
          const r = n.key,
            o = n.validateSpec,
            c = n.style,
            m = n.styleSpec,
            _ = n.value,
            v = n.objectKey,
            w = m[`${t}_${n.layerType}`];
          if (!w) return [];
          const S = v.match(/^(.*)-transition$/);
          if (t === "paint" && S && w[S[1]] && w[S[1]].transition) return o({
            key: r,
            value: _,
            valueSpec: m.transition,
            style: c,
            styleSpec: m
          });
          const A = n.valueSpec || w[v];
          if (!A) return [new bt(r, _, `unknown property "${v}"`)];
          let L;
          if (mn(_) === "string" && xo(A) && !A.tokens && (L = /^{([^}]+)}$/.exec(_))) return [new bt(r, _, `"${v}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(L[1])} }\`.`)];
          const j = [];
          return n.layerType === "symbol" && (v === "text-field" && c && !c.glyphs && j.push(new bt(r, _, 'use of "text-field" requires a style "glyphs" property')), v === "text-font" && Ks($a(_)) && Xn(_.type) === "identity" && j.push(new bt(r, _, '"text-font" does not support identity functions'))), j.concat(o({
            key: n.key,
            value: _,
            valueSpec: A,
            style: c,
            styleSpec: m,
            expressionContext: "property",
            propertyType: t,
            propertyKey: v
          }))
        }

        function xd(n) {
          return yd(n, "paint")
        }

        function bd(n) {
          return yd(n, "layout")
        }

        function wd(n) {
          let t = [];
          const r = n.value,
            o = n.key,
            c = n.style,
            m = n.styleSpec;
          if (mn(r) !== "object") return [new bt(o, r, `object expected, ${mn(r)} found`)];
          r.type || r.ref || t.push(new bt(o, r, 'either "type" or "ref" is required'));
          let _ = Xn(r.type);
          const v = Xn(r.ref);
          if (r.id) {
            const w = Xn(r.id);
            for (let S = 0; S < n.arrayIndex; S++) {
              const A = c.layers[S];
              Xn(A.id) === w && t.push(new bt(o, r.id, `duplicate layer id "${r.id}", previously used at line ${A.id.__line__}`))
            }
          }
          if ("ref" in r) {
            let w;
            ["type", "source", "source-layer", "filter", "layout"].forEach((S => {
              S in r && t.push(new bt(o, r[S], `"${S}" is prohibited for ref layers`))
            })), c.layers.forEach((S => {
              Xn(S.id) === v && (w = S)
            })), w ? w.ref ? t.push(new bt(o, r.ref, "ref cannot reference another ref layer")) : _ = Xn(w.type) : t.push(new bt(o, r.ref, `ref layer "${v}" not found`))
          } else if (_ !== "background")
            if (r.source) {
              const w = c.sources && c.sources[r.source],
                S = w && Xn(w.type);
              w ? S === "vector" && _ === "raster" ? t.push(new bt(o, r.source, `layer "${r.id}" requires a raster source`)) : S !== "raster-dem" && _ === "hillshade" || S !== "raster-dem" && _ === "color-relief" ? t.push(new bt(o, r.source, `layer "${r.id}" requires a raster-dem source`)) : S === "raster" && _ !== "raster" ? t.push(new bt(o, r.source, `layer "${r.id}" requires a vector source`)) : S !== "vector" || r["source-layer"] ? S === "raster-dem" && _ !== "hillshade" && _ !== "color-relief" ? t.push(new bt(o, r.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : _ !== "line" || !r.paint || !r.paint["line-gradient"] || S === "geojson" && w.lineMetrics || t.push(new bt(o, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new bt(o, r, `layer "${r.id}" must specify a "source-layer"`)) : t.push(new bt(o, r.source, `source "${r.source}" not found`))
            } else t.push(new bt(o, r, 'missing required property "source"'));
          return t = t.concat(ma({
            key: o,
            value: r,
            valueSpec: m.layer,
            style: n.style,
            styleSpec: n.styleSpec,
            validateSpec: n.validateSpec,
            objectElementValidators: {
              "*": () => [],
              type: () => n.validateSpec({
                key: `${o}.type`,
                value: r.type,
                valueSpec: m.layer.type,
                style: n.style,
                styleSpec: n.styleSpec,
                validateSpec: n.validateSpec,
                object: r,
                objectKey: "type"
              }),
              filter: lu,
              layout: w => ma({
                layer: r,
                key: w.key,
                value: w.value,
                style: w.style,
                styleSpec: w.styleSpec,
                validateSpec: w.validateSpec,
                objectElementValidators: {
                  "*": S => bd(bn({
                    layerType: _
                  }, S))
                }
              }),
              paint: w => ma({
                layer: r,
                key: w.key,
                value: w.value,
                style: w.style,
                styleSpec: w.styleSpec,
                validateSpec: w.validateSpec,
                objectElementValidators: {
                  "*": S => xd(bn({
                    layerType: _
                  }, S))
                }
              })
            }
          })), t
        }

        function Sa(n) {
          const t = n.value,
            r = n.key,
            o = mn(t);
          return o !== "string" ? [new bt(r, t, `string expected, ${o} found`)] : []
        }
        const gs = {
          promoteId: function({
            key: n,
            value: t
          }) {
            if (mn(t) === "string") return Sa({
              key: n,
              value: t
            });
            {
              const r = [];
              for (const o in t) r.push(...Sa({
                key: `${n}.${o}`,
                value: t[o]
              }));
              return r
            }
          }
        };

        function Yi(n) {
          const t = n.value,
            r = n.key,
            o = n.styleSpec,
            c = n.style,
            m = n.validateSpec;
          if (!t.type) return [new bt(r, t, '"type" is required')];
          const _ = Xn(t.type);
          let v;
          switch (_) {
            case "vector":
            case "raster":
              return v = ma({
                key: r,
                value: t,
                valueSpec: o[`source_${_.replace("-","_")}`],
                style: n.style,
                styleSpec: o,
                objectElementValidators: gs,
                validateSpec: m
              }), v;
            case "raster-dem":
              return v = (function(w) {
                var S;
                const A = (S = w.sourceName) !== null && S !== void 0 ? S : "",
                  L = w.value,
                  j = w.styleSpec,
                  q = j.source_raster_dem,
                  $ = w.style;
                let J = [];
                const te = mn(L);
                if (L === void 0) return J;
                if (te !== "object") return J.push(new bt("source_raster_dem", L, `object expected, ${te} found`)), J;
                const he = Xn(L.encoding) === "custom",
                  je = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                  be = w.value.encoding ? `"${w.value.encoding}"` : "Default";
                for (const Me in L) !he && je.includes(Me) ? J.push(new bt(Me, L[Me], `In "${A}": "${Me}" is only valid when "encoding" is set to "custom". ${be} encoding found`)) : q[Me] ? J = J.concat(w.validateSpec({
                  key: Me,
                  value: L[Me],
                  valueSpec: q[Me],
                  validateSpec: w.validateSpec,
                  style: $,
                  styleSpec: j
                })) : J.push(new bt(Me, L[Me], `unknown property "${Me}"`));
                return J
              })({
                sourceName: r,
                value: t,
                style: n.style,
                styleSpec: o,
                validateSpec: m
              }), v;
            case "geojson":
              if (v = ma({
                  key: r,
                  value: t,
                  valueSpec: o.source_geojson,
                  style: c,
                  styleSpec: o,
                  validateSpec: m,
                  objectElementValidators: gs
                }), t.cluster)
                for (const w in t.clusterProperties) {
                  const [S, A] = t.clusterProperties[w], L = typeof S == "string" ? [S, ["accumulated"],
                    ["get", w]
                  ] : S;
                  v.push(...Wo({
                    key: `${r}.${w}.map`,
                    value: A,
                    expressionContext: "cluster-map"
                  })), v.push(...Wo({
                    key: `${r}.${w}.reduce`,
                    value: L,
                    expressionContext: "cluster-reduce"
                  }))
                }
              return v;
            case "video":
              return ma({
                key: r,
                value: t,
                valueSpec: o.source_video,
                style: c,
                validateSpec: m,
                styleSpec: o
              });
            case "image":
              return ma({
                key: r,
                value: t,
                valueSpec: o.source_image,
                style: c,
                validateSpec: m,
                styleSpec: o
              });
            case "canvas":
              return [new bt(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return io({
                key: `${r}.type`,
                value: t.type,
                valueSpec: {
                  values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                }
              })
          }
        }

        function vs(n) {
          const t = n.value,
            r = n.styleSpec,
            o = r.light,
            c = n.style;
          let m = [];
          const _ = mn(t);
          if (t === void 0) return m;
          if (_ !== "object") return m = m.concat([new bt("light", t, `object expected, ${_} found`)]), m;
          for (const v in t) {
            const w = v.match(/^(.*)-transition$/);
            m = m.concat(w && o[w[1]] && o[w[1]].transition ? n.validateSpec({
              key: v,
              value: t[v],
              valueSpec: r.transition,
              validateSpec: n.validateSpec,
              style: c,
              styleSpec: r
            }) : o[v] ? n.validateSpec({
              key: v,
              value: t[v],
              valueSpec: o[v],
              validateSpec: n.validateSpec,
              style: c,
              styleSpec: r
            }) : [new bt(v, t[v], `unknown property "${v}"`)])
          }
          return m
        }

        function cu(n) {
          const t = n.value,
            r = n.styleSpec,
            o = r.sky,
            c = n.style,
            m = mn(t);
          if (t === void 0) return [];
          if (m !== "object") return [new bt("sky", t, `object expected, ${m} found`)];
          let _ = [];
          for (const v in t) _ = _.concat(o[v] ? n.validateSpec({
            key: v,
            value: t[v],
            valueSpec: o[v],
            style: c,
            styleSpec: r
          }) : [new bt(v, t[v], `unknown property "${v}"`)]);
          return _
        }

        function Cd(n) {
          const t = n.value,
            r = n.styleSpec,
            o = r.terrain,
            c = n.style;
          let m = [];
          const _ = mn(t);
          if (t === void 0) return m;
          if (_ !== "object") return m = m.concat([new bt("terrain", t, `object expected, ${_} found`)]), m;
          for (const v in t) m = m.concat(o[v] ? n.validateSpec({
            key: v,
            value: t[v],
            valueSpec: o[v],
            validateSpec: n.validateSpec,
            style: c,
            styleSpec: r
          }) : [new bt(v, t[v], `unknown property "${v}"`)]);
          return m
        }

        function Td(n) {
          let t = [];
          const r = n.value,
            o = n.key;
          if (Array.isArray(r)) {
            const c = [],
              m = [];
            for (const _ in r) r[_].id && c.includes(r[_].id) && t.push(new bt(o, r, `all the sprites' ids must be unique, but ${r[_].id} is duplicated`)), c.push(r[_].id), r[_].url && m.includes(r[_].url) && t.push(new bt(o, r, `all the sprites' URLs must be unique, but ${r[_].url} is duplicated`)), m.push(r[_].url), t = t.concat(ma({
              key: `${o}[${_}]`,
              value: r[_],
              valueSpec: {
                id: {
                  type: "string",
                  required: !0
                },
                url: {
                  type: "string",
                  required: !0
                }
              },
              validateSpec: n.validateSpec
            }));
            return t
          }
          return Sa({
            key: o,
            value: r
          })
        }

        function ys(n) {
          return t = n.value, t && t.constructor === Object ? [] : [new bt(n.key, n.value, `object expected, ${mn(n.value)} found`)];
          var t
        }
        const uu = {
          "*": () => [],
          array: Ul,
          boolean: function(n) {
            const t = n.value,
              r = n.key,
              o = mn(t);
            return o !== "boolean" ? [new bt(r, t, `boolean expected, ${o} found`)] : []
          },
          number: il,
          color: $l,
          constants: su,
          enum: io,
          filter: lu,
          function: gd,
          layer: wd,
          object: ma,
          source: Yi,
          light: vs,
          sky: cu,
          terrain: Cd,
          projection: function(n) {
            const t = n.value,
              r = n.styleSpec,
              o = r.projection,
              c = n.style,
              m = mn(t);
            if (t === void 0) return [];
            if (m !== "object") return [new bt("projection", t, `object expected, ${m} found`)];
            let _ = [];
            for (const v in t) _ = _.concat(o[v] ? n.validateSpec({
              key: v,
              value: t[v],
              valueSpec: o[v],
              style: c,
              styleSpec: r
            }) : [new bt(v, t[v], `unknown property "${v}"`)]);
            return _
          },
          projectionDefinition: function(n) {
            const t = n.key;
            let r = n.value;
            r = r instanceof String ? r.valueOf() : r;
            const o = mn(r);
            return o !== "array" || (function(c) {
              return Array.isArray(c) && c.length === 3 && typeof c[0] == "string" && typeof c[1] == "string" && typeof c[2] == "number"
            })(r) || (function(c) {
              return !!["interpolate", "step", "literal"].includes(c[0])
            })(r) ? ["array", "string"].includes(o) ? [] : [new bt(t, r, `projection expected, invalid type "${o}" found`)] : [new bt(t, r, `projection expected, invalid array ${JSON.stringify(r)} found`)]
          },
          string: Sa,
          formatted: function(n) {
            return Sa(n).length === 0 ? [] : Wo(n)
          },
          resolvedImage: function(n) {
            return Sa(n).length === 0 ? [] : Wo(n)
          },
          padding: function(n) {
            const t = n.key,
              r = n.value;
            if (mn(r) === "array") {
              if (r.length < 1 || r.length > 4) return [new bt(t, r, `padding requires 1 to 4 values; ${r.length} values found`)];
              const o = {
                type: "number"
              };
              let c = [];
              for (let m = 0; m < r.length; m++) c = c.concat(n.validateSpec({
                key: `${t}[${m}]`,
                value: r[m],
                validateSpec: n.validateSpec,
                valueSpec: o
              }));
              return c
            }
            return il({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          numberArray: function(n) {
            const t = n.key,
              r = n.value;
            if (mn(r) === "array") {
              const o = {
                type: "number"
              };
              if (r.length < 1) return [new bt(t, r, "array length at least 1 expected, length 0 found")];
              let c = [];
              for (let m = 0; m < r.length; m++) c = c.concat(n.validateSpec({
                key: `${t}[${m}]`,
                value: r[m],
                validateSpec: n.validateSpec,
                valueSpec: o
              }));
              return c
            }
            return il({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          colorArray: function(n) {
            const t = n.key,
              r = n.value;
            if (mn(r) === "array") {
              if (r.length < 1) return [new bt(t, r, "array length at least 1 expected, length 0 found")];
              let o = [];
              for (let c = 0; c < r.length; c++) o = o.concat($l({
                key: `${t}[${c}]`,
                value: r[c]
              }));
              return o
            }
            return $l({
              key: t,
              value: r
            })
          },
          variableAnchorOffsetCollection: function(n) {
            const t = n.key,
              r = n.value,
              o = mn(r),
              c = n.styleSpec;
            if (o !== "array" || r.length < 1 || r.length % 2 != 0) return [new bt(t, r, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let m = [];
            for (let _ = 0; _ < r.length; _ += 2) m = m.concat(io({
              key: `${t}[${_}]`,
              value: r[_],
              valueSpec: c.layout_symbol["text-anchor"]
            })), m = m.concat(Ul({
              key: `${t}[${_+1}]`,
              value: r[_ + 1],
              valueSpec: {
                length: 2,
                value: "number"
              },
              validateSpec: n.validateSpec,
              style: n.style,
              styleSpec: c
            }));
            return m
          },
          sprite: Td,
          state: ys
        };

        function xs(n) {
          const t = n.value,
            r = n.valueSpec,
            o = n.styleSpec;
          return n.validateSpec = xs, r.expression && Ks(Xn(t)) ? gd(n) : r.expression && Nl($a(t)) ? Wo(n) : r.type && uu[r.type] ? uu[r.type](n) : ma(bn({}, n, {
            valueSpec: r.type ? o[r.type] : r
          }))
        }

        function Sd(n) {
          const t = n.value,
            r = n.key,
            o = Sa(n);
          return o.length || (t.indexOf("{fontstack}") === -1 && o.push(new bt(r, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && o.push(new bt(r, t, '"glyphs" url must include a "{range}" token'))), o
        }

        function Ki(n, t = we) {
          let r = [];
          return r = r.concat(xs({
            key: "",
            value: n,
            valueSpec: t.$root,
            styleSpec: t,
            style: n,
            validateSpec: xs,
            objectElementValidators: {
              glyphs: Sd,
              "*": () => []
            }
          })), n.constants && (r = r.concat(su({
            key: "constants",
            value: n.constants
          }))), bs(r)
        }

        function Ia(n) {
          return function(t) {
            return n({
              ...t,
              validateSpec: xs
            })
          }
        }

        function bs(n) {
          return [].concat(n).sort(((t, r) => t.line - r.line))
        }

        function Pa(n) {
          return function(...t) {
            return bs(n.apply(this, t))
          }
        }
        Ki.source = Pa(Ia(Yi)), Ki.sprite = Pa(Ia(Td)), Ki.glyphs = Pa(Ia(Sd)), Ki.light = Pa(Ia(vs)), Ki.sky = Pa(Ia(cu)), Ki.terrain = Pa(Ia(Cd)), Ki.state = Pa(Ia(ys)), Ki.layer = Pa(Ia(wd)), Ki.filter = Pa(Ia(lu)), Ki.paintProperty = Pa(Ia(xd)), Ki.layoutProperty = Pa(Ia(bd));
        const ws = Ki,
          nf = ws.light,
          al = ws.sky,
          af = ws.paintProperty,
          of = ws.layoutProperty;

        function ol(n, t) {
          let r = !1;
          if (t && t.length)
            for (const o of t) n.fire(new it(new Error(o.message))), r = !0;
          return r
        }
        class sl {
          constructor(t, r, o) {
            const c = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const _ = new Int32Array(this.arrayBuffer);
              t = _[0], this.d = (r = _[1]) + 2 * (o = _[2]);
              for (let w = 0; w < this.d * this.d; w++) {
                const S = _[3 + w],
                  A = _[3 + w + 1];
                c.push(S === A ? null : _.subarray(S, A))
              }
              const v = _[3 + c.length + 1];
              this.keys = _.subarray(_[3 + c.length], v), this.bboxes = _.subarray(v), this.insert = this._insertReadonly
            } else {
              this.d = r + 2 * o;
              for (let _ = 0; _ < this.d * this.d; _++) c.push([]);
              this.keys = [], this.bboxes = []
            }
            this.n = r, this.extent = t, this.padding = o, this.scale = r / t, this.uid = 0;
            const m = o / r * t;
            this.min = -m, this.max = t + m
          }
          insert(t, r, o, c, m) {
            this._forEachCell(r, o, c, m, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(r), this.bboxes.push(o), this.bboxes.push(c), this.bboxes.push(m)
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
          }
          _insertCell(t, r, o, c, m, _) {
            this.cells[m].push(_)
          }
          query(t, r, o, c, m) {
            const _ = this.min,
              v = this.max;
            if (t <= _ && r <= _ && v <= o && v <= c && !m) return Array.prototype.slice.call(this.keys);
            {
              const w = [];
              return this._forEachCell(t, r, o, c, this._queryCell, w, {}, m), w
            }
          }
          _queryCell(t, r, o, c, m, _, v, w) {
            const S = this.cells[m];
            if (S !== null) {
              const A = this.keys,
                L = this.bboxes;
              for (let j = 0; j < S.length; j++) {
                const q = S[j];
                if (v[q] === void 0) {
                  const $ = 4 * q;
                  (w ? w(L[$ + 0], L[$ + 1], L[$ + 2], L[$ + 3]) : t <= L[$ + 2] && r <= L[$ + 3] && o >= L[$ + 0] && c >= L[$ + 1]) ? (v[q] = !0, _.push(A[q])) : v[q] = !1
                }
              }
            }
          }
          _forEachCell(t, r, o, c, m, _, v, w) {
            const S = this._convertToCellCoord(t),
              A = this._convertToCellCoord(r),
              L = this._convertToCellCoord(o),
              j = this._convertToCellCoord(c);
            for (let q = S; q <= L; q++)
              for (let $ = A; $ <= j; $++) {
                const J = this.d * $ + q;
                if ((!w || w(this._convertFromCellCoord(q), this._convertFromCellCoord($), this._convertFromCellCoord(q + 1), this._convertFromCellCoord($ + 1))) && m.call(this, t, r, o, c, J, _, v, w)) return
              }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells,
              r = 3 + this.cells.length + 1 + 1;
            let o = 0;
            for (let _ = 0; _ < this.cells.length; _++) o += this.cells[_].length;
            const c = new Int32Array(r + o + this.keys.length + this.bboxes.length);
            c[0] = this.extent, c[1] = this.n, c[2] = this.padding;
            let m = r;
            for (let _ = 0; _ < t.length; _++) {
              const v = t[_];
              c[3 + _] = m, c.set(v, m), m += v.length
            }
            return c[3 + t.length] = m, c.set(this.keys, m), m += this.keys.length, c[3 + t.length + 1] = m, c.set(this.bboxes, m), m += this.bboxes.length, c.buffer
          }
          static serialize(t, r) {
            const o = t.toArrayBuffer();
            return r && r.push(o), {
              buffer: o
            }
          }
          static deserialize(t) {
            return new sl(t.buffer)
          }
        }
        const ka = {};

        function hr(n, t, r = {}) {
          if (ka[n]) throw new Error(`${n} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", {
            value: n,
            writeable: !1
          }), ka[n] = {
            klass: t,
            omit: r.omit || [],
            shallow: r.shallow || []
          }
        }
        hr("Object", Object), hr("Set", Set), hr("TransferableGridIndex", sl), hr("Color", kr), hr("Error", Error), hr("AJAXError", oe), hr("ResolvedImage", xn), hr("StylePropertyFunction", tl), hr("StyleExpression", tu, {
          omit: ["_evaluator"]
        }), hr("ZoomDependentExpression", ru), hr("ZoomConstantExpression", el), hr("CompoundExpression", fa, {
          omit: ["_evaluate"]
        });
        for (const n in ms) ms[n]._classRegistryKey || hr(`Expression_${n}`, ms[n]);

        function hu(n) {
          return n && typeof ArrayBuffer < "u" && (n instanceof ArrayBuffer || n.constructor && n.constructor.name === "ArrayBuffer")
        }

        function Gl(n) {
          return n.$name || n.constructor._classRegistryKey
        }

        function du(n) {
          return !(function(t) {
            if (t === null || typeof t != "object") return !1;
            const r = Gl(t);
            return !(!r || r === "Object")
          })(n) && (n == null || typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n instanceof Boolean || n instanceof Number || n instanceof String || n instanceof Date || n instanceof RegExp || n instanceof Blob || n instanceof Error || hu(n) || Rt(n) || ArrayBuffer.isView(n) || n instanceof ImageData)
        }

        function Cs(n, t) {
          if (du(n)) return (hu(n) || Rt(n)) && t && t.push(n), ArrayBuffer.isView(n) && t && t.push(n.buffer), n instanceof ImageData && t && t.push(n.data.buffer), n;
          if (Array.isArray(n)) {
            const m = [];
            for (const _ of n) m.push(Cs(_, t));
            return m
          }
          if (typeof n != "object") throw new Error("can't serialize object of type " + typeof n);
          const r = Gl(n);
          if (!r) throw new Error(`can't serialize object of unregistered class ${n.constructor.name}`);
          if (!ka[r]) throw new Error(`${r} is not registered.`);
          const {
            klass: o
          } = ka[r], c = o.serialize ? o.serialize(n, t) : {};
          if (o.serialize) {
            if (t && c === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property")
          } else {
            for (const m in n) {
              if (!n.hasOwnProperty(m) || ka[r].omit.indexOf(m) >= 0) continue;
              const _ = n[m];
              c[m] = ka[r].shallow.indexOf(m) >= 0 ? _ : Cs(_, t)
            }
            n instanceof Error && (c.message = n.message)
          }
          if (c.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return r !== "Object" && (c.$name = r), c
        }

        function Ho(n) {
          if (du(n)) return n;
          if (Array.isArray(n)) return n.map(Ho);
          if (typeof n != "object") throw new Error("can't deserialize object of type " + typeof n);
          const t = Gl(n) || "Object";
          if (!ka[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const {
            klass: r
          } = ka[t];
          if (!r) throw new Error(`can't deserialize unregistered class ${t}`);
          if (r.deserialize) return r.deserialize(n);
          const o = Object.create(r.prototype);
          for (const c of Object.keys(n)) {
            if (c === "$name") continue;
            const m = n[c];
            o[c] = ka[t].shallow.indexOf(c) >= 0 ? m : Ho(m)
          }
          return o
        }
        class Wl {
          constructor() {
            this.first = !0
          }
          update(t, r) {
            const o = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = o, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = o, !0) : (this.lastFloorZoom > o ? (this.lastIntegerZoom = o + 1, this.lastIntegerZoomTime = r) : this.lastFloorZoom < o && (this.lastIntegerZoom = o, this.lastIntegerZoomTime = r), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = o, !0))
          }
        }
        const _n = {
          "Latin-1 Supplement": n => n >= 128 && n <= 255,
          "Hangul Jamo": n => n >= 4352 && n <= 4607,
          Khmer: n => n >= 6016 && n <= 6143,
          "General Punctuation": n => n >= 8192 && n <= 8303,
          "Letterlike Symbols": n => n >= 8448 && n <= 8527,
          "Number Forms": n => n >= 8528 && n <= 8591,
          "Miscellaneous Technical": n => n >= 8960 && n <= 9215,
          "Control Pictures": n => n >= 9216 && n <= 9279,
          "Optical Character Recognition": n => n >= 9280 && n <= 9311,
          "Enclosed Alphanumerics": n => n >= 9312 && n <= 9471,
          "Geometric Shapes": n => n >= 9632 && n <= 9727,
          "Miscellaneous Symbols": n => n >= 9728 && n <= 9983,
          "Miscellaneous Symbols and Arrows": n => n >= 11008 && n <= 11263,
          "Ideographic Description Characters": n => n >= 12272 && n <= 12287,
          "CJK Symbols and Punctuation": n => n >= 12288 && n <= 12351,
          Hiragana: n => n >= 12352 && n <= 12447,
          Katakana: n => n >= 12448 && n <= 12543,
          Kanbun: n => n >= 12688 && n <= 12703,
          "CJK Strokes": n => n >= 12736 && n <= 12783,
          "Enclosed CJK Letters and Months": n => n >= 12800 && n <= 13055,
          "CJK Compatibility": n => n >= 13056 && n <= 13311,
          "Yijing Hexagram Symbols": n => n >= 19904 && n <= 19967,
          "CJK Unified Ideographs": n => n >= 19968 && n <= 40959,
          "Hangul Syllables": n => n >= 44032 && n <= 55215,
          "Private Use Area": n => n >= 57344 && n <= 63743,
          "Vertical Forms": n => n >= 65040 && n <= 65055,
          "CJK Compatibility Forms": n => n >= 65072 && n <= 65103,
          "Small Form Variants": n => n >= 65104 && n <= 65135,
          "Halfwidth and Fullwidth Forms": n => n >= 65280 && n <= 65519
        };

        function Hl(n) {
          for (const t of n)
            if (fu(t.charCodeAt(0))) return !0;
          return !1
        }

        function sf(n) {
          for (const t of n)
            if (!Id(t.charCodeAt(0))) return !1;
          return !0
        }

        function Jl(n) {
          const t = n.map((r => {
            try {
              return new RegExp(`\\p{sc=${r}}`, "u").source
            } catch {
              return null
            }
          })).filter((r => r));
          return new RegExp(t.join("|"), "u")
        }
        const lf = Jl(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);

        function Id(n) {
          return !lf.test(String.fromCodePoint(n))
        }
        const pu = Jl(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);

        function fu(n) {
          return !(n !== 746 && n !== 747 && (n < 4352 || !(_n["CJK Compatibility Forms"](n) && !(n >= 65097 && n <= 65103) || _n["CJK Compatibility"](n) || _n["CJK Strokes"](n) || !(!_n["CJK Symbols and Punctuation"](n) || n >= 12296 && n <= 12305 || n >= 12308 && n <= 12319 || n === 12336) || _n["Enclosed CJK Letters and Months"](n) || _n["Ideographic Description Characters"](n) || _n.Kanbun(n) || _n.Katakana(n) && n !== 12540 || !(!_n["Halfwidth and Fullwidth Forms"](n) || n === 65288 || n === 65289 || n === 65293 || n >= 65306 && n <= 65310 || n === 65339 || n === 65341 || n === 65343 || n >= 65371 && n <= 65503 || n === 65507 || n >= 65512 && n <= 65519) || !(!_n["Small Form Variants"](n) || n >= 65112 && n <= 65118 || n >= 65123 && n <= 65126) || _n["Vertical Forms"](n) || _n["Yijing Hexagram Symbols"](n) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(n)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(n)) || pu.test(String.fromCodePoint(n)))))
        }

        function Pd(n) {
          return !(fu(n) || (function(t) {
            return !!(_n["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || _n["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || _n["Letterlike Symbols"](t) || _n["Number Forms"](t) || _n["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || _n["Control Pictures"](t) && t !== 9251 || _n["Optical Character Recognition"](t) || _n["Enclosed Alphanumerics"](t) || _n["Geometric Shapes"](t) || _n["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || _n["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || _n["CJK Symbols and Punctuation"](t) || _n.Katakana(t) || _n["Private Use Area"](t) || _n["CJK Compatibility Forms"](t) || _n["Small Form Variants"](t) || _n["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
          })(n))
        }
        const kd = Jl(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);

        function mu(n) {
          return kd.test(String.fromCodePoint(n))
        }

        function Md(n, t) {
          return !(!t && mu(n) || n >= 2304 && n <= 3583 || n >= 3840 && n <= 4255 || _n.Khmer(n))
        }

        function Ad(n) {
          for (const t of n)
            if (mu(t.charCodeAt(0))) return !0;
          return !1
        }
        const Ma = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {}
          }
          setState(n) {
            this.pluginStatus = n.pluginStatus, this.pluginURL = n.pluginURL
          }
          getState() {
            return {
              pluginStatus: this.pluginStatus,
              pluginURL: this.pluginURL
            }
          }
          setMethods(n) {
            if (Ma.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = n.applyArabicShaping, this.processBidirectionalText = n.processBidirectionalText, this.processStyledBidirectionalText = n.processStyledBidirectionalText, this.loadScriptResolve()
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus
          }
          syncState(n, t) {
            return s(this, void 0, void 0, (function*() {
              if (this.isParsed()) return this.getState();
              if (n.pluginStatus !== "loading") return this.setState(n), n;
              const r = n.pluginURL,
                o = new Promise((m => {
                  this.loadScriptResolve = m
                }));
              t(r);
              const c = new Promise((m => setTimeout((() => m()), this.TIMEOUT)));
              if (yield Promise.race([o, c]), this.isParsed()) {
                const m = {
                  pluginStatus: "loaded",
                  pluginURL: r
                };
                return this.setState(m), m
              }
              throw this.setState({
                pluginStatus: "error",
                pluginURL: ""
              }), new Error(`RTL Text Plugin failed to import scripts from ${r}`)
            }))
          }
        };
        class Un {
          constructor(t, r) {
            this.zoom = t, r ? (this.now = r.now || 0, this.fadeDuration = r.fadeDuration || 0, this.zoomHistory = r.zoomHistory || new Wl, this.transition = r.transition || {}, this.globalState = r.globalState || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Wl, this.transition = {}, this.globalState = {})
          }
          isSupportedScript(t) {
            return (function(r, o) {
              for (const c of r)
                if (!Md(c.charCodeAt(0), o)) return !1;
              return !0
            })(t, Ma.getRTLTextPluginStatus() === "loaded")
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
          }
          getCrossfadeParameters() {
            const t = this.zoom,
              r = t - Math.floor(t),
              o = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? {
              fromScale: 2,
              toScale: 1,
              t: r + (1 - r) * o
            } : {
              fromScale: .5,
              toScale: 1,
              t: 1 - (1 - o) * r
            }
          }
        }
        class Ts {
          constructor(t, r) {
            this.property = t, this.value = r, this.expression = (function(o, c) {
              if (Ks(o)) return new tl(o, c);
              if (Nl(o)) {
                const m = fd(o, c);
                if (m.result === "error") throw new Error(m.value.map((_ => `${_.key}: ${_.message}`)).join(", "));
                return m.value
              } {
                let m = o;
                return c.type === "color" && typeof o == "string" ? m = kr.parse(o) : c.type !== "padding" || typeof o != "number" && !Array.isArray(o) ? c.type !== "numberArray" || typeof o != "number" && !Array.isArray(o) ? c.type !== "colorArray" || typeof o != "string" && !Array.isArray(o) ? c.type === "variableAnchorOffsetCollection" && Array.isArray(o) ? m = Bn.parse(o) : c.type === "projectionDefinition" && typeof o == "string" && (m = pn.parse(o)) : m = cn.parse(o) : m = yn.parse(o) : m = sn.parse(o), {
                  globalStateRefs: new Set,
                  kind: "constant",
                  evaluate: () => m
                }
              }
            })(r === void 0 ? t.specification.default : r, t.specification)
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite"
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || new Set
          }
          possiblyEvaluate(t, r, o) {
            return this.property.possiblyEvaluate(this, t, r, o)
          }
        }
        class _u {
          constructor(t) {
            this.property = t, this.value = new Ts(t, void 0)
          }
          transitioned(t, r) {
            return new gu(this.property, this.value, r, ut({}, t.transition, this.transition), t.now)
          }
          untransitioned() {
            return new gu(this.property, this.value, null, {}, 0)
          }
        }
        class Ed {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues)
          }
          getValue(t) {
            return Ct(this._values[t].value.value)
          }
          setValue(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new _u(this._values[t].property)), this._values[t].value = new Ts(this._values[t].property, r === null ? void 0 : Ct(r))
          }
          getTransition(t) {
            return Ct(this._values[t].transition)
          }
          setTransition(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new _u(this._values[t].property)), this._values[t].transition = Ct(r) || void 0
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const o = this.getValue(r);
              o !== void 0 && (t[r] = o);
              const c = this.getTransition(r);
              c !== void 0 && (t[`${r}-transition`] = c)
            }
            return t
          }
          transitioned(t, r) {
            const o = new vu(this._properties);
            for (const c of Object.keys(this._values)) o._values[c] = this._values[c].transitioned(t, r._values[c]);
            return o
          }
          untransitioned() {
            const t = new vu(this._properties);
            for (const r of Object.keys(this._values)) t._values[r] = this._values[r].untransitioned();
            return t
          }
        }
        class gu {
          constructor(t, r, o, c, m) {
            this.property = t, this.value = r, this.begin = m + c.delay || 0, this.end = this.begin + c.duration || 0, t.specification.transition && (c.delay || c.duration) && (this.prior = o)
          }
          possiblyEvaluate(t, r, o) {
            const c = t.now || 0,
              m = this.value.possiblyEvaluate(t, r, o),
              _ = this.prior;
            if (_) {
              if (c > this.end) return this.prior = null, m;
              if (this.value.isDataDriven()) return this.prior = null, m;
              if (c < this.begin) return _.possiblyEvaluate(t, r, o);
              {
                const v = (c - this.begin) / (this.end - this.begin);
                return this.property.interpolate(_.possiblyEvaluate(t, r, o), m, ot(v))
              }
            }
            return m
          }
        }
        class vu {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues)
          }
          possiblyEvaluate(t, r, o) {
            const c = new Xl(this._properties);
            for (const m of Object.keys(this._values)) c._values[m] = this._values[m].possiblyEvaluate(t, r, o);
            return c
          }
          hasTransition() {
            for (const t of Object.keys(this._values))
              if (this._values[t].prior) return !0;
            return !1
          }
        }
        class zd {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues)
          }
          hasValue(t) {
            return this._values[t].value !== void 0
          }
          getValue(t) {
            return Ct(this._values[t].value)
          }
          setValue(t, r) {
            this._values[t] = new Ts(this._values[t].property, r === null ? void 0 : Ct(r))
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const o = this.getValue(r);
              o !== void 0 && (t[r] = o)
            }
            return t
          }
          possiblyEvaluate(t, r, o) {
            const c = new Xl(this._properties);
            for (const m of Object.keys(this._values)) c._values[m] = this._values[m].possiblyEvaluate(t, r, o);
            return c
          }
        }
        class Ga {
          constructor(t, r, o) {
            this.property = t, this.value = r, this.parameters = o
          }
          isConstant() {
            return this.value.kind === "constant"
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t
          }
          evaluate(t, r, o, c) {
            return this.property.evaluate(this.value, this.parameters, t, r, o, c)
          }
        }
        class Xl {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues)
          }
          get(t) {
            return this._values[t]
          }
        }
        class Mr {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(r)
          }
          interpolate(t, r, o) {
            const c = Ua[this.specification.type];
            return c ? c(t, r, o) : t
          }
        }
        class Gr {
          constructor(t, r) {
            this.specification = t, this.overrides = r
          }
          possiblyEvaluate(t, r, o, c) {
            return new Ga(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? {
              kind: "constant",
              value: t.expression.evaluate(r, null, {}, o, c)
            } : t.expression, r)
          }
          interpolate(t, r, o) {
            if (t.value.kind !== "constant" || r.value.kind !== "constant") return t;
            if (t.value.value === void 0 || r.value.value === void 0) return new Ga(this, {
              kind: "constant",
              value: void 0
            }, t.parameters);
            const c = Ua[this.specification.type];
            if (c) {
              const m = c(t.value.value, r.value.value, o);
              return new Ga(this, {
                kind: "constant",
                value: m
              }, t.parameters)
            }
            return t
          }
          evaluate(t, r, o, c, m, _) {
            return t.kind === "constant" ? t.value : t.evaluate(r, o, c, m, _)
          }
        }
        class Yl extends Gr {
          possiblyEvaluate(t, r, o, c) {
            if (t.value === void 0) return new Ga(this, {
              kind: "constant",
              value: void 0
            }, r);
            if (t.expression.kind === "constant") {
              const m = t.expression.evaluate(r, null, {}, o, c),
                _ = t.property.specification.type === "resolvedImage" && typeof m != "string" ? m.name : m,
                v = this._calculate(_, _, _, r);
              return new Ga(this, {
                kind: "constant",
                value: v
              }, r)
            }
            if (t.expression.kind === "camera") {
              const m = this._calculate(t.expression.evaluate({
                zoom: r.zoom - 1
              }), t.expression.evaluate({
                zoom: r.zoom
              }), t.expression.evaluate({
                zoom: r.zoom + 1
              }), r);
              return new Ga(this, {
                kind: "constant",
                value: m
              }, r)
            }
            return new Ga(this, t.expression, r)
          }
          evaluate(t, r, o, c, m, _) {
            if (t.kind === "source") {
              const v = t.evaluate(r, o, c, m, _);
              return this._calculate(v, v, v, r)
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({
              zoom: Math.floor(r.zoom) - 1
            }, o, c), t.evaluate({
              zoom: Math.floor(r.zoom)
            }, o, c), t.evaluate({
              zoom: Math.floor(r.zoom) + 1
            }, o, c), r) : t.value
          }
          _calculate(t, r, o, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: o,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class wo {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, o, c) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const m = t.expression.evaluate(r, null, {}, o, c);
                return this._calculate(m, m, m, r)
              }
              return this._calculate(t.expression.evaluate(new Un(Math.floor(r.zoom - 1), r)), t.expression.evaluate(new Un(Math.floor(r.zoom), r)), t.expression.evaluate(new Un(Math.floor(r.zoom + 1), r)), r)
            }
          }
          _calculate(t, r, o, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: o,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class Kl {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, o, c) {
            return !!t.expression.evaluate(r, null, {}, o, c)
          }
          interpolate() {
            return !1
          }
        }
        class Wi {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const r in t) {
              const o = t[r];
              o.specification.overridable && this.overridableProperties.push(r);
              const c = this.defaultPropertyValues[r] = new Ts(o, void 0),
                m = this.defaultTransitionablePropertyValues[r] = new _u(o);
              this.defaultTransitioningPropertyValues[r] = m.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = c.possiblyEvaluate({})
            }
          }
        }
        hr("DataDrivenProperty", Gr), hr("DataConstantProperty", Mr), hr("CrossFadedDataDrivenProperty", Yl), hr("CrossFadedProperty", wo), hr("ColorRampProperty", Kl);
        const Ld = "-transition";
        class _a extends qt {
          constructor(t, r) {
            if (super(), this.id = t.id, this.type = t.type, this._featureFilter = {
                filter: () => !0,
                needGeometry: !1,
                getGlobalStateRefs: () => new Set
              }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = $o(t.filter)), r.layout && (this._unevaluatedLayout = new zd(r.layout)), r.paint)) {
              this._transitionablePaint = new Ed(r.paint);
              for (const o in t.paint) this.setPaintProperty(o, t.paint[o], {
                validate: !1
              });
              for (const o in t.layout) this.setLayoutProperty(o, t.layout[o], {
                validate: !1
              });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Xl(r.paint)
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = $o(t)
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = new Set;
            if (this._unevaluatedLayout)
              for (const r in this._unevaluatedLayout._values) {
                const o = this._unevaluatedLayout._values[r];
                for (const c of o.getGlobalStateRefs()) t.add(c)
              }
            for (const r of this._featureFilter.getGlobalStateRefs()) t.add(r);
            return t
          }
          setLayoutProperty(t, r, o = {}) {
            r != null && this._validate(of, `layers.${this.id}.layout.${t}`, t, r, o) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, r) : this.visibility = r)
          }
          getPaintProperty(t) {
            return t.endsWith(Ld) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
          }
          setPaintProperty(t, r, o = {}) {
            if (r != null && this._validate(af, `layers.${this.id}.paint.${t}`, t, r, o)) return !1;
            if (t.endsWith(Ld)) return this._transitionablePaint.setTransition(t.slice(0, -11), r || void 0), !1;
            {
              const c = this._transitionablePaint._values[t],
                m = c.property.specification["property-type"] === "cross-faded-data-driven",
                _ = c.value.isDataDriven(),
                v = c.value;
              this._transitionablePaint.setValue(t, r), this._handleSpecialPaintPropertyUpdate(t);
              const w = this._transitionablePaint._values[t].value;
              return w.isDataDriven() || _ || m || this._handleOverridablePaintPropertyUpdate(t, v, w)
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {}
          _handleOverridablePaintPropertyUpdate(t, r, o) {
            return !1
          }
          isHidden(t) {
            return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition()
          }
          recalculate(t, r) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, r)
          }
          serialize() {
            const t = {
              id: this.id,
              type: this.type,
              source: this.source,
              "source-layer": this.sourceLayer,
              metadata: this.metadata,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              filter: this.filter,
              layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
              paint: this._transitionablePaint && this._transitionablePaint.serialize()
            };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), vt(t, ((r, o) => !(r === void 0 || o === "layout" && !Object.keys(r).length || o === "paint" && !Object.keys(r).length)))
          }
          _validate(t, r, o, c, m = {}) {
            return (!m || m.validate !== !1) && ol(this, t.call(ws, {
              key: r,
              layerType: this.type,
              objectKey: o,
              value: c,
              styleSpec: we,
              style: {
                glyphs: !0,
                sprite: !0
              }
            }))
          }
          is3D() {
            return !1
          }
          isTileClipped() {
            return !1
          }
          hasOffscreenPass() {
            return !1
          }
          resize() {}
          isStateDependent() {
            for (const t in this.paint._values) {
              const r = this.paint.get(t);
              if (r instanceof Ga && xo(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return !0
            }
            return !1
          }
        }
        const cf = {
          Int8: Int8Array,
          Uint8: Uint8Array,
          Int16: Int16Array,
          Uint16: Uint16Array,
          Int32: Int32Array,
          Uint32: Uint32Array,
          Float32: Float32Array
        };
        class ll {
          constructor(t, r) {
            this._structArray = t, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
          }
        }
        class Pn {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0)
          }
          static serialize(t, r) {
            return t._trim(), r && (t.isTransferred = !0, r.push(t.arrayBuffer)), {
              length: t.length,
              arrayBuffer: t.arrayBuffer
            }
          }
          static deserialize(t) {
            const r = Object.create(this.prototype);
            return r.arrayBuffer = t.arrayBuffer, r.length = t.length, r.capacity = t.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
          }
          clear() {
            this.length = 0
          }
          resize(t) {
            this.reserve(t), this.length = t
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const r = this.uint8;
              this._refreshViews(), r && this.uint8.set(r)
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
          }
        }

        function ei(n, t = 1) {
          let r = 0,
            o = 0;
          return {
            members: n.map((c => {
              const m = cf[c.type].BYTES_PER_ELEMENT,
                _ = r = Ql(r, Math.max(t, m)),
                v = c.components || 1;
              return o = Math.max(o, m), r += m * v, {
                name: c.name,
                type: c.type,
                components: v,
                offset: _
              }
            })),
            size: Ql(r, Math.max(o, t)),
            alignment: t
          }
        }

        function Ql(n, t) {
          return Math.ceil(n / t) * t
        }
        class Ss extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, t, r)
          }
          emplace(t, r, o) {
            const c = 2 * t;
            return this.int16[c + 0] = r, this.int16[c + 1] = o, t
          }
        }
        Ss.prototype.bytesPerElement = 4, hr("StructArrayLayout2i4", Ss);
        class Is extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, o)
          }
          emplace(t, r, o, c) {
            const m = 3 * t;
            return this.int16[m + 0] = r, this.int16[m + 1] = o, this.int16[m + 2] = c, t
          }
        }
        Is.prototype.bytesPerElement = 6, hr("StructArrayLayout3i6", Is);
        class yu extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, t, r, o, c)
          }
          emplace(t, r, o, c, m) {
            const _ = 4 * t;
            return this.int16[_ + 0] = r, this.int16[_ + 1] = o, this.int16[_ + 2] = c, this.int16[_ + 3] = m, t
          }
        }
        yu.prototype.bytesPerElement = 8, hr("StructArrayLayout4i8", yu);
        class Ps extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, m, _) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, o, c, m, _)
          }
          emplace(t, r, o, c, m, _, v) {
            const w = 6 * t;
            return this.int16[w + 0] = r, this.int16[w + 1] = o, this.int16[w + 2] = c, this.int16[w + 3] = m, this.int16[w + 4] = _, this.int16[w + 5] = v, t
          }
        }
        Ps.prototype.bytesPerElement = 12, hr("StructArrayLayout2i4i12", Ps);
        class Jo extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, m, _) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, o, c, m, _)
          }
          emplace(t, r, o, c, m, _, v) {
            const w = 4 * t,
              S = 8 * t;
            return this.int16[w + 0] = r, this.int16[w + 1] = o, this.uint8[S + 4] = c, this.uint8[S + 5] = m, this.uint8[S + 6] = _, this.uint8[S + 7] = v, t
          }
        }
        Jo.prototype.bytesPerElement = 8, hr("StructArrayLayout2i4ub8", Jo);
        class cl extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, t, r)
          }
          emplace(t, r, o) {
            const c = 2 * t;
            return this.float32[c + 0] = r, this.float32[c + 1] = o, t
          }
        }
        cl.prototype.bytesPerElement = 8, hr("StructArrayLayout2f8", cl);
        class ec extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, m, _, v, w, S, A) {
            const L = this.length;
            return this.resize(L + 1), this.emplace(L, t, r, o, c, m, _, v, w, S, A)
          }
          emplace(t, r, o, c, m, _, v, w, S, A, L) {
            const j = 10 * t;
            return this.uint16[j + 0] = r, this.uint16[j + 1] = o, this.uint16[j + 2] = c, this.uint16[j + 3] = m, this.uint16[j + 4] = _, this.uint16[j + 5] = v, this.uint16[j + 6] = w, this.uint16[j + 7] = S, this.uint16[j + 8] = A, this.uint16[j + 9] = L, t
          }
        }
        ec.prototype.bytesPerElement = 20, hr("StructArrayLayout10ui20", ec);
        class Xo extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, m, _, v, w, S, A, L, j) {
            const q = this.length;
            return this.resize(q + 1), this.emplace(q, t, r, o, c, m, _, v, w, S, A, L, j)
          }
          emplace(t, r, o, c, m, _, v, w, S, A, L, j, q) {
            const $ = 12 * t;
            return this.int16[$ + 0] = r, this.int16[$ + 1] = o, this.int16[$ + 2] = c, this.int16[$ + 3] = m, this.uint16[$ + 4] = _, this.uint16[$ + 5] = v, this.uint16[$ + 6] = w, this.uint16[$ + 7] = S, this.int16[$ + 8] = A, this.int16[$ + 9] = L, this.int16[$ + 10] = j, this.int16[$ + 11] = q, t
          }
        }
        Xo.prototype.bytesPerElement = 24, hr("StructArrayLayout4i4ui4i24", Xo);
        class xu extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, o)
          }
          emplace(t, r, o, c) {
            const m = 3 * t;
            return this.float32[m + 0] = r, this.float32[m + 1] = o, this.float32[m + 2] = c, t
          }
        }
        xu.prototype.bytesPerElement = 12, hr("StructArrayLayout3f12", xu);
        class bu extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint32[1 * t + 0] = r, t
          }
        }
        bu.prototype.bytesPerElement = 4, hr("StructArrayLayout1ul4", bu);
        class tc extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, m, _, v, w, S) {
            const A = this.length;
            return this.resize(A + 1), this.emplace(A, t, r, o, c, m, _, v, w, S)
          }
          emplace(t, r, o, c, m, _, v, w, S, A) {
            const L = 10 * t,
              j = 5 * t;
            return this.int16[L + 0] = r, this.int16[L + 1] = o, this.int16[L + 2] = c, this.int16[L + 3] = m, this.int16[L + 4] = _, this.int16[L + 5] = v, this.uint32[j + 3] = w, this.uint16[L + 8] = S, this.uint16[L + 9] = A, t
          }
        }
        tc.prototype.bytesPerElement = 20, hr("StructArrayLayout6i1ul2ui20", tc);
        class wu extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, m, _) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, o, c, m, _)
          }
          emplace(t, r, o, c, m, _, v) {
            const w = 6 * t;
            return this.int16[w + 0] = r, this.int16[w + 1] = o, this.int16[w + 2] = c, this.int16[w + 3] = m, this.int16[w + 4] = _, this.int16[w + 5] = v, t
          }
        }
        wu.prototype.bytesPerElement = 12, hr("StructArrayLayout2i2i2i12", wu);
        class p extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, m) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, r, o, c, m)
          }
          emplace(t, r, o, c, m, _) {
            const v = 4 * t,
              w = 8 * t;
            return this.float32[v + 0] = r, this.float32[v + 1] = o, this.float32[v + 2] = c, this.int16[w + 6] = m, this.int16[w + 7] = _, t
          }
        }
        p.prototype.bytesPerElement = 16, hr("StructArrayLayout2f1f2i16", p);
        class e extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, m, _) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, o, c, m, _)
          }
          emplace(t, r, o, c, m, _, v) {
            const w = 16 * t,
              S = 4 * t,
              A = 8 * t;
            return this.uint8[w + 0] = r, this.uint8[w + 1] = o, this.float32[S + 1] = c, this.float32[S + 2] = m, this.int16[A + 6] = _, this.int16[A + 7] = v, t
          }
        }
        e.prototype.bytesPerElement = 16, hr("StructArrayLayout2ub2f2i16", e);
        class i extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, o)
          }
          emplace(t, r, o, c) {
            const m = 3 * t;
            return this.uint16[m + 0] = r, this.uint16[m + 1] = o, this.uint16[m + 2] = c, t
          }
        }
        i.prototype.bytesPerElement = 6, hr("StructArrayLayout3ui6", i);
        class l extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, m, _, v, w, S, A, L, j, q, $, J, te, he) {
            const je = this.length;
            return this.resize(je + 1), this.emplace(je, t, r, o, c, m, _, v, w, S, A, L, j, q, $, J, te, he)
          }
          emplace(t, r, o, c, m, _, v, w, S, A, L, j, q, $, J, te, he, je) {
            const be = 24 * t,
              Me = 12 * t,
              et = 48 * t;
            return this.int16[be + 0] = r, this.int16[be + 1] = o, this.uint16[be + 2] = c, this.uint16[be + 3] = m, this.uint32[Me + 2] = _, this.uint32[Me + 3] = v, this.uint32[Me + 4] = w, this.uint16[be + 10] = S, this.uint16[be + 11] = A, this.uint16[be + 12] = L, this.float32[Me + 7] = j, this.float32[Me + 8] = q, this.uint8[et + 36] = $, this.uint8[et + 37] = J, this.uint8[et + 38] = te, this.uint32[Me + 10] = he, this.int16[be + 22] = je, t
          }
        }
        l.prototype.bytesPerElement = 48, hr("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", l);
        class u extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, m, _, v, w, S, A, L, j, q, $, J, te, he, je, be, Me, et, ct, Et, ar, Jt, tr, Rr, Qt) {
            const rr = this.length;
            return this.resize(rr + 1), this.emplace(rr, t, r, o, c, m, _, v, w, S, A, L, j, q, $, J, te, he, je, be, Me, et, ct, Et, ar, Jt, tr, Rr, Qt)
          }
          emplace(t, r, o, c, m, _, v, w, S, A, L, j, q, $, J, te, he, je, be, Me, et, ct, Et, ar, Jt, tr, Rr, Qt, rr) {
            const yt = 32 * t,
              Yr = 16 * t;
            return this.int16[yt + 0] = r, this.int16[yt + 1] = o, this.int16[yt + 2] = c, this.int16[yt + 3] = m, this.int16[yt + 4] = _, this.int16[yt + 5] = v, this.int16[yt + 6] = w, this.int16[yt + 7] = S, this.uint16[yt + 8] = A, this.uint16[yt + 9] = L, this.uint16[yt + 10] = j, this.uint16[yt + 11] = q, this.uint16[yt + 12] = $, this.uint16[yt + 13] = J, this.uint16[yt + 14] = te, this.uint16[yt + 15] = he, this.uint16[yt + 16] = je, this.uint16[yt + 17] = be, this.uint16[yt + 18] = Me, this.uint16[yt + 19] = et, this.uint16[yt + 20] = ct, this.uint16[yt + 21] = Et, this.uint16[yt + 22] = ar, this.uint32[Yr + 12] = Jt, this.float32[Yr + 13] = tr, this.float32[Yr + 14] = Rr, this.uint16[yt + 30] = Qt, this.uint16[yt + 31] = rr, t
          }
        }
        u.prototype.bytesPerElement = 64, hr("StructArrayLayout8i15ui1ul2f2ui64", u);
        class f extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.float32[1 * t + 0] = r, t
          }
        }
        f.prototype.bytesPerElement = 4, hr("StructArrayLayout1f4", f);
        class g extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, o)
          }
          emplace(t, r, o, c) {
            const m = 3 * t;
            return this.uint16[6 * t + 0] = r, this.float32[m + 1] = o, this.float32[m + 2] = c, t
          }
        }
        g.prototype.bytesPerElement = 12, hr("StructArrayLayout1ui2f12", g);
        class C extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, o)
          }
          emplace(t, r, o, c) {
            const m = 4 * t;
            return this.uint32[2 * t + 0] = r, this.uint16[m + 2] = o, this.uint16[m + 3] = c, t
          }
        }
        C.prototype.bytesPerElement = 8, hr("StructArrayLayout1ul2ui8", C);
        class T extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, t, r)
          }
          emplace(t, r, o) {
            const c = 2 * t;
            return this.uint16[c + 0] = r, this.uint16[c + 1] = o, t
          }
        }
        T.prototype.bytesPerElement = 4, hr("StructArrayLayout2ui4", T);
        class M extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint16[1 * t + 0] = r, t
          }
        }
        M.prototype.bytesPerElement = 2, hr("StructArrayLayout1ui2", M);
        class z extends Pn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, t, r, o, c)
          }
          emplace(t, r, o, c, m) {
            const _ = 4 * t;
            return this.float32[_ + 0] = r, this.float32[_ + 1] = o, this.float32[_ + 2] = c, this.float32[_ + 3] = m, t
          }
        }
        z.prototype.bytesPerElement = 16, hr("StructArrayLayout4f16", z);
        class R extends ll {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get anchorPoint() {
            return new F(this.anchorPointX, this.anchorPointY)
          }
        }
        R.prototype.size = 20;
        class D extends tc {
          get(t) {
            return new R(this, t)
          }
        }
        hr("CollisionBoxArray", D);
        class N extends ll {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3]
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2]
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4]
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7]
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8]
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36]
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37]
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38]
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22]
          }
        }
        N.prototype.size = 48;
        class H extends l {
          get(t) {
            return new N(this, t)
          }
        }
        hr("PlacedSymbolArray", H);
        class ie extends ll {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6]
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7]
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13]
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14]
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15]
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16]
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17]
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18]
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19]
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20]
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21]
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22]
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13]
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14]
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30]
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31]
          }
        }
        ie.prototype.size = 64;
        class ne extends u {
          get(t) {
            return new ie(this, t)
          }
        }
        hr("SymbolInstanceArray", ne);
        class se extends f {
          getoffsetX(t) {
            return this.float32[1 * t + 0]
          }
        }
        hr("GlyphOffsetArray", se);
        class pe extends Is {
          getx(t) {
            return this.int16[3 * t + 0]
          }
          gety(t) {
            return this.int16[3 * t + 1]
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2]
          }
        }
        hr("SymbolLineVertexArray", pe);
        class ye extends ll {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0]
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1]
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2]
          }
        }
        ye.prototype.size = 12;
        class ge extends g {
          get(t) {
            return new ye(this, t)
          }
        }
        hr("TextAnchorOffsetArray", ge);
        class Te extends ll {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3]
          }
        }
        Te.prototype.size = 8;
        class Le extends C {
          get(t) {
            return new Te(this, t)
          }
        }
        hr("FeatureIndexArray", Le);
        class ve extends Ss {}
        class Ne extends Ss {}
        class st extends Ss {}
        class Xe extends Ps {}
        class Qe extends Jo {}
        class at extends cl {}
        class Ht extends ec {}
        class Xt extends Xo {}
        class kt extends xu {}
        class wr extends bu {}
        class dn extends wu {}
        class Tn extends e {}
        class kn extends i {}
        class Sn extends T {}
        const Gn = ei([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: Yn
          } = Gn;
        class un {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t
          }
          prepareSegment(t, r, o, c) {
            const m = this.segments[this.segments.length - 1];
            return t > un.MAX_VERTEX_ARRAY_LENGTH && Bt(`Max vertices per segment is ${un.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${un.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !m || m.vertexLength + t > un.MAX_VERTEX_ARRAY_LENGTH || m.sortKey !== c ? this.createNewSegment(r, o, c) : m
          }
          createNewSegment(t, r, o) {
            const c = {
              vertexOffset: t.length,
              primitiveOffset: r.length,
              vertexLength: 0,
              primitiveLength: 0,
              vaos: {}
            };
            return o !== void 0 && (c.sortKey = o), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(c), c
          }
          getOrCreateLatestSegment(t, r, o) {
            return this.prepareSegment(0, t, r, o)
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0
          }
          get() {
            return this.segments
          }
          destroy() {
            for (const t of this.segments)
              for (const r in t.vaos) t.vaos[r].destroy()
          }
          static simpleSegment(t, r, o, c) {
            return new un([{
              vertexOffset: t,
              primitiveOffset: r,
              vertexLength: o,
              primitiveLength: c,
              vaos: {},
              sortKey: 0
            }])
          }
        }

        function Mn(n, t) {
          return 256 * (n = Lt(Math.floor(n), 0, 255)) + Lt(Math.floor(t), 0, 255)
        }
        un.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, hr("SegmentVector", un);
        const li = ei([{
          name: "a_pattern_from",
          components: 4,
          type: "Uint16"
        }, {
          name: "a_pattern_to",
          components: 4,
          type: "Uint16"
        }, {
          name: "a_pixel_ratio_from",
          components: 1,
          type: "Uint16"
        }, {
          name: "a_pixel_ratio_to",
          components: 1,
          type: "Uint16"
        }]);
        var mi, xi, Hi, Aa = {
            exports: {}
          },
          Co = {
            exports: {}
          },
          To = {
            exports: {}
          },
          ks = (function() {
            if (Hi) return Aa.exports;
            Hi = 1;
            var n = (mi || (mi = 1, Co.exports = function(r, o) {
                var c, m, _, v, w, S, A, L;
                for (m = r.length - (c = 3 & r.length), _ = o, w = 3432918353, S = 461845907, L = 0; L < m;) A = 255 & r.charCodeAt(L) | (255 & r.charCodeAt(++L)) << 8 | (255 & r.charCodeAt(++L)) << 16 | (255 & r.charCodeAt(++L)) << 24, ++L, _ = 27492 + (65535 & (v = 5 * (65535 & (_ = (_ ^= A = (65535 & (A = (A = (65535 & A) * w + (((A >>> 16) * w & 65535) << 16) & 4294967295) << 15 | A >>> 17)) * S + (((A >>> 16) * S & 65535) << 16) & 4294967295) << 13 | _ >>> 19)) + ((5 * (_ >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (v >>> 16) & 65535) << 16);
                switch (A = 0, c) {
                  case 3:
                    A ^= (255 & r.charCodeAt(L + 2)) << 16;
                  case 2:
                    A ^= (255 & r.charCodeAt(L + 1)) << 8;
                  case 1:
                    _ ^= A = (65535 & (A = (A = (65535 & (A ^= 255 & r.charCodeAt(L))) * w + (((A >>> 16) * w & 65535) << 16) & 4294967295) << 15 | A >>> 17)) * S + (((A >>> 16) * S & 65535) << 16) & 4294967295
                }
                return _ ^= r.length, _ = 2246822507 * (65535 & (_ ^= _ >>> 16)) + ((2246822507 * (_ >>> 16) & 65535) << 16) & 4294967295, _ = 3266489909 * (65535 & (_ ^= _ >>> 13)) + ((3266489909 * (_ >>> 16) & 65535) << 16) & 4294967295, (_ ^= _ >>> 16) >>> 0
              }), Co.exports),
              t = (xi || (xi = 1, To.exports = function(r, o) {
                for (var c, m = r.length, _ = o ^ m, v = 0; m >= 4;) c = 1540483477 * (65535 & (c = 255 & r.charCodeAt(v) | (255 & r.charCodeAt(++v)) << 8 | (255 & r.charCodeAt(++v)) << 16 | (255 & r.charCodeAt(++v)) << 24)) + ((1540483477 * (c >>> 16) & 65535) << 16), _ = 1540483477 * (65535 & _) + ((1540483477 * (_ >>> 16) & 65535) << 16) ^ (c = 1540483477 * (65535 & (c ^= c >>> 24)) + ((1540483477 * (c >>> 16) & 65535) << 16)), m -= 4, ++v;
                switch (m) {
                  case 3:
                    _ ^= (255 & r.charCodeAt(v + 2)) << 16;
                  case 2:
                    _ ^= (255 & r.charCodeAt(v + 1)) << 8;
                  case 1:
                    _ = 1540483477 * (65535 & (_ ^= 255 & r.charCodeAt(v))) + ((1540483477 * (_ >>> 16) & 65535) << 16)
                }
                return _ = 1540483477 * (65535 & (_ ^= _ >>> 13)) + ((1540483477 * (_ >>> 16) & 65535) << 16), (_ ^= _ >>> 15) >>> 0
              }), To.exports);
            return Aa.exports = n, Aa.exports.murmur3 = n, Aa.exports.murmur2 = t, Aa.exports
          })(),
          Ms = O(ks);
        class Yo {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1
          }
          add(t, r, o, c) {
            this.ids.push(Ko(t)), this.positions.push(r, o, c)
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const r = Ko(t);
            let o = 0,
              c = this.ids.length - 1;
            for (; o < c;) {
              const _ = o + c >> 1;
              this.ids[_] >= r ? c = _ : o = _ + 1
            }
            const m = [];
            for (; this.ids[o] === r;) m.push({
              index: this.positions[3 * o],
              start: this.positions[3 * o + 1],
              end: this.positions[3 * o + 2]
            }), o++;
            return m
          }
          static serialize(t, r) {
            const o = new Float64Array(t.ids),
              c = new Uint32Array(t.positions);
            return Qi(o, c, 0, o.length - 1), r && r.push(o.buffer, c.buffer), {
              ids: o,
              positions: c
            }
          }
          static deserialize(t) {
            const r = new Yo;
            return r.ids = t.ids, r.positions = t.positions, r.indexed = !0, r
          }
        }

        function Ko(n) {
          const t = +n;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : Ms(String(n))
        }

        function Qi(n, t, r, o) {
          for (; r < o;) {
            const c = n[r + o >> 1];
            let m = r - 1,
              _ = o + 1;
            for (;;) {
              do m++; while (n[m] < c);
              do _--; while (n[_] > c);
              if (m >= _) break;
              Ea(n, m, _), Ea(t, 3 * m, 3 * _), Ea(t, 3 * m + 1, 3 * _ + 1), Ea(t, 3 * m + 2, 3 * _ + 2)
            }
            _ - r < o - _ ? (Qi(n, t, r, _), r = _ + 1) : (Qi(n, t, _ + 1, o), o = _)
          }
        }

        function Ea(n, t, r) {
          const o = n[t];
          n[t] = n[r], n[r] = o
        }
        hr("FeaturePositionMap", Yo);
        class Ji {
          constructor(t, r) {
            this.gl = t.gl, this.location = r
          }
        }
        class So extends Ji {
          constructor(t, r) {
            super(t, r), this.current = 0
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t))
          }
        }
        class ci extends Ji {
          constructor(t, r) {
            super(t, r), this.current = [0, 0, 0, 0]
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
          }
        }
        class _i extends Ji {
          constructor(t, r) {
            super(t, r), this.current = kr.transparent
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
          }
        }
        const ga = new Float32Array(16);

        function ui(n) {
          return [Mn(255 * n.r, 255 * n.g), Mn(255 * n.b, 255 * n.a)]
        }
        class ul {
          constructor(t, r, o) {
            this.value = t, this.uniformNames = r.map((c => `u_${c}`)), this.type = o
          }
          setUniform(t, r, o) {
            t.set(o.constantOr(this.value))
          }
          getBinding(t, r, o) {
            return this.type === "color" ? new _i(t, r) : new So(t, r)
          }
        }
        class As {
          constructor(t, r) {
            this.uniformNames = r.map((o => `u_${o}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1
          }
          setConstantPatternPositions(t, r) {
            this.pixelRatioFrom = r.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = r.tlbr, this.patternTo = t.tlbr
          }
          setUniform(t, r, o, c) {
            const m = c === "u_pattern_to" ? this.patternTo : c === "u_pattern_from" ? this.patternFrom : c === "u_pixel_ratio_to" ? this.pixelRatioTo : c === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            m && t.set(m)
          }
          getBinding(t, r, o) {
            return o.substr(0, 9) === "u_pattern" ? new ci(t, r) : new So(t, r)
          }
        }
        class ao {
          constructor(t, r, o, c) {
            this.expression = t, this.type = o, this.maxValue = 0, this.paintVertexAttributes = r.map((m => ({
              name: `a_${m}`,
              type: "Float32",
              components: o === "color" ? 2 : 1,
              offset: 0
            }))), this.paintVertexArray = new c
          }
          populatePaintArray(t, r, o, c, m) {
            const _ = this.paintVertexArray.length,
              v = this.expression.evaluate(new Un(0), r, {}, c, [], m);
            this.paintVertexArray.resize(t), this._setPaintValue(_, t, v)
          }
          updatePaintArray(t, r, o, c) {
            const m = this.expression.evaluate({
              zoom: 0
            }, o, c);
            this._setPaintValue(t, r, m)
          }
          _setPaintValue(t, r, o) {
            if (this.type === "color") {
              const c = ui(o);
              for (let m = t; m < r; m++) this.paintVertexArray.emplace(m, c[0], c[1])
            } else {
              for (let c = t; c < r; c++) this.paintVertexArray.emplace(c, o);
              this.maxValue = Math.max(this.maxValue, Math.abs(o))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
        }
        class za {
          constructor(t, r, o, c, m, _) {
            this.expression = t, this.uniformNames = r.map((v => `u_${v}_t`)), this.type = o, this.useIntegerZoom = c, this.zoom = m, this.maxValue = 0, this.paintVertexAttributes = r.map((v => ({
              name: `a_${v}`,
              type: "Float32",
              components: o === "color" ? 4 : 2,
              offset: 0
            }))), this.paintVertexArray = new _
          }
          populatePaintArray(t, r, o, c, m) {
            const _ = this.expression.evaluate(new Un(this.zoom), r, {}, c, [], m),
              v = this.expression.evaluate(new Un(this.zoom + 1), r, {}, c, [], m),
              w = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(w, t, _, v)
          }
          updatePaintArray(t, r, o, c) {
            const m = this.expression.evaluate({
                zoom: this.zoom
              }, o, c),
              _ = this.expression.evaluate({
                zoom: this.zoom + 1
              }, o, c);
            this._setPaintValue(t, r, m, _)
          }
          _setPaintValue(t, r, o, c) {
            if (this.type === "color") {
              const m = ui(o),
                _ = ui(c);
              for (let v = t; v < r; v++) this.paintVertexArray.emplace(v, m[0], m[1], _[0], _[1])
            } else {
              for (let m = t; m < r; m++) this.paintVertexArray.emplace(m, o, c);
              this.maxValue = Math.max(this.maxValue, Math.abs(o), Math.abs(c))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
          setUniform(t, r) {
            const o = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,
              c = Lt(this.expression.interpolationFactor(o, this.zoom, this.zoom + 1), 0, 1);
            t.set(c)
          }
          getBinding(t, r, o) {
            return new So(t, r)
          }
        }
        class Io {
          constructor(t, r, o, c, m, _) {
            this.expression = t, this.type = r, this.useIntegerZoom = o, this.zoom = c, this.layerId = _, this.zoomInPaintVertexArray = new m, this.zoomOutPaintVertexArray = new m
          }
          populatePaintArray(t, r, o) {
            const c = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(c, t, r.patterns && r.patterns[this.layerId], o)
          }
          updatePaintArray(t, r, o, c, m) {
            this._setPaintValues(t, r, o.patterns && o.patterns[this.layerId], m)
          }
          _setPaintValues(t, r, o, c) {
            if (!c || !o) return;
            const {
              min: m,
              mid: _,
              max: v
            } = o, w = c[m], S = c[_], A = c[v];
            if (w && S && A)
              for (let L = t; L < r; L++) this.zoomInPaintVertexArray.emplace(L, S.tl[0], S.tl[1], S.br[0], S.br[1], w.tl[0], w.tl[1], w.br[0], w.br[1], S.pixelRatio, w.pixelRatio), this.zoomOutPaintVertexArray.emplace(L, S.tl[0], S.tl[1], S.br[0], S.br[1], A.tl[0], A.tl[1], A.br[0], A.br[1], S.pixelRatio, A.pixelRatio)
          }
          upload(t) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, li.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, li.members, this.expression.isStateDependent))
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
          }
        }
        class Dd {
          constructor(t, r, o) {
            this.binders = {}, this._buffers = [];
            const c = [];
            for (const m in t.paint._values) {
              if (!o(m)) continue;
              const _ = t.paint.get(m);
              if (!(_ instanceof Ga && xo(_.property.specification))) continue;
              const v = Rd(m, t.type),
                w = _.value,
                S = _.property.specification.type,
                A = _.property.useIntegerZoom,
                L = _.property.specification["property-type"],
                j = L === "cross-faded" || L === "cross-faded-data-driven";
              if (w.kind === "constant") this.binders[m] = j ? new As(w.value, v) : new ul(w.value, v, S), c.push(`/u_${m}`);
              else if (w.kind === "source" || j) {
                const q = Cu(m, S, "source");
                this.binders[m] = j ? new Io(w, S, A, r, q, t.id) : new ao(w, v, S, q), c.push(`/a_${m}`)
              } else {
                const q = Cu(m, S, "composite");
                this.binders[m] = new za(w, v, S, A, r, q), c.push(`/z_${m}`)
              }
            }
            this.cacheKey = c.sort().join("")
          }
          getMaxValue(t) {
            const r = this.binders[t];
            return r instanceof ao || r instanceof za ? r.maxValue : 0
          }
          populatePaintArrays(t, r, o, c, m) {
            for (const _ in this.binders) {
              const v = this.binders[_];
              (v instanceof ao || v instanceof za || v instanceof Io) && v.populatePaintArray(t, r, o, c, m)
            }
          }
          setConstantPatternPositions(t, r) {
            for (const o in this.binders) {
              const c = this.binders[o];
              c instanceof As && c.setConstantPatternPositions(t, r)
            }
          }
          updatePaintArrays(t, r, o, c, m) {
            let _ = !1;
            for (const v in t) {
              const w = r.getPositions(v);
              for (const S of w) {
                const A = o.feature(S.index);
                for (const L in this.binders) {
                  const j = this.binders[L];
                  if ((j instanceof ao || j instanceof za || j instanceof Io) && j.expression.isStateDependent === !0) {
                    const q = c.paint.get(L);
                    j.expression = q.value, j.updatePaintArray(S.start, S.end, A, t[v], m), _ = !0
                  }
                }
              }
            }
            return _
          }
          defines() {
            const t = [];
            for (const r in this.binders) {
              const o = this.binders[r];
              (o instanceof ul || o instanceof As) && t.push(...o.uniformNames.map((c => `#define HAS_UNIFORM_${c}`)))
            }
            return t
          }
          getBinderAttributes() {
            const t = [];
            for (const r in this.binders) {
              const o = this.binders[r];
              if (o instanceof ao || o instanceof za)
                for (let c = 0; c < o.paintVertexAttributes.length; c++) t.push(o.paintVertexAttributes[c].name);
              else if (o instanceof Io)
                for (let c = 0; c < li.members.length; c++) t.push(li.members[c].name)
            }
            return t
          }
          getBinderUniforms() {
            const t = [];
            for (const r in this.binders) {
              const o = this.binders[r];
              if (o instanceof ul || o instanceof As || o instanceof za)
                for (const c of o.uniformNames) t.push(c)
            }
            return t
          }
          getPaintVertexBuffers() {
            return this._buffers
          }
          getUniforms(t, r) {
            const o = [];
            for (const c in this.binders) {
              const m = this.binders[c];
              if (m instanceof ul || m instanceof As || m instanceof za) {
                for (const _ of m.uniformNames)
                  if (r[_]) {
                    const v = m.getBinding(t, r[_], _);
                    o.push({
                      name: _,
                      property: c,
                      binding: v
                    })
                  }
              }
            }
            return o
          }
          setUniforms(t, r, o, c) {
            for (const {
                name: m,
                property: _,
                binding: v
              }
              of r) this.binders[_].setUniform(v, c, o.get(_), m)
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const r in this.binders) {
              const o = this.binders[r];
              if (t && o instanceof Io) {
                const c = t.fromScale === 2 ? o.zoomInPaintVertexBuffer : o.zoomOutPaintVertexBuffer;
                c && this._buffers.push(c)
              } else(o instanceof ao || o instanceof za) && o.paintVertexBuffer && this._buffers.push(o.paintVertexBuffer)
            }
          }
          upload(t) {
            for (const r in this.binders) {
              const o = this.binders[r];
              (o instanceof ao || o instanceof za || o instanceof Io) && o.upload(t)
            }
            this.updatePaintBuffers()
          }
          destroy() {
            for (const t in this.binders) {
              const r = this.binders[t];
              (r instanceof ao || r instanceof za || r instanceof Io) && r.destroy()
            }
          }
        }
        class ia {
          constructor(t, r, o = () => !0) {
            this.programConfigurations = {};
            for (const c of t) this.programConfigurations[c.id] = new Dd(c, r, o);
            this.needsUpload = !1, this._featureMap = new Yo, this._bufferOffset = 0
          }
          populatePaintArrays(t, r, o, c, m, _) {
            for (const v in this.programConfigurations) this.programConfigurations[v].populatePaintArrays(t, r, c, m, _);
            r.id !== void 0 && this._featureMap.add(r.id, o, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0
          }
          updatePaintArrays(t, r, o, c) {
            for (const m of o) this.needsUpload = this.programConfigurations[m.id].updatePaintArrays(t, this._featureMap, r, m, c) || this.needsUpload
          }
          get(t) {
            return this.programConfigurations[t]
          }
          upload(t) {
            if (this.needsUpload) {
              for (const r in this.programConfigurations) this.programConfigurations[r].upload(t);
              this.needsUpload = !1
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy()
          }
        }

        function Rd(n, t) {
          return {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
          } [n] || [n.replace(`${t}-`, "").replace(/-/g, "_")]
        }

        function Cu(n, t, r) {
          const o = {
              color: {
                source: cl,
                composite: z
              },
              number: {
                source: f,
                composite: cl
              }
            },
            c = (function(m) {
              return {
                "line-pattern": {
                  source: Ht,
                  composite: Ht
                },
                "fill-pattern": {
                  source: Ht,
                  composite: Ht
                },
                "fill-extrusion-pattern": {
                  source: Ht,
                  composite: Ht
                }
              } [m]
            })(n);
          return c && c[r] || o[t][r]
        }
        hr("ConstantBinder", ul), hr("CrossFadedConstantBinder", As), hr("SourceExpressionBinder", ao), hr("CrossFadedCompositeBinder", Io), hr("CompositeExpressionBinder", za), hr("ProgramConfiguration", Dd, {
          omit: ["_buffers"]
        }), hr("ProgramConfigurationSet", ia);
        const rc = Math.pow(2, 14) - 1,
          nc = -rc - 1;

        function Po(n) {
          const t = ae / n.extent,
            r = n.loadGeometry();
          for (let o = 0; o < r.length; o++) {
            const c = r[o];
            for (let m = 0; m < c.length; m++) {
              const _ = c[m],
                v = Math.round(_.x * t),
                w = Math.round(_.y * t);
              _.x = Lt(v, nc, rc), _.y = Lt(w, nc, rc), (v < _.x || v > _.x + 1 || w < _.y || w > _.y + 1) && Bt("Geometry exceeds allowed extent, reduce your vector tile buffer size")
            }
          }
          return r
        }

        function oo(n, t) {
          return {
            type: n.type,
            id: n.id,
            properties: n.properties,
            geometry: t ? Po(n) : []
          }
        }
        const z_ = -32768;

        function Iy(n, t, r, o, c) {
          n.emplaceBack(z_ + 8 * t + o, z_ + 8 * r + c)
        }
        class uf {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Ne, this.indexArray = new kn, this.segments = new un, this.programConfigurations = new ia(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, o) {
            const c = this.layers[0],
              m = [];
            let _ = null,
              v = !1,
              w = c.type === "heatmap";
            if (c.type === "circle") {
              const A = c;
              _ = A.layout.get("circle-sort-key"), v = !_.isConstant(), w = w || A.paint.get("circle-pitch-alignment") === "map"
            }
            const S = w ? r.subdivisionGranularity.circle : 1;
            for (const {
                feature: A,
                id: L,
                index: j,
                sourceLayerIndex: q
              }
              of t) {
              const $ = this.layers[0]._featureFilter.needGeometry,
                J = oo(A, $);
              if (!this.layers[0]._featureFilter.filter(new Un(this.zoom, {
                  globalState: this.globalState
                }), J, o)) continue;
              const te = v ? _.evaluate(J, {}, o) : void 0,
                he = {
                  id: L,
                  properties: A.properties,
                  type: A.type,
                  sourceLayerIndex: q,
                  index: j,
                  geometry: $ ? J.geometry : Po(A),
                  patterns: {},
                  sortKey: te
                };
              m.push(he)
            }
            v && m.sort(((A, L) => A.sortKey - L.sortKey));
            for (const A of m) {
              const {
                geometry: L,
                index: j,
                sourceLayerIndex: q
              } = A, $ = t[j].feature;
              this.addFeature(A, L, j, o, S), r.featureIndex.insert($, L, j, q, this.index)
            }
          }
          update(t, r, o) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, o)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Yn), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          addFeature(t, r, o, c, m = 1) {
            let _;
            switch (m) {
              case 1:
                _ = [0, 7];
                break;
              case 3:
                _ = [0, 2, 5, 7];
                break;
              case 5:
                _ = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                _ = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${m}; valid values are 1, 3, 5, 7.`)
            }
            const v = _.length;
            for (const w of r)
              for (const S of w) {
                const A = S.x,
                  L = S.y;
                if (A < 0 || A >= ae || L < 0 || L >= ae) continue;
                const j = this.segments.prepareSegment(v * v, this.layoutVertexArray, this.indexArray, t.sortKey),
                  q = j.vertexLength;
                for (let $ = 0; $ < v; $++)
                  for (let J = 0; J < v; J++) Iy(this.layoutVertexArray, A, L, _[J], _[$]);
                for (let $ = 0; $ < v - 1; $++)
                  for (let J = 0; J < v - 1; J++) {
                    const te = q + $ * v + J,
                      he = q + ($ + 1) * v + J;
                    this.indexArray.emplaceBack(te, he + 1, te + 1), this.indexArray.emplaceBack(te, he, he + 1)
                  }
                j.vertexLength += v * v, j.primitiveLength += (v - 1) * (v - 1) * 2
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {}, c)
          }
        }

        function L_(n, t) {
          for (let r = 0; r < n.length; r++)
            if (ic(t, n[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (ic(n, t[r])) return !0;
          return !!hf(n, t)
        }

        function Py(n, t, r) {
          return !!ic(n, t) || !!df(t, n, r)
        }

        function D_(n, t) {
          if (n.length === 1) return B_(t, n[0]);
          for (let r = 0; r < t.length; r++) {
            const o = t[r];
            for (let c = 0; c < o.length; c++)
              if (ic(n, o[c])) return !0
          }
          for (let r = 0; r < n.length; r++)
            if (B_(t, n[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (hf(n, t[r])) return !0;
          return !1
        }

        function ky(n, t, r) {
          if (n.length > 1) {
            if (hf(n, t)) return !0;
            for (let o = 0; o < t.length; o++)
              if (df(t[o], n, r)) return !0
          }
          for (let o = 0; o < n.length; o++)
            if (df(n[o], t, r)) return !0;
          return !1
        }

        function hf(n, t) {
          if (n.length === 0 || t.length === 0) return !1;
          for (let r = 0; r < n.length - 1; r++) {
            const o = n[r],
              c = n[r + 1];
            for (let m = 0; m < t.length - 1; m++)
              if (My(o, c, t[m], t[m + 1])) return !0
          }
          return !1
        }

        function My(n, t, r, o) {
          return Vt(n, r, o) !== Vt(t, r, o) && Vt(n, t, r) !== Vt(n, t, o)
        }

        function df(n, t, r) {
          const o = r * r;
          if (t.length === 1) return n.distSqr(t[0]) < o;
          for (let c = 1; c < t.length; c++)
            if (R_(n, t[c - 1], t[c]) < o) return !0;
          return !1
        }

        function R_(n, t, r) {
          const o = t.distSqr(r);
          if (o === 0) return n.distSqr(t);
          const c = ((n.x - t.x) * (r.x - t.x) + (n.y - t.y) * (r.y - t.y)) / o;
          return n.distSqr(c < 0 ? t : c > 1 ? r : r.sub(t)._mult(c)._add(t))
        }

        function B_(n, t) {
          let r, o, c, m = !1;
          for (let _ = 0; _ < n.length; _++) {
            r = n[_];
            for (let v = 0, w = r.length - 1; v < r.length; w = v++) o = r[v], c = r[w], o.y > t.y != c.y > t.y && t.x < (c.x - o.x) * (t.y - o.y) / (c.y - o.y) + o.x && (m = !m)
          }
          return m
        }

        function ic(n, t) {
          let r = !1;
          for (let o = 0, c = n.length - 1; o < n.length; c = o++) {
            const m = n[o],
              _ = n[c];
            m.y > t.y != _.y > t.y && t.x < (_.x - m.x) * (t.y - m.y) / (_.y - m.y) + m.x && (r = !r)
          }
          return r
        }

        function Ay(n, t, r) {
          const o = r[0],
            c = r[2];
          if (n.x < o.x && t.x < o.x || n.x > c.x && t.x > c.x || n.y < o.y && t.y < o.y || n.y > c.y && t.y > c.y) return !1;
          const m = Vt(n, t, r[0]);
          return m !== Vt(n, t, r[1]) || m !== Vt(n, t, r[2]) || m !== Vt(n, t, r[3])
        }

        function Tu(n, t, r) {
          const o = t.paint.get(n).value;
          return o.kind === "constant" ? o.value : r.programConfigurations.get(t.id).getMaxValue(n)
        }

        function Bd(n) {
          return Math.sqrt(n[0] * n[0] + n[1] * n[1])
        }

        function Fd(n, t, r, o, c) {
          if (!t[0] && !t[1]) return n;
          const m = F.convert(t)._mult(c);
          r === "viewport" && m._rotate(-o);
          const _ = [];
          for (let v = 0; v < n.length; v++) _.push(n[v].sub(m));
          return _
        }
        let F_, O_;
        hr("CircleBucket", uf, {
          omit: ["layers"]
        });
        var Ey = {
          get paint() {
            return O_ = O_ || new Wi({
              "circle-radius": new Gr(we.paint_circle["circle-radius"]),
              "circle-color": new Gr(we.paint_circle["circle-color"]),
              "circle-blur": new Gr(we.paint_circle["circle-blur"]),
              "circle-opacity": new Gr(we.paint_circle["circle-opacity"]),
              "circle-translate": new Mr(we.paint_circle["circle-translate"]),
              "circle-translate-anchor": new Mr(we.paint_circle["circle-translate-anchor"]),
              "circle-pitch-scale": new Mr(we.paint_circle["circle-pitch-scale"]),
              "circle-pitch-alignment": new Mr(we.paint_circle["circle-pitch-alignment"]),
              "circle-stroke-width": new Gr(we.paint_circle["circle-stroke-width"]),
              "circle-stroke-color": new Gr(we.paint_circle["circle-stroke-color"]),
              "circle-stroke-opacity": new Gr(we.paint_circle["circle-stroke-opacity"])
            })
          },
          get layout() {
            return F_ = F_ || new Wi({
              "circle-sort-key": new Gr(we.layout_circle["circle-sort-key"])
            })
          }
        };
        class zy extends _a {
          constructor(t) {
            super(t, Ey)
          }
          createBucket(t) {
            return new uf(t)
          }
          queryRadius(t) {
            const r = t;
            return Tu("circle-radius", this, r) + Tu("circle-stroke-width", this, r) + Bd(this.paint.get("circle-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: o,
            geometry: c,
            transform: m,
            pixelsToTileUnits: _,
            unwrappedTileID: v,
            getElevation: w
          }) {
            const S = Fd(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -m.bearingInRadians, _),
              A = this.paint.get("circle-radius").evaluate(r, o) + this.paint.get("circle-stroke-width").evaluate(r, o),
              L = this.paint.get("circle-pitch-alignment") === "map",
              j = L ? S : (function($, J, te, he) {
                return $.map((je => j_(je, J, te, he)))
              })(S, m, v, w),
              q = L ? A * _ : A;
            for (const $ of c)
              for (const J of $) {
                const te = L ? J : j_(J, m, v, w);
                let he = q;
                const je = m.projectTileCoordinates(J.x, J.y, v, w).signedDistanceFromCamera;
                if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? he *= je / m.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (he *= m.cameraToCenterDistance / je), Py(j, te, he)) return !0
              }
            return !1
          }
        }

        function j_(n, t, r, o) {
          const c = t.projectTileCoordinates(n.x, n.y, r, o).point;
          return new F((.5 * c.x + .5) * t.width, (.5 * -c.y + .5) * t.height)
        }
        class N_ extends uf {}
        let Z_;
        hr("HeatmapBucket", N_, {
          omit: ["layers"]
        });
        var Ly = {
          get paint() {
            return Z_ = Z_ || new Wi({
              "heatmap-radius": new Gr(we.paint_heatmap["heatmap-radius"]),
              "heatmap-weight": new Gr(we.paint_heatmap["heatmap-weight"]),
              "heatmap-intensity": new Mr(we.paint_heatmap["heatmap-intensity"]),
              "heatmap-color": new Kl(we.paint_heatmap["heatmap-color"]),
              "heatmap-opacity": new Mr(we.paint_heatmap["heatmap-opacity"])
            })
          }
        };

        function pf(n, {
          width: t,
          height: r
        }, o, c) {
          if (c) {
            if (c instanceof Uint8ClampedArray) c = new Uint8Array(c.buffer);
            else if (c.length !== t * r * o) throw new RangeError(`mismatched image size. expected: ${c.length} but got: ${t*r*o}`)
          } else c = new Uint8Array(t * r * o);
          return n.width = t, n.height = r, n.data = c, n
        }

        function V_(n, {
          width: t,
          height: r
        }, o) {
          if (t === n.width && r === n.height) return;
          const c = pf({}, {
            width: t,
            height: r
          }, o);
          ff(n, c, {
            x: 0,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            width: Math.min(n.width, t),
            height: Math.min(n.height, r)
          }, o), n.width = t, n.height = r, n.data = c.data
        }

        function ff(n, t, r, o, c, m) {
          if (c.width === 0 || c.height === 0) return t;
          if (c.width > n.width || c.height > n.height || r.x > n.width - c.width || r.y > n.height - c.height) throw new RangeError("out of range source coordinates for image copy");
          if (c.width > t.width || c.height > t.height || o.x > t.width - c.width || o.y > t.height - c.height) throw new RangeError("out of range destination coordinates for image copy");
          const _ = n.data,
            v = t.data;
          if (_ === v) throw new Error("srcData equals dstData, so image is already copied");
          for (let w = 0; w < c.height; w++) {
            const S = ((r.y + w) * n.width + r.x) * m,
              A = ((o.y + w) * t.width + o.x) * m;
            for (let L = 0; L < c.width * m; L++) v[A + L] = _[S + L]
          }
          return t
        }
        class Su {
          constructor(t, r) {
            pf(this, t, 1, r)
          }
          resize(t) {
            V_(this, t, 1)
          }
          clone() {
            return new Su({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, o, c, m) {
            ff(t, r, o, c, m, 1)
          }
        }
        class aa {
          constructor(t, r) {
            pf(this, t, 4, r)
          }
          resize(t) {
            V_(this, t, 4)
          }
          replace(t, r) {
            r ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
          }
          clone() {
            return new aa({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, o, c, m) {
            ff(t, r, o, c, m, 4)
          }
          setPixel(t, r, o) {
            const c = 4 * (t * this.width + r);
            this.data[c + 0] = Math.round(255 * o.r / o.a), this.data[c + 1] = Math.round(255 * o.g / o.a), this.data[c + 2] = Math.round(255 * o.b / o.a), this.data[c + 3] = Math.round(255 * o.a)
          }
        }

        function q_(n) {
          const t = {},
            r = n.resolution || 256,
            o = n.clips ? n.clips.length : 1,
            c = n.image || new aa({
              width: r,
              height: o
            });
          if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`);
          const m = (_, v, w) => {
            t[n.evaluationKey] = w;
            const S = n.expression.evaluate(t);
            c.setPixel(_ / 4 / r, v / 4, S)
          };
          if (n.clips)
            for (let _ = 0, v = 0; _ < o; ++_, v += 4 * r)
              for (let w = 0, S = 0; w < r; w++, S += 4) {
                const A = w / (r - 1),
                  {
                    start: L,
                    end: j
                  } = n.clips[_];
                m(v, S, L * (1 - A) + j * A)
              } else
                for (let _ = 0, v = 0; _ < r; _++, v += 4) m(0, v, _ / (r - 1));
          return c
        }
        hr("AlphaImage", Su), hr("RGBAImage", aa);
        const mf = "big-fb";
        class Dy extends _a {
          createBucket(t) {
            return new N_(t)
          }
          constructor(t) {
            super(t, Ly), this.heatmapFbos = new Map, this._updateColorRamp()
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp()
          }
          _updateColorRamp() {
            this.colorRamp = q_({
              expression: this._transitionablePaint._values["heatmap-color"].value.expression,
              evaluationKey: "heatmapDensity",
              image: this.colorRamp
            }), this.colorRampTexture = null
          }
          resize() {
            this.heatmapFbos.has(mf) && this.heatmapFbos.delete(mf)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            return !1
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
          }
        }
        let U_;
        var Ry = {
          get paint() {
            return U_ = U_ || new Wi({
              "hillshade-illumination-direction": new Mr(we.paint_hillshade["hillshade-illumination-direction"]),
              "hillshade-illumination-altitude": new Mr(we.paint_hillshade["hillshade-illumination-altitude"]),
              "hillshade-illumination-anchor": new Mr(we.paint_hillshade["hillshade-illumination-anchor"]),
              "hillshade-exaggeration": new Mr(we.paint_hillshade["hillshade-exaggeration"]),
              "hillshade-shadow-color": new Mr(we.paint_hillshade["hillshade-shadow-color"]),
              "hillshade-highlight-color": new Mr(we.paint_hillshade["hillshade-highlight-color"]),
              "hillshade-accent-color": new Mr(we.paint_hillshade["hillshade-accent-color"]),
              "hillshade-method": new Mr(we.paint_hillshade["hillshade-method"])
            })
          }
        };
        class By extends _a {
          constructor(t) {
            super(t, Ry), this.recalculate({
              zoom: 0,
              zoomHistory: {}
            }, void 0)
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values,
              r = this.paint.get("hillshade-illumination-altitude").values,
              o = this.paint.get("hillshade-highlight-color").values,
              c = this.paint.get("hillshade-shadow-color").values;
            const m = Math.max(t.length, r.length, o.length, c.length);
            t = t.concat(Array(m - t.length).fill(t.at(-1))), r = r.concat(Array(m - r.length).fill(r.at(-1))), o = o.concat(Array(m - o.length).fill(o.at(-1))), c = c.concat(Array(m - c.length).fill(c.at(-1)));
            const _ = r.map(dr);
            return {
              directionRadians: t.map(dr),
              altitudeRadians: _,
              shadowColor: c,
              highlightColor: o
            }
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
          }
        }
        let $_;
        var Fy = {
          get paint() {
            return $_ = $_ || new Wi({
              "color-relief-opacity": new Mr(we["paint_color-relief"]["color-relief-opacity"]),
              "color-relief-color": new Kl(we["paint_color-relief"]["color-relief-color"])
            })
          }
        };
        class _f {
          constructor(t, r, o, c) {
            this.context = t, this.format = o, this.texture = t.gl.createTexture(), this.update(r, c)
          }
          update(t, r, o) {
            const {
              width: c,
              height: m
            } = t, _ = !(this.size && this.size[0] === c && this.size[1] === m || o), {
              context: v
            } = this, {
              gl: w
            } = v;
            if (this.useMipmap = !!(r && r.useMipmap), w.bindTexture(w.TEXTURE_2D, this.texture), v.pixelStoreUnpackFlipY.set(!1), v.pixelStoreUnpack.set(1), v.pixelStoreUnpackPremultiplyAlpha.set(this.format === w.RGBA && (!r || r.premultiply !== !1)), _) this.size = [c, m], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Rt(t) ? w.texImage2D(w.TEXTURE_2D, 0, this.format, this.format, w.UNSIGNED_BYTE, t) : w.texImage2D(w.TEXTURE_2D, 0, this.format, c, m, 0, this.format, w.UNSIGNED_BYTE, t.data);
            else {
              const {
                x: S,
                y: A
              } = o || {
                x: 0,
                y: 0
              };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Rt(t) ? w.texSubImage2D(w.TEXTURE_2D, 0, S, A, w.RGBA, w.UNSIGNED_BYTE, t) : w.texSubImage2D(w.TEXTURE_2D, 0, S, A, c, m, w.RGBA, w.UNSIGNED_BYTE, t.data)
            }
            this.useMipmap && this.isSizePowerOfTwo() && w.generateMipmap(w.TEXTURE_2D), v.pixelStoreUnpackFlipY.setDefault(), v.pixelStoreUnpack.setDefault(), v.pixelStoreUnpackPremultiplyAlpha.setDefault()
          }
          bind(t, r, o) {
            const {
              context: c
            } = this, {
              gl: m
            } = c;
            m.bindTexture(m.TEXTURE_2D, this.texture), o !== m.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (o = m.LINEAR), t !== this.filter && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, t), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, o || t), this.filter = t), r !== this.wrap && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, r), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, r), this.wrap = r)
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
          }
          destroy() {
            const {
              gl: t
            } = this.context;
            t.deleteTexture(this.texture), this.texture = null
          }
        }
        class G_ {
          constructor(t, r, o, c = 1, m = 1, _ = 1, v = 0) {
            if (this.uid = t, r.height !== r.width) throw new RangeError("DEM tiles must be square");
            if (o && !["mapbox", "terrarium", "custom"].includes(o)) return void Bt(`"${o}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = r.height;
            const w = this.dim = r.height - 2;
            switch (this.data = new Uint32Array(r.data.buffer), o) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = c, this.greenFactor = m, this.blueFactor = _, this.baseShift = v;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4
            }
            for (let S = 0; S < w; S++) this.data[this._idx(-1, S)] = this.data[this._idx(0, S)], this.data[this._idx(w, S)] = this.data[this._idx(w - 1, S)], this.data[this._idx(S, -1)] = this.data[this._idx(S, 0)], this.data[this._idx(S, w)] = this.data[this._idx(S, w - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(w, -1)] = this.data[this._idx(w - 1, 0)], this.data[this._idx(-1, w)] = this.data[this._idx(0, w - 1)], this.data[this._idx(w, w)] = this.data[this._idx(w - 1, w - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let S = 0; S < w; S++)
              for (let A = 0; A < w; A++) {
                const L = this.get(S, A);
                L > this.max && (this.max = L), L < this.min && (this.min = L)
              }
          }
          get(t, r) {
            const o = new Uint8Array(this.data.buffer),
              c = 4 * this._idx(t, r);
            return this.unpack(o[c], o[c + 1], o[c + 2])
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
          }
          _idx(t, r) {
            if (t < -1 || t >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (r + 1) * this.stride + (t + 1)
          }
          unpack(t, r, o) {
            return t * this.redFactor + r * this.greenFactor + o * this.blueFactor - this.baseShift
          }
          pack(t) {
            return W_(t, this.getUnpackVector())
          }
          getPixels() {
            return new aa({
              width: this.stride,
              height: this.stride
            }, new Uint8Array(this.data.buffer))
          }
          backfillBorder(t, r, o) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let c = r * this.dim,
              m = r * this.dim + this.dim,
              _ = o * this.dim,
              v = o * this.dim + this.dim;
            switch (r) {
              case -1:
                c = m - 1;
                break;
              case 1:
                m = c + 1
            }
            switch (o) {
              case -1:
                _ = v - 1;
                break;
              case 1:
                v = _ + 1
            }
            const w = -r * this.dim,
              S = -o * this.dim;
            for (let A = _; A < v; A++)
              for (let L = c; L < m; L++) this.data[this._idx(L, A)] = t.data[this._idx(L + w, A + S)]
          }
        }

        function W_(n, t) {
          const r = t[0],
            o = t[1],
            c = t[2],
            m = t[3],
            _ = Math.min(r, o, c),
            v = Math.round((n + m) / _);
          return {
            r: Math.floor(v * _ / r) % 256,
            g: Math.floor(v * _ / o) % 256,
            b: Math.floor(v * _ / c) % 256
          }
        }
        hr("DEMData", G_);
        class Oy extends _a {
          constructor(t) {
            super(t, Fy)
          }
          _createColorRamp(t) {
            const r = {
                elevationStops: [],
                colorStops: []
              },
              o = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (o instanceof el && o._styleExpression.expression instanceof Ei) {
              this.colorRampExpression = o;
              const _ = o._styleExpression.expression;
              r.elevationStops = _.labels, r.colorStops = [];
              for (const v of r.elevationStops) r.colorStops.push(_.evaluate({
                globals: {
                  elevation: v
                }
              }))
            }
            if (r.elevationStops.length < 1 && (r.elevationStops = [0], r.colorStops = [kr.transparent]), r.elevationStops.length < 2 && (r.elevationStops.push(r.elevationStops[0] + 1), r.colorStops.push(r.colorStops[0])), r.elevationStops.length <= t) return r;
            const c = {
                elevationStops: [],
                colorStops: []
              },
              m = (r.elevationStops.length - 1) / (t - 1);
            for (let _ = 0; _ < r.elevationStops.length - .5; _ += m) c.elevationStops.push(r.elevationStops[Math.round(_)]), c.colorStops.push(r.colorStops[Math.round(_)]);
            return Bt(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), c
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
          }
          getColorRampTextures(t, r, o) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const c = this._createColorRamp(r),
              m = new aa({
                width: c.colorStops.length,
                height: 1
              }),
              _ = new aa({
                width: c.colorStops.length,
                height: 1
              });
            for (let v = 0; v < c.elevationStops.length; v++) {
              const w = W_(c.elevationStops[v], o);
              _.setPixel(0, v, new kr(w.r / 255, w.g / 255, w.b / 255, 1)), m.setPixel(0, v, c.colorStops[v])
            }
            return this.colorRampTextures = {
              elevationTexture: new _f(t, _, t.gl.RGBA),
              colorTexture: new _f(t, m, t.gl.RGBA)
            }, this.colorRampTextures
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures
          }
        }
        const jy = ei([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: Ny
          } = jy;

        function gf(n, t, r) {
          const o = r.patternDependencies;
          let c = !1;
          for (const m of t) {
            const _ = m.paint.get(`${n}-pattern`);
            _.isConstant() || (c = !0);
            const v = _.constantOr(null);
            v && (c = !0, o[v.to] = !0, o[v.from] = !0)
          }
          return c
        }

        function vf(n, t, r, o, c) {
          const m = c.patternDependencies;
          for (const _ of t) {
            const v = _.paint.get(`${n}-pattern`).value;
            if (v.kind !== "constant") {
              let w = v.evaluate({
                  zoom: o - 1
                }, r, {}, c.availableImages),
                S = v.evaluate({
                  zoom: o
                }, r, {}, c.availableImages),
                A = v.evaluate({
                  zoom: o + 1
                }, r, {}, c.availableImages);
              w = w && w.name ? w.name : w, S = S && S.name ? S.name : S, A = A && A.name ? A.name : A, m[w] = !0, m[S] = !0, m[A] = !0, r.patterns[_.id] = {
                min: w,
                mid: S,
                max: A
              }
            }
          }
          return r
        }

        function H_(n, t, r, o, c) {
          let m;
          if (c === (function(_, v, w, S) {
              let A = 0;
              for (let L = v, j = w - S; L < w; L += S) A += (_[j] - _[L]) * (_[L + 1] + _[j + 1]), j = L;
              return A
            })(n, t, r, o) > 0)
            for (let _ = t; _ < r; _ += o) m = K_(_ / o | 0, n[_], n[_ + 1], m);
          else
            for (let _ = r - o; _ >= t; _ -= o) m = K_(_ / o | 0, n[_], n[_ + 1], m);
          return m && ac(m, m.next) && (Mu(m), m = m.next), m
        }

        function hl(n, t) {
          if (!n) return n;
          t || (t = n);
          let r, o = n;
          do
            if (r = !1, o.steiner || !ac(o, o.next) && ii(o.prev, o, o.next) !== 0) o = o.next;
            else {
              if (Mu(o), o = t = o.prev, o === o.next) break;
              r = !0
            } while (r || o !== t);
          return t
        }

        function Iu(n, t, r, o, c, m, _) {
          if (!n) return;
          !_ && m && (function(w, S, A, L) {
            let j = w;
            do j.z === 0 && (j.z = yf(j.x, j.y, S, A, L)), j.prevZ = j.prev, j.nextZ = j.next, j = j.next; while (j !== w);
            j.prevZ.nextZ = null, j.prevZ = null, (function(q) {
              let $, J = 1;
              do {
                let te, he = q;
                q = null;
                let je = null;
                for ($ = 0; he;) {
                  $++;
                  let be = he,
                    Me = 0;
                  for (let ct = 0; ct < J && (Me++, be = be.nextZ, be); ct++);
                  let et = J;
                  for (; Me > 0 || et > 0 && be;) Me !== 0 && (et === 0 || !be || he.z <= be.z) ? (te = he, he = he.nextZ, Me--) : (te = be, be = be.nextZ, et--), je ? je.nextZ = te : q = te, te.prevZ = je, je = te;
                  he = be
                }
                je.nextZ = null, J *= 2
              } while ($ > 1)
            })(j)
          })(n, o, c, m);
          let v = n;
          for (; n.prev !== n.next;) {
            const w = n.prev,
              S = n.next;
            if (m ? Vy(n, o, c, m) : Zy(n)) t.push(w.i, n.i, S.i), Mu(n), n = S.next, v = S.next;
            else if ((n = S) === v) {
              _ ? _ === 1 ? Iu(n = qy(hl(n), t), t, r, o, c, m, 2) : _ === 2 && Uy(n, t, r, o, c, m) : Iu(hl(n), t, r, o, c, m, 1);
              break
            }
          }
        }

        function Zy(n) {
          const t = n.prev,
            r = n,
            o = n.next;
          if (ii(t, r, o) >= 0) return !1;
          const c = t.x,
            m = r.x,
            _ = o.x,
            v = t.y,
            w = r.y,
            S = o.y,
            A = Math.min(c, m, _),
            L = Math.min(v, w, S),
            j = Math.max(c, m, _),
            q = Math.max(v, w, S);
          let $ = o.next;
          for (; $ !== t;) {
            if ($.x >= A && $.x <= j && $.y >= L && $.y <= q && Pu(c, v, m, w, _, S, $.x, $.y) && ii($.prev, $, $.next) >= 0) return !1;
            $ = $.next
          }
          return !0
        }

        function Vy(n, t, r, o) {
          const c = n.prev,
            m = n,
            _ = n.next;
          if (ii(c, m, _) >= 0) return !1;
          const v = c.x,
            w = m.x,
            S = _.x,
            A = c.y,
            L = m.y,
            j = _.y,
            q = Math.min(v, w, S),
            $ = Math.min(A, L, j),
            J = Math.max(v, w, S),
            te = Math.max(A, L, j),
            he = yf(q, $, t, r, o),
            je = yf(J, te, t, r, o);
          let be = n.prevZ,
            Me = n.nextZ;
          for (; be && be.z >= he && Me && Me.z <= je;) {
            if (be.x >= q && be.x <= J && be.y >= $ && be.y <= te && be !== c && be !== _ && Pu(v, A, w, L, S, j, be.x, be.y) && ii(be.prev, be, be.next) >= 0 || (be = be.prevZ, Me.x >= q && Me.x <= J && Me.y >= $ && Me.y <= te && Me !== c && Me !== _ && Pu(v, A, w, L, S, j, Me.x, Me.y) && ii(Me.prev, Me, Me.next) >= 0)) return !1;
            Me = Me.nextZ
          }
          for (; be && be.z >= he;) {
            if (be.x >= q && be.x <= J && be.y >= $ && be.y <= te && be !== c && be !== _ && Pu(v, A, w, L, S, j, be.x, be.y) && ii(be.prev, be, be.next) >= 0) return !1;
            be = be.prevZ
          }
          for (; Me && Me.z <= je;) {
            if (Me.x >= q && Me.x <= J && Me.y >= $ && Me.y <= te && Me !== c && Me !== _ && Pu(v, A, w, L, S, j, Me.x, Me.y) && ii(Me.prev, Me, Me.next) >= 0) return !1;
            Me = Me.nextZ
          }
          return !0
        }

        function qy(n, t) {
          let r = n;
          do {
            const o = r.prev,
              c = r.next.next;
            !ac(o, c) && X_(o, r, r.next, c) && ku(o, c) && ku(c, o) && (t.push(o.i, r.i, c.i), Mu(r), Mu(r.next), r = n = c), r = r.next
          } while (r !== n);
          return hl(r)
        }

        function Uy(n, t, r, o, c, m) {
          let _ = n;
          do {
            let v = _.next.next;
            for (; v !== _.prev;) {
              if (_.i !== v.i && Jy(_, v)) {
                let w = Y_(_, v);
                return _ = hl(_, _.next), w = hl(w, w.next), Iu(_, t, r, o, c, m, 0), void Iu(w, t, r, o, c, m, 0)
              }
              v = v.next
            }
            _ = _.next
          } while (_ !== n)
        }

        function $y(n, t) {
          let r = n.x - t.x;
          return r === 0 && (r = n.y - t.y, r === 0) && (r = (n.next.y - n.y) / (n.next.x - n.x) - (t.next.y - t.y) / (t.next.x - t.x)), r
        }

        function Gy(n, t) {
          const r = (function(c, m) {
            let _ = m;
            const v = c.x,
              w = c.y;
            let S, A = -1 / 0;
            if (ac(c, _)) return _;
            do {
              if (ac(c, _.next)) return _.next;
              if (w <= _.y && w >= _.next.y && _.next.y !== _.y) {
                const J = _.x + (w - _.y) * (_.next.x - _.x) / (_.next.y - _.y);
                if (J <= v && J > A && (A = J, S = _.x < _.next.x ? _ : _.next, J === v)) return S
              }
              _ = _.next
            } while (_ !== m);
            if (!S) return null;
            const L = S,
              j = S.x,
              q = S.y;
            let $ = 1 / 0;
            _ = S;
            do {
              if (v >= _.x && _.x >= j && v !== _.x && J_(w < q ? v : A, w, j, q, w < q ? A : v, w, _.x, _.y)) {
                const J = Math.abs(w - _.y) / (v - _.x);
                ku(_, c) && (J < $ || J === $ && (_.x > S.x || _.x === S.x && Wy(S, _))) && (S = _, $ = J)
              }
              _ = _.next
            } while (_ !== L);
            return S
          })(n, t);
          if (!r) return t;
          const o = Y_(r, n);
          return hl(o, o.next), hl(r, r.next)
        }

        function Wy(n, t) {
          return ii(n.prev, n, t.prev) < 0 && ii(t.next, n, n.next) < 0
        }

        function yf(n, t, r, o, c) {
          return (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - r) * c | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - o) * c | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }

        function Hy(n) {
          let t = n,
            r = n;
          do(t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next; while (t !== n);
          return r
        }

        function J_(n, t, r, o, c, m, _, v) {
          return (c - _) * (t - v) >= (n - _) * (m - v) && (n - _) * (o - v) >= (r - _) * (t - v) && (r - _) * (m - v) >= (c - _) * (o - v)
        }

        function Pu(n, t, r, o, c, m, _, v) {
          return !(n === _ && t === v) && J_(n, t, r, o, c, m, _, v)
        }

        function Jy(n, t) {
          return n.next.i !== t.i && n.prev.i !== t.i && !(function(r, o) {
            let c = r;
            do {
              if (c.i !== r.i && c.next.i !== r.i && c.i !== o.i && c.next.i !== o.i && X_(c, c.next, r, o)) return !0;
              c = c.next
            } while (c !== r);
            return !1
          })(n, t) && (ku(n, t) && ku(t, n) && (function(r, o) {
            let c = r,
              m = !1;
            const _ = (r.x + o.x) / 2,
              v = (r.y + o.y) / 2;
            do c.y > v != c.next.y > v && c.next.y !== c.y && _ < (c.next.x - c.x) * (v - c.y) / (c.next.y - c.y) + c.x && (m = !m), c = c.next; while (c !== r);
            return m
          })(n, t) && (ii(n.prev, n, t.prev) || ii(n, t.prev, t)) || ac(n, t) && ii(n.prev, n, n.next) > 0 && ii(t.prev, t, t.next) > 0)
        }

        function ii(n, t, r) {
          return (t.y - n.y) * (r.x - t.x) - (t.x - n.x) * (r.y - t.y)
        }

        function ac(n, t) {
          return n.x === t.x && n.y === t.y
        }

        function X_(n, t, r, o) {
          const c = jd(ii(n, t, r)),
            m = jd(ii(n, t, o)),
            _ = jd(ii(r, o, n)),
            v = jd(ii(r, o, t));
          return c !== m && _ !== v || !(c !== 0 || !Od(n, r, t)) || !(m !== 0 || !Od(n, o, t)) || !(_ !== 0 || !Od(r, n, o)) || !(v !== 0 || !Od(r, t, o))
        }

        function Od(n, t, r) {
          return t.x <= Math.max(n.x, r.x) && t.x >= Math.min(n.x, r.x) && t.y <= Math.max(n.y, r.y) && t.y >= Math.min(n.y, r.y)
        }

        function jd(n) {
          return n > 0 ? 1 : n < 0 ? -1 : 0
        }

        function ku(n, t) {
          return ii(n.prev, n, n.next) < 0 ? ii(n, t, n.next) >= 0 && ii(n, n.prev, t) >= 0 : ii(n, t, n.prev) < 0 || ii(n, n.next, t) < 0
        }

        function Y_(n, t) {
          const r = xf(n.i, n.x, n.y),
            o = xf(t.i, t.x, t.y),
            c = n.next,
            m = t.prev;
          return n.next = t, t.prev = n, r.next = c, c.prev = r, o.next = r, r.prev = o, m.next = o, o.prev = m, o
        }

        function K_(n, t, r, o) {
          const c = xf(n, t, r);
          return o ? (c.next = o.next, c.prev = o, o.next.prev = c, o.next = c) : (c.prev = c, c.next = c), c
        }

        function Mu(n) {
          n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ)
        }

        function xf(n, t, r) {
          return {
            i: n,
            x: t,
            y: r,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
          }
        }
        class oc {
          constructor(t, r) {
            if (r > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = r
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1)
          }
        }
        class Nd {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle
          }
        }
        Nd.noSubdivision = new Nd({
          fill: new oc(0, 0),
          line: new oc(0, 0),
          tile: new oc(0, 0),
          stencil: new oc(0, 0),
          circle: 1
        }), hr("SubdivisionGranularityExpression", oc), hr("SubdivisionGranularitySetting", Nd);
        const sc = -32768,
          Au = 32767;
        class Xy {
          constructor(t, r) {
            this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = t, this._granularityCellSize = ae / t, this._canonical = r
          }
          _getKey(t, r) {
            return (t += 32768) << 16 | r + 32768
          }
          _vertexToIndex(t, r) {
            if (t < -32768 || r < -32768 || t > 32767 || r > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const o = 0 | Math.round(t),
              c = 0 | Math.round(r),
              m = this._getKey(o, c);
            if (this._vertexDictionary.has(m)) return this._vertexDictionary.get(m);
            const _ = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(m, _), this._vertexBuffer.push(o, c), _
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(c, m) {
              const _ = [];
              for (let v = 0; v < m.length; v += 3) {
                const w = m[v],
                  S = m[v + 1],
                  A = m[v + 2],
                  L = c[2 * w],
                  j = c[2 * w + 1];
                (c[2 * S] - L) * (c[2 * A + 1] - j) - (c[2 * S + 1] - j) * (c[2 * A] - L) > 0 ? (_.push(w), _.push(A), _.push(S)) : (_.push(w), _.push(S), _.push(A))
              }
              return _
            })(this._vertexBuffer, t);
            const r = [],
              o = t.length;
            for (let c = 0; c < o; c += 3) {
              const m = [t[c + 0], t[c + 1], t[c + 2]],
                _ = [this._vertexBuffer[2 * t[c + 0] + 0], this._vertexBuffer[2 * t[c + 0] + 1], this._vertexBuffer[2 * t[c + 1] + 0], this._vertexBuffer[2 * t[c + 1] + 1], this._vertexBuffer[2 * t[c + 2] + 0], this._vertexBuffer[2 * t[c + 2] + 1]];
              let v = 1 / 0,
                w = 1 / 0,
                S = -1 / 0,
                A = -1 / 0;
              for (let J = 0; J < 3; J++) {
                const te = _[2 * J],
                  he = _[2 * J + 1];
                v = Math.min(v, te), S = Math.max(S, te), w = Math.min(w, he), A = Math.max(A, he)
              }
              if (v === S || w === A) continue;
              const L = Math.floor(v / this._granularityCellSize),
                j = Math.ceil(S / this._granularityCellSize),
                q = Math.floor(w / this._granularityCellSize),
                $ = Math.ceil(A / this._granularityCellSize);
              if (L !== j || q !== $)
                for (let J = q; J < $; J++) {
                  const te = this._scanlineGenerateVertexRingForCellRow(J, _, m);
                  Yy(this._vertexBuffer, te, r)
                } else r.push(...m)
            }
            return r
          }
          _scanlineGenerateVertexRingForCellRow(t, r, o) {
            const c = t * this._granularityCellSize,
              m = c + this._granularityCellSize,
              _ = [];
            for (let v = 0; v < 3; v++) {
              const w = r[2 * v],
                S = r[2 * v + 1],
                A = r[2 * (v + 1) % 6],
                L = r[(2 * (v + 1) + 1) % 6],
                j = r[2 * (v + 2) % 6],
                q = r[(2 * (v + 2) + 1) % 6],
                $ = A - w,
                J = L - S,
                te = $ === 0,
                he = J === 0,
                je = (c - S) / J,
                be = (m - S) / J,
                Me = Math.min(je, be),
                et = Math.max(je, be);
              if (!he && (Me >= 1 || et <= 0) || he && (S < c || S > m)) {
                L >= c && L <= m && _.push(o[(v + 1) % 3]);
                continue
              }!he && Me > 0 && _.push(this._vertexToIndex(w + $ * Me, S + J * Me));
              const ct = w + $ * Math.max(Me, 0),
                Et = w + $ * Math.min(et, 1);
              te || this._generateIntraEdgeVertices(_, w, S, A, L, ct, Et), !he && et < 1 && _.push(this._vertexToIndex(w + $ * et, S + J * et)), (he || L >= c && L <= m) && _.push(o[(v + 1) % 3]), !he && (L <= c || L >= m) && this._generateInterEdgeVertices(_, w, S, A, L, j, q, Et, c, m)
            }
            return _
          }
          _generateIntraEdgeVertices(t, r, o, c, m, _, v) {
            const w = c - r,
              S = m - o,
              A = S === 0,
              L = A ? Math.min(r, c) : Math.min(_, v),
              j = A ? Math.max(r, c) : Math.max(_, v),
              q = Math.floor(L / this._granularityCellSize) + 1,
              $ = Math.ceil(j / this._granularityCellSize) - 1;
            if (A ? r < c : _ < v)
              for (let J = q; J <= $; J++) {
                const te = J * this._granularityCellSize;
                t.push(this._vertexToIndex(te, o + S * (te - r) / w))
              } else
                for (let J = $; J >= q; J--) {
                  const te = J * this._granularityCellSize;
                  t.push(this._vertexToIndex(te, o + S * (te - r) / w))
                }
          }
          _generateInterEdgeVertices(t, r, o, c, m, _, v, w, S, A) {
            const L = m - o,
              j = _ - c,
              q = v - m,
              $ = (S - m) / q,
              J = (A - m) / q,
              te = Math.min($, J),
              he = Math.max($, J),
              je = c + j * te;
            let be = Math.floor(Math.min(je, w) / this._granularityCellSize) + 1,
              Me = Math.ceil(Math.max(je, w) / this._granularityCellSize) - 1,
              et = w < je;
            const ct = q === 0;
            if (ct && (v === S || v === A)) return;
            if (ct || te >= 1 || he <= 0) {
              const ar = o - v,
                Jt = _ + (r - _) * Math.min((S - v) / ar, (A - v) / ar);
              be = Math.floor(Math.min(Jt, w) / this._granularityCellSize) + 1, Me = Math.ceil(Math.max(Jt, w) / this._granularityCellSize) - 1, et = w < Jt
            }
            const Et = L > 0 ? A : S;
            if (et)
              for (let ar = be; ar <= Me; ar++) t.push(this._vertexToIndex(ar * this._granularityCellSize, Et));
            else
              for (let ar = Me; ar >= be; ar--) t.push(this._vertexToIndex(ar * this._granularityCellSize, Et))
          }
          _generateOutline(t) {
            const r = [];
            for (const o of t) {
              const c = dl(o, this._granularity, !0),
                m = this._pointArrayToIndices(c),
                _ = [];
              for (let v = 1; v < m.length; v++) _.push(m[v - 1]), _.push(m[v]);
              r.push(_)
            }
            return r
          }
          _handlePoles(t) {
            let r = !1,
              o = !1;
            this._canonical && (this._canonical.y === 0 && (r = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (o = !0)), (r || o) && this._fillPoles(t, r, o)
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let r = 0; r < t.length; r += 2) {
              const o = t[r + 1];
              o === sc && (t[r + 1] = -32767), o === Au && (t[r + 1] = 32766)
            }
          }
          _generatePoleQuad(t, r, o, c, m, _) {
            c > m != (_ === sc) ? (t.push(r), t.push(o), t.push(this._vertexToIndex(c, _)), t.push(o), t.push(this._vertexToIndex(m, _)), t.push(this._vertexToIndex(c, _))) : (t.push(o), t.push(r), t.push(this._vertexToIndex(c, _)), t.push(this._vertexToIndex(m, _)), t.push(o), t.push(this._vertexToIndex(c, _)))
          }
          _fillPoles(t, r, o) {
            const c = this._vertexBuffer,
              m = ae,
              _ = t.length;
            for (let v = 2; v < _; v += 3) {
              const w = t[v - 2],
                S = t[v - 1],
                A = t[v],
                L = c[2 * w],
                j = c[2 * w + 1],
                q = c[2 * S],
                $ = c[2 * S + 1],
                J = c[2 * A],
                te = c[2 * A + 1];
              r && (j === 0 && $ === 0 && this._generatePoleQuad(t, w, S, L, q, sc), $ === 0 && te === 0 && this._generatePoleQuad(t, S, A, q, J, sc), te === 0 && j === 0 && this._generatePoleQuad(t, A, w, J, L, sc)), o && (j === m && $ === m && this._generatePoleQuad(t, w, S, L, q, Au), $ === m && te === m && this._generatePoleQuad(t, S, A, q, J, Au), te === m && j === m && this._generatePoleQuad(t, A, w, J, L, Au))
            }
          }
          _initializeVertices(t) {
            for (let r = 0; r < t.length; r += 2) this._vertexToIndex(t[r], t[r + 1])
          }
          subdividePolygonInternal(t, r) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const {
              flattened: o,
              holeIndices: c
            } = (function(v) {
              const w = [],
                S = [];
              for (const A of v)
                if (A.length !== 0) {
                  A !== v[0] && w.push(S.length / 2);
                  for (let L = 0; L < A.length; L++) S.push(A[L].x), S.push(A[L].y)
                } return {
                flattened: S,
                holeIndices: w
              }
            })(t);
            let m;
            this._initializeVertices(o);
            try {
              const v = (function(S, A, L = 2) {
                  const j = A && A.length,
                    q = j ? A[0] * L : S.length;
                  let $ = H_(S, 0, q, L, !0);
                  const J = [];
                  if (!$ || $.next === $.prev) return J;
                  let te, he, je;
                  if (j && ($ = (function(be, Me, et, ct) {
                      const Et = [];
                      for (let ar = 0, Jt = Me.length; ar < Jt; ar++) {
                        const tr = H_(be, Me[ar] * ct, ar < Jt - 1 ? Me[ar + 1] * ct : be.length, ct, !1);
                        tr === tr.next && (tr.steiner = !0), Et.push(Hy(tr))
                      }
                      Et.sort($y);
                      for (let ar = 0; ar < Et.length; ar++) et = Gy(Et[ar], et);
                      return et
                    })(S, A, $, L)), S.length > 80 * L) {
                    te = S[0], he = S[1];
                    let be = te,
                      Me = he;
                    for (let et = L; et < q; et += L) {
                      const ct = S[et],
                        Et = S[et + 1];
                      ct < te && (te = ct), Et < he && (he = Et), ct > be && (be = ct), Et > Me && (Me = Et)
                    }
                    je = Math.max(be - te, Me - he), je = je !== 0 ? 32767 / je : 0
                  }
                  return Iu($, J, L, te, he, je, 0), J
                })(o, c),
                w = this._convertIndices(o, v);
              m = this._subdivideTrianglesScanline(w)
            } catch (v) {
              console.error(v)
            }
            let _ = [];
            return r && (_ = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(m), {
              verticesFlattened: this._vertexBuffer,
              indicesTriangles: m,
              indicesLineList: _
            }
          }
          _convertIndices(t, r) {
            const o = [];
            for (let c = 0; c < r.length; c++) o.push(this._vertexToIndex(t[2 * r[c]], t[2 * r[c] + 1]));
            return o
          }
          _pointArrayToIndices(t) {
            const r = [];
            for (let o = 0; o < t.length; o++) {
              const c = t[o];
              r.push(this._vertexToIndex(c.x, c.y))
            }
            return r
          }
        }

        function Q_(n, t, r, o = !0) {
          return new Xy(r, t).subdividePolygonInternal(n, o)
        }

        function dl(n, t, r = !1) {
          if (!n || n.length < 1) return [];
          if (n.length < 2) return [];
          const o = n[0],
            c = n[n.length - 1],
            m = r && (o.x !== c.x || o.y !== c.y);
          if (t < 2) return m ? [...n, n[0]] : [...n];
          const _ = Math.floor(ae / t),
            v = [];
          v.push(new F(n[0].x, n[0].y));
          const w = n.length,
            S = m ? w : w - 1;
          for (let A = 0; A < S; A++) {
            const L = n[A],
              j = A < w - 1 ? n[A + 1] : n[0],
              q = L.x,
              $ = L.y,
              J = j.x,
              te = j.y,
              he = q !== J,
              je = $ !== te;
            if (!he && !je) continue;
            const be = J - q,
              Me = te - $,
              et = Math.abs(be),
              ct = Math.abs(Me);
            let Et = q,
              ar = $;
            for (;;) {
              const tr = be > 0 ? (Math.floor(Et / _) + 1) * _ : (Math.ceil(Et / _) - 1) * _,
                Rr = Me > 0 ? (Math.floor(ar / _) + 1) * _ : (Math.ceil(ar / _) - 1) * _,
                Qt = Math.abs(Et - tr),
                rr = Math.abs(ar - Rr),
                yt = Math.abs(Et - J),
                Yr = Math.abs(ar - te),
                on = he ? Qt / et : Number.POSITIVE_INFINITY,
                Zr = je ? rr / ct : Number.POSITIVE_INFINITY;
              if ((yt <= Qt || !he) && (Yr <= rr || !je)) break;
              if (on < Zr && he || !je) {
                Et = tr, ar += Me * on;
                const Cr = new F(Et, Math.round(ar));
                v[v.length - 1].x === Cr.x && v[v.length - 1].y === Cr.y || v.push(Cr)
              } else {
                Et += be * Zr, ar = Rr;
                const Cr = new F(Math.round(Et), ar);
                v[v.length - 1].x === Cr.x && v[v.length - 1].y === Cr.y || v.push(Cr)
              }
            }
            const Jt = new F(J, te);
            v[v.length - 1].x === Jt.x && v[v.length - 1].y === Jt.y || v.push(Jt)
          }
          return v
        }

        function Yy(n, t, r) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let o = 0,
            c = n[2 * t[0]];
          for (let w = 1; w < t.length; w++) {
            const S = n[2 * t[w]];
            S < c && (c = S, o = w)
          }
          const m = t.length;
          let _ = o,
            v = (_ + 1) % m;
          for (;;) {
            const w = _ - 1 >= 0 ? _ - 1 : m - 1,
              S = (v + 1) % m,
              A = n[2 * t[w]],
              L = n[2 * t[S]],
              j = n[2 * t[_]],
              q = n[2 * t[_] + 1],
              $ = n[2 * t[v] + 1];
            let J = !1;
            if (A < L) J = !0;
            else if (A > L) J = !1;
            else {
              const te = $ - q,
                he = -(n[2 * t[v]] - j),
                je = q < $ ? 1 : -1;
              ((A - j) * te + (n[2 * t[w] + 1] - q) * he) * je > ((L - j) * te + (n[2 * t[S] + 1] - q) * he) * je && (J = !0)
            }
            if (J) {
              const te = t[w],
                he = t[_],
                je = t[v];
              te !== he && te !== je && he !== je && r.push(je, he, te), _--, _ < 0 && (_ = m - 1)
            } else {
              const te = t[S],
                he = t[_],
                je = t[v];
              te !== he && te !== je && he !== je && r.push(je, he, te), v++, v >= m && (v = 0)
            }
            if (w === S) break
          }
        }

        function eg(n, t, r, o, c, m, _, v, w) {
          const S = c.length / 2,
            A = _ && v && w;
          if (S < un.MAX_VERTEX_ARRAY_LENGTH) {
            const L = t.prepareSegment(S, r, o),
              j = L.vertexLength;
            for (let J = 0; J < m.length; J += 3) o.emplaceBack(j + m[J], j + m[J + 1], j + m[J + 2]);
            let q, $;
            L.vertexLength += S, L.primitiveLength += m.length / 3, A && ($ = _.prepareSegment(S, r, v), q = $.vertexLength, $.vertexLength += S);
            for (let J = 0; J < c.length; J += 2) n(c[J], c[J + 1]);
            if (A)
              for (let J = 0; J < w.length; J++) {
                const te = w[J];
                for (let he = 1; he < te.length; he += 2) v.emplaceBack(q + te[he - 1], q + te[he]);
                $.primitiveLength += te.length / 2
              }
          } else(function(L, j, q, $, J, te) {
            const he = [];
            for (let ct = 0; ct < $.length / 2; ct++) he.push(-1);
            const je = {
              count: 0
            };
            let be = 0,
              Me = L.getOrCreateLatestSegment(j, q),
              et = Me.vertexLength;
            for (let ct = 2; ct < J.length; ct += 3) {
              const Et = J[ct - 2],
                ar = J[ct - 1],
                Jt = J[ct];
              let tr = he[Et] < be,
                Rr = he[ar] < be,
                Qt = he[Jt] < be;
              Me.vertexLength + ((tr ? 1 : 0) + (Rr ? 1 : 0) + (Qt ? 1 : 0)) > un.MAX_VERTEX_ARRAY_LENGTH && (Me = L.createNewSegment(j, q), be = je.count, tr = !0, Rr = !0, Qt = !0, et = 0);
              const rr = Eu(he, $, te, je, Et, tr, Me),
                yt = Eu(he, $, te, je, ar, Rr, Me),
                Yr = Eu(he, $, te, je, Jt, Qt, Me);
              q.emplaceBack(et + rr - be, et + yt - be, et + Yr - be), Me.primitiveLength++
            }
          })(t, r, o, c, m, n), A && (function(L, j, q, $, J, te) {
            const he = [];
            for (let ct = 0; ct < $.length / 2; ct++) he.push(-1);
            const je = {
              count: 0
            };
            let be = 0,
              Me = L.getOrCreateLatestSegment(j, q),
              et = Me.vertexLength;
            for (let ct = 0; ct < J.length; ct++) {
              const Et = J[ct];
              for (let ar = 1; ar < J[ct].length; ar += 2) {
                const Jt = Et[ar - 1],
                  tr = Et[ar];
                let Rr = he[Jt] < be,
                  Qt = he[tr] < be;
                Me.vertexLength + ((Rr ? 1 : 0) + (Qt ? 1 : 0)) > un.MAX_VERTEX_ARRAY_LENGTH && (Me = L.createNewSegment(j, q), be = je.count, Rr = !0, Qt = !0, et = 0);
                const rr = Eu(he, $, te, je, Jt, Rr, Me),
                  yt = Eu(he, $, te, je, tr, Qt, Me);
                q.emplaceBack(et + rr - be, et + yt - be), Me.primitiveLength++
              }
            }
          })(_, r, v, c, w, n), t.forceNewSegmentOnNextPrepare(), _ == null || _.forceNewSegmentOnNextPrepare()
        }

        function Eu(n, t, r, o, c, m, _) {
          if (m) {
            const v = o.count;
            return r(t[2 * c], t[2 * c + 1]), n[c] = o.count, o.count++, _.vertexLength++, v
          }
          return n[c]
        }
        class bf {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new st, this.indexArray = new kn, this.indexArray2 = new Sn, this.programConfigurations = new ia(t.layers, t.zoom), this.segments = new un, this.segments2 = new un, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, o) {
            this.hasPattern = gf("fill", this.layers, r);
            const c = this.layers[0].layout.get("fill-sort-key"),
              m = !c.isConstant(),
              _ = [];
            for (const {
                feature: v,
                id: w,
                index: S,
                sourceLayerIndex: A
              }
              of t) {
              const L = this.layers[0]._featureFilter.needGeometry,
                j = oo(v, L);
              if (!this.layers[0]._featureFilter.filter(new Un(this.zoom, {
                  globalState: this.globalState
                }), j, o)) continue;
              const q = m ? c.evaluate(j, {}, o, r.availableImages) : void 0,
                $ = {
                  id: w,
                  properties: v.properties,
                  type: v.type,
                  sourceLayerIndex: A,
                  index: S,
                  geometry: L ? j.geometry : Po(v),
                  patterns: {},
                  sortKey: q
                };
              _.push($)
            }
            m && _.sort(((v, w) => v.sortKey - w.sortKey));
            for (const v of _) {
              const {
                geometry: w,
                index: S,
                sourceLayerIndex: A
              } = v;
              if (this.hasPattern) {
                const L = vf("fill", this.layers, v, this.zoom, r);
                this.patternFeatures.push(L)
              } else this.addFeature(v, w, S, o, {}, r.subdivisionGranularity);
              r.featureIndex.insert(t[S].feature, w, S, A, this.index)
            }
          }
          update(t, r, o) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, o)
          }
          addFeatures(t, r, o) {
            for (const c of this.patternFeatures) this.addFeature(c, c.geometry, c.index, r, o, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ny), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy())
          }
          addFeature(t, r, o, c, m, _) {
            for (const v of Js(r, 500)) {
              const w = Q_(v, c, _.fill.getGranularityForZoomLevel(c.z)),
                S = this.layoutVertexArray;
              eg(((A, L) => {
                S.emplaceBack(A, L)
              }), this.segments, this.layoutVertexArray, this.indexArray, w.verticesFlattened, w.indicesTriangles, this.segments2, this.indexArray2, w.indicesLineList)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, m, c)
          }
        }
        let tg, rg;
        hr("FillBucket", bf, {
          omit: ["layers", "patternFeatures"]
        });
        var Ky = {
          get paint() {
            return rg = rg || new Wi({
              "fill-antialias": new Mr(we.paint_fill["fill-antialias"]),
              "fill-opacity": new Gr(we.paint_fill["fill-opacity"]),
              "fill-color": new Gr(we.paint_fill["fill-color"]),
              "fill-outline-color": new Gr(we.paint_fill["fill-outline-color"]),
              "fill-translate": new Mr(we.paint_fill["fill-translate"]),
              "fill-translate-anchor": new Mr(we.paint_fill["fill-translate-anchor"]),
              "fill-pattern": new Yl(we.paint_fill["fill-pattern"])
            })
          },
          get layout() {
            return tg = tg || new Wi({
              "fill-sort-key": new Gr(we.layout_fill["fill-sort-key"])
            })
          }
        };
        class Qy extends _a {
          constructor(t) {
            super(t, Ky)
          }
          recalculate(t, r) {
            super.recalculate(t, r);
            const o = this.paint._values["fill-outline-color"];
            o.value.kind === "constant" && o.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
          }
          createBucket(t) {
            return new bf(t)
          }
          queryRadius() {
            return Bd(this.paint.get("fill-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            geometry: r,
            transform: o,
            pixelsToTileUnits: c
          }) {
            return D_(Fd(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -o.bearingInRadians, c), r)
          }
          isTileClipped() {
            return !0
          }
        }
        const e1 = ei([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_normal_ed",
            components: 4,
            type: "Int16"
          }], 4),
          t1 = ei([{
            name: "a_centroid",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: r1
          } = e1;
        class lc {
          constructor(t, r, o, c, m) {
            this.properties = {}, this.extent = o, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = c, this._values = m, t.readFields(n1, this, r)
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos,
              o = [];
            let c, m = 1,
              _ = 0,
              v = 0,
              w = 0;
            for (; t.pos < r;) {
              if (_ <= 0) {
                const S = t.readVarint();
                m = 7 & S, _ = S >> 3
              }
              if (_--, m === 1 || m === 2) v += t.readSVarint(), w += t.readSVarint(), m === 1 && (c && o.push(c), c = []), c && c.push(new F(v, w));
              else {
                if (m !== 7) throw new Error(`unknown command ${m}`);
                c && c.push(c[0].clone())
              }
            }
            return c && o.push(c), o
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos;
            let o = 1,
              c = 0,
              m = 0,
              _ = 0,
              v = 1 / 0,
              w = -1 / 0,
              S = 1 / 0,
              A = -1 / 0;
            for (; t.pos < r;) {
              if (c <= 0) {
                const L = t.readVarint();
                o = 7 & L, c = L >> 3
              }
              if (c--, o === 1 || o === 2) m += t.readSVarint(), _ += t.readSVarint(), m < v && (v = m), m > w && (w = m), _ < S && (S = _), _ > A && (A = _);
              else if (o !== 7) throw new Error(`unknown command ${o}`)
            }
            return [v, S, w, A]
          }
          toGeoJSON(t, r, o) {
            const c = this.extent * Math.pow(2, o),
              m = this.extent * t,
              _ = this.extent * r,
              v = this.loadGeometry();

            function w(j) {
              return [360 * (j.x + m) / c - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (j.y + _) / c) * Math.PI)) - 90]
            }

            function S(j) {
              return j.map(w)
            }
            let A;
            if (this.type === 1) {
              const j = [];
              for (const $ of v) j.push($[0]);
              const q = S(j);
              A = j.length === 1 ? {
                type: "Point",
                coordinates: q[0]
              } : {
                type: "MultiPoint",
                coordinates: q
              }
            } else if (this.type === 2) {
              const j = v.map(S);
              A = j.length === 1 ? {
                type: "LineString",
                coordinates: j[0]
              } : {
                type: "MultiLineString",
                coordinates: j
              }
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const j = (function($) {
                    const J = $.length;
                    if (J <= 1) return [$];
                    const te = [];
                    let he, je;
                    for (let be = 0; be < J; be++) {
                      const Me = i1($[be]);
                      Me !== 0 && (je === void 0 && (je = Me < 0), je === Me < 0 ? (he && te.push(he), he = [$[be]]) : he && he.push($[be]))
                    }
                    return he && te.push(he), te
                  })(v),
                  q = [];
                for (const $ of j) q.push($.map(S));
                A = q.length === 1 ? {
                  type: "Polygon",
                  coordinates: q[0]
                } : {
                  type: "MultiPolygon",
                  coordinates: q
                }
              }
            }
            const L = {
              type: "Feature",
              geometry: A,
              properties: this.properties
            };
            return this.id != null && (L.id = this.id), L
          }
        }

        function n1(n, t, r) {
          n === 1 ? t.id = r.readVarint() : n === 2 ? (function(o, c) {
            const m = o.readVarint() + o.pos;
            for (; o.pos < m;) {
              const _ = c._keys[o.readVarint()],
                v = c._values[o.readVarint()];
              c.properties[_] = v
            }
          })(r, t) : n === 3 ? t.type = r.readVarint() : n === 4 && (t._geometry = r.pos)
        }

        function i1(n) {
          let t = 0;
          for (let r, o, c = 0, m = n.length, _ = m - 1; c < m; _ = c++) r = n[c], o = n[_], t += (o.x - r.x) * (r.y + o.y);
          return t
        }
        lc.types = ["Unknown", "Point", "LineString", "Polygon"];
        class ng {
          constructor(t, r) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(a1, this, r), this.length = this._features.length
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const r = this._pbf.readVarint() + this._pbf.pos;
            return new lc(this._pbf, r, this.extent, this._keys, this._values)
          }
        }

        function a1(n, t, r) {
          n === 15 ? t.version = r.readVarint() : n === 1 ? t.name = r.readString() : n === 5 ? t.extent = r.readVarint() : n === 2 ? t._features.push(r.pos) : n === 3 ? t._keys.push(r.readString()) : n === 4 && t._values.push((function(o) {
            let c = null;
            const m = o.readVarint() + o.pos;
            for (; o.pos < m;) {
              const _ = o.readVarint() >> 3;
              c = _ === 1 ? o.readString() : _ === 2 ? o.readFloat() : _ === 3 ? o.readDouble() : _ === 4 ? o.readVarint64() : _ === 5 ? o.readVarint() : _ === 6 ? o.readSVarint() : _ === 7 ? o.readBoolean() : null
            }
            if (c == null) throw new Error("unknown feature value");
            return c
          })(r))
        }
        class ig {
          constructor(t, r) {
            this.layers = t.readFields(o1, {}, r)
          }
        }

        function o1(n, t, r) {
          if (n === 3) {
            const o = new ng(r, r.readVarint() + r.pos);
            o.length && (t[o.name] = o)
          }
        }
        const wf = Math.pow(2, 13);

        function zu(n, t, r, o, c, m, _, v) {
          n.emplaceBack(t, r, 2 * Math.floor(o * wf) + _, c * wf * 2, m * wf * 2, Math.round(v))
        }
        class Cf {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Xe, this.centroidVertexArray = new ve, this.indexArray = new kn, this.programConfigurations = new ia(t.layers, t.zoom), this.segments = new un, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, o) {
            this.features = [], this.hasPattern = gf("fill-extrusion", this.layers, r);
            for (const {
                feature: c,
                id: m,
                index: _,
                sourceLayerIndex: v
              }
              of t) {
              const w = this.layers[0]._featureFilter.needGeometry,
                S = oo(c, w);
              if (!this.layers[0]._featureFilter.filter(new Un(this.zoom, {
                  globalState: this.globalState
                }), S, o)) continue;
              const A = {
                id: m,
                sourceLayerIndex: v,
                index: _,
                geometry: w ? S.geometry : Po(c),
                properties: c.properties,
                type: c.type,
                patterns: {}
              };
              this.hasPattern ? this.features.push(vf("fill-extrusion", this.layers, A, this.zoom, r)) : this.addFeature(A, A.geometry, _, o, {}, r.subdivisionGranularity), r.featureIndex.insert(c, A.geometry, _, v, this.index, !0)
            }
          }
          addFeatures(t, r, o) {
            for (const c of this.features) {
              const {
                geometry: m
              } = c;
              this.addFeature(c, m, c.index, r, o, t.subdivisionGranularity)
            }
          }
          update(t, r, o) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, o)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, r1), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, t1.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy())
          }
          addFeature(t, r, o, c, m, _) {
            for (const v of Js(r, 500)) {
              const w = {
                  x: 0,
                  y: 0,
                  sampleCount: 0
                },
                S = this.layoutVertexArray.length;
              this.processPolygon(w, c, t, v, _);
              const A = this.layoutVertexArray.length - S,
                L = Math.floor(w.x / w.sampleCount),
                j = Math.floor(w.y / w.sampleCount);
              for (let q = 0; q < A; q++) this.centroidVertexArray.emplaceBack(L, j)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, m, c)
          }
          processPolygon(t, r, o, c, m) {
            if (c.length < 1 || ag(c[0])) return;
            for (const L of c) L.length !== 0 && s1(t, L);
            const _ = {
                segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
              },
              v = m.fill.getGranularityForZoomLevel(r.z),
              w = lc.types[o.type] === "Polygon";
            for (const L of c) {
              if (L.length === 0 || ag(L)) continue;
              const j = dl(L, v, w);
              this._generateSideFaces(j, _)
            }
            if (!w) return;
            const S = Q_(c, r, v, !1),
              A = this.layoutVertexArray;
            eg(((L, j) => {
              zu(A, L, j, 0, 0, 1, 1, 0)
            }), this.segments, this.layoutVertexArray, this.indexArray, S.verticesFlattened, S.indicesTriangles)
          }
          _generateSideFaces(t, r) {
            let o = 0;
            for (let c = 1; c < t.length; c++) {
              const m = t[c],
                _ = t[c - 1];
              if (l1(m, _)) continue;
              r.segment.vertexLength + 4 > un.MAX_VERTEX_ARRAY_LENGTH && (r.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const v = m.sub(_)._perp()._unit(),
                w = _.dist(m);
              o + w > 32768 && (o = 0), zu(this.layoutVertexArray, m.x, m.y, v.x, v.y, 0, 0, o), zu(this.layoutVertexArray, m.x, m.y, v.x, v.y, 0, 1, o), o += w, zu(this.layoutVertexArray, _.x, _.y, v.x, v.y, 0, 0, o), zu(this.layoutVertexArray, _.x, _.y, v.x, v.y, 0, 1, o);
              const S = r.segment.vertexLength;
              this.indexArray.emplaceBack(S, S + 2, S + 1), this.indexArray.emplaceBack(S + 1, S + 2, S + 3), r.segment.vertexLength += 4, r.segment.primitiveLength += 2
            }
          }
        }

        function s1(n, t) {
          for (let r = 0; r < t.length; r++) {
            const o = t[r];
            r === t.length - 1 && t[0].x === o.x && t[0].y === o.y || (n.x += o.x, n.y += o.y, n.sampleCount++)
          }
        }

        function l1(n, t) {
          return n.x === t.x && (n.x < 0 || n.x > ae) || n.y === t.y && (n.y < 0 || n.y > ae)
        }

        function ag(n) {
          return n.every((t => t.x < 0)) || n.every((t => t.x > ae)) || n.every((t => t.y < 0)) || n.every((t => t.y > ae))
        }
        let og;
        hr("FillExtrusionBucket", Cf, {
          omit: ["layers", "features"]
        });
        var c1 = {
          get paint() {
            return og = og || new Wi({
              "fill-extrusion-opacity": new Mr(we["paint_fill-extrusion"]["fill-extrusion-opacity"]),
              "fill-extrusion-color": new Gr(we["paint_fill-extrusion"]["fill-extrusion-color"]),
              "fill-extrusion-translate": new Mr(we["paint_fill-extrusion"]["fill-extrusion-translate"]),
              "fill-extrusion-translate-anchor": new Mr(we["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
              "fill-extrusion-pattern": new Yl(we["paint_fill-extrusion"]["fill-extrusion-pattern"]),
              "fill-extrusion-height": new Gr(we["paint_fill-extrusion"]["fill-extrusion-height"]),
              "fill-extrusion-base": new Gr(we["paint_fill-extrusion"]["fill-extrusion-base"]),
              "fill-extrusion-vertical-gradient": new Mr(we["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
            })
          }
        };
        class u1 extends _a {
          constructor(t) {
            super(t, c1)
          }
          createBucket(t) {
            return new Cf(t)
          }
          queryRadius() {
            return Bd(this.paint.get("fill-extrusion-translate"))
          }
          is3D() {
            return !0
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: o,
            geometry: c,
            transform: m,
            pixelsToTileUnits: _,
            pixelPosMatrix: v
          }) {
            const w = Fd(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -m.bearingInRadians, _),
              S = this.paint.get("fill-extrusion-height").evaluate(r, o),
              A = this.paint.get("fill-extrusion-base").evaluate(r, o),
              L = (function(q, $) {
                const J = [];
                for (const te of q) {
                  const he = [te.x, te.y, 0, 1];
                  Ee(he, he, $), J.push(new F(he[0] / he[3], he[1] / he[3]))
                }
                return J
              })(w, v),
              j = (function(q, $, J, te) {
                const he = [],
                  je = [],
                  be = te[8] * $,
                  Me = te[9] * $,
                  et = te[10] * $,
                  ct = te[11] * $,
                  Et = te[8] * J,
                  ar = te[9] * J,
                  Jt = te[10] * J,
                  tr = te[11] * J;
                for (const Rr of q) {
                  const Qt = [],
                    rr = [];
                  for (const yt of Rr) {
                    const Yr = yt.x,
                      on = yt.y,
                      Zr = te[0] * Yr + te[4] * on + te[12],
                      Cr = te[1] * Yr + te[5] * on + te[13],
                      gn = te[2] * Yr + te[6] * on + te[14],
                      Kn = te[3] * Yr + te[7] * on + te[15],
                      gi = gn + et,
                      ji = Kn + ct,
                      Da = Zr + Et,
                      oa = Cr + ar,
                      zi = gn + Jt,
                      Wn = Kn + tr,
                      wi = new F((Zr + be) / ji, (Cr + Me) / ji);
                    wi.z = gi / ji, Qt.push(wi);
                    const Li = new F(Da / Wn, oa / Wn);
                    Li.z = zi / Wn, rr.push(Li)
                  }
                  he.push(Qt), je.push(rr)
                }
                return [he, je]
              })(c, A, S, v);
            return (function(q, $, J) {
              let te = 1 / 0;
              D_(J, $) && (te = sg(J, $[0]));
              for (let he = 0; he < $.length; he++) {
                const je = $[he],
                  be = q[he];
                for (let Me = 0; Me < je.length - 1; Me++) {
                  const et = je[Me],
                    ct = [et, je[Me + 1], be[Me + 1], be[Me], et];
                  L_(J, ct) && (te = Math.min(te, sg(J, ct)))
                }
              }
              return te !== 1 / 0 && te
            })(j[0], j[1], L)
          }
        }

        function Lu(n, t) {
          return n.x * t.x + n.y * t.y
        }

        function sg(n, t) {
          if (n.length === 1) {
            let r = 0;
            const o = t[r++];
            let c;
            for (; !c || o.equals(c);)
              if (c = t[r++], !c) return 1 / 0;
            for (; r < t.length; r++) {
              const m = t[r],
                _ = n[0],
                v = c.sub(o),
                w = m.sub(o),
                S = _.sub(o),
                A = Lu(v, v),
                L = Lu(v, w),
                j = Lu(w, w),
                q = Lu(S, v),
                $ = Lu(S, w),
                J = A * j - L * L,
                te = (j * q - L * $) / J,
                he = (A * $ - L * q) / J,
                je = o.z * (1 - te - he) + c.z * te + m.z * he;
              if (isFinite(je)) return je
            }
            return 1 / 0
          } {
            let r = 1 / 0;
            for (const o of t) r = Math.min(r, o.z);
            return r
          }
        }
        const h1 = ei([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
          }], 4),
          {
            members: d1
          } = h1,
          p1 = ei([{
            name: "a_uv_x",
            components: 1,
            type: "Float32"
          }, {
            name: "a_split_index",
            components: 1,
            type: "Float32"
          }]),
          {
            members: f1
          } = p1,
          m1 = Math.cos(Math.PI / 180 * 37.5),
          lg = Math.pow(2, 14) / .5;
        class Tf {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((r => {
              this.gradients[r.id] = {}
            })), this.layoutVertexArray = new Qe, this.layoutVertexArray2 = new at, this.indexArray = new kn, this.programConfigurations = new ia(t.layers, t.zoom), this.segments = new un, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, o) {
            this.hasPattern = gf("line", this.layers, r);
            const c = this.layers[0].layout.get("line-sort-key"),
              m = !c.isConstant(),
              _ = [];
            for (const {
                feature: v,
                id: w,
                index: S,
                sourceLayerIndex: A
              }
              of t) {
              const L = this.layers[0]._featureFilter.needGeometry,
                j = oo(v, L);
              if (!this.layers[0]._featureFilter.filter(new Un(this.zoom, {
                  globalState: this.globalState
                }), j, o)) continue;
              const q = m ? c.evaluate(j, {}, o) : void 0,
                $ = {
                  id: w,
                  properties: v.properties,
                  type: v.type,
                  sourceLayerIndex: A,
                  index: S,
                  geometry: L ? j.geometry : Po(v),
                  patterns: {},
                  sortKey: q
                };
              _.push($)
            }
            m && _.sort(((v, w) => v.sortKey - w.sortKey));
            for (const v of _) {
              const {
                geometry: w,
                index: S,
                sourceLayerIndex: A
              } = v;
              if (this.hasPattern) {
                const L = vf("line", this.layers, v, this.zoom, r);
                this.patternFeatures.push(L)
              } else this.addFeature(v, w, S, o, {}, r.subdivisionGranularity);
              r.featureIndex.insert(t[S].feature, w, S, A, this.index)
            }
          }
          update(t, r, o) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, o)
          }
          addFeatures(t, r, o) {
            for (const c of this.patternFeatures) this.addFeature(c, c.geometry, c.index, r, o, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, f1)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, d1), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return {
              start: +t.properties.mapbox_clip_start,
              end: +t.properties.mapbox_clip_end
            }
          }
          addFeature(t, r, o, c, m, _) {
            const v = this.layers[0].layout,
              w = v.get("line-join").evaluate(t, {}),
              S = v.get("line-cap"),
              A = v.get("line-miter-limit"),
              L = v.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const j of r) this.addLine(j, t, w, S, A, L, c, _);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, m, c)
          }
          addLine(t, r, o, c, m, _, v, w) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = dl(t, v ? w.line.getGranularityForZoomLevel(v.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let be = 0; be < t.length - 1; be++) this.totalDistance += t[be].dist(t[be + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
            }
            const S = lc.types[r.type] === "Polygon";
            let A = t.length;
            for (; A >= 2 && t[A - 1].equals(t[A - 2]);) A--;
            let L = 0;
            for (; L < A - 1 && t[L].equals(t[L + 1]);) L++;
            if (A < (S ? 3 : 2)) return;
            o === "bevel" && (m = 1.05);
            const j = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
              q = this.segments.prepareSegment(10 * A, this.layoutVertexArray, this.indexArray);
            let $, J, te, he, je;
            this.e1 = this.e2 = -1, S && ($ = t[A - 2], je = t[L].sub($)._unit()._perp());
            for (let be = L; be < A; be++) {
              if (te = be === A - 1 ? S ? t[L + 1] : void 0 : t[be + 1], te && t[be].equals(te)) continue;
              je && (he = je), $ && (J = $), $ = t[be], je = te ? te.sub($)._unit()._perp() : he, he = he || je;
              let Me = he.add(je);
              Me.x === 0 && Me.y === 0 || Me._unit();
              const et = he.x * je.x + he.y * je.y,
                ct = Me.x * je.x + Me.y * je.y,
                Et = ct !== 0 ? 1 / ct : 1 / 0,
                ar = 2 * Math.sqrt(2 - 2 * ct),
                Jt = ct < m1 && J && te,
                tr = he.x * je.y - he.y * je.x > 0;
              if (Jt && be > L) {
                const rr = $.dist(J);
                if (rr > 2 * j) {
                  const yt = $.sub($.sub(J)._mult(j / rr)._round());
                  this.updateDistance(J, yt), this.addCurrentVertex(yt, he, 0, 0, q), J = yt
                }
              }
              const Rr = J && te;
              let Qt = Rr ? o : S ? "butt" : c;
              if (Rr && Qt === "round" && (Et < _ ? Qt = "miter" : Et <= 2 && (Qt = "fakeround")), Qt === "miter" && Et > m && (Qt = "bevel"), Qt === "bevel" && (Et > 2 && (Qt = "flipbevel"), Et < m && (Qt = "miter")), J && this.updateDistance(J, $), Qt === "miter") Me._mult(Et), this.addCurrentVertex($, Me, 0, 0, q);
              else if (Qt === "flipbevel") {
                if (Et > 100) Me = je.mult(-1);
                else {
                  const rr = Et * he.add(je).mag() / he.sub(je).mag();
                  Me._perp()._mult(rr * (tr ? -1 : 1))
                }
                this.addCurrentVertex($, Me, 0, 0, q), this.addCurrentVertex($, Me.mult(-1), 0, 0, q)
              } else if (Qt === "bevel" || Qt === "fakeround") {
                const rr = -Math.sqrt(Et * Et - 1),
                  yt = tr ? rr : 0,
                  Yr = tr ? 0 : rr;
                if (J && this.addCurrentVertex($, he, yt, Yr, q), Qt === "fakeround") {
                  const on = Math.round(180 * ar / Math.PI / 20);
                  for (let Zr = 1; Zr < on; Zr++) {
                    let Cr = Zr / on;
                    if (Cr !== .5) {
                      const Kn = Cr - .5;
                      Cr += Cr * Kn * (Cr - 1) * ((1.0904 + et * (et * (3.55645 - 1.43519 * et) - 3.2452)) * Kn * Kn + (.848013 + et * (.215638 * et - 1.06021)))
                    }
                    const gn = je.sub(he)._mult(Cr)._add(he)._unit()._mult(tr ? -1 : 1);
                    this.addHalfVertex($, gn.x, gn.y, !1, tr, 0, q)
                  }
                }
                te && this.addCurrentVertex($, je, -yt, -Yr, q)
              } else if (Qt === "butt") this.addCurrentVertex($, Me, 0, 0, q);
              else if (Qt === "square") {
                const rr = J ? 1 : -1;
                this.addCurrentVertex($, Me, rr, rr, q)
              } else Qt === "round" && (J && (this.addCurrentVertex($, he, 0, 0, q), this.addCurrentVertex($, he, 1, 1, q, !0)), te && (this.addCurrentVertex($, je, -1, -1, q, !0), this.addCurrentVertex($, je, 0, 0, q)));
              if (Jt && be < A - 1) {
                const rr = $.dist(te);
                if (rr > 2 * j) {
                  const yt = $.add(te.sub($)._mult(j / rr)._round());
                  this.updateDistance($, yt), this.addCurrentVertex(yt, je, 0, 0, q), $ = yt
                }
              }
            }
          }
          addCurrentVertex(t, r, o, c, m, _ = !1) {
            const v = r.y * c - r.x,
              w = -r.y - r.x * c;
            this.addHalfVertex(t, r.x + r.y * o, r.y - r.x * o, _, !1, o, m), this.addHalfVertex(t, v, w, _, !0, -c, m), this.distance > lg / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, r, o, c, m, _))
          }
          addHalfVertex({
            x: t,
            y: r
          }, o, c, m, _, v, w) {
            const S = .5 * (this.lineClips ? this.scaledDistance * (lg - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (m ? 1 : 0), (r << 1) + (_ ? 1 : 0), Math.round(63 * o) + 128, Math.round(63 * c) + 128, 1 + (v === 0 ? 0 : v < 0 ? -1 : 1) | (63 & S) << 2, S >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const A = w.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, A, this.e2), w.primitiveLength++), _ ? this.e2 = A : this.e1 = A
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
          }
          updateDistance(t, r) {
            this.distance += t.dist(r), this.updateScaledDistance()
          }
        }
        let cg, ug;
        hr("LineBucket", Tf, {
          omit: ["layers", "patternFeatures"]
        });
        var hg = {
          get paint() {
            return ug = ug || new Wi({
              "line-opacity": new Gr(we.paint_line["line-opacity"]),
              "line-color": new Gr(we.paint_line["line-color"]),
              "line-translate": new Mr(we.paint_line["line-translate"]),
              "line-translate-anchor": new Mr(we.paint_line["line-translate-anchor"]),
              "line-width": new Gr(we.paint_line["line-width"]),
              "line-gap-width": new Gr(we.paint_line["line-gap-width"]),
              "line-offset": new Gr(we.paint_line["line-offset"]),
              "line-blur": new Gr(we.paint_line["line-blur"]),
              "line-dasharray": new wo(we.paint_line["line-dasharray"]),
              "line-pattern": new Yl(we.paint_line["line-pattern"]),
              "line-gradient": new Kl(we.paint_line["line-gradient"])
            })
          },
          get layout() {
            return cg = cg || new Wi({
              "line-cap": new Mr(we.layout_line["line-cap"]),
              "line-join": new Gr(we.layout_line["line-join"]),
              "line-miter-limit": new Mr(we.layout_line["line-miter-limit"]),
              "line-round-limit": new Mr(we.layout_line["line-round-limit"]),
              "line-sort-key": new Gr(we.layout_line["line-sort-key"])
            })
          }
        };
        class _1 extends Gr {
          possiblyEvaluate(t, r) {
            return r = new Un(Math.floor(r.zoom), {
              now: r.now,
              fadeDuration: r.fadeDuration,
              zoomHistory: r.zoomHistory,
              transition: r.transition
            }), super.possiblyEvaluate(t, r)
          }
          evaluate(t, r, o, c) {
            return r = ut({}, r, {
              zoom: Math.floor(r.zoom)
            }), super.evaluate(t, r, o, c)
          }
        }
        let Zd;
        class g1 extends _a {
          constructor(t) {
            super(t, hg), this.gradientVersion = 0, Zd || (Zd = new _1(hg.paint.properties["line-width"].specification), Zd.useIntegerZoom = !0)
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const r = this.gradientExpression();
              this.stepInterpolant = !!(function(o) {
                return o._styleExpression !== void 0
              })(r) && r._styleExpression.expression instanceof Fn, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression
          }
          recalculate(t, r) {
            super.recalculate(t, r), this.paint._values["line-floorwidth"] = Zd.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
          }
          createBucket(t) {
            return new Tf(t)
          }
          queryRadius(t) {
            const r = t,
              o = dg(Tu("line-width", this, r), Tu("line-gap-width", this, r)),
              c = Tu("line-offset", this, r);
            return o / 2 + Math.abs(c) + Bd(this.paint.get("line-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: o,
            geometry: c,
            transform: m,
            pixelsToTileUnits: _
          }) {
            const v = Fd(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -m.bearingInRadians, _),
              w = _ / 2 * dg(this.paint.get("line-width").evaluate(r, o), this.paint.get("line-gap-width").evaluate(r, o)),
              S = this.paint.get("line-offset").evaluate(r, o);
            return S && (c = (function(A, L) {
              const j = [];
              for (let q = 0; q < A.length; q++) {
                const $ = A[q],
                  J = [];
                for (let te = 0; te < $.length; te++) {
                  const he = $[te - 1],
                    je = $[te],
                    be = $[te + 1],
                    Me = te === 0 ? new F(0, 0) : je.sub(he)._unit()._perp(),
                    et = te === $.length - 1 ? new F(0, 0) : be.sub(je)._unit()._perp(),
                    ct = Me._add(et)._unit(),
                    Et = ct.x * et.x + ct.y * et.y;
                  Et !== 0 && ct._mult(1 / Et), J.push(ct._mult(L)._add(je))
                }
                j.push(J)
              }
              return j
            })(c, S * _)), (function(A, L, j) {
              for (let q = 0; q < L.length; q++) {
                const $ = L[q];
                if (A.length >= 3) {
                  for (let J = 0; J < $.length; J++)
                    if (ic(A, $[J])) return !0
                }
                if (ky(A, $, j)) return !0
              }
              return !1
            })(v, c, w)
          }
          isTileClipped() {
            return !0
          }
        }

        function dg(n, t) {
          return t > 0 ? t + 2 * n : n
        }
        const v1 = ei([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
          }], 4),
          y1 = ei([{
            name: "a_projected_pos",
            components: 3,
            type: "Float32"
          }], 4);
        ei([{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint32"
        }], 4);
        const x1 = ei([{
          name: "a_placed",
          components: 2,
          type: "Uint8"
        }, {
          name: "a_shift",
          components: 2,
          type: "Float32"
        }, {
          name: "a_box_real",
          components: 2,
          type: "Int16"
        }]);
        ei([{
          type: "Int16",
          name: "anchorPointX"
        }, {
          type: "Int16",
          name: "anchorPointY"
        }, {
          type: "Int16",
          name: "x1"
        }, {
          type: "Int16",
          name: "y1"
        }, {
          type: "Int16",
          name: "x2"
        }, {
          type: "Int16",
          name: "y2"
        }, {
          type: "Uint32",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "sourceLayerIndex"
        }, {
          type: "Uint16",
          name: "bucketIndex"
        }]);
        const pg = ei([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
          }], 4),
          b1 = ei([{
            name: "a_pos",
            components: 2,
            type: "Float32"
          }, {
            name: "a_radius",
            components: 1,
            type: "Float32"
          }, {
            name: "a_flags",
            components: 2,
            type: "Int16"
          }], 4);

        function w1(n, t, r) {
          return n.sections.forEach((o => {
            o.text = (function(c, m, _) {
              const v = m.layout.get("text-transform").evaluate(_, {});
              return v === "uppercase" ? c = c.toLocaleUpperCase() : v === "lowercase" && (c = c.toLocaleLowerCase()), Ma.applyArabicShaping && (c = Ma.applyArabicShaping(c)), c
            })(o.text, t, r)
          })), n
        }
        ei([{
          name: "triangle",
          components: 3,
          type: "Uint16"
        }]), ei([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Uint16",
          name: "glyphStartIndex"
        }, {
          type: "Uint16",
          name: "numGlyphs"
        }, {
          type: "Uint32",
          name: "vertexStartIndex"
        }, {
          type: "Uint32",
          name: "lineStartIndex"
        }, {
          type: "Uint32",
          name: "lineLength"
        }, {
          type: "Uint16",
          name: "segment"
        }, {
          type: "Uint16",
          name: "lowerSize"
        }, {
          type: "Uint16",
          name: "upperSize"
        }, {
          type: "Float32",
          name: "lineOffsetX"
        }, {
          type: "Float32",
          name: "lineOffsetY"
        }, {
          type: "Uint8",
          name: "writingMode"
        }, {
          type: "Uint8",
          name: "placedOrientation"
        }, {
          type: "Uint8",
          name: "hidden"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Int16",
          name: "associatedIconIndex"
        }]), ei([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Int16",
          name: "rightJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "centerJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "leftJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "placedIconSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedIconSymbolIndex"
        }, {
          type: "Uint16",
          name: "key"
        }, {
          type: "Uint16",
          name: "textBoxStartIndex"
        }, {
          type: "Uint16",
          name: "textBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxEndIndex"
        }, {
          type: "Uint16",
          name: "iconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "iconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "numHorizontalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numVerticalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numIconVertices"
        }, {
          type: "Uint16",
          name: "numVerticalIconVertices"
        }, {
          type: "Uint16",
          name: "useRuntimeCollisionCircles"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Float32",
          name: "textBoxScale"
        }, {
          type: "Float32",
          name: "collisionCircleDiameter"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetStartIndex"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetEndIndex"
        }]), ei([{
          type: "Float32",
          name: "offsetX"
        }]), ei([{
          type: "Int16",
          name: "x"
        }, {
          type: "Int16",
          name: "y"
        }, {
          type: "Int16",
          name: "tileUnitDistanceFromAnchor"
        }]), ei([{
          type: "Uint16",
          name: "textAnchor"
        }, {
          type: "Float32",
          components: 2,
          name: "textOffset"
        }]);
        const Du = {
          "!": "︕",
          "#": "＃",
          $: "＄",
          "%": "％",
          "&": "＆",
          "(": "︵",
          ")": "︶",
          "*": "＊",
          "+": "＋",
          ",": "︐",
          "-": "︲",
          ".": "・",
          "/": "／",
          ":": "︓",
          ";": "︔",
          "<": "︿",
          "=": "＝",
          ">": "﹀",
          "?": "︖",
          "@": "＠",
          "[": "﹇",
          "\\": "＼",
          "]": "﹈",
          "^": "＾",
          _: "︳",
          "`": "｀",
          "{": "︷",
          "|": "―",
          "}": "︸",
          "~": "～",
          "¢": "￠",
          "£": "￡",
          "¥": "￥",
          "¦": "￤",
          "¬": "￢",
          "¯": "￣",
          "–": "︲",
          "—": "︱",
          "‘": "﹃",
          "’": "﹄",
          "“": "﹁",
          "”": "﹂",
          "…": "︙",
          "‧": "・",
          "₩": "￦",
          "、": "︑",
          "。": "︒",
          "〈": "︿",
          "〉": "﹀",
          "《": "︽",
          "》": "︾",
          "「": "﹁",
          "」": "﹂",
          "『": "﹃",
          "』": "﹄",
          "【": "︻",
          "】": "︼",
          "〔": "︹",
          "〕": "︺",
          "〖": "︗",
          "〗": "︘",
          "！": "︕",
          "（": "︵",
          "）": "︶",
          "，": "︐",
          "－": "︲",
          "．": "・",
          "：": "︓",
          "；": "︔",
          "＜": "︿",
          "＞": "﹀",
          "？": "︖",
          "［": "﹇",
          "］": "﹈",
          "＿": "︳",
          "｛": "︷",
          "｜": "―",
          "｝": "︸",
          "｟": "︵",
          "｠": "︶",
          "｡": "︒",
          "｢": "﹁",
          "｣": "﹂"
        };
        var bi = 24;
        const Sf = 4294967296,
          fg = 1 / Sf,
          mg = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class If {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length
          }
          readFields(t, r, o = this.length) {
            for (; this.pos < o;) {
              const c = this.readVarint(),
                m = c >> 3,
                _ = this.pos;
              this.type = 7 & c, t(m, r, this), this.pos === _ && this.skip(c)
            }
            return r
          }
          readMessage(t, r) {
            return this.readFields(t, r, this.readVarint() + this.pos)
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, t
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, t
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * Sf;
            return this.pos += 8, t
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * Sf;
            return this.pos += 8, t
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, t
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, t
          }
          readVarint(t) {
            const r = this.buf;
            let o, c;
            return c = r[this.pos++], o = 127 & c, c < 128 ? o : (c = r[this.pos++], o |= (127 & c) << 7, c < 128 ? o : (c = r[this.pos++], o |= (127 & c) << 14, c < 128 ? o : (c = r[this.pos++], o |= (127 & c) << 21, c < 128 ? o : (c = r[this.pos], o |= (15 & c) << 28, (function(m, _, v) {
              const w = v.buf;
              let S, A;
              if (A = w[v.pos++], S = (112 & A) >> 4, A < 128 || (A = w[v.pos++], S |= (127 & A) << 3, A < 128) || (A = w[v.pos++], S |= (127 & A) << 10, A < 128) || (A = w[v.pos++], S |= (127 & A) << 17, A < 128) || (A = w[v.pos++], S |= (127 & A) << 24, A < 128) || (A = w[v.pos++], S |= (1 & A) << 31, A < 128)) return cc(m, S, _);
              throw new Error("Expected varint not more than 10 bytes")
            })(o, t, this)))))
          }
          readVarint64() {
            return this.readVarint(!0)
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2
          }
          readBoolean() {
            return !!this.readVarint()
          }
          readString() {
            const t = this.readVarint() + this.pos,
              r = this.pos;
            return this.pos = t, t - r >= 12 && mg ? mg.decode(this.buf.subarray(r, t)) : (function(o, c, m) {
              let _ = "",
                v = c;
              for (; v < m;) {
                const w = o[v];
                let S, A, L, j = null,
                  q = w > 239 ? 4 : w > 223 ? 3 : w > 191 ? 2 : 1;
                if (v + q > m) break;
                q === 1 ? w < 128 && (j = w) : q === 2 ? (S = o[v + 1], (192 & S) == 128 && (j = (31 & w) << 6 | 63 & S, j <= 127 && (j = null))) : q === 3 ? (S = o[v + 1], A = o[v + 2], (192 & S) == 128 && (192 & A) == 128 && (j = (15 & w) << 12 | (63 & S) << 6 | 63 & A, (j <= 2047 || j >= 55296 && j <= 57343) && (j = null))) : q === 4 && (S = o[v + 1], A = o[v + 2], L = o[v + 3], (192 & S) == 128 && (192 & A) == 128 && (192 & L) == 128 && (j = (15 & w) << 18 | (63 & S) << 12 | (63 & A) << 6 | 63 & L, (j <= 65535 || j >= 1114112) && (j = null))), j === null ? (j = 65533, q = 1) : j > 65535 && (j -= 65536, _ += String.fromCharCode(j >>> 10 & 1023 | 55296), j = 56320 | 1023 & j), _ += String.fromCharCode(j), v += q
              }
              return _
            })(this.buf, r, t)
          }
          readBytes() {
            const t = this.readVarint() + this.pos,
              r = this.buf.subarray(this.pos, t);
            return this.pos = t, r
          }
          readPackedVarint(t = [], r) {
            const o = this.readPackedEnd();
            for (; this.pos < o;) t.push(this.readVarint(r));
            return t
          }
          readPackedSVarint(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSVarint());
            return t
          }
          readPackedBoolean(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readBoolean());
            return t
          }
          readPackedFloat(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFloat());
            return t
          }
          readPackedDouble(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readDouble());
            return t
          }
          readPackedFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed32());
            return t
          }
          readPackedSFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed32());
            return t
          }
          readPackedFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed64());
            return t
          }
          readPackedSFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed64());
            return t
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1
          }
          skip(t) {
            const r = 7 & t;
            if (r === 0)
              for (; this.buf[this.pos++] > 127;);
            else if (r === 2) this.pos = this.readVarint() + this.pos;
            else if (r === 5) this.pos += 4;
            else {
              if (r !== 1) throw new Error(`Unimplemented type: ${r}`);
              this.pos += 8
            }
          }
          writeTag(t, r) {
            this.writeVarint(t << 3 | r)
          }
          realloc(t) {
            let r = this.length || 16;
            for (; r < this.pos + t;) r *= 2;
            if (r !== this.length) {
              const o = new Uint8Array(r);
              o.set(this.buf), this.buf = o, this.dataView = new DataView(o.buffer), this.length = r
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * fg), !0), this.pos += 8
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * fg), !0), this.pos += 8
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(r, o) {
              let c, m;
              if (r >= 0 ? (c = r % 4294967296 | 0, m = r / 4294967296 | 0) : (c = ~(-r % 4294967296), m = ~(-r / 4294967296), 4294967295 ^ c ? c = c + 1 | 0 : (c = 0, m = m + 1 | 0)), r >= 18446744073709552e3 || r < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              o.realloc(10), (function(_, v, w) {
                w.buf[w.pos++] = 127 & _ | 128, _ >>>= 7, w.buf[w.pos++] = 127 & _ | 128, _ >>>= 7, w.buf[w.pos++] = 127 & _ | 128, _ >>>= 7, w.buf[w.pos++] = 127 & _ | 128, w.buf[w.pos] = 127 & (_ >>>= 7)
              })(c, 0, o), (function(_, v) {
                const w = (7 & _) << 4;
                v.buf[v.pos++] |= w | ((_ >>>= 3) ? 128 : 0), _ && (v.buf[v.pos++] = 127 & _ | ((_ >>>= 7) ? 128 : 0), _ && (v.buf[v.pos++] = 127 & _ | ((_ >>>= 7) ? 128 : 0), _ && (v.buf[v.pos++] = 127 & _ | ((_ >>>= 7) ? 128 : 0), _ && (v.buf[v.pos++] = 127 & _ | ((_ >>>= 7) ? 128 : 0), _ && (v.buf[v.pos++] = 127 & _)))))
              })(m, o)
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))))
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t)
          }
          writeBoolean(t) {
            this.writeVarint(+t)
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const r = this.pos;
            this.pos = (function(c, m, _) {
              for (let v, w, S = 0; S < m.length; S++) {
                if (v = m.charCodeAt(S), v > 55295 && v < 57344) {
                  if (!w) {
                    v > 56319 || S + 1 === m.length ? (c[_++] = 239, c[_++] = 191, c[_++] = 189) : w = v;
                    continue
                  }
                  if (v < 56320) {
                    c[_++] = 239, c[_++] = 191, c[_++] = 189, w = v;
                    continue
                  }
                  v = w - 55296 << 10 | v - 56320 | 65536, w = null
                } else w && (c[_++] = 239, c[_++] = 191, c[_++] = 189, w = null);
                v < 128 ? c[_++] = v : (v < 2048 ? c[_++] = v >> 6 | 192 : (v < 65536 ? c[_++] = v >> 12 | 224 : (c[_++] = v >> 18 | 240, c[_++] = v >> 12 & 63 | 128), c[_++] = v >> 6 & 63 | 128), c[_++] = 63 & v | 128)
              }
              return _
            })(this.buf, t, this.pos);
            const o = this.pos - r;
            o >= 128 && _g(r, o, this), this.pos = r - 1, this.writeVarint(o), this.pos += o
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8
          }
          writeBytes(t) {
            const r = t.length;
            this.writeVarint(r), this.realloc(r);
            for (let o = 0; o < r; o++) this.buf[this.pos++] = t[o]
          }
          writeRawMessage(t, r) {
            this.pos++;
            const o = this.pos;
            t(r, this);
            const c = this.pos - o;
            c >= 128 && _g(o, c, this), this.pos = o - 1, this.writeVarint(c), this.pos += c
          }
          writeMessage(t, r, o) {
            this.writeTag(t, 2), this.writeRawMessage(r, o)
          }
          writePackedVarint(t, r) {
            r.length && this.writeMessage(t, C1, r)
          }
          writePackedSVarint(t, r) {
            r.length && this.writeMessage(t, T1, r)
          }
          writePackedBoolean(t, r) {
            r.length && this.writeMessage(t, P1, r)
          }
          writePackedFloat(t, r) {
            r.length && this.writeMessage(t, S1, r)
          }
          writePackedDouble(t, r) {
            r.length && this.writeMessage(t, I1, r)
          }
          writePackedFixed32(t, r) {
            r.length && this.writeMessage(t, k1, r)
          }
          writePackedSFixed32(t, r) {
            r.length && this.writeMessage(t, M1, r)
          }
          writePackedFixed64(t, r) {
            r.length && this.writeMessage(t, A1, r)
          }
          writePackedSFixed64(t, r) {
            r.length && this.writeMessage(t, E1, r)
          }
          writeBytesField(t, r) {
            this.writeTag(t, 2), this.writeBytes(r)
          }
          writeFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeFixed32(r)
          }
          writeSFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeSFixed32(r)
          }
          writeFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeFixed64(r)
          }
          writeSFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeSFixed64(r)
          }
          writeVarintField(t, r) {
            this.writeTag(t, 0), this.writeVarint(r)
          }
          writeSVarintField(t, r) {
            this.writeTag(t, 0), this.writeSVarint(r)
          }
          writeStringField(t, r) {
            this.writeTag(t, 2), this.writeString(r)
          }
          writeFloatField(t, r) {
            this.writeTag(t, 5), this.writeFloat(r)
          }
          writeDoubleField(t, r) {
            this.writeTag(t, 1), this.writeDouble(r)
          }
          writeBooleanField(t, r) {
            this.writeVarintField(t, +r)
          }
        }

        function cc(n, t, r) {
          return r ? 4294967296 * t + (n >>> 0) : 4294967296 * (t >>> 0) + (n >>> 0)
        }

        function _g(n, t, r) {
          const o = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          r.realloc(o);
          for (let c = r.pos - 1; c >= n; c--) r.buf[c + o] = r.buf[c]
        }

        function C1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeVarint(n[r])
        }

        function T1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSVarint(n[r])
        }

        function S1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFloat(n[r])
        }

        function I1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeDouble(n[r])
        }

        function P1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeBoolean(n[r])
        }

        function k1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFixed32(n[r])
        }

        function M1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSFixed32(n[r])
        }

        function A1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFixed64(n[r])
        }

        function E1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSFixed64(n[r])
        }

        function z1(n, t, r) {
          n === 1 && r.readMessage(L1, t)
        }

        function L1(n, t, r) {
          if (n === 3) {
            const {
              id: o,
              bitmap: c,
              width: m,
              height: _,
              left: v,
              top: w,
              advance: S
            } = r.readMessage(D1, {});
            t.push({
              id: o,
              bitmap: new Su({
                width: m + 6,
                height: _ + 6
              }, c),
              metrics: {
                width: m,
                height: _,
                left: v,
                top: w,
                advance: S
              }
            })
          }
        }

        function D1(n, t, r) {
          n === 1 ? t.id = r.readVarint() : n === 2 ? t.bitmap = r.readBytes() : n === 3 ? t.width = r.readVarint() : n === 4 ? t.height = r.readVarint() : n === 5 ? t.left = r.readSVarint() : n === 6 ? t.top = r.readSVarint() : n === 7 && (t.advance = r.readVarint())
        }

        function gg(n) {
          let t = 0,
            r = 0;
          for (const _ of n) t += _.w * _.h, r = Math.max(r, _.w);
          n.sort(((_, v) => v.h - _.h));
          const o = [{
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(t / .95)), r),
            h: 1 / 0
          }];
          let c = 0,
            m = 0;
          for (const _ of n)
            for (let v = o.length - 1; v >= 0; v--) {
              const w = o[v];
              if (!(_.w > w.w || _.h > w.h)) {
                if (_.x = w.x, _.y = w.y, m = Math.max(m, _.y + _.h), c = Math.max(c, _.x + _.w), _.w === w.w && _.h === w.h) {
                  const S = o.pop();
                  S && v < o.length && (o[v] = S)
                } else _.h === w.h ? (w.x += _.w, w.w -= _.w) : _.w === w.w ? (w.y += _.h, w.h -= _.h) : (o.push({
                  x: w.x + _.w,
                  y: w.y,
                  w: w.w - _.w,
                  h: _.h
                }), w.y += _.h, w.h -= _.h);
                break
              }
            }
          return {
            w: c,
            h: m,
            fill: t / (c * m) || 0
          }
        }
        class Pf {
          constructor(t, {
            pixelRatio: r,
            version: o,
            stretchX: c,
            stretchY: m,
            content: _,
            textFitWidth: v,
            textFitHeight: w
          }) {
            this.paddedRect = t, this.pixelRatio = r, this.stretchX = c, this.stretchY = m, this.content = _, this.version = o, this.textFitWidth = v, this.textFitHeight = w
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1]
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
          }
          get tlbr() {
            return this.tl.concat(this.br)
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
          }
        }
        class vg {
          constructor(t, r) {
            const o = {},
              c = {};
            this.haveRenderCallbacks = [];
            const m = [];
            this.addImages(t, o, m), this.addImages(r, c, m);
            const {
              w: _,
              h: v
            } = gg(m), w = new aa({
              width: _ || 1,
              height: v || 1
            });
            for (const S in t) {
              const A = t[S],
                L = o[S].paddedRect;
              aa.copy(A.data, w, {
                x: 0,
                y: 0
              }, {
                x: L.x + 1,
                y: L.y + 1
              }, A.data)
            }
            for (const S in r) {
              const A = r[S],
                L = c[S].paddedRect,
                j = L.x + 1,
                q = L.y + 1,
                $ = A.data.width,
                J = A.data.height;
              aa.copy(A.data, w, {
                x: 0,
                y: 0
              }, {
                x: j,
                y: q
              }, A.data), aa.copy(A.data, w, {
                x: 0,
                y: J - 1
              }, {
                x: j,
                y: q - 1
              }, {
                width: $,
                height: 1
              }), aa.copy(A.data, w, {
                x: 0,
                y: 0
              }, {
                x: j,
                y: q + J
              }, {
                width: $,
                height: 1
              }), aa.copy(A.data, w, {
                x: $ - 1,
                y: 0
              }, {
                x: j - 1,
                y: q
              }, {
                width: 1,
                height: J
              }), aa.copy(A.data, w, {
                x: 0,
                y: 0
              }, {
                x: j + $,
                y: q
              }, {
                width: 1,
                height: J
              })
            }
            this.image = w, this.iconPositions = o, this.patternPositions = c
          }
          addImages(t, r, o) {
            for (const c in t) {
              const m = t[c],
                _ = {
                  x: 0,
                  y: 0,
                  w: m.data.width + 2,
                  h: m.data.height + 2
                };
              o.push(_), r[c] = new Pf(_, m), m.hasRenderCallback && this.haveRenderCallbacks.push(c)
            }
          }
          patchUpdatedImages(t, r) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const o in t.updatedImages) this.patchUpdatedImage(this.iconPositions[o], t.getImage(o), r), this.patchUpdatedImage(this.patternPositions[o], t.getImage(o), r)
          }
          patchUpdatedImage(t, r, o) {
            if (!t || !r || t.version === r.version) return;
            t.version = r.version;
            const [c, m] = t.tl;
            o.update(r.data, void 0, {
              x: c,
              y: m
            })
          }
        }
        var Es;
        hr("ImagePosition", Pf), hr("ImageAtlas", vg), b.ao = void 0, (Es = b.ao || (b.ao = {}))[Es.none = 0] = "none", Es[Es.horizontal = 1] = "horizontal", Es[Es.vertical = 2] = "vertical", Es[Es.horizontalOnly = 3] = "horizontalOnly";
        class Ru {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom"
          }
          static forText(t, r, o) {
            const c = new Ru;
            return c.scale = t || 1, c.fontStack = r, c.verticalAlign = o || "bottom", c
          }
          static forImage(t, r) {
            const o = new Ru;
            return o.imageName = t, o.verticalAlign = r || "bottom", o
          }
        }
        class uc {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
          }
          static fromFeature(t, r) {
            const o = new uc;
            for (let c = 0; c < t.sections.length; c++) {
              const m = t.sections[c];
              m.image ? o.addImageSection(m) : o.addTextSection(m, r)
            }
            return o
          }
          length() {
            return this.text.length
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]]
          }
          getSectionIndex(t) {
            return this.sectionIndex[t]
          }
          getCharCode(t) {
            return this.text.charCodeAt(t)
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let r = "";
              for (let o = 0; o < t.length; o++) {
                const c = t.charCodeAt(o + 1) || null,
                  m = t.charCodeAt(o - 1) || null;
                r += c && Pd(c) && !Du[t[o + 1]] || m && Pd(m) && !Du[t[o - 1]] || !Du[t[o]] ? t[o] : Du[t[o]]
              }
              return r
            })(this.text)
          }
          trim() {
            let t = 0;
            for (let o = 0; o < this.text.length && qd[this.text.charCodeAt(o)]; o++) t++;
            let r = this.text.length;
            for (let o = this.text.length - 1; o >= 0 && o >= t && qd[this.text.charCodeAt(o)]; o--) r--;
            this.text = this.text.substring(t, r), this.sectionIndex = this.sectionIndex.slice(t, r)
          }
          substring(t, r) {
            const o = new uc;
            return o.text = this.text.substring(t, r), o.sectionIndex = this.sectionIndex.slice(t, r), o.sections = this.sections, o
          }
          toString() {
            return this.text
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, r) => Math.max(t, this.sections[r].scale)), 0)
          }
          getMaxImageSize(t) {
            let r = 0,
              o = 0;
            for (let c = 0; c < this.length(); c++) {
              const m = this.getSection(c);
              if (m.imageName) {
                const _ = t[m.imageName];
                if (!_) continue;
                const v = _.displaySize;
                r = Math.max(r, v[0]), o = Math.max(o, v[1])
              }
            }
            return {
              maxImageWidth: r,
              maxImageHeight: o
            }
          }
          addTextSection(t, r) {
            this.text += t.text, this.sections.push(Ru.forText(t.scale, t.fontStack || r, t.verticalAlign));
            const o = this.sections.length - 1;
            for (let c = 0; c < t.text.length; ++c) this.sectionIndex.push(o)
          }
          addImageSection(t) {
            const r = t.image ? t.image.name : "";
            if (r.length === 0) return void Bt("Can't add FormattedSection with an empty image.");
            const o = this.getNextImageSectionCharCode();
            o ? (this.text += String.fromCharCode(o), this.sections.push(Ru.forImage(r, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Bt("Reached maximum number of images 6401")
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
          }
        }

        function Vd(n, t, r, o, c, m, _, v, w, S, A, L, j, q, $) {
          const J = uc.fromFeature(n, c);
          let te;
          L === b.ao.vertical && J.verticalizePunctuation();
          const {
            processBidirectionalText: he,
            processStyledBidirectionalText: je
          } = Ma;
          if (he && J.sections.length === 1) {
            te = [];
            const et = he(J.toString(), kf(J, S, m, t, o, q));
            for (const ct of et) {
              const Et = new uc;
              Et.text = ct, Et.sections = J.sections;
              for (let ar = 0; ar < ct.length; ar++) Et.sectionIndex.push(0);
              te.push(Et)
            }
          } else if (je) {
            te = [];
            const et = je(J.text, J.sectionIndex, kf(J, S, m, t, o, q));
            for (const ct of et) {
              const Et = new uc;
              Et.text = ct[0], Et.sectionIndex = ct[1], Et.sections = J.sections, te.push(Et)
            }
          } else te = (function(et, ct) {
            const Et = [],
              ar = et.text;
            let Jt = 0;
            for (const tr of ct) Et.push(et.substring(Jt, tr)), Jt = tr;
            return Jt < ar.length && Et.push(et.substring(Jt, ar.length)), Et
          })(J, kf(J, S, m, t, o, q));
          const be = [],
            Me = {
              positionedLines: be,
              text: J.toString(),
              top: A[1],
              bottom: A[1],
              left: A[0],
              right: A[0],
              writingMode: L,
              iconsInText: !1,
              verticalizable: !1
            };
          return (function(et, ct, Et, ar, Jt, tr, Rr, Qt, rr, yt, Yr, on) {
            let Zr = 0,
              Cr = 0,
              gn = 0,
              Kn = 0;
            const gi = Qt === "right" ? 1 : Qt === "left" ? 0 : .5,
              ji = bi / on;
            let Da = 0;
            for (const Wn of Jt) {
              Wn.trim();
              const wi = Wn.getMaxScale(),
                Li = {
                  positionedGlyphs: [],
                  lineOffset: 0
                };
              et.positionedLines[Da] = Li;
              const Di = Li.positionedGlyphs;
              let ea = 0;
              if (!Wn.length()) {
                Cr += tr, ++Da;
                continue
              }
              const Ra = O1(ar, Wn, ji);
              for (let sa = 0; sa < Wn.length(); sa++) {
                const vi = Wn.getSection(sa),
                  Ti = Wn.getSectionIndex(sa),
                  Si = Wn.getCharCode(sa),
                  hi = j1(rr, Yr, Si);
                let Nn;
                if (vi.imageName) {
                  if (et.iconsInText = !0, vi.scale = vi.scale * ji, Nn = Z1(vi, hi, wi, Ra, ar), !Nn) continue;
                  ea = Math.max(ea, Nn.imageOffset)
                } else if (Nn = N1(vi, Si, hi, Ra, ct, Et), !Nn) continue;
                const {
                  rect: so,
                  metrics: fc,
                  baselineOffset: lo
                } = Nn;
                Di.push({
                  glyph: Si,
                  imageName: vi.imageName,
                  x: Zr,
                  y: Cr + lo + -17,
                  vertical: hi,
                  scale: vi.scale,
                  fontStack: vi.fontStack,
                  sectionIndex: Ti,
                  metrics: fc,
                  rect: so
                }), hi ? (et.verticalizable = !0, Zr += (vi.imageName ? fc.advance : bi) * vi.scale + yt) : Zr += fc.advance * vi.scale + yt
              }
              Di.length !== 0 && (gn = Math.max(Zr - yt, gn), V1(Di, 0, Di.length - 1, gi)), Zr = 0, Li.lineOffset = Math.max(ea, (wi - 1) * bi);
              const Ci = tr * wi + ea;
              Cr += Ci, Kn = Math.max(Ci, Kn), ++Da
            }
            const {
              horizontalAlign: oa,
              verticalAlign: zi
            } = Mf(Rr);
            (function(Wn, wi, Li, Di, ea, Ra, Ci, sa, vi) {
              const Ti = (wi - Li) * ea;
              let Si = 0;
              Si = Ra !== Ci ? -sa * Di - -17 : -Di * vi * Ci + .5 * Ci;
              for (const hi of Wn)
                for (const Nn of hi.positionedGlyphs) Nn.x += Ti, Nn.y += Si
            })(et.positionedLines, gi, oa, zi, gn, Kn, tr, Cr, Jt.length), et.top += -zi * Cr, et.bottom = et.top + Cr, et.left += -oa * gn, et.right = et.left + gn
          })(Me, t, r, o, te, _, v, w, L, S, j, $), !(function(et) {
            for (const ct of et)
              if (ct.positionedGlyphs.length !== 0) return !1;
            return !0
          })(be) && Me
        }
        const qd = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
          },
          R1 = {
            10: !0,
            32: !0,
            38: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
          },
          B1 = {
            40: !0
          };

        function yg(n, t, r, o, c, m) {
          if (t.imageName) {
            const _ = o[t.imageName];
            return _ ? _.displaySize[0] * t.scale * bi / m + c : 0
          } {
            const _ = r[t.fontStack],
              v = _ && _[n];
            return v ? v.metrics.advance * t.scale + c : 0
          }
        }

        function xg(n, t, r, o) {
          const c = Math.pow(n - t, 2);
          return o ? n < t ? c / 2 : 2 * c : c + Math.abs(r) * r
        }

        function F1(n, t, r) {
          let o = 0;
          return n === 10 && (o -= 1e4), r && (o += 150), n !== 40 && n !== 65288 || (o += 50), t !== 41 && t !== 65289 || (o += 50), o
        }

        function bg(n, t, r, o, c, m) {
          let _ = null,
            v = xg(t, r, c, m);
          for (const w of o) {
            const S = xg(t - w.x, r, c, m) + w.badness;
            S <= v && (_ = w, v = S)
          }
          return {
            index: n,
            x: t,
            priorBreak: _,
            badness: v
          }
        }

        function wg(n) {
          return n ? wg(n.priorBreak).concat(n.index) : []
        }

        function kf(n, t, r, o, c, m) {
          if (!n) return [];
          const _ = [],
            v = (function(L, j, q, $, J, te) {
              let he = 0;
              for (let je = 0; je < L.length(); je++) {
                const be = L.getSection(je);
                he += yg(L.getCharCode(je), be, $, J, j, te)
              }
              return he / Math.max(1, Math.ceil(he / q))
            })(n, t, r, o, c, m),
            w = n.text.indexOf("​") >= 0;
          let S = 0;
          for (let L = 0; L < n.length(); L++) {
            const j = n.getSection(L),
              q = n.getCharCode(L);
            if (qd[q] || (S += yg(q, j, o, c, t, m)), L < n.length() - 1) {
              const $ = !((A = q) < 11904) && (!!_n["CJK Compatibility Forms"](A) || !!_n["CJK Compatibility"](A) || !!_n["CJK Strokes"](A) || !!_n["CJK Symbols and Punctuation"](A) || !!_n["Enclosed CJK Letters and Months"](A) || !!_n["Halfwidth and Fullwidth Forms"](A) || !!_n["Ideographic Description Characters"](A) || !!_n["Vertical Forms"](A) || pu.test(String.fromCodePoint(A)));
              (R1[q] || $ || j.imageName || L !== n.length() - 2 && B1[n.getCharCode(L + 1)]) && _.push(bg(L + 1, S, v, _, F1(q, n.getCharCode(L + 1), $ && w), !1))
            }
          }
          var A;
          return wg(bg(n.length(), S, v, _, 0, !0))
        }

        function Mf(n) {
          let t = .5,
            r = .5;
          switch (n) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0
          }
          switch (n) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r = 0
          }
          return {
            horizontalAlign: t,
            verticalAlign: r
          }
        }

        function O1(n, t, r) {
          const o = t.getMaxScale() * bi,
            {
              maxImageWidth: c,
              maxImageHeight: m
            } = t.getMaxImageSize(n),
            _ = Math.max(o, m * r);
          return {
            verticalLineContentWidth: Math.max(o, c * r),
            horizontalLineContentHeight: _
          }
        }

        function Cg(n) {
          switch (n) {
            case "top":
              return 0;
            case "center":
              return .5;
            default:
              return 1
          }
        }

        function j1(n, t, r) {
          return !(n === b.ao.horizontal || !t && !fu(r) || t && (qd[r] || (o = r, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(o)))));
          var o
        }

        function N1(n, t, r, o, c, m) {
          const _ = m[n.fontStack],
            v = (function(S, A, L, j) {
              if (S && S.rect) return S;
              const q = A[L.fontStack],
                $ = q && q[j];
              return $ ? {
                rect: null,
                metrics: $.metrics
              } : null
            })(_ && _[t], c, n, t);
          if (v === null) return null;
          let w;
          if (r) w = o.verticalLineContentWidth - n.scale * bi;
          else {
            const S = Cg(n.verticalAlign);
            w = (o.horizontalLineContentHeight - n.scale * bi) * S
          }
          return {
            rect: v.rect,
            metrics: v.metrics,
            baselineOffset: w
          }
        }

        function Z1(n, t, r, o, c) {
          const m = c[n.imageName];
          if (!m) return null;
          const _ = m.paddedRect,
            v = m.displaySize,
            w = {
              width: v[0],
              height: v[1],
              left: 1,
              top: -3,
              advance: t ? v[1] : v[0]
            };
          let S;
          if (t) S = o.verticalLineContentWidth - v[1] * n.scale;
          else {
            const A = Cg(n.verticalAlign);
            S = (o.horizontalLineContentHeight - v[1] * n.scale) * A
          }
          return {
            rect: _,
            metrics: w,
            baselineOffset: S,
            imageOffset: (t ? v[0] : v[1]) * n.scale - bi * r
          }
        }

        function V1(n, t, r, o) {
          if (o === 0) return;
          const c = n[r],
            m = (n[r].x + c.metrics.advance * c.scale) * o;
          for (let _ = t; _ <= r; _++) n[_].x -= m
        }

        function q1(n, t, r) {
          const {
            horizontalAlign: o,
            verticalAlign: c
          } = Mf(r), m = t[0] - n.displaySize[0] * o, _ = t[1] - n.displaySize[1] * c;
          return {
            image: n,
            top: _,
            bottom: _ + n.displaySize[1],
            left: m,
            right: m + n.displaySize[0]
          }
        }

        function Tg(n) {
          var t, r;
          let o = n.left,
            c = n.top,
            m = n.right - o,
            _ = n.bottom - c;
          const v = (t = n.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink",
            w = (r = n.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink",
            S = (n.image.content[2] - n.image.content[0]) / (n.image.content[3] - n.image.content[1]);
          if (w === "proportional") {
            if (v === "stretchOnly" && m / _ < S || v === "proportional") {
              const A = Math.ceil(_ * S);
              o *= A / m, m = A
            }
          } else if (v === "proportional" && w === "stretchOnly" && S !== 0 && m / _ > S) {
            const A = Math.ceil(m / S);
            c *= A / _, _ = A
          }
          return {
            x1: o,
            y1: c,
            x2: o + m,
            y2: c + _
          }
        }

        function Sg(n, t, r, o, c, m) {
          const _ = n.image;
          let v;
          if (_.content) {
            const te = _.content,
              he = _.pixelRatio || 1;
            v = [te[0] / he, te[1] / he, _.displaySize[0] - te[2] / he, _.displaySize[1] - te[3] / he]
          }
          const w = t.left * m,
            S = t.right * m;
          let A, L, j, q;
          r === "width" || r === "both" ? (q = c[0] + w - o[3], L = c[0] + S + o[1]) : (q = c[0] + (w + S - _.displaySize[0]) / 2, L = q + _.displaySize[0]);
          const $ = t.top * m,
            J = t.bottom * m;
          return r === "height" || r === "both" ? (A = c[1] + $ - o[0], j = c[1] + J + o[2]) : (A = c[1] + ($ + J - _.displaySize[1]) / 2, j = A + _.displaySize[1]), {
            image: _,
            top: A,
            right: L,
            bottom: j,
            left: q,
            collisionPadding: v
          }
        }
        const Qo = 128,
          zs = 32640;

        function Ig(n, t) {
          const {
            expression: r
          } = t;
          if (r.kind === "constant") return {
            kind: "constant",
            layoutSize: r.evaluate(new Un(n + 1))
          };
          if (r.kind === "source") return {
            kind: "source"
          };
          {
            const {
              zoomStops: o,
              interpolationType: c
            } = r;
            let m = 0;
            for (; m < o.length && o[m] <= n;) m++;
            m = Math.max(0, m - 1);
            let _ = m;
            for (; _ < o.length && o[_] < n + 1;) _++;
            _ = Math.min(o.length - 1, _);
            const v = o[m],
              w = o[_];
            return r.kind === "composite" ? {
              kind: "composite",
              minZoom: v,
              maxZoom: w,
              interpolationType: c
            } : {
              kind: "camera",
              minZoom: v,
              maxZoom: w,
              minSize: r.evaluate(new Un(v)),
              maxSize: r.evaluate(new Un(w)),
              interpolationType: c
            }
          }
        }

        function Af(n, t, r) {
          let o = "never";
          const c = n.get(t);
          return c ? o = c : n.get(r) && (o = "always"), o
        }
        const U1 = [{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint8",
          offset: 0
        }];

        function Ud(n, t, r, o, c, m, _, v, w, S, A, L, j) {
          const q = v ? Math.min(zs, Math.round(v[0])) : 0,
            $ = v ? Math.min(zs, Math.round(v[1])) : 0;
          n.emplaceBack(t, r, Math.round(32 * o), Math.round(32 * c), m, _, (q << 1) + (w ? 1 : 0), $, 16 * S, 16 * A, 256 * L, 256 * j)
        }

        function Ef(n, t, r) {
          n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r)
        }

        function $1(n) {
          for (const t of n.sections)
            if (Ad(t.text)) return !0;
          return !1
        }
        class zf {
          constructor(t) {
            this.layoutVertexArray = new Xt, this.indexArray = new kn, this.programConfigurations = t, this.segments = new un, this.dynamicLayoutVertexArray = new kt, this.opacityVertexArray = new wr, this.hasVisibleVertices = !1, this.placedSymbolArray = new H
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
          }
          upload(t, r, o, c) {
            this.isEmpty() || (o && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, v1.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, y1.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, U1, !0), this.opacityVertexBuffer.itemSize = 1), (o || c) && this.programConfigurations.upload(t))
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy())
          }
        }
        hr("SymbolBuffers", zf);
        class Lf {
          constructor(t, r, o) {
            this.layoutVertexArray = new t, this.layoutAttributes = r, this.indexArray = new o, this.segments = new un, this.collisionVertexArray = new Tn
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, x1.members, !0)
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy())
          }
        }
        hr("CollisionBuffers", Lf);
        class hc {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((_ => _.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const r = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Ig(this.zoom, r["text-size"]), this.iconSizeData = Ig(this.zoom, r["icon-size"]);
            const o = this.layers[0].layout,
              c = o.get("symbol-sort-key"),
              m = o.get("symbol-z-order");
            this.canOverlap = Af(o, "text-overlap", "text-allow-overlap") !== "never" || Af(o, "icon-overlap", "icon-allow-overlap") !== "never" || o.get("text-ignore-placement") || o.get("icon-ignore-placement"), this.sortFeaturesByKey = m !== "viewport-y" && !c.isConstant(), this.sortFeaturesByY = (m === "viewport-y" || m === "auto" && !this.sortFeaturesByKey) && this.canOverlap, o.get("symbol-placement") === "point" && (this.writingModes = o.get("text-writing-mode").map((_ => b.ao[_]))), this.stateDependentLayerIds = this.layers.filter((_ => _.isStateDependent())).map((_ => _.id)), this.sourceID = t.sourceID
          }
          createArrays() {
            this.text = new zf(new ia(this.layers, this.zoom, (t => /^text/.test(t)))), this.icon = new zf(new ia(this.layers, this.zoom, (t => /^icon/.test(t)))), this.glyphOffsetArray = new se, this.lineVertexArray = new pe, this.symbolInstances = new ne, this.textAnchorOffsets = new ge
          }
          calculateGlyphDependencies(t, r, o, c, m) {
            for (let _ = 0; _ < t.length; _++)
              if (r[t.charCodeAt(_)] = !0, (o || c) && m) {
                const v = Du[t.charAt(_)];
                v && (r[v.charCodeAt(0)] = !0)
              }
          }
          populate(t, r, o) {
            const c = this.layers[0],
              m = c.layout,
              _ = m.get("text-font"),
              v = m.get("text-field"),
              w = m.get("icon-image"),
              S = (v.value.kind !== "constant" || v.value.value instanceof rn && !v.value.value.isEmpty() || v.value.value.toString().length > 0) && (_.value.kind !== "constant" || _.value.value.length > 0),
              A = w.value.kind !== "constant" || !!w.value.value || Object.keys(w.parameters).length > 0,
              L = m.get("symbol-sort-key");
            if (this.features = [], !S && !A) return;
            const j = r.iconDependencies,
              q = r.glyphDependencies,
              $ = r.availableImages,
              J = new Un(this.zoom, {
                globalState: this.globalState
              });
            for (const {
                feature: te,
                id: he,
                index: je,
                sourceLayerIndex: be
              }
              of t) {
              const Me = c._featureFilter.needGeometry,
                et = oo(te, Me);
              if (!c._featureFilter.filter(J, et, o)) continue;
              let ct, Et;
              if (Me || (et.geometry = Po(te)), S) {
                const Jt = c.getValueAndResolveTokens("text-field", et, o, $),
                  tr = rn.factory(Jt),
                  Rr = this.hasRTLText = this.hasRTLText || $1(tr);
                (!Rr || Ma.getRTLTextPluginStatus() === "unavailable" || Rr && Ma.isParsed()) && (ct = w1(tr, c, et))
              }
              if (A) {
                const Jt = c.getValueAndResolveTokens("icon-image", et, o, $);
                Et = Jt instanceof xn ? Jt : xn.fromString(Jt)
              }
              if (!ct && !Et) continue;
              const ar = this.sortFeaturesByKey ? L.evaluate(et, {}, o) : void 0;
              if (this.features.push({
                  id: he,
                  text: ct,
                  icon: Et,
                  index: je,
                  sourceLayerIndex: be,
                  geometry: et.geometry,
                  properties: te.properties,
                  type: lc.types[te.type],
                  sortKey: ar
                }), Et && (j[Et.name] = !0), ct) {
                const Jt = _.evaluate(et, {}, o).join(","),
                  tr = m.get("text-rotation-alignment") !== "viewport" && m.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(b.ao.vertical) >= 0;
                for (const Rr of ct.sections)
                  if (Rr.image) j[Rr.image.name] = !0;
                  else {
                    const Qt = Hl(ct.toString()),
                      rr = Rr.fontStack || Jt,
                      yt = q[rr] = q[rr] || {};
                    this.calculateGlyphDependencies(Rr.text, yt, tr, this.allowVerticalPlacement, Qt)
                  }
              }
            }
            m.get("symbol-placement") === "line" && (this.features = (function(te) {
              const he = {},
                je = {},
                be = [];
              let Me = 0;

              function et(Jt) {
                be.push(te[Jt]), Me++
              }

              function ct(Jt, tr, Rr) {
                const Qt = je[Jt];
                return delete je[Jt], je[tr] = Qt, be[Qt].geometry[0].pop(), be[Qt].geometry[0] = be[Qt].geometry[0].concat(Rr[0]), Qt
              }

              function Et(Jt, tr, Rr) {
                const Qt = he[tr];
                return delete he[tr], he[Jt] = Qt, be[Qt].geometry[0].shift(), be[Qt].geometry[0] = Rr[0].concat(be[Qt].geometry[0]), Qt
              }

              function ar(Jt, tr, Rr) {
                const Qt = Rr ? tr[0][tr[0].length - 1] : tr[0][0];
                return `${Jt}:${Qt.x}:${Qt.y}`
              }
              for (let Jt = 0; Jt < te.length; Jt++) {
                const tr = te[Jt],
                  Rr = tr.geometry,
                  Qt = tr.text ? tr.text.toString() : null;
                if (!Qt) {
                  et(Jt);
                  continue
                }
                const rr = ar(Qt, Rr),
                  yt = ar(Qt, Rr, !0);
                if (rr in je && yt in he && je[rr] !== he[yt]) {
                  const Yr = Et(rr, yt, Rr),
                    on = ct(rr, yt, be[Yr].geometry);
                  delete he[rr], delete je[yt], je[ar(Qt, be[on].geometry, !0)] = on, be[Yr].geometry = null
                } else rr in je ? ct(rr, yt, Rr) : yt in he ? Et(rr, yt, Rr) : (et(Jt), he[rr] = Me - 1, je[yt] = Me - 1)
              }
              return be.filter((Jt => Jt.geometry))
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((te, he) => te.sortKey - he.sortKey))
          }
          update(t, r, o) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, r, this.layers, o), this.icon.programConfigurations.updatePaintArrays(t, r, this.layers, o))
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
          }
          addToLineVertexArray(t, r) {
            const o = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let c = t.dist(r[t.segment + 1]),
                m = t.dist(r[t.segment]);
              const _ = {};
              for (let v = t.segment + 1; v < r.length; v++) _[v] = {
                x: r[v].x,
                y: r[v].y,
                tileUnitDistanceFromAnchor: c
              }, v < r.length - 1 && (c += r[v + 1].dist(r[v]));
              for (let v = t.segment || 0; v >= 0; v--) _[v] = {
                x: r[v].x,
                y: r[v].y,
                tileUnitDistanceFromAnchor: m
              }, v > 0 && (m += r[v - 1].dist(r[v]));
              for (let v = 0; v < r.length; v++) {
                const w = _[v];
                this.lineVertexArray.emplaceBack(w.x, w.y, w.tileUnitDistanceFromAnchor)
              }
            }
            return {
              lineStartIndex: o,
              lineLength: this.lineVertexArray.length - o
            }
          }
          addSymbols(t, r, o, c, m, _, v, w, S, A, L, j) {
            const q = t.indexArray,
              $ = t.layoutVertexArray,
              J = t.segments.prepareSegment(4 * r.length, $, q, this.canOverlap ? _.sortKey : void 0),
              te = this.glyphOffsetArray.length,
              he = J.vertexLength,
              je = this.allowVerticalPlacement && v === b.ao.vertical ? Math.PI / 2 : 0,
              be = _.text && _.text.sections;
            for (let Me = 0; Me < r.length; Me++) {
              const {
                tl: et,
                tr: ct,
                bl: Et,
                br: ar,
                tex: Jt,
                pixelOffsetTL: tr,
                pixelOffsetBR: Rr,
                minFontScaleX: Qt,
                minFontScaleY: rr,
                glyphOffset: yt,
                isSDF: Yr,
                sectionIndex: on
              } = r[Me], Zr = J.vertexLength, Cr = yt[1];
              Ud($, w.x, w.y, et.x, Cr + et.y, Jt.x, Jt.y, o, Yr, tr.x, tr.y, Qt, rr), Ud($, w.x, w.y, ct.x, Cr + ct.y, Jt.x + Jt.w, Jt.y, o, Yr, Rr.x, tr.y, Qt, rr), Ud($, w.x, w.y, Et.x, Cr + Et.y, Jt.x, Jt.y + Jt.h, o, Yr, tr.x, Rr.y, Qt, rr), Ud($, w.x, w.y, ar.x, Cr + ar.y, Jt.x + Jt.w, Jt.y + Jt.h, o, Yr, Rr.x, Rr.y, Qt, rr), Ef(t.dynamicLayoutVertexArray, w, je), q.emplaceBack(Zr, Zr + 2, Zr + 1), q.emplaceBack(Zr + 1, Zr + 2, Zr + 3), J.vertexLength += 4, J.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(yt[0]), Me !== r.length - 1 && on === r[Me + 1].sectionIndex || t.programConfigurations.populatePaintArrays($.length, _, _.index, {}, j, be && be[on])
            }
            t.placedSymbolArray.emplaceBack(w.x, w.y, te, this.glyphOffsetArray.length - te, he, S, A, w.segment, o ? o[0] : 0, o ? o[1] : 0, c[0], c[1], v, 0, !1, 0, L)
          }
          _addCollisionDebugVertex(t, r, o, c, m, _) {
            return r.emplaceBack(0, 0), t.emplaceBack(o.x, o.y, c, m, Math.round(_.x), Math.round(_.y))
          }
          addCollisionDebugVertices(t, r, o, c, m, _, v) {
            const w = m.segments.prepareSegment(4, m.layoutVertexArray, m.indexArray),
              S = w.vertexLength,
              A = m.layoutVertexArray,
              L = m.collisionVertexArray,
              j = v.anchorX,
              q = v.anchorY;
            this._addCollisionDebugVertex(A, L, _, j, q, new F(t, r)), this._addCollisionDebugVertex(A, L, _, j, q, new F(o, r)), this._addCollisionDebugVertex(A, L, _, j, q, new F(o, c)), this._addCollisionDebugVertex(A, L, _, j, q, new F(t, c)), w.vertexLength += 4;
            const $ = m.indexArray;
            $.emplaceBack(S, S + 1), $.emplaceBack(S + 1, S + 2), $.emplaceBack(S + 2, S + 3), $.emplaceBack(S + 3, S), w.primitiveLength += 4
          }
          addDebugCollisionBoxes(t, r, o, c) {
            for (let m = t; m < r; m++) {
              const _ = this.collisionBoxArray.get(m);
              this.addCollisionDebugVertices(_.x1, _.y1, _.x2, _.y2, c ? this.textCollisionBox : this.iconCollisionBox, _.anchorPoint, o)
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Lf(dn, pg.members, Sn), this.iconCollisionBox = new Lf(dn, pg.members, Sn);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const r = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, !1), this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, !1)
            }
          }
          _deserializeCollisionBoxesForSymbol(t, r, o, c, m, _, v, w, S) {
            const A = {};
            for (let L = r; L < o; L++) {
              const j = t.get(L);
              A.textBox = {
                x1: j.x1,
                y1: j.y1,
                x2: j.x2,
                y2: j.y2,
                anchorPointX: j.anchorPointX,
                anchorPointY: j.anchorPointY
              }, A.textFeatureIndex = j.featureIndex;
              break
            }
            for (let L = c; L < m; L++) {
              const j = t.get(L);
              A.verticalTextBox = {
                x1: j.x1,
                y1: j.y1,
                x2: j.x2,
                y2: j.y2,
                anchorPointX: j.anchorPointX,
                anchorPointY: j.anchorPointY
              }, A.verticalTextFeatureIndex = j.featureIndex;
              break
            }
            for (let L = _; L < v; L++) {
              const j = t.get(L);
              A.iconBox = {
                x1: j.x1,
                y1: j.y1,
                x2: j.x2,
                y2: j.y2,
                anchorPointX: j.anchorPointX,
                anchorPointY: j.anchorPointY
              }, A.iconFeatureIndex = j.featureIndex;
              break
            }
            for (let L = w; L < S; L++) {
              const j = t.get(L);
              A.verticalIconBox = {
                x1: j.x1,
                y1: j.y1,
                x2: j.x2,
                y2: j.y2,
                anchorPointX: j.anchorPointX,
                anchorPointY: j.anchorPointY
              }, A.verticalIconFeatureIndex = j.featureIndex;
              break
            }
            return A
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let r = 0; r < this.symbolInstances.length; r++) {
              const o = this.symbolInstances.get(r);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, o.textBoxStartIndex, o.textBoxEndIndex, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o.iconBoxStartIndex, o.iconBoxEndIndex, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex))
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0
          }
          hasIconData() {
            return this.icon.segments.get().length > 0
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
          }
          addIndicesForPlacedSymbol(t, r) {
            const o = t.placedSymbolArray.get(r),
              c = o.vertexStartIndex + 4 * o.numGlyphs;
            for (let m = o.vertexStartIndex; m < c; m += 4) t.indexArray.emplaceBack(m, m + 2, m + 1), t.indexArray.emplaceBack(m + 1, m + 2, m + 3)
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const r = Math.sin(t),
              o = Math.cos(t),
              c = [],
              m = [],
              _ = [];
            for (let v = 0; v < this.symbolInstances.length; ++v) {
              _.push(v);
              const w = this.symbolInstances.get(v);
              c.push(0 | Math.round(r * w.anchorX + o * w.anchorY)), m.push(w.featureIndex)
            }
            return _.sort(((v, w) => c[v] - c[w] || m[w] - m[v])), _
          }
          addToSortKeyRanges(t, r) {
            const o = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            o && o.sortKey === r ? o.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
              sortKey: r,
              symbolInstanceStart: t,
              symbolInstanceEnd: t + 1
            })
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const r of this.symbolInstanceIndexes) {
                const o = this.symbolInstances.get(r);
                this.featureSortOrder.push(o.featureIndex), [o.rightJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.leftJustifiedTextSymbolIndex].forEach(((c, m, _) => {
                  c >= 0 && _.indexOf(c) === m && this.addIndicesForPlacedSymbol(this.text, c)
                })), o.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, o.verticalPlacedTextSymbolIndex), o.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, o.placedIconSymbolIndex), o.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, o.verticalPlacedIconSymbolIndex)
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
            }
          }
        }
        let Pg, kg;
        hr("SymbolBucket", hc, {
          omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }), hc.MAX_GLYPHS = 65535, hc.addDynamicAttributes = Ef;
        var Df = {
          get paint() {
            return kg = kg || new Wi({
              "icon-opacity": new Gr(we.paint_symbol["icon-opacity"]),
              "icon-color": new Gr(we.paint_symbol["icon-color"]),
              "icon-halo-color": new Gr(we.paint_symbol["icon-halo-color"]),
              "icon-halo-width": new Gr(we.paint_symbol["icon-halo-width"]),
              "icon-halo-blur": new Gr(we.paint_symbol["icon-halo-blur"]),
              "icon-translate": new Mr(we.paint_symbol["icon-translate"]),
              "icon-translate-anchor": new Mr(we.paint_symbol["icon-translate-anchor"]),
              "text-opacity": new Gr(we.paint_symbol["text-opacity"]),
              "text-color": new Gr(we.paint_symbol["text-color"], {
                runtimeType: xt,
                getOverride: n => n.textColor,
                hasOverride: n => !!n.textColor
              }),
              "text-halo-color": new Gr(we.paint_symbol["text-halo-color"]),
              "text-halo-width": new Gr(we.paint_symbol["text-halo-width"]),
              "text-halo-blur": new Gr(we.paint_symbol["text-halo-blur"]),
              "text-translate": new Mr(we.paint_symbol["text-translate"]),
              "text-translate-anchor": new Mr(we.paint_symbol["text-translate-anchor"])
            })
          },
          get layout() {
            return Pg = Pg || new Wi({
              "symbol-placement": new Mr(we.layout_symbol["symbol-placement"]),
              "symbol-spacing": new Mr(we.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new Mr(we.layout_symbol["symbol-avoid-edges"]),
              "symbol-sort-key": new Gr(we.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new Mr(we.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new Mr(we.layout_symbol["icon-allow-overlap"]),
              "icon-overlap": new Mr(we.layout_symbol["icon-overlap"]),
              "icon-ignore-placement": new Mr(we.layout_symbol["icon-ignore-placement"]),
              "icon-optional": new Mr(we.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new Mr(we.layout_symbol["icon-rotation-alignment"]),
              "icon-size": new Gr(we.layout_symbol["icon-size"]),
              "icon-text-fit": new Mr(we.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new Mr(we.layout_symbol["icon-text-fit-padding"]),
              "icon-image": new Gr(we.layout_symbol["icon-image"]),
              "icon-rotate": new Gr(we.layout_symbol["icon-rotate"]),
              "icon-padding": new Gr(we.layout_symbol["icon-padding"]),
              "icon-keep-upright": new Mr(we.layout_symbol["icon-keep-upright"]),
              "icon-offset": new Gr(we.layout_symbol["icon-offset"]),
              "icon-anchor": new Gr(we.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new Mr(we.layout_symbol["icon-pitch-alignment"]),
              "text-pitch-alignment": new Mr(we.layout_symbol["text-pitch-alignment"]),
              "text-rotation-alignment": new Mr(we.layout_symbol["text-rotation-alignment"]),
              "text-field": new Gr(we.layout_symbol["text-field"]),
              "text-font": new Gr(we.layout_symbol["text-font"]),
              "text-size": new Gr(we.layout_symbol["text-size"]),
              "text-max-width": new Gr(we.layout_symbol["text-max-width"]),
              "text-line-height": new Mr(we.layout_symbol["text-line-height"]),
              "text-letter-spacing": new Gr(we.layout_symbol["text-letter-spacing"]),
              "text-justify": new Gr(we.layout_symbol["text-justify"]),
              "text-radial-offset": new Gr(we.layout_symbol["text-radial-offset"]),
              "text-variable-anchor": new Mr(we.layout_symbol["text-variable-anchor"]),
              "text-variable-anchor-offset": new Gr(we.layout_symbol["text-variable-anchor-offset"]),
              "text-anchor": new Gr(we.layout_symbol["text-anchor"]),
              "text-max-angle": new Mr(we.layout_symbol["text-max-angle"]),
              "text-writing-mode": new Mr(we.layout_symbol["text-writing-mode"]),
              "text-rotate": new Gr(we.layout_symbol["text-rotate"]),
              "text-padding": new Mr(we.layout_symbol["text-padding"]),
              "text-keep-upright": new Mr(we.layout_symbol["text-keep-upright"]),
              "text-transform": new Gr(we.layout_symbol["text-transform"]),
              "text-offset": new Gr(we.layout_symbol["text-offset"]),
              "text-allow-overlap": new Mr(we.layout_symbol["text-allow-overlap"]),
              "text-overlap": new Mr(we.layout_symbol["text-overlap"]),
              "text-ignore-placement": new Mr(we.layout_symbol["text-ignore-placement"]),
              "text-optional": new Mr(we.layout_symbol["text-optional"])
            })
          }
        };
        class Mg {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : zt, this.defaultValue = t
          }
          evaluate(t) {
            if (t.formattedSection) {
              const r = this.defaultValue.property.overrides;
              if (r && r.hasOverride(t.formattedSection)) return r.getOverride(t.formattedSection)
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
          }
          outputDefined() {
            return !1
          }
          serialize() {
            return null
          }
        }
        hr("FormatSectionOverride", Mg, {
          omit: ["defaultValue"]
        });
        class $d extends _a {
          constructor(t) {
            super(t, Df)
          }
          recalculate(t, r) {
            if (super.recalculate(t, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const o = this.layout.get("text-writing-mode");
              if (o) {
                const c = [];
                for (const m of o) c.indexOf(m) < 0 && c.push(m);
                this.layout._values["text-writing-mode"] = c
              } else this.layout._values["text-writing-mode"] = ["horizontal"]
            }
            this._setPaintOverrides()
          }
          getValueAndResolveTokens(t, r, o, c) {
            const m = this.layout.get(t).evaluate(r, {}, o, c),
              _ = this._unevaluatedLayout._values[t];
            return _.isDataDriven() || Nl(_.value) || !m ? m : (function(v, w) {
              return w.replace(/{([^{}]+)}/g, ((S, A) => v && A in v ? String(v[A]) : ""))
            })(r.properties, m)
          }
          createBucket(t) {
            return new hc(t)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex")
          }
          _setPaintOverrides() {
            for (const t of Df.paint.overridableProperties) {
              if (!$d.hasPaintOverride(this.layout, t)) continue;
              const r = this.paint.get(t),
                o = new Mg(r),
                c = new tu(o, r.property.specification);
              let m = null;
              m = r.value.kind === "constant" || r.value.kind === "source" ? new el("source", c) : new ru("composite", c, r.value.zoomStops), this.paint._values[t] = new Ga(r.property, m, r.parameters)
            }
          }
          _handleOverridablePaintPropertyUpdate(t, r, o) {
            return !(!this.layout || r.isDataDriven() || o.isDataDriven()) && $d.hasPaintOverride(this.layout, t)
          }
          static hasPaintOverride(t, r) {
            const o = t.get("text-field"),
              c = Df.paint.properties[r];
            let m = !1;
            const _ = v => {
              for (const w of v)
                if (c.overrides && c.overrides.hasOverride(w)) return void(m = !0)
            };
            if (o.value.kind === "constant" && o.value.value instanceof rn) _(o.value.value.sections);
            else if (o.value.kind === "source") {
              const v = S => {
                  m || (S instanceof Vn && mr(S.value) === Qr ? _(S.value.sections) : S instanceof jo ? _(S.sections) : S.eachChild(v))
                },
                w = o.value;
              w._styleExpression && v(w._styleExpression.expression)
            }
            return m
          }
        }
        let Ag;
        var G1 = {
          get paint() {
            return Ag = Ag || new Wi({
              "background-color": new Mr(we.paint_background["background-color"]),
              "background-pattern": new wo(we.paint_background["background-pattern"]),
              "background-opacity": new Mr(we.paint_background["background-opacity"])
            })
          }
        };
        class W1 extends _a {
          constructor(t) {
            super(t, G1)
          }
        }
        let Eg;
        var H1 = {
          get paint() {
            return Eg = Eg || new Wi({
              "raster-opacity": new Mr(we.paint_raster["raster-opacity"]),
              "raster-hue-rotate": new Mr(we.paint_raster["raster-hue-rotate"]),
              "raster-brightness-min": new Mr(we.paint_raster["raster-brightness-min"]),
              "raster-brightness-max": new Mr(we.paint_raster["raster-brightness-max"]),
              "raster-saturation": new Mr(we.paint_raster["raster-saturation"]),
              "raster-contrast": new Mr(we.paint_raster["raster-contrast"]),
              "raster-resampling": new Mr(we.paint_raster["raster-resampling"]),
              "raster-fade-duration": new Mr(we.paint_raster["raster-fade-duration"])
            })
          }
        };
        class J1 extends _a {
          constructor(t) {
            super(t, H1)
          }
        }
        class X1 extends _a {
          constructor(t) {
            super(t, {}), this.onAdd = r => {
              this.implementation.onAdd && this.implementation.onAdd(r, r.painter.context.gl)
            }, this.onRemove = r => {
              this.implementation.onRemove && this.implementation.onRemove(r, r.painter.context.gl)
            }, this.implementation = t
          }
          is3D() {
            return this.implementation.renderingMode === "3d"
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0
          }
          recalculate() {}
          updateTransitions() {}
          hasTransition() {
            return !1
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized")
          }
        }
        class Y1 {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle()
            })
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle()
            }), 0))
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {}
          }
        }
        const K1 = {
            once: !0
          },
          Rf = 63710088e-1;
        class Ls {
          constructor(t, r) {
            if (isNaN(t) || isNaN(r)) throw new Error(`Invalid LngLat object: (${t}, ${r})`);
            if (this.lng = +t, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
          }
          wrap() {
            return new Ls(He(this.lng, -180, 180), this.lat)
          }
          toArray() {
            return [this.lng, this.lat]
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`
          }
          distanceTo(t) {
            const r = Math.PI / 180,
              o = this.lat * r,
              c = t.lat * r,
              m = Math.sin(o) * Math.sin(c) + Math.cos(o) * Math.cos(c) * Math.cos((t.lng - this.lng) * r);
            return Rf * Math.acos(Math.min(m, 1))
          }
          static convert(t) {
            if (t instanceof Ls) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new Ls(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new Ls(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
          }
        }
        const zg = 2 * Math.PI * Rf;

        function Lg(n) {
          return zg * Math.cos(n * Math.PI / 180)
        }

        function Dg(n) {
          return (180 + n) / 360
        }

        function Rg(n) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n * Math.PI / 360))) / 360
        }

        function Bg(n, t) {
          return n / Lg(t)
        }

        function Bf(n) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90
        }

        function Fg(n, t) {
          return n * Lg(Bf(t))
        }
        class Bu {
          constructor(t, r, o = 0) {
            this.x = +t, this.y = +r, this.z = +o
          }
          static fromLngLat(t, r = 0) {
            const o = Ls.convert(t);
            return new Bu(Dg(o.lng), Rg(o.lat), Bg(r, o.lat))
          }
          toLngLat() {
            return new Ls(360 * this.x - 180, Bf(this.y))
          }
          toAltitude() {
            return Fg(this.z, this.y)
          }
          meterInMercatorCoordinateUnits() {
            return 1 / zg * (t = Bf(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t
          }
        }

        function Og(n, t, r) {
          var o = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
          return [n * o - 2 * Math.PI * 6378137 / 2, t * o - 2 * Math.PI * 6378137 / 2]
        }
        class Ff {
          constructor(t, r, o) {
            if (!(function(c, m, _) {
                return !(c < 0 || c > 25 || _ < 0 || _ >= Math.pow(2, c) || m < 0 || m >= Math.pow(2, c))
              })(t, r, o)) throw new Error(`x=${r}, y=${o}, z=${t} outside of bounds. 0<=x<${Math.pow(2,t)}, 0<=y<${Math.pow(2,t)} 0<=z<=25 `);
            this.z = t, this.x = r, this.y = o, this.key = dc(0, t, t, r, o)
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y
          }
          url(t, r, o) {
            const c = (_ = this.y, v = this.z, w = Og(256 * (m = this.x), 256 * (_ = Math.pow(2, v) - _ - 1), v), S = Og(256 * (m + 1), 256 * (_ + 1), v), w[0] + "," + w[1] + "," + S[0] + "," + S[1]);
            var m, _, v, w, S;
            const A = (function(L, j, q) {
              let $, J = "";
              for (let te = L; te > 0; te--) $ = 1 << te - 1, J += (j & $ ? 1 : 0) + (q & $ ? 2 : 0);
              return J
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(o === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, A).replace(/{bbox-epsg-3857}/g, c)
          }
          isChildOf(t) {
            const r = this.z - t.z;
            return r > 0 && t.x === this.x >> r && t.y === this.y >> r
          }
          getTilePoint(t) {
            const r = Math.pow(2, this.z);
            return new F((t.x * r - this.x) * ae, (t.y * r - this.y) * ae)
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`
          }
        }
        class jg {
          constructor(t, r) {
            this.wrap = t, this.canonical = r, this.key = dc(t, r.z, r.z, r.x, r.y)
          }
        }
        class La {
          constructor(t, r, o, c, m) {
            if (this.terrainRttPosMatrix32f = null, t < o) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${o}`);
            this.overscaledZ = t, this.wrap = r, this.canonical = new Ff(o, +c, +m), this.key = dc(r, t, o, c, m)
          }
          clone() {
            return new La(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const r = this.canonical.z - t;
            return t > this.canonical.z ? new La(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new La(t, this.wrap, t, this.canonical.x >> r, this.canonical.y >> r)
          }
          calculateScaledKey(t, r) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const o = this.canonical.z - t;
            return t > this.canonical.z ? dc(this.wrap * +r, t, this.canonical.z, this.canonical.x, this.canonical.y) : dc(this.wrap * +r, t, t, this.canonical.x >> o, this.canonical.y >> o)
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap) return !1;
            const r = this.canonical.z - t.canonical.z;
            return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> r && t.canonical.y === this.canonical.y >> r
          }
          children(t) {
            if (this.overscaledZ >= t) return [new La(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const r = this.canonical.z + 1,
              o = 2 * this.canonical.x,
              c = 2 * this.canonical.y;
            return [new La(r, this.wrap, r, o, c), new La(r, this.wrap, r, o + 1, c), new La(r, this.wrap, r, o, c + 1), new La(r, this.wrap, r, o + 1, c + 1)]
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
          }
          wrapped() {
            return new La(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          unwrapTo(t) {
            return new La(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z)
          }
          toUnwrapped() {
            return new jg(this.wrap, this.canonical)
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new Bu(t.x - this.wrap, t.y))
          }
        }

        function dc(n, t, r, o, c) {
          (n *= 2) < 0 && (n = -1 * n - 1);
          const m = 1 << r;
          return (m * m * n + m * c + o).toString(36) + r.toString(36) + t.toString(36)
        }

        function Fu(n, t) {
          return t ? n.properties[t] : n.id
        }
        hr("CanonicalTileID", Ff), hr("OverscaledTileID", La, {
          omit: ["terrainRttPosMatrix32f"]
        });
        class pl {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this
          }
          shrinkBy(t) {
            return this.expandBy(-t)
          }
          map(t) {
            const r = new pl;
            return r.extend(t(new F(this.minX, this.minY))), r.extend(t(new F(this.maxX, this.minY))), r.extend(t(new F(this.minX, this.maxY))), r.extend(t(new F(this.maxX, this.maxY))), r
          }
          static fromPoints(t) {
            const r = new pl;
            for (const o of t) r.extend(o);
            return r
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY
          }
          empty() {
            return this.minX > this.maxX
          }
          width() {
            return this.maxX - this.minX
          }
          height() {
            return this.maxY - this.minY
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY
          }
        }
        class Ng {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let r = 0; r < t.length; r++) {
              const o = t[r];
              this._stringToNumber[o] = r, this._numberToString[r] = o
            }
          }
          encode(t) {
            return this._stringToNumber[t]
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t]
          }
        }
        class Zg {
          constructor(t, r, o, c, m) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = r, t._x = o, t._y = c, this.properties = t.properties, this.id = m
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry
          }
          set geometry(t) {
            this._geometry = t
          }
          toJSON() {
            const t = {
              geometry: this.geometry
            };
            for (const r in this) r !== "_geometry" && r !== "_vectorTileFeature" && (t[r] = this[r]);
            return t
          }
        }
        class Vg {
          constructor(t, r) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new sl(ae, 16, 0), this.grid3D = new sl(ae, 16, 0), this.featureIndexArray = new Le, this.promoteId = r
          }
          insert(t, r, o, c, m, _) {
            const v = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(o, c, m);
            const w = _ ? this.grid3D : this.grid;
            for (let S = 0; S < r.length; S++) {
              const A = r[S],
                L = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let j = 0; j < A.length; j++) {
                const q = A[j];
                L[0] = Math.min(L[0], q.x), L[1] = Math.min(L[1], q.y), L[2] = Math.max(L[2], q.x), L[3] = Math.max(L[3], q.y)
              }
              L[0] < ae && L[1] < ae && L[2] >= 0 && L[3] >= 0 && w.insert(v, L[0], L[1], L[2], L[3])
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new ig(new If(this.rawTileData)).layers, this.sourceLayerCoder = new Ng(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers
          }
          query(t, r, o, c) {
            this.loadVTLayers();
            const m = t.params,
              _ = ae / t.tileSize / t.scale,
              v = $o(m.filter),
              w = t.queryGeometry,
              S = t.queryPadding * _,
              A = pl.fromPoints(w),
              L = this.grid.query(A.minX - S, A.minY - S, A.maxX + S, A.maxY + S),
              j = pl.fromPoints(t.cameraQueryGeometry).expandBy(S),
              q = this.grid3D.query(j.minX, j.minY, j.maxX, j.maxY, ((te, he, je, be) => (function(Me, et, ct, Et, ar) {
                for (const tr of Me)
                  if (et <= tr.x && ct <= tr.y && Et >= tr.x && ar >= tr.y) return !0;
                const Jt = [new F(et, ct), new F(et, ar), new F(Et, ar), new F(Et, ct)];
                if (Me.length > 2) {
                  for (const tr of Jt)
                    if (ic(Me, tr)) return !0
                }
                for (let tr = 0; tr < Me.length - 1; tr++)
                  if (Ay(Me[tr], Me[tr + 1], Jt)) return !0;
                return !1
              })(t.cameraQueryGeometry, te - S, he - S, je + S, be + S)));
            for (const te of q) L.push(te);
            L.sort(Q1);
            const $ = {};
            let J;
            for (let te = 0; te < L.length; te++) {
              const he = L[te];
              if (he === J) continue;
              J = he;
              const je = this.featureIndexArray.get(he);
              let be = null;
              this.loadMatchingFeature($, je.bucketIndex, je.sourceLayerIndex, je.featureIndex, v, m.layers, m.availableImages, r, o, c, ((Me, et, ct) => (be || (be = Po(Me)), et.queryIntersectsFeature({
                queryGeometry: w,
                feature: Me,
                featureState: ct,
                geometry: be,
                zoom: this.z,
                transform: t.transform,
                pixelsToTileUnits: _,
                pixelPosMatrix: t.pixelPosMatrix,
                unwrappedTileID: this.tileID.toUnwrapped(),
                getElevation: t.getElevation
              }))))
            }
            return $
          }
          loadMatchingFeature(t, r, o, c, m, _, v, w, S, A, L) {
            const j = this.bucketLayerIDs[r];
            if (_ && !j.some((te => _.has(te)))) return;
            const q = this.sourceLayerCoder.decode(o),
              $ = this.vtLayers[q].feature(c);
            if (m.needGeometry) {
              const te = oo($, !0);
              if (!m.filter(new Un(this.tileID.overscaledZ), te, this.tileID.canonical)) return
            } else if (!m.filter(new Un(this.tileID.overscaledZ), $)) return;
            const J = this.getId($, q);
            for (let te = 0; te < j.length; te++) {
              const he = j[te];
              if (_ && !_.has(he)) continue;
              const je = w[he];
              if (!je) continue;
              let be = {};
              J && A && (be = A.getState(je.sourceLayer || "_geojsonTileLayer", J));
              const Me = ut({}, S[he]);
              Me.paint = qg(Me.paint, je.paint, $, be, v), Me.layout = qg(Me.layout, je.layout, $, be, v);
              const et = !L || L($, je, be);
              if (!et) continue;
              const ct = new Zg($, this.z, this.x, this.y, J);
              ct.layer = Me;
              let Et = t[he];
              Et === void 0 && (Et = t[he] = []), Et.push({
                featureIndex: c,
                feature: ct,
                intersectionZ: et
              })
            }
          }
          lookupSymbolFeatures(t, r, o, c, m, _, v, w) {
            const S = {};
            this.loadVTLayers();
            const A = $o(m);
            for (const L of t) this.loadMatchingFeature(S, o, c, L, A, _, v, w, r);
            return S
          }
          hasLayer(t) {
            for (const r of this.bucketLayerIDs)
              for (const o of r)
                if (t === o) return !0;
            return !1
          }
          getId(t, r) {
            var o;
            let c = t.id;
            return this.promoteId && (c = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]], typeof c == "boolean" && (c = Number(c)), c === void 0 && (!((o = t.properties) === null || o === void 0) && o.cluster) && this.promoteId && (c = Number(t.properties.cluster_id))), c
          }
        }

        function qg(n, t, r, o, c) {
          return St(n, ((m, _) => {
            const v = t instanceof Xl ? t.get(_) : null;
            return v && v.evaluate ? v.evaluate(r, o, c) : v
          }))
        }

        function Q1(n, t) {
          return t - n
        }

        function Ug(n, t, r, o, c) {
          const m = [];
          for (let _ = 0; _ < n.length; _++) {
            const v = n[_];
            let w;
            for (let S = 0; S < v.length - 1; S++) {
              let A = v[S],
                L = v[S + 1];
              A.x < t && L.x < t || (A.x < t ? A = new F(t, A.y + (t - A.x) / (L.x - A.x) * (L.y - A.y))._round() : L.x < t && (L = new F(t, A.y + (t - A.x) / (L.x - A.x) * (L.y - A.y))._round()), A.y < r && L.y < r || (A.y < r ? A = new F(A.x + (r - A.y) / (L.y - A.y) * (L.x - A.x), r)._round() : L.y < r && (L = new F(A.x + (r - A.y) / (L.y - A.y) * (L.x - A.x), r)._round()), A.x >= o && L.x >= o || (A.x >= o ? A = new F(o, A.y + (o - A.x) / (L.x - A.x) * (L.y - A.y))._round() : L.x >= o && (L = new F(o, A.y + (o - A.x) / (L.x - A.x) * (L.y - A.y))._round()), A.y >= c && L.y >= c || (A.y >= c ? A = new F(A.x + (c - A.y) / (L.y - A.y) * (L.x - A.x), c)._round() : L.y >= c && (L = new F(A.x + (c - A.y) / (L.y - A.y) * (L.x - A.x), c)._round()), w && A.equals(w[w.length - 1]) || (w = [A], m.push(w)), w.push(L)))))
            }
          }
          return m
        }
        hr("FeatureIndex", Vg, {
          omit: ["rawTileData", "sourceLayerCoder"]
        });
        class Ds extends F {
          constructor(t, r, o, c) {
            super(t, r), this.angle = o, c !== void 0 && (this.segment = c)
          }
          clone() {
            return new Ds(this.x, this.y, this.angle, this.segment)
          }
        }

        function $g(n, t, r, o, c) {
          if (t.segment === void 0 || r === 0) return !0;
          let m = t,
            _ = t.segment + 1,
            v = 0;
          for (; v > -r / 2;) {
            if (_--, _ < 0) return !1;
            v -= n[_].dist(m), m = n[_]
          }
          v += n[_].dist(n[_ + 1]), _++;
          const w = [];
          let S = 0;
          for (; v < r / 2;) {
            const A = n[_],
              L = n[_ + 1];
            if (!L) return !1;
            let j = n[_ - 1].angleTo(A) - A.angleTo(L);
            for (j = Math.abs((j + 3 * Math.PI) % (2 * Math.PI) - Math.PI), w.push({
                distance: v,
                angleDelta: j
              }), S += j; v - w[0].distance > o;) S -= w.shift().angleDelta;
            if (S > c) return !1;
            _++, v += A.dist(L)
          }
          return !0
        }

        function Gg(n) {
          let t = 0;
          for (let r = 0; r < n.length - 1; r++) t += n[r].dist(n[r + 1]);
          return t
        }

        function Wg(n, t, r) {
          return n ? .6 * t * r : 0
        }

        function Hg(n, t) {
          return Math.max(n ? n.right - n.left : 0, t ? t.right - t.left : 0)
        }

        function ex(n, t, r, o, c, m) {
          const _ = Wg(r, c, m),
            v = Hg(r, o) * m;
          let w = 0;
          const S = Gg(n) / 2;
          for (let A = 0; A < n.length - 1; A++) {
            const L = n[A],
              j = n[A + 1],
              q = L.dist(j);
            if (w + q > S) {
              const $ = (S - w) / q,
                J = Ua.number(L.x, j.x, $),
                te = Ua.number(L.y, j.y, $),
                he = new Ds(J, te, j.angleTo(L), A);
              return he._round(), !_ || $g(n, he, v, _, t) ? he : void 0
            }
            w += q
          }
        }

        function tx(n, t, r, o, c, m, _, v, w) {
          const S = Wg(o, m, _),
            A = Hg(o, c),
            L = A * _,
            j = n[0].x === 0 || n[0].x === w || n[0].y === 0 || n[0].y === w;
          return t - L < t / 4 && (t = L + t / 4), Jg(n, j ? t / 2 * v % t : (A / 2 + 2 * m) * _ * v % t, t, S, r, L, j, !1, w)
        }

        function Jg(n, t, r, o, c, m, _, v, w) {
          const S = m / 2,
            A = Gg(n);
          let L = 0,
            j = t - r,
            q = [];
          for (let $ = 0; $ < n.length - 1; $++) {
            const J = n[$],
              te = n[$ + 1],
              he = J.dist(te),
              je = te.angleTo(J);
            for (; j + r < L + he;) {
              j += r;
              const be = (j - L) / he,
                Me = Ua.number(J.x, te.x, be),
                et = Ua.number(J.y, te.y, be);
              if (Me >= 0 && Me < w && et >= 0 && et < w && j - S >= 0 && j + S <= A) {
                const ct = new Ds(Me, et, je, $);
                ct._round(), o && !$g(n, ct, m, o, c) || q.push(ct)
              }
            }
            L += he
          }
          return v || q.length || _ || (q = Jg(n, L / 2, r, o, c, m, _, !0, w)), q
        }

        function Xg(n, t, r, o) {
          const c = [],
            m = n.image,
            _ = m.pixelRatio,
            v = m.paddedRect.w - 2,
            w = m.paddedRect.h - 2;
          let S = {
            x1: n.left,
            y1: n.top,
            x2: n.right,
            y2: n.bottom
          };
          const A = m.stretchX || [
              [0, v]
            ],
            L = m.stretchY || [
              [0, w]
            ],
            j = (yt, Yr) => yt + Yr[1] - Yr[0],
            q = A.reduce(j, 0),
            $ = L.reduce(j, 0),
            J = v - q,
            te = w - $;
          let he = 0,
            je = q,
            be = 0,
            Me = $,
            et = 0,
            ct = J,
            Et = 0,
            ar = te;
          if (m.content && o) {
            const yt = m.content,
              Yr = yt[2] - yt[0],
              on = yt[3] - yt[1];
            (m.textFitWidth || m.textFitHeight) && (S = Tg(n)), he = Gd(A, 0, yt[0]), be = Gd(L, 0, yt[1]), je = Gd(A, yt[0], yt[2]), Me = Gd(L, yt[1], yt[3]), et = yt[0] - he, Et = yt[1] - be, ct = Yr - je, ar = on - Me
          }
          const Jt = S.x1,
            tr = S.y1,
            Rr = S.x2 - Jt,
            Qt = S.y2 - tr,
            rr = (yt, Yr, on, Zr) => {
              const Cr = Wd(yt.stretch - he, je, Rr, Jt),
                gn = Hd(yt.fixed - et, ct, yt.stretch, q),
                Kn = Wd(Yr.stretch - be, Me, Qt, tr),
                gi = Hd(Yr.fixed - Et, ar, Yr.stretch, $),
                ji = Wd(on.stretch - he, je, Rr, Jt),
                Da = Hd(on.fixed - et, ct, on.stretch, q),
                oa = Wd(Zr.stretch - be, Me, Qt, tr),
                zi = Hd(Zr.fixed - Et, ar, Zr.stretch, $),
                Wn = new F(Cr, Kn),
                wi = new F(ji, Kn),
                Li = new F(ji, oa),
                Di = new F(Cr, oa),
                ea = new F(gn / _, gi / _),
                Ra = new F(Da / _, zi / _),
                Ci = t * Math.PI / 180;
              if (Ci) {
                const Ti = Math.sin(Ci),
                  Si = Math.cos(Ci),
                  hi = [Si, -Ti, Ti, Si];
                Wn._matMult(hi), wi._matMult(hi), Di._matMult(hi), Li._matMult(hi)
              }
              const sa = yt.stretch + yt.fixed,
                vi = Yr.stretch + Yr.fixed;
              return {
                tl: Wn,
                tr: wi,
                bl: Di,
                br: Li,
                tex: {
                  x: m.paddedRect.x + 1 + sa,
                  y: m.paddedRect.y + 1 + vi,
                  w: on.stretch + on.fixed - sa,
                  h: Zr.stretch + Zr.fixed - vi
                },
                writingMode: void 0,
                glyphOffset: [0, 0],
                sectionIndex: 0,
                pixelOffsetTL: ea,
                pixelOffsetBR: Ra,
                minFontScaleX: ct / _ / Rr,
                minFontScaleY: ar / _ / Qt,
                isSDF: r
              }
            };
          if (o && (m.stretchX || m.stretchY)) {
            const yt = Yg(A, J, q),
              Yr = Yg(L, te, $);
            for (let on = 0; on < yt.length - 1; on++) {
              const Zr = yt[on],
                Cr = yt[on + 1];
              for (let gn = 0; gn < Yr.length - 1; gn++) c.push(rr(Zr, Yr[gn], Cr, Yr[gn + 1]))
            }
          } else c.push(rr({
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: v + 1
          }, {
            fixed: 0,
            stretch: w + 1
          }));
          return c
        }

        function Gd(n, t, r) {
          let o = 0;
          for (const c of n) o += Math.max(t, Math.min(r, c[1])) - Math.max(t, Math.min(r, c[0]));
          return o
        }

        function Yg(n, t, r) {
          const o = [{
            fixed: -1,
            stretch: 0
          }];
          for (const [c, m] of n) {
            const _ = o[o.length - 1];
            o.push({
              fixed: c - _.stretch,
              stretch: _.stretch
            }), o.push({
              fixed: c - _.stretch,
              stretch: _.stretch + (m - c)
            })
          }
          return o.push({
            fixed: t + 1,
            stretch: r
          }), o
        }

        function Wd(n, t, r, o) {
          return n / t * r + o
        }

        function Hd(n, t, r, o) {
          return n - t * r / o
        }
        hr("Anchor", Ds);
        class Jd {
          constructor(t, r, o, c, m, _, v, w, S, A) {
            var L;
            if (this.boxStartIndex = t.length, S) {
              let j = _.top,
                q = _.bottom;
              const $ = _.collisionPadding;
              $ && (j -= $[1], q += $[3]);
              let J = q - j;
              J > 0 && (J = Math.max(10, J), this.circleDiameter = J)
            } else {
              const j = !((L = _.image) === null || L === void 0) && L.content && (_.image.textFitWidth || _.image.textFitHeight) ? Tg(_) : {
                x1: _.left,
                y1: _.top,
                x2: _.right,
                y2: _.bottom
              };
              j.y1 = j.y1 * v - w[0], j.y2 = j.y2 * v + w[2], j.x1 = j.x1 * v - w[3], j.x2 = j.x2 * v + w[1];
              const q = _.collisionPadding;
              if (q && (j.x1 -= q[0] * v, j.y1 -= q[1] * v, j.x2 += q[2] * v, j.y2 += q[3] * v), A) {
                const $ = new F(j.x1, j.y1),
                  J = new F(j.x2, j.y1),
                  te = new F(j.x1, j.y2),
                  he = new F(j.x2, j.y2),
                  je = A * Math.PI / 180;
                $._rotate(je), J._rotate(je), te._rotate(je), he._rotate(je), j.x1 = Math.min($.x, J.x, te.x, he.x), j.x2 = Math.max($.x, J.x, te.x, he.x), j.y1 = Math.min($.y, J.y, te.y, he.y), j.y2 = Math.max($.y, J.y, te.y, he.y)
              }
              t.emplaceBack(r.x, r.y, j.x1, j.y1, j.x2, j.y2, o, c, m)
            }
            this.boxEndIndex = t.length
          }
        }
        class rx {
          constructor(t = [], r = (o, c) => o < c ? -1 : o > c ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = r, this.length > 0)
              for (let o = (this.length >> 1) - 1; o >= 0; o--) this._down(o)
          }
          push(t) {
            this.data.push(t), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0],
              r = this.data.pop();
            return --this.length > 0 && (this.data[0] = r, this._down(0)), t
          }
          peek() {
            return this.data[0]
          }
          _up(t) {
            const {
              data: r,
              compare: o
            } = this, c = r[t];
            for (; t > 0;) {
              const m = t - 1 >> 1,
                _ = r[m];
              if (o(c, _) >= 0) break;
              r[t] = _, t = m
            }
            r[t] = c
          }
          _down(t) {
            const {
              data: r,
              compare: o
            } = this, c = this.length >> 1, m = r[t];
            for (; t < c;) {
              let _ = 1 + (t << 1);
              const v = _ + 1;
              if (v < this.length && o(r[v], r[_]) < 0 && (_ = v), o(r[_], m) >= 0) break;
              r[t] = r[_], t = _
            }
            r[t] = m
          }
        }

        function nx(n, t = 1, r = !1) {
          const o = pl.fromPoints(n[0]),
            c = Math.min(o.width(), o.height());
          let m = c / 2;
          const _ = new rx([], ix),
            {
              minX: v,
              minY: w,
              maxX: S,
              maxY: A
            } = o;
          if (c === 0) return new F(v, w);
          for (let q = v; q < S; q += c)
            for (let $ = w; $ < A; $ += c) _.push(new pc(q + m, $ + m, m, n));
          let L = (function(q) {
              let $ = 0,
                J = 0,
                te = 0;
              const he = q[0];
              for (let je = 0, be = he.length, Me = be - 1; je < be; Me = je++) {
                const et = he[je],
                  ct = he[Me],
                  Et = et.x * ct.y - ct.x * et.y;
                J += (et.x + ct.x) * Et, te += (et.y + ct.y) * Et, $ += 3 * Et
              }
              return new pc(J / $, te / $, 0, q)
            })(n),
            j = _.length;
          for (; _.length;) {
            const q = _.pop();
            (q.d > L.d || !L.d) && (L = q, r && console.log("found best %d after %d probes", Math.round(1e4 * q.d) / 1e4, j)), q.max - L.d <= t || (m = q.h / 2, _.push(new pc(q.p.x - m, q.p.y - m, m, n)), _.push(new pc(q.p.x + m, q.p.y - m, m, n)), _.push(new pc(q.p.x - m, q.p.y + m, m, n)), _.push(new pc(q.p.x + m, q.p.y + m, m, n)), j += 4)
          }
          return r && (console.log(`num probes: ${j}`), console.log(`best distance: ${L.d}`)), L.p
        }

        function ix(n, t) {
          return t.max - n.max
        }

        function pc(n, t, r, o) {
          this.p = new F(n, t), this.h = r, this.d = (function(c, m) {
            let _ = !1,
              v = 1 / 0;
            for (let w = 0; w < m.length; w++) {
              const S = m[w];
              for (let A = 0, L = S.length, j = L - 1; A < L; j = A++) {
                const q = S[A],
                  $ = S[j];
                q.y > c.y != $.y > c.y && c.x < ($.x - q.x) * (c.y - q.y) / ($.y - q.y) + q.x && (_ = !_), v = Math.min(v, R_(c, q, $))
              }
            }
            return (_ ? 1 : -1) * Math.sqrt(v)
          })(this.p, o), this.max = this.d + this.h * Math.SQRT2
        }
        var Oi;
        b.aE = void 0, (Oi = b.aE || (b.aE = {}))[Oi.center = 1] = "center", Oi[Oi.left = 2] = "left", Oi[Oi.right = 3] = "right", Oi[Oi.top = 4] = "top", Oi[Oi.bottom = 5] = "bottom", Oi[Oi["top-left"] = 6] = "top-left", Oi[Oi["top-right"] = 7] = "top-right", Oi[Oi["bottom-left"] = 8] = "bottom-left", Oi[Oi["bottom-right"] = 9] = "bottom-right";
        const Of = Number.POSITIVE_INFINITY;

        function Kg(n, t) {
          return t[1] !== Of ? (function(r, o, c) {
            let m = 0,
              _ = 0;
            switch (o = Math.abs(o), c = Math.abs(c), r) {
              case "top-right":
              case "top-left":
              case "top":
                _ = c - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                _ = 7 - c
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
              case "right":
                m = -o;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                m = o
            }
            return [m, _]
          })(n, t[0], t[1]) : (function(r, o) {
            let c = 0,
              m = 0;
            o < 0 && (o = 0);
            const _ = o / Math.SQRT2;
            switch (r) {
              case "top-right":
              case "top-left":
                m = _ - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                m = 7 - _;
                break;
              case "bottom":
                m = 7 - o;
                break;
              case "top":
                m = o - 7
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
                c = -_;
                break;
              case "top-left":
              case "bottom-left":
                c = _;
                break;
              case "left":
                c = o;
                break;
              case "right":
                c = -o
            }
            return [c, m]
          })(n, t[0])
        }

        function Qg(n, t, r) {
          var o;
          const c = n.layout,
            m = (o = c.get("text-variable-anchor-offset")) === null || o === void 0 ? void 0 : o.evaluate(t, {}, r);
          if (m) {
            const v = m.values,
              w = [];
            for (let S = 0; S < v.length; S += 2) {
              const A = w[S] = v[S],
                L = v[S + 1].map((j => j * bi));
              A.startsWith("top") ? L[1] -= 7 : A.startsWith("bottom") && (L[1] += 7), w[S + 1] = L
            }
            return new Bn(w)
          }
          const _ = c.get("text-variable-anchor");
          if (_) {
            let v;
            v = n._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [c.get("text-radial-offset").evaluate(t, {}, r) * bi, Of] : c.get("text-offset").evaluate(t, {}, r).map((S => S * bi));
            const w = [];
            for (const S of _) w.push(S, Kg(S, v));
            return new Bn(w)
          }
          return null
        }

        function jf(n) {
          switch (n) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left"
          }
          return "center"
        }

        function ax(n, t, r, o, c, m, _, v, w, S, A, L) {
          let j = m.textMaxSize.evaluate(t, {});
          j === void 0 && (j = _);
          const q = n.layers[0].layout,
            $ = q.get("icon-offset").evaluate(t, {}, A),
            J = tv(r.horizontal),
            te = _ / 24,
            he = n.tilePixelRatio * te,
            je = n.tilePixelRatio * j / 24,
            be = n.tilePixelRatio * v,
            Me = n.tilePixelRatio * q.get("symbol-spacing"),
            et = q.get("text-padding") * n.tilePixelRatio,
            ct = (function(on, Zr, Cr, gn = 1) {
              const Kn = on.get("icon-padding").evaluate(Zr, {}, Cr),
                gi = Kn && Kn.values;
              return [gi[0] * gn, gi[1] * gn, gi[2] * gn, gi[3] * gn]
            })(q, t, A, n.tilePixelRatio),
            Et = q.get("text-max-angle") / 180 * Math.PI,
            ar = q.get("text-rotation-alignment") !== "viewport" && q.get("symbol-placement") !== "point",
            Jt = q.get("icon-rotation-alignment") === "map" && q.get("symbol-placement") !== "point",
            tr = q.get("symbol-placement"),
            Rr = Me / 2,
            Qt = q.get("icon-text-fit");
          let rr;
          o && Qt !== "none" && (n.allowVerticalPlacement && r.vertical && (rr = Sg(o, r.vertical, Qt, q.get("icon-text-fit-padding"), $, te)), J && (o = Sg(o, J, Qt, q.get("icon-text-fit-padding"), $, te)));
          const yt = A ? L.line.getGranularityForZoomLevel(A.z) : 1,
            Yr = (on, Zr) => {
              Zr.x < 0 || Zr.x >= ae || Zr.y < 0 || Zr.y >= ae || (function(Cr, gn, Kn, gi, ji, Da, oa, zi, Wn, wi, Li, Di, ea, Ra, Ci, sa, vi, Ti, Si, hi, Nn, so, fc, lo, lx) {
                const mc = Cr.addToLineVertexArray(gn, Kn);
                let fl, _c, gc, vc, av = 0,
                  ov = 0,
                  sv = 0,
                  lv = 0,
                  Wf = -1,
                  Hf = -1;
                const es = {};
                let cv = Ms("");
                if (Cr.allowVerticalPlacement && gi.vertical) {
                  const Xi = zi.layout.get("text-rotate").evaluate(Nn, {}, lo) + 90;
                  gc = new Jd(Wn, gn, wi, Li, Di, gi.vertical, ea, Ra, Ci, Xi), oa && (vc = new Jd(Wn, gn, wi, Li, Di, oa, vi, Ti, Ci, Xi))
                }
                if (ji) {
                  const Xi = zi.layout.get("icon-rotate").evaluate(Nn, {}),
                    Ba = zi.layout.get("icon-text-fit") !== "none",
                    ml = Xg(ji, Xi, fc, Ba),
                    uo = oa ? Xg(oa, Xi, fc, Ba) : void 0;
                  _c = new Jd(Wn, gn, wi, Li, Di, ji, vi, Ti, !1, Xi), av = 4 * ml.length;
                  const _l = Cr.iconSizeData;
                  let ko = null;
                  _l.kind === "source" ? (ko = [Qo * zi.layout.get("icon-size").evaluate(Nn, {})], ko[0] > zs && Bt(`${Cr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : _l.kind === "composite" && (ko = [Qo * so.compositeIconSizes[0].evaluate(Nn, {}, lo), Qo * so.compositeIconSizes[1].evaluate(Nn, {}, lo)], (ko[0] > zs || ko[1] > zs) && Bt(`${Cr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Cr.addSymbols(Cr.icon, ml, ko, hi, Si, Nn, b.ao.none, gn, mc.lineStartIndex, mc.lineLength, -1, lo), Wf = Cr.icon.placedSymbolArray.length - 1, uo && (ov = 4 * uo.length, Cr.addSymbols(Cr.icon, uo, ko, hi, Si, Nn, b.ao.vertical, gn, mc.lineStartIndex, mc.lineLength, -1, lo), Hf = Cr.icon.placedSymbolArray.length - 1)
                }
                const uv = Object.keys(gi.horizontal);
                for (const Xi of uv) {
                  const Ba = gi.horizontal[Xi];
                  if (!fl) {
                    cv = Ms(Ba.text);
                    const uo = zi.layout.get("text-rotate").evaluate(Nn, {}, lo);
                    fl = new Jd(Wn, gn, wi, Li, Di, Ba, ea, Ra, Ci, uo)
                  }
                  const ml = Ba.positionedLines.length === 1;
                  if (sv += ev(Cr, gn, Ba, Da, zi, Ci, Nn, sa, mc, gi.vertical ? b.ao.horizontal : b.ao.horizontalOnly, ml ? uv : [Xi], es, Wf, so, lo), ml) break
                }
                gi.vertical && (lv += ev(Cr, gn, gi.vertical, Da, zi, Ci, Nn, sa, mc, b.ao.vertical, ["vertical"], es, Hf, so, lo));
                const cx = fl ? fl.boxStartIndex : Cr.collisionBoxArray.length,
                  ux = fl ? fl.boxEndIndex : Cr.collisionBoxArray.length,
                  hx = gc ? gc.boxStartIndex : Cr.collisionBoxArray.length,
                  dx = gc ? gc.boxEndIndex : Cr.collisionBoxArray.length,
                  px = _c ? _c.boxStartIndex : Cr.collisionBoxArray.length,
                  fx = _c ? _c.boxEndIndex : Cr.collisionBoxArray.length,
                  mx = vc ? vc.boxStartIndex : Cr.collisionBoxArray.length,
                  _x = vc ? vc.boxEndIndex : Cr.collisionBoxArray.length;
                let co = -1;
                const Yd = (Xi, Ba) => Xi && Xi.circleDiameter ? Math.max(Xi.circleDiameter, Ba) : Ba;
                co = Yd(fl, co), co = Yd(gc, co), co = Yd(_c, co), co = Yd(vc, co);
                const hv = co > -1 ? 1 : 0;
                hv && (co *= lx / bi), Cr.glyphOffsetArray.length >= hc.MAX_GLYPHS && Bt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Nn.sortKey !== void 0 && Cr.addToSortKeyRanges(Cr.symbolInstances.length, Nn.sortKey);
                const gx = Qg(zi, Nn, lo),
                  [vx, yx] = (function(Xi, Ba) {
                    const ml = Xi.length,
                      uo = Ba == null ? void 0 : Ba.values;
                    if ((uo == null ? void 0 : uo.length) > 0)
                      for (let _l = 0; _l < uo.length; _l += 2) {
                        const ko = uo[_l + 1];
                        Xi.emplaceBack(b.aE[uo[_l]], ko[0], ko[1])
                      }
                    return [ml, Xi.length]
                  })(Cr.textAnchorOffsets, gx);
                Cr.symbolInstances.emplaceBack(gn.x, gn.y, es.right >= 0 ? es.right : -1, es.center >= 0 ? es.center : -1, es.left >= 0 ? es.left : -1, es.vertical || -1, Wf, Hf, cv, cx, ux, hx, dx, px, fx, mx, _x, wi, sv, lv, av, ov, hv, 0, ea, co, vx, yx)
              })(n, Zr, on, r, o, c, rr, n.layers[0], n.collisionBoxArray, t.index, t.sourceLayerIndex, n.index, he, [et, et, et, et], ar, w, be, ct, Jt, $, t, m, S, A, _)
            };
          if (tr === "line")
            for (const on of Ug(t.geometry, 0, 0, ae, ae)) {
              const Zr = dl(on, yt),
                Cr = tx(Zr, Me, Et, r.vertical || J, o, 24, je, n.overscaling, ae);
              for (const gn of Cr) J && ox(n, J.text, Rr, gn) || Yr(Zr, gn)
            } else if (tr === "line-center") {
              for (const on of t.geometry)
                if (on.length > 1) {
                  const Zr = dl(on, yt),
                    Cr = ex(Zr, Et, r.vertical || J, o, 24, je);
                  Cr && Yr(Zr, Cr)
                }
            } else if (t.type === "Polygon")
            for (const on of Js(t.geometry, 0)) {
              const Zr = nx(on, 16);
              Yr(dl(on[0], yt, !0), new Ds(Zr.x, Zr.y, 0))
            } else if (t.type === "LineString")
              for (const on of t.geometry) {
                const Zr = dl(on, yt);
                Yr(Zr, new Ds(Zr[0].x, Zr[0].y, 0))
              } else if (t.type === "Point")
                for (const on of t.geometry)
                  for (const Zr of on) Yr([Zr], new Ds(Zr.x, Zr.y, 0))
        }

        function ev(n, t, r, o, c, m, _, v, w, S, A, L, j, q, $) {
          const J = (function(je, be, Me, et, ct, Et, ar, Jt) {
              const tr = et.layout.get("text-rotate").evaluate(Et, {}) * Math.PI / 180,
                Rr = [];
              for (const Qt of be.positionedLines)
                for (const rr of Qt.positionedGlyphs) {
                  if (!rr.rect) continue;
                  const yt = rr.rect || {};
                  let Yr = 4,
                    on = !0,
                    Zr = 1,
                    Cr = 0;
                  const gn = (ct || Jt) && rr.vertical,
                    Kn = rr.metrics.advance * rr.scale / 2;
                  if (Jt && be.verticalizable && (Cr = Qt.lineOffset / 2 - (rr.imageName ? -(bi - rr.metrics.width * rr.scale) / 2 : (rr.scale - 1) * bi)), rr.imageName) {
                    const Ti = ar[rr.imageName];
                    on = Ti.sdf, Zr = Ti.pixelRatio, Yr = 1 / Zr
                  }
                  const gi = ct ? [rr.x + Kn, rr.y] : [0, 0];
                  let ji = ct ? [0, 0] : [rr.x + Kn + Me[0], rr.y + Me[1] - Cr],
                    Da = [0, 0];
                  gn && (Da = ji, ji = [0, 0]);
                  const oa = rr.metrics.isDoubleResolution ? 2 : 1,
                    zi = (rr.metrics.left - Yr) * rr.scale - Kn + ji[0],
                    Wn = (-rr.metrics.top - Yr) * rr.scale + ji[1],
                    wi = zi + yt.w / oa * rr.scale / Zr,
                    Li = Wn + yt.h / oa * rr.scale / Zr,
                    Di = new F(zi, Wn),
                    ea = new F(wi, Wn),
                    Ra = new F(zi, Li),
                    Ci = new F(wi, Li);
                  if (gn) {
                    const Ti = new F(-Kn, Kn - -17),
                      Si = -Math.PI / 2,
                      hi = 12 - Kn,
                      Nn = new F(22 - hi, -(rr.imageName ? hi : 0)),
                      so = new F(...Da);
                    Di._rotateAround(Si, Ti)._add(Nn)._add(so), ea._rotateAround(Si, Ti)._add(Nn)._add(so), Ra._rotateAround(Si, Ti)._add(Nn)._add(so), Ci._rotateAround(Si, Ti)._add(Nn)._add(so)
                  }
                  if (tr) {
                    const Ti = Math.sin(tr),
                      Si = Math.cos(tr),
                      hi = [Si, -Ti, Ti, Si];
                    Di._matMult(hi), ea._matMult(hi), Ra._matMult(hi), Ci._matMult(hi)
                  }
                  const sa = new F(0, 0),
                    vi = new F(0, 0);
                  Rr.push({
                    tl: Di,
                    tr: ea,
                    bl: Ra,
                    br: Ci,
                    tex: yt,
                    writingMode: be.writingMode,
                    glyphOffset: gi,
                    sectionIndex: rr.sectionIndex,
                    isSDF: on,
                    pixelOffsetTL: sa,
                    pixelOffsetBR: vi,
                    minFontScaleX: 0,
                    minFontScaleY: 0
                  })
                }
              return Rr
            })(0, r, v, c, m, _, o, n.allowVerticalPlacement),
            te = n.textSizeData;
          let he = null;
          te.kind === "source" ? (he = [Qo * c.layout.get("text-size").evaluate(_, {})], he[0] > zs && Bt(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : te.kind === "composite" && (he = [Qo * q.compositeTextSizes[0].evaluate(_, {}, $), Qo * q.compositeTextSizes[1].evaluate(_, {}, $)], (he[0] > zs || he[1] > zs) && Bt(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), n.addSymbols(n.text, J, he, v, m, _, S, t, w.lineStartIndex, w.lineLength, j, $);
          for (const je of A) L[je] = n.text.placedSymbolArray.length - 1;
          return 4 * J.length
        }

        function tv(n) {
          for (const t in n) return n[t];
          return null
        }

        function ox(n, t, r, o) {
          const c = n.compareText;
          if (t in c) {
            const m = c[t];
            for (let _ = m.length - 1; _ >= 0; _--)
              if (o.dist(m[_]) < r) return !0
          } else c[t] = [];
          return c[t].push(o), !1
        }
        const rv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Nf {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [r, o] = new Uint8Array(t, 0, 2);
            if (r !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const c = o >> 4;
            if (c !== 1) throw new Error(`Got v${c} data when expected v1.`);
            const m = rv[15 & o];
            if (!m) throw new Error("Unrecognized array type.");
            const [_] = new Uint16Array(t, 2, 1), [v] = new Uint32Array(t, 4, 1);
            return new Nf(v, _, m, t)
          }
          constructor(t, r = 64, o = Float64Array, c) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = o, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const m = rv.indexOf(this.ArrayType),
              _ = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
              v = t * this.IndexArrayType.BYTES_PER_ELEMENT,
              w = (8 - v % 8) % 8;
            if (m < 0) throw new Error(`Unexpected typed array class: ${o}.`);
            c && c instanceof ArrayBuffer ? (this.data = c, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + v + w, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + _ + v + w), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + v + w, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + m]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = t)
          }
          add(t, r) {
            const o = this._pos >> 1;
            return this.ids[o] = o, this.coords[this._pos++] = t, this.coords[this._pos++] = r, o
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return Zf(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this
          }
          range(t, r, o, c) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: m,
              coords: _,
              nodeSize: v
            } = this, w = [0, m.length - 1, 0], S = [];
            for (; w.length;) {
              const A = w.pop() || 0,
                L = w.pop() || 0,
                j = w.pop() || 0;
              if (L - j <= v) {
                for (let te = j; te <= L; te++) {
                  const he = _[2 * te],
                    je = _[2 * te + 1];
                  he >= t && he <= o && je >= r && je <= c && S.push(m[te])
                }
                continue
              }
              const q = j + L >> 1,
                $ = _[2 * q],
                J = _[2 * q + 1];
              $ >= t && $ <= o && J >= r && J <= c && S.push(m[q]), (A === 0 ? t <= $ : r <= J) && (w.push(j), w.push(q - 1), w.push(1 - A)), (A === 0 ? o >= $ : c >= J) && (w.push(q + 1), w.push(L), w.push(1 - A))
            }
            return S
          }
          within(t, r, o) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: c,
              coords: m,
              nodeSize: _
            } = this, v = [0, c.length - 1, 0], w = [], S = o * o;
            for (; v.length;) {
              const A = v.pop() || 0,
                L = v.pop() || 0,
                j = v.pop() || 0;
              if (L - j <= _) {
                for (let te = j; te <= L; te++) iv(m[2 * te], m[2 * te + 1], t, r) <= S && w.push(c[te]);
                continue
              }
              const q = j + L >> 1,
                $ = m[2 * q],
                J = m[2 * q + 1];
              iv($, J, t, r) <= S && w.push(c[q]), (A === 0 ? t - o <= $ : r - o <= J) && (v.push(j), v.push(q - 1), v.push(1 - A)), (A === 0 ? t + o >= $ : r + o >= J) && (v.push(q + 1), v.push(L), v.push(1 - A))
            }
            return w
          }
        }

        function Zf(n, t, r, o, c, m) {
          if (c - o <= r) return;
          const _ = o + c >> 1;
          nv(n, t, _, o, c, m), Zf(n, t, r, o, _ - 1, 1 - m), Zf(n, t, r, _ + 1, c, 1 - m)
        }

        function nv(n, t, r, o, c, m) {
          for (; c > o;) {
            if (c - o > 600) {
              const S = c - o + 1,
                A = r - o + 1,
                L = Math.log(S),
                j = .5 * Math.exp(2 * L / 3),
                q = .5 * Math.sqrt(L * j * (S - j) / S) * (A - S / 2 < 0 ? -1 : 1);
              nv(n, t, r, Math.max(o, Math.floor(r - A * j / S + q)), Math.min(c, Math.floor(r + (S - A) * j / S + q)), m)
            }
            const _ = t[2 * r + m];
            let v = o,
              w = c;
            for (Ou(n, t, o, r), t[2 * c + m] > _ && Ou(n, t, o, c); v < w;) {
              for (Ou(n, t, v, w), v++, w--; t[2 * v + m] < _;) v++;
              for (; t[2 * w + m] > _;) w--
            }
            t[2 * o + m] === _ ? Ou(n, t, o, w) : (w++, Ou(n, t, w, c)), w <= r && (o = w + 1), r <= w && (c = w - 1)
          }
        }

        function Ou(n, t, r, o) {
          Vf(n, r, o), Vf(t, 2 * r, 2 * o), Vf(t, 2 * r + 1, 2 * o + 1)
        }

        function Vf(n, t, r) {
          const o = n[t];
          n[t] = n[r], n[r] = o
        }

        function iv(n, t, r, o) {
          const c = n - r,
            m = t - o;
          return c * c + m * m
        }
        var qf;
        b.cx = void 0, (qf = b.cx || (b.cx = {})).create = "create", qf.load = "load", qf.fullLoad = "fullLoad";
        let Xd = null,
          ju = [];
        const Uf = 1e3 / 60,
          $f = "loadTime",
          Gf = "fullLoadTime",
          sx = {
            mark(n) {
              performance.mark(n)
            },
            frame(n) {
              const t = n;
              Xd != null && ju.push(t - Xd), Xd = t
            },
            clearMetrics() {
              Xd = null, ju = [], performance.clearMeasures($f), performance.clearMeasures(Gf);
              for (const n in b.cx) performance.clearMarks(b.cx[n])
            },
            getPerformanceMetrics() {
              performance.measure($f, b.cx.create, b.cx.load), performance.measure(Gf, b.cx.create, b.cx.fullLoad);
              const n = performance.getEntriesByName($f)[0].duration,
                t = performance.getEntriesByName(Gf)[0].duration,
                r = ju.length,
                o = 1 / (ju.reduce(((m, _) => m + _), 0) / r / 1e3),
                c = ju.filter((m => m > Uf)).reduce(((m, _) => m + (_ - Uf) / Uf), 0);
              return {
                loadTime: n,
                fullLoadTime: t,
                fps: o,
                percentDroppedFrames: c / (r + c) * 100,
                totalFrames: r
              }
            }
          };
        b.$ = ae, b.A = Pe, b.B = function([n, t, r]) {
          return t += 90, t *= Math.PI / 180, r *= Math.PI / 180, {
            x: n * Math.cos(t) * Math.sin(r),
            y: n * Math.sin(t) * Math.sin(r),
            z: n * Math.cos(r)
          }
        }, b.C = Ua, b.D = Mr, b.E = qt, b.F = Un, b.G = al, b.H = function(n) {
          if (Dt == null) {
            const t = n.navigator ? n.navigator.userAgent : null;
            Dt = !!n.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
          }
          return Dt
        }, b.I = Pf, b.J = class {
          constructor(n, t) {
            this.target = n, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Y1((() => this.process())), this.subscription = Er(this.target, "message", (r => this.receive(r)), !1), this.globalScope = Ot(self) ? n : window
          }
          registerMessageHandler(n, t) {
            this.messageHandlers[n] = t
          }
          sendAsync(n, t) {
            return new Promise(((r, o) => {
              const c = Math.round(1e18 * Math.random()).toString(36).substring(0, 10),
                m = t ? Er(t.signal, "abort", (() => {
                  m == null || m.unsubscribe(), delete this.resolveRejects[c];
                  const w = {
                    id: c,
                    type: "<cancel>",
                    origin: location.origin,
                    targetMapId: n.targetMapId,
                    sourceMapId: this.mapId
                  };
                  this.target.postMessage(w)
                }), K1) : null;
              this.resolveRejects[c] = {
                resolve: w => {
                  m == null || m.unsubscribe(), r(w)
                },
                reject: w => {
                  m == null || m.unsubscribe(), o(w)
                }
              };
              const _ = [],
                v = Object.assign(Object.assign({}, n), {
                  id: c,
                  sourceMapId: this.mapId,
                  origin: location.origin,
                  data: Cs(n.data, _)
                });
              this.target.postMessage(v, {
                transfer: _
              })
            }))
          }
          receive(n) {
            const t = n.data,
              r = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[r];
                const o = this.abortControllers[r];
                return delete this.abortControllers[r], void(o && o.abort())
              }
              if (Ot(self) || t.mustQueue) return this.tasks[r] = t, this.taskQueue.push(r), void this.invoker.trigger();
              this.processTask(r, t)
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const n = this.taskQueue.shift(),
              t = this.tasks[n];
            delete this.tasks[n], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(n, t)
          }
          processTask(n, t) {
            return s(this, void 0, void 0, (function*() {
              if (t.type === "<response>") {
                const c = this.resolveRejects[n];
                return delete this.resolveRejects[n], c ? void(t.error ? c.reject(Ho(t.error)) : c.resolve(Ho(t.data))) : void 0
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(n, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const r = Ho(t.data),
                o = new AbortController;
              this.abortControllers[n] = o;
              try {
                const c = yield this.messageHandlers[t.type](t.sourceMapId, r, o);
                this.completeTask(n, null, c)
              } catch (c) {
                this.completeTask(n, c)
              }
            }))
          }
          completeTask(n, t, r) {
            const o = [];
            delete this.abortControllers[n];
            const c = {
              id: n,
              type: "<response>",
              sourceMapId: this.mapId,
              origin: location.origin,
              error: t ? Cs(t) : null,
              data: Cs(r, o)
            };
            this.target.postMessage(c, {
              transfer: o
            })
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe()
          }
        }, b.K = Y, b.L = function() {
          var n = new Pe(16);
          return Pe != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0), n[0] = 1, n[5] = 1, n[10] = 1, n[15] = 1, n
        }, b.M = function(n, t, r) {
          var o, c, m, _, v, w, S, A, L, j, q, $, J = r[0],
            te = r[1],
            he = r[2];
          return t === n ? (n[12] = t[0] * J + t[4] * te + t[8] * he + t[12], n[13] = t[1] * J + t[5] * te + t[9] * he + t[13], n[14] = t[2] * J + t[6] * te + t[10] * he + t[14], n[15] = t[3] * J + t[7] * te + t[11] * he + t[15]) : (c = t[1], m = t[2], _ = t[3], v = t[4], w = t[5], S = t[6], A = t[7], L = t[8], j = t[9], q = t[10], $ = t[11], n[0] = o = t[0], n[1] = c, n[2] = m, n[3] = _, n[4] = v, n[5] = w, n[6] = S, n[7] = A, n[8] = L, n[9] = j, n[10] = q, n[11] = $, n[12] = o * J + v * te + L * he + t[12], n[13] = c * J + w * te + j * he + t[13], n[14] = m * J + S * te + q * he + t[14], n[15] = _ * J + A * te + $ * he + t[15]), n
        }, b.N = function(n, t, r) {
          var o = r[0],
            c = r[1],
            m = r[2];
          return n[0] = t[0] * o, n[1] = t[1] * o, n[2] = t[2] * o, n[3] = t[3] * o, n[4] = t[4] * c, n[5] = t[5] * c, n[6] = t[6] * c, n[7] = t[7] * c, n[8] = t[8] * m, n[9] = t[9] * m, n[10] = t[10] * m, n[11] = t[11] * m, n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n
        }, b.O = function(n, t, r) {
          var o = t[0],
            c = t[1],
            m = t[2],
            _ = t[3],
            v = t[4],
            w = t[5],
            S = t[6],
            A = t[7],
            L = t[8],
            j = t[9],
            q = t[10],
            $ = t[11],
            J = t[12],
            te = t[13],
            he = t[14],
            je = t[15],
            be = r[0],
            Me = r[1],
            et = r[2],
            ct = r[3];
          return n[0] = be * o + Me * v + et * L + ct * J, n[1] = be * c + Me * w + et * j + ct * te, n[2] = be * m + Me * S + et * q + ct * he, n[3] = be * _ + Me * A + et * $ + ct * je, n[4] = (be = r[4]) * o + (Me = r[5]) * v + (et = r[6]) * L + (ct = r[7]) * J, n[5] = be * c + Me * w + et * j + ct * te, n[6] = be * m + Me * S + et * q + ct * he, n[7] = be * _ + Me * A + et * $ + ct * je, n[8] = (be = r[8]) * o + (Me = r[9]) * v + (et = r[10]) * L + (ct = r[11]) * J, n[9] = be * c + Me * w + et * j + ct * te, n[10] = be * m + Me * S + et * q + ct * he, n[11] = be * _ + Me * A + et * $ + ct * je, n[12] = (be = r[12]) * o + (Me = r[13]) * v + (et = r[14]) * L + (ct = r[15]) * J, n[13] = be * c + Me * w + et * j + ct * te, n[14] = be * m + Me * S + et * q + ct * he, n[15] = be * _ + Me * A + et * $ + ct * je, n
        }, b.P = F, b.Q = function(n, t) {
          const r = {};
          for (let o = 0; o < t.length; o++) {
            const c = t[o];
            c in n && (r[c] = n[c])
          }
          return r
        }, b.R = aa, b.S = Ls, b.T = _f, b.U = Rg, b.V = Dg, b.W = Ae, b.X = xe, b.Y = Ft, b.Z = La, b._ = s, b.a = V, b.a$ = Ge, b.a0 = function(n, t) {
          var r, o, c, m;
          if (!n) return t ?? {};
          if (!t) return n;
          const _ = Object.assign({}, n);
          if (t.removeAll && (_.removeAll = !0), t.remove) {
            const v = new Set(_.remove ? _.remove.concat(t.remove) : t.remove);
            _.remove = Array.from(v.values())
          }
          if (t.add) {
            const v = _.add ? _.add.concat(t.add) : t.add,
              w = new Map(v.map((S => [S.id, S])));
            _.add = Array.from(w.values())
          }
          if (t.update) {
            const v = new Map((r = _.update) === null || r === void 0 ? void 0 : r.map((w => [w.id, w])));
            for (const w of t.update) {
              const S = (o = v.get(w.id)) !== null && o !== void 0 ? o : {
                id: w.id
              };
              w.newGeometry && (S.newGeometry = w.newGeometry), w.addOrUpdateProperties && (S.addOrUpdateProperties = ((c = S.addOrUpdateProperties) !== null && c !== void 0 ? c : []).concat(w.addOrUpdateProperties)), w.removeProperties && (S.removeProperties = ((m = S.removeProperties) !== null && m !== void 0 ? m : []).concat(w.removeProperties)), w.removeAllProperties && (S.removeAllProperties = !0), v.set(w.id, S)
            }
            _.update = Array.from(v.values())
          }
          return _
        }, b.a1 = Bu, b.a2 = pl, b.a3 = 25, b.a4 = Ff, b.a5 = n => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise((r => {
            t.onloadstart = () => {
              r(t)
            };
            for (const o of n) {
              const c = window.document.createElement("source");
              Oe(o) || (t.crossOrigin = "Anonymous"), c.src = o, t.appendChild(c)
            }
          }))
        }, b.a6 = bt, b.a7 = function() {
          return gt++
        }, b.a8 = D, b.a9 = hc, b.aA = function(n) {
          let t = 1 / 0,
            r = 1 / 0,
            o = -1 / 0,
            c = -1 / 0;
          for (const m of n) t = Math.min(t, m.x), r = Math.min(r, m.y), o = Math.max(o, m.x), c = Math.max(c, m.y);
          return [t, r, o, c]
        }, b.aB = bi, b.aC = ke, b.aD = function(n, t, r, o, c = !1) {
          if (!r[0] && !r[1]) return [0, 0];
          const m = c ? o === "map" ? -n.bearingInRadians : 0 : o === "viewport" ? n.bearingInRadians : 0;
          if (m) {
            const _ = Math.sin(m),
              v = Math.cos(m);
            r = [r[0] * v - r[1] * _, r[0] * _ + r[1] * v]
          }
          return [c ? r[0] : ke(t, r[0], n.zoom), c ? r[1] : ke(t, r[1], n.zoom)]
        }, b.aF = Af, b.aG = jf, b.aH = Mf, b.aI = Nf, b.aJ = ei, b.aK = Nd, b.aL = ve, b.aM = un, b.aN = kn, b.aO = He, b.aP = pr, b.aQ = Fg, b.aR = Ce, b.aS = Ue, b.aT = function(n) {
          var t = new Pe(3);
          return t[0] = n[0], t[1] = n[1], t[2] = n[2], t
        }, b.aU = function(n, t, r) {
          return n[0] = t[0] - r[0], n[1] = t[1] - r[1], n[2] = t[2] - r[2], n
        }, b.aV = function(n, t) {
          var r = t[0],
            o = t[1],
            c = t[2],
            m = r * r + o * o + c * c;
          return m > 0 && (m = 1 / Math.sqrt(m)), n[0] = t[0] * m, n[1] = t[1] * m, n[2] = t[2] * m, n
        }, b.aW = We, b.aX = function(n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2]
        }, b.aY = function(n, t, r) {
          return n[0] = t[0] * r[0], n[1] = t[1] * r[1], n[2] = t[2] * r[2], n[3] = t[3] * r[3], n
        }, b.aZ = Ve, b.a_ = function(n, t, r) {
          const o = t[0] * r[0] + t[1] * r[1] + t[2] * r[2];
          return o === 0 ? null : (-(n[0] * r[0] + n[1] * r[1] + n[2] * r[2]) - r[3]) / o
        }, b.aa = $o, b.ab = oo, b.ac = Zg, b.ad = function(n) {
          const t = {};
          if (n.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((r, o, c, m) => {
              const _ = c || m;
              return t[o] = !_ || _.toLowerCase(), ""
            })), t["max-age"]) {
            const r = parseInt(t["max-age"], 10);
            isNaN(r) ? delete t["max-age"] : t["max-age"] = r
          }
          return t
        }, b.ae = dr, b.af = function(n) {
          return Math.pow(2, n)
        }, b.ag = $e, b.ah = Lt, b.ai = 85.051129, b.aj = Bg, b.ak = function(n) {
          return Math.log(n) / Math.LN2
        }, b.al = function(n) {
          var t = n[0],
            r = n[1];
          return t * t + r * r
        }, b.am = function(n, t) {
          const r = [];
          for (const o in n) o in t || r.push(o);
          return r
        }, b.an = function(n, t) {
          let r = 0,
            o = 0;
          if (n.kind === "constant") o = n.layoutSize;
          else if (n.kind !== "source") {
            const {
              interpolationType: c,
              minZoom: m,
              maxZoom: _
            } = n, v = c ? Lt(Ei.interpolationFactor(c, t, m, _), 0, 1) : 0;
            n.kind === "camera" ? o = Ua.number(n.minSize, n.maxSize, v) : r = v
          }
          return {
            uSizeT: r,
            uSize: o
          }
        }, b.ap = function(n, {
          uSize: t,
          uSizeT: r
        }, {
          lowerSize: o,
          upperSize: c
        }) {
          return n.kind === "source" ? o / Qo : n.kind === "composite" ? Ua.number(o / Qo, c / Qo, r) : t
        }, b.aq = function(n, t) {
          var r = t[0],
            o = t[1],
            c = t[2],
            m = t[3],
            _ = t[4],
            v = t[5],
            w = t[6],
            S = t[7],
            A = t[8],
            L = t[9],
            j = t[10],
            q = t[11],
            $ = t[12],
            J = t[13],
            te = t[14],
            he = t[15],
            je = r * v - o * _,
            be = r * w - c * _,
            Me = r * S - m * _,
            et = o * w - c * v,
            ct = o * S - m * v,
            Et = c * S - m * w,
            ar = A * J - L * $,
            Jt = A * te - j * $,
            tr = A * he - q * $,
            Rr = L * te - j * J,
            Qt = L * he - q * J,
            rr = j * he - q * te,
            yt = je * rr - be * Qt + Me * Rr + et * tr - ct * Jt + Et * ar;
          return yt ? (n[0] = (v * rr - w * Qt + S * Rr) * (yt = 1 / yt), n[1] = (c * Qt - o * rr - m * Rr) * yt, n[2] = (J * Et - te * ct + he * et) * yt, n[3] = (j * ct - L * Et - q * et) * yt, n[4] = (w * tr - _ * rr - S * Jt) * yt, n[5] = (r * rr - c * tr + m * Jt) * yt, n[6] = (te * Me - $ * Et - he * be) * yt, n[7] = (A * Et - j * Me + q * be) * yt, n[8] = (_ * Qt - v * tr + S * ar) * yt, n[9] = (o * tr - r * Qt - m * ar) * yt, n[10] = ($ * ct - J * Me + he * je) * yt, n[11] = (L * Me - A * ct - q * je) * yt, n[12] = (v * Jt - _ * Rr - w * ar) * yt, n[13] = (r * Rr - o * Jt + c * ar) * yt, n[14] = (J * be - $ * et - te * je) * yt, n[15] = (A * et - L * be + j * je) * yt, n) : null
        }, b.ar = ee, b.as = function(n) {
          return Math.hypot(n[0], n[1])
        }, b.at = function(n) {
          return n[0] = 0, n[1] = 0, n
        }, b.au = function(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n
        }, b.av = Ef, b.aw = Ee, b.ax = function(n, t, r, o) {
          const c = t.y - n.y,
            m = t.x - n.x,
            _ = o.y - r.y,
            v = o.x - r.x,
            w = _ * m - v * c;
          if (w === 0) return null;
          const S = (v * (n.y - r.y) - _ * (n.x - r.x)) / w;
          return new F(n.x + S * m, n.y + S * c)
        }, b.ay = Ug, b.az = L_, b.b = Rt, b.b$ = class extends p {}, b.b0 = function(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n[3] = t[3] * r, n
        }, b.b1 = function(n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3]
        }, b.b2 = jg, b.b3 = dc, b.b4 = function(n, t, r, o, c) {
          var m, _ = 1 / Math.tan(t / 2);
          return n[0] = _ / r, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = _, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, c != null && c !== 1 / 0 ? (n[10] = (c + o) * (m = 1 / (o - c)), n[14] = 2 * c * o * m) : (n[10] = -1, n[14] = -2 * o), n
        }, b.b5 = function(n) {
          var t = new Pe(16);
          return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t
        }, b.b6 = function(n, t, r) {
          var o = Math.sin(r),
            c = Math.cos(r),
            m = t[0],
            _ = t[1],
            v = t[2],
            w = t[3],
            S = t[4],
            A = t[5],
            L = t[6],
            j = t[7];
          return t !== n && (n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = m * c + S * o, n[1] = _ * c + A * o, n[2] = v * c + L * o, n[3] = w * c + j * o, n[4] = S * c - m * o, n[5] = A * c - _ * o, n[6] = L * c - v * o, n[7] = j * c - w * o, n
        }, b.b7 = function(n, t, r) {
          var o = Math.sin(r),
            c = Math.cos(r),
            m = t[4],
            _ = t[5],
            v = t[6],
            w = t[7],
            S = t[8],
            A = t[9],
            L = t[10],
            j = t[11];
          return t !== n && (n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[4] = m * c + S * o, n[5] = _ * c + A * o, n[6] = v * c + L * o, n[7] = w * c + j * o, n[8] = S * c - m * o, n[9] = A * c - _ * o, n[10] = L * c - v * o, n[11] = j * c - w * o, n
        }, b.b8 = function() {
          const n = new Float32Array(16);
          return $e(n), n
        }, b.b9 = function() {
          const n = new Float64Array(16);
          return $e(n), n
        }, b.bA = function(n, t) {
          const r = qe(n, 360),
            o = qe(t, 360),
            c = o - r,
            m = o > r ? c - 360 : c + 360;
          return Math.abs(c) < Math.abs(m) ? c : m
        }, b.bB = function(n) {
          return n[0] = 0, n[1] = 0, n[2] = 0, n
        }, b.bC = function(n, t, r, o) {
          const c = Math.sqrt(n * n + t * t),
            m = Math.sqrt(r * r + o * o);
          n /= c, t /= c, r /= m, o /= m;
          const _ = Math.acos(n * r + t * o);
          return -t * r + n * o > 0 ? _ : -_
        }, b.bD = function(n, t) {
          const r = qe(n, 2 * Math.PI),
            o = qe(t, 2 * Math.PI);
          return Math.min(Math.abs(r - o), Math.abs(r - o + 2 * Math.PI), Math.abs(r - o - 2 * Math.PI))
        }, b.bE = function() {
          const n = {},
            t = we.$version;
          for (const r in we.$root) {
            const o = we.$root[r];
            if (o.required) {
              let c = null;
              c = r === "version" ? t : o.type === "array" ? [] : {}, c != null && (n[r] = c)
            }
          }
          return n
        }, b.bF = Wl, b.bG = me, b.bH = function n(t, r) {
          if (Array.isArray(t)) {
            if (!Array.isArray(r) || t.length !== r.length) return !1;
            for (let o = 0; o < t.length; o++)
              if (!n(t[o], r[o])) return !1;
            return !0
          }
          if (typeof t == "object" && t !== null && r !== null) {
            if (typeof r != "object" || Object.keys(t).length !== Object.keys(r).length) return !1;
            for (const o in t)
              if (!n(t[o], r[o])) return !1;
            return !0
          }
          return t === r
        }, b.bI = function(n) {
          n = n.slice();
          const t = Object.create(null);
          for (let r = 0; r < n.length; r++) t[n[r].id] = n[r];
          for (let r = 0; r < n.length; r++) "ref" in n[r] && (n[r] = Ut(n[r], t[n[r].ref]));
          return n
        }, b.bJ = function(n) {
          if (n.type === "custom") return new X1(n);
          switch (n.type) {
            case "background":
              return new W1(n);
            case "circle":
              return new zy(n);
            case "color-relief":
              return new Oy(n);
            case "fill":
              return new Qy(n);
            case "fill-extrusion":
              return new u1(n);
            case "heatmap":
              return new Dy(n);
            case "hillshade":
              return new By(n);
            case "line":
              return new g1(n);
            case "raster":
              return new J1(n);
            case "symbol":
              return new $d(n)
          }
        }, b.bK = Ct, b.bL = function(n, t) {
          if (!n) return [{
            command: "setStyle",
            args: [t]
          }];
          let r = [];
          try {
            if (!jt(n.version, t.version)) return [{
              command: "setStyle",
              args: [t]
            }];
            jt(n.center, t.center) || r.push({
              command: "setCenter",
              args: [t.center]
            }), jt(n.state, t.state) || r.push({
              command: "setGlobalState",
              args: [t.state]
            }), jt(n.centerAltitude, t.centerAltitude) || r.push({
              command: "setCenterAltitude",
              args: [t.centerAltitude]
            }), jt(n.zoom, t.zoom) || r.push({
              command: "setZoom",
              args: [t.zoom]
            }), jt(n.bearing, t.bearing) || r.push({
              command: "setBearing",
              args: [t.bearing]
            }), jt(n.pitch, t.pitch) || r.push({
              command: "setPitch",
              args: [t.pitch]
            }), jt(n.roll, t.roll) || r.push({
              command: "setRoll",
              args: [t.roll]
            }), jt(n.sprite, t.sprite) || r.push({
              command: "setSprite",
              args: [t.sprite]
            }), jt(n.glyphs, t.glyphs) || r.push({
              command: "setGlyphs",
              args: [t.glyphs]
            }), jt(n.transition, t.transition) || r.push({
              command: "setTransition",
              args: [t.transition]
            }), jt(n.light, t.light) || r.push({
              command: "setLight",
              args: [t.light]
            }), jt(n.terrain, t.terrain) || r.push({
              command: "setTerrain",
              args: [t.terrain]
            }), jt(n.sky, t.sky) || r.push({
              command: "setSky",
              args: [t.sky]
            }), jt(n.projection, t.projection) || r.push({
              command: "setProjection",
              args: [t.projection]
            });
            const o = {},
              c = [];
            (function(_, v, w, S) {
              let A;
              for (A in v = v || {}, _ = _ || {}) Object.prototype.hasOwnProperty.call(_, A) && (Object.prototype.hasOwnProperty.call(v, A) || Dr(A, w, S));
              for (A in v) Object.prototype.hasOwnProperty.call(v, A) && (Object.prototype.hasOwnProperty.call(_, A) ? jt(_[A], v[A]) || (_[A].type === "geojson" && v[A].type === "geojson" && $r(_, v, A) ? fr(w, {
                command: "setGeoJSONSourceData",
                args: [A, v[A].data]
              }) : jr(A, v, w, S)) : Ur(A, v, w))
            })(n.sources, t.sources, c, o);
            const m = [];
            n.layers && n.layers.forEach((_ => {
              "source" in _ && o[_.source] ? r.push({
                command: "removeLayer",
                args: [_.id]
              }) : m.push(_)
            })), r = r.concat(c), (function(_, v, w) {
              v = v || [];
              const S = (_ = _ || []).map(Fr),
                A = v.map(Fr),
                L = _.reduce(vn, {}),
                j = v.reduce(vn, {}),
                q = S.slice(),
                $ = Object.create(null);
              let J, te, he, je, be;
              for (let Me = 0, et = 0; Me < S.length; Me++) J = S[Me], Object.prototype.hasOwnProperty.call(j, J) ? et++ : (fr(w, {
                command: "removeLayer",
                args: [J]
              }), q.splice(q.indexOf(J, et), 1));
              for (let Me = 0, et = 0; Me < A.length; Me++) J = A[A.length - 1 - Me], q[q.length - 1 - Me] !== J && (Object.prototype.hasOwnProperty.call(L, J) ? (fr(w, {
                command: "removeLayer",
                args: [J]
              }), q.splice(q.lastIndexOf(J, q.length - et), 1)) : et++, je = q[q.length - Me], fr(w, {
                command: "addLayer",
                args: [j[J], je]
              }), q.splice(q.length - Me, 0, J), $[J] = !0);
              for (let Me = 0; Me < A.length; Me++)
                if (J = A[Me], te = L[J], he = j[J], !$[J] && !jt(te, he))
                  if (jt(te.source, he.source) && jt(te["source-layer"], he["source-layer"]) && jt(te.type, he.type)) {
                    for (be in Br(te.layout, he.layout, w, J, null, "setLayoutProperty"), Br(te.paint, he.paint, w, J, null, "setPaintProperty"), jt(te.filter, he.filter) || fr(w, {
                        command: "setFilter",
                        args: [J, he.filter]
                      }), jt(te.minzoom, he.minzoom) && jt(te.maxzoom, he.maxzoom) || fr(w, {
                        command: "setLayerZoomRange",
                        args: [J, he.minzoom, he.maxzoom]
                      }), te) Object.prototype.hasOwnProperty.call(te, be) && be !== "layout" && be !== "paint" && be !== "filter" && be !== "metadata" && be !== "minzoom" && be !== "maxzoom" && (be.indexOf("paint.") === 0 ? Br(te[be], he[be], w, J, be.slice(6), "setPaintProperty") : jt(te[be], he[be]) || fr(w, {
                      command: "setLayerProperty",
                      args: [J, be, he[be]]
                    }));
                    for (be in he) Object.prototype.hasOwnProperty.call(he, be) && !Object.prototype.hasOwnProperty.call(te, be) && be !== "layout" && be !== "paint" && be !== "filter" && be !== "metadata" && be !== "minzoom" && be !== "maxzoom" && (be.indexOf("paint.") === 0 ? Br(te[be], he[be], w, J, be.slice(6), "setPaintProperty") : jt(te[be], he[be]) || fr(w, {
                      command: "setLayerProperty",
                      args: [J, be, he[be]]
                    }))
                  } else fr(w, {
                    command: "removeLayer",
                    args: [J]
                  }), je = q[q.lastIndexOf(J) + 1], fr(w, {
                    command: "addLayer",
                    args: [he, je]
                  })
            })(m, t.layers, r)
          } catch (o) {
            console.warn("Unable to compute style diff:", o), r = [{
              command: "setStyle",
              args: [t]
            }]
          }
          return r
        }, b.bM = function(n) {
          const t = [],
            r = n.id;
          return r === void 0 && t.push({
            message: `layers.${r}: missing required property "id"`
          }), n.render === void 0 && t.push({
            message: `layers.${r}: missing required method "render"`
          }), n.renderingMode && n.renderingMode !== "2d" && n.renderingMode !== "3d" && t.push({
            message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
          }), t
        }, b.bN = St, b.bO = vt, b.bP = class extends Ji {
          constructor(n, t) {
            super(n, t), this.current = 0
          }
          set(n) {
            this.current !== n && (this.current = n, this.gl.uniform1i(this.location, n))
          }
        }, b.bQ = _i, b.bR = class extends Ji {
          constructor(n, t) {
            super(n, t), this.current = ga
          }
          set(n) {
            if (n[12] !== this.current[12] || n[0] !== this.current[0]) return this.current = n, void this.gl.uniformMatrix4fv(this.location, !1, n);
            for (let t = 1; t < 16; t++)
              if (n[t] !== this.current[t]) {
                this.current = n, this.gl.uniformMatrix4fv(this.location, !1, n);
                break
              }
          }
        }, b.bS = ci, b.bT = class extends Ji {
          constructor(n, t) {
            super(n, t), this.current = [0, 0, 0]
          }
          set(n) {
            n[0] === this.current[0] && n[1] === this.current[1] && n[2] === this.current[2] || (this.current = n, this.gl.uniform3f(this.location, n[0], n[1], n[2]))
          }
        }, b.bU = class extends Ji {
          constructor(n, t) {
            super(n, t), this.current = [0, 0]
          }
          set(n) {
            n[0] === this.current[0] && n[1] === this.current[1] || (this.current = n, this.gl.uniform2f(this.location, n[0], n[1]))
          }
        }, b.bV = De, b.bW = function(n, t) {
          var r = Math.sin(t),
            o = Math.cos(t);
          return n[0] = o, n[1] = r, n[2] = 0, n[3] = -r, n[4] = o, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n
        }, b.bX = function(n, t, r) {
          var o = t[0],
            c = t[1],
            m = t[2];
          return n[0] = o * r[0] + c * r[3] + m * r[6], n[1] = o * r[1] + c * r[4] + m * r[7], n[2] = o * r[2] + c * r[5] + m * r[8], n
        }, b.bY = function(n, t, r, o, c, m, _) {
          var v = 1 / (t - r),
            w = 1 / (o - c),
            S = 1 / (m - _);
          return n[0] = -2 * v, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * w, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * S, n[11] = 0, n[12] = (t + r) * v, n[13] = (c + o) * w, n[14] = (_ + m) * S, n[15] = 1, n
        }, b.bZ = class extends Ji {
          constructor(n, t) {
            super(n, t), this.current = new Array
          }
          set(n) {
            if (n != this.current) {
              this.current = n;
              const t = new Float32Array(4 * n.length);
              for (let r = 0; r < n.length; r++) t[4 * r] = n[r].r, t[4 * r + 1] = n[r].g, t[4 * r + 2] = n[r].b, t[4 * r + 3] = n[r].a;
              this.gl.uniform4fv(this.location, t)
            }
          }
        }, b.b_ = class extends Ji {
          constructor(n, t) {
            super(n, t), this.current = new Array
          }
          set(n) {
            if (n != this.current) {
              this.current = n;
              const t = new Float32Array(n);
              this.gl.uniform1fv(this.location, t)
            }
          }
        }, b.ba = function() {
          return new Float64Array(16)
        }, b.bb = function(n, t, r) {
          const o = new Float64Array(4);
          return K(o, n, t - 90, r), o
        }, b.bc = function(n, t, r, o) {
          var c, m, _, v, w, S = t[0],
            A = t[1],
            L = t[2],
            j = t[3],
            q = r[0],
            $ = r[1],
            J = r[2],
            te = r[3];
          return (m = S * q + A * $ + L * J + j * te) < 0 && (m = -m, q = -q, $ = -$, J = -J, te = -te), 1 - m > Ie ? (c = Math.acos(m), _ = Math.sin(c), v = Math.sin((1 - o) * c) / _, w = Math.sin(o * c) / _) : (v = 1 - o, w = o), n[0] = v * S + w * q, n[1] = v * A + w * $, n[2] = v * L + w * J, n[3] = v * j + w * te, n
        }, b.bd = function(n) {
          const t = new Float64Array(9);
          var r, o, c, m, _, v, w, S, A, L, j, q, $, J, te, he, je, be;
          L = (c = (o = n)[0]) * (w = c + c), j = (m = o[1]) * w, $ = (_ = o[2]) * w, J = _ * (S = m + m), he = (v = o[3]) * w, je = v * S, be = v * (A = _ + _), (r = t)[0] = 1 - (q = m * S) - (te = _ * A), r[3] = j - be, r[6] = $ + je, r[1] = j + be, r[4] = 1 - L - te, r[7] = J - he, r[2] = $ - je, r[5] = J + he, r[8] = 1 - L - q;
          const Me = pr(-Math.asin(Lt(t[2], -1, 1)));
          let et, ct;
          return Math.hypot(t[5], t[8]) < .001 ? (et = 0, ct = -pr(Math.atan2(t[3], t[4]))) : (et = pr(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), ct = pr(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), {
            roll: et,
            pitch: Me + 90,
            bearing: ct
          }
        }, b.be = function(n, t) {
          return n.roll == t.roll && n.pitch == t.pitch && n.bearing == t.bearing
        }, b.bf = kr, b.bg = So, b.bh = sc, b.bi = Au, b.bj = oc, b.bk = lt, b.bl = ot, b.bm = pn, b.bn = function(n, t, r, o, c) {
          return lt(o, c, Lt((n - t) / (r - t), 0, 1))
        }, b.bo = qe, b.bp = function() {
          return new Float64Array(3)
        }, b.bq = function(n, t, r, o) {
          return n[0] = t[0] + r[0] * o, n[1] = t[1] + r[1] * o, n[2] = t[2] + r[2] * o, n
        }, b.br = K, b.bs = function(n, t, r) {
          var o = r[0],
            c = r[1],
            m = r[2],
            _ = t[0],
            v = t[1],
            w = t[2],
            S = c * w - m * v,
            A = m * _ - o * w,
            L = o * v - c * _,
            j = c * L - m * A,
            q = m * S - o * L,
            $ = o * A - c * S,
            J = 2 * r[3];
          return A *= J, L *= J, q *= 2, $ *= 2, n[0] = _ + (S *= J) + (j *= 2), n[1] = v + A + q, n[2] = w + L + $, n
        }, b.bt = function(n, t, r) {
          const o = (c = [n[0], n[1], n[2], t[0], t[1], t[2], r[0], r[1], r[2]])[0] * ((A = c[8]) * (_ = c[4]) - (v = c[5]) * (S = c[7])) + c[1] * (-A * (m = c[3]) + v * (w = c[6])) + c[2] * (S * m - _ * w);
          var c, m, _, v, w, S, A;
          if (o === 0) return null;
          const L = We([], [t[0], t[1], t[2]], [r[0], r[1], r[2]]),
            j = We([], [r[0], r[1], r[2]], [n[0], n[1], n[2]]),
            q = We([], [n[0], n[1], n[2]], [t[0], t[1], t[2]]),
            $ = Ce([], L, -n[3]);
          return Ue($, $, Ce([], j, -t[3])), Ue($, $, Ce([], q, -r[3])), Ce($, $, 1 / o), $
        }, b.bu = Rf, b.bv = function() {
          return new Float64Array(4)
        }, b.bw = function(n, t, r, o) {
          var c = [],
            m = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], m[0] = c[0] * Math.cos(o) - c[1] * Math.sin(o), m[1] = c[0] * Math.sin(o) + c[1] * Math.cos(o), m[2] = c[2], n[0] = m[0] + r[0], n[1] = m[1] + r[1], n[2] = m[2] + r[2], n
        }, b.bx = function(n, t, r, o) {
          var c = [],
            m = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], m[0] = c[0], m[1] = c[1] * Math.cos(o) - c[2] * Math.sin(o), m[2] = c[1] * Math.sin(o) + c[2] * Math.cos(o), n[0] = m[0] + r[0], n[1] = m[1] + r[1], n[2] = m[2] + r[2], n
        }, b.by = function(n, t, r, o) {
          var c = [],
            m = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], m[0] = c[2] * Math.sin(o) + c[0] * Math.cos(o), m[1] = c[1], m[2] = c[2] * Math.cos(o) - c[0] * Math.sin(o), n[0] = m[0] + r[0], n[1] = m[1] + r[1], n[2] = m[2] + r[2], n
        }, b.bz = function(n, t, r) {
          var o = Math.sin(r),
            c = Math.cos(r),
            m = t[0],
            _ = t[1],
            v = t[2],
            w = t[3],
            S = t[8],
            A = t[9],
            L = t[10],
            j = t[11];
          return t !== n && (n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = m * c - S * o, n[1] = _ * c - A * o, n[2] = v * c - L * o, n[3] = w * c - j * o, n[8] = m * o + S * c, n[9] = _ * o + A * c, n[10] = v * o + L * c, n[11] = w * o + j * c, n
        }, b.c = ue, b.c0 = b1, b.c1 = class extends i {}, b.c2 = mf, b.c3 = function(n) {
          return n <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
        }, b.c4 = q_, b.c5 = function(n, t, r) {
          var o = t[0],
            c = t[1],
            m = t[2],
            _ = r[3] * o + r[7] * c + r[11] * m + r[15];
          return n[0] = (r[0] * o + r[4] * c + r[8] * m + r[12]) / (_ = _ || 1), n[1] = (r[1] * o + r[5] * c + r[9] * m + r[13]) / _, n[2] = (r[2] * o + r[6] * c + r[10] * m + r[14]) / _, n
        }, b.c6 = class extends yu {}, b.c7 = class extends M {}, b.c8 = function(n, t) {
          return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] && n[4] === t[4] && n[5] === t[5] && n[6] === t[6] && n[7] === t[7] && n[8] === t[8] && n[9] === t[9] && n[10] === t[10] && n[11] === t[11] && n[12] === t[12] && n[13] === t[13] && n[14] === t[14] && n[15] === t[15]
        }, b.c9 = function(n, t) {
          var r = n[0],
            o = n[1],
            c = n[2],
            m = n[3],
            _ = n[4],
            v = n[5],
            w = n[6],
            S = n[7],
            A = n[8],
            L = n[9],
            j = n[10],
            q = n[11],
            $ = n[12],
            J = n[13],
            te = n[14],
            he = n[15],
            je = t[0],
            be = t[1],
            Me = t[2],
            et = t[3],
            ct = t[4],
            Et = t[5],
            ar = t[6],
            Jt = t[7],
            tr = t[8],
            Rr = t[9],
            Qt = t[10],
            rr = t[11],
            yt = t[12],
            Yr = t[13],
            on = t[14],
            Zr = t[15];
          return Math.abs(r - je) <= Ie * Math.max(1, Math.abs(r), Math.abs(je)) && Math.abs(o - be) <= Ie * Math.max(1, Math.abs(o), Math.abs(be)) && Math.abs(c - Me) <= Ie * Math.max(1, Math.abs(c), Math.abs(Me)) && Math.abs(m - et) <= Ie * Math.max(1, Math.abs(m), Math.abs(et)) && Math.abs(_ - ct) <= Ie * Math.max(1, Math.abs(_), Math.abs(ct)) && Math.abs(v - Et) <= Ie * Math.max(1, Math.abs(v), Math.abs(Et)) && Math.abs(w - ar) <= Ie * Math.max(1, Math.abs(w), Math.abs(ar)) && Math.abs(S - Jt) <= Ie * Math.max(1, Math.abs(S), Math.abs(Jt)) && Math.abs(A - tr) <= Ie * Math.max(1, Math.abs(A), Math.abs(tr)) && Math.abs(L - Rr) <= Ie * Math.max(1, Math.abs(L), Math.abs(Rr)) && Math.abs(j - Qt) <= Ie * Math.max(1, Math.abs(j), Math.abs(Qt)) && Math.abs(q - rr) <= Ie * Math.max(1, Math.abs(q), Math.abs(rr)) && Math.abs($ - yt) <= Ie * Math.max(1, Math.abs($), Math.abs(yt)) && Math.abs(J - Yr) <= Ie * Math.max(1, Math.abs(J), Math.abs(Yr)) && Math.abs(te - on) <= Ie * Math.max(1, Math.abs(te), Math.abs(on)) && Math.abs(he - Zr) <= Ie * Math.max(1, Math.abs(he), Math.abs(Zr))
        }, b.cA = function(n, t) {
          V.REGISTERED_PROTOCOLS[n] = t
        }, b.cB = function(n) {
          delete V.REGISTERED_PROTOCOLS[n]
        }, b.cC = function(n, t) {
          const r = {};
          for (let c = 0; c < n.length; c++) {
            const m = t && t[n[c].id] || rf(n[c]);
            t && (t[n[c].id] = m);
            let _ = r[m];
            _ || (_ = r[m] = []), _.push(n[c])
          }
          const o = [];
          for (const c in r) o.push(r[c]);
          return o
        }, b.cD = hr, b.cE = Ng, b.cF = Vg, b.cG = vg, b.cH = function(n) {
          n.bucket.createArrays(), n.bucket.tilePixelRatio = ae / (512 * n.bucket.overscaling), n.bucket.compareText = {}, n.bucket.iconsNeedLinear = !1;
          const t = n.bucket.layers[0],
            r = t.layout,
            o = t._unevaluatedLayout._values,
            c = {
              layoutIconSize: o["icon-size"].possiblyEvaluate(new Un(n.bucket.zoom + 1), n.canonical),
              layoutTextSize: o["text-size"].possiblyEvaluate(new Un(n.bucket.zoom + 1), n.canonical),
              textMaxSize: o["text-size"].possiblyEvaluate(new Un(18))
            };
          if (n.bucket.textSizeData.kind === "composite") {
            const {
              minZoom: S,
              maxZoom: A
            } = n.bucket.textSizeData;
            c.compositeTextSizes = [o["text-size"].possiblyEvaluate(new Un(S), n.canonical), o["text-size"].possiblyEvaluate(new Un(A), n.canonical)]
          }
          if (n.bucket.iconSizeData.kind === "composite") {
            const {
              minZoom: S,
              maxZoom: A
            } = n.bucket.iconSizeData;
            c.compositeIconSizes = [o["icon-size"].possiblyEvaluate(new Un(S), n.canonical), o["icon-size"].possiblyEvaluate(new Un(A), n.canonical)]
          }
          const m = r.get("text-line-height") * bi,
            _ = r.get("text-rotation-alignment") !== "viewport" && r.get("symbol-placement") !== "point",
            v = r.get("text-keep-upright"),
            w = r.get("text-size");
          for (const S of n.bucket.features) {
            const A = r.get("text-font").evaluate(S, {}, n.canonical).join(","),
              L = w.evaluate(S, {}, n.canonical),
              j = c.layoutTextSize.evaluate(S, {}, n.canonical),
              q = c.layoutIconSize.evaluate(S, {}, n.canonical),
              $ = {
                horizontal: {},
                vertical: void 0
              },
              J = S.text;
            let te, he = [0, 0];
            if (J) {
              const Me = J.toString(),
                et = r.get("text-letter-spacing").evaluate(S, {}, n.canonical) * bi,
                ct = sf(Me) ? et : 0,
                Et = r.get("text-anchor").evaluate(S, {}, n.canonical),
                ar = Qg(t, S, n.canonical);
              if (!ar) {
                const Qt = r.get("text-radial-offset").evaluate(S, {}, n.canonical);
                he = Qt ? Kg(Et, [Qt * bi, Of]) : r.get("text-offset").evaluate(S, {}, n.canonical).map((rr => rr * bi))
              }
              let Jt = _ ? "center" : r.get("text-justify").evaluate(S, {}, n.canonical);
              const tr = r.get("symbol-placement") === "point" ? r.get("text-max-width").evaluate(S, {}, n.canonical) * bi : 1 / 0,
                Rr = () => {
                  n.bucket.allowVerticalPlacement && Hl(Me) && ($.vertical = Vd(J, n.glyphMap, n.glyphPositions, n.imagePositions, A, tr, m, Et, "left", ct, he, b.ao.vertical, !0, j, L))
                };
              if (!_ && ar) {
                const Qt = new Set;
                if (Jt === "auto")
                  for (let yt = 0; yt < ar.values.length; yt += 2) Qt.add(jf(ar.values[yt]));
                else Qt.add(Jt);
                let rr = !1;
                for (const yt of Qt)
                  if (!$.horizontal[yt])
                    if (rr) $.horizontal[yt] = $.horizontal[0];
                    else {
                      const Yr = Vd(J, n.glyphMap, n.glyphPositions, n.imagePositions, A, tr, m, "center", yt, ct, he, b.ao.horizontal, !1, j, L);
                      Yr && ($.horizontal[yt] = Yr, rr = Yr.positionedLines.length === 1)
                    } Rr()
              } else {
                Jt === "auto" && (Jt = jf(Et));
                const Qt = Vd(J, n.glyphMap, n.glyphPositions, n.imagePositions, A, tr, m, Et, Jt, ct, he, b.ao.horizontal, !1, j, L);
                Qt && ($.horizontal[Jt] = Qt), Rr(), Hl(Me) && _ && v && ($.vertical = Vd(J, n.glyphMap, n.glyphPositions, n.imagePositions, A, tr, m, Et, Jt, ct, he, b.ao.vertical, !1, j, L))
              }
            }
            let je = !1;
            if (S.icon && S.icon.name) {
              const Me = n.imageMap[S.icon.name];
              Me && (te = q1(n.imagePositions[S.icon.name], r.get("icon-offset").evaluate(S, {}, n.canonical), r.get("icon-anchor").evaluate(S, {}, n.canonical)), je = !!Me.sdf, n.bucket.sdfIcons === void 0 ? n.bucket.sdfIcons = je : n.bucket.sdfIcons !== je && Bt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Me.pixelRatio !== n.bucket.pixelRatio || r.get("icon-rotate").constantOr(1) !== 0) && (n.bucket.iconsNeedLinear = !0))
            }
            const be = tv($.horizontal) || $.vertical;
            n.bucket.iconsInText = !!be && be.iconsInText, (be || te) && ax(n.bucket, S, $, te, n.imageMap, c, j, q, he, je, n.canonical, n.subdivisionGranularity)
          }
          n.showCollisionBoxes && n.bucket.generateCollisionDebugBuffers()
        }, b.cI = Tf, b.cJ = bf, b.cK = Cf, b.cL = ig, b.cM = If, b.cN = class {
          constructor(n) {
            this._marks = {
              start: [n.url, "start"].join("#"),
              end: [n.url, "end"].join("#"),
              measure: n.url.toString()
            }, performance.mark(this._marks.start)
          }
          finish() {
            performance.mark(this._marks.end);
            let n = performance.getEntriesByName(this._marks.measure);
            return n.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), n = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), n
          }
        }, b.cO = function(n, t, r, o, c) {
          return s(this, void 0, void 0, (function*() {
            if (xe()) try {
              return yield Ft(n, t, r, o, c)
            } catch {}
            return (function(m, _, v, w, S) {
              const A = m.width,
                L = m.height;
              cr && ur || (cr = new OffscreenCanvas(A, L), ur = cr.getContext("2d", {
                willReadFrequently: !0
              })), cr.width = A, cr.height = L, ur.drawImage(m, 0, 0, A, L);
              const j = ur.getImageData(_, v, w, S);
              return ur.clearRect(0, 0, A, L), j.data
            })(n, t, r, o, c)
          }))
        }, b.cP = G_, b.cQ = O, b.cR = ng, b.cS = lc, b.cT = Qs, b.cU = function(n, t) {
          const r = new Map;
          if (n != null)
            if (n.type === "Feature") r.set(Fu(n, t), n);
            else
              for (const o of n.features) r.set(Fu(o, t), o);
          return r
        }, b.cV = function(n, t) {
          if (n == null) return !0;
          if (n.type === "Feature") return Fu(n, t) != null;
          if (n.type === "FeatureCollection") {
            const r = new Set;
            for (const o of n.features) {
              const c = Fu(o, t);
              if (c == null || r.has(c)) return !1;
              r.add(c)
            }
            return !0
          }
          return !1
        }, b.cW = function(n, t, r) {
          var o, c, m, _;
          if (t.removeAll && n.clear(), t.remove)
            for (const v of t.remove) n.delete(v);
          if (t.add)
            for (const v of t.add) {
              const w = Fu(v, r);
              w != null && n.set(w, v)
            }
          if (t.update)
            for (const v of t.update) {
              let w = n.get(v.id);
              if (w == null) continue;
              const S = !v.removeAllProperties && (((o = v.removeProperties) === null || o === void 0 ? void 0 : o.length) > 0 || ((c = v.addOrUpdateProperties) === null || c === void 0 ? void 0 : c.length) > 0);
              if ((v.newGeometry || v.removeAllProperties || S) && (w = Object.assign({}, w), n.set(v.id, w), S && (w.properties = Object.assign({}, w.properties))), v.newGeometry && (w.geometry = v.newGeometry), v.removeAllProperties) w.properties = {};
              else if (((m = v.removeProperties) === null || m === void 0 ? void 0 : m.length) > 0)
                for (const A of v.removeProperties) Object.prototype.hasOwnProperty.call(w.properties, A) && delete w.properties[A];
              if (((_ = v.addOrUpdateProperties) === null || _ === void 0 ? void 0 : _.length) > 0)
                for (const {
                    key: A,
                    value: L
                  }
                  of v.addOrUpdateProperties) w.properties[A] = L
            }
        }, b.cX = Ma, b.ca = function(n, t) {
          return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n
        }, b.cb = n => n.type === "symbol", b.cc = n => n.type === "circle", b.cd = n => n.type === "heatmap", b.ce = n => n.type === "line", b.cf = n => n.type === "fill", b.cg = n => n.type === "fill-extrusion", b.ch = n => n.type === "hillshade", b.ci = n => n.type === "color-relief", b.cj = n => n.type === "raster", b.ck = n => n.type === "background", b.cl = n => n.type === "custom", b.cm = dt, b.cn = function(n, t, r) {
          const o = le(t.x - r.x, t.y - r.y),
            c = le(n.x - r.x, n.y - r.y);
          var m, _;
          return pr(Math.atan2(o[0] * c[1] - o[1] * c[0], (m = o)[0] * (_ = c)[0] + m[1] * _[1]))
        }, b.co = Pt, b.cp = function(n, t) {
          return Vr[t] && (n instanceof MouseEvent || n instanceof WheelEvent)
        }, b.cq = function(n, t) {
          return vr[t] && "touches" in n
        }, b.cr = function(n) {
          return vr[n] || Vr[n]
        }, b.cs = function(n, t, r) {
          var o = t[0],
            c = t[1];
          return n[0] = r[0] * o + r[4] * c + r[12], n[1] = r[1] * o + r[5] * c + r[13], n
        }, b.ct = function(n, t) {
          const {
            x: r,
            y: o
          } = Bu.fromLngLat(t);
          return !(n < 0 || n > 25 || o < 0 || o >= 1 || r < 0 || r >= 1)
        }, b.cu = function(n, t) {
          return n[0] = t[0], n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = t[1], n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = t[2], n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n
        }, b.cv = class extends Is {}, b.cw = sx, b.cy = function(n) {
          return n.message === qr
        }, b.cz = oe, b.d = Oe, b.e = ut, b.f = n => s(void 0, void 0, void 0, (function*() {
          if (n.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(n)], {
            type: "image/png"
          });
          try {
            return createImageBitmap(t)
          } catch (r) {
            throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
          }
        })), b.g = U, b.h = n => new Promise(((t, r) => {
          const o = new Image;
          o.onload = () => {
            t(o), URL.revokeObjectURL(o.src), o.onload = null, window.requestAnimationFrame((() => {
              o.src = Zt
            }))
          }, o.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const c = new Blob([new Uint8Array(n)], {
            type: "image/png"
          });
          o.src = n.byteLength ? URL.createObjectURL(c) : Zt
        })), b.i = Ot, b.j = (n, t) => Se(ut(n, {
          type: "json"
        }), t), b.k = it, b.l = _t, b.m = Se, b.n = (n, t) => Se(ut(n, {
          type: "arrayBuffer"
        }), t), b.o = function(n) {
          return new If(n).readFields(z1, [])
        }, b.p = gg, b.q = Su, b.r = Wi, b.s = Er, b.t = Ed, b.u = _n, b.v = we, b.w = Bt, b.x = nf, b.y = ol, b.z = ws
      })), k("worker", ["./shared"], (function(b) {
        class s {
          constructor(V) {
            this.keyCache = {}, V && this.replace(V)
          }
          replace(V) {
            this._layerConfigs = {}, this._layers = {}, this.update(V, [])
          }
          update(V, U) {
            for (const oe of V) {
              this._layerConfigs[oe.id] = oe;
              const me = this._layers[oe.id] = b.bJ(oe);
              me._featureFilter = b.aa(me.filter), this.keyCache[oe.id] && delete this.keyCache[oe.id]
            }
            for (const oe of U) delete this.keyCache[oe], delete this._layerConfigs[oe], delete this._layers[oe];
            this.familiesBySource = {};
            const Y = b.cC(Object.values(this._layerConfigs), this.keyCache);
            for (const oe of Y) {
              const me = oe.map((it => this._layers[it.id])),
                Se = me[0];
              if (Se.visibility === "none") continue;
              const Oe = Se.source || "";
              let ze = this.familiesBySource[Oe];
              ze || (ze = this.familiesBySource[Oe] = {});
              const Ke = Se.sourceLayer || "_geojsonTileLayer";
              let _t = ze[Ke];
              _t || (_t = ze[Ke] = []), _t.push(me)
            }
          }
        }
        class F {
          constructor(V) {
            const U = {},
              Y = [];
            for (const Oe in V) {
              const ze = V[Oe],
                Ke = U[Oe] = {};
              for (const _t in ze) {
                const it = ze[+_t];
                if (!it || it.bitmap.width === 0 || it.bitmap.height === 0) continue;
                const qt = {
                  x: 0,
                  y: 0,
                  w: it.bitmap.width + 2,
                  h: it.bitmap.height + 2
                };
                Y.push(qt), Ke[_t] = {
                  rect: qt,
                  metrics: it.metrics
                }
              }
            }
            const {
              w: oe,
              h: me
            } = b.p(Y), Se = new b.q({
              width: oe || 1,
              height: me || 1
            });
            for (const Oe in V) {
              const ze = V[Oe];
              for (const Ke in ze) {
                const _t = ze[+Ke];
                if (!_t || _t.bitmap.width === 0 || _t.bitmap.height === 0) continue;
                const it = U[Oe][Ke].rect;
                b.q.copy(_t.bitmap, Se, {
                  x: 0,
                  y: 0
                }, {
                  x: it.x + 1,
                  y: it.y + 1
                }, _t.bitmap)
              }
            }
            this.image = Se, this.positions = U
          }
        }
        b.cD("GlyphAtlas", F);
        class O {
          constructor(V) {
            this.tileID = new b.Z(V.tileID.overscaledZ, V.tileID.wrap, V.tileID.canonical.z, V.tileID.canonical.x, V.tileID.canonical.y), this.uid = V.uid, this.zoom = V.zoom, this.pixelRatio = V.pixelRatio, this.tileSize = V.tileSize, this.source = V.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = V.showCollisionBoxes, this.collectResourceTiming = !!V.collectResourceTiming, this.returnDependencies = !!V.returnDependencies, this.promoteId = V.promoteId, this.inFlightDependencies = [], this.globalState = V.globalState
          }
          parse(V, U, Y, oe, me) {
            return b._(this, void 0, void 0, (function*() {
              this.status = "parsing", this.data = V, this.collisionBoxArray = new b.a8;
              const Se = new b.cE(Object.keys(V.layers).sort()),
                Oe = new b.cF(this.tileID, this.promoteId);
              Oe.bucketLayerIDs = [];
              const ze = {},
                Ke = {
                  featureIndex: Oe,
                  iconDependencies: {},
                  patternDependencies: {},
                  glyphDependencies: {},
                  availableImages: Y,
                  subdivisionGranularity: me
                },
                _t = U.familiesBySource[this.source];
              for (const Br in _t) {
                const Fr = V.layers[Br];
                if (!Fr) continue;
                Fr.version === 1 && b.w(`Vector tile source "${this.source}" layer "${Br}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const vn = Se.encode(Br),
                  bt = [];
                for (let bn = 0; bn < Fr.length; bn++) {
                  const fn = Fr.feature(bn),
                    $n = Oe.getId(fn, Br);
                  bt.push({
                    feature: fn,
                    id: $n,
                    index: bn,
                    sourceLayerIndex: vn
                  })
                }
                for (const bn of _t[Br]) {
                  const fn = bn[0];
                  fn.source !== this.source && b.w(`layer.source = ${fn.source} does not equal this.source = ${this.source}`), fn.minzoom && this.zoom < Math.floor(fn.minzoom) || fn.maxzoom && this.zoom >= fn.maxzoom || fn.visibility !== "none" && (G(bn, this.zoom, Y), (ze[fn.id] = fn.createBucket({
                    index: Oe.bucketLayerIDs.length,
                    layers: bn,
                    zoom: this.zoom,
                    pixelRatio: this.pixelRatio,
                    overscaling: this.overscaling,
                    collisionBoxArray: this.collisionBoxArray,
                    sourceLayerIndex: vn,
                    sourceID: this.source,
                    globalState: this.globalState
                  })).populate(bt, Ke, this.tileID.canonical), Oe.bucketLayerIDs.push(bn.map(($n => $n.id))))
                }
              }
              const it = b.bN(Ke.glyphDependencies, (Br => Object.keys(Br).map(Number)));
              this.inFlightDependencies.forEach((Br => Br == null ? void 0 : Br.abort())), this.inFlightDependencies = [];
              let qt = Promise.resolve({});
              if (Object.keys(it).length) {
                const Br = new AbortController;
                this.inFlightDependencies.push(Br), qt = oe.sendAsync({
                  type: "GG",
                  data: {
                    stacks: it,
                    source: this.source,
                    tileID: this.tileID,
                    type: "glyphs"
                  }
                }, Br)
              }
              const we = Object.keys(Ke.iconDependencies);
              let Mt = Promise.resolve({});
              if (we.length) {
                const Br = new AbortController;
                this.inFlightDependencies.push(Br), Mt = oe.sendAsync({
                  type: "GI",
                  data: {
                    icons: we,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                  }
                }, Br)
              }
              const Ut = Object.keys(Ke.patternDependencies);
              let jt = Promise.resolve({});
              if (Ut.length) {
                const Br = new AbortController;
                this.inFlightDependencies.push(Br), jt = oe.sendAsync({
                  type: "GI",
                  data: {
                    icons: Ut,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                  }
                }, Br)
              }
              const [fr, Ur, Dr] = yield Promise.all([qt, Mt, jt]), jr = new F(fr), $r = new b.cG(Ur, Dr);
              for (const Br in ze) {
                const Fr = ze[Br];
                Fr instanceof b.a9 ? (G(Fr.layers, this.zoom, Y), b.cH({
                  bucket: Fr,
                  glyphMap: fr,
                  glyphPositions: jr.positions,
                  imageMap: Ur,
                  imagePositions: $r.iconPositions,
                  showCollisionBoxes: this.showCollisionBoxes,
                  canonical: this.tileID.canonical,
                  subdivisionGranularity: Ke.subdivisionGranularity
                })) : Fr.hasPattern && (Fr instanceof b.cI || Fr instanceof b.cJ || Fr instanceof b.cK) && (G(Fr.layers, this.zoom, Y), Fr.addFeatures(Ke, this.tileID.canonical, $r.patternPositions))
              }
              return this.status = "done", {
                buckets: Object.values(ze).filter((Br => !Br.isEmpty())),
                featureIndex: Oe,
                collisionBoxArray: this.collisionBoxArray,
                glyphAtlasImage: jr.image,
                imageAtlas: $r,
                glyphMap: this.returnDependencies ? fr : null,
                iconMap: this.returnDependencies ? Ur : null,
                glyphPositions: this.returnDependencies ? jr.positions : null
              }
            }))
          }
        }

        function G(ue, V, U) {
          const Y = new b.F(V);
          for (const oe of ue) oe.recalculate(Y, U)
        }
        class X {
          constructor(V, U, Y) {
            this.actor = V, this.layerIndex = U, this.availableImages = Y, this.fetching = {}, this.loading = {}, this.loaded = {}
          }
          loadVectorTile(V, U) {
            return b._(this, void 0, void 0, (function*() {
              const Y = yield b.n(V.request, U);
              try {
                return {
                  vectorTile: new b.cL(new b.cM(Y.data)),
                  rawData: Y.data,
                  cacheControl: Y.cacheControl,
                  expires: Y.expires
                }
              } catch (oe) {
                const me = new Uint8Array(Y.data);
                let Se = `Unable to parse the tile at ${V.request.url}, `;
                throw Se += me[0] === 31 && me[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${oe.message}`, new Error(Se)
              }
            }))
          }
          loadTile(V) {
            return b._(this, void 0, void 0, (function*() {
              const U = V.uid,
                Y = !!(V && V.request && V.request.collectResourceTiming) && new b.cN(V.request),
                oe = new O(V);
              this.loading[U] = oe;
              const me = new AbortController;
              oe.abort = me;
              try {
                const Se = yield this.loadVectorTile(V, me);
                if (delete this.loading[U], !Se) return null;
                const Oe = Se.rawData,
                  ze = {};
                Se.expires && (ze.expires = Se.expires), Se.cacheControl && (ze.cacheControl = Se.cacheControl);
                const Ke = {};
                if (Y) {
                  const it = Y.finish();
                  it && (Ke.resourceTiming = JSON.parse(JSON.stringify(it)))
                }
                oe.vectorTile = Se.vectorTile;
                const _t = oe.parse(Se.vectorTile, this.layerIndex, this.availableImages, this.actor, V.subdivisionGranularity);
                this.loaded[U] = oe, this.fetching[U] = {
                  rawTileData: Oe,
                  cacheControl: ze,
                  resourceTiming: Ke
                };
                try {
                  const it = yield _t;
                  return b.e({
                    rawTileData: Oe.slice(0)
                  }, it, ze, Ke)
                } finally {
                  delete this.fetching[U]
                }
              } catch (Se) {
                throw delete this.loading[U], oe.status = "done", this.loaded[U] = oe, Se
              }
            }))
          }
          reloadTile(V) {
            return b._(this, void 0, void 0, (function*() {
              const U = V.uid;
              if (!this.loaded || !this.loaded[U]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const Y = this.loaded[U];
              if (Y.showCollisionBoxes = V.showCollisionBoxes, Y.globalState = V.globalState, Y.status === "parsing") {
                const oe = yield Y.parse(Y.vectorTile, this.layerIndex, this.availableImages, this.actor, V.subdivisionGranularity);
                let me;
                if (this.fetching[U]) {
                  const {
                    rawTileData: Se,
                    cacheControl: Oe,
                    resourceTiming: ze
                  } = this.fetching[U];
                  delete this.fetching[U], me = b.e({
                    rawTileData: Se.slice(0)
                  }, oe, Oe, ze)
                } else me = oe;
                return me
              }
              if (Y.status === "done" && Y.vectorTile) return Y.parse(Y.vectorTile, this.layerIndex, this.availableImages, this.actor, V.subdivisionGranularity)
            }))
          }
          abortTile(V) {
            return b._(this, void 0, void 0, (function*() {
              const U = this.loading,
                Y = V.uid;
              U && U[Y] && U[Y].abort && (U[Y].abort.abort(), delete U[Y])
            }))
          }
          removeTile(V) {
            return b._(this, void 0, void 0, (function*() {
              this.loaded && this.loaded[V.uid] && delete this.loaded[V.uid]
            }))
          }
        }
        class Q {
          constructor() {
            this.loaded = {}
          }
          loadTile(V) {
            return b._(this, void 0, void 0, (function*() {
              const {
                uid: U,
                encoding: Y,
                rawImageData: oe,
                redFactor: me,
                greenFactor: Se,
                blueFactor: Oe,
                baseShift: ze
              } = V, Ke = oe.width + 2, _t = oe.height + 2, it = b.b(oe) ? new b.R({
                width: Ke,
                height: _t
              }, yield b.cO(oe, -1, -1, Ke, _t)) : oe, qt = new b.cP(U, it, Y, me, Se, Oe, ze);
              return this.loaded = this.loaded || {}, this.loaded[U] = qt, qt
            }))
          }
          removeTile(V) {
            const U = this.loaded,
              Y = V.uid;
            U && U[Y] && delete U[Y]
          }
        }
        var W, de, _e = (function() {
            if (de) return W;

            function ue(U, Y) {
              if (U.length !== 0) {
                V(U[0], Y);
                for (var oe = 1; oe < U.length; oe++) V(U[oe], !Y)
              }
            }

            function V(U, Y) {
              for (var oe = 0, me = 0, Se = 0, Oe = U.length, ze = Oe - 1; Se < Oe; ze = Se++) {
                var Ke = (U[Se][0] - U[ze][0]) * (U[ze][1] + U[Se][1]),
                  _t = oe + Ke;
                me += Math.abs(oe) >= Math.abs(Ke) ? oe - _t + Ke : Ke - _t + oe, oe = _t
              }
              oe + me >= 0 != !!Y && U.reverse()
            }
            return de = 1, W = function U(Y, oe) {
              var me, Se = Y && Y.type;
              if (Se === "FeatureCollection")
                for (me = 0; me < Y.features.length; me++) U(Y.features[me], oe);
              else if (Se === "GeometryCollection")
                for (me = 0; me < Y.geometries.length; me++) U(Y.geometries[me], oe);
              else if (Se === "Feature") U(Y.geometry, oe);
              else if (Se === "Polygon") ue(Y.coordinates, oe);
              else if (Se === "MultiPolygon")
                for (me = 0; me < Y.coordinates.length; me++) ue(Y.coordinates[me], oe);
              return Y
            }
          })(),
          Ae = b.cQ(_e);
        class xe extends b.cS {
          constructor(V, U) {
            super(new b.cM, 0, U, [], []), this.feature = V, this.type = V.type, this.properties = V.tags ? V.tags : {}, "id" in V && (typeof V.id == "string" ? this.id = parseInt(V.id, 10) : typeof V.id != "number" || isNaN(V.id) || (this.id = V.id))
          }
          loadGeometry() {
            const V = [],
              U = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const Y of U) {
              const oe = [];
              for (const me of Y) oe.push(new b.P(me[0], me[1]));
              V.push(oe)
            }
            return V
          }
        }
        class Ie extends b.cR {
          constructor(V, U) {
            super(new b.cM), this.layers = {
              _geojsonTileLayer: this
            }, this.name = "_geojsonTileLayer", this.version = U ? U.version : 1, this.extent = U ? U.extent : 4096, this.length = V.length, this.features = V
          }
          feature(V) {
            return new xe(this.features[V], this.extent)
          }
        }

        function Pe(ue, V) {
          V.writeVarintField(15, ue.version || 1), V.writeStringField(1, ue.name || ""), V.writeVarintField(5, ue.extent || 4096);
          const U = {
            keys: [],
            values: [],
            keycache: {},
            valuecache: {}
          };
          for (let me = 0; me < ue.length; me++) U.feature = ue.feature(me), V.writeMessage(2, De, U);
          const Y = U.keys;
          for (const me of Y) V.writeStringField(3, me);
          const oe = U.values;
          for (const me of oe) V.writeMessage(4, Ue, me)
        }

        function De(ue, V) {
          if (!ue.feature) return;
          const U = ue.feature;
          U.id !== void 0 && V.writeVarintField(1, U.id), V.writeMessage(2, $e, ue), V.writeVarintField(3, U.type), V.writeMessage(4, Re, U)
        }

        function $e(ue, V) {
          var U;
          for (const Y in (U = ue.feature) == null ? void 0 : U.properties) {
            let oe = ue.feature.properties[Y],
              me = ue.keycache[Y];
            if (oe === null) continue;
            me === void 0 && (ue.keys.push(Y), me = ue.keys.length - 1, ue.keycache[Y] = me), V.writeVarint(me), typeof oe != "string" && typeof oe != "boolean" && typeof oe != "number" && (oe = JSON.stringify(oe));
            const Se = typeof oe + ":" + oe;
            let Oe = ue.valuecache[Se];
            Oe === void 0 && (ue.values.push(oe), Oe = ue.values.length - 1, ue.valuecache[Se] = Oe), V.writeVarint(Oe)
          }
        }

        function tt(ue, V) {
          return (V << 3) + (7 & ue)
        }

        function Ve(ue) {
          return ue << 1 ^ ue >> 31
        }

        function Re(ue, V) {
          const U = ue.loadGeometry(),
            Y = ue.type;
          let oe = 0,
            me = 0;
          for (const Se of U) {
            let Oe = 1;
            Y === 1 && (Oe = Se.length), V.writeVarint(tt(1, Oe));
            const ze = Y === 3 ? Se.length - 1 : Se.length;
            for (let Ke = 0; Ke < ze; Ke++) {
              Ke === 1 && Y !== 1 && V.writeVarint(tt(2, ze - 1));
              const _t = Se[Ke].x - oe,
                it = Se[Ke].y - me;
              V.writeVarint(Ve(_t)), V.writeVarint(Ve(it)), oe += _t, me += it
            }
            ue.type === 3 && V.writeVarint(tt(7, 1))
          }
        }

        function Ue(ue, V) {
          const U = typeof ue;
          U === "string" ? V.writeStringField(1, ue) : U === "boolean" ? V.writeBooleanField(7, ue) : U === "number" && (ue % 1 != 0 ? V.writeDoubleField(3, ue) : ue < 0 ? V.writeSVarintField(6, ue) : V.writeVarintField(5, ue))
        }
        const Ce = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: ue => ue
          },
          We = Math.fround || (Je = new Float32Array(1), ue => (Je[0] = +ue, Je[0]));
        var Je;
        class Ge {
          constructor(V) {
            this.options = Object.assign(Object.create(Ce), V), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []
          }
          load(V) {
            const {
              log: U,
              minZoom: Y,
              maxZoom: oe
            } = this.options;
            U && console.time("total time");
            const me = `prepare ${V.length} points`;
            U && console.time(me), this.points = V;
            const Se = [];
            for (let ze = 0; ze < V.length; ze++) {
              const Ke = V[ze];
              if (!Ke.geometry) continue;
              const [_t, it] = Ke.geometry.coordinates, qt = We(K(_t)), we = We(ee(it));
              Se.push(qt, we, 1 / 0, ze, -1, 1), this.options.reduce && Se.push(0)
            }
            let Oe = this.trees[oe + 1] = this._createTree(Se);
            U && console.timeEnd(me);
            for (let ze = oe; ze >= Y; ze--) {
              const Ke = +Date.now();
              Oe = this.trees[ze] = this._createTree(this._cluster(Oe, ze)), U && console.log("z%d: %d clusters in %dms", ze, Oe.numItems, +Date.now() - Ke)
            }
            return U && console.timeEnd("total time"), this
          }
          getClusters(V, U) {
            let Y = ((V[0] + 180) % 360 + 360) % 360 - 180;
            const oe = Math.max(-90, Math.min(90, V[1]));
            let me = V[2] === 180 ? 180 : ((V[2] + 180) % 360 + 360) % 360 - 180;
            const Se = Math.max(-90, Math.min(90, V[3]));
            if (V[2] - V[0] >= 360) Y = -180, me = 180;
            else if (Y > me) {
              const it = this.getClusters([Y, oe, 180, Se], U),
                qt = this.getClusters([-180, oe, me, Se], U);
              return it.concat(qt)
            }
            const Oe = this.trees[this._limitZoom(U)],
              ze = Oe.range(K(Y), ee(Se), K(me), ee(oe)),
              Ke = Oe.data,
              _t = [];
            for (const it of ze) {
              const qt = this.stride * it;
              _t.push(Ke[qt + 5] > 1 ? Ee(Ke, qt, this.clusterProps) : this.points[Ke[qt + 3]])
            }
            return _t
          }
          getChildren(V) {
            const U = this._getOriginId(V),
              Y = this._getOriginZoom(V),
              oe = "No cluster with the specified id.",
              me = this.trees[Y];
            if (!me) throw new Error(oe);
            const Se = me.data;
            if (U * this.stride >= Se.length) throw new Error(oe);
            const Oe = this.options.radius / (this.options.extent * Math.pow(2, Y - 1)),
              ze = me.within(Se[U * this.stride], Se[U * this.stride + 1], Oe),
              Ke = [];
            for (const _t of ze) {
              const it = _t * this.stride;
              Se[it + 4] === V && Ke.push(Se[it + 5] > 1 ? Ee(Se, it, this.clusterProps) : this.points[Se[it + 3]])
            }
            if (Ke.length === 0) throw new Error(oe);
            return Ke
          }
          getLeaves(V, U, Y) {
            const oe = [];
            return this._appendLeaves(oe, V, U = U || 10, Y = Y || 0, 0), oe
          }
          getTile(V, U, Y) {
            const oe = this.trees[this._limitZoom(V)],
              me = Math.pow(2, V),
              {
                extent: Se,
                radius: Oe
              } = this.options,
              ze = Oe / Se,
              Ke = (Y - ze) / me,
              _t = (Y + 1 + ze) / me,
              it = {
                features: []
              };
            return this._addTileFeatures(oe.range((U - ze) / me, Ke, (U + 1 + ze) / me, _t), oe.data, U, Y, me, it), U === 0 && this._addTileFeatures(oe.range(1 - ze / me, Ke, 1, _t), oe.data, me, Y, me, it), U === me - 1 && this._addTileFeatures(oe.range(0, Ke, ze / me, _t), oe.data, -1, Y, me, it), it.features.length ? it : null
          }
          getClusterExpansionZoom(V) {
            let U = this._getOriginZoom(V) - 1;
            for (; U <= this.options.maxZoom;) {
              const Y = this.getChildren(V);
              if (U++, Y.length !== 1) break;
              V = Y[0].properties.cluster_id
            }
            return U
          }
          _appendLeaves(V, U, Y, oe, me) {
            const Se = this.getChildren(U);
            for (const Oe of Se) {
              const ze = Oe.properties;
              if (ze && ze.cluster ? me + ze.point_count <= oe ? me += ze.point_count : me = this._appendLeaves(V, ze.cluster_id, Y, oe, me) : me < oe ? me++ : V.push(Oe), V.length === Y) break
            }
            return me
          }
          _createTree(V) {
            const U = new b.aI(V.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let Y = 0; Y < V.length; Y += this.stride) U.add(V[Y], V[Y + 1]);
            return U.finish(), U.data = V, U
          }
          _addTileFeatures(V, U, Y, oe, me, Se) {
            for (const Oe of V) {
              const ze = Oe * this.stride,
                Ke = U[ze + 5] > 1;
              let _t, it, qt;
              if (Ke) _t = mt(U, ze, this.clusterProps), it = U[ze], qt = U[ze + 1];
              else {
                const Ut = this.points[U[ze + 3]];
                _t = Ut.properties;
                const [jt, fr] = Ut.geometry.coordinates;
                it = K(jt), qt = ee(fr)
              }
              const we = {
                type: 1,
                geometry: [
                  [Math.round(this.options.extent * (it * me - Y)), Math.round(this.options.extent * (qt * me - oe))]
                ],
                tags: _t
              };
              let Mt;
              Mt = Ke || this.options.generateId ? U[ze + 3] : this.points[U[ze + 3]].id, Mt !== void 0 && (we.id = Mt), Se.features.push(we)
            }
          }
          _limitZoom(V) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+V), this.options.maxZoom + 1))
          }
          _cluster(V, U) {
            const {
              radius: Y,
              extent: oe,
              reduce: me,
              minPoints: Se
            } = this.options, Oe = Y / (oe * Math.pow(2, U)), ze = V.data, Ke = [], _t = this.stride;
            for (let it = 0; it < ze.length; it += _t) {
              if (ze[it + 2] <= U) continue;
              ze[it + 2] = U;
              const qt = ze[it],
                we = ze[it + 1],
                Mt = V.within(ze[it], ze[it + 1], Oe),
                Ut = ze[it + 5];
              let jt = Ut;
              for (const fr of Mt) {
                const Ur = fr * _t;
                ze[Ur + 2] > U && (jt += ze[Ur + 5])
              }
              if (jt > Ut && jt >= Se) {
                let fr, Ur = qt * Ut,
                  Dr = we * Ut,
                  jr = -1;
                const $r = (it / _t << 5) + (U + 1) + this.points.length;
                for (const Br of Mt) {
                  const Fr = Br * _t;
                  if (ze[Fr + 2] <= U) continue;
                  ze[Fr + 2] = U;
                  const vn = ze[Fr + 5];
                  Ur += ze[Fr] * vn, Dr += ze[Fr + 1] * vn, ze[Fr + 4] = $r, me && (fr || (fr = this._map(ze, it, !0), jr = this.clusterProps.length, this.clusterProps.push(fr)), me(fr, this._map(ze, Fr)))
                }
                ze[it + 4] = $r, Ke.push(Ur / jt, Dr / jt, 1 / 0, $r, -1, jt), me && Ke.push(jr)
              } else {
                for (let fr = 0; fr < _t; fr++) Ke.push(ze[it + fr]);
                if (jt > 1)
                  for (const fr of Mt) {
                    const Ur = fr * _t;
                    if (!(ze[Ur + 2] <= U)) {
                      ze[Ur + 2] = U;
                      for (let Dr = 0; Dr < _t; Dr++) Ke.push(ze[Ur + Dr])
                    }
                  }
              }
            }
            return Ke
          }
          _getOriginId(V) {
            return V - this.points.length >> 5
          }
          _getOriginZoom(V) {
            return (V - this.points.length) % 32
          }
          _map(V, U, Y) {
            if (V[U + 5] > 1) {
              const Se = this.clusterProps[V[U + 6]];
              return Y ? Object.assign({}, Se) : Se
            }
            const oe = this.points[V[U + 3]].properties,
              me = this.options.map(oe);
            return Y && me === oe ? Object.assign({}, me) : me
          }
        }

        function Ee(ue, V, U) {
          return {
            type: "Feature",
            id: ue[V + 3],
            properties: mt(ue, V, U),
            geometry: {
              type: "Point",
              coordinates: [(Y = ue[V], 360 * (Y - .5)), le(ue[V + 1])]
            }
          };
          var Y
        }

        function mt(ue, V, U) {
          const Y = ue[V + 5],
            oe = Y >= 1e4 ? `${Math.round(Y/1e3)}k` : Y >= 1e3 ? Math.round(Y / 100) / 10 + "k" : Y,
            me = ue[V + 6],
            Se = me === -1 ? {} : Object.assign({}, U[me]);
          return Object.assign(Se, {
            cluster: !0,
            cluster_id: ue[V + 3],
            point_count: Y,
            point_count_abbreviated: oe
          })
        }

        function K(ue) {
          return ue / 360 + .5
        }

        function ee(ue) {
          const V = Math.sin(ue * Math.PI / 180),
            U = .5 - .25 * Math.log((1 + V) / (1 - V)) / Math.PI;
          return U < 0 ? 0 : U > 1 ? 1 : U
        }

        function le(ue) {
          const V = (180 - 360 * ue) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(V)) / Math.PI - 90
        }

        function ae(ue, V, U, Y) {
          let oe = Y;
          const me = V + (U - V >> 1);
          let Se, Oe = U - V;
          const ze = ue[V],
            Ke = ue[V + 1],
            _t = ue[U],
            it = ue[U + 1];
          for (let qt = V + 3; qt < U; qt += 3) {
            const we = ke(ue[qt], ue[qt + 1], ze, Ke, _t, it);
            if (we > oe) Se = qt, oe = we;
            else if (we === oe) {
              const Mt = Math.abs(qt - me);
              Mt < Oe && (Se = qt, Oe = Mt)
            }
          }
          oe > Y && (Se - V > 3 && ae(ue, V, Se, Y), ue[Se + 2] = oe, U - Se > 3 && ae(ue, Se, U, Y))
        }

        function ke(ue, V, U, Y, oe, me) {
          let Se = oe - U,
            Oe = me - Y;
          if (Se !== 0 || Oe !== 0) {
            const ze = ((ue - U) * Se + (V - Y) * Oe) / (Se * Se + Oe * Oe);
            ze > 1 ? (U = oe, Y = me) : ze > 0 && (U += Se * ze, Y += Oe * ze)
          }
          return Se = ue - U, Oe = V - Y, Se * Se + Oe * Oe
        }

        function qe(ue, V, U, Y) {
          const oe = {
            id: ue ?? null,
            type: V,
            geometry: U,
            tags: Y,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
          };
          if (V === "Point" || V === "MultiPoint" || V === "LineString") lt(oe, U);
          else if (V === "Polygon") lt(oe, U[0]);
          else if (V === "MultiLineString")
            for (const me of U) lt(oe, me);
          else if (V === "MultiPolygon")
            for (const me of U) lt(oe, me[0]);
          return oe
        }

        function lt(ue, V) {
          for (let U = 0; U < V.length; U += 3) ue.minX = Math.min(ue.minX, V[U]), ue.minY = Math.min(ue.minY, V[U + 1]), ue.maxX = Math.max(ue.maxX, V[U]), ue.maxY = Math.max(ue.maxY, V[U + 1])
        }

        function ot(ue, V, U, Y) {
          if (!V.geometry) return;
          const oe = V.geometry.coordinates;
          if (oe && oe.length === 0) return;
          const me = V.geometry.type,
            Se = Math.pow(U.tolerance / ((1 << U.maxZoom) * U.extent), 2);
          let Oe = [],
            ze = V.id;
          if (U.promoteId ? ze = V.properties[U.promoteId] : U.generateId && (ze = Y || 0), me === "Point") dt(oe, Oe);
          else if (me === "MultiPoint")
            for (const Ke of oe) dt(Ke, Oe);
          else if (me === "LineString") Pt(oe, Oe, Se, !1);
          else if (me === "MultiLineString") {
            if (U.lineMetrics) {
              for (const Ke of oe) Oe = [], Pt(Ke, Oe, Se, !1), ue.push(qe(ze, "LineString", Oe, V.properties));
              return
            }
            Lt(oe, Oe, Se, !1)
          } else if (me === "Polygon") Lt(oe, Oe, Se, !0);
          else {
            if (me !== "MultiPolygon") {
              if (me === "GeometryCollection") {
                for (const Ke of V.geometry.geometries) ot(ue, {
                  id: ze,
                  geometry: Ke,
                  properties: V.properties
                }, U, Y);
                return
              }
              throw new Error("Input data is not a valid GeoJSON object.")
            }
            for (const Ke of oe) {
              const _t = [];
              Lt(Ke, _t, Se, !0), Oe.push(_t)
            }
          }
          ue.push(qe(ze, me, Oe, V.properties))
        }

        function dt(ue, V) {
          V.push(He(ue[0]), ut(ue[1]), 0)
        }

        function Pt(ue, V, U, Y) {
          let oe, me, Se = 0;
          for (let ze = 0; ze < ue.length; ze++) {
            const Ke = He(ue[ze][0]),
              _t = ut(ue[ze][1]);
            V.push(Ke, _t, 0), ze > 0 && (Se += Y ? (oe * _t - Ke * me) / 2 : Math.sqrt(Math.pow(Ke - oe, 2) + Math.pow(_t - me, 2))), oe = Ke, me = _t
          }
          const Oe = V.length - 3;
          V[2] = 1, ae(V, 0, Oe, U), V[Oe + 2] = 1, V.size = Math.abs(Se), V.start = 0, V.end = V.size
        }

        function Lt(ue, V, U, Y) {
          for (let oe = 0; oe < ue.length; oe++) {
            const me = [];
            Pt(ue[oe], me, U, Y), V.push(me)
          }
        }

        function He(ue) {
          return ue / 360 + .5
        }

        function ut(ue) {
          const V = Math.sin(ue * Math.PI / 180),
            U = .5 - .25 * Math.log((1 + V) / (1 - V)) / Math.PI;
          return U < 0 ? 0 : U > 1 ? 1 : U
        }

        function gt(ue, V, U, Y, oe, me, Se, Oe) {
          if (Y /= V, me >= (U /= V) && Se < Y) return ue;
          if (Se < U || me >= Y) return null;
          const ze = [];
          for (const Ke of ue) {
            const _t = Ke.geometry;
            let it = Ke.type;
            const qt = oe === 0 ? Ke.minX : Ke.minY,
              we = oe === 0 ? Ke.maxX : Ke.maxY;
            if (qt >= U && we < Y) {
              ze.push(Ke);
              continue
            }
            if (we < U || qt >= Y) continue;
            let Mt = [];
            if (it === "Point" || it === "MultiPoint") St(_t, Mt, U, Y, oe);
            else if (it === "LineString") vt(_t, Mt, U, Y, oe, !1, Oe.lineMetrics);
            else if (it === "MultiLineString") At(_t, Mt, U, Y, oe, !1);
            else if (it === "Polygon") At(_t, Mt, U, Y, oe, !0);
            else if (it === "MultiPolygon")
              for (const Ut of _t) {
                const jt = [];
                At(Ut, jt, U, Y, oe, !0), jt.length && Mt.push(jt)
              }
            if (Mt.length) {
              if (Oe.lineMetrics && it === "LineString") {
                for (const Ut of Mt) ze.push(qe(Ke.id, it, Ut, Ke.tags));
                continue
              }
              it !== "LineString" && it !== "MultiLineString" || (Mt.length === 1 ? (it = "LineString", Mt = Mt[0]) : it = "MultiLineString"), it !== "Point" && it !== "MultiPoint" || (it = Mt.length === 3 ? "Point" : "MultiPoint"), ze.push(qe(Ke.id, it, Mt, Ke.tags))
            }
          }
          return ze.length ? ze : null
        }

        function St(ue, V, U, Y, oe) {
          for (let me = 0; me < ue.length; me += 3) {
            const Se = ue[me + oe];
            Se >= U && Se <= Y && Bt(V, ue[me], ue[me + 1], ue[me + 2])
          }
        }

        function vt(ue, V, U, Y, oe, me, Se) {
          let Oe = Ct(ue);
          const ze = oe === 0 ? Vt : Ot;
          let Ke, _t, it = ue.start;
          for (let jt = 0; jt < ue.length - 3; jt += 3) {
            const fr = ue[jt],
              Ur = ue[jt + 1],
              Dr = ue[jt + 2],
              jr = ue[jt + 3],
              $r = ue[jt + 4],
              Br = oe === 0 ? fr : Ur,
              Fr = oe === 0 ? jr : $r;
            let vn = !1;
            Se && (Ke = Math.sqrt(Math.pow(fr - jr, 2) + Math.pow(Ur - $r, 2))), Br < U ? Fr > U && (_t = ze(Oe, fr, Ur, jr, $r, U), Se && (Oe.start = it + Ke * _t)) : Br > Y ? Fr < Y && (_t = ze(Oe, fr, Ur, jr, $r, Y), Se && (Oe.start = it + Ke * _t)) : Bt(Oe, fr, Ur, Dr), Fr < U && Br >= U && (_t = ze(Oe, fr, Ur, jr, $r, U), vn = !0), Fr > Y && Br <= Y && (_t = ze(Oe, fr, Ur, jr, $r, Y), vn = !0), !me && vn && (Se && (Oe.end = it + Ke * _t), V.push(Oe), Oe = Ct(ue)), Se && (it += Ke)
          }
          let qt = ue.length - 3;
          const we = ue[qt],
            Mt = ue[qt + 1],
            Ut = oe === 0 ? we : Mt;
          Ut >= U && Ut <= Y && Bt(Oe, we, Mt, ue[qt + 2]), qt = Oe.length - 3, me && qt >= 3 && (Oe[qt] !== Oe[0] || Oe[qt + 1] !== Oe[1]) && Bt(Oe, Oe[0], Oe[1], Oe[2]), Oe.length && V.push(Oe)
        }

        function Ct(ue) {
          const V = [];
          return V.size = ue.size, V.start = ue.start, V.end = ue.end, V
        }

        function At(ue, V, U, Y, oe, me) {
          for (const Se of ue) vt(Se, V, U, Y, oe, me, !1)
        }

        function Bt(ue, V, U, Y) {
          ue.push(V, U, Y)
        }

        function Vt(ue, V, U, Y, oe, me) {
          const Se = (me - V) / (Y - V);
          return Bt(ue, me, U + (oe - U) * Se, 1), Se
        }

        function Ot(ue, V, U, Y, oe, me) {
          const Se = (me - U) / (oe - U);
          return Bt(ue, V + (Y - V) * Se, me, 1), Se
        }

        function Dt(ue, V) {
          const U = [];
          for (let Y = 0; Y < ue.length; Y++) {
            const oe = ue[Y],
              me = oe.type;
            let Se;
            if (me === "Point" || me === "MultiPoint" || me === "LineString") Se = Rt(oe.geometry, V);
            else if (me === "MultiLineString" || me === "Polygon") {
              Se = [];
              for (const Oe of oe.geometry) Se.push(Rt(Oe, V))
            } else if (me === "MultiPolygon") {
              Se = [];
              for (const Oe of oe.geometry) {
                const ze = [];
                for (const Ke of Oe) ze.push(Rt(Ke, V));
                Se.push(ze)
              }
            }
            U.push(qe(oe.id, me, Se, oe.tags))
          }
          return U
        }

        function Rt(ue, V) {
          const U = [];
          U.size = ue.size, ue.start !== void 0 && (U.start = ue.start, U.end = ue.end);
          for (let Y = 0; Y < ue.length; Y += 3) U.push(ue[Y] + V, ue[Y + 1], ue[Y + 2]);
          return U
        }

        function Zt(ue, V) {
          if (ue.transformed) return ue;
          const U = 1 << ue.z,
            Y = ue.x,
            oe = ue.y;
          for (const me of ue.features) {
            const Se = me.geometry,
              Oe = me.type;
            if (me.geometry = [], Oe === 1)
              for (let ze = 0; ze < Se.length; ze += 2) me.geometry.push(Ft(Se[ze], Se[ze + 1], V, U, Y, oe));
            else
              for (let ze = 0; ze < Se.length; ze++) {
                const Ke = [];
                for (let _t = 0; _t < Se[ze].length; _t += 2) Ke.push(Ft(Se[ze][_t], Se[ze][_t + 1], V, U, Y, oe));
                me.geometry.push(Ke)
              }
          }
          return ue.transformed = !0, ue
        }

        function Ft(ue, V, U, Y, oe, me) {
          return [Math.round(U * (ue * Y - oe)), Math.round(U * (V * Y - me))]
        }

        function cr(ue, V, U, Y, oe) {
          const me = V === oe.maxZoom ? 0 : oe.tolerance / ((1 << V) * oe.extent),
            Se = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: ue.length,
              source: null,
              x: U,
              y: Y,
              z: V,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0
            };
          for (const Oe of ue) ur(Se, Oe, me, oe);
          return Se
        }

        function ur(ue, V, U, Y) {
          const oe = V.geometry,
            me = V.type,
            Se = [];
          if (ue.minX = Math.min(ue.minX, V.minX), ue.minY = Math.min(ue.minY, V.minY), ue.maxX = Math.max(ue.maxX, V.maxX), ue.maxY = Math.max(ue.maxY, V.maxY), me === "Point" || me === "MultiPoint")
            for (let Oe = 0; Oe < oe.length; Oe += 3) Se.push(oe[Oe], oe[Oe + 1]), ue.numPoints++, ue.numSimplified++;
          else if (me === "LineString") Er(Se, oe, ue, U, !1, !1);
          else if (me === "MultiLineString" || me === "Polygon")
            for (let Oe = 0; Oe < oe.length; Oe++) Er(Se, oe[Oe], ue, U, me === "Polygon", Oe === 0);
          else if (me === "MultiPolygon")
            for (let Oe = 0; Oe < oe.length; Oe++) {
              const ze = oe[Oe];
              for (let Ke = 0; Ke < ze.length; Ke++) Er(Se, ze[Ke], ue, U, !0, Ke === 0)
            }
          if (Se.length) {
            let Oe = V.tags || null;
            if (me === "LineString" && Y.lineMetrics) {
              Oe = {};
              for (const Ke in V.tags) Oe[Ke] = V.tags[Ke];
              Oe.mapbox_clip_start = oe.start / oe.size, Oe.mapbox_clip_end = oe.end / oe.size
            }
            const ze = {
              geometry: Se,
              type: me === "Polygon" || me === "MultiPolygon" ? 3 : me === "LineString" || me === "MultiLineString" ? 2 : 1,
              tags: Oe
            };
            V.id !== null && (ze.id = V.id), ue.features.push(ze)
          }
        }

        function Er(ue, V, U, Y, oe, me) {
          const Se = Y * Y;
          if (Y > 0 && V.size < (oe ? Se : Y)) return void(U.numPoints += V.length / 3);
          const Oe = [];
          for (let ze = 0; ze < V.length; ze += 3)(Y === 0 || V[ze + 2] > Se) && (U.numSimplified++, Oe.push(V[ze], V[ze + 1])), U.numPoints++;
          oe && (function(ze, Ke) {
            let _t = 0;
            for (let it = 0, qt = ze.length, we = qt - 2; it < qt; we = it, it += 2) _t += (ze[it] - ze[we]) * (ze[it + 1] + ze[we + 1]);
            if (_t > 0 === Ke)
              for (let it = 0, qt = ze.length; it < qt / 2; it += 2) {
                const we = ze[it],
                  Mt = ze[it + 1];
                ze[it] = ze[qt - 2 - it], ze[it + 1] = ze[qt - 1 - it], ze[qt - 2 - it] = we, ze[qt - 1 - it] = Mt
              }
          })(Oe, me), ue.push(Oe)
        }
        const dr = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0
        };
        class pr {
          constructor(V, U) {
            const Y = (U = this.options = (function(me, Se) {
              for (const Oe in Se) me[Oe] = Se[Oe];
              return me
            })(Object.create(dr), U)).debug;
            if (Y && console.time("preprocess data"), U.maxZoom < 0 || U.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (U.promoteId && U.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let oe = (function(me, Se) {
              const Oe = [];
              if (me.type === "FeatureCollection")
                for (let ze = 0; ze < me.features.length; ze++) ot(Oe, me.features[ze], Se, ze);
              else ot(Oe, me.type === "Feature" ? me : {
                geometry: me
              }, Se);
              return Oe
            })(V, U);
            this.tiles = {}, this.tileCoords = [], Y && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", U.indexMaxZoom, U.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), oe = (function(me, Se) {
              const Oe = Se.buffer / Se.extent;
              let ze = me;
              const Ke = gt(me, 1, -1 - Oe, Oe, 0, -1, 2, Se),
                _t = gt(me, 1, 1 - Oe, 2 + Oe, 0, -1, 2, Se);
              return (Ke || _t) && (ze = gt(me, 1, -Oe, 1 + Oe, 0, -1, 2, Se) || [], Ke && (ze = Dt(Ke, 1).concat(ze)), _t && (ze = ze.concat(Dt(_t, -1)))), ze
            })(oe, U), oe.length && this.splitTile(oe, 0, 0, 0), Y && (oe.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
          }
          splitTile(V, U, Y, oe, me, Se, Oe) {
            const ze = [V, U, Y, oe],
              Ke = this.options,
              _t = Ke.debug;
            for (; ze.length;) {
              oe = ze.pop(), Y = ze.pop(), U = ze.pop(), V = ze.pop();
              const it = 1 << U,
                qt = vr(U, Y, oe);
              let we = this.tiles[qt];
              if (!we && (_t > 1 && console.time("creation"), we = this.tiles[qt] = cr(V, U, Y, oe, Ke), this.tileCoords.push({
                  z: U,
                  x: Y,
                  y: oe
                }), _t)) {
                _t > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", U, Y, oe, we.numFeatures, we.numPoints, we.numSimplified), console.timeEnd("creation"));
                const vn = `z${U}`;
                this.stats[vn] = (this.stats[vn] || 0) + 1, this.total++
              }
              if (we.source = V, me == null) {
                if (U === Ke.indexMaxZoom || we.numPoints <= Ke.indexMaxPoints) continue
              } else {
                if (U === Ke.maxZoom || U === me) continue;
                if (me != null) {
                  const vn = me - U;
                  if (Y !== Se >> vn || oe !== Oe >> vn) continue
                }
              }
              if (we.source = null, V.length === 0) continue;
              _t > 1 && console.time("clipping");
              const Mt = .5 * Ke.buffer / Ke.extent,
                Ut = .5 - Mt,
                jt = .5 + Mt,
                fr = 1 + Mt;
              let Ur = null,
                Dr = null,
                jr = null,
                $r = null,
                Br = gt(V, it, Y - Mt, Y + jt, 0, we.minX, we.maxX, Ke),
                Fr = gt(V, it, Y + Ut, Y + fr, 0, we.minX, we.maxX, Ke);
              V = null, Br && (Ur = gt(Br, it, oe - Mt, oe + jt, 1, we.minY, we.maxY, Ke), Dr = gt(Br, it, oe + Ut, oe + fr, 1, we.minY, we.maxY, Ke), Br = null), Fr && (jr = gt(Fr, it, oe - Mt, oe + jt, 1, we.minY, we.maxY, Ke), $r = gt(Fr, it, oe + Ut, oe + fr, 1, we.minY, we.maxY, Ke), Fr = null), _t > 1 && console.timeEnd("clipping"), ze.push(Ur || [], U + 1, 2 * Y, 2 * oe), ze.push(Dr || [], U + 1, 2 * Y, 2 * oe + 1), ze.push(jr || [], U + 1, 2 * Y + 1, 2 * oe), ze.push($r || [], U + 1, 2 * Y + 1, 2 * oe + 1)
            }
          }
          getTile(V, U, Y) {
            V = +V, U = +U, Y = +Y;
            const oe = this.options,
              {
                extent: me,
                debug: Se
              } = oe;
            if (V < 0 || V > 24) return null;
            const Oe = 1 << V,
              ze = vr(V, U = U + Oe & Oe - 1, Y);
            if (this.tiles[ze]) return Zt(this.tiles[ze], me);
            Se > 1 && console.log("drilling down to z%d-%d-%d", V, U, Y);
            let Ke, _t = V,
              it = U,
              qt = Y;
            for (; !Ke && _t > 0;) _t--, it >>= 1, qt >>= 1, Ke = this.tiles[vr(_t, it, qt)];
            return Ke && Ke.source ? (Se > 1 && (console.log("found parent tile z%d-%d-%d", _t, it, qt), console.time("drilling down")), this.splitTile(Ke.source, _t, it, qt, V, U, Y), Se > 1 && console.timeEnd("drilling down"), this.tiles[ze] ? Zt(this.tiles[ze], me) : null) : null
          }
        }

        function vr(ue, V, U) {
          return 32 * ((1 << ue) * U + V) + ue
        }
        class Vr extends X {
          constructor() {
            super(...arguments), this._dataUpdateable = new Map
          }
          loadVectorTile(V, U) {
            return b._(this, void 0, void 0, (function*() {
              const Y = V.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const oe = this._geoJSONIndex.getTile(Y.z, Y.x, Y.y);
              if (!oe) return null;
              const me = new Ie(oe.features, {
                version: 2,
                extent: b.$
              });
              let Se = (function(Oe) {
                const ze = new b.cM;
                return (function(Ke, _t) {
                  for (const it in Ke.layers) _t.writeMessage(3, Pe, Ke.layers[it])
                })(Oe, ze), ze.finish()
              })(me);
              return Se.byteOffset === 0 && Se.byteLength === Se.buffer.byteLength || (Se = new Uint8Array(Se)), {
                vectorTile: me,
                rawData: Se.buffer
              }
            }))
          }
          loadData(V) {
            return b._(this, void 0, void 0, (function*() {
              var U;
              (U = this._pendingRequest) === null || U === void 0 || U.abort();
              const Y = !!(V && V.request && V.request.collectResourceTiming) && new b.cN(V.request);
              this._pendingRequest = new AbortController;
              try {
                this._pendingData = this.loadAndProcessGeoJSON(V, this._pendingRequest);
                const oe = yield this._pendingData;
                this._geoJSONIndex = V.cluster ? new Ge((function({
                  superclusterOptions: Se,
                  clusterProperties: Oe
                }) {
                  if (!Oe || !Se) return Se;
                  const ze = {},
                    Ke = {},
                    _t = {
                      accumulated: null,
                      zoom: 0
                    },
                    it = {
                      properties: null
                    },
                    qt = Object.keys(Oe);
                  for (const we of qt) {
                    const [Mt, Ut] = Oe[we], jt = b.cT(Ut), fr = b.cT(typeof Mt == "string" ? [Mt, ["accumulated"],
                      ["get", we]
                    ] : Mt);
                    ze[we] = jt.value, Ke[we] = fr.value
                  }
                  return Se.map = we => {
                    it.properties = we;
                    const Mt = {};
                    for (const Ut of qt) Mt[Ut] = ze[Ut].evaluate(_t, it);
                    return Mt
                  }, Se.reduce = (we, Mt) => {
                    it.properties = Mt;
                    for (const Ut of qt) _t.accumulated = we[Ut], we[Ut] = Ke[Ut].evaluate(_t, it)
                  }, Se
                })(V)).load(oe.features) : (function(Se, Oe) {
                  return new pr(Se, Oe)
                })(oe, V.geojsonVtOptions), this.loaded = {};
                const me = {
                  data: oe
                };
                if (Y) {
                  const Se = Y.finish();
                  Se && (me.resourceTiming = {}, me.resourceTiming[V.source] = JSON.parse(JSON.stringify(Se)))
                }
                return me
              } catch (oe) {
                if (delete this._pendingRequest, b.cy(oe)) return {
                  abandoned: !0
                };
                throw oe
              }
            }))
          }
          getData() {
            return b._(this, void 0, void 0, (function*() {
              return this._pendingData
            }))
          }
          reloadTile(V) {
            const U = this.loaded;
            return U && U[V.uid] ? super.reloadTile(V) : this.loadTile(V)
          }
          loadAndProcessGeoJSON(V, U) {
            return b._(this, void 0, void 0, (function*() {
              let Y = yield this.loadGeoJSON(V, U);
              if (delete this._pendingRequest, typeof Y != "object") throw new Error(`Input data given to '${V.source}' is not a valid GeoJSON object.`);
              if (Ae(Y, !0), V.filter) {
                const oe = b.cT(V.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1
                });
                if (oe.result === "error") throw new Error(oe.value.map((Se => `${Se.key}: ${Se.message}`)).join(", "));
                Y = {
                  type: "FeatureCollection",
                  features: Y.features.filter((Se => oe.value.evaluate({
                    zoom: 0
                  }, Se)))
                }
              }
              return Y
            }))
          }
          loadGeoJSON(V, U) {
            return b._(this, void 0, void 0, (function*() {
              const {
                promoteId: Y
              } = V;
              if (V.request) {
                const oe = yield b.j(V.request, U);
                return this._dataUpdateable = b.cV(oe.data, Y) ? b.cU(oe.data, Y) : void 0, oe.data
              }
              if (typeof V.data == "string") try {
                const oe = JSON.parse(V.data);
                return this._dataUpdateable = b.cV(oe, Y) ? b.cU(oe, Y) : void 0, oe
              } catch {
                throw new Error(`Input data given to '${V.source}' is not a valid GeoJSON object.`)
              }
              if (!V.dataDiff) throw new Error(`Input data given to '${V.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${V.source}`);
              return b.cW(this._dataUpdateable, V.dataDiff, Y), {
                type: "FeatureCollection",
                features: Array.from(this._dataUpdateable.values())
              }
            }))
          }
          removeSource(V) {
            return b._(this, void 0, void 0, (function*() {
              this._pendingRequest && this._pendingRequest.abort()
            }))
          }
          getClusterExpansionZoom(V) {
            return this._geoJSONIndex.getClusterExpansionZoom(V.clusterId)
          }
          getClusterChildren(V) {
            return this._geoJSONIndex.getChildren(V.clusterId)
          }
          getClusterLeaves(V) {
            return this._geoJSONIndex.getLeaves(V.clusterId, V.limit, V.offset)
          }
        }
        class qr {
          constructor(V) {
            this.self = V, this.actor = new b.J(V), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (U, Y) => {
              if (this.externalWorkerSourceTypes[U]) throw new Error(`Worker source with name "${U}" already registered.`);
              this.externalWorkerSourceTypes[U] = Y
            }, this.self.addProtocol = b.cA, this.self.removeProtocol = b.cB, this.self.registerRTLTextPlugin = U => {
              b.cX.setMethods(U)
            }, this.actor.registerMessageHandler("LDT", ((U, Y) => this._getDEMWorkerSource(U, Y.source).loadTile(Y))), this.actor.registerMessageHandler("RDT", ((U, Y) => b._(this, void 0, void 0, (function*() {
              this._getDEMWorkerSource(U, Y.source).removeTile(Y)
            })))), this.actor.registerMessageHandler("GCEZ", ((U, Y) => b._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(U, Y.type, Y.source).getClusterExpansionZoom(Y)
            })))), this.actor.registerMessageHandler("GCC", ((U, Y) => b._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(U, Y.type, Y.source).getClusterChildren(Y)
            })))), this.actor.registerMessageHandler("GCL", ((U, Y) => b._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(U, Y.type, Y.source).getClusterLeaves(Y)
            })))), this.actor.registerMessageHandler("LD", ((U, Y) => this._getWorkerSource(U, Y.type, Y.source).loadData(Y))), this.actor.registerMessageHandler("GD", ((U, Y) => this._getWorkerSource(U, Y.type, Y.source).getData())), this.actor.registerMessageHandler("LT", ((U, Y) => this._getWorkerSource(U, Y.type, Y.source).loadTile(Y))), this.actor.registerMessageHandler("RT", ((U, Y) => this._getWorkerSource(U, Y.type, Y.source).reloadTile(Y))), this.actor.registerMessageHandler("AT", ((U, Y) => this._getWorkerSource(U, Y.type, Y.source).abortTile(Y))), this.actor.registerMessageHandler("RMT", ((U, Y) => this._getWorkerSource(U, Y.type, Y.source).removeTile(Y))), this.actor.registerMessageHandler("RS", ((U, Y) => b._(this, void 0, void 0, (function*() {
              if (!this.workerSources[U] || !this.workerSources[U][Y.type] || !this.workerSources[U][Y.type][Y.source]) return;
              const oe = this.workerSources[U][Y.type][Y.source];
              delete this.workerSources[U][Y.type][Y.source], oe.removeSource !== void 0 && oe.removeSource(Y)
            })))), this.actor.registerMessageHandler("RM", (U => b._(this, void 0, void 0, (function*() {
              delete this.layerIndexes[U], delete this.availableImages[U], delete this.workerSources[U], delete this.demWorkerSources[U]
            })))), this.actor.registerMessageHandler("SR", ((U, Y) => b._(this, void 0, void 0, (function*() {
              this.referrer = Y
            })))), this.actor.registerMessageHandler("SRPS", ((U, Y) => this._syncRTLPluginState(U, Y))), this.actor.registerMessageHandler("IS", ((U, Y) => b._(this, void 0, void 0, (function*() {
              this.self.importScripts(Y)
            })))), this.actor.registerMessageHandler("SI", ((U, Y) => this._setImages(U, Y))), this.actor.registerMessageHandler("UL", ((U, Y) => b._(this, void 0, void 0, (function*() {
              this._getLayerIndex(U).update(Y.layers, Y.removedIds)
            })))), this.actor.registerMessageHandler("SL", ((U, Y) => b._(this, void 0, void 0, (function*() {
              this._getLayerIndex(U).replace(Y)
            }))))
          }
          _setImages(V, U) {
            return b._(this, void 0, void 0, (function*() {
              this.availableImages[V] = U;
              for (const Y in this.workerSources[V]) {
                const oe = this.workerSources[V][Y];
                for (const me in oe) oe[me].availableImages = U
              }
            }))
          }
          _syncRTLPluginState(V, U) {
            return b._(this, void 0, void 0, (function*() {
              return yield b.cX.syncState(U, this.self.importScripts)
            }))
          }
          _getAvailableImages(V) {
            let U = this.availableImages[V];
            return U || (U = []), U
          }
          _getLayerIndex(V) {
            let U = this.layerIndexes[V];
            return U || (U = this.layerIndexes[V] = new s), U
          }
          _getWorkerSource(V, U, Y) {
            if (this.workerSources[V] || (this.workerSources[V] = {}), this.workerSources[V][U] || (this.workerSources[V][U] = {}), !this.workerSources[V][U][Y]) {
              const oe = {
                sendAsync: (me, Se) => (me.targetMapId = V, this.actor.sendAsync(me, Se))
              };
              switch (U) {
                case "vector":
                  this.workerSources[V][U][Y] = new X(oe, this._getLayerIndex(V), this._getAvailableImages(V));
                  break;
                case "geojson":
                  this.workerSources[V][U][Y] = new Vr(oe, this._getLayerIndex(V), this._getAvailableImages(V));
                  break;
                default:
                  this.workerSources[V][U][Y] = new this.externalWorkerSourceTypes[U](oe, this._getLayerIndex(V), this._getAvailableImages(V))
              }
            }
            return this.workerSources[V][U][Y]
          }
          _getDEMWorkerSource(V, U) {
            return this.demWorkerSources[V] || (this.demWorkerSources[V] = {}), this.demWorkerSources[V][U] || (this.demWorkerSources[V][U] = new Q), this.demWorkerSources[V][U]
          }
        }
        return b.i(self) && (self.worker = new qr(self)), qr
      })), k("index", ["exports", "./shared"], (function(b, s) {
        var F = "5.6.2";

        function O() {
          var p = new s.A(4);
          return s.A != Float32Array && (p[1] = 0, p[2] = 0), p[0] = 1, p[3] = 1, p
        }
        let G, X;
        const Q = {
          now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),
          frame(p, e, i) {
            const l = requestAnimationFrame((f => {
                u(), e(f)
              })),
              {
                unsubscribe: u
              } = s.s(p.signal, "abort", (() => {
                u(), cancelAnimationFrame(l), i(s.c())
              }), !1)
          },
          frameAsync(p) {
            return new Promise(((e, i) => {
              this.frame(p, e, i)
            }))
          },
          getImageData(p, e = 0) {
            return this.getImageCanvasContext(p).getImageData(-e, -e, p.width + 2 * e, p.height + 2 * e)
          },
          getImageCanvasContext(p) {
            const e = window.document.createElement("canvas"),
              i = e.getContext("2d", {
                willReadFrequently: !0
              });
            if (!i) throw new Error("failed to create canvas 2d context");
            return e.width = p.width, e.height = p.height, i.drawImage(p, 0, 0, p.width, p.height), i
          },
          resolveURL: p => (G || (G = document.createElement("a")), G.href = p, G.href),
          hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
          get prefersReducedMotion() {
            return !!matchMedia && (X == null && (X = matchMedia("(prefers-reduced-motion: reduce)")), X.matches)
          }
        };
        class W {
          static testProp(e) {
            if (!W.docStyle) return e[0];
            for (let i = 0; i < e.length; i++)
              if (e[i] in W.docStyle) return e[i];
            return e[0]
          }
          static create(e, i, l) {
            const u = window.document.createElement(e);
            return i !== void 0 && (u.className = i), l && l.appendChild(u), u
          }
          static createNS(e, i) {
            return window.document.createElementNS(e, i)
          }
          static disableDrag() {
            W.docStyle && W.selectProp && (W.userSelect = W.docStyle[W.selectProp], W.docStyle[W.selectProp] = "none")
          }
          static enableDrag() {
            W.docStyle && W.selectProp && (W.docStyle[W.selectProp] = W.userSelect)
          }
          static setTransform(e, i) {
            e.style[W.transformProp] = i
          }
          static addEventListener(e, i, l, u = {}) {
            e.addEventListener(i, l, "passive" in u ? u : u.capture)
          }
          static removeEventListener(e, i, l, u = {}) {
            e.removeEventListener(i, l, "passive" in u ? u : u.capture)
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", W.suppressClickInternal, !0)
          }
          static suppressClick() {
            window.addEventListener("click", W.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", W.suppressClickInternal, !0)
            }), 0)
          }
          static getScale(e) {
            const i = e.getBoundingClientRect();
            return {
              x: i.width / e.offsetWidth || 1,
              y: i.height / e.offsetHeight || 1,
              boundingClientRect: i
            }
          }
          static getPoint(e, i, l) {
            const u = i.boundingClientRect;
            return new s.P((l.clientX - u.left) / i.x - e.clientLeft, (l.clientY - u.top) / i.y - e.clientTop)
          }
          static mousePos(e, i) {
            const l = W.getScale(e);
            return W.getPoint(e, l, i)
          }
          static touchPos(e, i) {
            const l = [],
              u = W.getScale(e);
            for (let f = 0; f < i.length; f++) l.push(W.getPoint(e, u, i[f]));
            return l
          }
          static mouseButton(e) {
            return e.button
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e)
          }
          static sanitize(e) {
            const i = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"),
              l = i.querySelectorAll("script");
            for (const u of l) u.remove();
            return W.clean(i), i.innerHTML
          }
          static isPossiblyDangerous(e, i) {
            const l = i.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !l.includes("javascript:") && !l.includes("data:")) || !!e.startsWith("on") || void 0
          }
          static clean(e) {
            const i = e.children;
            for (const l of i) W.removeAttributes(l), W.clean(l)
          }
          static removeAttributes(e) {
            for (const {
                name: i,
                value: l
              }
              of e.attributes) W.isPossiblyDangerous(i, l) && e.removeAttribute(i)
          }
        }
        W.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, W.selectProp = W.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), W.transformProp = W.testProp(["transform", "WebkitTransform"]);
        const de = {
          supported: !1,
          testSupport: function(p) {
            !xe && Ae && (Ie ? Pe(p) : _e = p)
          }
        };
        let _e, Ae, xe = !1,
          Ie = !1;

        function Pe(p) {
          const e = p.createTexture();
          p.bindTexture(p.TEXTURE_2D, e);
          try {
            if (p.texImage2D(p.TEXTURE_2D, 0, p.RGBA, p.RGBA, p.UNSIGNED_BYTE, Ae), p.isContextLost()) return;
            de.supported = !0
          } catch {}
          p.deleteTexture(e), xe = !0
        }
        var De;
        typeof document < "u" && (Ae = document.createElement("img"), Ae.onload = () => {
          _e && Pe(_e), _e = null, Ie = !0
        }, Ae.onerror = () => {
          xe = !0, _e = null
        }, Ae.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(p) {
          let e, i, l, u;
          p.resetRequestQueue = () => {
            e = [], i = 0, l = 0, u = {}
          }, p.addThrottleControl = T => {
            const M = l++;
            return u[M] = T, M
          }, p.removeThrottleControl = T => {
            delete u[T], g()
          }, p.getImage = (T, M, z = !0) => new Promise(((R, D) => {
            de.supported && (T.headers || (T.headers = {}), T.headers.accept = "image/webp,*/*"), s.e(T, {
              type: "image"
            }), e.push({
              abortController: M,
              requestParameters: T,
              supportImageRefresh: z,
              state: "queued",
              onError: N => {
                D(N)
              },
              onSuccess: N => {
                R(N)
              }
            }), g()
          }));
          const f = T => s._(this, void 0, void 0, (function*() {
              T.state = "running";
              const {
                requestParameters: M,
                supportImageRefresh: z,
                onError: R,
                onSuccess: D,
                abortController: N
              } = T, H = z === !1 && !s.i(self) && !s.g(M.url) && (!M.headers || Object.keys(M.headers).reduce(((se, pe) => se && pe === "accept"), !0));
              i++;
              const ie = H ? C(M, N) : s.m(M, N);
              try {
                const se = yield ie;
                delete T.abortController, T.state = "completed", se.data instanceof HTMLImageElement || s.b(se.data) ? D(se) : se.data && D({
                  data: yield(ne = se.data, typeof createImageBitmap == "function" ? s.f(ne) : s.h(ne)),
                  cacheControl: se.cacheControl,
                  expires: se.expires
                })
              } catch (se) {
                delete T.abortController, R(se)
              } finally {
                i--, g()
              }
              var ne
            })),
            g = () => {
              const T = (() => {
                for (const M of Object.keys(u))
                  if (u[M]()) return !0;
                return !1
              })() ? s.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : s.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let M = i; M < T && e.length > 0; M++) {
                const z = e.shift();
                z.abortController.signal.aborted ? M-- : f(z)
              }
            },
            C = (T, M) => new Promise(((z, R) => {
              const D = new Image,
                N = T.url,
                H = T.credentials;
              H && H === "include" ? D.crossOrigin = "use-credentials" : (H && H === "same-origin" || !s.d(N)) && (D.crossOrigin = "anonymous"), M.signal.addEventListener("abort", (() => {
                D.src = "", R(s.c())
              })), D.fetchPriority = "high", D.onload = () => {
                D.onerror = D.onload = null, z({
                  data: D
                })
              }, D.onerror = () => {
                D.onerror = D.onload = null, M.signal.aborted || R(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
              }, D.src = N
            }))
        })(De || (De = {})), De.resetRequestQueue();
        class $e {
          constructor(e) {
            this._transformRequestFn = e ?? null
          }
          transformRequest(e, i) {
            return this._transformRequestFn && this._transformRequestFn(e, i) || {
              url: e
            }
          }
          setTransformRequest(e) {
            this._transformRequestFn = e
          }
        }

        function tt(p) {
          const e = [];
          if (typeof p == "string") e.push({
            id: "default",
            url: p
          });
          else if (p && p.length > 0) {
            const i = [];
            for (const {
                id: l,
                url: u
              }
              of p) {
              const f = `${l}${u}`;
              i.indexOf(f) === -1 && (i.push(f), e.push({
                id: l,
                url: u
              }))
            }
          }
          return e
        }

        function Ve(p, e, i) {
          try {
            const l = new URL(p);
            return l.pathname += `${e}${i}`, l.toString()
          } catch {
            throw new Error(`Invalid sprite URL "${p}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
          }
        }

        function Re(p) {
          const {
            userImage: e
          } = p;
          return !!(e && e.render && e.render()) && (p.data.replace(new Uint8Array(e.data.buffer)), !0)
        }
        class Ue extends s.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new s.R({
              width: 1,
              height: 1
            }), this.dirty = !0
          }
          isLoaded() {
            return this.loaded
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const {
                  ids: i,
                  promiseResolve: l
                }
                of this.requestors) l(this._getImagesForIds(i));
              this.requestors = []
            }
          }
          getImage(e) {
            const i = this.images[e];
            if (i && !i.data && i.spriteData) {
              const l = i.spriteData;
              i.data = new s.R({
                width: l.width,
                height: l.height
              }, l.context.getImageData(l.x, l.y, l.width, l.height).data), i.spriteData = null
            }
            return i
          }
          addImage(e, i) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, i) && (this.images[e] = i)
          }
          _validate(e, i) {
            let l = !0;
            const u = i.data || i.spriteData;
            return this._validateStretch(i.stretchX, u && u.width) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchX" value`))), l = !1), this._validateStretch(i.stretchY, u && u.height) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchY" value`))), l = !1), this._validateContent(i.content, i) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "content" value`))), l = !1), l
          }
          _validateStretch(e, i) {
            if (!e) return !0;
            let l = 0;
            for (const u of e) {
              if (u[0] < l || u[1] < u[0] || i < u[1]) return !1;
              l = u[1]
            }
            return !0
          }
          _validateContent(e, i) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const l = i.spriteData,
              u = l && l.width || i.data.width,
              f = l && l.height || i.data.height;
            return !(e[0] < 0 || u < e[0] || e[1] < 0 || f < e[1] || e[2] < 0 || u < e[2] || e[3] < 0 || f < e[3] || e[2] < e[0] || e[3] < e[1])
          }
          updateImage(e, i, l = !0) {
            const u = this.getImage(e);
            if (l && (u.data.width !== i.data.width || u.data.height !== i.data.height)) throw new Error(`size mismatch between old image (${u.data.width}x${u.data.height}) and new image (${i.data.width}x${i.data.height}).`);
            i.version = u.version + 1, this.images[e] = i, this.updatedImages[e] = !0
          }
          removeImage(e) {
            const i = this.images[e];
            delete this.images[e], delete this.patterns[e], i.userImage && i.userImage.onRemove && i.userImage.onRemove()
          }
          listImages() {
            return Object.keys(this.images)
          }
          getImages(e) {
            return new Promise(((i, l) => {
              let u = !0;
              if (!this.isLoaded())
                for (const f of e) this.images[f] || (u = !1);
              this.isLoaded() || u ? i(this._getImagesForIds(e)) : this.requestors.push({
                ids: e,
                promiseResolve: i
              })
            }))
          }
          _getImagesForIds(e) {
            const i = {};
            for (const l of e) {
              let u = this.getImage(l);
              u || (this.fire(new s.l("styleimagemissing", {
                id: l
              })), u = this.getImage(l)), u ? i[l] = {
                data: u.data.clone(),
                pixelRatio: u.pixelRatio,
                sdf: u.sdf,
                version: u.version,
                stretchX: u.stretchX,
                stretchY: u.stretchY,
                content: u.content,
                textFitWidth: u.textFitWidth,
                textFitHeight: u.textFitHeight,
                hasRenderCallback: !!(u.userImage && u.userImage.render)
              } : s.w(`Image "${l}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
            }
            return i
          }
          getPixelSize() {
            const {
              width: e,
              height: i
            } = this.atlasImage;
            return {
              width: e,
              height: i
            }
          }
          getPattern(e) {
            const i = this.patterns[e],
              l = this.getImage(e);
            if (!l) return null;
            if (i && i.position.version === l.version) return i.position;
            if (i) i.position.version = l.version;
            else {
              const u = {
                  w: l.data.width + 2,
                  h: l.data.height + 2,
                  x: 0,
                  y: 0
                },
                f = new s.I(u, l);
              this.patterns[e] = {
                bin: u,
                position: f
              }
            }
            return this._updatePatternAtlas(), this.patterns[e].position
          }
          bind(e) {
            const i = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new s.T(e, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE)
          }
          _updatePatternAtlas() {
            const e = [];
            for (const f in this.patterns) e.push(this.patterns[f].bin);
            const {
              w: i,
              h: l
            } = s.p(e), u = this.atlasImage;
            u.resize({
              width: i || 1,
              height: l || 1
            });
            for (const f in this.patterns) {
              const {
                bin: g
              } = this.patterns[f], C = g.x + 1, T = g.y + 1, M = this.getImage(f).data, z = M.width, R = M.height;
              s.R.copy(M, u, {
                x: 0,
                y: 0
              }, {
                x: C,
                y: T
              }, {
                width: z,
                height: R
              }), s.R.copy(M, u, {
                x: 0,
                y: R - 1
              }, {
                x: C,
                y: T - 1
              }, {
                width: z,
                height: 1
              }), s.R.copy(M, u, {
                x: 0,
                y: 0
              }, {
                x: C,
                y: T + R
              }, {
                width: z,
                height: 1
              }), s.R.copy(M, u, {
                x: z - 1,
                y: 0
              }, {
                x: C - 1,
                y: T
              }, {
                width: 1,
                height: R
              }), s.R.copy(M, u, {
                x: 0,
                y: 0
              }, {
                x: C + z,
                y: T
              }, {
                width: 1,
                height: R
              })
            }
            this.dirty = !0
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {}
          }
          dispatchRenderCallbacks(e) {
            for (const i of e) {
              if (this.callbackDispatchedThisFrame[i]) continue;
              this.callbackDispatchedThisFrame[i] = !0;
              const l = this.getImage(i);
              l || s.w(`Image with ID: "${i}" was not found`), Re(l) && this.updateImage(i, l)
            }
          }
        }
        const Ce = 1e20;

        function We(p, e, i, l, u, f, g, C, T) {
          for (let M = e; M < e + l; M++) Je(p, i * f + M, f, u, g, C, T);
          for (let M = i; M < i + u; M++) Je(p, M * f + e, 1, l, g, C, T)
        }

        function Je(p, e, i, l, u, f, g) {
          f[0] = 0, g[0] = -Ce, g[1] = Ce, u[0] = p[e];
          for (let C = 1, T = 0, M = 0; C < l; C++) {
            u[C] = p[e + C * i];
            const z = C * C;
            do {
              const R = f[T];
              M = (u[C] - u[R] + z - R * R) / (C - R) / 2
            } while (M <= g[T] && --T > -1);
            T++, f[T] = C, g[T] = M, g[T + 1] = Ce
          }
          for (let C = 0, T = 0; C < l; C++) {
            for (; g[T + 1] < C;) T++;
            const M = f[T],
              z = C - M;
            p[e + C * i] = u[M] + z * z
          }
        }
        class Ge {
          constructor(e, i) {
            this.requestManager = e, this.localIdeographFontFamily = i, this.entries = {}
          }
          setURL(e) {
            this.url = e
          }
          getGlyphs(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = [];
              for (const f in e)
                for (const g of e[f]) i.push(this._getAndCacheGlyphsPromise(f, g));
              const l = yield Promise.all(i), u = {};
              for (const {
                  stack: f,
                  id: g,
                  glyph: C
                }
                of l) u[f] || (u[f] = {}), u[f][g] = C && {
                id: C.id,
                bitmap: C.bitmap.clone(),
                metrics: C.metrics
              };
              return u
            }))
          }
          _getAndCacheGlyphsPromise(e, i) {
            return s._(this, void 0, void 0, (function*() {
              let l = this.entries[e];
              l || (l = this.entries[e] = {
                glyphs: {},
                requests: {},
                ranges: {}
              });
              let u = l.glyphs[i];
              if (u !== void 0) return {
                stack: e,
                id: i,
                glyph: u
              };
              if (u = this._tinySDF(l, e, i), u) return l.glyphs[i] = u, {
                stack: e,
                id: i,
                glyph: u
              };
              const f = Math.floor(i / 256);
              if (256 * f > 65535) throw new Error("glyphs > 65535 not supported");
              if (l.ranges[f]) return {
                stack: e,
                id: i,
                glyph: u
              };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!l.requests[f]) {
                const C = Ge.loadGlyphRange(e, f, this.url, this.requestManager);
                l.requests[f] = C
              }
              const g = yield l.requests[f];
              for (const C in g) this._doesCharSupportLocalGlyph(+C) || (l.glyphs[+C] = g[+C]);
              return l.ranges[f] = !0, {
                stack: e,
                id: i,
                glyph: g[i] || null
              }
            }))
          }
          _doesCharSupportLocalGlyph(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || s.u["CJK Unified Ideographs"](e) || s.u["Hangul Syllables"](e) || s.u.Hiragana(e) || s.u.Katakana(e) || s.u["CJK Symbols and Punctuation"](e) || s.u["Halfwidth and Fullwidth Forms"](e))
          }
          _tinySDF(e, i, l) {
            const u = this.localIdeographFontFamily;
            if (!u || !this._doesCharSupportLocalGlyph(l)) return;
            let f = e.tinySDF;
            if (!f) {
              let C = "400";
              /bold/i.test(i) ? C = "900" : /medium/i.test(i) ? C = "500" : /light/i.test(i) && (C = "200"), f = e.tinySDF = new Ge.TinySDF({
                fontSize: 48,
                buffer: 6,
                radius: 16,
                cutoff: .25,
                fontFamily: u,
                fontWeight: C
              })
            }
            const g = f.draw(String.fromCharCode(l));
            return {
              id: l,
              bitmap: new s.q({
                width: g.width || 60,
                height: g.height || 60
              }, g.data),
              metrics: {
                width: g.glyphWidth / 2 || 24,
                height: g.glyphHeight / 2 || 24,
                left: g.glyphLeft / 2 + .5 || 0,
                top: g.glyphTop / 2 - 27.5 || -8,
                advance: g.glyphAdvance / 2 || 24,
                isDoubleResolution: !0
              }
            }
          }
        }
        Ge.loadGlyphRange = function(p, e, i, l) {
          return s._(this, void 0, void 0, (function*() {
            const u = 256 * e,
              f = u + 255,
              g = l.transformRequest(i.replace("{fontstack}", p).replace("{range}", `${u}-${f}`), "Glyphs"),
              C = yield s.n(g, new AbortController);
            if (!C || !C.data) throw new Error(`Could not load glyph range. range: ${e}, ${u}-${f}`);
            const T = {};
            for (const M of s.o(C.data)) T[M.id] = M;
            return T
          }))
        }, Ge.TinySDF = class {
          constructor({
            fontSize: p = 24,
            buffer: e = 3,
            radius: i = 8,
            cutoff: l = .25,
            fontFamily: u = "sans-serif",
            fontWeight: f = "normal",
            fontStyle: g = "normal",
            lang: C = null
          } = {}) {
            this.buffer = e, this.cutoff = l, this.radius = i, this.lang = C;
            const T = this.size = p + 4 * e,
              M = this._createCanvas(T),
              z = this.ctx = M.getContext("2d", {
                willReadFrequently: !0
              });
            z.font = `${g} ${f} ${p}px ${u}`, z.textBaseline = "alphabetic", z.textAlign = "left", z.fillStyle = "black", this.gridOuter = new Float64Array(T * T), this.gridInner = new Float64Array(T * T), this.f = new Float64Array(T), this.z = new Float64Array(T + 1), this.v = new Uint16Array(T)
          }
          _createCanvas(p) {
            const e = document.createElement("canvas");
            return e.width = e.height = p, e
          }
          draw(p) {
            const {
              width: e,
              actualBoundingBoxAscent: i,
              actualBoundingBoxDescent: l,
              actualBoundingBoxLeft: u,
              actualBoundingBoxRight: f
            } = this.ctx.measureText(p), g = Math.ceil(i), C = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(f - u))), T = Math.min(this.size - this.buffer, g + Math.ceil(l)), M = C + 2 * this.buffer, z = T + 2 * this.buffer, R = Math.max(M * z, 0), D = new Uint8ClampedArray(R), N = {
              data: D,
              width: M,
              height: z,
              glyphWidth: C,
              glyphHeight: T,
              glyphTop: g,
              glyphLeft: 0,
              glyphAdvance: e
            };
            if (C === 0 || T === 0) return N;
            const {
              ctx: H,
              buffer: ie,
              gridInner: ne,
              gridOuter: se
            } = this;
            this.lang && (H.lang = this.lang), H.clearRect(ie, ie, C, T), H.fillText(p, ie, ie + g);
            const pe = H.getImageData(ie, ie, C, T);
            se.fill(Ce, 0, R), ne.fill(0, 0, R);
            for (let ye = 0; ye < T; ye++)
              for (let ge = 0; ge < C; ge++) {
                const Te = pe.data[4 * (ye * C + ge) + 3] / 255;
                if (Te === 0) continue;
                const Le = (ye + ie) * M + ge + ie;
                if (Te === 1) se[Le] = 0, ne[Le] = Ce;
                else {
                  const ve = .5 - Te;
                  se[Le] = ve > 0 ? ve * ve : 0, ne[Le] = ve < 0 ? ve * ve : 0
                }
              }
            We(se, 0, 0, M, z, M, this.f, this.v, this.z), We(ne, ie, ie, C, T, M, this.f, this.v, this.z);
            for (let ye = 0; ye < R; ye++) {
              const ge = Math.sqrt(se[ye]) - Math.sqrt(ne[ye]);
              D[ye] = Math.round(255 - 255 * (ge / this.radius + this.cutoff))
            }
            return N
          }
        };
        class Ee {
          constructor() {
            this.specification = s.v.light.position
          }
          possiblyEvaluate(e, i) {
            return s.B(e.expression.evaluate(i))
          }
          interpolate(e, i, l) {
            return {
              x: s.C.number(e.x, i.x, l),
              y: s.C.number(e.y, i.y, l),
              z: s.C.number(e.z, i.z, l)
            }
          }
        }
        let mt;
        class K extends s.E {
          constructor(e) {
            super(), mt = mt || new s.r({
              anchor: new s.D(s.v.light.anchor),
              position: new Ee,
              color: new s.D(s.v.light.color),
              intensity: new s.D(s.v.light.intensity)
            }), this._transitionable = new s.t(mt), this.setLight(e), this._transitioning = this._transitionable.untransitioned()
          }
          getLight() {
            return this._transitionable.serialize()
          }
          setLight(e, i = {}) {
            if (!this._validate(s.x, e, i))
              for (const l in e) {
                const u = e[l];
                l.endsWith("-transition") ? this._transitionable.setTransition(l.slice(0, -11), u) : this._transitionable.setValue(l, u)
              }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, i, l) {
            return (!l || l.validate !== !1) && s.y(this, e.call(s.z, {
              value: i,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: s.v
            }))
          }
        }
        const ee = new s.r({
          "sky-color": new s.D(s.v.sky["sky-color"]),
          "horizon-color": new s.D(s.v.sky["horizon-color"]),
          "fog-color": new s.D(s.v.sky["fog-color"]),
          "fog-ground-blend": new s.D(s.v.sky["fog-ground-blend"]),
          "horizon-fog-blend": new s.D(s.v.sky["horizon-fog-blend"]),
          "sky-horizon-blend": new s.D(s.v.sky["sky-horizon-blend"]),
          "atmosphere-blend": new s.D(s.v.sky["atmosphere-blend"])
        });
        class le extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.t(ee), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.F(0))
          }
          setSky(e, i = {}) {
            if (!this._validate(s.G, e, i)) {
              e || (e = {
                "sky-color": "transparent",
                "horizon-color": "transparent",
                "fog-color": "transparent",
                "fog-ground-blend": 1,
                "atmosphere-blend": 0
              });
              for (const l in e) {
                const u = e[l];
                l.endsWith("-transition") ? this._transitionable.setTransition(l.slice(0, -11), u) : this._transitionable.setValue(l, u)
              }
            }
          }
          getSky() {
            return this._transitionable.serialize()
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, i, l = {}) {
            return (l == null ? void 0 : l.validate) !== !1 && s.y(this, e.call(s.z, s.e({
              value: i,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: s.v
            })))
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
          }
        }
        class ae {
          constructor(e, i) {
            this.width = e, this.height = i, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {}
          }
          getDash(e, i) {
            const l = e.join(",") + String(i);
            return this.dashEntry[l] || (this.dashEntry[l] = this.addDash(e, i)), this.dashEntry[l]
          }
          getDashRanges(e, i, l) {
            const u = [];
            let f = e.length % 2 == 1 ? -e[e.length - 1] * l : 0,
              g = e[0] * l,
              C = !0;
            u.push({
              left: f,
              right: g,
              isDash: C,
              zeroLength: e[0] === 0
            });
            let T = e[0];
            for (let M = 1; M < e.length; M++) {
              C = !C;
              const z = e[M];
              f = T * l, T += z, g = T * l, u.push({
                left: f,
                right: g,
                isDash: C,
                zeroLength: z === 0
              })
            }
            return u
          }
          addRoundDash(e, i, l) {
            const u = i / 2;
            for (let f = -l; f <= l; f++) {
              const g = this.width * (this.nextRow + l + f);
              let C = 0,
                T = e[C];
              for (let M = 0; M < this.width; M++) {
                M / T.right > 1 && (T = e[++C]);
                const z = Math.abs(M - T.left),
                  R = Math.abs(M - T.right),
                  D = Math.min(z, R);
                let N;
                const H = f / l * (u + 1);
                if (T.isDash) {
                  const ie = u - Math.abs(H);
                  N = Math.sqrt(D * D + ie * ie)
                } else N = u - Math.sqrt(D * D + H * H);
                this.data[g + M] = Math.max(0, Math.min(255, N + 128))
              }
            }
          }
          addRegularDash(e) {
            for (let C = e.length - 1; C >= 0; --C) {
              const T = e[C],
                M = e[C + 1];
              T.zeroLength ? e.splice(C, 1) : M && M.isDash === T.isDash && (M.left = T.left, e.splice(C, 1))
            }
            const i = e[0],
              l = e[e.length - 1];
            i.isDash === l.isDash && (i.left = l.left - this.width, l.right = i.right + this.width);
            const u = this.width * this.nextRow;
            let f = 0,
              g = e[f];
            for (let C = 0; C < this.width; C++) {
              C / g.right > 1 && (g = e[++f]);
              const T = Math.abs(C - g.left),
                M = Math.abs(C - g.right),
                z = Math.min(T, M);
              this.data[u + C] = Math.max(0, Math.min(255, (g.isDash ? z : -z) + 128))
            }
          }
          addDash(e, i) {
            const l = i ? 7 : 0,
              u = 2 * l + 1;
            if (this.nextRow + u > this.height) return s.w("LineAtlas out of space"), null;
            let f = 0;
            for (let C = 0; C < e.length; C++) f += e[C];
            if (f !== 0) {
              const C = this.width / f,
                T = this.getDashRanges(e, this.width, C);
              i ? this.addRoundDash(T, C, l) : this.addRegularDash(T)
            }
            const g = {
              y: (this.nextRow + l + .5) / this.height,
              height: 2 * l / this.height,
              width: f
            };
            return this.nextRow += u, this.dirty = !0, g
          }
          bind(e) {
            const i = e.gl;
            this.texture ? (i.bindTexture(i.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, this.width, this.height, i.ALPHA, i.UNSIGNED_BYTE, this.data))) : (this.texture = i.createTexture(), i.bindTexture(i.TEXTURE_2D, this.texture), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), i.texImage2D(i.TEXTURE_2D, 0, i.ALPHA, this.width, this.height, 0, i.ALPHA, i.UNSIGNED_BYTE, this.data))
          }
        }
        const ke = "maplibre_preloaded_worker_pool";
        class qe {
          constructor() {
            this.active = {}
          }
          acquire(e) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < qe.workerCount;) this.workers.push(new Worker(s.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice()
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach((i => {
              i.terminate()
            })), this.workers = null)
          }
          isPreloaded() {
            return !!this.active[ke]
          }
          numActive() {
            return Object.keys(this.active).length
          }
        }
        const lt = Math.floor(Q.hardwareConcurrency / 2);
        let ot, dt;

        function Pt() {
          return ot || (ot = new qe), ot
        }
        qe.workerCount = s.H(globalThis) ? Math.max(Math.min(lt, 3), 1) : 1;
        class Lt {
          constructor(e, i) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = i;
            const l = this.workerPool.acquire(i);
            for (let u = 0; u < l.length; u++) {
              const f = new s.J(l[u], i);
              f.name = `Worker ${u}`, this.actors.push(f)
            }
            if (!this.actors.length) throw new Error("No actors found")
          }
          broadcast(e, i) {
            const l = [];
            for (const u of this.actors) l.push(u.sendAsync({
              type: e,
              data: i
            }));
            return Promise.all(l)
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
          }
          remove(e = !0) {
            this.actors.forEach((i => {
              i.remove()
            })), this.actors = [], e && this.workerPool.release(this.id)
          }
          registerMessageHandler(e, i) {
            for (const l of this.actors) l.registerMessageHandler(e, i)
          }
        }

        function He() {
          return dt || (dt = new Lt(Pt(), s.K), dt.registerMessageHandler("GR", ((p, e, i) => s.m(e, i)))), dt
        }

        function ut(p, e) {
          const i = s.L();
          return s.M(i, i, [1, 1, 0]), s.N(i, i, [.5 * p.width, .5 * p.height, 1]), p.calculatePosMatrix ? s.O(i, i, p.calculatePosMatrix(e.toUnwrapped())) : i
        }

        function gt(p, e, i, l, u, f, g) {
          var C;
          const T = (function(D, N, H) {
              if (D)
                for (const ie of D) {
                  const ne = N[ie];
                  if (ne && ne.source === H && ne.type === "fill-extrusion") return !0
                } else
                  for (const ie in N) {
                    const ne = N[ie];
                    if (ne.source === H && ne.type === "fill-extrusion") return !0
                  }
              return !1
            })((C = u == null ? void 0 : u.layers) !== null && C !== void 0 ? C : null, e, p.id),
            M = f.maxPitchScaleFactor(),
            z = p.tilesIn(l, M, T);
          z.sort(St);
          const R = [];
          for (const D of z) R.push({
            wrappedTileID: D.tileID.wrapped().key,
            queryResults: D.tile.queryRenderedFeatures(e, i, p._state, D.queryGeometry, D.cameraQueryGeometry, D.scale, u, f, M, ut(p.transform, D.tileID), g ? (N, H) => g(D.tileID, N, H) : void 0)
          });
          return (function(D, N) {
            for (const H in D)
              for (const ie of D[H]) vt(ie, N);
            return D
          })((function(D) {
            const N = {},
              H = {};
            for (const ie of D) {
              const ne = ie.queryResults,
                se = ie.wrappedTileID,
                pe = H[se] = H[se] || {};
              for (const ye in ne) {
                const ge = ne[ye],
                  Te = pe[ye] = pe[ye] || {},
                  Le = N[ye] = N[ye] || [];
                for (const ve of ge) Te[ve.featureIndex] || (Te[ve.featureIndex] = !0, Le.push(ve))
              }
            }
            return N
          })(R), p)
        }

        function St(p, e) {
          const i = p.tileID,
            l = e.tileID;
          return i.overscaledZ - l.overscaledZ || i.canonical.y - l.canonical.y || i.wrap - l.wrap || i.canonical.x - l.canonical.x
        }

        function vt(p, e) {
          const i = p.feature,
            l = e.getFeatureState(i.layer["source-layer"], i.id);
          i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = l
        }

        function Ct(p, e, i) {
          return s._(this, void 0, void 0, (function*() {
            let l = p;
            if (p.url ? l = (yield s.j(e.transformRequest(p.url, "Source"), i)).data : yield Q.frameAsync(i), !l) return null;
            const u = s.Q(s.e(l, p), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in l && l.vector_layers && (u.vectorLayerIds = l.vector_layers.map((f => f.id))), u
          }))
        }
        class At {
          constructor(e, i) {
            e && (i ? this.setSouthWest(e).setNorthEast(i) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
          }
          setNorthEast(e) {
            return this._ne = e instanceof s.S ? new s.S(e.lng, e.lat) : s.S.convert(e), this
          }
          setSouthWest(e) {
            return this._sw = e instanceof s.S ? new s.S(e.lng, e.lat) : s.S.convert(e), this
          }
          extend(e) {
            const i = this._sw,
              l = this._ne;
            let u, f;
            if (e instanceof s.S) u = e, f = e;
            else {
              if (!(e instanceof At)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(At.convert(e)) : this.extend(s.S.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(s.S.convert(e)) : this;
              if (u = e._sw, f = e._ne, !u || !f) return this
            }
            return i || l ? (i.lng = Math.min(u.lng, i.lng), i.lat = Math.min(u.lat, i.lat), l.lng = Math.max(f.lng, l.lng), l.lat = Math.max(f.lat, l.lat)) : (this._sw = new s.S(u.lng, u.lat), this._ne = new s.S(f.lng, f.lat)), this
          }
          getCenter() {
            return new s.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
          }
          getSouthWest() {
            return this._sw
          }
          getNorthEast() {
            return this._ne
          }
          getNorthWest() {
            return new s.S(this.getWest(), this.getNorth())
          }
          getSouthEast() {
            return new s.S(this.getEast(), this.getSouth())
          }
          getWest() {
            return this._sw.lng
          }
          getSouth() {
            return this._sw.lat
          }
          getEast() {
            return this._ne.lng
          }
          getNorth() {
            return this._ne.lat
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()]
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
          }
          isEmpty() {
            return !(this._sw && this._ne)
          }
          contains(e) {
            const {
              lng: i,
              lat: l
            } = s.S.convert(e);
            let u = this._sw.lng <= i && i <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (u = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= l && l <= this._ne.lat && u
          }
          static convert(e) {
            return e instanceof At ? e : e && new At(e)
          }
          static fromLngLat(e, i = 0) {
            const l = 360 * i / 40075017,
              u = l / Math.cos(Math.PI / 180 * e.lat);
            return new At(new s.S(e.lng - u, e.lat - l), new s.S(e.lng + u, e.lat + l))
          }
          adjustAntiMeridian() {
            const e = new s.S(this._sw.lng, this._sw.lat),
              i = new s.S(this._ne.lng, this._ne.lat);
            return new At(e, e.lng > i.lng ? new s.S(i.lng + 360, i.lat) : i)
          }
        }
        class Bt {
          constructor(e, i, l) {
            this.bounds = At.convert(this.validateBounds(e)), this.minzoom = i || 0, this.maxzoom = l || 24
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
          }
          contains(e) {
            const i = Math.pow(2, e.z),
              l = Math.floor(s.V(this.bounds.getWest()) * i),
              u = Math.floor(s.U(this.bounds.getNorth()) * i),
              f = Math.ceil(s.V(this.bounds.getEast()) * i),
              g = Math.ceil(s.U(this.bounds.getSouth()) * i);
            return e.x >= l && e.x < f && e.y >= u && e.y < g
          }
        }
        class Vt extends s.E {
          constructor(e, i, l, u) {
            if (super(), this.id = e, this.dispatcher = l, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, s.e(this, s.Q(i, ["url", "scheme", "tileSize", "promoteId"])), this._options = s.e({
                type: "vector"
              }, i), this._collectResourceTiming = i.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(u)
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const e = yield Ct(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (s.e(this, e), e.bounds && (this.tileBounds = new Bt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "content"
                })))
              } catch (e) {
                this._tileJSONRequest = null, this.fire(new s.k(e))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load()
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          serialize() {
            return s.e({}, this._options)
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                l = {
                  request: this.map._requestManager.transformRequest(i, "Tile"),
                  uid: e.uid,
                  tileID: e.tileID,
                  zoom: e.tileID.overscaledZ,
                  tileSize: this.tileSize * e.tileID.overscaleFactor(),
                  type: this.type,
                  source: this.id,
                  pixelRatio: this.map.getPixelRatio(),
                  showCollisionBoxes: this.map.showCollisionBoxes,
                  promoteId: this.promoteId,
                  subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                  globalState: this.map.getGlobalState()
                };
              l.request.collectResourceTiming = this._collectResourceTiming;
              let u = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((f, g) => {
                  e.reloadPromise = {
                    resolve: f,
                    reject: g
                  }
                }))
              } else e.actor = this.dispatcher.getActor(), u = "LT";
              e.abortController = new AbortController;
              try {
                const f = yield e.actor.sendAsync({
                  type: u,
                  data: l
                }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, f)
              } catch (f) {
                if (delete e.abortController, e.aborted) return;
                if (f && f.status !== 404) throw f;
                this._afterTileLoadWorkerResponse(e, null)
              }
            }))
          }
          _afterTileLoadWorkerResponse(e, i) {
            if (i && i.resourceTiming && (e.resourceTiming = i.resourceTiming), i && this.map._refreshExpiredTiles && e.setExpiryData(i), e.loadVectorData(i, this.map.painter), e.reloadPromise) {
              const l = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(l.resolve).catch(l.reject)
            }
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({
                type: "AT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class Ot extends s.E {
          constructor(e, i, l, u) {
            super(), this.id = e, this.dispatcher = l, this.setEventedParent(u), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = s.e({
              type: "raster"
            }, i), s.e(this, s.Q(i, ["url", "scheme", "tileSize"]))
          }
          load() {
            return s._(this, arguments, void 0, (function*(e = !1) {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const i = yield Ct(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, i && (s.e(this, i), i.bounds && (this.tileBounds = new Bt(i.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "content",
                  sourceDataChanged: e
                })))
              } catch (i) {
                this._tileJSONRequest = null, this.fire(new s.k(i))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0)
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          serialize() {
            return s.e({}, this._options)
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController;
              try {
                const l = yield De.getImage(this.map._requestManager.transformRequest(i, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (l && l.data) {
                  this.map._refreshExpiredTiles && (l.cacheControl || l.expires) && e.setExpiryData({
                    cacheControl: l.cacheControl,
                    expires: l.expires
                  });
                  const u = this.map.painter.context,
                    f = u.gl,
                    g = l.data;
                  e.texture = this.map.painter.getTileTexture(g.width), e.texture ? e.texture.update(g, {
                    useMipmap: !0
                  }) : (e.texture = new s.T(u, g, f.RGBA, {
                    useMipmap: !0
                  }), e.texture.bind(f.LINEAR, f.CLAMP_TO_EDGE, f.LINEAR_MIPMAP_NEAREST)), e.state = "loaded"
                }
              } catch (l) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (l) throw e.state = "errored", l
              }
            }))
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController)
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.texture && this.map.painter.saveTileTexture(e.texture)
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class Dt extends Ot {
          constructor(e, i, l, u) {
            super(e, i, l, u), this.type = "raster-dem", this.maxzoom = 22, this._options = s.e({
              type: "raster-dem"
            }, i), this.encoding = i.encoding || "mapbox", this.redFactor = i.redFactor, this.greenFactor = i.greenFactor, this.blueFactor = i.blueFactor, this.baseShift = i.baseShift
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                l = this.map._requestManager.transformRequest(i, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController;
              try {
                const u = yield De.getImage(l, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (u && u.data) {
                  const f = u.data;
                  this.map._refreshExpiredTiles && (u.cacheControl || u.expires) && e.setExpiryData({
                    cacheControl: u.cacheControl,
                    expires: u.expires
                  });
                  const g = s.b(f) && s.W() ? f : yield this.readImageNow(f), C = {
                    type: this.type,
                    uid: e.uid,
                    source: this.id,
                    rawImageData: g,
                    encoding: this.encoding,
                    redFactor: this.redFactor,
                    greenFactor: this.greenFactor,
                    blueFactor: this.blueFactor,
                    baseShift: this.baseShift
                  };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const T = yield e.actor.sendAsync({
                      type: "LDT",
                      data: C
                    });
                    e.dem = T, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded"
                  }
                }
              } catch (u) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (u) throw e.state = "errored", u
              }
            }))
          }
          readImageNow(e) {
            return s._(this, void 0, void 0, (function*() {
              if (typeof VideoFrame < "u" && s.X()) {
                const i = e.width + 2,
                  l = e.height + 2;
                try {
                  return new s.R({
                    width: i,
                    height: l
                  }, yield s.Y(e, -1, -1, i, l))
                } catch {}
              }
              return Q.getImageData(e, 1)
            }))
          }
          _getNeighboringTiles(e) {
            const i = e.canonical,
              l = Math.pow(2, i.z),
              u = (i.x - 1 + l) % l,
              f = i.x === 0 ? e.wrap - 1 : e.wrap,
              g = (i.x + 1 + l) % l,
              C = i.x + 1 === l ? e.wrap + 1 : e.wrap,
              T = {};
            return T[new s.Z(e.overscaledZ, f, i.z, u, i.y).key] = {
              backfilled: !1
            }, T[new s.Z(e.overscaledZ, C, i.z, g, i.y).key] = {
              backfilled: !1
            }, i.y > 0 && (T[new s.Z(e.overscaledZ, f, i.z, u, i.y - 1).key] = {
              backfilled: !1
            }, T[new s.Z(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = {
              backfilled: !1
            }, T[new s.Z(e.overscaledZ, C, i.z, g, i.y - 1).key] = {
              backfilled: !1
            }), i.y + 1 < l && (T[new s.Z(e.overscaledZ, f, i.z, u, i.y + 1).key] = {
              backfilled: !1
            }, T[new s.Z(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = {
              backfilled: !1
            }, T[new s.Z(e.overscaledZ, C, i.z, g, i.y + 1).key] = {
              backfilled: !1
            }), T
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({
                type: "RDT",
                data: {
                  type: this.type,
                  uid: e.uid,
                  source: this.id
                }
              }))
            }))
          }
        }
        class Rt extends s.E {
          constructor(e, i, l, u) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = {
              data: i.data
            }, this.actor = l.getActor(), this.setEventedParent(u), this._data = i.data, this._options = s.e({}, i), this._collectResourceTiming = i.collectResourceTiming, i.maxzoom !== void 0 && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId, i.clusterMaxZoom !== void 0 && this.maxzoom <= i.clusterMaxZoom && s.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`), this.workerOptions = s.e({
              source: this.id,
              cluster: i.cluster || !1,
              geojsonVtOptions: {
                buffer: this._pixelsToTileUnits(i.buffer !== void 0 ? i.buffer : 128),
                tolerance: this._pixelsToTileUnits(i.tolerance !== void 0 ? i.tolerance : .375),
                extent: s.$,
                maxZoom: this.maxzoom,
                lineMetrics: i.lineMetrics || !1,
                generateId: i.generateId || !1
              },
              superclusterOptions: {
                maxZoom: this._getClusterMaxZoom(i.clusterMaxZoom),
                minPoints: Math.max(2, i.clusterMinPoints || 2),
                extent: s.$,
                radius: this._pixelsToTileUnits(i.clusterRadius || 50),
                log: !1,
                generateId: i.generateId || !1
              },
              clusterProperties: i.clusterProperties,
              filter: i.filter
            }, i.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
          }
          _pixelsToTileUnits(e) {
            return e * (s.$ / this.tileSize)
          }
          _getClusterMaxZoom(e) {
            const i = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || s.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${i}"`), i
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              yield this._updateWorkerData()
            }))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = {
              data: e
            }, this._updateWorkerData(), this
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = s.a0(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this
          }
          getData() {
            return s._(this, void 0, void 0, (function*() {
              const e = s.e({
                type: this.type
              }, this.workerOptions);
              return this.actor.sendAsync({
                type: "GD",
                data: e
              })
            }))
          }
          getCoordinatesFromGeometry(e) {
            return e.type === "GeometryCollection" ? e.geometries.map((i => i.coordinates)).flat(1 / 0) : e.coordinates.flat(1 / 0)
          }
          getBounds() {
            return s._(this, void 0, void 0, (function*() {
              const e = new At,
                i = yield this.getData();
              let l;
              switch (i.type) {
                case "FeatureCollection":
                  l = i.features.map((u => this.getCoordinatesFromGeometry(u.geometry))).flat(1 / 0);
                  break;
                case "Feature":
                  l = this.getCoordinatesFromGeometry(i.geometry);
                  break;
                default:
                  l = this.getCoordinatesFromGeometry(i)
              }
              if (l.length == 0) return e;
              for (let u = 0; u < l.length - 1; u += 2) e.extend([l[u], l[u + 1]]);
              return e
            }))
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom))), this._updateWorkerData(), this
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({
              type: "GCEZ",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({
              type: "GCC",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterLeaves(e, i, l) {
            return this.actor.sendAsync({
              type: "GCL",
              data: {
                type: this.type,
                source: this.id,
                clusterId: e,
                limit: i,
                offset: l
              }
            })
          }
          _updateWorkerData() {
            return s._(this, void 0, void 0, (function*() {
              if (this._isUpdatingWorker) return;
              const {
                data: e,
                diff: i
              } = this._pendingWorkerUpdate;
              if (!e && !i) return void s.w(`No data or diff provided to GeoJSONSource ${this.id}.`);
              const l = s.e({
                type: this.type
              }, this.workerOptions);
              e ? (typeof e == "string" ? (l.request = this.map._requestManager.transformRequest(Q.resolveURL(e), "Source"), l.request.collectResourceTiming = this._collectResourceTiming) : l.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : i && (l.dataDiff = i, this._pendingWorkerUpdate.diff = void 0), this._isUpdatingWorker = !0, this.fire(new s.l("dataloading", {
                dataType: "source"
              }));
              try {
                const u = yield this.actor.sendAsync({
                  type: "LD",
                  data: l
                });
                if (this._isUpdatingWorker = !1, this._removed || u.abandoned) return void this.fire(new s.l("dataabort", {
                  dataType: "source"
                }));
                this._data = u.data;
                let f = null;
                u.resourceTiming && u.resourceTiming[this.id] && (f = u.resourceTiming[this.id].slice(0));
                const g = {
                  dataType: "source"
                };
                this._collectResourceTiming && f && f.length > 0 && s.e(g, {
                  resourceTiming: f
                }), this.fire(new s.l("data", Object.assign(Object.assign({}, g), {
                  sourceDataType: "metadata"
                }))), this.fire(new s.l("data", Object.assign(Object.assign({}, g), {
                  sourceDataType: "content"
                })))
              } catch (u) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new s.l("dataabort", {
                  dataType: "source"
                }));
                this.fire(new s.k(u))
              } finally {
                (this._pendingWorkerUpdate.data || this._pendingWorkerUpdate.diff) && this._updateWorkerData()
              }
            }))
          }
          loaded() {
            return !this._isUpdatingWorker && this._pendingWorkerUpdate.data === void 0 && this._pendingWorkerUpdate.diff === void 0
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const l = {
                type: this.type,
                uid: e.uid,
                tileID: e.tileID,
                zoom: e.tileID.overscaledZ,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                globalState: this.map.getGlobalState()
              };
              e.abortController = new AbortController;
              const u = yield this.actor.sendAsync({
                type: i,
                data: l
              }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(u, this.map.painter, i === "RT")
            }))
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), yield this.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              })
            }))
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({
              type: "RS",
              data: {
                type: this.type,
                source: this.id
              }
            })
          }
          serialize() {
            return s.e({}, this._options, {
              type: this.type,
              data: this._data
            })
          }
          hasTransition() {
            return !1
          }
        }
        class Zt extends s.E {
          constructor(e, i, l, u) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = l, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(u), this.options = i
          }
          load(e) {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this.url = this.options.url, this._request = new AbortController;
              try {
                const i = yield De.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, i && i.data && (this.image = i.data, e && (this.coordinates = e), this._finishLoading())
              } catch (i) {
                this._request = null, this._loaded = !0, this.fire(new s.k(i))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null
            })), this) : this
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null)
          }
          setCoordinates(e) {
            this.coordinates = e;
            const i = e.map(s.a1.fromLngLat);
            var l;
            return this.tileID = (function(u) {
              const f = s.a2.fromPoints(u),
                g = f.width(),
                C = f.height(),
                T = Math.max(g, C),
                M = Math.max(0, Math.floor(-Math.log(T) / Math.LN2)),
                z = Math.pow(2, M);
              return new s.a4(M, Math.floor((f.minX + f.maxX) / 2 * z), Math.floor((f.minY + f.maxY) / 2 * z))
            })(i), this.terrainTileRanges = this._getOverlappingTileRanges(i), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i.map((u => this.tileID.getTilePoint(u)._round())), this.flippedWindingOrder = ((l = this.tileCoords)[1].x - l[0].x) * (l[2].y - l[0].y) - (l[1].y - l[0].y) * (l[2].x - l[0].x) < 0, this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "content"
            })), this
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context,
              i = e.gl;
            this.texture || (this.texture = new s.T(e, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let l = !1;
            for (const u in this.tiles) {
              const f = this.tiles[u];
              f.state !== "loaded" && (f.state = "loaded", f.texture = this.texture, l = !0)
            }
            l && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored"
            }))
          }
          serialize() {
            return {
              type: "image",
              url: this.options.url,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return !1
          }
          _getOverlappingTileRanges(e) {
            const {
              minX: i,
              minY: l,
              maxX: u,
              maxY: f
            } = s.a2.fromPoints(e), g = {};
            for (let C = 0; C <= s.a3; C++) {
              const T = Math.pow(2, C),
                M = Math.floor(i * T),
                z = Math.floor(l * T),
                R = Math.floor(u * T),
                D = Math.floor(f * T);
              g[C] = {
                minTileX: M,
                minTileY: z,
                maxTileX: R,
                maxTileY: D
              }
            }
            return g
          }
        }
        class Ft extends Zt {
          constructor(e, i, l, u) {
            super(e, i, l, u), this.roundZoom = !0, this.type = "video", this.options = i
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const i of e.urls) this.urls.push(this.map._requestManager.transformRequest(i, "Source").url);
              try {
                const i = yield s.a5(this.urls);
                if (this._loaded = !0, !i) return;
                this.video = i, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint()
                })), this.map && this.video.play(), this._finishLoading()
              } catch (i) {
                this.fire(new s.k(i))
              }
            }))
          }
          pause() {
            this.video && this.video.pause()
          }
          play() {
            this.video && this.video.play()
          }
          seek(e) {
            if (this.video) {
              const i = this.video.seekable;
              e < i.start(0) || e > i.end(0) ? this.fire(new s.k(new s.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e
            }
          }
          getVideo() {
            return this.video
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context,
              i = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new s.T(e, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let l = !1;
            for (const u in this.tiles) {
              const f = this.tiles[u];
              f.state !== "loaded" && (f.state = "loaded", f.texture = this.texture, l = !0)
            }
            l && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this.video && !this.video.paused
          }
        }
        class cr extends Zt {
          constructor(e, i, l, u) {
            super(e, i, l, u), i.coordinates ? Array.isArray(i.coordinates) && i.coordinates.length === 4 && !i.coordinates.some((f => !Array.isArray(f) || f.length !== 2 || f.some((g => typeof g != "number")))) || this.fire(new s.k(new s.a6(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.k(new s.a6(`sources.${e}`, null, 'missing required property "coordinates"'))), i.animate && typeof i.animate != "boolean" && this.fire(new s.k(new s.a6(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? typeof i.canvas == "string" || i.canvas instanceof HTMLCanvasElement || this.fire(new s.k(new s.a6(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.k(new s.a6(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = i.animate === void 0 || i.animate
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint()
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1)
              }, this._finishLoading())
            }))
          }
          getCanvas() {
            return this.canvas
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play()
          }
          onRemove() {
            this.pause()
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const i = this.map.painter.context,
              l = i.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
              premultiply: !0
            }) : this.texture = new s.T(i, this.canvas, l.RGBA, {
              premultiply: !0
            });
            let u = !1;
            for (const f in this.tiles) {
              const g = this.tiles[f];
              g.state !== "loaded" && (g.state = "loaded", g.texture = this.texture, u = !0)
            }
            u && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "canvas",
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this._playing
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height])
              if (isNaN(e) || e <= 0) return !0;
            return !1
          }
        }
        const ur = {},
          Er = p => {
            switch (p) {
              case "geojson":
                return Rt;
              case "image":
                return Zt;
              case "raster":
                return Ot;
              case "raster-dem":
                return Dt;
              case "vector":
                return Vt;
              case "video":
                return Ft;
              case "canvas":
                return cr
            }
            return ur[p]
          },
          dr = "RTLPluginLoaded";
        class pr extends s.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = He()
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", {
              pluginStatus: e,
              pluginURL: this.url
            }).catch((i => {
              throw this.status = "error", i
            }))
          }
          getRTLTextPluginStatus() {
            return this.status
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null
          }
          setRTLTextPlugin(e) {
            return s._(this, arguments, void 0, (function*(i, l = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = Q.resolveURL(i), !this.url) throw new Error(`requested url ${i} is invalid`);
              if (this.status === "unavailable") {
                if (!l) return this._requestImport();
                this.status = "deferred", this._syncState(this.status)
              } else if (this.status === "requested") return this._requestImport()
            }))
          }
          _requestImport() {
            return s._(this, void 0, void 0, (function*() {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new s.l(dr))
            }))
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
          }
        }
        let vr = null;

        function Vr() {
          return vr || (vr = new pr), vr
        }
        class qr {
          constructor(e, i) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = s.a7(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading"
          }
          registerFadeDuration(e) {
            const i = e + this.timeAdded;
            i < this.fadeEndTime || (this.fadeEndTime = i)
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null
          }
          loadVectorData(e, i, l) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(u, f) {
                const g = {};
                if (!f) return g;
                for (const C of u) {
                  const T = C.layerIds.map((M => f.getLayer(M))).filter(Boolean);
                  if (T.length !== 0) {
                    C.layers = T, C.stateDependentLayerIds && (C.stateDependentLayers = C.stateDependentLayerIds.map((M => T.filter((z => z.id === M))[0])));
                    for (const M of T) g[M.id] = C
                  }
                }
                return g
              })(e.buckets, i == null ? void 0 : i.style), this.hasSymbolBuckets = !1;
              for (const u in this.buckets) {
                const f = this.buckets[u];
                if (f instanceof s.a9) {
                  if (this.hasSymbolBuckets = !0, !l) break;
                  f.justReloaded = !0
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets)
                for (const u in this.buckets) {
                  const f = this.buckets[u];
                  if (f instanceof s.a9 && f.hasRTLText) {
                    this.hasRTLText = !0, Vr().lazyLoad();
                    break
                  }
                }
              this.queryPadding = 0;
              for (const u in this.buckets) {
                const f = this.buckets[u];
                this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(u).queryRadius(f))
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage)
            } else this.collisionBoxArray = new s.a8
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded"
          }
          getBucket(e) {
            return this.buckets[e.id]
          }
          upload(e) {
            for (const l in this.buckets) {
              const u = this.buckets[l];
              u.uploadPending() && u.upload(e)
            }
            const i = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new s.T(e, this.imageAtlas.image, i.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new s.T(e, this.glyphAtlasImage, i.ALPHA), this.glyphAtlasImage = null)
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
          }
          queryRenderedFeatures(e, i, l, u, f, g, C, T, M, z, R) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
              queryGeometry: u,
              cameraQueryGeometry: f,
              scale: g,
              tileSize: this.tileSize,
              pixelPosMatrix: z,
              transform: T,
              params: C,
              queryPadding: this.queryPadding * M,
              getElevation: R
            }, e, i, l) : {}
          }
          querySourceFeatures(e, i) {
            const l = this.latestFeatureIndex;
            if (!l || !l.rawTileData) return;
            const u = l.loadVTLayers(),
              f = i && i.sourceLayer ? i.sourceLayer : "",
              g = u._geojsonTileLayer || u[f];
            if (!g) return;
            const C = s.aa(i && i.filter),
              {
                z: T,
                x: M,
                y: z
              } = this.tileID.canonical,
              R = {
                z: T,
                x: M,
                y: z
              };
            for (let D = 0; D < g.length; D++) {
              const N = g.feature(D);
              if (C.needGeometry) {
                const ne = s.ab(N, !0);
                if (!C.filter(new s.F(this.tileID.overscaledZ), ne, this.tileID.canonical)) continue
              } else if (!C.filter(new s.F(this.tileID.overscaledZ), N)) continue;
              const H = l.getId(N, f),
                ie = new s.ac(N, T, M, z, H);
              ie.tile = R, e.push(ie)
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
          }
          setExpiryData(e) {
            const i = this.expirationTime;
            if (e.cacheControl) {
              const l = s.ad(e.cacheControl);
              l["max-age"] && (this.expirationTime = Date.now() + 1e3 * l["max-age"])
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const l = Date.now();
              let u = !1;
              if (this.expirationTime > l) u = !1;
              else if (i)
                if (this.expirationTime < i) u = !0;
                else {
                  const f = this.expirationTime - i;
                  f ? this.expirationTime = l + Math.max(f, 3e4) : u = !0
                }
              else u = !0;
              u ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
          }
          setFeatureState(e, i) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const l = this.latestFeatureIndex.loadVTLayers();
            for (const u in this.buckets) {
              if (!i.style.hasLayer(u)) continue;
              const f = this.buckets[u],
                g = f.layers[0].sourceLayer || "_geojsonTileLayer",
                C = l[g],
                T = e[g];
              if (!C || !T || Object.keys(T).length === 0) continue;
              f.update(T, C, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const M = i && i.style && i.style.getLayer(u);
              M && (this.queryPadding = Math.max(this.queryPadding, M.queryRadius(f)))
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Q.now()
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0
          }
          setHoldDuration(e) {
            this.symbolFadeHoldUntil = Q.now() + e
          }
          setDependencies(e, i) {
            const l = {};
            for (const u of i) l[u] = !0;
            this.dependencies[e] = l
          }
          hasDependency(e, i) {
            for (const l of e) {
              const u = this.dependencies[l];
              if (u) {
                for (const f of i)
                  if (u[f]) return !0
              }
            }
            return !1
          }
        }
        class ue {
          constructor(e, i) {
            this.max = e, this.onRemove = i, this.reset()
          }
          reset() {
            for (const e in this.data)
              for (const i of this.data[e]) i.timeout && clearTimeout(i.timeout), this.onRemove(i.value);
            return this.data = {}, this.order = [], this
          }
          add(e, i, l) {
            const u = e.wrapped().key;
            this.data[u] === void 0 && (this.data[u] = []);
            const f = {
              value: i,
              timeout: void 0
            };
            if (l !== void 0 && (f.timeout = setTimeout((() => {
                this.remove(e, f)
              }), l)), this.data[u].push(f), this.order.push(u), this.order.length > this.max) {
              const g = this._getAndRemoveByKey(this.order[0]);
              g && this.onRemove(g)
            }
            return this
          }
          has(e) {
            return e.wrapped().key in this.data
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
          }
          _getAndRemoveByKey(e) {
            const i = this.data[e].shift();
            return i.timeout && clearTimeout(i.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), i.value
          }
          getByKey(e) {
            const i = this.data[e];
            return i ? i[0].value : null
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null
          }
          remove(e, i) {
            if (!this.has(e)) return this;
            const l = e.wrapped().key,
              u = i === void 0 ? 0 : this.data[l].indexOf(i),
              f = this.data[l][u];
            return this.data[l].splice(u, 1), f.timeout && clearTimeout(f.timeout), this.data[l].length === 0 && delete this.data[l], this.onRemove(f.value), this.order.splice(this.order.indexOf(l), 1), this
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max;) {
              const i = this._getAndRemoveByKey(this.order[0]);
              i && this.onRemove(i)
            }
            return this
          }
          filter(e) {
            const i = [];
            for (const l in this.data)
              for (const u of this.data[l]) e(u.value) || i.push(u);
            for (const l of i) this.remove(l.value.tileID, l)
          }
        }
        class V {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {}
          }
          updateState(e, i, l) {
            const u = String(i);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][u] = this.stateChanges[e][u] || {}, s.e(this.stateChanges[e][u], l), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const f in this.state[e]) f !== u && (this.deletedStates[e][f] = null)
            } else if (this.deletedStates[e] && this.deletedStates[e][u] === null) {
              this.deletedStates[e][u] = {};
              for (const f in this.state[e][u]) l[f] || (this.deletedStates[e][u][f] = null)
            } else
              for (const f in l) this.deletedStates[e] && this.deletedStates[e][u] && this.deletedStates[e][u][f] === null && delete this.deletedStates[e][u][f]
          }
          removeFeatureState(e, i, l) {
            if (this.deletedStates[e] === null) return;
            const u = String(i);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, l && i !== void 0) this.deletedStates[e][u] !== null && (this.deletedStates[e][u] = this.deletedStates[e][u] || {}, this.deletedStates[e][u][l] = null);
            else if (i !== void 0)
              if (this.stateChanges[e] && this.stateChanges[e][u])
                for (l in this.deletedStates[e][u] = {}, this.stateChanges[e][u]) this.deletedStates[e][u][l] = null;
              else this.deletedStates[e][u] = null;
            else this.deletedStates[e] = null
          }
          getState(e, i) {
            const l = String(i),
              u = s.e({}, (this.state[e] || {})[l], (this.stateChanges[e] || {})[l]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const f = this.deletedStates[e][i];
              if (f === null) return {};
              for (const g in f) delete u[g]
            }
            return u
          }
          initializeTileState(e, i) {
            e.setFeatureState(this.state, i)
          }
          coalesceChanges(e, i) {
            const l = {};
            for (const u in this.stateChanges) {
              this.state[u] = this.state[u] || {};
              const f = {};
              for (const g in this.stateChanges[u]) this.state[u][g] || (this.state[u][g] = {}), s.e(this.state[u][g], this.stateChanges[u][g]), f[g] = this.state[u][g];
              l[u] = f
            }
            for (const u in this.deletedStates) {
              this.state[u] = this.state[u] || {};
              const f = {};
              if (this.deletedStates[u] === null)
                for (const g in this.state[u]) f[g] = {}, this.state[u][g] = {};
              else
                for (const g in this.deletedStates[u]) {
                  if (this.deletedStates[u][g] === null) this.state[u][g] = {};
                  else
                    for (const C of Object.keys(this.deletedStates[u][g])) delete this.state[u][g][C];
                  f[g] = this.state[u][g]
                }
              l[u] = l[u] || {}, s.e(l[u], f)
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(l).length !== 0)
              for (const u in e) e[u].setFeatureState(l, i)
          }
        }
        const U = 89.25;

        function Y(p, e) {
          const i = s.ah(e.lat, -s.ai, s.ai);
          return new s.P(s.V(e.lng) * p, s.U(i) * p)
        }

        function oe(p, e) {
          return new s.a1(e.x / p, e.y / p).toLngLat()
        }

        function me(p) {
          return p.cameraToCenterDistance * Math.min(.85 * Math.tan(s.ae(90 - p.pitch)), Math.tan(s.ae(U - p.pitch)))
        }

        function Se(p, e) {
          const i = p.canonical,
            l = e / s.af(i.z),
            u = i.x + Math.pow(2, i.z) * p.wrap,
            f = s.ag(new Float64Array(16));
          return s.M(f, f, [u * l, i.y * l, 0]), s.N(f, f, [l / s.$, l / s.$, 1]), f
        }

        function Oe(p, e, i, l, u) {
          const f = s.a1.fromLngLat(p, e),
            g = u * s.aj(1, p.lat),
            C = g * Math.cos(s.ae(i)),
            T = Math.sqrt(g * g - C * C),
            M = T * Math.sin(s.ae(-l)),
            z = T * Math.cos(s.ae(-l));
          return new s.a1(f.x + M, f.y + z, f.z + C)
        }

        function ze(p, e, i) {
          const l = e.intersectsFrustum(p);
          if (!i || l === 0) return l;
          const u = e.intersectsPlane(i);
          return u === 0 ? 0 : l === 2 && u === 2 ? 2 : 1
        }

        function Ke(p, e, i) {
          let l = 0;
          const u = (i - e) / 10;
          for (let f = 0; f < 10; f++) l += u * Math.pow(Math.cos(e + (f + .5) / 10 * (i - e)), p);
          return l
        }

        function _t(p, e) {
          return function(i, l, u, f, g) {
            const C = 2 * ((p - 1) / s.ak(Math.cos(s.ae(U - g)) / Math.cos(s.ae(U))) - 1),
              T = Math.acos(u / f),
              M = 2 * Ke(C - 1, 0, s.ae(g / 2)),
              z = Math.min(s.ae(U), T + s.ae(g / 2)),
              R = Ke(C - 1, Math.min(z, T - s.ae(g / 2)), z),
              D = Math.atan(l / u),
              N = Math.hypot(l, u);
            let H = i;
            return H += s.ak(f / N / Math.max(.5, Math.cos(s.ae(g / 2)))), H += C * s.ak(Math.cos(D)) / 2, H -= s.ak(Math.max(1, R / M / e)) / 2, H
          }
        }
        const it = _t(9.314, 3);

        function qt(p, e) {
          const i = (e.roundZoom ? Math.round : Math.floor)(p.zoom + s.ak(p.tileSize / e.tileSize));
          return Math.max(0, i)
        }

        function we(p, e) {
          const i = p.getCameraFrustum(),
            l = p.getClippingPlane(),
            u = p.screenPointToMercatorCoordinate(p.getCameraPoint()),
            f = s.a1.fromLngLat(p.center, p.elevation);
          u.z = f.z + Math.cos(p.pitchInRadians) * p.cameraToCenterDistance / p.worldSize;
          const g = p.getCoveringTilesDetailsProvider(),
            C = g.allowVariableZoom(p, e),
            T = qt(p, e),
            M = e.minzoom || 0,
            z = e.maxzoom !== void 0 ? e.maxzoom : p.maxZoom,
            R = Math.min(Math.max(0, T), z),
            D = Math.pow(2, R),
            N = [D * u.x, D * u.y, 0],
            H = [D * f.x, D * f.y, 0],
            ie = Math.hypot(f.x - u.x, f.y - u.y),
            ne = Math.abs(f.z - u.z),
            se = Math.hypot(ie, ne),
            pe = Te => ({
              zoom: 0,
              x: 0,
              y: 0,
              wrap: Te,
              fullyVisible: !1
            }),
            ye = [],
            ge = [];
          if (p.renderWorldCopies && g.allowWorldCopies())
            for (let Te = 1; Te <= 3; Te++) ye.push(pe(-Te)), ye.push(pe(Te));
          for (ye.push(pe(0)); ye.length > 0;) {
            const Te = ye.pop(),
              Le = Te.x,
              ve = Te.y;
            let Ne = Te.fullyVisible;
            const st = {
                x: Le,
                y: ve,
                z: Te.zoom
              },
              Xe = g.getTileBoundingVolume(st, Te.wrap, p.elevation, e);
            if (!Ne) {
              const Xt = ze(i, Xe, l);
              if (Xt === 0) continue;
              Ne = Xt === 2
            }
            const Qe = g.distanceToTile2d(u.x, u.y, st, Xe);
            let at = T;
            C && (at = (e.calculateTileZoom || it)(p.zoom + s.ak(p.tileSize / e.tileSize), Qe, ne, se, p.fov)), at = (e.roundZoom ? Math.round : Math.floor)(at), at = Math.max(0, at);
            const Ht = Math.min(at, z);
            if (Te.wrap = g.getWrap(f, st, Te.wrap), Te.zoom >= Ht) {
              if (Te.zoom < M) continue;
              const Xt = R - Te.zoom,
                kt = N[0] - .5 - (Le << Xt),
                wr = N[1] - .5 - (ve << Xt),
                dn = e.reparseOverscaled ? Math.max(Te.zoom, at) : Te.zoom;
              ge.push({
                tileID: new s.Z(Te.zoom === z ? dn : Te.zoom, Te.wrap, Te.zoom, Le, ve),
                distanceSq: s.al([H[0] - .5 - Le, H[1] - .5 - ve]),
                tileDistanceToCamera: Math.sqrt(kt * kt + wr * wr)
              })
            } else
              for (let Xt = 0; Xt < 4; Xt++) ye.push({
                zoom: Te.zoom + 1,
                x: (Le << 1) + Xt % 2,
                y: (ve << 1) + (Xt >> 1),
                wrap: Te.wrap,
                fullyVisible: Ne
              })
          }
          return ge.sort(((Te, Le) => Te.distanceSq - Le.distanceSq)).map((Te => Te.tileID))
        }
        const Mt = s.a2.fromPoints([new s.P(0, 0), new s.P(s.$, s.$)]);
        class Ut extends s.E {
          constructor(e, i, l) {
            super(), this.id = e, this.dispatcher = l, this.on("data", (u => this._dataHandler(u))), this.on("dataloading", (() => {
              this._sourceErrored = !1
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded()
            })), this._source = ((u, f, g, C) => {
              const T = new(Er(f.type))(u, f, g, C);
              if (T.id !== u) throw new Error(`Expected Source id to be ${u} instead of ${T.id}`);
              return T
            })(e, i, l, this), this._tiles = {}, this._cache = new ue(0, (u => this._unloadTile(u))), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new V, this._didEmitContent = !1, this._updated = !1
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e)
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e)
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const i = this._tiles[e];
              if (i.state !== "loaded" && i.state !== "errored") return !1
            }
            return !0
          }
          getSource() {
            return this._source
          }
          pause() {
            this._paused = !0
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain)
          }
          _loadTile(e, i, l) {
            return s._(this, void 0, void 0, (function*() {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, i, l)
              } catch (u) {
                e.state = "errored", u.status !== 404 ? this._source.fire(new s.k(u, {
                  tile: e
                })) : this.update(this.transform, this.terrain)
              }
            }))
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e)
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new s.l("dataabort", {
              tile: e,
              coord: e.tileID,
              dataType: "source"
            }))
          }
          serialize() {
            return this._source.serialize()
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const i in this._tiles) {
              const l = this._tiles[i];
              l.upload(e), l.prepare(this.map.style.imageManager)
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e => e.tileID)).sort(jt).map((e => e.key))
          }
          getRenderableIds(e) {
            const i = [];
            for (const l in this._tiles) this._isIdRenderable(l, e) && i.push(this._tiles[l]);
            return e ? i.sort(((l, u) => {
              const f = l.tileID,
                g = u.tileID,
                C = new s.P(f.canonical.x, f.canonical.y)._rotate(-this.transform.bearingInRadians),
                T = new s.P(g.canonical.x, g.canonical.y)._rotate(-this.transform.bearingInRadians);
              return f.overscaledZ - g.overscaledZ || T.y - C.y || T.x - C.x
            })).map((l => l.tileID.key)) : i.map((l => l.tileID)).sort(jt).map((l => l.key))
          }
          hasRenderableParent(e) {
            const i = this.findLoadedParent(e, 0);
            return !!i && this._isIdRenderable(i.tileID.key)
          }
          _isIdRenderable(e, i) {
            return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (i || !this._tiles[e].holdingForFade())
          }
          reload(e) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const i in this._tiles) e ? this._reloadTile(i, "expired") : this._tiles[i].state !== "errored" && this._reloadTile(i, "reloading")
            }
          }
          _reloadTile(e, i) {
            return s._(this, void 0, void 0, (function*() {
              const l = this._tiles[e];
              l && (l.state !== "loading" && (l.state = i), yield this._loadTile(l, e, i))
            }))
          }
          _tileLoaded(e, i, l) {
            e.timeAdded = Q.now(), l === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new s.l("data", {
              dataType: "source",
              tile: e,
              coord: e.tileID
            }))
          }
          _backfillDEM(e) {
            const i = this.getRenderableIds();
            for (let u = 0; u < i.length; u++) {
              const f = i[u];
              if (e.neighboringTiles && e.neighboringTiles[f]) {
                const g = this.getTileByID(f);
                l(e, g), l(g, e)
              }
            }

            function l(u, f) {
              u.needsHillshadePrepare = !0, u.needsTerrainPrepare = !0;
              let g = f.tileID.canonical.x - u.tileID.canonical.x;
              const C = f.tileID.canonical.y - u.tileID.canonical.y,
                T = Math.pow(2, u.tileID.canonical.z),
                M = f.tileID.key;
              g === 0 && C === 0 || Math.abs(C) > 1 || (Math.abs(g) > 1 && (Math.abs(g + T) === 1 ? g += T : Math.abs(g - T) === 1 && (g -= T)), f.dem && u.dem && (u.dem.backfillBorder(f.dem, g, C), u.neighboringTiles && u.neighboringTiles[M] && (u.neighboringTiles[M].backfilled = !0)))
            }
          }
          getTile(e) {
            return this.getTileByID(e.key)
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          _retainLoadedChildren(e, i, l, u) {
            for (const f in this._tiles) {
              let g = this._tiles[f];
              if (u[f] || !g.hasData() || g.tileID.overscaledZ <= i || g.tileID.overscaledZ > l) continue;
              let C = g.tileID;
              for (; g && g.tileID.overscaledZ > i + 1;) {
                const M = g.tileID.scaledTo(g.tileID.overscaledZ - 1);
                g = this._tiles[M.key], g && g.hasData() && (C = M)
              }
              let T = C;
              for (; T.overscaledZ > i;)
                if (T = T.scaledTo(T.overscaledZ - 1), e[T.key] || e[T.canonical.key]) {
                  u[C.key] = C;
                  break
                }
            }
          }
          findLoadedParent(e, i) {
            if (e.key in this._loadedParentTiles) {
              const l = this._loadedParentTiles[e.key];
              return l && l.tileID.overscaledZ >= i ? l : null
            }
            for (let l = e.overscaledZ - 1; l >= i; l--) {
              const u = e.scaledTo(l),
                f = this._getLoadedTile(u);
              if (f) return f
            }
          }
          findLoadedSibling(e) {
            return this._getLoadedTile(e)
          }
          _getLoadedTile(e) {
            const i = this._tiles[e.key];
            return i && i.hasData() ? i : this._cache.getByKey(e.wrapped().key)
          }
          updateCacheSize(e) {
            const i = Math.ceil(e.width / this._source.tileSize) + 1,
              l = Math.ceil(e.height / this._source.tileSize) + 1,
              u = Math.floor(i * l * (this._maxTileCacheZoomLevels === null ? s.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)),
              f = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, u) : u;
            this._cache.setMaxSize(f)
          }
          handleWrapJump(e) {
            const i = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, i) {
              const l = {};
              for (const u in this._tiles) {
                const f = this._tiles[u];
                f.tileID = f.tileID.unwrapTo(f.tileID.wrap + i), l[f.tileID.key] = f
              }
              this._tiles = l;
              for (const u in this._timers) clearTimeout(this._timers[u]), delete this._timers[u];
              for (const u in this._tiles) this._setTileReloadTimer(u, this._tiles[u])
            }
          }
          _updateCoveredAndRetainedTiles(e, i, l, u, f, g) {
            const C = {},
              T = {},
              M = Object.keys(e),
              z = Q.now();
            for (const R of M) {
              const D = e[R],
                N = this._tiles[R];
              if (!N || N.fadeEndTime !== 0 && N.fadeEndTime <= z) continue;
              const H = this.findLoadedParent(D, i),
                ie = this.findLoadedSibling(D),
                ne = H || ie || null;
              ne && (this._addTile(ne.tileID), C[ne.tileID.key] = ne.tileID), T[R] = D
            }
            this._retainLoadedChildren(T, u, l, e);
            for (const R in C) e[R] || (this._coveredTiles[R] = !0, e[R] = C[R]);
            if (g) {
              const R = {},
                D = {};
              for (const N of f) this._tiles[N.key].hasData() ? R[N.key] = N : D[N.key] = N;
              for (const N in D) {
                const H = D[N].children(this._source.maxzoom);
                this._tiles[H[0].key] && this._tiles[H[1].key] && this._tiles[H[2].key] && this._tiles[H[3].key] && (R[H[0].key] = e[H[0].key] = H[0], R[H[1].key] = e[H[1].key] = H[1], R[H[2].key] = e[H[2].key] = H[2], R[H[3].key] = e[H[3].key] = H[3], delete D[N])
              }
              for (const N in D) {
                const H = D[N],
                  ie = this.findLoadedParent(H, this._source.minzoom),
                  ne = this.findLoadedSibling(H),
                  se = ie || ne || null;
                if (se) {
                  R[se.tileID.key] = e[se.tileID.key] = se.tileID;
                  for (const pe in R) R[pe].isChildOf(se.tileID) && delete R[pe]
                }
              }
              for (const N in this._tiles) R[N] || (this._coveredTiles[N] = !0)
            }
          }
          update(e, i) {
            if (!this._sourceLoaded || this._paused) return;
            let l;
            this.transform = e, this.terrain = i, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? l = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((z => new s.Z(z.canonical.z, z.wrap, z.canonical.z, z.canonical.x, z.canonical.y))) : (l = we(e, {
              tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
              minzoom: this._source.minzoom,
              maxzoom: this._source.maxzoom,
              roundZoom: !this.usedForTerrain && this._source.roundZoom,
              reparseOverscaled: this._source.reparseOverscaled,
              terrain: i,
              calculateTileZoom: this._source.calculateTileZoom
            }), this._source.hasTile && (l = l.filter((z => this._source.hasTile(z))))) : l = [];
            const u = qt(e, this._source),
              f = Math.max(u - Ut.maxOverzooming, this._source.minzoom),
              g = Math.max(u + Ut.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const z = {};
              for (const R of l)
                if (R.canonical.z > this._source.minzoom) {
                  const D = R.scaledTo(R.canonical.z - 1);
                  z[D.key] = D;
                  const N = R.scaledTo(Math.max(this._source.minzoom, Math.min(R.canonical.z, 5)));
                  z[N.key] = N
                } l = l.concat(Object.values(z))
            }
            const C = l.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, C && this.fire(new s.l("data", {
              sourceDataType: "idle",
              dataType: "source",
              sourceId: this.id
            }));
            const T = this._updateRetainedTiles(l, u);
            fr(this._source.type) && this._updateCoveredAndRetainedTiles(T, f, g, u, l, i);
            for (const z in T) this._tiles[z].clearFadeHold();
            const M = s.am(this._tiles, T);
            for (const z of M) {
              const R = this._tiles[z];
              R.hasSymbolBuckets && !R.holdingForFade() ? R.setHoldDuration(this.map._fadeDuration) : R.hasSymbolBuckets && !R.symbolFadeFinished() || this._removeTile(z)
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache()
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e)
          }
          _updateRetainedTiles(e, i) {
            var l;
            const u = {},
              f = {},
              g = Math.max(i - Ut.maxOverzooming, this._source.minzoom),
              C = Math.max(i + Ut.maxUnderzooming, this._source.minzoom),
              T = {};
            for (const M of e) {
              const z = this._addTile(M);
              u[M.key] = M, z.hasData() || i < this._source.maxzoom && (T[M.key] = M)
            }
            this._retainLoadedChildren(T, i, C, u);
            for (const M of e) {
              let z = this._tiles[M.key];
              if (z.hasData()) continue;
              if (i + 1 > this._source.maxzoom) {
                const D = M.children(this._source.maxzoom)[0],
                  N = this.getTile(D);
                if (N && N.hasData()) {
                  u[D.key] = D;
                  continue
                }
              } else {
                const D = M.children(this._source.maxzoom);
                if (u[D[0].key] && u[D[1].key] && u[D[2].key] && u[D[3].key]) continue
              }
              let R = z.wasRequested();
              for (let D = M.overscaledZ - 1; D >= g; --D) {
                const N = M.scaledTo(D);
                if (f[N.key]) break;
                if (f[N.key] = !0, z = this.getTile(N), !z && R && (z = this._addTile(N)), z) {
                  const H = z.hasData();
                  if ((H || !(!((l = this.map) === null || l === void 0) && l.cancelPendingTileRequestsWhileZooming) || R) && (u[N.key] = N), R = z.wasRequested(), H) break
                }
              }
            }
            return u
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e in this._tiles) {
              const i = [];
              let l, u = this._tiles[e].tileID;
              for (; u.overscaledZ > 0;) {
                if (u.key in this._loadedParentTiles) {
                  l = this._loadedParentTiles[u.key];
                  break
                }
                i.push(u.key);
                const f = u.scaledTo(u.overscaledZ - 1);
                if (l = this._getLoadedTile(f), l) break;
                u = f
              }
              for (const f of i) this._loadedParentTiles[f] = l
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const e in this._tiles) {
              const i = this._tiles[e].tileID,
                l = this._getLoadedTile(i);
              this._loadedSiblingTiles[i.key] = l
            }
          }
          _addTile(e) {
            let i = this._tiles[e.key];
            if (i) return i;
            i = this._cache.getAndRemove(e), i && (this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, i)));
            const l = i;
            return i || (i = new qr(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(i, e.key, i.state)), i.uses++, this._tiles[e.key] = i, l || this._source.fire(new s.l("dataloading", {
              tile: i,
              coord: i.tileID,
              dataType: "source"
            })), i
          }
          _setTileReloadTimer(e, i) {
            e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
            const l = i.getExpiryTimeout();
            l && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e]
            }), l))
          }
          refreshTiles(e) {
            for (const i in this._tiles)(this._isIdRenderable(i) || this._tiles[i].state == "errored") && e.some((l => l.equals(this._tiles[i].tileID.canonical))) && this._reloadTile(i, "expired")
          }
          _removeTile(e) {
            const i = this._tiles[e];
            i && (i.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), i.uses > 0 || (i.hasData() && i.state !== "reloading" ? this._cache.add(i.tileID, i, i.getExpiryTimeout()) : (i.aborted = !0, this._abortTile(i), this._unloadTile(i))))
          }
          _dataHandler(e) {
            const i = e.sourceDataType;
            e.dataType === "source" && i === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && e.dataType === "source" && i === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0)
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset()
          }
          tilesIn(e, i, l) {
            const u = [],
              f = this.transform;
            if (!f) return u;
            const g = f.getCoveringTilesDetailsProvider().allowWorldCopies(),
              C = l ? f.getCameraQueryGeometry(e) : e,
              T = N => f.screenPointToMercatorCoordinate(N, this.terrain),
              M = this.transformBbox(e, T, !g),
              z = this.transformBbox(C, T, !g),
              R = this.getIds(),
              D = s.a2.fromPoints(z);
            for (let N = 0; N < R.length; N++) {
              const H = this._tiles[R[N]];
              if (H.holdingForFade()) continue;
              const ie = g ? [H.tileID] : [H.tileID.unwrapTo(-1), H.tileID.unwrapTo(0)],
                ne = Math.pow(2, f.zoom - H.tileID.overscaledZ),
                se = i * H.queryPadding * s.$ / H.tileSize / ne;
              for (const pe of ie) {
                const ye = D.map((ge => pe.getTilePoint(new s.a1(ge.x, ge.y))));
                if (ye.expandBy(se), ye.intersects(Mt)) {
                  const ge = M.map((Le => pe.getTilePoint(Le))),
                    Te = z.map((Le => pe.getTilePoint(Le)));
                  u.push({
                    tile: H,
                    tileID: g ? pe : pe.unwrapTo(0),
                    queryGeometry: ge,
                    cameraQueryGeometry: Te,
                    scale: ne
                  })
                }
              }
            }
            return u
          }
          transformBbox(e, i, l) {
            let u = e.map(i);
            if (l) {
              const f = s.a2.fromPoints(e);
              f.shrinkBy(.001 * Math.min(f.width(), f.height()));
              const g = f.map(i);
              s.a2.fromPoints(u).covers(g) || (u = u.map((C => C.x > .5 ? new s.a1(C.x - 1, C.y, C.z) : C)))
            }
            return u
          }
          getVisibleCoordinates(e) {
            const i = this.getRenderableIds(e).map((l => this._tiles[l].tileID));
            return this.transform && this.transform.populateCache(i), i
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (fr(this._source.type)) {
              const e = Q.now();
              for (const i in this._tiles)
                if (this._tiles[i].fadeEndTime >= e) return !0
            }
            return !1
          }
          setFeatureState(e, i, l) {
            this._state.updateState(e = e || "_geojsonTileLayer", i, l)
          }
          removeFeatureState(e, i, l) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", i, l)
          }
          getFeatureState(e, i) {
            return this._state.getState(e = e || "_geojsonTileLayer", i)
          }
          setDependencies(e, i, l) {
            const u = this._tiles[e];
            u && u.setDependencies(i, l)
          }
          reloadTilesForDependencies(e, i) {
            for (const l in this._tiles) this._tiles[l].hasDependency(e, i) && this._reloadTile(l, "reloading");
            this._cache.filter((l => !l.hasDependency(e, i)))
          }
        }

        function jt(p, e) {
          const i = Math.abs(2 * p.wrap) - +(p.wrap < 0),
            l = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return p.overscaledZ - e.overscaledZ || l - i || e.canonical.y - p.canonical.y || e.canonical.x - p.canonical.x
        }

        function fr(p) {
          return p === "raster" || p === "image" || p === "video"
        }
        Ut.maxOverzooming = 10, Ut.maxUnderzooming = 3;
        class Ur {
          constructor(e, i) {
            this.reset(e, i)
          }
          reset(e, i) {
            this.points = e || [], this._distances = [0];
            for (let l = 1; l < this.points.length; l++) this._distances[l] = this._distances[l - 1] + this.points[l].dist(this.points[l - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(i || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = s.ah(e, 0, 1);
            let i = 1,
              l = this._distances[i];
            const u = e * this.paddedLength + this.padding;
            for (; l < u && i < this._distances.length;) l = this._distances[++i];
            const f = i - 1,
              g = this._distances[f],
              C = l - g,
              T = C > 0 ? (u - g) / C : 0;
            return this.points[f].mult(1 - T).add(this.points[i].mult(T))
          }
        }

        function Dr(p, e) {
          let i = !0;
          return p === "always" || p !== "never" && e !== "never" || (i = !1), i
        }
        class jr {
          constructor(e, i, l) {
            const u = this.boxCells = [],
              f = this.circleCells = [];
            this.xCellCount = Math.ceil(e / l), this.yCellCount = Math.ceil(i / l);
            for (let g = 0; g < this.xCellCount * this.yCellCount; g++) u.push([]), f.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = i, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / i, this.boxUid = 0, this.circleUid = 0
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length
          }
          insert(e, i, l, u, f) {
            this._forEachCell(i, l, u, f, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(i), this.bboxes.push(l), this.bboxes.push(u), this.bboxes.push(f)
          }
          insertCircle(e, i, l, u) {
            this._forEachCell(i - u, l - u, i + u, l + u, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(i), this.circles.push(l), this.circles.push(u)
          }
          _insertBoxCell(e, i, l, u, f, g) {
            this.boxCells[f].push(g)
          }
          _insertCircleCell(e, i, l, u, f, g) {
            this.circleCells[f].push(g)
          }
          _query(e, i, l, u, f, g, C) {
            if (l < 0 || e > this.width || u < 0 || i > this.height) return [];
            const T = [];
            if (e <= 0 && i <= 0 && this.width <= l && this.height <= u) {
              if (f) return [{
                key: null,
                x1: e,
                y1: i,
                x2: l,
                y2: u
              }];
              for (let M = 0; M < this.boxKeys.length; M++) T.push({
                key: this.boxKeys[M],
                x1: this.bboxes[4 * M],
                y1: this.bboxes[4 * M + 1],
                x2: this.bboxes[4 * M + 2],
                y2: this.bboxes[4 * M + 3]
              });
              for (let M = 0; M < this.circleKeys.length; M++) {
                const z = this.circles[3 * M],
                  R = this.circles[3 * M + 1],
                  D = this.circles[3 * M + 2];
                T.push({
                  key: this.circleKeys[M],
                  x1: z - D,
                  y1: R - D,
                  x2: z + D,
                  y2: R + D
                })
              }
            } else this._forEachCell(e, i, l, u, this._queryCell, T, {
              hitTest: f,
              overlapMode: g,
              seenUids: {
                box: {},
                circle: {}
              }
            }, C);
            return T
          }
          query(e, i, l, u) {
            return this._query(e, i, l, u, !1, null)
          }
          hitTest(e, i, l, u, f, g) {
            return this._query(e, i, l, u, !0, f, g).length > 0
          }
          hitTestCircle(e, i, l, u, f) {
            const g = e - l,
              C = e + l,
              T = i - l,
              M = i + l;
            if (C < 0 || g > this.width || M < 0 || T > this.height) return !1;
            const z = [];
            return this._forEachCell(g, T, C, M, this._queryCellCircle, z, {
              hitTest: !0,
              overlapMode: u,
              circle: {
                x: e,
                y: i,
                radius: l
              },
              seenUids: {
                box: {},
                circle: {}
              }
            }, f), z.length > 0
          }
          _queryCell(e, i, l, u, f, g, C, T) {
            const {
              seenUids: M,
              hitTest: z,
              overlapMode: R
            } = C, D = this.boxCells[f];
            if (D !== null) {
              const H = this.bboxes;
              for (const ie of D)
                if (!M.box[ie]) {
                  M.box[ie] = !0;
                  const ne = 4 * ie,
                    se = this.boxKeys[ie];
                  if (e <= H[ne + 2] && i <= H[ne + 3] && l >= H[ne + 0] && u >= H[ne + 1] && (!T || T(se)) && (!z || !Dr(R, se.overlapMode)) && (g.push({
                      key: se,
                      x1: H[ne],
                      y1: H[ne + 1],
                      x2: H[ne + 2],
                      y2: H[ne + 3]
                    }), z)) return !0
                }
            }
            const N = this.circleCells[f];
            if (N !== null) {
              const H = this.circles;
              for (const ie of N)
                if (!M.circle[ie]) {
                  M.circle[ie] = !0;
                  const ne = 3 * ie,
                    se = this.circleKeys[ie];
                  if (this._circleAndRectCollide(H[ne], H[ne + 1], H[ne + 2], e, i, l, u) && (!T || T(se)) && (!z || !Dr(R, se.overlapMode))) {
                    const pe = H[ne],
                      ye = H[ne + 1],
                      ge = H[ne + 2];
                    if (g.push({
                        key: se,
                        x1: pe - ge,
                        y1: ye - ge,
                        x2: pe + ge,
                        y2: ye + ge
                      }), z) return !0
                  }
                }
            }
            return !1
          }
          _queryCellCircle(e, i, l, u, f, g, C, T) {
            const {
              circle: M,
              seenUids: z,
              overlapMode: R
            } = C, D = this.boxCells[f];
            if (D !== null) {
              const H = this.bboxes;
              for (const ie of D)
                if (!z.box[ie]) {
                  z.box[ie] = !0;
                  const ne = 4 * ie,
                    se = this.boxKeys[ie];
                  if (this._circleAndRectCollide(M.x, M.y, M.radius, H[ne + 0], H[ne + 1], H[ne + 2], H[ne + 3]) && (!T || T(se)) && !Dr(R, se.overlapMode)) return g.push(!0), !0
                }
            }
            const N = this.circleCells[f];
            if (N !== null) {
              const H = this.circles;
              for (const ie of N)
                if (!z.circle[ie]) {
                  z.circle[ie] = !0;
                  const ne = 3 * ie,
                    se = this.circleKeys[ie];
                  if (this._circlesCollide(H[ne], H[ne + 1], H[ne + 2], M.x, M.y, M.radius) && (!T || T(se)) && !Dr(R, se.overlapMode)) return g.push(!0), !0
                }
            }
          }
          _forEachCell(e, i, l, u, f, g, C, T) {
            const M = this._convertToXCellCoord(e),
              z = this._convertToYCellCoord(i),
              R = this._convertToXCellCoord(l),
              D = this._convertToYCellCoord(u);
            for (let N = M; N <= R; N++)
              for (let H = z; H <= D; H++)
                if (f.call(this, e, i, l, u, this.xCellCount * H + N, g, C, T)) return
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
          }
          _circlesCollide(e, i, l, u, f, g) {
            const C = u - e,
              T = f - i,
              M = l + g;
            return M * M > C * C + T * T
          }
          _circleAndRectCollide(e, i, l, u, f, g, C) {
            const T = (g - u) / 2,
              M = Math.abs(e - (u + T));
            if (M > T + l) return !1;
            const z = (C - f) / 2,
              R = Math.abs(i - (f + z));
            if (R > z + l) return !1;
            if (M <= T || R <= z) return !0;
            const D = M - T,
              N = R - z;
            return D * D + N * N <= l * l
          }
        }

        function $r(p, e, i) {
          const l = s.L();
          if (!p) {
            const {
              vecSouth: R,
              vecEast: D
            } = Fr(e), N = O();
            N[0] = D[0], N[1] = D[1], N[2] = R[0], N[3] = R[1], u = N, (z = (g = (f = N)[0]) * (M = f[3]) - (T = f[2]) * (C = f[1])) && (u[0] = M * (z = 1 / z), u[1] = -C * z, u[2] = -T * z, u[3] = g * z), l[0] = N[0], l[1] = N[1], l[4] = N[2], l[5] = N[3]
          }
          var u, f, g, C, T, M, z;
          return s.N(l, l, [1 / i, 1 / i, 1]), l
        }

        function Br(p, e, i, l) {
          if (p) {
            const u = s.L();
            if (!e) {
              const {
                vecSouth: f,
                vecEast: g
              } = Fr(i);
              u[0] = g[0], u[1] = g[1], u[4] = f[0], u[5] = f[1]
            }
            return s.N(u, u, [l, l, 1]), u
          }
          return i.pixelsToClipSpaceMatrix
        }

        function Fr(p) {
          const e = Math.cos(p.rollInRadians),
            i = Math.sin(p.rollInRadians),
            l = Math.cos(p.pitchInRadians),
            u = Math.cos(p.bearingInRadians),
            f = Math.sin(p.bearingInRadians),
            g = s.ar();
          g[0] = -u * l * i - f * e, g[1] = -f * l * i + u * e;
          const C = s.as(g);
          C < 1e-9 ? s.at(g) : s.au(g, g, 1 / C);
          const T = s.ar();
          T[0] = u * l * e - f * i, T[1] = f * l * e + u * i;
          const M = s.as(T);
          return M < 1e-9 ? s.at(T) : s.au(T, T, 1 / M), {
            vecEast: T,
            vecSouth: g
          }
        }

        function vn(p, e, i, l) {
          let u;
          l ? (u = [p, e, l(p, e), 1], s.aw(u, u, i)) : (u = [p, e, 0, 1], hn(u, u, i));
          const f = u[3];
          return {
            point: new s.P(u[0] / f, u[1] / f),
            signedDistanceFromCamera: f,
            isOccluded: !1
          }
        }

        function bt(p, e) {
          return .5 + p / e * .5
        }

        function bn(p, e) {
          return p.x >= -e[0] && p.x <= e[0] && p.y >= -e[1] && p.y <= e[1]
        }

        function fn(p, e, i, l, u, f, g, C, T, M, z, R, D) {
          const N = i ? p.textSizeData : p.iconSizeData,
            H = s.an(N, e.transform.zoom),
            ie = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1],
            ne = i ? p.text.dynamicLayoutVertexArray : p.icon.dynamicLayoutVertexArray;
          ne.clear();
          const se = p.lineVertexArray,
            pe = i ? p.text.placedSymbolArray : p.icon.placedSymbolArray,
            ye = e.transform.width / e.transform.height;
          let ge = !1;
          for (let Te = 0; Te < pe.length; Te++) {
            const Le = pe.get(Te);
            if (Le.hidden || Le.writingMode === s.ao.vertical && !ge) {
              Hr(Le.numGlyphs, ne);
              continue
            }
            ge = !1;
            const ve = new s.P(Le.anchorX, Le.anchorY),
              Ne = {
                getElevation: D,
                pitchedLabelPlaneMatrix: l,
                lineVertexArray: se,
                pitchWithMap: f,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: e.transform,
                tileAnchorPoint: ve,
                unwrappedTileID: T,
                width: M,
                height: z,
                translation: R
              },
              st = Wt(Le.anchorX, Le.anchorY, Ne);
            if (!bn(st.point, ie)) {
              Hr(Le.numGlyphs, ne);
              continue
            }
            const Xe = bt(e.transform.cameraToCenterDistance, st.signedDistanceFromCamera),
              Qe = s.ap(N, H, Le),
              at = f ? Qe * e.transform.getPitchedTextCorrection(Le.anchorX, Le.anchorY, T) / Xe : Qe * Xe,
              Ht = nt({
                projectionContext: Ne,
                pitchedLabelPlaneMatrixInverse: u,
                symbol: Le,
                fontSize: at,
                flip: !1,
                keepUpright: g,
                glyphOffsetArray: p.glyphOffsetArray,
                dynamicLayoutVertexArray: ne,
                aspectRatio: ye,
                rotateToLine: C
              });
            ge = Ht.useVertical, (Ht.notEnoughRoom || ge || Ht.needsFlipping && nt({
              projectionContext: Ne,
              pitchedLabelPlaneMatrixInverse: u,
              symbol: Le,
              fontSize: at,
              flip: !0,
              keepUpright: g,
              glyphOffsetArray: p.glyphOffsetArray,
              dynamicLayoutVertexArray: ne,
              aspectRatio: ye,
              rotateToLine: C
            }).notEnoughRoom) && Hr(Le.numGlyphs, ne)
          }
          i ? p.text.dynamicLayoutVertexBuffer.updateData(ne) : p.icon.dynamicLayoutVertexBuffer.updateData(ne)
        }

        function $n(p, e, i, l, u, f, g, C) {
          const T = f.glyphStartIndex + f.numGlyphs,
            M = f.lineStartIndex,
            z = f.lineStartIndex + f.lineLength,
            R = e.getoffsetX(f.glyphStartIndex),
            D = e.getoffsetX(T - 1),
            N = Qr(p * R, i, l, u, f.segment, M, z, C, g);
          if (!N) return null;
          const H = Qr(p * D, i, l, u, f.segment, M, z, C, g);
          return H ? C.projectionCache.anyProjectionOccluded ? null : {
            first: N,
            last: H
          } : null
        }

        function zt(p, e, i, l) {
          return p === s.ao.horizontal && Math.abs(i.y - e.y) > Math.abs(i.x - e.x) * l ? {
            useVertical: !0
          } : (p === s.ao.vertical ? e.y < i.y : e.x > i.x) ? {
            needsFlipping: !0
          } : null
        }

        function nt(p) {
          const {
            projectionContext: e,
            pitchedLabelPlaneMatrixInverse: i,
            symbol: l,
            fontSize: u,
            flip: f,
            keepUpright: g,
            glyphOffsetArray: C,
            dynamicLayoutVertexArray: T,
            aspectRatio: M,
            rotateToLine: z
          } = p, R = u / 24, D = l.lineOffsetX * R, N = l.lineOffsetY * R;
          let H;
          if (l.numGlyphs > 1) {
            const ie = l.glyphStartIndex + l.numGlyphs,
              ne = l.lineStartIndex,
              se = l.lineStartIndex + l.lineLength,
              pe = $n(R, C, D, N, f, l, z, e);
            if (!pe) return {
              notEnoughRoom: !0
            };
            const ye = It(pe.first.point.x, pe.first.point.y, e, i),
              ge = It(pe.last.point.x, pe.last.point.y, e, i);
            if (g && !f) {
              const Te = zt(l.writingMode, ye, ge, M);
              if (Te) return Te
            }
            H = [pe.first];
            for (let Te = l.glyphStartIndex + 1; Te < ie - 1; Te++) {
              const Le = Qr(R * C.getoffsetX(Te), D, N, f, l.segment, ne, se, e, z);
              if (!Le) return {
                notEnoughRoom: !0
              };
              H.push(Le)
            }
            H.push(pe.last)
          } else {
            if (g && !f) {
              const ne = xt(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point,
                se = l.lineStartIndex + l.segment + 1,
                pe = new s.P(e.lineVertexArray.getx(se), e.lineVertexArray.gety(se)),
                ye = xt(pe.x, pe.y, e),
                ge = ye.signedDistanceFromCamera > 0 ? ye.point : $t(e.tileAnchorPoint, pe, ne, 1, e),
                Te = It(ne.x, ne.y, e, i),
                Le = It(ge.x, ge.y, e, i),
                ve = zt(l.writingMode, Te, Le, M);
              if (ve) return ve
            }
            const ie = Qr(R * C.getoffsetX(l.glyphStartIndex), D, N, f, l.segment, l.lineStartIndex, l.lineStartIndex + l.lineLength, e, z);
            if (!ie || e.projectionCache.anyProjectionOccluded) return {
              notEnoughRoom: !0
            };
            H = [ie]
          }
          for (const ie of H) s.av(T, ie.point, ie.angle);
          return {}
        }

        function $t(p, e, i, l, u) {
          const f = p.add(p.sub(e)._unit()),
            g = xt(f.x, f.y, u).point,
            C = i.sub(g);
          return i.add(C._mult(l / C.mag()))
        }

        function Gt(p, e, i) {
          const l = e.projectionCache;
          if (l.projections[p]) return l.projections[p];
          const u = new s.P(e.lineVertexArray.getx(p), e.lineVertexArray.gety(p)),
            f = xt(u.x, u.y, e);
          if (f.signedDistanceFromCamera > 0) return l.projections[p] = f.point, l.anyProjectionOccluded = l.anyProjectionOccluded || f.isOccluded, f.point;
          const g = p - i.direction;
          return $t(i.distanceFromAnchor === 0 ? e.tileAnchorPoint : new s.P(e.lineVertexArray.getx(g), e.lineVertexArray.gety(g)), u, i.previousVertex, i.absOffsetX - i.distanceFromAnchor + 1, e)
        }

        function xt(p, e, i) {
          const l = p + i.translation[0],
            u = e + i.translation[1];
          let f;
          return i.pitchWithMap ? (f = vn(l, u, i.pitchedLabelPlaneMatrix, i.getElevation), f.isOccluded = !1) : (f = i.transform.projectTileCoordinates(l, u, i.unwrappedTileID, i.getElevation), f.point.x = (.5 * f.point.x + .5) * i.width, f.point.y = (.5 * -f.point.y + .5) * i.height), f
        }

        function It(p, e, i, l) {
          if (i.pitchWithMap) {
            const u = [p, e, 0, 1];
            return s.aw(u, u, l), i.transform.projectTileCoordinates(u[0] / u[3], u[1] / u[3], i.unwrappedTileID, i.getElevation).point
          }
          return {
            x: p / i.width * 2 - 1,
            y: 1 - e / i.height * 2
          }
        }

        function Wt(p, e, i) {
          return i.transform.projectTileCoordinates(p, e, i.unwrappedTileID, i.getElevation)
        }

        function Nt(p, e, i) {
          return p._unit()._perp()._mult(e * i)
        }

        function gr(p, e, i, l, u, f, g, C, T) {
          if (C.projectionCache.offsets[p]) return C.projectionCache.offsets[p];
          const M = i.add(e);
          if (p + T.direction < l || p + T.direction >= u) return C.projectionCache.offsets[p] = M, M;
          const z = Gt(p + T.direction, C, T),
            R = Nt(z.sub(i), g, T.direction),
            D = i.add(R),
            N = z.add(R);
          return C.projectionCache.offsets[p] = s.ax(f, M, D, N) || M, C.projectionCache.offsets[p]
        }

        function Qr(p, e, i, l, u, f, g, C, T) {
          const M = l ? p - e : p + e;
          let z = M > 0 ? 1 : -1,
            R = 0;
          l && (z *= -1, R = Math.PI), z < 0 && (R += Math.PI);
          let D, N = z > 0 ? f + u : f + u + 1;
          C.projectionCache.cachedAnchorPoint ? D = C.projectionCache.cachedAnchorPoint : (D = xt(C.tileAnchorPoint.x, C.tileAnchorPoint.y, C).point, C.projectionCache.cachedAnchorPoint = D);
          let H, ie, ne = D,
            se = D,
            pe = 0,
            ye = 0;
          const ge = Math.abs(M),
            Te = [];
          let Le;
          for (; pe + ye <= ge;) {
            if (N += z, N < f || N >= g) return null;
            pe += ye, se = ne, ie = H;
            const st = {
              absOffsetX: ge,
              direction: z,
              distanceFromAnchor: pe,
              previousVertex: se
            };
            if (ne = Gt(N, C, st), i === 0) Te.push(se), Le = ne.sub(se);
            else {
              let Xe;
              const Qe = ne.sub(se);
              Xe = Qe.mag() === 0 ? Nt(Gt(N + z, C, st).sub(ne), i, z) : Nt(Qe, i, z), ie || (ie = se.add(Xe)), H = gr(N, Xe, ne, f, g, ie, i, C, st), Te.push(ie), Le = H.sub(ie)
            }
            ye = Le.mag()
          }
          const ve = Le._mult((ge - pe) / ye)._add(ie || se),
            Ne = R + Math.atan2(ne.y - se.y, ne.x - se.x);
          return Te.push(ve), {
            point: ve,
            angle: T ? Ne : 0,
            path: Te
          }
        }
        const zr = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

        function Hr(p, e) {
          for (let i = 0; i < p; i++) {
            const l = e.length;
            e.resize(l + 4), e.float32.set(zr, 3 * l)
          }
        }

        function hn(p, e, i) {
          const l = e[0],
            u = e[1];
          return p[0] = i[0] * l + i[4] * u + i[12], p[1] = i[1] * l + i[5] * u + i[13], p[3] = i[3] * l + i[7] * u + i[15], p
        }
        const Yt = 100;
        class tn {
          constructor(e, i = new jr(e.width + 200, e.height + 200, 25), l = new jr(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = i, this.ignoredGrid = l, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Yt, this.screenBottomBoundary = e.height + Yt, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6
          }
          placeCollisionBox(e, i, l, u, f, g, C, T, M, z, R, D) {
            const N = this.projectAndGetPerspectiveRatio(e.anchorPointX + T[0], e.anchorPointY + T[1], f, z, D),
              H = l * N.perspectiveRatio;
            let ie;
            if (g || C) ie = this._projectCollisionBox(e, H, u, f, g, C, T, N, z, R, D);
            else {
              const Le = N.x + (R ? R.x * H : 0),
                ve = N.y + (R ? R.y * H : 0);
              ie = {
                allPointsOccluded: !1,
                box: [Le + e.x1 * H, ve + e.y1 * H, Le + e.x2 * H, ve + e.y2 * H]
              }
            }
            const [ne, se, pe, ye] = ie.box, ge = g ? ie.allPointsOccluded : N.isOccluded;
            let Te = ge;
            return Te || (Te = N.perspectiveRatio < this.perspectiveRatioCutoff), Te || (Te = !this.isInsideGrid(ne, se, pe, ye)), Te || i !== "always" && this.grid.hitTest(ne, se, pe, ye, i, M) ? {
              box: [ne, se, pe, ye],
              placeable: !1,
              offscreen: !1,
              occluded: ge
            } : {
              box: [ne, se, pe, ye],
              placeable: !0,
              offscreen: this.isOffscreen(ne, se, pe, ye),
              occluded: ge
            }
          }
          placeCollisionCircles(e, i, l, u, f, g, C, T, M, z, R, D, N, H) {
            const ie = [],
              ne = new s.P(i.anchorX, i.anchorY),
              se = this.getPerspectiveRatio(ne.x, ne.y, g, H),
              pe = (M ? f * this.transform.getPitchedTextCorrection(i.anchorX, i.anchorY, g) / se : f * se) / s.aB,
              ye = {
                getElevation: H,
                pitchedLabelPlaneMatrix: C,
                lineVertexArray: l,
                pitchWithMap: M,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: this.transform,
                tileAnchorPoint: ne,
                unwrappedTileID: g,
                width: this.transform.width,
                height: this.transform.height,
                translation: N
              },
              ge = $n(pe, u, i.lineOffsetX * pe, i.lineOffsetY * pe, !1, i, !1, ye);
            let Te = !1,
              Le = !1,
              ve = !0;
            if (ge) {
              const Ne = .5 * R * se + D,
                st = new s.P(-100, -100),
                Xe = new s.P(this.screenRightBoundary, this.screenBottomBoundary),
                Qe = new Ur,
                at = ge.first,
                Ht = ge.last;
              let Xt = [];
              for (let dn = at.path.length - 1; dn >= 1; dn--) Xt.push(at.path[dn]);
              for (let dn = 1; dn < Ht.path.length; dn++) Xt.push(Ht.path[dn]);
              const kt = 2.5 * Ne;
              if (M) {
                const dn = this.projectPathToScreenSpace(Xt, ye);
                Xt = dn.some((Tn => Tn.signedDistanceFromCamera <= 0)) ? [] : dn.map((Tn => Tn.point))
              }
              let wr = [];
              if (Xt.length > 0) {
                const dn = Xt[0].clone(),
                  Tn = Xt[0].clone();
                for (let kn = 1; kn < Xt.length; kn++) dn.x = Math.min(dn.x, Xt[kn].x), dn.y = Math.min(dn.y, Xt[kn].y), Tn.x = Math.max(Tn.x, Xt[kn].x), Tn.y = Math.max(Tn.y, Xt[kn].y);
                wr = dn.x >= st.x && Tn.x <= Xe.x && dn.y >= st.y && Tn.y <= Xe.y ? [Xt] : Tn.x < st.x || dn.x > Xe.x || Tn.y < st.y || dn.y > Xe.y ? [] : s.ay([Xt], st.x, st.y, Xe.x, Xe.y)
              }
              for (const dn of wr) {
                Qe.reset(dn, .25 * Ne);
                let Tn = 0;
                Tn = Qe.length <= .5 * Ne ? 1 : Math.ceil(Qe.paddedLength / kt) + 1;
                for (let kn = 0; kn < Tn; kn++) {
                  const Sn = kn / Math.max(Tn - 1, 1),
                    Gn = Qe.lerp(Sn),
                    Yn = Gn.x + Yt,
                    un = Gn.y + Yt;
                  ie.push(Yn, un, Ne, 0);
                  const Mn = Yn - Ne,
                    li = un - Ne,
                    mi = Yn + Ne,
                    xi = un + Ne;
                  if (ve = ve && this.isOffscreen(Mn, li, mi, xi), Le = Le || this.isInsideGrid(Mn, li, mi, xi), e !== "always" && this.grid.hitTestCircle(Yn, un, Ne, e, z) && (Te = !0, !T)) return {
                    circles: [],
                    offscreen: !1,
                    collisionDetected: Te
                  }
                }
              }
            }
            return {
              circles: !T && Te || !Le || se < this.perspectiveRatioCutoff ? [] : ie,
              offscreen: ve,
              collisionDetected: Te
            }
          }
          projectPathToScreenSpace(e, i) {
            const l = (function(u, f) {
              const g = s.L();
              return s.aq(g, f.pitchedLabelPlaneMatrix), u.map((C => {
                const T = vn(C.x, C.y, g, f.getElevation),
                  M = f.transform.projectTileCoordinates(T.point.x, T.point.y, f.unwrappedTileID, f.getElevation);
                return M.point.x = (.5 * M.point.x + .5) * f.width, M.point.y = (.5 * -M.point.y + .5) * f.height, M
              }))
            })(e, i);
            return (function(u) {
              let f = 0,
                g = 0,
                C = 0,
                T = 0;
              for (let M = 0; M < u.length; M++) u[M].isOccluded ? (C = M + 1, T = 0) : (T++, T > g && (g = T, f = C));
              return u.slice(f, f + g)
            })(l)
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const i = [],
              l = new s.a2;
            for (const R of e) {
              const D = new s.P(R.x + Yt, R.y + Yt);
              l.extend(D), i.push(D)
            }
            const {
              minX: u,
              minY: f,
              maxX: g,
              maxY: C
            } = l, T = this.grid.query(u, f, g, C).concat(this.ignoredGrid.query(u, f, g, C)), M = {}, z = {};
            for (const R of T) {
              const D = R.key;
              if (M[D.bucketInstanceId] === void 0 && (M[D.bucketInstanceId] = {}), M[D.bucketInstanceId][D.featureIndex]) continue;
              const N = [new s.P(R.x1, R.y1), new s.P(R.x2, R.y1), new s.P(R.x2, R.y2), new s.P(R.x1, R.y2)];
              s.az(i, N) && (M[D.bucketInstanceId][D.featureIndex] = !0, z[D.bucketInstanceId] === void 0 && (z[D.bucketInstanceId] = []), z[D.bucketInstanceId].push(D.featureIndex))
            }
            return z
          }
          insertCollisionBox(e, i, l, u, f, g) {
            (l ? this.ignoredGrid : this.grid).insert({
              bucketInstanceId: u,
              featureIndex: f,
              collisionGroupID: g,
              overlapMode: i
            }, e[0], e[1], e[2], e[3])
          }
          insertCollisionCircles(e, i, l, u, f, g) {
            const C = l ? this.ignoredGrid : this.grid,
              T = {
                bucketInstanceId: u,
                featureIndex: f,
                collisionGroupID: g,
                overlapMode: i
              };
            for (let M = 0; M < e.length; M += 4) C.insertCircle(T, e[M], e[M + 1], e[M + 2])
          }
          projectAndGetPerspectiveRatio(e, i, l, u, f) {
            if (f) {
              let g;
              u ? (g = [e, i, u(e, i), 1], s.aw(g, g, f)) : (g = [e, i, 0, 1], hn(g, g, f));
              const C = g[3];
              return {
                x: (g[0] / C + 1) / 2 * this.transform.width + Yt,
                y: (-g[1] / C + 1) / 2 * this.transform.height + Yt,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / C * .5,
                isOccluded: !1,
                signedDistanceFromCamera: C
              }
            } {
              const g = this.transform.projectTileCoordinates(e, i, l, u);
              return {
                x: (g.point.x + 1) / 2 * this.transform.width + Yt,
                y: (1 - g.point.y) / 2 * this.transform.height + Yt,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / g.signedDistanceFromCamera * .5,
                isOccluded: g.isOccluded,
                signedDistanceFromCamera: g.signedDistanceFromCamera
              }
            }
          }
          getPerspectiveRatio(e, i, l, u) {
            const f = this.transform.projectTileCoordinates(e, i, l, u);
            return .5 + this.transform.cameraToCenterDistance / f.signedDistanceFromCamera * .5
          }
          isOffscreen(e, i, l, u) {
            return l < Yt || e >= this.screenRightBoundary || u < Yt || i > this.screenBottomBoundary
          }
          isInsideGrid(e, i, l, u) {
            return l >= 0 && e < this.gridRightBoundary && u >= 0 && i < this.gridBottomBoundary
          }
          getViewportMatrix() {
            const e = s.ag([]);
            return s.M(e, e, [-100, -100, 0]), e
          }
          _projectCollisionBox(e, i, l, u, f, g, C, T, M, z, R) {
            let D = 1,
              N = 0,
              H = 0,
              ie = 1;
            const ne = e.anchorPointX + C[0],
              se = e.anchorPointY + C[1];
            if (g && !f) {
              const Xt = this.projectAndGetPerspectiveRatio(ne + 1, se, u, M, R),
                kt = Xt.x - T.x,
                wr = Math.atan((Xt.y - T.y) / kt) + (kt < 0 ? Math.PI : 0),
                dn = Math.sin(wr),
                Tn = Math.cos(wr);
              D = Tn, N = dn, H = -dn, ie = Tn
            } else if (!g && f) {
              const Xt = Fr(this.transform);
              D = Xt.vecEast[0], N = Xt.vecEast[1], H = Xt.vecSouth[0], ie = Xt.vecSouth[1]
            }
            let pe = T.x,
              ye = T.y,
              ge = i;
            f && (pe = ne, ye = se, ge = Math.pow(2, -(this.transform.zoom - l.overscaledZ)), ge *= this.transform.getPitchedTextCorrection(ne, se, u), z || (ge *= s.ah(.5 + T.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), z && (pe += D * z.x * ge + H * z.y * ge, ye += N * z.x * ge + ie * z.y * ge);
            const Te = e.x1 * ge,
              Le = e.x2 * ge,
              ve = (Te + Le) / 2,
              Ne = e.y1 * ge,
              st = e.y2 * ge,
              Xe = (Ne + st) / 2,
              Qe = [{
                offsetX: Te,
                offsetY: Ne
              }, {
                offsetX: ve,
                offsetY: Ne
              }, {
                offsetX: Le,
                offsetY: Ne
              }, {
                offsetX: Le,
                offsetY: Xe
              }, {
                offsetX: Le,
                offsetY: st
              }, {
                offsetX: ve,
                offsetY: st
              }, {
                offsetX: Te,
                offsetY: st
              }, {
                offsetX: Te,
                offsetY: Xe
              }];
            let at = [];
            for (const {
                offsetX: Xt,
                offsetY: kt
              }
              of Qe) at.push(new s.P(pe + D * Xt + H * kt, ye + N * Xt + ie * kt));
            let Ht = !1;
            if (f) {
              const Xt = at.map((kt => this.projectAndGetPerspectiveRatio(kt.x, kt.y, u, M, R)));
              Ht = Xt.some((kt => !kt.isOccluded)), at = Xt.map((kt => new s.P(kt.x, kt.y)))
            } else Ht = !0;
            return {
              box: s.aA(at),
              allPointsOccluded: !Ht
            }
          }
        }
        class an {
          constructor(e, i, l, u) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? i : -i))) : u && l ? 1 : 0, this.placed = l
          }
          isHidden() {
            return this.opacity === 0 && !this.placed
          }
        }
        class ln {
          constructor(e, i, l, u, f) {
            this.text = new an(e ? e.text : null, i, l, f), this.icon = new an(e ? e.icon : null, i, u, f)
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden()
          }
        }
        class Pi {
          constructor(e, i, l) {
            this.text = e, this.icon = i, this.skipFade = l
          }
        }
        class In {
          constructor(e, i, l, u, f) {
            this.bucketInstanceId = e, this.featureIndex = i, this.sourceLayerIndex = l, this.bucketIndex = u, this.tileID = f
          }
        }
        class fi {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {}
          }
          get(e) {
            if (this.crossSourceCollisions) return {
              ID: 0,
              predicate: null
            };
            if (!this.collisionGroups[e]) {
              const i = ++this.maxGroupID;
              this.collisionGroups[e] = {
                ID: i,
                predicate: l => l.collisionGroupID === i
              }
            }
            return this.collisionGroups[e]
          }
        }

        function Dn(p, e, i, l, u) {
          const {
            horizontalAlign: f,
            verticalAlign: g
          } = s.aH(p);
          return new s.P(-(f - .5) * e + l[0] * u, -(g - .5) * i + l[1] * u)
        }
        class ni {
          constructor(e, i, l, u, f) {
            this.transform = e.clone(), this.terrain = i, this.collisionIndex = new tn(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = l, this.retainedQueryData = {}, this.collisionGroups = new fi(u), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = f, f && (f.prevPlacement = void 0), this.placedOrientations = {}
          }
          _getTerrainElevationFunc(e) {
            const i = this.terrain;
            return i ? (l, u) => i.getElevation(e, l, u) : null
          }
          getBucketParts(e, i, l, u) {
            const f = l.getBucket(i),
              g = l.latestFeatureIndex;
            if (!f || !g || i.id !== f.layerIds[0]) return;
            const C = l.collisionBoxArray,
              T = f.layers[0].layout,
              M = f.layers[0].paint,
              z = Math.pow(2, this.transform.zoom - l.tileID.overscaledZ),
              R = l.tileSize / s.$,
              D = l.tileID.toUnwrapped(),
              N = T.get("text-rotation-alignment") === "map",
              H = s.aC(l, 1, this.transform.zoom),
              ie = s.aD(this.collisionIndex.transform, l, M.get("text-translate"), M.get("text-translate-anchor")),
              ne = s.aD(this.collisionIndex.transform, l, M.get("icon-translate"), M.get("icon-translate-anchor")),
              se = $r(N, this.transform, H);
            this.retainedQueryData[f.bucketInstanceId] = new In(f.bucketInstanceId, g, f.sourceLayerIndex, f.index, l.tileID);
            const pe = {
              bucket: f,
              layout: T,
              translationText: ie,
              translationIcon: ne,
              unwrappedTileID: D,
              pitchedLabelPlaneMatrix: se,
              scale: z,
              textPixelRatio: R,
              holdingForFade: l.holdingForFade(),
              collisionBoxArray: C,
              partiallyEvaluatedTextSize: s.an(f.textSizeData, this.transform.zoom),
              collisionGroup: this.collisionGroups.get(f.sourceID)
            };
            if (u)
              for (const ye of f.sortKeyRanges) {
                const {
                  sortKey: ge,
                  symbolInstanceStart: Te,
                  symbolInstanceEnd: Le
                } = ye;
                e.push({
                  sortKey: ge,
                  symbolInstanceStart: Te,
                  symbolInstanceEnd: Le,
                  parameters: pe
                })
              } else e.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: f.symbolInstances.length,
                parameters: pe
              })
          }
          attemptAnchorPlacement(e, i, l, u, f, g, C, T, M, z, R, D, N, H, ie, ne, se, pe, ye, ge) {
            const Te = s.aE[e.textAnchor],
              Le = [e.textOffset0, e.textOffset1],
              ve = Dn(Te, l, u, Le, f),
              Ne = this.collisionIndex.placeCollisionBox(i, D, T, M, z, C, g, ne, R.predicate, ye, ve, ge);
            if ((!pe || this.collisionIndex.placeCollisionBox(pe, D, T, M, z, C, g, se, R.predicate, ye, ve, ge).placeable) && Ne.placeable) {
              let st;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[N.crossTileID] && this.prevPlacement.placements[N.crossTileID] && this.prevPlacement.placements[N.crossTileID].text && (st = this.prevPlacement.variableOffsets[N.crossTileID].anchor), N.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[N.crossTileID] = {
                textOffset: Le,
                width: l,
                height: u,
                anchor: Te,
                textBoxScale: f,
                prevAnchor: st
              }, this.markUsedJustification(H, Te, N, ie), H.allowVerticalPlacement && (this.markUsedOrientation(H, ie, N), this.placedOrientations[N.crossTileID] = ie), {
                shift: ve,
                placedGlyphBoxes: Ne
              }
            }
          }
          placeLayerBucketPart(e, i, l) {
            const {
              bucket: u,
              layout: f,
              translationText: g,
              translationIcon: C,
              unwrappedTileID: T,
              pitchedLabelPlaneMatrix: M,
              textPixelRatio: z,
              holdingForFade: R,
              collisionBoxArray: D,
              partiallyEvaluatedTextSize: N,
              collisionGroup: H
            } = e.parameters, ie = f.get("text-optional"), ne = f.get("icon-optional"), se = s.aF(f, "text-overlap", "text-allow-overlap"), pe = se === "always", ye = s.aF(f, "icon-overlap", "icon-allow-overlap"), ge = ye === "always", Te = f.get("text-rotation-alignment") === "map", Le = f.get("text-pitch-alignment") === "map", ve = f.get("icon-text-fit") !== "none", Ne = f.get("symbol-z-order") === "viewport-y", st = pe && (ge || !u.hasIconData() || ne), Xe = ge && (pe || !u.hasTextData() || ie);
            !u.collisionArrays && D && u.deserializeCollisionBoxes(D);
            const Qe = this.retainedQueryData[u.bucketInstanceId].tileID,
              at = this._getTerrainElevationFunc(Qe),
              Ht = this.transform.getFastPathSimpleProjectionMatrix(Qe),
              Xt = (kt, wr, dn) => {
                var Tn, kn;
                if (i[kt.crossTileID]) return;
                if (R) return void(this.placements[kt.crossTileID] = new Pi(!1, !1, !1));
                let Sn = !1,
                  Gn = !1,
                  Yn = !0,
                  un = null,
                  Mn = {
                    box: null,
                    placeable: !1,
                    offscreen: null,
                    occluded: !1
                  },
                  li = {
                    placeable: !1
                  },
                  mi = null,
                  xi = null,
                  Hi = null,
                  Aa = 0,
                  Co = 0,
                  To = 0;
                wr.textFeatureIndex ? Aa = wr.textFeatureIndex : kt.useRuntimeCollisionCircles && (Aa = kt.featureIndex), wr.verticalTextFeatureIndex && (Co = wr.verticalTextFeatureIndex);
                const ks = wr.textBox;
                if (ks) {
                  const Qi = ci => {
                      let _i = s.ao.horizontal;
                      if (u.allowVerticalPlacement && !ci && this.prevPlacement) {
                        const ga = this.prevPlacement.placedOrientations[kt.crossTileID];
                        ga && (this.placedOrientations[kt.crossTileID] = ga, _i = ga, this.markUsedOrientation(u, _i, kt))
                      }
                      return _i
                    },
                    Ea = (ci, _i) => {
                      if (u.allowVerticalPlacement && kt.numVerticalGlyphVertices > 0 && wr.verticalTextBox) {
                        for (const ga of u.writingModes)
                          if (ga === s.ao.vertical ? (Mn = _i(), li = Mn) : Mn = ci(), Mn && Mn.placeable) break
                      } else Mn = ci()
                    },
                    Ji = kt.textAnchorOffsetStartIndex,
                    So = kt.textAnchorOffsetEndIndex;
                  if (So === Ji) {
                    const ci = (_i, ga) => {
                      const ui = this.collisionIndex.placeCollisionBox(_i, se, z, Qe, T, Le, Te, g, H.predicate, at, void 0, Ht);
                      return ui && ui.placeable && (this.markUsedOrientation(u, ga, kt), this.placedOrientations[kt.crossTileID] = ga), ui
                    };
                    Ea((() => ci(ks, s.ao.horizontal)), (() => {
                      const _i = wr.verticalTextBox;
                      return u.allowVerticalPlacement && kt.numVerticalGlyphVertices > 0 && _i ? ci(_i, s.ao.vertical) : {
                        box: null,
                        offscreen: null
                      }
                    })), Qi(Mn && Mn.placeable)
                  } else {
                    let ci = s.aE[(kn = (Tn = this.prevPlacement) === null || Tn === void 0 ? void 0 : Tn.variableOffsets[kt.crossTileID]) === null || kn === void 0 ? void 0 : kn.anchor];
                    const _i = (ui, ul, As) => {
                      const ao = ui.x2 - ui.x1,
                        za = ui.y2 - ui.y1,
                        Io = kt.textBoxScale,
                        Dd = ve && ye === "never" ? ul : null;
                      let ia = null,
                        Rd = se === "never" ? 1 : 2,
                        Cu = "never";
                      ci && Rd++;
                      for (let rc = 0; rc < Rd; rc++) {
                        for (let nc = Ji; nc < So; nc++) {
                          const Po = u.textAnchorOffsets.get(nc);
                          if (ci && Po.textAnchor !== ci) continue;
                          const oo = this.attemptAnchorPlacement(Po, ui, ao, za, Io, Te, Le, z, Qe, T, H, Cu, kt, u, As, g, C, Dd, at);
                          if (oo && (ia = oo.placedGlyphBoxes, ia && ia.placeable)) return Sn = !0, un = oo.shift, ia
                        }
                        ci ? ci = null : Cu = se
                      }
                      return l && !ia && (ia = {
                        box: this.collisionIndex.placeCollisionBox(ks, "always", z, Qe, T, Le, Te, g, H.predicate, at, void 0, Ht).box,
                        offscreen: !1,
                        placeable: !1,
                        occluded: !1
                      }), ia
                    };
                    Ea((() => _i(ks, wr.iconBox, s.ao.horizontal)), (() => {
                      const ui = wr.verticalTextBox;
                      return u.allowVerticalPlacement && (!Mn || !Mn.placeable) && kt.numVerticalGlyphVertices > 0 && ui ? _i(ui, wr.verticalIconBox, s.ao.vertical) : {
                        box: null,
                        occluded: !0,
                        offscreen: null
                      }
                    })), Mn && (Sn = Mn.placeable, Yn = Mn.offscreen);
                    const ga = Qi(Mn && Mn.placeable);
                    if (!Sn && this.prevPlacement) {
                      const ui = this.prevPlacement.variableOffsets[kt.crossTileID];
                      ui && (this.variableOffsets[kt.crossTileID] = ui, this.markUsedJustification(u, ui.anchor, kt, ga))
                    }
                  }
                }
                if (mi = Mn, Sn = mi && mi.placeable, Yn = mi && mi.offscreen, kt.useRuntimeCollisionCircles) {
                  const Qi = u.text.placedSymbolArray.get(kt.centerJustifiedTextSymbolIndex),
                    Ea = s.ap(u.textSizeData, N, Qi),
                    Ji = f.get("text-padding");
                  xi = this.collisionIndex.placeCollisionCircles(se, Qi, u.lineVertexArray, u.glyphOffsetArray, Ea, T, M, l, Le, H.predicate, kt.collisionCircleDiameter, Ji, g, at), xi.circles.length && xi.collisionDetected && !l && s.w("Collisions detected, but collision boxes are not shown"), Sn = pe || xi.circles.length > 0 && !xi.collisionDetected, Yn = Yn && xi.offscreen
                }
                if (wr.iconFeatureIndex && (To = wr.iconFeatureIndex), wr.iconBox) {
                  const Qi = Ea => this.collisionIndex.placeCollisionBox(Ea, ye, z, Qe, T, Le, Te, C, H.predicate, at, ve && un ? un : void 0, Ht);
                  li && li.placeable && wr.verticalIconBox ? (Hi = Qi(wr.verticalIconBox), Gn = Hi.placeable) : (Hi = Qi(wr.iconBox), Gn = Hi.placeable), Yn = Yn && Hi.offscreen
                }
                const Ms = ie || kt.numHorizontalGlyphVertices === 0 && kt.numVerticalGlyphVertices === 0,
                  Yo = ne || kt.numIconVertices === 0;
                Ms || Yo ? Yo ? Ms || (Gn = Gn && Sn) : Sn = Gn && Sn : Gn = Sn = Gn && Sn;
                const Ko = Gn && Hi.placeable;
                if (Sn && mi.placeable && this.collisionIndex.insertCollisionBox(mi.box, se, f.get("text-ignore-placement"), u.bucketInstanceId, li && li.placeable && Co ? Co : Aa, H.ID), Ko && this.collisionIndex.insertCollisionBox(Hi.box, ye, f.get("icon-ignore-placement"), u.bucketInstanceId, To, H.ID), xi && Sn && this.collisionIndex.insertCollisionCircles(xi.circles, se, f.get("text-ignore-placement"), u.bucketInstanceId, Aa, H.ID), l && this.storeCollisionData(u.bucketInstanceId, dn, wr, mi, Hi, xi), kt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                if (u.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[kt.crossTileID] = new Pi((Sn || st) && !(mi != null && mi.occluded), (Gn || Xe) && !(Hi != null && Hi.occluded), Yn || u.justReloaded), i[kt.crossTileID] = !0
              };
            if (Ne) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const kt = u.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let wr = kt.length - 1; wr >= 0; --wr) {
                const dn = kt[wr];
                Xt(u.symbolInstances.get(dn), u.collisionArrays[dn], dn)
              }
            } else
              for (let kt = e.symbolInstanceStart; kt < e.symbolInstanceEnd; kt++) Xt(u.symbolInstances.get(kt), u.collisionArrays[kt], kt);
            u.justReloaded = !1
          }
          storeCollisionData(e, i, l, u, f, g) {
            if (l.textBox || l.iconBox) {
              let C, T;
              this.collisionBoxArrays.has(e) ? C = this.collisionBoxArrays.get(e) : (C = new Map, this.collisionBoxArrays.set(e, C)), C.has(i) ? T = C.get(i) : (T = {
                text: null,
                icon: null
              }, C.set(i, T)), l.textBox && (T.text = u.box), l.iconBox && (T.icon = f.box)
            }
            if (g) {
              let C = this.collisionCircleArrays[e];
              C === void 0 && (C = this.collisionCircleArrays[e] = []);
              for (let T = 0; T < g.circles.length; T += 4) C.push(g.circles[T + 0] - Yt), C.push(g.circles[T + 1] - Yt), C.push(g.circles[T + 2]), C.push(g.collisionDetected ? 1 : 0)
            }
          }
          markUsedJustification(e, i, l, u) {
            let f;
            f = u === s.ao.vertical ? l.verticalPlacedTextSymbolIndex : {
              left: l.leftJustifiedTextSymbolIndex,
              center: l.centerJustifiedTextSymbolIndex,
              right: l.rightJustifiedTextSymbolIndex
            } [s.aG(i)];
            const g = [l.leftJustifiedTextSymbolIndex, l.centerJustifiedTextSymbolIndex, l.rightJustifiedTextSymbolIndex, l.verticalPlacedTextSymbolIndex];
            for (const C of g) C >= 0 && (e.text.placedSymbolArray.get(C).crossTileID = f >= 0 && C !== f ? 0 : l.crossTileID)
          }
          markUsedOrientation(e, i, l) {
            const u = i === s.ao.horizontal || i === s.ao.horizontalOnly ? i : 0,
              f = i === s.ao.vertical ? i : 0,
              g = [l.leftJustifiedTextSymbolIndex, l.centerJustifiedTextSymbolIndex, l.rightJustifiedTextSymbolIndex];
            for (const C of g) e.text.placedSymbolArray.get(C).placedOrientation = u;
            l.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(l.verticalPlacedTextSymbolIndex).placedOrientation = f)
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const i = this.prevPlacement;
            let l = !1;
            this.prevZoomAdjustment = i ? i.zoomAdjustment(this.transform.zoom) : 0;
            const u = i ? i.symbolFadeChange(e) : 1,
              f = i ? i.opacities : {},
              g = i ? i.variableOffsets : {},
              C = i ? i.placedOrientations : {};
            for (const T in this.placements) {
              const M = this.placements[T],
                z = f[T];
              z ? (this.opacities[T] = new ln(z, u, M.text, M.icon), l = l || M.text !== z.text.placed || M.icon !== z.icon.placed) : (this.opacities[T] = new ln(null, u, M.text, M.icon, M.skipFade), l = l || M.text || M.icon)
            }
            for (const T in f) {
              const M = f[T];
              if (!this.opacities[T]) {
                const z = new ln(M, u, !1, !1);
                z.isHidden() || (this.opacities[T] = z, l = l || M.text.placed || M.icon.placed)
              }
            }
            for (const T in g) this.variableOffsets[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.variableOffsets[T] = g[T]);
            for (const T in C) this.placedOrientations[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.placedOrientations[T] = C[T]);
            if (i && i.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            l ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = i ? i.lastPlacementChangeTime : e)
          }
          updateLayerOpacities(e, i) {
            const l = {};
            for (const u of i) {
              const f = u.getBucket(e);
              f && u.latestFeatureIndex && e.id === f.layerIds[0] && this.updateBucketOpacities(f, u.tileID, l, u.collisionBoxArray)
            }
          }
          updateBucketOpacities(e, i, l, u) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const f = e.layers[0],
              g = f.layout,
              C = new ln(null, 0, !1, !1, !0),
              T = g.get("text-allow-overlap"),
              M = g.get("icon-allow-overlap"),
              z = f._unevaluatedLayout.hasValue("text-variable-anchor") || f._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
              R = g.get("text-rotation-alignment") === "map",
              D = g.get("text-pitch-alignment") === "map",
              N = g.get("icon-text-fit") !== "none",
              H = new ln(null, 0, T && (M || !e.hasIconData() || g.get("icon-optional")), M && (T || !e.hasTextData() || g.get("text-optional")), !0);
            !e.collisionArrays && u && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(u);
            const ie = (se, pe, ye) => {
                for (let ge = 0; ge < pe / 4; ge++) se.opacityVertexArray.emplaceBack(ye);
                se.hasVisibleVertices = se.hasVisibleVertices || ye !== Ca
              },
              ne = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let se = 0; se < e.symbolInstances.length; se++) {
              const pe = e.symbolInstances.get(se),
                {
                  numHorizontalGlyphVertices: ye,
                  numVerticalGlyphVertices: ge,
                  crossTileID: Te
                } = pe;
              let Le = this.opacities[Te];
              l[Te] ? Le = C : Le || (Le = H, this.opacities[Te] = Le), l[Te] = !0;
              const ve = pe.numIconVertices > 0,
                Ne = this.placedOrientations[pe.crossTileID],
                st = Ne === s.ao.vertical,
                Xe = Ne === s.ao.horizontal || Ne === s.ao.horizontalOnly;
              if (ye > 0 || ge > 0) {
                const at = wa(Le.text);
                ie(e.text, ye, st ? Ca : at), ie(e.text, ge, Xe ? Ca : at);
                const Ht = Le.text.isHidden();
                [pe.rightJustifiedTextSymbolIndex, pe.centerJustifiedTextSymbolIndex, pe.leftJustifiedTextSymbolIndex].forEach((wr => {
                  wr >= 0 && (e.text.placedSymbolArray.get(wr).hidden = Ht || st ? 1 : 0)
                })), pe.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(pe.verticalPlacedTextSymbolIndex).hidden = Ht || Xe ? 1 : 0);
                const Xt = this.variableOffsets[pe.crossTileID];
                Xt && this.markUsedJustification(e, Xt.anchor, pe, Ne);
                const kt = this.placedOrientations[pe.crossTileID];
                kt && (this.markUsedJustification(e, "left", pe, kt), this.markUsedOrientation(e, kt, pe))
              }
              if (ve) {
                const at = wa(Le.icon),
                  Ht = !(N && pe.verticalPlacedIconSymbolIndex && st);
                pe.placedIconSymbolIndex >= 0 && (ie(e.icon, pe.numIconVertices, Ht ? at : Ca), e.icon.placedSymbolArray.get(pe.placedIconSymbolIndex).hidden = Le.icon.isHidden()), pe.verticalPlacedIconSymbolIndex >= 0 && (ie(e.icon, pe.numVerticalIconVertices, Ht ? Ca : at), e.icon.placedSymbolArray.get(pe.verticalPlacedIconSymbolIndex).hidden = Le.icon.isHidden())
              }
              const Qe = ne && ne.has(se) ? ne.get(se) : {
                text: null,
                icon: null
              };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const at = e.collisionArrays[se];
                if (at) {
                  let Ht = new s.P(0, 0);
                  if (at.textBox || at.verticalTextBox) {
                    let Xt = !0;
                    if (z) {
                      const kt = this.variableOffsets[Te];
                      kt ? (Ht = Dn(kt.anchor, kt.width, kt.height, kt.textOffset, kt.textBoxScale), R && Ht._rotate(D ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Xt = !1
                    }
                    if (at.textBox || at.verticalTextBox) {
                      let kt;
                      at.textBox && (kt = st), at.verticalTextBox && (kt = Xe), qi(e.textCollisionBox.collisionVertexArray, Le.text.placed, !Xt || kt, Qe.text, Ht.x, Ht.y)
                    }
                  }
                  if (at.iconBox || at.verticalIconBox) {
                    const Xt = !!(!Xe && at.verticalIconBox);
                    let kt;
                    at.iconBox && (kt = Xt), at.verticalIconBox && (kt = !Xt), qi(e.iconCollisionBox.collisionVertexArray, Le.icon.placed, kt, Qe.icon, N ? Ht.x : 0, N ? Ht.y : 0)
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId])
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5)
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
          }
          stillRecent(e, i) {
            const l = this.zoomAtLastRecencyCheck === i ? 1 - this.zoomAdjustment(i) : 1;
            return this.zoomAtLastRecencyCheck = i, this.commitTime + this.fadeDuration * l > e
          }
          setStale() {
            this.stale = !0
          }
        }

        function qi(p, e, i, l, u, f) {
          l && l.length !== 0 || (l = [0, 0, 0, 0]);
          const g = l[0] - Yt,
            C = l[1] - Yt,
            T = l[2] - Yt,
            M = l[3] - Yt;
          p.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, f || 0, g, C), p.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, f || 0, T, C), p.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, f || 0, T, M), p.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, f || 0, g, M)
        }
        const Ui = Math.pow(2, 25),
          ki = Math.pow(2, 24),
          Mi = Math.pow(2, 17),
          $i = Math.pow(2, 16),
          na = Math.pow(2, 9),
          ua = Math.pow(2, 8),
          ba = Math.pow(2, 1);

        function wa(p) {
          if (p.opacity === 0 && !p.placed) return 0;
          if (p.opacity === 1 && p.placed) return 4294967295;
          const e = p.placed ? 1 : 0,
            i = Math.floor(127 * p.opacity);
          return i * Ui + e * ki + i * Mi + e * $i + i * na + e * ua + i * ba + e
        }
        const Ca = 0;
        class ha {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []
          }
          continuePlacement(e, i, l, u, f) {
            const g = this._bucketParts;
            for (; this._currentTileIndex < e.length;)
              if (i.getBucketParts(g, u, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, f()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, g.sort(((C, T) => C.sortKey - T.sortKey))); this._currentPartIndex < g.length;)
              if (i.placeLayerBucketPart(g[this._currentPartIndex], this._seenCrossTileIDs, l), this._currentPartIndex++, f()) return !0;
            return !1
          }
        }
        class da {
          constructor(e, i, l, u, f, g, C, T) {
            this.placement = new ni(e, i, g, C, T), this._currentPlacementIndex = l.length - 1, this._forceFullPlacement = u, this._showCollisionBoxes = f, this._done = !1
          }
          isDone() {
            return this._done
          }
          continuePlacement(e, i, l) {
            const u = Q.now(),
              f = () => !this._forceFullPlacement && Q.now() - u > 2;
            for (; this._currentPlacementIndex >= 0;) {
              const g = i[e[this._currentPlacementIndex]],
                C = this.placement.collisionIndex.transform.zoom;
              if (g.type === "symbol" && (!g.minzoom || g.minzoom <= C) && (!g.maxzoom || g.maxzoom > C)) {
                if (this._inProgressLayer || (this._inProgressLayer = new ha(g)), this._inProgressLayer.continuePlacement(l[g.source], this.placement, this._showCollisionBoxes, g, f)) return;
                delete this._inProgressLayer
              }
              this._currentPlacementIndex--
            }
            this._done = !0
          }
          commit(e) {
            return this.placement.commit(e), this.placement
          }
        }
        const pa = 512 / s.$ / 2;
        class go {
          constructor(e, i, l) {
            this.tileID = e, this.bucketInstanceId = l, this._symbolsByKey = {};
            const u = new Map;
            for (let f = 0; f < i.length; f++) {
              const g = i.get(f),
                C = g.key,
                T = u.get(C);
              T ? T.push(g) : u.set(C, [g])
            }
            for (const [f, g] of u) {
              const C = {
                positions: g.map((T => ({
                  x: Math.floor(T.anchorX * pa),
                  y: Math.floor(T.anchorY * pa)
                }))),
                crossTileIDs: g.map((T => T.crossTileID))
              };
              if (C.positions.length > 128) {
                const T = new s.aI(C.positions.length, 16, Uint16Array);
                for (const {
                    x: M,
                    y: z
                  }
                  of C.positions) T.add(M, z);
                T.finish(), delete C.positions, C.index = T
              }
              this._symbolsByKey[f] = C
            }
          }
          getScaledCoordinates(e, i) {
            const {
              x: l,
              y: u,
              z: f
            } = this.tileID.canonical, {
              x: g,
              y: C,
              z: T
            } = i.canonical, M = pa / Math.pow(2, T - f), z = (C * s.$ + e.anchorY) * M, R = u * s.$ * pa;
            return {
              x: Math.floor((g * s.$ + e.anchorX) * M - l * s.$ * pa),
              y: Math.floor(z - R)
            }
          }
          findMatches(e, i, l) {
            const u = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z);
            for (let f = 0; f < e.length; f++) {
              const g = e.get(f);
              if (g.crossTileID) continue;
              const C = this._symbolsByKey[g.key];
              if (!C) continue;
              const T = this.getScaledCoordinates(g, i);
              if (C.index) {
                const M = C.index.range(T.x - u, T.y - u, T.x + u, T.y + u).sort();
                for (const z of M) {
                  const R = C.crossTileIDs[z];
                  if (!l[R]) {
                    l[R] = !0, g.crossTileID = R;
                    break
                  }
                }
              } else if (C.positions)
                for (let M = 0; M < C.positions.length; M++) {
                  const z = C.positions[M],
                    R = C.crossTileIDs[M];
                  if (Math.abs(z.x - T.x) <= u && Math.abs(z.y - T.y) <= u && !l[R]) {
                    l[R] = !0, g.crossTileID = R;
                    break
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({
              crossTileIDs: e
            }) => e))
          }
        }
        class Za {
          constructor() {
            this.maxCrossTileID = 0
          }
          generate() {
            return ++this.maxCrossTileID
          }
        }
        class hs {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
          }
          handleWrapJump(e) {
            const i = Math.round((e - this.lng) / 360);
            if (i !== 0)
              for (const l in this.indexes) {
                const u = this.indexes[l],
                  f = {};
                for (const g in u) {
                  const C = u[g];
                  C.tileID = C.tileID.unwrapTo(C.tileID.wrap + i), f[C.tileID.key] = C
                }
                this.indexes[l] = f
              }
            this.lng = e
          }
          addBucket(e, i, l) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === i.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
            }
            for (let f = 0; f < i.symbolInstances.length; f++) i.symbolInstances.get(f).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const u = this.usedCrossTileIDs[e.overscaledZ];
            for (const f in this.indexes) {
              const g = this.indexes[f];
              if (Number(f) > e.overscaledZ)
                for (const C in g) {
                  const T = g[C];
                  T.tileID.isChildOf(e) && T.findMatches(i.symbolInstances, e, u)
                } else {
                  const C = g[e.scaledTo(Number(f)).key];
                  C && C.findMatches(i.symbolInstances, e, u)
                }
            }
            for (let f = 0; f < i.symbolInstances.length; f++) {
              const g = i.symbolInstances.get(f);
              g.crossTileID || (g.crossTileID = l.generate(), u[g.crossTileID] = !0)
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new go(e, i.symbolInstances, i.bucketInstanceId), !0
          }
          removeBucketCrossTileIDs(e, i) {
            for (const l of i.getCrossTileIDsLists())
              for (const u of l) delete this.usedCrossTileIDs[e][u]
          }
          removeStaleBuckets(e) {
            let i = !1;
            for (const l in this.indexes) {
              const u = this.indexes[l];
              for (const f in u) e[u[f].bucketInstanceId] || (this.removeBucketCrossTileIDs(l, u[f]), delete u[f], i = !0)
            }
            return i
          }
        }
        class Va {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Za, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
          }
          addLayer(e, i, l) {
            let u = this.layerIndexes[e.id];
            u === void 0 && (u = this.layerIndexes[e.id] = new hs);
            let f = !1;
            const g = {};
            u.handleWrapJump(l);
            for (const C of i) {
              const T = C.getBucket(e);
              T && e.id === T.layerIds[0] && (T.bucketInstanceId || (T.bucketInstanceId = ++this.maxBucketInstanceId), u.addBucket(C.tileID, T, this.crossTileIDs) && (f = !0), g[T.bucketInstanceId] = !0)
            }
            return u.removeStaleBuckets(g) && (f = !0), f
          }
          pruneUnusedLayers(e) {
            const i = {};
            e.forEach((l => {
              i[l] = !0
            }));
            for (const l in this.layerIndexes) i[l] || delete this.layerIndexes[l]
          }
        }
        var ft = "void main() {fragColor=vec4(1.0);}";
        const Kt = {
          prelude: er(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
          projectionMercator: er("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
          projectionGlobe: er("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
          background: er(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          backgroundPattern: er(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
          circle: er(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
          clippingMask: er(ft, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          heatmap: er(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
          heatmapTexture: er(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
          collisionBox: er("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
          collisionCircle: er("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
          colorRelief: er(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          debug: er("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
          depth: er(ft, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
          fill: er(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
          fillOutline: er(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillOutlinePattern: er(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillPattern: er(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
          fillExtrusion: er(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
          fillExtrusionPattern: er(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
          hillshadePrepare: er(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
          hillshade: er(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          line: er(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          lineGradient: er(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          linePattern: er(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
          lineSDF: er(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`),
          raster: er(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
          symbolIcon: er(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
          symbolSDF: er(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
          symbolTextAndIcon: er(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
          terrain: er("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
          terrainDepth: er("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
          terrainCoords: er("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
          projectionErrorMeasurement: er("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
          atmosphere: er(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
          sky: er("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
        };

        function er(p, e) {
          const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            l = e.match(/in ([\w]+) ([\w]+)/g),
            u = p.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            f = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            g = f ? f.concat(u) : u,
            C = {};
          return {
            fragmentSource: p = p.replace(i, ((T, M, z, R, D) => (C[D] = !0, M === "define" ? `
#ifndef HAS_UNIFORM_u_${D}
in ${z} ${R} ${D};
#else
uniform ${z} ${R} u_${D};
#endif
` : `
#ifdef HAS_UNIFORM_u_${D}
    ${z} ${R} ${D} = u_${D};
#endif
`))),
            vertexSource: e = e.replace(i, ((T, M, z, R, D) => {
              const N = R === "float" ? "vec2" : "vec4",
                H = D.match(/color/) ? "color" : N;
              return C[D] ? M === "define" ? `
#ifndef HAS_UNIFORM_u_${D}
uniform lowp float u_${D}_t;
in ${z} ${N} a_${D};
out ${z} ${R} ${D};
#else
uniform ${z} ${R} u_${D};
#endif
` : H === "vec4" ? `
#ifndef HAS_UNIFORM_u_${D}
    ${D} = a_${D};
#else
    ${z} ${R} ${D} = u_${D};
#endif
` : `
#ifndef HAS_UNIFORM_u_${D}
    ${D} = unpack_mix_${H}(a_${D}, u_${D}_t);
#else
    ${z} ${R} ${D} = u_${D};
#endif
` : M === "define" ? `
#ifndef HAS_UNIFORM_u_${D}
uniform lowp float u_${D}_t;
in ${z} ${N} a_${D};
#else
uniform ${z} ${R} u_${D};
#endif
` : H === "vec4" ? `
#ifndef HAS_UNIFORM_u_${D}
    ${z} ${R} ${D} = a_${D};
#else
    ${z} ${R} ${D} = u_${D};
#endif
` : `
#ifndef HAS_UNIFORM_u_${D}
    ${z} ${R} ${D} = unpack_mix_${H}(a_${D}, u_${D}_t);
#else
    ${z} ${R} ${D} = u_${D};
#endif
`
            })),
            staticAttributes: l,
            staticUniforms: g
          }
        }
        class Cn {
          constructor(e, i, l) {
            this.vertexBuffer = e, this.indexBuffer = i, this.segments = l
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null
          }
        }
        var Rn = s.aJ([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }]);
        const Qn = "#define PROJECTION_MERCATOR",
          En = "mercator";
        class kr {
          constructor() {
            this._cachedMesh = null
          }
          get name() {
            return "mercator"
          }
          get useSubdivision() {
            return !1
          }
          get shaderVariantName() {
            return En
          }
          get shaderDefine() {
            return Qn
          }
          get shaderPreludeCode() {
            return Kt.projectionMercator
          }
          get vertexShaderPreludeCode() {
            return Kt.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return s.aK.noSubdivision
          }
          get useGlobeControls() {
            return !1
          }
          get transitionState() {
            return 0
          }
          get latitudeErrorCorrectionRadians() {
            return 0
          }
          destroy() {}
          updateGPUdependent(e) {}
          getMeshFromTileID(e, i, l, u, f) {
            if (this._cachedMesh) return this._cachedMesh;
            const g = new s.aL;
            g.emplaceBack(0, 0), g.emplaceBack(s.$, 0), g.emplaceBack(0, s.$), g.emplaceBack(s.$, s.$);
            const C = e.createVertexBuffer(g, Rn.members),
              T = s.aM.simpleSegment(0, 0, 4, 2),
              M = new s.aN;
            M.emplaceBack(1, 0, 2), M.emplaceBack(1, 2, 3);
            const z = e.createIndexBuffer(M);
            return this._cachedMesh = new Cn(C, z, T), this._cachedMesh
          }
          recalculate() {}
          hasTransition() {
            return !1
          }
          setErrorQueryLatitudeDegrees(e) {}
        }
        class Ai {
          constructor(e = 0, i = 0, l = 0, u = 0) {
            if (isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(l) || l < 0 || isNaN(u) || u < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = i, this.left = l, this.right = u
          }
          interpolate(e, i, l) {
            return i.top != null && e.top != null && (this.top = s.C.number(e.top, i.top, l)), i.bottom != null && e.bottom != null && (this.bottom = s.C.number(e.bottom, i.bottom, l)), i.left != null && e.left != null && (this.left = s.C.number(e.left, i.left, l)), i.right != null && e.right != null && (this.right = s.C.number(e.right, i.right, l)), this
          }
          getCenter(e, i) {
            const l = s.ah((this.left + e - this.right) / 2, 0, e),
              u = s.ah((this.top + i - this.bottom) / 2, 0, i);
            return new s.P(l, u)
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
          }
          clone() {
            return new Ai(this.top, this.bottom, this.left, this.right)
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right
            }
          }
        }

        function br(p, e) {
          if (!p.renderWorldCopies || p.lngRange) return;
          const i = e.lng - p.center.lng;
          e.lng += i > 180 ? -360 : i < -180 ? 360 : 0
        }

        function ir(p) {
          return Math.max(0, Math.floor(p))
        }
        class rn {
          constructor(e, i, l, u, f, g) {
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = g === void 0 || !!g, this._minZoom = i || 0, this._maxZoom = l || 22, this._minPitch = u ?? 0, this._maxPitch = f ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new s.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = ir(this._zoom), this._scale = s.af(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Ai, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0
          }
          apply(e, i, l) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = ir(this._zoom), this._scale = s.af(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new Ai(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !l && e.autoCalculateNearFarZ, i && this._constrain(), this._calcMatrices()
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e
          }
          get tileSize() {
            return this._tileSize
          }
          get tileZoom() {
            return this._tileZoom
          }
          get scale() {
            return this._scale
          }
          get width() {
            return this._width
          }
          get height() {
            return this._height
          }
          get bearingInRadians() {
            return this._bearingInRadians
          }
          get lngRange() {
            return this._lngRange
          }
          get latRange() {
            return this._latRange
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits
          }
          get minZoom() {
            return this._minZoom
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
          }
          get maxZoom() {
            return this._maxZoom
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
          }
          get minPitch() {
            return this._minPitch
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)))
          }
          get maxPitch() {
            return this._maxPitch
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)))
          }
          get renderWorldCopies() {
            return this._renderWorldCopies
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e
          }
          get worldSize() {
            return this._tileSize * this._scale
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2))
          }
          get size() {
            return new s.P(this._width, this._height)
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180
          }
          setBearing(e) {
            const i = s.aO(e, -180, 180) * Math.PI / 180;
            var l, u, f, g, C, T, M, z, R;
            this._bearingInRadians !== i && (this._unmodified = !1, this._bearingInRadians = i, this._calcMatrices(), this._rotationMatrix = O(), l = this._rotationMatrix, f = -this._bearingInRadians, g = (u = this._rotationMatrix)[0], C = u[1], T = u[2], M = u[3], z = Math.sin(f), R = Math.cos(f), l[0] = g * R + T * z, l[1] = C * R + M * z, l[2] = g * -z + T * R, l[3] = C * -z + M * R)
          }
          get rotationMatrix() {
            return this._rotationMatrix
          }
          get pitchInRadians() {
            return this._pitchInRadians
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180
          }
          setPitch(e) {
            const i = s.ah(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== i && (this._unmodified = !1, this._pitchInRadians = i, this._calcMatrices())
          }
          get rollInRadians() {
            return this._rollInRadians
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180
          }
          setRoll(e) {
            const i = e / 180 * Math.PI;
            this._rollInRadians !== i && (this._unmodified = !1, this._rollInRadians = i, this._calcMatrices())
          }
          get fovInRadians() {
            return this._fovInRadians
          }
          get fov() {
            return s.aP(this._fovInRadians)
          }
          setFov(e) {
            e = s.ah(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = s.ae(e), this._calcMatrices())
          }
          get zoom() {
            return this._zoom
          }
          setZoom(e) {
            const i = this.getConstrained(this._center, e).zoom;
            this._zoom !== i && (this._unmodified = !1, this._zoom = i, this._tileZoom = Math.max(0, Math.floor(i)), this._scale = s.af(i), this._constrain(), this._calcMatrices())
          }
          get center() {
            return this._center
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices())
          }
          get elevation() {
            return this._elevation
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices())
          }
          get padding() {
            return this._edgeInsets.toJSON()
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices())
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height)
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter
          }
          get unmodified() {
            return this._unmodified
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance
          }
          get nearZ() {
            return this._nearZ
          }
          get farZ() {
            return this._farZ
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ
          }
          overrideNearFarZ(e, i) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = i, this._calcMatrices()
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices()
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e)
          }
          interpolatePadding(e, i, l) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, i, l), this._constrain(), this._calcMatrices()
          }
          resize(e, i, l = !0) {
            this._width = e, this._height = i, l && this._constrain(), this._calcMatrices()
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new At([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-s.ai, s.ai])
          }
          getConstrained(e, i) {
            return this._callbacks.getConstrained(e, i)
          }
          getCameraQueryGeometry(e, i) {
            if (i.length === 1) return [i[0], e];
            {
              const {
                minX: l,
                minY: u,
                maxX: f,
                maxY: g
              } = s.a2.fromPoints(i).extend(e);
              return [new s.P(l, u), new s.P(f, u), new s.P(f, g), new s.P(l, g), new s.P(l, u)]
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified,
              {
                center: i,
                zoom: l
              } = this.getConstrained(this.center, this.zoom);
            this.setCenter(i), this.setZoom(l), this._unmodified = e, this._constraining = !1
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = s.ag(new Float64Array(16));
              s.N(e, e, [this._width / 2, -this._height / 2, 1]), s.M(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = s.ag(new Float64Array(16)), s.N(e, e, [1, -1, 1]), s.M(e, e, [-1, -1, 0]), s.N(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
            }
            this._callbacks.calcMatrices()
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            const f = l !== void 0 ? l : this.bearing,
              g = u = u !== void 0 ? u : this.pitch,
              C = s.a1.fromLngLat(e, i),
              T = -Math.cos(s.ae(g)),
              M = Math.sin(s.ae(g)),
              z = M * Math.sin(s.ae(f)),
              R = -M * Math.cos(s.ae(f));
            let D = this.elevation;
            const N = i - D;
            let H;
            T * N >= 0 || Math.abs(T) < .1 ? (H = 1e4, D = i + H * T) : H = -N / T;
            let ie, ne, se = s.aQ(1, C.y),
              pe = 0;
            do {
              if (pe += 1, pe > 10) break;
              ne = H / se, ie = new s.a1(C.x + z * ne, C.y + R * ne), se = 1 / ie.meterInMercatorCoordinateUnits()
            } while (Math.abs(H - ne * se) > 1e-12);
            return {
              center: ie.toLngLat(),
              elevation: D,
              zoom: s.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / ne / this.tileSize)
            }
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const i = s.aj(1, this.center.lat) * this.worldSize,
              l = this.cameraToCenterDistance / i,
              u = s.a1.fromLngLat(this.center, this.elevation),
              f = Oe(this.center, this.elevation, this.pitch, this.bearing, l);
            this._elevation = e;
            const g = this.calculateCenterFromCameraLngLatAlt(f.toLngLat(), s.aQ(f.z, u.y), this.bearing, this.pitch);
            this._elevation = g.elevation, this._center = g.center, this.setZoom(g.zoom)
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new s.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)))
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
          }
          getCameraLngLat() {
            const e = s.aj(1, this.center.lat) * this.worldSize;
            return Oe(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const i = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / i, e.canonical.y / i, 1 / i / s.$, 1 / i / s.$]
          }
        }
        class sn {
          constructor(e, i) {
            this.min = e, this.max = i, this.center = s.aR([], s.aS([], this.min, this.max), .5)
          }
          quadrant(e) {
            const i = [e % 2 == 0, e < 2],
              l = s.aT(this.min),
              u = s.aT(this.max);
            for (let f = 0; f < i.length; f++) l[f] = i[f] ? this.min[f] : this.center[f], u[f] = i[f] ? this.center[f] : this.max[f];
            return u[2] = this.max[2], new sn(l, u)
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
          }
          intersectsFrustum(e) {
            let i = !0;
            for (let l = 0; l < e.planes.length; l++) {
              const u = this.intersectsPlane(e.planes[l]);
              if (u === 0) return 0;
              u === 1 && (i = !1)
            }
            return i ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
          }
          intersectsPlane(e) {
            let i = e[3],
              l = e[3];
            for (let u = 0; u < 3; u++) e[u] > 0 ? (i += e[u] * this.min[u], l += e[u] * this.max[u]) : (l += e[u] * this.min[u], i += e[u] * this.max[u]);
            return i >= 0 ? 2 : l < 0 ? 0 : 1
          }
        }
        class yn {
          distanceToTile2d(e, i, l, u) {
            const f = u.distanceX([e, i]),
              g = u.distanceY([e, i]);
            return Math.hypot(f, g)
          }
          getWrap(e, i, l) {
            return l
          }
          getTileBoundingVolume(e, i, l, u) {
            var f, g;
            let C = 0,
              T = 0;
            if (u != null && u.terrain) {
              const z = new s.Z(e.z, i, e.z, e.x, e.y),
                R = u.terrain.getMinMaxElevation(z);
              C = (f = R.minElevation) !== null && f !== void 0 ? f : Math.min(0, l), T = (g = R.maxElevation) !== null && g !== void 0 ? g : Math.max(0, l)
            }
            const M = 1 << e.z;
            return new sn([i + e.x / M, e.y / M, C], [i + (e.x + 1) / M, (e.y + 1) / M, T])
          }
          allowVariableZoom(e, i) {
            const l = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height,
              u = s.ah(78.5 - l / 2, 0, 60);
            return !!i.terrain || e.pitch > u
          }
          allowWorldCopies() {
            return !0
          }
          prepareNextFrame() {}
        }
        class cn {
          constructor(e, i, l) {
            this.points = e, this.planes = i, this.aabb = l
          }
          static fromInvProjectionMatrix(e, i = 1, l = 0, u, f) {
            const g = f ? [
                [6, 5, 4],
                [0, 1, 2],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ] : [
                [0, 1, 2],
                [6, 5, 4],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ],
              C = Math.pow(2, l),
              T = [
                [-1, 1, -1, 1],
                [1, 1, -1, 1],
                [1, -1, -1, 1],
                [-1, -1, -1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, -1, 1, 1],
                [-1, -1, 1, 1]
              ].map((D => (function(N, H, ie, ne) {
                const se = s.aw([], N, H),
                  pe = 1 / se[3] / ie * ne;
                return s.aY(se, se, [pe, pe, 1 / se[3], pe])
              })(D, e, i, C)));
            u && (function(D, N, H, ie) {
              const ne = ie ? 4 : 0,
                se = ie ? 0 : 4;
              let pe = 0;
              const ye = [],
                ge = [];
              for (let ve = 0; ve < 4; ve++) {
                const Ne = s.aU([], D[ve + se], D[ve + ne]),
                  st = s.aZ(Ne);
                s.aR(Ne, Ne, 1 / st), ye.push(st), ge.push(Ne)
              }
              for (let ve = 0; ve < 4; ve++) {
                const Ne = s.a_(D[ve + ne], ge[ve], H);
                pe = Ne !== null && Ne >= 0 ? Math.max(pe, Ne) : Math.max(pe, ye[ve])
              }
              const Te = (function(ve, Ne) {
                  const st = s.aU([], ve[Ne[0]], ve[Ne[1]]),
                    Xe = s.aU([], ve[Ne[2]], ve[Ne[1]]),
                    Qe = [0, 0, 0, 0];
                  return s.aV(Qe, s.aW([], st, Xe)), Qe[3] = -s.aX(Qe, ve[Ne[0]]), Qe
                })(D, N),
                Le = (function(ve, Ne) {
                  const st = s.a$(ve),
                    Xe = s.b0([], ve, 1 / st),
                    Qe = s.aU([], Ne, s.aR([], Xe, s.aX(Ne, Xe))),
                    at = s.a$(Qe);
                  if (at > 0) {
                    const Ht = Math.sqrt(1 - Xe[3] * Xe[3]),
                      Xt = s.aR([], Xe, -Xe[3]),
                      kt = s.aS([], Xt, s.aR([], Qe, Ht / at));
                    return s.b1(Ne, kt)
                  }
                  return null
                })(H, Te);
              if (Le !== null) {
                const ve = Le / s.aX(ge[0], Te);
                pe = Math.min(pe, ve)
              }
              for (let ve = 0; ve < 4; ve++) {
                const Ne = Math.min(pe, ye[ve]);
                D[ve + se] = [D[ve + ne][0] + ge[ve][0] * Ne, D[ve + ne][1] + ge[ve][1] * Ne, D[ve + ne][2] + ge[ve][2] * Ne, 1]
              }
            })(T, g[0], u, f);
            const M = g.map((D => {
                const N = s.aU([], T[D[0]], T[D[1]]),
                  H = s.aU([], T[D[2]], T[D[1]]),
                  ie = s.aV([], s.aW([], N, H)),
                  ne = -s.aX(ie, T[D[1]]);
                return ie.concat(ne)
              })),
              z = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
              R = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const D of T)
              for (let N = 0; N < 3; N++) z[N] = Math.min(z[N], D[N]), R[N] = Math.max(R[N], D[N]);
            return new cn(T, M, new sn(z, R))
          }
        }
        class Jr {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, i, l) {
            return this._helper.interpolatePadding(e, i, l)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, i, l = !0) {
            this._helper.resize(e, i, l)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e, i) {}
          constructor(e, i, l, u, f) {
            this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this._helper = new rn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              getConstrained: (g, C) => this.getConstrained(g, C)
            }, e, i, l, u, f), this._coveringTilesDetailsProvider = new yn
          }
          clone() {
            const e = new Jr;
            return e.apply(this), e
          }
          apply(e, i, l) {
            this._helper.apply(e, i, l)
          }
          get cameraPosition() {
            return this._cameraPosition
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix
          }
          get mercatorMatrix() {
            return this._mercatorMatrix
          }
          getVisibleUnwrappedCoordinates(e) {
            const i = [new s.b2(0, e)];
            if (this._helper._renderWorldCopies) {
              const l = this.screenPointToMercatorCoordinate(new s.P(0, 0)),
                u = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, 0)),
                f = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, this._helper._height)),
                g = this.screenPointToMercatorCoordinate(new s.P(0, this._helper._height)),
                C = Math.floor(Math.min(l.x, u.x, f.x, g.x)),
                T = Math.floor(Math.max(l.x, u.x, f.x, g.x)),
                M = 1;
              for (let z = C - M; z <= T + M; z++) z !== 0 && i.push(new s.b2(z, e))
            }
            return i
          }
          getCameraFrustum() {
            return cn.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
          }
          getClippingPlane() {
            return null
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            const i = this.screenPointToLocation(this.centerPoint, e),
              l = e ? e.getElevationForLngLatZoom(i, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(l)
          }
          setLocationAtPoint(e, i) {
            const l = s.aj(this.elevation, this.center.lat),
              u = this.screenPointToMercatorCoordinateAtZ(i, l),
              f = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, l),
              g = s.a1.fromLngLat(e),
              C = new s.a1(g.x - (u.x - f.x), g.y - (u.y - f.y));
            this.setCenter(C == null ? void 0 : C.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
          }
          locationToScreenPoint(e, i) {
            return i ? this.coordinatePoint(s.a1.fromLngLat(e), i.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(s.a1.fromLngLat(e))
          }
          screenPointToLocation(e, i) {
            var l;
            return (l = this.screenPointToMercatorCoordinate(e, i)) === null || l === void 0 ? void 0 : l.toLngLat()
          }
          screenPointToMercatorCoordinate(e, i) {
            if (i) {
              const l = i.pointCoordinate(e);
              if (l != null) return l
            }
            return this.screenPointToMercatorCoordinateAtZ(e)
          }
          screenPointToMercatorCoordinateAtZ(e, i) {
            const l = i || 0,
              u = [e.x, e.y, 0, 1],
              f = [e.x, e.y, 1, 1];
            s.aw(u, u, this._pixelMatrixInverse), s.aw(f, f, this._pixelMatrixInverse);
            const g = u[3],
              C = f[3],
              T = u[1] / g,
              M = f[1] / C,
              z = u[2] / g,
              R = f[2] / C,
              D = z === R ? 0 : (l - z) / (R - z);
            return new s.a1(s.C.number(u[0] / g, f[0] / C, D) / this.worldSize, s.C.number(T, M, D) / this.worldSize, l)
          }
          coordinatePoint(e, i = 0, l = this._pixelMatrix) {
            const u = [e.x * this.worldSize, e.y * this.worldSize, i, 1];
            return s.aw(u, u, l), new s.P(u[0] / u[3], u[1] / u[3])
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - me(this));
            return new At().extend(this.screenPointToLocation(new s.P(0, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new s.P(0, this._helper._height)))
          }
          isPointOnMapSurface(e, i) {
            return i ? i.pointCoordinate(e) != null : e.y > this.height / 2 - me(this)
          }
          calculatePosMatrix(e, i = !1, l) {
            var u;
            const f = (u = e.key) !== null && u !== void 0 ? u : s.b3(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y),
              g = i ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (g.has(f)) {
              const M = g.get(f);
              return l ? M.f32 : M.f64
            }
            const C = Se(e, this.worldSize);
            s.O(C, i ? this._alignedProjMatrix : this._viewProjMatrix, C);
            const T = {
              f64: C,
              f32: new Float32Array(C)
            };
            return g.set(f, T), l ? T.f32 : T.f64
          }
          calculateFogMatrix(e) {
            const i = e.key,
              l = this._fogMatrixCacheF32;
            if (l.has(i)) return l.get(i);
            const u = Se(e, this.worldSize);
            return s.O(u, this._fogMatrix, u), l.set(i, new Float32Array(u)), l.get(i)
          }
          getConstrained(e, i) {
            i = s.ah(+i, this.minZoom, this.maxZoom);
            const l = {
              center: new s.S(e.lng, e.lat),
              zoom: i
            };
            let u = this._helper._lngRange;
            if (!this._helper._renderWorldCopies && u === null) {
              const ye = 179.9999999999;
              u = [-ye, ye]
            }
            const f = this.tileSize * s.af(l.zoom);
            let g = 0,
              C = f,
              T = 0,
              M = f,
              z = 0,
              R = 0;
            const {
              x: D,
              y: N
            } = this.size;
            if (this._helper._latRange) {
              const ye = this._helper._latRange;
              g = s.U(ye[1]) * f, C = s.U(ye[0]) * f, C - g < N && (z = N / (C - g))
            }
            u && (T = s.aO(s.V(u[0]) * f, 0, f), M = s.aO(s.V(u[1]) * f, 0, f), M < T && (M += f), M - T < D && (R = D / (M - T)));
            const {
              x: H,
              y: ie
            } = Y(f, e);
            let ne, se;
            const pe = Math.max(R || 0, z || 0);
            if (pe) {
              const ye = new s.P(R ? (M + T) / 2 : H, z ? (C + g) / 2 : ie);
              return l.center = oe(f, ye).wrap(), l.zoom += s.ak(pe), l
            }
            if (this._helper._latRange) {
              const ye = N / 2;
              ie - ye < g && (se = g + ye), ie + ye > C && (se = C - ye)
            }
            if (u) {
              const ye = (T + M) / 2;
              let ge = H;
              this._helper._renderWorldCopies && (ge = s.aO(H, ye - f / 2, ye + f / 2));
              const Te = D / 2;
              ge - Te < T && (ne = T + Te), ge + Te > M && (ne = M - Te)
            }
            if (ne !== void 0 || se !== void 0) {
              const ye = new s.P(ne ?? H, se ?? ie);
              l.center = oe(f, ye).wrap()
            }
            return l
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, l, u)
          }
          _calculateNearFarZIfNeeded(e, i, l) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const u = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100),
              f = e - u * this._helper._pixelPerMeter / Math.cos(i),
              g = u < 0 ? f : e,
              C = Math.PI / 2 + this.pitchInRadians,
              T = s.ae(this.fov) * (Math.abs(Math.cos(s.ae(this.roll))) * this.height + Math.abs(Math.sin(s.ae(this.roll))) * this.width) / this.height * (.5 + l.y / this.height),
              M = Math.sin(T) * g / Math.sin(s.ah(Math.PI - C - T, .01, Math.PI - .01)),
              z = me(this),
              R = Math.atan(z / this._helper.cameraToCenterDistance),
              D = s.ae(.75),
              N = R > D ? 2 * R * (.5 + l.y / (2 * z)) : D,
              H = Math.sin(N) * g / Math.sin(s.ah(Math.PI - C - N, .01, Math.PI - .01)),
              ie = Math.min(M, H);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i) * ie + g), this._helper._nearZ = this._helper._height / 50
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset,
              i = Y(this.worldSize, this.center),
              l = i.x,
              u = i.y;
            this._helper._pixelPerMeter = s.aj(1, this.center.lat) * this.worldSize;
            const f = s.ae(Math.min(this.pitch, U)),
              g = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(f));
            let C;
            this._calculateNearFarZIfNeeded(g, f, e), C = new Float64Array(16), s.b4(C, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), s.aq(this._invProjMatrix, C), C[8] = 2 * -e.x / this._helper._width, C[9] = 2 * e.y / this._helper._height, this._projectionMatrix = s.b5(C), s.N(C, C, [1, -1, 1]), s.M(C, C, [0, 0, -this._helper.cameraToCenterDistance]), s.b6(C, C, -this.rollInRadians), s.b7(C, C, this.pitchInRadians), s.b6(C, C, -this.bearingInRadians), s.M(C, C, [-l, -u, 0]), this._mercatorMatrix = s.N([], C, [this.worldSize, this.worldSize, this.worldSize]), s.N(C, C, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = s.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, C), s.M(C, C, [0, 0, -this.elevation]), this._viewProjMatrix = C, this._invViewProjMatrix = s.aq([], C);
            const T = [0, 0, -1, 1];
            s.aw(T, T, this._invViewProjMatrix), this._cameraPosition = [T[0] / T[3], T[1] / T[3], T[2] / T[3]], this._fogMatrix = new Float64Array(16), s.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, g, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, s.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]), s.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), s.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), s.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), s.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), s.M(this._fogMatrix, this._fogMatrix, [-l, -u, 0]), s.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), s.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = s.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, C);
            const M = this._helper._width % 2 / 2,
              z = this._helper._height % 2 / 2,
              R = Math.cos(this.bearingInRadians),
              D = Math.sin(-this.bearingInRadians),
              N = l - Math.round(l) + R * M + D * z,
              H = u - Math.round(u) + R * z + D * M,
              ie = new Float64Array(C);
            if (s.M(ie, ie, [N > .5 ? N - 1 : N, H > .5 ? H - 1 : H, 0]), this._alignedProjMatrix = ie, C = s.aq(new Float64Array(16), this._pixelMatrix), !C) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = C, this._clearMatrixCaches()
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear()
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new s.P(0, 0)),
              i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return s.aw(i, i, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            const e = s.aj(1, this.center.lat) * this.worldSize;
            return Oe(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
          }
          lngLatToCameraDepth(e, i) {
            const l = s.a1.fromLngLat(e),
              u = [l.x * this.worldSize, l.y * this.worldSize, i, 1];
            return s.aw(u, u, this._viewProjMatrix), u[2] / u[3]
          }
          getProjectionData(e) {
            const {
              overscaledTileID: i,
              aligned: l,
              applyTerrainMatrix: u
            } = e, f = this._helper.getMercatorTileCoordinates(i), g = i ? this.calculatePosMatrix(i, l, !0) : null;
            let C;
            return C = i && i.terrainRttPosMatrix32f && u ? i.terrainRttPosMatrix32f : g || s.b8(), {
              mainMatrix: C,
              tileMercatorCoords: f,
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: C
            }
          }
          isLocationOccluded(e) {
            return !1
          }
          getPixelScale() {
            return 1
          }
          getCircleRadiusCorrection() {
            return 1
          }
          getPitchedTextCorrection(e, i, l) {
            return 1
          }
          transformLightDirection(e) {
            return s.aT(e)
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.")
          }
          projectTileCoordinates(e, i, l, u) {
            const f = this.calculatePosMatrix(l);
            let g;
            u ? (g = [e, i, u(e, i), 1], s.aw(g, g, f)) : (g = [e, i, 0, 1], hn(g, g, f));
            const C = g[3];
            return {
              point: new s.P(g[0] / C, g[1] / C),
              signedDistanceFromCamera: C,
              isOccluded: !1
            }
          }
          populateCache(e) {
            for (const i of e) this.calculatePosMatrix(i)
          }
          getMatrixForModel(e, i) {
            const l = s.a1.fromLngLat(e, i),
              u = l.meterInMercatorCoordinateUnits(),
              f = s.b9();
            return s.M(f, f, [l.x, l.y, l.z]), s.b6(f, f, Math.PI), s.b7(f, f, Math.PI / 2), s.N(f, f, [-u, u, u]), f
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = new s.Z(0, 0, 0, 0, 0),
              l = this.getProjectionData({
                overscaledTileID: i,
                applyGlobeMatrix: e
              }),
              u = Se(i, this.worldSize);
            s.O(u, this._viewProjMatrix, u), l.tileMercatorCoords = [0, 0, 1, 1];
            const f = [s.$, s.$, this.worldSize / this._helper.pixelsPerMeter],
              g = s.ba();
            return s.N(g, u, f), l.fallbackMatrix = g, l.mainMatrix = g, l
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e)
          }
        }

        function Jn() {
          s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
        }

        function Bn(p) {
          if (p.useSlerp)
            if (p.k < 1) {
              const e = s.bb(p.startEulerAngles.roll, p.startEulerAngles.pitch, p.startEulerAngles.bearing),
                i = s.bb(p.endEulerAngles.roll, p.endEulerAngles.pitch, p.endEulerAngles.bearing),
                l = new Float64Array(4);
              s.bc(l, e, i, p.k);
              const u = s.bd(l);
              p.tr.setRoll(u.roll), p.tr.setPitch(u.pitch), p.tr.setBearing(u.bearing)
            } else p.tr.setRoll(p.endEulerAngles.roll), p.tr.setPitch(p.endEulerAngles.pitch), p.tr.setBearing(p.endEulerAngles.bearing);
          else p.tr.setRoll(s.C.number(p.startEulerAngles.roll, p.endEulerAngles.roll, p.k)), p.tr.setPitch(s.C.number(p.startEulerAngles.pitch, p.endEulerAngles.pitch, p.k)), p.tr.setBearing(s.C.number(p.startEulerAngles.bearing, p.endEulerAngles.bearing, p.k))
        }

        function xn(p, e, i, l, u) {
          const f = u.padding,
            g = Y(u.worldSize, i.getNorthWest()),
            C = Y(u.worldSize, i.getNorthEast()),
            T = Y(u.worldSize, i.getSouthEast()),
            M = Y(u.worldSize, i.getSouthWest()),
            z = s.ae(-l),
            R = g.rotate(z),
            D = C.rotate(z),
            N = T.rotate(z),
            H = M.rotate(z),
            ie = new s.P(Math.max(R.x, D.x, H.x, N.x), Math.max(R.y, D.y, H.y, N.y)),
            ne = new s.P(Math.min(R.x, D.x, H.x, N.x), Math.min(R.y, D.y, H.y, N.y)),
            se = ie.sub(ne),
            pe = (u.width - (f.left + f.right + e.left + e.right)) / se.x,
            ye = (u.height - (f.top + f.bottom + e.top + e.bottom)) / se.y;
          if (ye < 0 || pe < 0) return void Jn();
          const ge = Math.min(s.ak(u.scale * Math.min(pe, ye)), p.maxZoom),
            Te = s.P.convert(p.offset),
            Le = new s.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(s.ae(l)),
            ve = Te.add(Le).mult(u.scale / s.af(ge));
          return {
            center: oe(u.worldSize, g.add(T).div(2).sub(ve)),
            zoom: ge,
            bearing: l
          }
        }
        class pn {
          get useGlobeControls() {
            return !1
          }
          handlePanInertia(e, i) {
            return {
              easingOffset: e,
              easingCenter: i.center
            }
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta), e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta)
          }
          handleMapControlsPan(e, i, l) {
            e.around.distSqr(i.centerPoint) < .01 || i.setLocationAtPoint(l, e.around)
          }
          cameraForBoxAndBearing(e, i, l, u, f) {
            return xn(e, i, l, u, f)
          }
          handleJumpToCenterZoom(e, i) {
            e.zoom !== (i.zoom !== void 0 ? +i.zoom : e.zoom) && e.setZoom(+i.zoom), i.center !== void 0 && e.setCenter(s.S.convert(i.center))
          }
          handleEaseTo(e, i) {
            const l = e.zoom,
              u = e.padding,
              f = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              g = {
                roll: i.roll === void 0 ? e.roll : i.roll,
                pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                bearing: i.bearing === void 0 ? e.bearing : i.bearing
              },
              C = i.zoom !== void 0,
              T = !e.isPaddingEqual(i.padding);
            let M = !1;
            const z = C ? +i.zoom : e.zoom;
            let R = e.centerPoint.add(i.offsetAsPoint);
            const D = e.screenPointToLocation(R),
              {
                center: N,
                zoom: H
              } = e.getConstrained(s.S.convert(i.center || D), z ?? l);
            br(e, N);
            const ie = Y(e.worldSize, D),
              ne = Y(e.worldSize, N).sub(ie),
              se = s.af(H - l);
            return M = H !== l, {
              easeFunc: pe => {
                if (M && e.setZoom(s.C.number(l, H, pe)), s.be(f, g) || Bn({
                    startEulerAngles: f,
                    endEulerAngles: g,
                    tr: e,
                    k: pe,
                    useSlerp: f.roll != g.roll
                  }), T && (e.interpolatePadding(u, i.padding, pe), R = e.centerPoint.add(i.offsetAsPoint)), i.around) e.setLocationAtPoint(i.around, i.aroundPoint);
                else {
                  const ye = s.af(e.zoom - l),
                    ge = H > l ? Math.min(2, se) : Math.max(.5, se),
                    Te = Math.pow(ge, 1 - pe),
                    Le = oe(e.worldSize, ie.add(ne.mult(pe * Te)).mult(ye));
                  e.setLocationAtPoint(e.renderWorldCopies ? Le.wrap() : Le, R)
                }
              },
              isZooming: M,
              elevationCenter: N
            }
          }
          handleFlyTo(e, i) {
            const l = i.zoom !== void 0,
              u = e.zoom,
              f = e.getConstrained(s.S.convert(i.center || i.locationAtOffset), l ? +i.zoom : u),
              g = f.center,
              C = f.zoom;
            br(e, g);
            const T = Y(e.worldSize, i.locationAtOffset),
              M = Y(e.worldSize, g).sub(T),
              z = M.mag(),
              R = s.af(C - u);
            let D;
            if (i.minZoom !== void 0) {
              const N = Math.min(+i.minZoom, u, C),
                H = e.getConstrained(g, N).zoom;
              D = s.af(H - u)
            }
            return {
              easeFunc: (N, H, ie, ne) => {
                e.setZoom(N === 1 ? C : u + s.ak(H));
                const se = N === 1 ? g : oe(e.worldSize, T.add(M.mult(ie)).mult(H));
                e.setLocationAtPoint(e.renderWorldCopies ? se.wrap() : se, ne)
              },
              scaleOfZoom: R,
              targetCenter: g,
              scaleOfMinZoom: D,
              pixelPathLength: z
            }
          }
        }
        class Xr {
          constructor(e, i, l) {
            this.blendFunction = e, this.blendColor = i, this.mask = l
          }
        }
        Xr.Replace = [1, 0], Xr.disabled = new Xr(Xr.Replace, s.bf.transparent, [!1, !1, !1, !1]), Xr.unblended = new Xr(Xr.Replace, s.bf.transparent, [!0, !0, !0, !0]), Xr.alphaBlended = new Xr([1, 771], s.bf.transparent, [!0, !0, !0, !0]);
        const On = 2305;
        class mr {
          constructor(e, i, l) {
            this.enable = e, this.mode = i, this.frontFace = l
          }
        }
        mr.disabled = new mr(!1, 1029, On), mr.backCCW = new mr(!0, 1029, On), mr.frontCCW = new mr(!0, 1028, On);
        class _r {
          constructor(e, i, l) {
            this.func = e, this.mask = i, this.range = l
          }
        }
        _r.ReadOnly = !1, _r.ReadWrite = !0, _r.disabled = new _r(519, _r.ReadOnly, [0, 1]);
        const Vn = 7680;
        class Wr {
          constructor(e, i, l, u, f, g) {
            this.test = e, this.ref = i, this.mask = l, this.fail = u, this.depthFail = f, this.pass = g
          }
        }
        Wr.disabled = new Wr({
          func: 519,
          mask: 0
        }, 0, 0, Vn, Vn, Vn);
        const jn = new WeakMap;

        function qn(p) {
          var e;
          if (jn.has(p)) return jn.get(p);
          {
            const i = (e = p.getParameter(p.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return jn.set(p, i), i
          }
        }
        class oi {
          get awaitingQuery() {
            return !!this._readbackQueue
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const i = e.context,
              l = i.gl;
            this._texFormat = l.RGBA, this._texType = l.UNSIGNED_BYTE;
            const u = new s.aL;
            u.emplaceBack(-1, -1), u.emplaceBack(2, -1), u.emplaceBack(-1, 2);
            const f = new s.aN;
            f.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Cn(i.createVertexBuffer(u, Rn.members), i.createIndexBuffer(f), s.aM.simpleSegment(0, 0, u.length, f.length)), this._resultBuffer = new Uint8Array(4), i.activeTexture.set(l.TEXTURE1);
            const g = l.createTexture();
            l.bindTexture(l.TEXTURE_2D, g), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, l.NEAREST), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, l.NEAREST), l.texImage2D(l.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(g), qn(l) && (this._pbo = l.createBuffer(), l.bindBuffer(l.PIXEL_PACK_BUFFER, this._pbo), l.bufferData(l.PIXEL_PACK_BUFFER, 4, l.STREAM_READ), l.bindBuffer(l.PIXEL_PACK_BUFFER, null))
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null
          }
          updateErrorLoop(e, i) {
            const l = this._updateCount;
            return this._readbackQueue ? l >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : l >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, i), this._updateCount++, this._measuredError
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context,
              i = e.gl;
            e.activeTexture.set(i.TEXTURE1), i.bindTexture(i.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer)
          }
          _renderErrorTexture(e, i) {
            const l = this._cachedRenderContext.context,
              u = l.gl;
            if (this._bindFramebuffer(), l.viewport.set([0, 0, this._texWidth, this._texHeight]), l.clear({
                color: s.bf.transparent
              }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(l, u.TRIANGLES, _r.disabled, Wr.disabled, Xr.unblended, mr.disabled, ((f, g) => ({
                u_input: f,
                u_output_expected: g
              }))(e, i), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && qn(u)) {
              u.bindBuffer(u.PIXEL_PACK_BUFFER, this._pbo), u.readBuffer(u.COLOR_ATTACHMENT0), u.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), u.bindBuffer(u.PIXEL_PACK_BUFFER, null);
              const f = u.fenceSync(u.SYNC_GPU_COMMANDS_COMPLETE, 0);
              u.flush(), this._readbackQueue = {
                frameNumberIssued: this._updateCount,
                sync: f
              }
            } else this._readbackQueue = {
              frameNumberIssued: this._updateCount,
              sync: null
            }
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && qn(e)) {
              const i = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (i === e.WAIT_FAILED) return s.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void(this._lastReadbackFrame = this._updateCount);
              if (i === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = oi._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount
          }
          static _parseRGBA8float(e) {
            let i = 0;
            return i += e[0] / 256, i += e[1] / 65536, i += e[2] / 16777216, e[3] < 127 && (i = -i), i / 128
          }
        }
        const vo = s.$ / 128;

        function Bo(p, e) {
          const i = p.granularity !== void 0 ? Math.max(p.granularity, 1) : 1,
            l = i + (p.generateBorders ? 2 : 0),
            u = i + (p.extendToNorthPole || p.generateBorders ? 1 : 0) + (p.extendToSouthPole || p.generateBorders ? 1 : 0),
            f = l + 1,
            g = u + 1,
            C = p.generateBorders ? -1 : 0,
            T = p.generateBorders || p.extendToNorthPole ? -1 : 0,
            M = i + (p.generateBorders ? 1 : 0),
            z = i + (p.generateBorders || p.extendToSouthPole ? 1 : 0),
            R = f * g,
            D = l * u * 6,
            N = f * g > 65536;
          if (N && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const H = N || e === "32bit",
            ie = new Int16Array(2 * R);
          let ne = 0;
          for (let ye = T; ye <= z; ye++)
            for (let ge = C; ge <= M; ge++) {
              let Te = ge / i * s.$;
              ge === -1 && (Te = -vo), ge === i + 1 && (Te = s.$ + vo);
              let Le = ye / i * s.$;
              ye === -1 && (Le = p.extendToNorthPole ? s.bh : -vo), ye === i + 1 && (Le = p.extendToSouthPole ? s.bi : s.$ + vo), ie[ne++] = Te, ie[ne++] = Le
            }
          const se = H ? new Uint32Array(D) : new Uint16Array(D);
          let pe = 0;
          for (let ye = 0; ye < u; ye++)
            for (let ge = 0; ge < l; ge++) {
              const Te = ge + 1 + ye * f,
                Le = ge + (ye + 1) * f,
                ve = ge + 1 + (ye + 1) * f;
              se[pe++] = ge + ye * f, se[pe++] = Le, se[pe++] = Te, se[pe++] = Te, se[pe++] = Le, se[pe++] = ve
            }
          return {
            vertices: ie.buffer.slice(0),
            indices: se.buffer.slice(0),
            uses32bitIndices: H
          }
        }
        const Qa = new s.aK({
          fill: new s.bj(128, 2),
          line: new s.bj(512, 0),
          tile: new s.bj(128, 32),
          stencil: new s.bj(128, 1),
          circle: 3
        });
        class eo {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3
          }
          get name() {
            return "vertical-perspective"
          }
          get transitionState() {
            return 1
          }
          get useSubdivision() {
            return !0
          }
          get shaderVariantName() {
            return "globe"
          }
          get shaderDefine() {
            return "#define GLOBE"
          }
          get shaderPreludeCode() {
            return Kt.projectionGlobe
          }
          get vertexShaderPreludeCode() {
            return Kt.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return Qa
          }
          get useGlobeControls() {
            return !0
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy()
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new oi(e));
            const i = s.U(this._errorQueryLatitudeDegrees),
              l = 2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) - .5 * Math.PI,
              u = this._errorMeasurement.updateErrorLoop(i, l),
              f = Q.now();
            u !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = u, this._errorMeasurementLastChangeTime = f);
            const g = Math.min(Math.max((f - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
            this._errorCorrectionUsable = s.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, s.bl(g))
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders?"b":""}${e.extendToNorthPole?"n":""}${e.extendToSouthPole?"s":""}`
          }
          getMeshFromTileID(e, i, l, u, f) {
            const g = (f === "stencil" ? Qa.stencil : Qa.tile).getGranularityForZoomLevel(i.z);
            return this._getMesh(e, {
              granularity: g,
              generateBorders: l,
              extendToNorthPole: i.y === 0 && u,
              extendToSouthPole: i.y === (1 << i.z) - 1 && u
            })
          }
          _getMesh(e, i) {
            const l = this._getMeshKey(i);
            if (l in this._tileMeshCache) return this._tileMeshCache[l];
            const u = (function(f, g) {
              const C = Bo(g, "16bit"),
                T = s.aL.deserialize({
                  arrayBuffer: C.vertices,
                  length: C.vertices.byteLength / 2 / 2
                }),
                M = s.aN.deserialize({
                  arrayBuffer: C.indices,
                  length: C.indices.byteLength / 2 / 3
                });
              return new Cn(f.createVertexBuffer(T, Rn.members), f.createIndexBuffer(M), s.aM.simpleSegment(0, 0, T.length, M.length))
            })(e, i);
            return this._tileMeshCache[l] = u, u
          }
          recalculate(e) {}
          hasTransition() {
            const e = Q.now();
            let i = !1;
            return i = i || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, i = i || this._errorMeasurement && this._errorMeasurement.awaitingQuery, i
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e
          }
        }
        const yo = new s.r({
          type: new s.D(s.v.projection.type)
        });
        class Fo extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.t(yo), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.F(0)), this._mercatorProjection = new kr, this._verticalPerspectiveProjection = new eo
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof s.bm) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition
            }
            return 1
          }
          get useGlobeRendering() {
            return this.transitionState > 0
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
          }
          get name() {
            return "globe"
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity
          }
          get useGlobeControls() {
            return this.transitionState > 0
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy()
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e)
          }
          getMeshFromTileID(e, i, l, u, f) {
            return this.currentProjection.getMeshFromTileID(e, i, l, u, f)
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator")
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
          }
        }

        function ds(p) {
          const e = to(p.worldSize, p.center.lat);
          return 2 * Math.PI * e
        }

        function Gi(p, e, i, l, u) {
          const f = 1 / (1 << u),
            g = e / s.$ * f + l * f,
            C = s.bo((p / s.$ * f + i * f) * Math.PI * 2 + Math.PI, 2 * Math.PI),
            T = 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - .5 * Math.PI,
            M = Math.cos(T),
            z = new Float64Array(3);
          return z[0] = Math.sin(C) * M, z[1] = Math.sin(T), z[2] = Math.cos(C) * M, z
        }

        function si(p) {
          return (function(e, i) {
            const l = Math.cos(i),
              u = new Float64Array(3);
            return u[0] = Math.sin(e) * l, u[1] = Math.sin(i), u[2] = Math.cos(e) * l, u
          })(p.lng * Math.PI / 180, p.lat * Math.PI / 180)
        }

        function to(p, e) {
          return p / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
        }

        function qa(p) {
          const e = Math.asin(p[1]) / Math.PI * 180,
            i = Math.sqrt(p[0] * p[0] + p[2] * p[2]);
          if (i > 1e-6) {
            const l = p[0] / i,
              u = Math.acos(p[2] / i),
              f = (l > 0 ? u : -u) / Math.PI * 180;
            return new s.S(s.aO(f, -180, 180), e)
          }
          return new s.S(0, e)
        }

        function ro(p) {
          return Math.cos(p * Math.PI / 180)
        }

        function Fn(p, e) {
          const i = ro(p),
            l = ro(e);
          return s.ak(l / i)
        }

        function ps(p, e) {
          const i = p.rotate(e.bearingInRadians),
            l = e.zoom + Fn(e.center.lat, 0),
            u = s.bk(1 / ro(e.center.lat), 1 / ro(Math.min(Math.abs(e.center.lat), 60)), s.bn(l, 7, 3, 0, 1)),
            f = 360 / ds({
              worldSize: e.worldSize,
              center: {
                lat: e.center.lat
              }
            });
          return new s.S(e.center.lng - i.x * f * u, s.ah(e.center.lat + i.y * f, -s.ai, s.ai))
        }

        function Oo(p) {
          const e = .5 * p,
            i = Math.sin(e),
            l = Math.cos(e);
          return Math.log(i + l) - Math.log(l - i)
        }

        function Oc(p, e, i, l) {
          const u = p.lat + i * l;
          if (Math.abs(i) > 1) {
            const f = (Math.sign(p.lat + i) !== Math.sign(p.lat) ? -Math.abs(p.lat) : Math.abs(p.lat)) * Math.PI / 180,
              g = Math.abs(p.lat + i) * Math.PI / 180,
              C = Oo(f + l * (g - f)),
              T = Oo(f),
              M = Oo(g);
            return new s.S(p.lng + e * ((C - T) / (M - T)), u)
          }
          return new s.S(p.lng + e * l, u)
        }
        class Op {
          constructor(e) {
            this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._boundingVolumeFactory = e
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1
          }
          getTileBoundingVolume(e, i, l, u) {
            const f = `${e.z}_${e.x}_${e.y}_${u!=null&&u.terrain?"t":""}`,
              g = this._cache.get(f);
            if (g) return g;
            const C = this._cachePrevious.get(f);
            if (C) return this._cache.set(f, C), C;
            const T = this._boundingVolumeFactory(e, i, l, u);
            return this._cache.set(f, T), this._hadAnyChanges = !0, T
          }
        }
        class fs {
          constructor(e, i, l, u) {
            this.min = l, this.max = u, this.points = e, this.planes = i
          }
          static fromAabb(e, i) {
            const l = [];
            for (let u = 0; u < 8; u++) l.push([1 & ~u ? e[0] : i[0], (u >> 1 & 1) == 1 ? i[1] : e[1], (u >> 2 & 1) == 1 ? i[2] : e[2]]);
            return new fs(l, [
              [-1, 0, 0, i[0]],
              [1, 0, 0, -e[0]],
              [0, -1, 0, i[1]],
              [0, 1, 0, -e[1]],
              [0, 0, -1, i[2]],
              [0, 0, 1, -e[2]]
            ], e, i)
          }
          static fromCenterSizeAngles(e, i, l) {
            const u = s.br([], l[0], l[1], l[2]),
              f = s.bs([], [i[0], 0, 0], u),
              g = s.bs([], [0, i[1], 0], u),
              C = s.bs([], [0, 0, i[2]], u),
              T = [...e],
              M = [...e];
            for (let R = 0; R < 8; R++)
              for (let D = 0; D < 3; D++) {
                const N = e[D] + f[D] * (1 & ~R ? -1 : 1) + g[D] * ((R >> 1 & 1) == 1 ? 1 : -1) + C[D] * ((R >> 2 & 1) == 1 ? 1 : -1);
                T[D] = Math.min(T[D], N), M[D] = Math.max(M[D], N)
              }
            const z = [];
            for (let R = 0; R < 8; R++) {
              const D = [...e];
              s.aS(D, D, s.aR([], f, 1 & ~R ? -1 : 1)), s.aS(D, D, s.aR([], g, (R >> 1 & 1) == 1 ? 1 : -1)), s.aS(D, D, s.aR([], C, (R >> 2 & 1) == 1 ? 1 : -1)), z.push(D)
            }
            return new fs(z, [
              [...f, -s.aX(f, z[0])],
              [...g, -s.aX(g, z[0])],
              [...C, -s.aX(C, z[0])],
              [-f[0], -f[1], -f[2], -s.aX(f, z[7])],
              [-g[0], -g[1], -g[2], -s.aX(g, z[7])],
              [-C[0], -C[1], -C[2], -s.aX(C, z[7])]
            ], T, M)
          }
          intersectsFrustum(e) {
            let i = !0;
            const l = this.points.length,
              u = this.planes.length,
              f = e.planes.length,
              g = e.points.length;
            for (let C = 0; C < f; C++) {
              const T = e.planes[C];
              let M = 0;
              for (let z = 0; z < l; z++) {
                const R = this.points[z];
                T[0] * R[0] + T[1] * R[1] + T[2] * R[2] + T[3] >= 0 && M++
              }
              if (M === 0) return 0;
              M < l && (i = !1)
            }
            if (i) return 2;
            for (let C = 0; C < u; C++) {
              const T = this.planes[C];
              let M = 0;
              for (let z = 0; z < g; z++) {
                const R = e.points[z];
                T[0] * R[0] + T[1] * R[1] + T[2] * R[2] + T[3] >= 0 && M++
              }
              if (M === 0) return 0
            }
            return 1
          }
          intersectsPlane(e) {
            const i = this.points.length;
            let l = 0;
            for (let u = 0; u < i; u++) {
              const f = this.points[u];
              e[0] * f[0] + e[1] * f[1] + e[2] * f[2] + e[3] >= 0 && l++
            }
            return l === i ? 2 : l === 0 ? 0 : 1
          }
        }

        function Ei(p, e, i) {
          const l = p - e;
          return l < 0 ? -l : Math.max(0, l - i)
        }

        function Vs(p, e, i, l, u) {
          const f = p - i;
          let g;
          return g = f < 0 ? Math.min(-f, 1 + f - u) : f > 1 ? Math.min(Math.max(f - u, 0), 1 - f) : 0, Math.max(g, Ei(e, l, u))
        }
        class Ua {
          constructor() {
            this._boundingVolumeCache = new Op(this._computeTileBoundingVolume)
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers()
          }
          distanceToTile2d(e, i, l, u) {
            const f = 1 << l.z,
              g = 1 / f,
              C = l.x / f,
              T = l.y / f;
            let M = 2;
            return M = Math.min(M, Vs(e, i, C, T, g)), M = Math.min(M, Vs(e, i, C + .5, -T - g, g)), M = Math.min(M, Vs(e, i, C + .5, 2 - T - g, g)), M
          }
          getWrap(e, i, l) {
            const u = 1 << i.z,
              f = 1 / u,
              g = i.x / u,
              C = Ei(e.x, g, f),
              T = Ei(e.x, g - 1, f),
              M = Ei(e.x, g + 1, f),
              z = Math.min(C, T, M);
            return z === M ? 1 : z === T ? -1 : 0
          }
          allowVariableZoom(e, i) {
            return qt(e, i) > 4
          }
          allowWorldCopies() {
            return !1
          }
          getTileBoundingVolume(e, i, l, u) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, i, l, u)
          }
          _computeTileBoundingVolume(e, i, l, u) {
            var f, g;
            let C = 0,
              T = 0;
            if (u != null && u.terrain) {
              const M = new s.Z(e.z, i, e.z, e.x, e.y),
                z = u.terrain.getMinMaxElevation(M);
              C = (f = z.minElevation) !== null && f !== void 0 ? f : Math.min(0, l), T = (g = z.maxElevation) !== null && g !== void 0 ? g : Math.max(0, l)
            }
            if (C /= s.bu, T /= s.bu, C += 1, T += 1, e.z <= 0) return fs.fromAabb([-T, -T, -T], [T, T, T]);
            if (e.z === 1) return fs.fromAabb([e.x === 0 ? -T : 0, e.y === 0 ? 0 : -T, -T], [e.x === 0 ? 0 : T, e.y === 0 ? T : 0, T]);
            {
              const M = [Gi(0, 0, e.x, e.y, e.z), Gi(s.$, 0, e.x, e.y, e.z), Gi(s.$, s.$, e.x, e.y, e.z), Gi(0, s.$, e.x, e.y, e.z)],
                z = [];
              for (const Qe of M) z.push(s.aR([], Qe, T));
              if (T !== C)
                for (const Qe of M) z.push(s.aR([], Qe, C));
              e.y === 0 && z.push([0, 1, 0]), e.y === (1 << e.z) - 1 && z.push([0, -1, 0]);
              const R = [1, 1, 1],
                D = [-1, -1, -1];
              for (const Qe of z)
                for (let at = 0; at < 3; at++) R[at] = Math.min(R[at], Qe[at]), D[at] = Math.max(D[at], Qe[at]);
              const N = Gi(s.$ / 2, s.$ / 2, e.x, e.y, e.z),
                H = s.aW([], [0, 1, 0], N);
              s.aV(H, H);
              const ie = s.aW([], N, H);
              s.aV(ie, ie);
              const ne = s.aW([], M[2], M[1]);
              s.aV(ne, ne);
              const se = s.aW([], M[0], M[3]);
              s.aV(se, se), z.push(s.aR([], N, T)), e.y >= (1 << e.z) / 2 && z.push(s.aR([], Gi(s.$ / 2, 0, e.x, e.y, e.z), T)), e.y < (1 << e.z) / 2 && z.push(s.aR([], Gi(s.$ / 2, s.$, e.x, e.y, e.z), T));
              const pe = qs(N, z),
                ye = qs(ie, z),
                ge = [-N[0], -N[1], -N[2], pe.max],
                Te = [N[0], N[1], N[2], -pe.min],
                Le = [-ie[0], -ie[1], -ie[2], ye.max],
                ve = [ie[0], ie[1], ie[2], -ye.min],
                Ne = [...ne, 0],
                st = [...se, 0],
                Xe = [];
              return e.y === 0 ? Xe.push(s.bt(st, Ne, ge), s.bt(st, Ne, Te)) : Xe.push(s.bt(Le, Ne, ge), s.bt(Le, Ne, Te), s.bt(Le, st, ge), s.bt(Le, st, Te)), e.y === (1 << e.z) - 1 ? Xe.push(s.bt(st, Ne, ge), s.bt(st, Ne, Te)) : Xe.push(s.bt(ve, Ne, ge), s.bt(ve, Ne, Te), s.bt(ve, st, ge), s.bt(ve, st, Te)), new fs(Xe, [ge, Te, Le, ve, Ne, st], R, D)
            }
          }
        }

        function qs(p, e) {
          let i = 1 / 0,
            l = -1 / 0;
          for (const u of e) {
            const f = s.aX(p, u);
            i = Math.min(i, f), l = Math.max(l, f)
          }
          return {
            min: i,
            max: l
          }
        }
        class Us {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, i, l) {
            return this._helper.interpolatePadding(e, i, l)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, i) {
            this._helper.resize(e, i)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e) {}
          constructor() {
            this._cachedClippingPlane = s.bv(), this._projectionMatrix = s.b9(), this._globeViewProjMatrix32f = s.b8(), this._globeViewProjMatrixNoCorrection = s.b9(), this._globeViewProjMatrixNoCorrectionInverted = s.b9(), this._globeProjMatrixInverted = s.b9(), this._cameraPosition = s.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new rn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              getConstrained: (e, i) => this.getConstrained(e, i)
            }), this._coveringTilesDetailsProvider = new Ua
          }
          clone() {
            const e = new Us;
            return e.apply(this), e
          }
          apply(e, i) {
            this._globeLatitudeErrorCorrectionRadians = i || 0, this._helper.apply(e)
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted
          }
          get cameraPosition() {
            const e = s.bp();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          getProjectionData(e) {
            const {
              overscaledTileID: i,
              applyGlobeMatrix: l
            } = e, u = this._helper.getMercatorTileCoordinates(i);
            return {
              mainMatrix: this._globeViewProjMatrix32f,
              tileMercatorCoords: u,
              clippingPlane: this._cachedClippingPlane,
              projectionTransition: l ? 1 : 0,
              fallbackMatrix: this._globeViewProjMatrix32f
            }
          }
          _computeClippingPlane(e) {
            const i = this.pitchInRadians,
              l = this.cameraToCenterDistance / e,
              u = Math.sin(i) * l,
              f = Math.cos(i) * l + 1,
              g = 1 / Math.sqrt(u * u + f * f) * 1;
            let C = -u,
              T = f;
            const M = Math.sqrt(C * C + T * T);
            C /= M, T /= M;
            const z = [0, C, T];
            s.bw(z, z, [0, 0, 0], -this.bearingInRadians), s.bx(z, z, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), s.by(z, z, [0, 0, 0], this.center.lng * Math.PI / 180);
            const R = 1 / s.aZ(z);
            return s.aR(z, z, R), [...z, -g * R]
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(si(e))
          }
          transformLightDirection(e) {
            const i = this._helper._center.lng * Math.PI / 180,
              l = this._helper._center.lat * Math.PI / 180,
              u = Math.cos(l),
              f = [Math.sin(i) * u, Math.sin(l), Math.cos(i) * u],
              g = [f[2], 0, -f[0]],
              C = [0, 0, 0];
            s.aW(C, g, f), s.aV(g, g), s.aV(C, C);
            const T = [0, 0, 0];
            return s.aV(T, [g[0] * e[0] + C[0] * e[1] + f[0] * e[2], g[1] * e[0] + C[1] * e[1] + f[1] * e[2], g[2] * e[0] + C[2] * e[1] + f[2] * e[2]]), T
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getPitchedTextCorrection(e, i, l) {
            const u = (function(C, T, M) {
                const z = 1 / (1 << M.z);
                return new s.a1(C / s.$ * z + M.x * z, T / s.$ * z + M.y * z)
              })(e, i, l.canonical),
              f = (g = u.y, [s.bo(u.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - .5 * Math.PI]);
            var g;
            return this.getCircleRadiusCorrection() / Math.cos(f[1])
          }
          projectTileCoordinates(e, i, l, u) {
            const f = l.canonical,
              g = Gi(e, i, f.x, f.y, f.z),
              C = 1 + (u ? u(e, i) : 0) / s.bu,
              T = [g[0] * C, g[1] * C, g[2] * C, 1];
            s.aw(T, T, this._globeViewProjMatrixNoCorrection);
            const M = this._cachedClippingPlane,
              z = M[0] * g[0] + M[1] * g[1] + M[2] * g[2] + M[3] < 0;
            return {
              point: new s.P(T[0] / T[3], T[1] / T[3]),
              signedDistanceFromCamera: T[3],
              isOccluded: z
            }
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = to(this.worldSize, this.center.lat),
              i = s.ba(),
              l = s.ba();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), s.b4(i, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const u = this.centerOffset;
            i[8] = 2 * -u.x / this._helper._width, i[9] = 2 * u.y / this._helper._height, this._projectionMatrix = s.b5(i), this._globeProjMatrixInverted = s.ba(), s.aq(this._globeProjMatrixInverted, i), s.M(i, i, [0, 0, -this.cameraToCenterDistance]), s.b6(i, i, this.rollInRadians), s.b7(i, i, -this.pitchInRadians), s.b6(i, i, this.bearingInRadians), s.M(i, i, [0, 0, -e]);
            const f = s.bp();
            f[0] = e, f[1] = e, f[2] = e, s.b7(l, i, this.center.lat * Math.PI / 180), s.bz(l, l, -this.center.lng * Math.PI / 180), s.N(l, l, f), this._globeViewProjMatrixNoCorrection = l, s.b7(i, i, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), s.bz(i, i, -this.center.lng * Math.PI / 180), s.N(i, i, f), this._globeViewProjMatrix32f = new Float32Array(i), this._globeViewProjMatrixNoCorrectionInverted = s.ba(), s.aq(this._globeViewProjMatrixNoCorrectionInverted, l);
            const g = s.bp();
            this._cameraPosition = s.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / e, s.bw(this._cameraPosition, this._cameraPosition, g, -this.rollInRadians), s.bx(this._cameraPosition, this._cameraPosition, g, this.pitchInRadians), s.bw(this._cameraPosition, this._cameraPosition, g, -this.bearingInRadians), s.aS(this._cameraPosition, this._cameraPosition, [0, 0, 1]), s.bx(this._cameraPosition, this._cameraPosition, g, -this.center.lat * Math.PI / 180), s.by(this._cameraPosition, this._cameraPosition, g, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const C = s.b5(this._globeViewProjMatrixNoCorrectionInverted);
            s.N(C, C, [1, 1, -1]), this._cachedFrustum = cn.fromInvProjectionMatrix(C, 1, 0, this._cachedClippingPlane, !0)
          }
          calculateFogMatrix(e) {
            s.w("calculateFogMatrix is not supported on globe projection.");
            const i = s.ba();
            return s.ag(i), i
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new s.b2(0, e)]
          }
          getCameraFrustum() {
            return this._cachedFrustum
          }
          getClippingPlane() {
            return this._cachedClippingPlane
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            e && s.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0)
          }
          maxPitchScaleFactor() {
            return 1
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, i) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const l = si(e);
            s.aR(l, l, 1 + i / s.bu);
            const u = s.bv();
            return s.aw(u, [l[0], l[1], l[2], 1], this._globeViewProjMatrixNoCorrection), u[2] / u[3]
          }
          populateCache(e) {}
          getBounds() {
            const e = .5 * this.width,
              i = .5 * this.height,
              l = [new s.P(0, 0), new s.P(e, 0), new s.P(this.width, 0), new s.P(this.width, i), new s.P(this.width, this.height), new s.P(e, this.height), new s.P(0, this.height), new s.P(0, i)],
              u = [];
            for (const R of l) u.push(this.unprojectScreenPoint(R));
            let f = 0,
              g = 0,
              C = 0,
              T = 0;
            const M = this.center;
            for (const R of u) {
              const D = s.bA(M.lng, R.lng),
                N = s.bA(M.lat, R.lat);
              D < g && (g = D), D > f && (f = D), N < T && (T = N), N > C && (C = N)
            }
            const z = [M.lng + g, M.lat + T, M.lng + f, M.lat + C];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (z[3] = 90, z[0] = -180, z[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (z[1] = -90, z[0] = -180, z[2] = 180), new At(z)
          }
          getConstrained(e, i) {
            const l = s.ah(e.lat, -s.ai, s.ai),
              u = s.ah(+i, this.minZoom + Fn(0, l), this.maxZoom);
            return {
              center: new s.S(e.lng, l),
              zoom: u
            }
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, l, u)
          }
          setLocationAtPoint(e, i) {
            const l = si(this.unprojectScreenPoint(i)),
              u = si(e),
              f = s.bp();
            s.bB(f);
            const g = s.bp();
            s.by(g, l, f, -this.center.lng * Math.PI / 180), s.bx(g, g, f, this.center.lat * Math.PI / 180);
            const C = u[0] * u[0] + u[2] * u[2],
              T = g[0] * g[0];
            if (C < T) return;
            const M = Math.sqrt(C - T),
              z = -M,
              R = s.bC(u[0], u[2], g[0], M),
              D = s.bC(u[0], u[2], g[0], z),
              N = s.bp();
            s.by(N, u, f, -R);
            const H = s.bC(N[1], N[2], g[1], g[2]),
              ie = s.bp();
            s.by(ie, u, f, -D);
            const ne = s.bC(ie[1], ie[2], g[1], g[2]),
              se = .5 * Math.PI,
              pe = H >= -se && H <= se,
              ye = ne >= -se && ne <= se;
            let ge, Te;
            if (pe && ye) {
              const st = this.center.lng * Math.PI / 180,
                Xe = this.center.lat * Math.PI / 180;
              s.bD(R, st) + s.bD(H, Xe) < s.bD(D, st) + s.bD(ne, Xe) ? (ge = R, Te = H) : (ge = D, Te = ne)
            } else if (pe) ge = R, Te = H;
            else {
              if (!ye) return;
              ge = D, Te = ne
            }
            const Le = ge / Math.PI * 180,
              ve = Te / Math.PI * 180,
              Ne = this.center.lat;
            this.setCenter(new s.S(Le, s.ah(ve, -90, 90))), this.setZoom(this.zoom + Fn(Ne, this.center.lat))
          }
          locationToScreenPoint(e, i) {
            const l = si(e);
            if (i) {
              const u = i.getElevationForLngLatZoom(e, this._helper._tileZoom);
              s.aR(l, l, 1 + u / s.bu)
            }
            return this._projectSurfacePointToScreen(l)
          }
          _projectSurfacePointToScreen(e) {
            const i = s.bv();
            return s.aw(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], new s.P((.5 * i[0] + .5) * this.width, (.5 * -i[1] + .5) * this.height)
          }
          screenPointToMercatorCoordinate(e, i) {
            if (i) {
              const l = i.pointCoordinate(e);
              if (l) return l
            }
            return s.a1.fromLngLat(this.unprojectScreenPoint(e))
          }
          screenPointToLocation(e, i) {
            var l;
            return (l = this.screenPointToMercatorCoordinate(e, i)) === null || l === void 0 ? void 0 : l.toLngLat()
          }
          isPointOnMapSurface(e, i) {
            const l = this._cameraPosition,
              u = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(l, u)
          }
          getRayDirectionFromPixel(e) {
            const i = s.bv();
            i[0] = e.x / this.width * 2 - 1, i[1] = -1 * (e.y / this.height * 2 - 1), i[2] = 1, i[3] = 1, s.aw(i, i, this._globeViewProjMatrixNoCorrectionInverted), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3];
            const l = s.bp();
            l[0] = i[0] - this._cameraPosition[0], l[1] = i[1] - this._cameraPosition[1], l[2] = i[2] - this._cameraPosition[2];
            const u = s.bp();
            return s.aV(u, l), u
          }
          isSurfacePointVisible(e) {
            const i = this._cachedClippingPlane;
            return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] >= 0
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const i = s.bv();
            return s.aw(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3], i[0] > -1 && i[0] < 1 && i[1] > -1 && i[1] < 1 && i[2] > -1 && i[2] < 1
          }
          rayPlanetIntersection(e, i) {
            const l = s.aX(e, i),
              u = s.bp(),
              f = s.bp();
            s.aR(f, i, l), s.aU(u, e, f);
            const g = 1 - s.aX(u, u);
            if (g < 0) return null;
            const C = s.aX(e, e) - 1,
              T = -l + (l < 0 ? 1 : -1) * Math.sqrt(g),
              M = C / T,
              z = T;
            return {
              tMin: Math.min(M, z),
              tMax: Math.max(M, z)
            }
          }
          unprojectScreenPoint(e) {
            const i = this._cameraPosition,
              l = this.getRayDirectionFromPixel(e),
              u = this.rayPlanetIntersection(i, l);
            if (u) {
              const z = s.bp();
              s.aS(z, i, [l[0] * u.tMin, l[1] * u.tMin, l[2] * u.tMin]);
              const R = s.bp();
              return s.aV(R, z), qa(R)
            }
            const f = this._cachedClippingPlane,
              g = f[0] * l[0] + f[1] * l[1] + f[2] * l[2],
              C = -s.b1(f, i) / g,
              T = s.bp();
            if (C > 0) s.aS(T, i, [l[0] * C, l[1] * C, l[2] * C]);
            else {
              const z = s.bp();
              s.aS(z, i, [2 * l[0], 2 * l[1], 2 * l[2]]);
              const R = s.b1(this._cachedClippingPlane, z);
              s.aU(T, z, [this._cachedClippingPlane[0] * R, this._cachedClippingPlane[1] * R, this._cachedClippingPlane[2] * R])
            }
            const M = (function(z) {
              const R = s.bp();
              return R[0] = z[0] * -z[3], R[1] = z[1] * -z[3], R[2] = z[2] * -z[3], {
                center: R,
                radius: Math.sqrt(1 - z[3] * z[3])
              }
            })(f);
            return qa((function(z, R, D) {
              const N = s.bp();
              s.aU(N, D, z);
              const H = s.bp();
              return s.bq(H, z, N, R / s.a$(N)), H
            })(M.center, M.radius, T))
          }
          getMatrixForModel(e, i) {
            const l = s.S.convert(e),
              u = 1 / s.bu,
              f = s.b9();
            return s.bz(f, f, l.lng / 180 * Math.PI), s.b7(f, f, -l.lat / 180 * Math.PI), s.M(f, f, [0, 0, 1 + i / s.bu]), s.b7(f, f, .5 * Math.PI), s.N(f, f, [u, u, u]), f
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = this.getProjectionData({
              overscaledTileID: new s.Z(0, 0, 0, 0, 0),
              applyGlobeMatrix: e
            });
            return i.tileMercatorCoords = [0, 0, 1, 1], i
          }
          getFastPathSimpleProjectionMatrix(e) {}
        }
        class $s {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, i, l) {
            return this._helper.interpolatePadding(e, i, l)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, i, l = !0) {
            this._helper.resize(e, i, l)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          get isGlobeRendering() {
            return this._globeness > 0
          }
          setTransitionState(e, i) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = i, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new rn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              getConstrained: (e, i) => this.getConstrained(e, i)
            }), this._globeness = 1, this._mercatorTransform = new Jr, this._verticalPerspectiveTransform = new Us
          }
          clone() {
            const e = new $s;
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition
          }
          getProjectionData(e) {
            const i = this._mercatorTransform.getProjectionData(e),
              l = this._verticalPerspectiveTransform.getProjectionData(e);
            return {
              mainMatrix: this.isGlobeRendering ? l.mainMatrix : i.mainMatrix,
              clippingPlane: l.clippingPlane,
              tileMercatorCoords: l.tileMercatorCoords,
              projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
              fallbackMatrix: i.fallbackMatrix
            }
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e)
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e)
          }
          getPixelScale() {
            return s.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
          }
          getCircleRadiusCorrection() {
            return s.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
          }
          getPitchedTextCorrection(e, i, l) {
            const u = this._mercatorTransform.getPitchedTextCorrection(e, i, l),
              f = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, i, l);
            return s.bk(u, f, this._globeness)
          }
          projectTileCoordinates(e, i, l, u) {
            return this.currentTransform.projectTileCoordinates(e, i, l, u)
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ)
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e)
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e)
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum()
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane()
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider()
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor()
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, i) {
            return this.currentTransform.lngLatToCameraDepth(e, i)
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e)
          }
          getBounds() {
            return this.currentTransform.getBounds()
          }
          getConstrained(e, i) {
            return this.currentTransform.getConstrained(e, i)
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, l, u)
          }
          setLocationAtPoint(e, i) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, i), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, i), this.apply(this._verticalPerspectiveTransform)
          }
          locationToScreenPoint(e, i) {
            return this.currentTransform.locationToScreenPoint(e, i)
          }
          screenPointToMercatorCoordinate(e, i) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, i)
          }
          screenPointToLocation(e, i) {
            return this.currentTransform.screenPointToLocation(e, i)
          }
          isPointOnMapSurface(e, i) {
            return this.currentTransform.isPointOnMapSurface(e, i)
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
          }
          getMatrixForModel(e, i) {
            return this.currentTransform.getMatrixForModel(e, i)
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return i;
            const l = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return l.fallbackMatrix = i.mainMatrix, l
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
          }
        }
        class Fi {
          get useGlobeControls() {
            return !0
          }
          handlePanInertia(e, i) {
            const l = ps(e, i);
            return Math.abs(l.lng - i.center.lng) > 180 && (l.lng = i.center.lng + 179.5 * Math.sign(l.lng - i.center.lng)), {
              easingCenter: l,
              easingOffset: new s.P(0, 0)
            }
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            const l = e.around,
              u = i.screenPointToLocation(l);
            e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta);
            const f = i.zoom;
            e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
            const g = i.zoom - f;
            if (g === 0) return;
            const C = s.bA(i.center.lng, u.lng),
              T = C / (Math.abs(C / 180) + 1),
              M = s.bA(i.center.lat, u.lat),
              z = i.getRayDirectionFromPixel(l),
              R = i.cameraPosition,
              D = -1 * s.aX(R, z),
              N = s.bp();
            s.aS(N, R, [z[0] * D, z[1] * D, z[2] * D]);
            const H = s.aZ(N) - 1,
              ie = Math.exp(.5 * -Math.max(H - .3, 0)),
              ne = to(i.worldSize, i.center.lat) / Math.min(i.width, i.height),
              se = s.bn(ne, .9, .5, 1, .25),
              pe = (1 - s.af(-g)) * Math.min(ie, se),
              ye = i.center.lat,
              ge = i.zoom,
              Te = new s.S(i.center.lng + T * pe, s.ah(i.center.lat + M * pe, -s.ai, s.ai));
            i.setLocationAtPoint(u, l);
            const Le = i.center,
              ve = s.bn(Math.abs(C), 45, 85, 0, 1),
              Ne = s.bn(ne, .75, .35, 0, 1),
              st = Math.pow(Math.max(ve, Ne), .25),
              Xe = s.bA(Le.lng, Te.lng),
              Qe = s.bA(Le.lat, Te.lat);
            i.setCenter(new s.S(Le.lng + Xe * st, Le.lat + Qe * st).wrap()), i.setZoom(ge + Fn(ye, i.center.lat))
          }
          handleMapControlsPan(e, i, l) {
            if (!e.panDelta) return;
            const u = i.center.lat,
              f = i.zoom;
            i.setCenter(ps(e.panDelta, i).wrap()), i.setZoom(f + Fn(u, i.center.lat))
          }
          cameraForBoxAndBearing(e, i, l, u, f) {
            const g = xn(e, i, l, u, f),
              C = i.left / f.width * 2 - 1,
              T = (f.width - i.right) / f.width * 2 - 1,
              M = i.top / f.height * -2 + 1,
              z = (f.height - i.bottom) / f.height * -2 + 1,
              R = s.bA(l.getWest(), l.getEast()) < 0,
              D = R ? l.getEast() : l.getWest(),
              N = R ? l.getWest() : l.getEast(),
              H = Math.max(l.getNorth(), l.getSouth()),
              ie = Math.min(l.getNorth(), l.getSouth()),
              ne = D + .5 * s.bA(D, N),
              se = H + .5 * s.bA(H, ie),
              pe = f.clone();
            pe.setCenter(g.center), pe.setBearing(g.bearing), pe.setPitch(0), pe.setRoll(0), pe.setZoom(g.zoom);
            const ye = pe.modelViewProjectionMatrix,
              ge = [si(l.getNorthWest()), si(l.getNorthEast()), si(l.getSouthWest()), si(l.getSouthEast()), si(new s.S(N, se)), si(new s.S(D, se)), si(new s.S(ne, H)), si(new s.S(ne, ie))],
              Te = si(g.center);
            let Le = Number.POSITIVE_INFINITY;
            for (const ve of ge) C < 0 && (Le = Fi.getLesserNonNegativeNonNull(Le, Fi.solveVectorScale(ve, Te, ye, "x", C))), T > 0 && (Le = Fi.getLesserNonNegativeNonNull(Le, Fi.solveVectorScale(ve, Te, ye, "x", T))), M > 0 && (Le = Fi.getLesserNonNegativeNonNull(Le, Fi.solveVectorScale(ve, Te, ye, "y", M))), z < 0 && (Le = Fi.getLesserNonNegativeNonNull(Le, Fi.solveVectorScale(ve, Te, ye, "y", z)));
            if (Number.isFinite(Le) && Le !== 0) return g.zoom = pe.zoom + s.ak(Le), g;
            Jn()
          }
          handleJumpToCenterZoom(e, i) {
            const l = e.center.lat,
              u = e.getConstrained(i.center ? s.S.convert(i.center) : e.center, e.zoom).center;
            e.setCenter(u.wrap());
            const f = i.zoom !== void 0 ? +i.zoom : e.zoom + Fn(l, u.lat);
            e.zoom !== f && e.setZoom(f)
          }
          handleEaseTo(e, i) {
            const l = e.zoom,
              u = e.center,
              f = e.padding,
              g = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              C = {
                roll: i.roll === void 0 ? e.roll : i.roll,
                pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                bearing: i.bearing === void 0 ? e.bearing : i.bearing
              },
              T = i.zoom !== void 0,
              M = !e.isPaddingEqual(i.padding);
            let z = !1;
            const R = i.center ? s.S.convert(i.center) : u,
              D = e.getConstrained(R, l).center;
            br(e, D);
            const N = e.clone();
            N.setCenter(D), N.setZoom(T ? +i.zoom : l + Fn(u.lat, R.lat)), N.setBearing(i.bearing);
            const H = new s.P(s.ah(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), s.ah(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
            N.setLocationAtPoint(D, H);
            const ie = (i.offset && i.offsetAsPoint.mag()) > 0 ? N.center : D,
              ne = T ? +i.zoom : l + Fn(u.lat, ie.lat),
              se = l + Fn(u.lat, 0),
              pe = ne + Fn(ie.lat, 0),
              ye = s.bA(u.lng, ie.lng),
              ge = s.bA(u.lat, ie.lat),
              Te = s.af(pe - se);
            return z = ne !== l, {
              easeFunc: Le => {
                if (s.be(g, C) || Bn({
                    startEulerAngles: g,
                    endEulerAngles: C,
                    tr: e,
                    k: Le,
                    useSlerp: g.roll != C.roll
                  }), M && e.interpolatePadding(f, i.padding, Le), i.around) s.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(i.around, i.aroundPoint);
                else {
                  const ve = pe > se ? Math.min(2, Te) : Math.max(.5, Te),
                    Ne = Math.pow(ve, 1 - Le),
                    st = Oc(u, ye, ge, Le * Ne);
                  e.setCenter(st.wrap())
                }
                if (z) {
                  const ve = s.C.number(se, pe, Le) + Fn(0, e.center.lat);
                  e.setZoom(ve)
                }
              },
              isZooming: z,
              elevationCenter: ie
            }
          }
          handleFlyTo(e, i) {
            const l = i.zoom !== void 0,
              u = e.center,
              f = e.zoom,
              g = e.padding,
              C = !e.isPaddingEqual(i.padding),
              T = e.getConstrained(s.S.convert(i.center || i.locationAtOffset), f).center,
              M = l ? +i.zoom : e.zoom + Fn(e.center.lat, T.lat),
              z = e.clone();
            z.setCenter(T), z.setZoom(M), z.setBearing(i.bearing);
            const R = new s.P(s.ah(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), s.ah(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
            z.setLocationAtPoint(T, R);
            const D = z.center;
            br(e, D);
            const N = (function(ge, Te, Le) {
                const ve = si(Te),
                  Ne = si(Le),
                  st = s.aX(ve, Ne),
                  Xe = Math.acos(st),
                  Qe = ds(ge);
                return Xe / (2 * Math.PI) * Qe
              })(e, u, D),
              H = f + Fn(u.lat, 0),
              ie = M + Fn(D.lat, 0),
              ne = s.af(ie - H);
            let se;
            if (typeof i.minZoom == "number") {
              const ge = +i.minZoom + Fn(D.lat, 0),
                Te = Math.min(ge, H, ie) + Fn(0, D.lat),
                Le = e.getConstrained(D, Te).zoom + Fn(D.lat, 0);
              se = s.af(Le - H)
            }
            const pe = s.bA(u.lng, D.lng),
              ye = s.bA(u.lat, D.lat);
            return {
              easeFunc: (ge, Te, Le, ve) => {
                const Ne = Oc(u, pe, ye, Le);
                C && e.interpolatePadding(g, i.padding, ge);
                const st = ge === 1 ? D : Ne;
                e.setCenter(st.wrap());
                const Xe = H + s.ak(Te);
                e.setZoom(ge === 1 ? M : Xe + Fn(0, st.lat))
              },
              scaleOfZoom: ne,
              targetCenter: D,
              scaleOfMinZoom: se,
              pixelPathLength: N
            }
          }
          static solveVectorScale(e, i, l, u, f) {
            const g = u === "x" ? [l[0], l[4], l[8], l[12]] : [l[1], l[5], l[9], l[13]],
              C = [l[3], l[7], l[11], l[15]],
              T = e[0] * g[0] + e[1] * g[1] + e[2] * g[2],
              M = e[0] * C[0] + e[1] * C[1] + e[2] * C[2],
              z = i[0] * g[0] + i[1] * g[1] + i[2] * g[2],
              R = i[0] * C[0] + i[1] * C[1] + i[2] * C[2];
            return z + f * M === T + f * R || C[3] * (T - z) + g[3] * (R - M) + T * R == z * M ? null : (z + g[3] - f * R - f * C[3]) / (z - T - f * R + f * M)
          }
          static getLesserNonNegativeNonNull(e, i) {
            return i !== null && i >= 0 && i < e ? i : e
          }
        }
        class Hh {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new pn, this._verticalPerspectiveCameraHelper = new Fi
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
          }
          handlePanInertia(e, i) {
            return this.currentHelper.handlePanInertia(e, i)
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, i)
          }
          handleMapControlsPan(e, i, l) {
            this.currentHelper.handleMapControlsPan(e, i, l)
          }
          cameraForBoxAndBearing(e, i, l, u, f) {
            return this.currentHelper.cameraForBoxAndBearing(e, i, l, u, f)
          }
          handleJumpToCenterZoom(e, i) {
            this.currentHelper.handleJumpToCenterZoom(e, i)
          }
          handleEaseTo(e, i) {
            return this.currentHelper.handleEaseTo(e, i)
          }
          handleFlyTo(e, i) {
            return this.currentHelper.handleFlyTo(e, i)
          }
        }
        const Pl = (p, e) => s.y(p, e && e.filter((i => i.identifier !== "source.canvas"))),
          jp = s.bE();
        class jc extends s.E {
          constructor(e, i = {}) {
            super(), this._rtlPluginLoaded = () => {
              for (const l in this.sourceCaches) {
                const u = this.sourceCaches[l].getSource().type;
                u !== "vector" && u !== "geojson" || this.sourceCaches[l].reload()
              }
            }, this.map = e, this.dispatcher = new Lt(Pt(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((l, u) => this.getGlyphs(l, u))), this.dispatcher.registerMessageHandler("GI", ((l, u) => this.getImages(l, u))), this.imageManager = new Ue, this.imageManager.setEventedParent(this), this.glyphManager = new Ge(e._requestManager, i.localIdeographFontFamily), this.lineAtlas = new ae(256, 512), this.crossTileSymbolIndex = new Va, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new s.bF, this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", s.bG()), Vr().on(dr, this._rtlPluginLoaded), this.on("data", (l => {
              if (l.dataType !== "source" || l.sourceDataType !== "metadata") return;
              const u = this.sourceCaches[l.sourceId];
              if (!u) return;
              const f = u.getSource();
              if (f && f.vectorLayerIds)
                for (const g in this._layers) {
                  const C = this._layers[g];
                  C.source === f.id && this._validateLayer(C)
                }
            }))
          }
          setGlobalStateProperty(e, i) {
            var l, u, f;
            this._checkLoaded();
            const g = i === null ? (f = (u = (l = this.stylesheet.state) === null || l === void 0 ? void 0 : l[e]) === null || u === void 0 ? void 0 : u.default) !== null && f !== void 0 ? f : null : i;
            if (s.bH(g, this._globalState[e])) return this;
            this._globalState[e] = g;
            const C = this._findGlobalStateAffectedSources([e]);
            for (const T in this.sourceCaches) C.has(T) && (this._reloadSource(T), this._changed = !0)
          }
          getGlobalState() {
            return this._globalState
          }
          setGlobalState(e) {
            this._checkLoaded();
            const i = [];
            for (const u in e) !s.bH(this._globalState[u], e[u].default) && (i.push(u), this._globalState[u] = e[u].default);
            const l = this._findGlobalStateAffectedSources(i);
            for (const u in this.sourceCaches) l.has(u) && (this._reloadSource(u), this._changed = !0)
          }
          _findGlobalStateAffectedSources(e) {
            if (e.length === 0) return new Set;
            const i = new Set;
            for (const l in this._layers) {
              const u = this._layers[l],
                f = u.getLayoutAffectingGlobalStateRefs();
              for (const g of e) f.has(g) && i.add(u.source)
            }
            return i
          }
          loadURL(e, i = {}, l) {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), i.validate = typeof i.validate != "boolean" || i.validate;
            const u = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController;
            const f = this._loadStyleRequest;
            s.j(u, this._loadStyleRequest).then((g => {
              this._loadStyleRequest = null, this._load(g.data, i, l)
            })).catch((g => {
              this._loadStyleRequest = null, g && !f.signal.aborted && this.fire(new s.k(g))
            }))
          }
          loadJSON(e, i = {}, l) {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), this._frameRequest = new AbortController, Q.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, i.validate = i.validate !== !1, this._load(e, i, l)
            })).catch((() => {}))
          }
          loadEmpty() {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), this._load(jp, {
              validate: !1
            })
          }
          _load(e, i, l) {
            var u, f, g;
            const C = i.transformStyle ? i.transformStyle(l, e) : e;
            if (!i.validate || !Pl(this, s.z(C))) {
              this._loaded = !0, this.stylesheet = C;
              for (const T in C.sources) this.addSource(T, C.sources[T], {
                validate: !1
              });
              C.sprite ? this._loadSprite(C.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(C.glyphs), this._createLayers(), this.light = new K(this.stylesheet.light), this._setProjectionInternal(((u = this.stylesheet.projection) === null || u === void 0 ? void 0 : u.type) || "mercator"), this.sky = new le(this.stylesheet.sky), this.map.setTerrain((f = this.stylesheet.terrain) !== null && f !== void 0 ? f : null), this.setGlobalState((g = this.stylesheet.state) !== null && g !== void 0 ? g : null), this.fire(new s.l("data", {
                dataType: "style"
              })), this.fire(new s.l("style.load"))
            }
          }
          _createLayers() {
            const e = s.bI(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", e), this._order = e.map((i => i.id)), this._layers = {}, this._serializedLayers = null;
            for (const i of e) {
              const l = s.bJ(i);
              l.setEventedParent(this, {
                layer: {
                  id: i.id
                }
              }), this._layers[i.id] = l
            }
          }
          _loadSprite(e, i = !1, l = void 0) {
            let u;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController, (function(f, g, C, T) {
              return s._(this, void 0, void 0, (function*() {
                const M = tt(f),
                  z = C > 1 ? "@2x" : "",
                  R = {},
                  D = {};
                for (const {
                    id: N,
                    url: H
                  }
                  of M) {
                  const ie = g.transformRequest(Ve(H, z, ".json"), "SpriteJSON");
                  R[N] = s.j(ie, T);
                  const ne = g.transformRequest(Ve(H, z, ".png"), "SpriteImage");
                  D[N] = De.getImage(ne, T)
                }
                return yield Promise.all([...Object.values(R), ...Object.values(D)]), (function(N, H) {
                  return s._(this, void 0, void 0, (function*() {
                    const ie = {};
                    for (const ne in N) {
                      ie[ne] = {};
                      const se = Q.getImageCanvasContext((yield H[ne]).data),
                        pe = (yield N[ne]).data;
                      for (const ye in pe) {
                        const {
                          width: ge,
                          height: Te,
                          x: Le,
                          y: ve,
                          sdf: Ne,
                          pixelRatio: st,
                          stretchX: Xe,
                          stretchY: Qe,
                          content: at,
                          textFitWidth: Ht,
                          textFitHeight: Xt
                        } = pe[ye];
                        ie[ne][ye] = {
                          data: null,
                          pixelRatio: st,
                          sdf: Ne,
                          stretchX: Xe,
                          stretchY: Qe,
                          content: at,
                          textFitWidth: Ht,
                          textFitHeight: Xt,
                          spriteData: {
                            width: ge,
                            height: Te,
                            x: Le,
                            y: ve,
                            context: se
                          }
                        }
                      }
                    }
                    return ie
                  }))
                })(R, D)
              }))
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((f => {
              if (this._spriteRequest = null, f)
                for (const g in f) {
                  this._spritesImagesIds[g] = [];
                  const C = this._spritesImagesIds[g] ? this._spritesImagesIds[g].filter((T => !(T in f))) : [];
                  for (const T of C) this.imageManager.removeImage(T), this._changedImages[T] = !0;
                  for (const T in f[g]) {
                    const M = g === "default" ? T : `${g}:${T}`;
                    this._spritesImagesIds[g].push(M), M in this.imageManager.images ? this.imageManager.updateImage(M, f[g][T], !1) : this.imageManager.addImage(M, f[g][T]), i && (this._changedImages[M] = !0)
                  }
                }
            })).catch((f => {
              this._spriteRequest = null, u = f, this.fire(new s.k(u))
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), i && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
                dataType: "style"
              })), l && l(u)
            }))
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          _validateLayer(e) {
            const i = this.sourceCaches[e.source];
            if (!i) return;
            const l = e.sourceLayer;
            if (!l) return;
            const u = i.getSource();
            (u.type === "geojson" || u.vectorLayerIds && u.vectorLayerIds.indexOf(l) === -1) && this.fire(new s.k(new Error(`Source layer "${l}" does not exist on source "${u.id}" as specified by style layer "${e.id}".`)))
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.sourceCaches)
              if (!this.sourceCaches[e].loaded()) return !1;
            return !!this.imageManager.isLoaded()
          }
          _serializeByIds(e, i = !1) {
            const l = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(i ? s.bK(l) : l);
            const u = [];
            for (const f of e)
              if (l[f]) {
                const g = i ? s.bK(l[f]) : l[f];
                u.push(g)
              } return u
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const i = Object.keys(this._layers);
            for (const l of i) {
              const u = this._layers[l];
              u.type !== "custom" && (e[l] = u.serialize())
            }
            return e
          }
          hasTransitions() {
            var e, i, l;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((i = this.sky) === null || i === void 0) && i.hasTransition() || !((l = this.projection) === null || l === void 0) && l.hasTransition()) return !0;
            for (const u in this.sourceCaches)
              if (this.sourceCaches[u].hasTransition()) return !0;
            for (const u in this._layers)
              if (this._layers[u].hasTransition()) return !0;
            return !1
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.")
          }
          update(e) {
            if (!this._loaded) return;
            const i = this._changed;
            if (i) {
              const u = Object.keys(this._updatedLayers),
                f = Object.keys(this._removedLayers);
              (u.length || f.length) && this._updateWorkerLayers(u, f);
              for (const g in this._updatedSources) {
                const C = this._updatedSources[g];
                if (C === "reload") this._reloadSource(g);
                else {
                  if (C !== "clear") throw new Error(`Invalid action ${C}`);
                  this._clearSource(g)
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const g in this._updatedPaintProps) this._layers[g].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates()
            }
            const l = {};
            for (const u in this.sourceCaches) {
              const f = this.sourceCaches[u];
              l[u] = f.used, f.used = !1
            }
            for (const u of this._order) {
              const f = this._layers[u];
              f.recalculate(e, this._availableImages), !f.isHidden(e.zoom) && f.source && (this.sourceCaches[f.source].used = !0)
            }
            for (const u in l) {
              const f = this.sourceCaches[u];
              !!l[u] != !!f.used && f.fire(new s.l("data", {
                sourceDataType: "visibility",
                dataType: "source",
                sourceId: u
              }))
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, i && this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const i in this.sourceCaches) this.sourceCaches[i].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {}
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1
            }
          }
          _updateWorkerLayers(e, i) {
            this.dispatcher.broadcast("UL", {
              layers: this._serializeByIds(e, !1),
              removedIds: i
            })
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1
          }
          setState(e, i = {}) {
            var l;
            this._checkLoaded();
            const u = this.serialize();
            if (e = i.transformStyle ? i.transformStyle(u, e) : e, ((l = i.validate) === null || l === void 0 || l) && Pl(this, s.z(e))) return !1;
            (e = s.bK(e)).layers = s.bI(e.layers);
            const f = s.bL(u, e),
              g = this._getOperationsToPerform(f);
            if (g.unimplemented.length > 0) throw new Error(`Unimplemented: ${g.unimplemented.join(", ")}.`);
            if (g.operations.length === 0) return !1;
            for (const C of g.operations) C();
            return this.stylesheet = e, this._serializedLayers = null, !0
          }
          _getOperationsToPerform(e) {
            const i = [],
              l = [];
            for (const u of e) switch (u.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                i.push((() => this.addLayer.apply(this, u.args)));
                break;
              case "removeLayer":
                i.push((() => this.removeLayer.apply(this, u.args)));
                break;
              case "setPaintProperty":
                i.push((() => this.setPaintProperty.apply(this, u.args)));
                break;
              case "setLayoutProperty":
                i.push((() => this.setLayoutProperty.apply(this, u.args)));
                break;
              case "setFilter":
                i.push((() => this.setFilter.apply(this, u.args)));
                break;
              case "addSource":
                i.push((() => this.addSource.apply(this, u.args)));
                break;
              case "removeSource":
                i.push((() => this.removeSource.apply(this, u.args)));
                break;
              case "setLayerZoomRange":
                i.push((() => this.setLayerZoomRange.apply(this, u.args)));
                break;
              case "setLight":
                i.push((() => this.setLight.apply(this, u.args)));
                break;
              case "setGeoJSONSourceData":
                i.push((() => this.setGeoJSONSourceData.apply(this, u.args)));
                break;
              case "setGlyphs":
                i.push((() => this.setGlyphs.apply(this, u.args)));
                break;
              case "setSprite":
                i.push((() => this.setSprite.apply(this, u.args)));
                break;
              case "setTerrain":
                i.push((() => this.map.setTerrain.apply(this, u.args)));
                break;
              case "setSky":
                i.push((() => this.setSky.apply(this, u.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, u.args);
                break;
              case "setGlobalState":
                i.push((() => this.setGlobalState.apply(this, u.args)));
                break;
              case "setTransition":
                i.push((() => {}));
                break;
              default:
                l.push(u.command)
            }
            return {
              operations: i,
              unimplemented: l
            }
          }
          addImage(e, i) {
            if (this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, i), this._afterImageUpdated(e)
          }
          updateImage(e, i) {
            this.imageManager.updateImage(e, i)
          }
          getImage(e) {
            return this.imageManager.getImage(e)
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e)
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages()
          }
          addSource(e, i, l = {}) {
            if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(s.z.source, `sources.${e}`, i, null, l)) return;
            this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
            const u = this.sourceCaches[e] = new Ut(e, i, this.dispatcher);
            u.style = this, u.setEventedParent(this, (() => ({
              isSourceLoaded: u.loaded(),
              source: u.serialize(),
              sourceId: e
            }))), u.onAdd(this.map), this._changed = !0
          }
          removeSource(e) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
            for (const l in this._layers)
              if (this._layers[l].source === e) return this.fire(new s.k(new Error(`Source "${e}" cannot be removed while layer "${l}" is using it.`)));
            const i = this.sourceCaches[e];
            delete this.sourceCaches[e], delete this._updatedSources[e], i.fire(new s.l("data", {
              sourceDataType: "metadata",
              dataType: "source",
              sourceId: e
            })), i.setEventedParent(null), i.onRemove(this.map), this._changed = !0
          }
          setGeoJSONSourceData(e, i) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const l = this.sourceCaches[e].getSource();
            if (l.type !== "geojson") throw new Error(`geojsonSource.type is ${l.type}, which is !== 'geojson`);
            l.setData(i), this._changed = !0
          }
          getSource(e) {
            return this.sourceCaches[e] && this.sourceCaches[e].getSource()
          }
          addLayer(e, i, l = {}) {
            this._checkLoaded();
            const u = e.id;
            if (this.getLayer(u)) return void this.fire(new s.k(new Error(`Layer "${u}" already exists on this map.`)));
            let f;
            if (e.type === "custom") {
              if (Pl(this, s.bM(e))) return;
              f = s.bJ(e)
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(u, e.source), e = s.bK(e), e = s.e(e, {
                  source: u
                })), this._validate(s.z.layer, `layers.${u}`, e, {
                  arrayIndex: -1
                }, l)) return;
              f = s.bJ(e), this._validateLayer(f), f.setEventedParent(this, {
                layer: {
                  id: u
                }
              })
            }
            const g = i ? this._order.indexOf(i) : this._order.length;
            if (i && g === -1) this.fire(new s.k(new Error(`Cannot add layer "${u}" before non-existing layer "${i}".`)));
            else {
              if (this._order.splice(g, 0, u), this._layerOrderChanged = !0, this._layers[u] = f, this._removedLayers[u] && f.source && f.type !== "custom") {
                const C = this._removedLayers[u];
                delete this._removedLayers[u], C.type !== f.type ? this._updatedSources[f.source] = "clear" : (this._updatedSources[f.source] = "reload", this.sourceCaches[f.source].pause())
              }
              this._updateLayer(f), f.onAdd && f.onAdd(this.map)
            }
          }
          moveLayer(e, i) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new s.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === i) return;
            const l = this._order.indexOf(e);
            this._order.splice(l, 1);
            const u = i ? this._order.indexOf(i) : this._order.length;
            i && u === -1 ? this.fire(new s.k(new Error(`Cannot move layer "${e}" before non-existing layer "${i}".`))) : (this._order.splice(u, 0, e), this._layerOrderChanged = !0)
          }
          removeLayer(e) {
            this._checkLoaded();
            const i = this._layers[e];
            if (!i) return void this.fire(new s.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            i.setEventedParent(null);
            const l = this._order.indexOf(e);
            this._order.splice(l, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = i, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], i.onRemove && i.onRemove(this.map)
          }
          getLayer(e) {
            return this._layers[e]
          }
          getLayersOrder() {
            return [...this._order]
          }
          hasLayer(e) {
            return e in this._layers
          }
          setLayerZoomRange(e, i, l) {
            this._checkLoaded();
            const u = this.getLayer(e);
            u ? u.minzoom === i && u.maxzoom === l || (i != null && (u.minzoom = i), l != null && (u.maxzoom = l), this._updateLayer(u)) : this.fire(new s.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
          }
          setFilter(e, i, l = {}) {
            this._checkLoaded();
            const u = this.getLayer(e);
            if (u) {
              if (!s.bH(u.filter, i)) return i == null ? (u.setFilter(void 0), void this._updateLayer(u)) : void(this._validate(s.z.filter, `layers.${u.id}.filter`, i, null, l) || (u.setFilter(s.bK(i)), this._updateLayer(u)))
            } else this.fire(new s.k(new Error(`Cannot filter non-existing layer "${e}".`)))
          }
          getFilter(e) {
            return s.bK(this.getLayer(e).filter)
          }
          setLayoutProperty(e, i, l, u = {}) {
            this._checkLoaded();
            const f = this.getLayer(e);
            f ? s.bH(f.getLayoutProperty(i), l) || (f.setLayoutProperty(i, l, u), this._updateLayer(f)) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getLayoutProperty(e, i) {
            const l = this.getLayer(e);
            if (l) return l.getLayoutProperty(i);
            this.fire(new s.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
          }
          setPaintProperty(e, i, l, u = {}) {
            this._checkLoaded();
            const f = this.getLayer(e);
            f ? s.bH(f.getPaintProperty(i), l) || (f.setPaintProperty(i, l, u) && this._updateLayer(f), this._changed = !0, this._updatedPaintProps[e] = !0, this._serializedLayers = null) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getPaintProperty(e, i) {
            return this.getLayer(e).getPaintProperty(i)
          }
          setFeatureState(e, i) {
            this._checkLoaded();
            const l = e.source,
              u = e.sourceLayer,
              f = this.sourceCaches[l];
            if (f === void 0) return void this.fire(new s.k(new Error(`The source '${l}' does not exist in the map's style.`)));
            const g = f.getSource().type;
            g === "geojson" && u ? this.fire(new s.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : g !== "vector" || u ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), f.setFeatureState(u, e.id, i)) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          removeFeatureState(e, i) {
            this._checkLoaded();
            const l = e.source,
              u = this.sourceCaches[l];
            if (u === void 0) return void this.fire(new s.k(new Error(`The source '${l}' does not exist in the map's style.`)));
            const f = u.getSource().type,
              g = f === "vector" ? e.sourceLayer : void 0;
            f !== "vector" || g ? i && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new s.k(new Error("A feature id is required to remove its specific state property."))) : u.removeFeatureState(g, e.id, i) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          getFeatureState(e) {
            this._checkLoaded();
            const i = e.source,
              l = e.sourceLayer,
              u = this.sourceCaches[i];
            if (u !== void 0) return u.getSource().type !== "vector" || l ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), u.getFeatureState(l, e.id)) : void this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new s.k(new Error(`The source '${i}' does not exist in the map's style.`)))
          }
          getTransition() {
            return s.e({
              duration: 300,
              delay: 0
            }, this.stylesheet && this.stylesheet.transition)
          }
          serialize() {
            if (!this._loaded) return;
            const e = s.bN(this.sourceCaches, (f => f.serialize())),
              i = this._serializeByIds(this._order, !0),
              l = this.map.getTerrain() || void 0,
              u = this.stylesheet;
            return s.bO({
              version: u.version,
              name: u.name,
              metadata: u.metadata,
              light: u.light,
              sky: u.sky,
              center: u.center,
              zoom: u.zoom,
              bearing: u.bearing,
              pitch: u.pitch,
              sprite: u.sprite,
              glyphs: u.glyphs,
              transition: u.transition,
              projection: u.projection,
              sources: e,
              layers: i,
              terrain: l
            }, (f => f !== void 0))
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0
          }
          _flattenAndSortRenderedFeatures(e) {
            const i = g => this._layers[g].type === "fill-extrusion",
              l = {},
              u = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const C = this._order[g];
              if (i(C)) {
                l[C] = g;
                for (const T of e) {
                  const M = T[C];
                  if (M)
                    for (const z of M) u.push(z)
                }
              }
            }
            u.sort(((g, C) => C.intersectionZ - g.intersectionZ));
            const f = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const C = this._order[g];
              if (i(C))
                for (let T = u.length - 1; T >= 0; T--) {
                  const M = u[T].feature;
                  if (l[M.layer.id] < g) break;
                  f.push(M), u.pop()
                } else
                  for (const T of e) {
                    const M = T[C];
                    if (M)
                      for (const z of M) f.push(z.feature)
                  }
            }
            return f
          }
          queryRenderedFeatures(e, i, l) {
            i && i.filter && this._validate(s.z.filter, "queryRenderedFeatures.filter", i.filter, null, i);
            const u = {};
            if (i && i.layers) {
              if (!(Array.isArray(i.layers) || i.layers instanceof Set)) return this.fire(new s.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const M of i.layers) {
                const z = this._layers[M];
                if (!z) return this.fire(new s.k(new Error(`The layer '${M}' does not exist in the map's style and cannot be queried for features.`))), [];
                u[z.source] = !0
              }
            }
            const f = [];
            i.availableImages = this._availableImages;
            const g = this._serializedAllLayers(),
              C = i.layers instanceof Set ? i.layers : Array.isArray(i.layers) ? new Set(i.layers) : null,
              T = Object.assign(Object.assign({}, i), {
                layers: C
              });
            for (const M in this.sourceCaches) i.layers && !u[M] || f.push(gt(this.sourceCaches[M], this._layers, g, e, T, l, this.map.terrain ? (z, R, D) => this.map.terrain.getElevation(z, R, D) : void 0));
            return this.placement && f.push((function(M, z, R, D, N, H, ie) {
              const ne = {},
                se = H.queryRenderedSymbols(D),
                pe = [];
              for (const ye of Object.keys(se).map(Number)) pe.push(ie[ye]);
              pe.sort(St);
              for (const ye of pe) {
                const ge = ye.featureIndex.lookupSymbolFeatures(se[ye.bucketInstanceId], z, ye.bucketIndex, ye.sourceLayerIndex, N.filter, N.layers, N.availableImages, M);
                for (const Te in ge) {
                  const Le = ne[Te] = ne[Te] || [],
                    ve = ge[Te];
                  ve.sort(((Ne, st) => {
                    const Xe = ye.featureSortOrder;
                    if (Xe) {
                      const Qe = Xe.indexOf(Ne.featureIndex);
                      return Xe.indexOf(st.featureIndex) - Qe
                    }
                    return st.featureIndex - Ne.featureIndex
                  }));
                  for (const Ne of ve) Le.push(Ne)
                }
              }
              return (function(ye, ge, Te) {
                for (const Le in ye)
                  for (const ve of ye[Le]) vt(ve, Te[ge[Le].source]);
                return ye
              })(ne, M, R)
            })(this._layers, g, this.sourceCaches, e, T, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(f)
          }
          querySourceFeatures(e, i) {
            i && i.filter && this._validate(s.z.filter, "querySourceFeatures.filter", i.filter, null, i);
            const l = this.sourceCaches[e];
            return l ? (function(u, f) {
              const g = u.getRenderableIds().map((M => u.getTileByID(M))),
                C = [],
                T = {};
              for (let M = 0; M < g.length; M++) {
                const z = g[M],
                  R = z.tileID.canonical.key;
                T[R] || (T[R] = !0, z.querySourceFeatures(C, f))
              }
              return C
            })(l, i) : []
          }
          getLight() {
            return this.light.getLight()
          }
          setLight(e, i = {}) {
            this._checkLoaded();
            const l = this.light.getLight();
            let u = !1;
            for (const g in e)
              if (!s.bH(e[g], l[g])) {
                u = !0;
                break
              } if (!u) return;
            const f = {
              now: Q.now(),
              transition: s.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.light.setLight(e, i), this.light.updateTransitions(f)
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type)
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
          }
          setSky(e, i = {}) {
            this._checkLoaded();
            const l = this.getSky();
            let u = !1;
            if (!e && !l) return;
            if (e && !l) u = !0;
            else if (!e && l) u = !0;
            else
              for (const g in e)
                if (!s.bH(e[g], l[g])) {
                  u = !0;
                  break
                } if (!u) return;
            const f = {
              now: Q.now(),
              transition: s.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.stylesheet.sky = e, this.sky.setSky(e, i), this.sky.updateTransitions(f)
          }
          _setProjectionInternal(e) {
            const i = (function(l) {
              if (Array.isArray(l)) {
                const u = new Fo({
                  type: l
                });
                return {
                  projection: u,
                  transform: new $s,
                  cameraHelper: new Hh(u)
                }
              }
              switch (l) {
                case "mercator":
                  return {
                    projection: new kr, transform: new Jr, cameraHelper: new pn
                  };
                case "globe": {
                  const u = new Fo({
                    type: ["interpolate", ["linear"],
                      ["zoom"], 11, "vertical-perspective", 12, "mercator"
                    ]
                  });
                  return {
                    projection: u,
                    transform: new $s,
                    cameraHelper: new Hh(u)
                  }
                }
                case "vertical-perspective":
                  return {
                    projection: new eo, transform: new Us, cameraHelper: new Fi
                  };
                default:
                  return s.w(`Unknown projection name: ${l}. Falling back to mercator projection.`), {
                    projection: new kr,
                    transform: new Jr,
                    cameraHelper: new pn
                  }
              }
            })(e);
            this.projection = i.projection, this.map.migrateProjection(i.transform, i.cameraHelper);
            for (const l in this.sourceCaches) this.sourceCaches[l].reload()
          }
          _validate(e, i, l, u, f = {}) {
            return (!f || f.validate !== !1) && Pl(this, e.call(s.z, s.e({
              key: i,
              style: this.serialize(),
              value: l,
              styleSpec: s.v
            }, u)))
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Vr().off(dr, this._rtlPluginLoaded);
            for (const i in this._layers) this._layers[i].setEventedParent(null);
            for (const i in this.sourceCaches) {
              const l = this.sourceCaches[i];
              l.setEventedParent(null), l.onRemove(this.map)
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e)
          }
          _clearSource(e) {
            this.sourceCaches[e].clearTiles()
          }
          _reloadSource(e) {
            this.sourceCaches[e].resume(), this.sourceCaches[e].reload()
          }
          _updateSources(e) {
            for (const i in this.sourceCaches) this.sourceCaches[i].update(e, this.map.terrain)
          }
          _generateCollisionBoxes() {
            for (const e in this.sourceCaches) this._reloadSource(e)
          }
          _updatePlacement(e, i, l, u, f = !1) {
            let g = !1,
              C = !1;
            const T = {};
            for (const M of this._order) {
              const z = this._layers[M];
              if (z.type !== "symbol") continue;
              if (!T[z.source]) {
                const D = this.sourceCaches[z.source];
                T[z.source] = D.getRenderableIds(!0).map((N => D.getTileByID(N))).sort(((N, H) => H.tileID.overscaledZ - N.tileID.overscaledZ || (N.tileID.isLessThan(H.tileID) ? -1 : 1)))
              }
              const R = this.crossTileSymbolIndex.addLayer(z, T[z.source], e.center.lng);
              g = g || R
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((f = f || this._layerOrderChanged || l === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(Q.now(), e.zoom)) && (this.pauseablePlacement = new da(e, this.map.terrain, this._order, f, i, l, u, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, T), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(Q.now()), C = !0), g && this.pauseablePlacement.placement.setStale()), C || g)
              for (const M of this._order) {
                const z = this._layers[M];
                z.type === "symbol" && this.placement.updateLayerOpacities(z, T[z.source])
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(Q.now())
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles()
          }
          getImages(e, i) {
            return s._(this, void 0, void 0, (function*() {
              const l = yield this.imageManager.getImages(i.icons);
              this._updateTilesForChangedImages();
              const u = this.sourceCaches[i.source];
              return u && u.setDependencies(i.tileID.key, i.type, i.icons), l
            }))
          }
          getGlyphs(e, i) {
            return s._(this, void 0, void 0, (function*() {
              const l = yield this.glyphManager.getGlyphs(i.stacks), u = this.sourceCaches[i.source];
              return u && u.setDependencies(i.tileID.key, i.type, [""]), l
            }))
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null
          }
          setGlyphs(e, i = {}) {
            this._checkLoaded(), e && this._validate(s.z.glyphs, "glyphs", e, null, i) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e))
          }
          addSprite(e, i, l = {}, u) {
            this._checkLoaded();
            const f = [{
                id: e,
                url: i
              }],
              g = [...tt(this.stylesheet.sprite), ...f];
            this._validate(s.z.sprite, "sprite", g, null, l) || (this.stylesheet.sprite = g, this._loadSprite(f, !0, u))
          }
          removeSprite(e) {
            this._checkLoaded();
            const i = tt(this.stylesheet.sprite);
            if (i.find((l => l.id === e))) {
              if (this._spritesImagesIds[e])
                for (const l of this._spritesImagesIds[e]) this.imageManager.removeImage(l), this._changedImages[l] = !0;
              i.splice(i.findIndex((l => l.id === e)), 1), this.stylesheet.sprite = i.length > 0 ? i : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
                dataType: "style"
              }))
            } else this.fire(new s.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
          }
          getSprite() {
            return tt(this.stylesheet.sprite)
          }
          setSprite(e, i = {}, l) {
            this._checkLoaded(), e && this._validate(s.z.sprite, "sprite", e, null, i) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, l) : (this._unloadSprite(), l && l(null)))
          }
        }
        var Np = s.aJ([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }, {
          name: "a_texture_pos",
          type: "Int16",
          components: 2
        }]);
        class Zp {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null
          }
          bind(e, i, l, u, f, g, C, T, M) {
            this.context = e;
            let z = this.boundPaintVertexBuffers.length !== u.length;
            for (let R = 0; !z && R < u.length; R++) this.boundPaintVertexBuffers[R] !== u[R] && (z = !0);
            !this.vao || this.boundProgram !== i || this.boundLayoutVertexBuffer !== l || z || this.boundIndexBuffer !== f || this.boundVertexOffset !== g || this.boundDynamicVertexBuffer !== C || this.boundDynamicVertexBuffer2 !== T || this.boundDynamicVertexBuffer3 !== M ? this.freshBind(i, l, u, f, g, C, T, M) : (e.bindVertexArray.set(this.vao), C && C.bind(), f && f.dynamicDraw && f.bind(), T && T.bind(), M && M.bind())
          }
          freshBind(e, i, l, u, f, g, C, T) {
            const M = e.numAttributes,
              z = this.context,
              R = z.gl;
            this.vao && this.destroy(), this.vao = z.createVertexArray(), z.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = i, this.boundPaintVertexBuffers = l, this.boundIndexBuffer = u, this.boundVertexOffset = f, this.boundDynamicVertexBuffer = g, this.boundDynamicVertexBuffer2 = C, this.boundDynamicVertexBuffer3 = T, i.enableAttributes(R, e);
            for (const D of l) D.enableAttributes(R, e);
            g && g.enableAttributes(R, e), C && C.enableAttributes(R, e), T && T.enableAttributes(R, e), i.bind(), i.setVertexAttribPointers(R, e, f);
            for (const D of l) D.bind(), D.setVertexAttribPointers(R, e, f);
            g && (g.bind(), g.setVertexAttribPointers(R, e, f)), u && u.bind(), C && (C.bind(), C.setVertexAttribPointers(R, e, f)), T && (T.bind(), T.setVertexAttribPointers(R, e, f)), z.currentNumAttributes = M
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null)
          }
        }
        const kl = (p, e, i, l, u) => ({
            u_texture: 0,
            u_ele_delta: p,
            u_fog_matrix: e,
            u_fog_color: i ? i.properties.get("fog-color") : s.bf.white,
            u_fog_ground_blend: i ? i.properties.get("fog-ground-blend") : 1,
            u_fog_ground_blend_opacity: u ? 0 : i ? i.calculateFogBlendOpacity(l) : 0,
            u_horizon_color: i ? i.properties.get("horizon-color") : s.bf.white,
            u_horizon_fog_blend: i ? i.properties.get("horizon-fog-blend") : 1,
            u_is_globe_mode: u ? 1 : 0
          }),
          Nc = {
            mainMatrix: "u_projection_matrix",
            tileMercatorCoords: "u_projection_tile_mercator_coords",
            clippingPlane: "u_projection_clipping_plane",
            projectionTransition: "u_projection_transition",
            fallbackMatrix: "u_projection_fallback_matrix"
          };

        function jo(p) {
          const e = [];
          for (let i = 0; i < p.length; i++) {
            if (p[i] === null) continue;
            const l = p[i].split(" ");
            e.push(l.pop())
          }
          return e
        }
        class Zc {
          constructor(e, i, l, u, f, g, C, T, M = []) {
            const z = e.gl;
            this.program = z.createProgram();
            const R = jo(i.staticAttributes),
              D = l ? l.getBinderAttributes() : [],
              N = R.concat(D),
              H = Kt.prelude.staticUniforms ? jo(Kt.prelude.staticUniforms) : [],
              ie = C.staticUniforms ? jo(C.staticUniforms) : [],
              ne = i.staticUniforms ? jo(i.staticUniforms) : [],
              se = l ? l.getBinderUniforms() : [],
              pe = H.concat(ie).concat(ne).concat(se),
              ye = [];
            for (const Xe of pe) ye.indexOf(Xe) < 0 && ye.push(Xe);
            const ge = l ? l.defines() : [];
            qn(z) && ge.unshift("#version 300 es"), f && ge.push("#define OVERDRAW_INSPECTOR;"), g && ge.push("#define TERRAIN3D;"), T && ge.push(T), M && ge.push(...M);
            let Te = ge.concat(Kt.prelude.fragmentSource, C.fragmentSource, i.fragmentSource).join(`
`),
              Le = ge.concat(Kt.prelude.vertexSource, C.vertexSource, i.vertexSource).join(`
`);
            qn(z) || (Te = (function(Xe) {
              return Xe.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
            })(Te), Le = (function(Xe) {
              return Xe.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
            })(Le));
            const ve = z.createShader(z.FRAGMENT_SHADER);
            if (z.isContextLost()) return void(this.failedToCreate = !0);
            if (z.shaderSource(ve, Te), z.compileShader(ve), !z.getShaderParameter(ve, z.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${z.getShaderInfoLog(ve)}`);
            z.attachShader(this.program, ve);
            const Ne = z.createShader(z.VERTEX_SHADER);
            if (z.isContextLost()) return void(this.failedToCreate = !0);
            if (z.shaderSource(Ne, Le), z.compileShader(Ne), !z.getShaderParameter(Ne, z.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${z.getShaderInfoLog(Ne)}`);
            z.attachShader(this.program, Ne), this.attributes = {};
            const st = {};
            this.numAttributes = N.length;
            for (let Xe = 0; Xe < this.numAttributes; Xe++) N[Xe] && (z.bindAttribLocation(this.program, Xe, N[Xe]), this.attributes[N[Xe]] = Xe);
            if (z.linkProgram(this.program), !z.getProgramParameter(this.program, z.LINK_STATUS)) throw new Error(`Program failed to link: ${z.getProgramInfoLog(this.program)}`);
            z.deleteShader(Ne), z.deleteShader(ve);
            for (let Xe = 0; Xe < ye.length; Xe++) {
              const Qe = ye[Xe];
              if (Qe && !st[Qe]) {
                const at = z.getUniformLocation(this.program, Qe);
                at && (st[Qe] = at)
              }
            }
            this.fixedUniforms = u(e, st), this.terrainUniforms = ((Xe, Qe) => ({
              u_depth: new s.bP(Xe, Qe.u_depth),
              u_terrain: new s.bP(Xe, Qe.u_terrain),
              u_terrain_dim: new s.bg(Xe, Qe.u_terrain_dim),
              u_terrain_matrix: new s.bR(Xe, Qe.u_terrain_matrix),
              u_terrain_unpack: new s.bS(Xe, Qe.u_terrain_unpack),
              u_terrain_exaggeration: new s.bg(Xe, Qe.u_terrain_exaggeration)
            }))(e, st), this.projectionUniforms = ((Xe, Qe) => ({
              u_projection_matrix: new s.bR(Xe, Qe.u_projection_matrix),
              u_projection_tile_mercator_coords: new s.bS(Xe, Qe.u_projection_tile_mercator_coords),
              u_projection_clipping_plane: new s.bS(Xe, Qe.u_projection_clipping_plane),
              u_projection_transition: new s.bg(Xe, Qe.u_projection_transition),
              u_projection_fallback_matrix: new s.bR(Xe, Qe.u_projection_fallback_matrix)
            }))(e, st), this.binderUniforms = l ? l.getUniforms(e, st) : []
          }
          draw(e, i, l, u, f, g, C, T, M, z, R, D, N, H, ie, ne, se, pe, ye) {
            const ge = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(l), e.setStencilMode(u), e.setColorMode(f), e.setCullFace(g), T) {
              e.activeTexture.set(ge.TEXTURE2), ge.bindTexture(ge.TEXTURE_2D, T.depthTexture), e.activeTexture.set(ge.TEXTURE3), ge.bindTexture(ge.TEXTURE_2D, T.texture);
              for (const Le in this.terrainUniforms) this.terrainUniforms[Le].set(T[Le])
            }
            if (M)
              for (const Le in M) this.projectionUniforms[Nc[Le]].set(M[Le]);
            if (C)
              for (const Le in this.fixedUniforms) this.fixedUniforms[Le].set(C[Le]);
            ne && ne.setUniforms(e, this.binderUniforms, H, {
              zoom: ie
            });
            let Te = 0;
            switch (i) {
              case ge.LINES:
                Te = 2;
                break;
              case ge.TRIANGLES:
                Te = 3;
                break;
              case ge.LINE_STRIP:
                Te = 1
            }
            for (const Le of N.get()) {
              const ve = Le.vaos || (Le.vaos = {});
              (ve[z] || (ve[z] = new Zp)).bind(e, this, R, ne ? ne.getPaintVertexBuffers() : [], D, Le.vertexOffset, se, pe, ye), ge.drawElements(i, Le.primitiveLength * Te, ge.UNSIGNED_SHORT, Le.primitiveOffset * Te * 2)
            }
          }
        }

        function Ml(p, e, i) {
          const l = 1 / s.aC(i, 1, e.transform.tileZoom),
            u = Math.pow(2, i.tileID.overscaledZ),
            f = i.tileSize * Math.pow(2, e.transform.tileZoom) / u,
            g = f * (i.tileID.canonical.x + i.tileID.wrap * u),
            C = f * i.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: i.imageAtlasTexture.size,
            u_scale: [l, p.fromScale, p.toScale],
            u_fade: p.t,
            u_pixel_coord_upper: [g >> 16, C >> 16],
            u_pixel_coord_lower: [65535 & g, 65535 & C]
          }
        }
        const Ta = (p, e, i, l) => {
            const u = p.style.light,
              f = u.properties.get("position"),
              g = [f.x, f.y, f.z],
              C = s.bV();
            u.properties.get("anchor") === "viewport" && s.bW(C, p.transform.bearingInRadians), s.bX(g, g, C);
            const T = p.transform.transformLightDirection(g),
              M = u.properties.get("color");
            return {
              u_lightpos: g,
              u_lightpos_globe: T,
              u_lightintensity: u.properties.get("intensity"),
              u_lightcolor: [M.r, M.g, M.b],
              u_vertical_gradient: +e,
              u_opacity: i,
              u_fill_translate: l
            }
          },
          Vp = (p, e, i, l, u, f, g) => s.e(Ta(p, e, i, l), Ml(f, p, g), {
            u_height_factor: -Math.pow(2, u.overscaledZ) / g.tileSize / 8
          }),
          Al = (p, e, i, l) => s.e(Ml(e, p, i), {
            u_fill_translate: l
          }),
          Gs = (p, e) => ({
            u_world: p,
            u_fill_translate: e
          }),
          Ws = (p, e, i, l, u) => s.e(Al(p, e, i, u), {
            u_world: l
          }),
          qp = (p, e, i, l, u) => {
            const f = p.transform;
            let g, C, T = 0;
            if (i.paint.get("circle-pitch-alignment") === "map") {
              const M = s.aC(e, 1, f.zoom);
              g = !0, C = [M, M], T = M / (s.$ * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * u
            } else g = !1, C = f.pixelsToGLUnits;
            return {
              u_camera_to_center_distance: f.cameraToCenterDistance,
              u_scale_with_map: +(i.paint.get("circle-pitch-scale") === "map"),
              u_pitch_with_map: +g,
              u_device_pixel_ratio: p.pixelRatio,
              u_extrude_scale: C,
              u_globe_extrude_scale: T,
              u_translate: l
            }
          },
          El = p => ({
            u_pixel_extrude_scale: [1 / p.width, 1 / p.height]
          }),
          Up = p => ({
            u_viewport_size: [p.width, p.height]
          }),
          No = (p, e = 1) => ({
            u_color: p,
            u_overlay: 0,
            u_overlay_scale: e
          }),
          Jh = (p, e, i, l) => {
            const u = s.aC(p, 1, e) / (s.$ * Math.pow(2, p.tileID.overscaledZ)) * 2 * Math.PI * l;
            return {
              u_extrude_scale: s.aC(p, 1, e),
              u_intensity: i,
              u_globe_extrude_scale: u
            }
          },
          Vc = (p, e, i, l) => {
            const u = s.L();
            s.bY(u, 0, p.width, p.height, 0, 0, 1);
            const f = p.context.gl;
            return {
              u_matrix: u,
              u_world: [f.drawingBufferWidth, f.drawingBufferHeight],
              u_image: i,
              u_color_ramp: l,
              u_opacity: e.paint.get("heatmap-opacity")
            }
          },
          $p = (p, e, i) => {
            const l = i.paint.get("hillshade-accent-color");
            let u;
            switch (i.paint.get("hillshade-method")) {
              case "basic":
                u = 4;
                break;
              case "combined":
                u = 1;
                break;
              case "igor":
                u = 2;
                break;
              case "multidirectional":
                u = 3;
                break;
              default:
                u = 0
            }
            const f = i.getIlluminationProperties();
            for (let g = 0; g < f.directionRadians.length; g++) i.paint.get("hillshade-illumination-anchor") === "viewport" && (f.directionRadians[g] += p.transform.bearingInRadians);
            return {
              u_image: 0,
              u_latrange: qc(0, e.tileID),
              u_exaggeration: i.paint.get("hillshade-exaggeration"),
              u_altitudes: f.altitudeRadians,
              u_azimuths: f.directionRadians,
              u_accent: l,
              u_method: u,
              u_highlights: f.highlightColor,
              u_shadows: f.shadowColor
            }
          },
          Xh = (p, e) => {
            const i = e.stride,
              l = s.L();
            return s.bY(l, 0, s.$, -s.$, 0, 0, 1), s.M(l, l, [0, -s.$, 0]), {
              u_matrix: l,
              u_image: 1,
              u_dimension: [i, i],
              u_zoom: p.overscaledZ,
              u_unpack: e.getUnpackVector()
            }
          };

        function qc(p, e) {
          const i = Math.pow(2, e.canonical.z),
            l = e.canonical.y;
          return [new s.a1(0, l / i).toLngLat().lat, new s.a1(0, (l + 1) / i).toLngLat().lat]
        }
        const Yh = (p, e, i = 0) => ({
            u_image: 0,
            u_unpack: e.getUnpackVector(),
            u_dimension: [e.stride, e.stride],
            u_elevation_stops: 1,
            u_color_stops: 4,
            u_color_ramp_size: i,
            u_opacity: p.paint.get("color-relief-opacity")
          }),
          zl = (p, e, i, l) => {
            const u = p.transform;
            return {
              u_translation: $c(p, e, i),
              u_ratio: l / s.aC(e, 1, u.zoom),
              u_device_pixel_ratio: p.pixelRatio,
              u_units_to_pixels: [1 / u.pixelsToGLUnits[0], 1 / u.pixelsToGLUnits[1]]
            }
          },
          Kh = (p, e, i, l, u) => s.e(zl(p, e, i, l), {
            u_image: 0,
            u_image_height: u
          }),
          Qh = (p, e, i, l, u) => {
            const f = p.transform,
              g = Uc(e, f);
            return {
              u_translation: $c(p, e, i),
              u_texsize: e.imageAtlasTexture.size,
              u_ratio: l / s.aC(e, 1, f.zoom),
              u_device_pixel_ratio: p.pixelRatio,
              u_image: 0,
              u_scale: [g, u.fromScale, u.toScale],
              u_fade: u.t,
              u_units_to_pixels: [1 / f.pixelsToGLUnits[0], 1 / f.pixelsToGLUnits[1]]
            }
          },
          Zo = (p, e, i, l, u, f) => {
            const g = p.lineAtlas,
              C = Uc(e, p.transform),
              T = i.layout.get("line-cap") === "round",
              M = g.getDash(u.from, T),
              z = g.getDash(u.to, T),
              R = M.width * f.fromScale,
              D = z.width * f.toScale;
            return s.e(zl(p, e, i, l), {
              u_patternscale_a: [C / R, -M.height / 2],
              u_patternscale_b: [C / D, -z.height / 2],
              u_sdfgamma: g.width / (256 * Math.min(R, D) * p.pixelRatio) / 2,
              u_image: 0,
              u_tex_y_a: M.y,
              u_tex_y_b: z.y,
              u_mix: f.t
            })
          };

        function Uc(p, e) {
          return 1 / s.aC(p, 1, e.tileZoom)
        }

        function $c(p, e, i) {
          return s.aD(p.transform, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"))
        }
        const Hs = (p, e, i, l, u) => {
          return {
            u_tl_parent: p,
            u_scale_parent: e,
            u_buffer_scale: 1,
            u_fade_t: i.mix,
            u_opacity: i.opacity * l.paint.get("raster-opacity"),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: l.paint.get("raster-brightness-min"),
            u_brightness_high: l.paint.get("raster-brightness-max"),
            u_saturation_factor: (g = l.paint.get("raster-saturation"), g > 0 ? 1 - 1 / (1.001 - g) : -g),
            u_contrast_factor: (f = l.paint.get("raster-contrast"), f > 0 ? 1 / (1 - f) : 1 + f),
            u_spin_weights: Gp(l.paint.get("raster-hue-rotate")),
            u_coords_top: [u[0].x, u[0].y, u[1].x, u[1].y],
            u_coords_bottom: [u[3].x, u[3].y, u[2].x, u[2].y]
          };
          var f, g
        };

        function Gp(p) {
          p *= Math.PI / 180;
          const e = Math.sin(p),
            i = Math.cos(p);
          return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3]
        }
        const Js = (p, e, i, l, u, f, g, C, T, M, z, R, D) => {
            const N = g.transform;
            return {
              u_is_size_zoom_constant: +(p === "constant" || p === "source"),
              u_is_size_feature_constant: +(p === "constant" || p === "camera"),
              u_size_t: e ? e.uSizeT : 0,
              u_size: e ? e.uSize : 0,
              u_camera_to_center_distance: N.cameraToCenterDistance,
              u_pitch: N.pitch / 360 * 2 * Math.PI,
              u_rotate_symbol: +i,
              u_aspect_ratio: N.width / N.height,
              u_fade_change: g.options.fadeDuration ? g.symbolFadeChange : 1,
              u_label_plane_matrix: C,
              u_coord_matrix: T,
              u_is_text: +z,
              u_pitch_with_map: +l,
              u_is_along_line: u,
              u_is_variable_anchor: f,
              u_texsize: R,
              u_texture: 0,
              u_translation: M,
              u_pitched_scale: D
            }
          },
          ed = (p, e, i, l, u, f, g, C, T, M, z, R, D, N) => {
            const H = g.transform;
            return s.e(Js(p, e, i, l, u, f, g, C, T, M, z, R, N), {
              u_gamma_scale: l ? Math.cos(H.pitch * Math.PI / 180) * H.cameraToCenterDistance : 1,
              u_device_pixel_ratio: g.pixelRatio,
              u_is_halo: 1
            })
          },
          Wp = (p, e, i, l, u, f, g, C, T, M, z, R, D) => s.e(ed(p, e, i, l, u, f, g, C, T, M, !0, z, 0, D), {
            u_texsize_icon: R,
            u_texture_icon: 1
          }),
          td = (p, e) => ({
            u_opacity: p,
            u_color: e
          }),
          rd = (p, e, i, l, u) => s.e((function(f, g, C, T) {
            const M = C.imageManager.getPattern(f.from.toString()),
              z = C.imageManager.getPattern(f.to.toString()),
              {
                width: R,
                height: D
              } = C.imageManager.getPixelSize(),
              N = Math.pow(2, T.tileID.overscaledZ),
              H = T.tileSize * Math.pow(2, C.transform.tileZoom) / N,
              ie = H * (T.tileID.canonical.x + T.tileID.wrap * N),
              ne = H * T.tileID.canonical.y;
            return {
              u_image: 0,
              u_pattern_tl_a: M.tl,
              u_pattern_br_a: M.br,
              u_pattern_tl_b: z.tl,
              u_pattern_br_b: z.br,
              u_texsize: [R, D],
              u_mix: g.t,
              u_pattern_size_a: M.displaySize,
              u_pattern_size_b: z.displaySize,
              u_scale_a: g.fromScale,
              u_scale_b: g.toScale,
              u_tile_units_to_pixels: 1 / s.aC(T, 1, C.transform.tileZoom),
              u_pixel_coord_upper: [ie >> 16, ne >> 16],
              u_pixel_coord_lower: [65535 & ie, 65535 & ne]
            }
          })(i, u, e, l), {
            u_opacity: p
          }),
          Gc = (p, e) => {},
          Wc = {
            fillExtrusion: (p, e) => ({
              u_lightpos: new s.bT(p, e.u_lightpos),
              u_lightpos_globe: new s.bT(p, e.u_lightpos_globe),
              u_lightintensity: new s.bg(p, e.u_lightintensity),
              u_lightcolor: new s.bT(p, e.u_lightcolor),
              u_vertical_gradient: new s.bg(p, e.u_vertical_gradient),
              u_opacity: new s.bg(p, e.u_opacity),
              u_fill_translate: new s.bU(p, e.u_fill_translate)
            }),
            fillExtrusionPattern: (p, e) => ({
              u_lightpos: new s.bT(p, e.u_lightpos),
              u_lightpos_globe: new s.bT(p, e.u_lightpos_globe),
              u_lightintensity: new s.bg(p, e.u_lightintensity),
              u_lightcolor: new s.bT(p, e.u_lightcolor),
              u_vertical_gradient: new s.bg(p, e.u_vertical_gradient),
              u_height_factor: new s.bg(p, e.u_height_factor),
              u_opacity: new s.bg(p, e.u_opacity),
              u_fill_translate: new s.bU(p, e.u_fill_translate),
              u_image: new s.bP(p, e.u_image),
              u_texsize: new s.bU(p, e.u_texsize),
              u_pixel_coord_upper: new s.bU(p, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bU(p, e.u_pixel_coord_lower),
              u_scale: new s.bT(p, e.u_scale),
              u_fade: new s.bg(p, e.u_fade)
            }),
            fill: (p, e) => ({
              u_fill_translate: new s.bU(p, e.u_fill_translate)
            }),
            fillPattern: (p, e) => ({
              u_image: new s.bP(p, e.u_image),
              u_texsize: new s.bU(p, e.u_texsize),
              u_pixel_coord_upper: new s.bU(p, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bU(p, e.u_pixel_coord_lower),
              u_scale: new s.bT(p, e.u_scale),
              u_fade: new s.bg(p, e.u_fade),
              u_fill_translate: new s.bU(p, e.u_fill_translate)
            }),
            fillOutline: (p, e) => ({
              u_world: new s.bU(p, e.u_world),
              u_fill_translate: new s.bU(p, e.u_fill_translate)
            }),
            fillOutlinePattern: (p, e) => ({
              u_world: new s.bU(p, e.u_world),
              u_image: new s.bP(p, e.u_image),
              u_texsize: new s.bU(p, e.u_texsize),
              u_pixel_coord_upper: new s.bU(p, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bU(p, e.u_pixel_coord_lower),
              u_scale: new s.bT(p, e.u_scale),
              u_fade: new s.bg(p, e.u_fade),
              u_fill_translate: new s.bU(p, e.u_fill_translate)
            }),
            circle: (p, e) => ({
              u_camera_to_center_distance: new s.bg(p, e.u_camera_to_center_distance),
              u_scale_with_map: new s.bP(p, e.u_scale_with_map),
              u_pitch_with_map: new s.bP(p, e.u_pitch_with_map),
              u_extrude_scale: new s.bU(p, e.u_extrude_scale),
              u_device_pixel_ratio: new s.bg(p, e.u_device_pixel_ratio),
              u_globe_extrude_scale: new s.bg(p, e.u_globe_extrude_scale),
              u_translate: new s.bU(p, e.u_translate)
            }),
            collisionBox: (p, e) => ({
              u_pixel_extrude_scale: new s.bU(p, e.u_pixel_extrude_scale)
            }),
            collisionCircle: (p, e) => ({
              u_viewport_size: new s.bU(p, e.u_viewport_size)
            }),
            debug: (p, e) => ({
              u_color: new s.bQ(p, e.u_color),
              u_overlay: new s.bP(p, e.u_overlay),
              u_overlay_scale: new s.bg(p, e.u_overlay_scale)
            }),
            depth: Gc,
            clippingMask: Gc,
            heatmap: (p, e) => ({
              u_extrude_scale: new s.bg(p, e.u_extrude_scale),
              u_intensity: new s.bg(p, e.u_intensity),
              u_globe_extrude_scale: new s.bg(p, e.u_globe_extrude_scale)
            }),
            heatmapTexture: (p, e) => ({
              u_matrix: new s.bR(p, e.u_matrix),
              u_world: new s.bU(p, e.u_world),
              u_image: new s.bP(p, e.u_image),
              u_color_ramp: new s.bP(p, e.u_color_ramp),
              u_opacity: new s.bg(p, e.u_opacity)
            }),
            hillshade: (p, e) => ({
              u_image: new s.bP(p, e.u_image),
              u_latrange: new s.bU(p, e.u_latrange),
              u_exaggeration: new s.bg(p, e.u_exaggeration),
              u_altitudes: new s.b_(p, e.u_altitudes),
              u_azimuths: new s.b_(p, e.u_azimuths),
              u_accent: new s.bQ(p, e.u_accent),
              u_method: new s.bP(p, e.u_method),
              u_shadows: new s.bZ(p, e.u_shadows),
              u_highlights: new s.bZ(p, e.u_highlights)
            }),
            hillshadePrepare: (p, e) => ({
              u_matrix: new s.bR(p, e.u_matrix),
              u_image: new s.bP(p, e.u_image),
              u_dimension: new s.bU(p, e.u_dimension),
              u_zoom: new s.bg(p, e.u_zoom),
              u_unpack: new s.bS(p, e.u_unpack)
            }),
            colorRelief: (p, e) => ({
              u_image: new s.bP(p, e.u_image),
              u_unpack: new s.bS(p, e.u_unpack),
              u_dimension: new s.bU(p, e.u_dimension),
              u_elevation_stops: new s.bP(p, e.u_elevation_stops),
              u_color_stops: new s.bP(p, e.u_color_stops),
              u_color_ramp_size: new s.bP(p, e.u_color_ramp_size),
              u_opacity: new s.bg(p, e.u_opacity)
            }),
            line: (p, e) => ({
              u_translation: new s.bU(p, e.u_translation),
              u_ratio: new s.bg(p, e.u_ratio),
              u_device_pixel_ratio: new s.bg(p, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bU(p, e.u_units_to_pixels)
            }),
            lineGradient: (p, e) => ({
              u_translation: new s.bU(p, e.u_translation),
              u_ratio: new s.bg(p, e.u_ratio),
              u_device_pixel_ratio: new s.bg(p, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bU(p, e.u_units_to_pixels),
              u_image: new s.bP(p, e.u_image),
              u_image_height: new s.bg(p, e.u_image_height)
            }),
            linePattern: (p, e) => ({
              u_translation: new s.bU(p, e.u_translation),
              u_texsize: new s.bU(p, e.u_texsize),
              u_ratio: new s.bg(p, e.u_ratio),
              u_device_pixel_ratio: new s.bg(p, e.u_device_pixel_ratio),
              u_image: new s.bP(p, e.u_image),
              u_units_to_pixels: new s.bU(p, e.u_units_to_pixels),
              u_scale: new s.bT(p, e.u_scale),
              u_fade: new s.bg(p, e.u_fade)
            }),
            lineSDF: (p, e) => ({
              u_translation: new s.bU(p, e.u_translation),
              u_ratio: new s.bg(p, e.u_ratio),
              u_device_pixel_ratio: new s.bg(p, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bU(p, e.u_units_to_pixels),
              u_patternscale_a: new s.bU(p, e.u_patternscale_a),
              u_patternscale_b: new s.bU(p, e.u_patternscale_b),
              u_sdfgamma: new s.bg(p, e.u_sdfgamma),
              u_image: new s.bP(p, e.u_image),
              u_tex_y_a: new s.bg(p, e.u_tex_y_a),
              u_tex_y_b: new s.bg(p, e.u_tex_y_b),
              u_mix: new s.bg(p, e.u_mix)
            }),
            raster: (p, e) => ({
              u_tl_parent: new s.bU(p, e.u_tl_parent),
              u_scale_parent: new s.bg(p, e.u_scale_parent),
              u_buffer_scale: new s.bg(p, e.u_buffer_scale),
              u_fade_t: new s.bg(p, e.u_fade_t),
              u_opacity: new s.bg(p, e.u_opacity),
              u_image0: new s.bP(p, e.u_image0),
              u_image1: new s.bP(p, e.u_image1),
              u_brightness_low: new s.bg(p, e.u_brightness_low),
              u_brightness_high: new s.bg(p, e.u_brightness_high),
              u_saturation_factor: new s.bg(p, e.u_saturation_factor),
              u_contrast_factor: new s.bg(p, e.u_contrast_factor),
              u_spin_weights: new s.bT(p, e.u_spin_weights),
              u_coords_top: new s.bS(p, e.u_coords_top),
              u_coords_bottom: new s.bS(p, e.u_coords_bottom)
            }),
            symbolIcon: (p, e) => ({
              u_is_size_zoom_constant: new s.bP(p, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bP(p, e.u_is_size_feature_constant),
              u_size_t: new s.bg(p, e.u_size_t),
              u_size: new s.bg(p, e.u_size),
              u_camera_to_center_distance: new s.bg(p, e.u_camera_to_center_distance),
              u_pitch: new s.bg(p, e.u_pitch),
              u_rotate_symbol: new s.bP(p, e.u_rotate_symbol),
              u_aspect_ratio: new s.bg(p, e.u_aspect_ratio),
              u_fade_change: new s.bg(p, e.u_fade_change),
              u_label_plane_matrix: new s.bR(p, e.u_label_plane_matrix),
              u_coord_matrix: new s.bR(p, e.u_coord_matrix),
              u_is_text: new s.bP(p, e.u_is_text),
              u_pitch_with_map: new s.bP(p, e.u_pitch_with_map),
              u_is_along_line: new s.bP(p, e.u_is_along_line),
              u_is_variable_anchor: new s.bP(p, e.u_is_variable_anchor),
              u_texsize: new s.bU(p, e.u_texsize),
              u_texture: new s.bP(p, e.u_texture),
              u_translation: new s.bU(p, e.u_translation),
              u_pitched_scale: new s.bg(p, e.u_pitched_scale)
            }),
            symbolSDF: (p, e) => ({
              u_is_size_zoom_constant: new s.bP(p, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bP(p, e.u_is_size_feature_constant),
              u_size_t: new s.bg(p, e.u_size_t),
              u_size: new s.bg(p, e.u_size),
              u_camera_to_center_distance: new s.bg(p, e.u_camera_to_center_distance),
              u_pitch: new s.bg(p, e.u_pitch),
              u_rotate_symbol: new s.bP(p, e.u_rotate_symbol),
              u_aspect_ratio: new s.bg(p, e.u_aspect_ratio),
              u_fade_change: new s.bg(p, e.u_fade_change),
              u_label_plane_matrix: new s.bR(p, e.u_label_plane_matrix),
              u_coord_matrix: new s.bR(p, e.u_coord_matrix),
              u_is_text: new s.bP(p, e.u_is_text),
              u_pitch_with_map: new s.bP(p, e.u_pitch_with_map),
              u_is_along_line: new s.bP(p, e.u_is_along_line),
              u_is_variable_anchor: new s.bP(p, e.u_is_variable_anchor),
              u_texsize: new s.bU(p, e.u_texsize),
              u_texture: new s.bP(p, e.u_texture),
              u_gamma_scale: new s.bg(p, e.u_gamma_scale),
              u_device_pixel_ratio: new s.bg(p, e.u_device_pixel_ratio),
              u_is_halo: new s.bP(p, e.u_is_halo),
              u_translation: new s.bU(p, e.u_translation),
              u_pitched_scale: new s.bg(p, e.u_pitched_scale)
            }),
            symbolTextAndIcon: (p, e) => ({
              u_is_size_zoom_constant: new s.bP(p, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bP(p, e.u_is_size_feature_constant),
              u_size_t: new s.bg(p, e.u_size_t),
              u_size: new s.bg(p, e.u_size),
              u_camera_to_center_distance: new s.bg(p, e.u_camera_to_center_distance),
              u_pitch: new s.bg(p, e.u_pitch),
              u_rotate_symbol: new s.bP(p, e.u_rotate_symbol),
              u_aspect_ratio: new s.bg(p, e.u_aspect_ratio),
              u_fade_change: new s.bg(p, e.u_fade_change),
              u_label_plane_matrix: new s.bR(p, e.u_label_plane_matrix),
              u_coord_matrix: new s.bR(p, e.u_coord_matrix),
              u_is_text: new s.bP(p, e.u_is_text),
              u_pitch_with_map: new s.bP(p, e.u_pitch_with_map),
              u_is_along_line: new s.bP(p, e.u_is_along_line),
              u_is_variable_anchor: new s.bP(p, e.u_is_variable_anchor),
              u_texsize: new s.bU(p, e.u_texsize),
              u_texsize_icon: new s.bU(p, e.u_texsize_icon),
              u_texture: new s.bP(p, e.u_texture),
              u_texture_icon: new s.bP(p, e.u_texture_icon),
              u_gamma_scale: new s.bg(p, e.u_gamma_scale),
              u_device_pixel_ratio: new s.bg(p, e.u_device_pixel_ratio),
              u_is_halo: new s.bP(p, e.u_is_halo),
              u_translation: new s.bU(p, e.u_translation),
              u_pitched_scale: new s.bg(p, e.u_pitched_scale)
            }),
            background: (p, e) => ({
              u_opacity: new s.bg(p, e.u_opacity),
              u_color: new s.bQ(p, e.u_color)
            }),
            backgroundPattern: (p, e) => ({
              u_opacity: new s.bg(p, e.u_opacity),
              u_image: new s.bP(p, e.u_image),
              u_pattern_tl_a: new s.bU(p, e.u_pattern_tl_a),
              u_pattern_br_a: new s.bU(p, e.u_pattern_br_a),
              u_pattern_tl_b: new s.bU(p, e.u_pattern_tl_b),
              u_pattern_br_b: new s.bU(p, e.u_pattern_br_b),
              u_texsize: new s.bU(p, e.u_texsize),
              u_mix: new s.bg(p, e.u_mix),
              u_pattern_size_a: new s.bU(p, e.u_pattern_size_a),
              u_pattern_size_b: new s.bU(p, e.u_pattern_size_b),
              u_scale_a: new s.bg(p, e.u_scale_a),
              u_scale_b: new s.bg(p, e.u_scale_b),
              u_pixel_coord_upper: new s.bU(p, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bU(p, e.u_pixel_coord_lower),
              u_tile_units_to_pixels: new s.bg(p, e.u_tile_units_to_pixels)
            }),
            terrain: (p, e) => ({
              u_texture: new s.bP(p, e.u_texture),
              u_ele_delta: new s.bg(p, e.u_ele_delta),
              u_fog_matrix: new s.bR(p, e.u_fog_matrix),
              u_fog_color: new s.bQ(p, e.u_fog_color),
              u_fog_ground_blend: new s.bg(p, e.u_fog_ground_blend),
              u_fog_ground_blend_opacity: new s.bg(p, e.u_fog_ground_blend_opacity),
              u_horizon_color: new s.bQ(p, e.u_horizon_color),
              u_horizon_fog_blend: new s.bg(p, e.u_horizon_fog_blend),
              u_is_globe_mode: new s.bg(p, e.u_is_globe_mode)
            }),
            terrainDepth: (p, e) => ({
              u_ele_delta: new s.bg(p, e.u_ele_delta)
            }),
            terrainCoords: (p, e) => ({
              u_texture: new s.bP(p, e.u_texture),
              u_terrain_coords_id: new s.bg(p, e.u_terrain_coords_id),
              u_ele_delta: new s.bg(p, e.u_ele_delta)
            }),
            projectionErrorMeasurement: (p, e) => ({
              u_input: new s.bg(p, e.u_input),
              u_output_expected: new s.bg(p, e.u_output_expected)
            }),
            atmosphere: (p, e) => ({
              u_sun_pos: new s.bT(p, e.u_sun_pos),
              u_atmosphere_blend: new s.bg(p, e.u_atmosphere_blend),
              u_globe_position: new s.bT(p, e.u_globe_position),
              u_globe_radius: new s.bg(p, e.u_globe_radius),
              u_inv_proj_matrix: new s.bR(p, e.u_inv_proj_matrix)
            }),
            sky: (p, e) => ({
              u_sky_color: new s.bQ(p, e.u_sky_color),
              u_horizon_color: new s.bQ(p, e.u_horizon_color),
              u_horizon: new s.bU(p, e.u_horizon),
              u_horizon_normal: new s.bU(p, e.u_horizon_normal),
              u_sky_horizon_blend: new s.bg(p, e.u_sky_horizon_blend),
              u_sky_blend: new s.bg(p, e.u_sky_blend)
            })
          };
        class nd {
          constructor(e, i, l) {
            this.context = e;
            const u = e.gl;
            this.buffer = u.createBuffer(), this.dynamicDraw = !!l, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), u.bufferData(u.ELEMENT_ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? u.DYNAMIC_DRAW : u.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer)
          }
          updateData(e) {
            const i = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), i.bufferSubData(i.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        const Ll = {
          Int8: "BYTE",
          Uint8: "UNSIGNED_BYTE",
          Int16: "SHORT",
          Uint16: "UNSIGNED_SHORT",
          Int32: "INT",
          Uint32: "UNSIGNED_INT",
          Float32: "FLOAT"
        };
        class no {
          constructor(e, i, l, u) {
            this.length = i.length, this.attributes = l, this.itemSize = i.bytesPerElement, this.dynamicDraw = u, this.context = e;
            const f = e.gl;
            this.buffer = f.createBuffer(), e.bindVertexBuffer.set(this.buffer), f.bufferData(f.ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? f.DYNAMIC_DRAW : f.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer)
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const i = this.context.gl;
            this.bind(), i.bufferSubData(i.ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          enableAttributes(e, i) {
            for (let l = 0; l < this.attributes.length; l++) {
              const u = i.attributes[this.attributes[l].name];
              u !== void 0 && e.enableVertexAttribArray(u)
            }
          }
          setVertexAttribPointers(e, i, l) {
            for (let u = 0; u < this.attributes.length; u++) {
              const f = this.attributes[u],
                g = i.attributes[f.name];
              g !== void 0 && e.vertexAttribPointer(g, f.components, e[Ll[f.type]], !1, this.itemSize, f.offset + this.itemSize * (l || 0))
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        class wn {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
          }
          get() {
            return this.current
          }
          set(e) {}
          getDefault() {
            return this.default
          }
          setDefault() {
            this.set(this.default)
          }
        }
        class Hc extends wn {
          getDefault() {
            return s.bf.transparent
          }
          set(e) {
            const i = this.current;
            (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Jc extends wn {
          getDefault() {
            return 1
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1)
          }
        }
        class id extends wn {
          getDefault() {
            return 0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1)
          }
        }
        class Xc extends wn {
          getDefault() {
            return [!0, !0, !0, !0]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class Vo extends wn {
          getDefault() {
            return !0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Yc extends wn {
          getDefault() {
            return 255
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Hp extends wn {
          getDefault() {
            return {
              func: this.gl.ALWAYS,
              ref: 0,
              mask: 255
            }
          }
          set(e) {
            const i = this.current;
            (e.func !== i.func || e.ref !== i.ref || e.mask !== i.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1)
          }
        }
        class Jp extends wn {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1)
          }
        }
        class Xp extends wn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST), this.current = e, this.dirty = !1
          }
        }
        class Yp extends wn {
          getDefault() {
            return [0, 1]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class ad extends wn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST), this.current = e, this.dirty = !1
          }
        }
        class Kp extends wn {
          getDefault() {
            return this.gl.LESS
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1)
          }
        }
        class od extends wn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.BLEND) : i.disable(i.BLEND), this.current = e, this.dirty = !1
          }
        }
        class Dl extends wn {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Rl extends wn {
          getDefault() {
            return s.bf.transparent
          }
          set(e) {
            const i = this.current;
            (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Bl extends wn {
          getDefault() {
            return this.gl.FUNC_ADD
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1)
          }
        }
        class Kc extends wn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.CULL_FACE) : i.disable(i.CULL_FACE), this.current = e, this.dirty = !1
          }
        }
        class qo extends wn {
          getDefault() {
            return this.gl.BACK
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1)
          }
        }
        class Xs extends wn {
          getDefault() {
            return this.gl.CCW
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1)
          }
        }
        class ms extends wn {
          getDefault() {
            return null
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1)
          }
        }
        class fa extends wn {
          getDefault() {
            return this.gl.TEXTURE0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1)
          }
        }
        class sd extends wn {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class ld extends wn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindFramebuffer(i.FRAMEBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Qc extends wn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindRenderbuffer(i.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Uo extends wn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindTexture(i.TEXTURE_2D, e), this.current = e, this.dirty = !1
          }
        }
        class Fl extends wn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindBuffer(i.ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Ol extends wn {
          getDefault() {
            return null
          }
          set(e) {
            const i = this.gl;
            i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Ys extends wn {
          getDefault() {
            return null
          }
          set(e) {
            var i;
            if (e === this.current && !this.dirty) return;
            const l = this.gl;
            qn(l) ? l.bindVertexArray(e) : (i = l.getExtension("OES_vertex_array_object")) === null || i === void 0 || i.bindVertexArrayOES(e), this.current = e, this.dirty = !1
          }
        }
        class jl extends wn {
          getDefault() {
            return 4
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1
          }
        }
        class cd extends wn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class _s extends wn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class xo extends wn {
          constructor(e, i) {
            super(e), this.context = e, this.parent = i
          }
          getDefault() {
            return null
          }
        }
        class ud extends xo {
          setDirty() {
            this.dirty = !0
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1
          }
        }
        class eu extends xo {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class mn extends xo {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        const Ks = "Framebuffer is not complete";
        class Qp {
          constructor(e, i, l, u, f) {
            this.context = e, this.width = i, this.height = l;
            const g = e.gl,
              C = this.framebuffer = g.createFramebuffer();
            if (this.colorAttachment = new ud(e, C), u) this.depthAttachment = f ? new mn(e, C) : new eu(e, C);
            else if (f) throw new Error("Stencil cannot be set without depth");
            if (g.checkFramebufferStatus(g.FRAMEBUFFER) !== g.FRAMEBUFFER_COMPLETE) throw new Error(Ks)
          }
          destroy() {
            const e = this.context.gl,
              i = this.colorAttachment.get();
            if (i && e.deleteTexture(i), this.depthAttachment) {
              const l = this.depthAttachment.get();
              l && e.deleteRenderbuffer(l)
            }
            e.deleteFramebuffer(this.framebuffer)
          }
        }
        class hd {
          constructor(e) {
            var i, l;
            if (this.gl = e, this.clearColor = new Hc(this), this.clearDepth = new Jc(this), this.clearStencil = new id(this), this.colorMask = new Xc(this), this.depthMask = new Vo(this), this.stencilMask = new Yc(this), this.stencilFunc = new Hp(this), this.stencilOp = new Jp(this), this.stencilTest = new Xp(this), this.depthRange = new Yp(this), this.depthTest = new ad(this), this.depthFunc = new Kp(this), this.blend = new od(this), this.blendFunc = new Dl(this), this.blendColor = new Rl(this), this.blendEquation = new Bl(this), this.cullFace = new Kc(this), this.cullFaceSide = new qo(this), this.frontFace = new Xs(this), this.program = new ms(this), this.activeTexture = new fa(this), this.viewport = new sd(this), this.bindFramebuffer = new ld(this), this.bindRenderbuffer = new Qc(this), this.bindTexture = new Uo(this), this.bindVertexBuffer = new Fl(this), this.bindElementBuffer = new Ol(this), this.bindVertexArray = new Ys(this), this.pixelStoreUnpack = new jl(this), this.pixelStoreUnpackPremultiplyAlpha = new cd(this), this.pixelStoreUnpackFlipY = new _s(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), qn(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const u = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (i = e.RGBA16F) !== null && i !== void 0 ? i : u == null ? void 0 : u.RGBA16F_EXT, this.RGB16F = (l = e.RGB16F) !== null && l !== void 0 ? l : u == null ? void 0 : u.RGB16F_EXT, e.getExtension("EXT_color_buffer_float")
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const u = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = u == null ? void 0 : u.HALF_FLOAT_OES
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
          }
          createIndexBuffer(e, i) {
            return new nd(this, e, i)
          }
          createVertexBuffer(e, i, l) {
            return new no(this, e, i, l)
          }
          createRenderbuffer(e, i, l) {
            const u = this.gl,
              f = u.createRenderbuffer();
            return this.bindRenderbuffer.set(f), u.renderbufferStorage(u.RENDERBUFFER, e, i, l), this.bindRenderbuffer.set(null), f
          }
          createFramebuffer(e, i, l, u) {
            return new Qp(this, e, i, l, u)
          }
          clear({
            color: e,
            depth: i,
            stencil: l
          }) {
            const u = this.gl;
            let f = 0;
            e && (f |= u.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), i !== void 0 && (f |= u.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i), this.depthMask.set(!0)), l !== void 0 && (f |= u.STENCIL_BUFFER_BIT, this.clearStencil.set(l), this.stencilMask.set(255)), u.clear(f)
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace))
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1)
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
              func: e.test.func,
              ref: e.ref,
              mask: e.test.mask
            })) : this.stencilTest.set(!1)
          }
          setColorMode(e) {
            s.bH(e.blendFunction, Xr.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask)
          }
          createVertexArray() {
            var e;
            return qn(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
          }
          deleteVertexArray(e) {
            var i;
            return qn(this.gl) ? this.gl.deleteVertexArray(e) : (i = this.gl.getExtension("OES_vertex_array_object")) === null || i === void 0 ? void 0 : i.deleteVertexArrayOES(e)
          }
          unbindVAO() {
            this.bindVertexArray.set(null)
          }
        }
        let bo;

        function dd(p, e, i, l, u) {
          const f = p.context,
            g = p.transform,
            C = f.gl,
            T = p.useProgram("collisionBox"),
            M = [];
          let z = 0,
            R = 0;
          for (let se = 0; se < l.length; se++) {
            const pe = l[se],
              ye = e.getTile(pe).getBucket(i);
            if (!ye) continue;
            const ge = u ? ye.textCollisionBox : ye.iconCollisionBox,
              Te = ye.collisionCircleArray;
            Te.length > 0 && (M.push({
              circleArray: Te,
              circleOffset: R,
              coord: pe
            }), z += Te.length / 4, R = z), ge && T.draw(f, C.LINES, _r.disabled, Wr.disabled, p.colorModeForRenderPass(), mr.disabled, El(p.transform), p.style.map.terrain && p.style.map.terrain.getTerrainData(pe), g.getProjectionData({
              overscaledTileID: pe,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }), i.id, ge.layoutVertexBuffer, ge.indexBuffer, ge.segments, null, p.transform.zoom, null, null, ge.collisionVertexBuffer)
          }
          if (!u || !M.length) return;
          const D = p.useProgram("collisionCircle"),
            N = new s.b$;
          N.resize(4 * z), N._trim();
          let H = 0;
          for (const se of M)
            for (let pe = 0; pe < se.circleArray.length / 4; pe++) {
              const ye = 4 * pe,
                ge = se.circleArray[ye + 0],
                Te = se.circleArray[ye + 1],
                Le = se.circleArray[ye + 2],
                ve = se.circleArray[ye + 3];
              N.emplace(H++, ge, Te, Le, ve, 0), N.emplace(H++, ge, Te, Le, ve, 1), N.emplace(H++, ge, Te, Le, ve, 2), N.emplace(H++, ge, Te, Le, ve, 3)
            }(!bo || bo.length < 2 * z) && (bo = (function(se) {
              const pe = 2 * se,
                ye = new s.c1;
              ye.resize(pe), ye._trim();
              for (let ge = 0; ge < pe; ge++) {
                const Te = 6 * ge;
                ye.uint16[Te + 0] = 4 * ge + 0, ye.uint16[Te + 1] = 4 * ge + 1, ye.uint16[Te + 2] = 4 * ge + 2, ye.uint16[Te + 3] = 4 * ge + 2, ye.uint16[Te + 4] = 4 * ge + 3, ye.uint16[Te + 5] = 4 * ge + 0
              }
              return ye
            })(z));
          const ie = f.createIndexBuffer(bo, !0),
            ne = f.createVertexBuffer(N, s.c0.members, !0);
          for (const se of M) {
            const pe = Up(p.transform);
            D.draw(f, C.TRIANGLES, _r.disabled, Wr.disabled, p.colorModeForRenderPass(), mr.disabled, pe, p.style.map.terrain && p.style.map.terrain.getTerrainData(se.coord), null, i.id, ne, ie, s.aM.simpleSegment(0, 2 * se.circleOffset, se.circleArray.length, se.circleArray.length / 2), null, p.transform.zoom, null, null, null)
          }
          ne.destroy(), ie.destroy()
        }
        const ef = s.ag(new Float32Array(16));

        function pd(p, e, i, l, u, f) {
          const {
            horizontalAlign: g,
            verticalAlign: C
          } = s.aH(p);
          return new s.P((-(g - .5) * e / u + l[0]) * f, (-(C - .5) * i / u + l[1]) * f)
        }

        function tf(p, e, i, l, u, f) {
          const g = e.tileAnchorPoint.add(new s.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let C = l.mult(f);
            i || (C = C.rotate(-u));
            const T = g.add(C);
            return vn(T.x, T.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
          }
          if (i) {
            const C = xt(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(p),
              T = Math.atan(C.y / C.x) + (C.x < 0 ? Math.PI : 0);
            return p.add(l.rotate(T))
          }
          return p.add(l)
        }

        function tu(p, e, i, l, u, f, g, C, T, M, z, R) {
          const D = p.text.placedSymbolArray,
            N = p.text.dynamicLayoutVertexArray,
            H = p.icon.dynamicLayoutVertexArray,
            ie = {};
          N.clear();
          for (let ne = 0; ne < D.length; ne++) {
            const se = D.get(ne),
              pe = se.hidden || !se.crossTileID || p.allowVerticalPlacement && !se.placedOrientation ? null : l[se.crossTileID];
            if (pe) {
              const ye = new s.P(se.anchorX, se.anchorY),
                ge = {
                  getElevation: R,
                  width: u.width,
                  height: u.height,
                  pitchedLabelPlaneMatrix: f,
                  pitchWithMap: i,
                  transform: u,
                  tileAnchorPoint: ye,
                  translation: M,
                  unwrappedTileID: z
                },
                Te = i ? Wt(ye.x, ye.y, ge) : xt(ye.x, ye.y, ge),
                Le = bt(u.cameraToCenterDistance, Te.signedDistanceFromCamera);
              let ve = s.ap(p.textSizeData, C, se) * Le / s.aB;
              i && (ve *= p.tilePixelRatio / g);
              const {
                width: Ne,
                height: st,
                anchor: Xe,
                textOffset: Qe,
                textBoxScale: at
              } = pe, Ht = pd(Xe, Ne, st, Qe, at, ve), Xt = u.getPitchedTextCorrection(ye.x + M[0], ye.y + M[1], z), kt = tf(Te.point, ge, e, Ht, -u.bearingInRadians, Xt), wr = p.allowVerticalPlacement && se.placedOrientation === s.ao.vertical ? Math.PI / 2 : 0;
              for (let dn = 0; dn < se.numGlyphs; dn++) s.av(N, kt, wr);
              T && se.associatedIconIndex >= 0 && (ie[se.associatedIconIndex] = {
                shiftedAnchor: kt,
                angle: wr
              })
            } else Hr(se.numGlyphs, N)
          }
          if (T) {
            H.clear();
            const ne = p.icon.placedSymbolArray;
            for (let se = 0; se < ne.length; se++) {
              const pe = ne.get(se);
              if (pe.hidden) Hr(pe.numGlyphs, H);
              else {
                const ye = ie[se];
                if (ye)
                  for (let ge = 0; ge < pe.numGlyphs; ge++) s.av(H, ye.shiftedAnchor, ye.angle);
                else Hr(pe.numGlyphs, H)
              }
            }
            p.icon.dynamicLayoutVertexBuffer.updateData(H)
          }
          p.text.dynamicLayoutVertexBuffer.updateData(N)
        }

        function Nl(p, e, i) {
          return i.iconsInText && e ? "symbolTextAndIcon" : p ? "symbolSDF" : "symbolIcon"
        }

        function Qs(p, e, i, l, u, f, g, C, T, M, z, R, D) {
          const N = p.context,
            H = N.gl,
            ie = p.transform,
            ne = C === "map",
            se = T === "map",
            pe = C !== "viewport" && i.layout.get("symbol-placement") !== "point",
            ye = ne && !se && !pe,
            ge = !i.layout.get("symbol-sort-key").isConstant();
          let Te = !1;
          const Le = p.getDepthModeForSublayer(0, _r.ReadOnly),
            ve = i._unevaluatedLayout.hasValue("text-variable-anchor") || i._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
            Ne = [],
            st = ie.getCircleRadiusCorrection();
          for (const Xe of l) {
            const Qe = e.getTile(Xe),
              at = Qe.getBucket(i);
            if (!at) continue;
            const Ht = u ? at.text : at.icon;
            if (!Ht || !Ht.segments.get().length || !Ht.hasVisibleVertices) continue;
            const Xt = Ht.programConfigurations.get(i.id),
              kt = u || at.sdfIcons,
              wr = u ? at.textSizeData : at.iconSizeData,
              dn = se || ie.pitch !== 0,
              Tn = p.useProgram(Nl(kt, u, at), Xt),
              kn = s.an(wr, ie.zoom),
              Sn = p.style.map.terrain && p.style.map.terrain.getTerrainData(Xe);
            let Gn, Yn, un, Mn, li = [0, 0],
              mi = null;
            if (u) Yn = Qe.glyphAtlasTexture, un = H.LINEAR, Gn = Qe.glyphAtlasTexture.size, at.iconsInText && (li = Qe.imageAtlasTexture.size, mi = Qe.imageAtlasTexture, Mn = dn || p.options.rotating || p.options.zooming || wr.kind === "composite" || wr.kind === "camera" ? H.LINEAR : H.NEAREST);
            else {
              const ci = i.layout.get("icon-size").constantOr(0) !== 1 || at.iconsNeedLinear;
              Yn = Qe.imageAtlasTexture, un = kt || p.options.rotating || p.options.zooming || ci || dn ? H.LINEAR : H.NEAREST, Gn = Qe.imageAtlasTexture.size
            }
            const xi = s.aC(Qe, 1, p.transform.zoom),
              Hi = $r(ne, p.transform, xi),
              Aa = s.L();
            s.aq(Aa, Hi);
            const Co = Br(se, ne, p.transform, xi),
              To = s.aD(ie, Qe, f, g),
              ks = ie.getProjectionData({
                overscaledTileID: Xe,
                applyGlobeMatrix: !D,
                applyTerrainMatrix: !0
              }),
              Ms = ve && at.hasTextData(),
              Yo = i.layout.get("icon-text-fit") !== "none" && Ms && at.hasIconData();
            if (pe) {
              const ci = p.style.map.terrain ? (ga, ui) => p.style.map.terrain.getElevation(Xe, ga, ui) : null,
                _i = i.layout.get("text-rotation-alignment") === "map";
              fn(at, p, u, Hi, Aa, se, M, _i, Xe.toUnwrapped(), ie.width, ie.height, To, ci)
            }
            const Ko = u && ve || Yo,
              Qi = pe || Ko ? ef : se ? Hi : p.transform.clipSpaceToPixelsMatrix,
              Ea = kt && i.paint.get(u ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Ji;
            Ji = kt ? at.iconsInText ? Wp(wr.kind, kn, ye, se, pe, Ko, p, Qi, Co, To, Gn, li, st) : ed(wr.kind, kn, ye, se, pe, Ko, p, Qi, Co, To, u, Gn, 0, st) : Js(wr.kind, kn, ye, se, pe, Ko, p, Qi, Co, To, u, Gn, st);
            const So = {
              program: Tn,
              buffers: Ht,
              uniformValues: Ji,
              projectionData: ks,
              atlasTexture: Yn,
              atlasTextureIcon: mi,
              atlasInterpolation: un,
              atlasInterpolationIcon: Mn,
              isSDF: kt,
              hasHalo: Ea
            };
            if (ge && at.canOverlap) {
              Te = !0;
              const ci = Ht.segments.get();
              for (const _i of ci) Ne.push({
                segments: new s.aM([_i]),
                sortKey: _i.sortKey,
                state: So,
                terrainData: Sn
              })
            } else Ne.push({
              segments: Ht.segments,
              sortKey: 0,
              state: So,
              terrainData: Sn
            })
          }
          Te && Ne.sort(((Xe, Qe) => Xe.sortKey - Qe.sortKey));
          for (const Xe of Ne) {
            const Qe = Xe.state;
            if (N.activeTexture.set(H.TEXTURE0), Qe.atlasTexture.bind(Qe.atlasInterpolation, H.CLAMP_TO_EDGE), Qe.atlasTextureIcon && (N.activeTexture.set(H.TEXTURE1), Qe.atlasTextureIcon && Qe.atlasTextureIcon.bind(Qe.atlasInterpolationIcon, H.CLAMP_TO_EDGE)), Qe.isSDF) {
              const at = Qe.uniformValues;
              Qe.hasHalo && (at.u_is_halo = 1, el(Qe.buffers, Xe.segments, i, p, Qe.program, Le, z, R, at, Qe.projectionData, Xe.terrainData)), at.u_is_halo = 0
            }
            el(Qe.buffers, Xe.segments, i, p, Qe.program, Le, z, R, Qe.uniformValues, Qe.projectionData, Xe.terrainData)
          }
        }

        function el(p, e, i, l, u, f, g, C, T, M, z) {
          const R = l.context;
          u.draw(R, R.gl.TRIANGLES, f, g, C, mr.backCCW, T, z, M, i.id, p.layoutVertexBuffer, p.indexBuffer, e, i.paint, l.transform.zoom, p.programConfigurations.get(i.id), p.dynamicLayoutVertexBuffer, p.opacityVertexBuffer)
        }

        function ru(p, e, i, l, u) {
          const f = p.context,
            g = f.gl,
            C = Wr.disabled,
            T = new Xr([g.ONE, g.ONE], s.bf.transparent, [!0, !0, !0, !0]),
            M = e.getBucket(i);
          if (!M) return;
          const z = l.key;
          let R = i.heatmapFbos.get(z);
          R || (R = tl(f, e.tileSize, e.tileSize), i.heatmapFbos.set(z, R)), f.bindFramebuffer.set(R.framebuffer), f.viewport.set([0, 0, e.tileSize, e.tileSize]), f.clear({
            color: s.bf.transparent
          });
          const D = M.programConfigurations.get(i.id),
            N = p.useProgram("heatmap", D, !u),
            H = p.transform.getProjectionData({
              overscaledTileID: e.tileID,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }),
            ie = p.style.map.terrain.getTerrainData(l);
          N.draw(f, g.TRIANGLES, _r.disabled, C, T, mr.disabled, Jh(e, p.transform.zoom, i.paint.get("heatmap-intensity"), 1), ie, H, i.id, M.layoutVertexBuffer, M.indexBuffer, M.segments, i.paint, p.transform.zoom, D)
        }

        function fd(p, e, i, l, u) {
          const f = p.context,
            g = f.gl,
            C = p.transform;
          f.setColorMode(p.colorModeForRenderPass());
          const T = rl(f, e),
            M = i.key,
            z = e.heatmapFbos.get(M);
          if (!z) return;
          f.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, z.colorAttachment.get()), f.activeTexture.set(g.TEXTURE1), T.bind(g.LINEAR, g.CLAMP_TO_EDGE);
          const R = C.getProjectionData({
            overscaledTileID: i,
            applyTerrainMatrix: u,
            applyGlobeMatrix: !l
          });
          p.useProgram("heatmapTexture").draw(f, g.TRIANGLES, _r.disabled, Wr.disabled, p.colorModeForRenderPass(), mr.disabled, Vc(p, e, 0, 1), null, R, e.id, p.rasterBoundsBuffer, p.quadTriangleIndexBuffer, p.rasterBoundsSegments, e.paint, C.zoom), z.destroy(), e.heatmapFbos.delete(M)
        }

        function tl(p, e, i) {
          var l, u;
          const f = p.gl,
            g = f.createTexture();
          f.bindTexture(f.TEXTURE_2D, g), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.LINEAR), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.LINEAR);
          const C = (l = p.HALF_FLOAT) !== null && l !== void 0 ? l : f.UNSIGNED_BYTE,
            T = (u = p.RGBA16F) !== null && u !== void 0 ? u : f.RGBA;
          f.texImage2D(f.TEXTURE_2D, 0, T, e, i, 0, f.RGBA, C, null);
          const M = p.createFramebuffer(e, i, !1, !1);
          return M.colorAttachment.set(g), M
        }

        function rl(p, e) {
          return e.colorRampTexture || (e.colorRampTexture = new s.T(p, e.colorRamp, p.gl.RGBA)), e.colorRampTexture
        }

        function nl(p, e, i, l, u) {
          if (!i || !l || !l.imageAtlas) return;
          const f = l.imageAtlas.patternPositions;
          let g = f[i.to.toString()],
            C = f[i.from.toString()];
          if (!g && C && (g = C), !C && g && (C = g), !g || !C) {
            const T = u.getPaintProperty(e);
            g = f[T], C = f[T]
          }
          g && C && p.setConstantPatternPositions(g, C)
        }

        function Zl(p, e, i, l, u, f, g, C) {
          const T = p.context.gl,
            M = "fill-pattern",
            z = i.paint.get(M),
            R = z && z.constantOr(1),
            D = i.getCrossfadeParameters();
          let N, H, ie, ne, se;
          const pe = p.transform,
            ye = i.paint.get("fill-translate"),
            ge = i.paint.get("fill-translate-anchor");
          g ? (H = R && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", N = T.LINES) : (H = R ? "fillPattern" : "fill", N = T.TRIANGLES);
          const Te = z.constantOr(null);
          for (const Le of l) {
            const ve = e.getTile(Le);
            if (R && !ve.patternsLoaded()) continue;
            const Ne = ve.getBucket(i);
            if (!Ne) continue;
            const st = Ne.programConfigurations.get(i.id),
              Xe = p.useProgram(H, st),
              Qe = p.style.map.terrain && p.style.map.terrain.getTerrainData(Le);
            R && (p.context.activeTexture.set(T.TEXTURE0), ve.imageAtlasTexture.bind(T.LINEAR, T.CLAMP_TO_EDGE), st.updatePaintBuffers(D)), nl(st, M, Te, ve, i);
            const at = pe.getProjectionData({
                overscaledTileID: Le,
                applyGlobeMatrix: !C,
                applyTerrainMatrix: !0
              }),
              Ht = s.aD(pe, ve, ye, ge);
            if (g) {
              ne = Ne.indexBuffer2, se = Ne.segments2;
              const kt = [T.drawingBufferWidth, T.drawingBufferHeight];
              ie = H === "fillOutlinePattern" && R ? Ws(p, D, ve, kt, Ht) : Gs(kt, Ht)
            } else ne = Ne.indexBuffer, se = Ne.segments, ie = R ? Al(p, D, ve, Ht) : {
              u_fill_translate: Ht
            };
            const Xt = p.stencilModeForClipping(Le);
            Xe.draw(p.context, N, u, Xt, f, mr.backCCW, ie, Qe, at, i.id, Ne.layoutVertexBuffer, ne, se, i.paint, p.transform.zoom, st)
          }
        }

        function nu(p, e, i, l, u, f, g, C) {
          const T = p.context,
            M = T.gl,
            z = "fill-extrusion-pattern",
            R = i.paint.get(z),
            D = R.constantOr(1),
            N = i.getCrossfadeParameters(),
            H = i.paint.get("fill-extrusion-opacity"),
            ie = R.constantOr(null),
            ne = p.transform;
          for (const se of l) {
            const pe = e.getTile(se),
              ye = pe.getBucket(i);
            if (!ye) continue;
            const ge = p.style.map.terrain && p.style.map.terrain.getTerrainData(se),
              Te = ye.programConfigurations.get(i.id),
              Le = p.useProgram(D ? "fillExtrusionPattern" : "fillExtrusion", Te);
            D && (p.context.activeTexture.set(M.TEXTURE0), pe.imageAtlasTexture.bind(M.LINEAR, M.CLAMP_TO_EDGE), Te.updatePaintBuffers(N));
            const ve = ne.getProjectionData({
              overscaledTileID: se,
              applyGlobeMatrix: !C,
              applyTerrainMatrix: !0
            });
            nl(Te, z, ie, pe, i);
            const Ne = s.aD(ne, pe, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")),
              st = i.paint.get("fill-extrusion-vertical-gradient"),
              Xe = D ? Vp(p, st, H, Ne, se, N, pe) : Ta(p, st, H, Ne);
            Le.draw(T, T.gl.TRIANGLES, u, f, g, mr.backCCW, Xe, ge, ve, i.id, ye.layoutVertexBuffer, ye.indexBuffer, ye.segments, i.paint, p.transform.zoom, Te, p.style.map.terrain && ye.centroidVertexBuffer)
          }
        }

        function $o(p, e, i, l, u, f, g, C, T) {
          var M;
          const z = p.style.projection,
            R = p.context,
            D = p.transform,
            N = R.gl,
            H = [`#define NUM_ILLUMINATION_SOURCES ${i.paint.get("hillshade-highlight-color").values.length}`],
            ie = p.useProgram("hillshade", null, !1, H),
            ne = !p.options.moving;
          for (const se of l) {
            const pe = e.getTile(se),
              ye = pe.fbo;
            if (!ye) continue;
            const ge = z.getMeshFromTileID(R, se.canonical, C, !0, "raster"),
              Te = (M = p.style.map.terrain) === null || M === void 0 ? void 0 : M.getTerrainData(se);
            R.activeTexture.set(N.TEXTURE0), N.bindTexture(N.TEXTURE_2D, ye.colorAttachment.get());
            const Le = D.getProjectionData({
              overscaledTileID: se,
              aligned: ne,
              applyGlobeMatrix: !T,
              applyTerrainMatrix: !0
            });
            ie.draw(R, N.TRIANGLES, f, u[se.overscaledZ], g, mr.backCCW, $p(p, pe, i), Te, Le, i.id, ge.vertexBuffer, ge.indexBuffer, ge.segments)
          }
        }

        function iu(p, e, i, l, u, f, g, C, T) {
          var M;
          const z = p.style.projection,
            R = p.context,
            D = p.transform,
            N = R.gl,
            H = p.useProgram("colorRelief"),
            ie = !p.options.moving;
          let ne = !0,
            se = 0;
          for (const pe of l) {
            const ye = e.getTile(pe),
              ge = ye.dem;
            if (ne) {
              const Xe = N.getParameter(N.MAX_TEXTURE_SIZE),
                {
                  elevationTexture: Qe,
                  colorTexture: at
                } = i.getColorRampTextures(R, Xe, ge.getUnpackVector());
              R.activeTexture.set(N.TEXTURE1), Qe.bind(N.NEAREST, N.CLAMP_TO_EDGE), R.activeTexture.set(N.TEXTURE4), at.bind(N.LINEAR, N.CLAMP_TO_EDGE), ne = !1, se = Qe.size[0]
            }
            if (!ge || !ge.data) continue;
            const Te = ge.stride,
              Le = ge.getPixels();
            if (R.activeTexture.set(N.TEXTURE0), R.pixelStoreUnpackPremultiplyAlpha.set(!1), ye.demTexture = ye.demTexture || p.getTileTexture(Te), ye.demTexture) {
              const Xe = ye.demTexture;
              Xe.update(Le, {
                premultiply: !1
              }), Xe.bind(N.LINEAR, N.CLAMP_TO_EDGE)
            } else ye.demTexture = new s.T(R, Le, N.RGBA, {
              premultiply: !1
            }), ye.demTexture.bind(N.LINEAR, N.CLAMP_TO_EDGE);
            const ve = z.getMeshFromTileID(R, pe.canonical, C, !0, "raster"),
              Ne = (M = p.style.map.terrain) === null || M === void 0 ? void 0 : M.getTerrainData(pe),
              st = D.getProjectionData({
                overscaledTileID: pe,
                aligned: ie,
                applyGlobeMatrix: !T,
                applyTerrainMatrix: !0
              });
            H.draw(R, N.TRIANGLES, f, u[pe.overscaledZ], g, mr.backCCW, Yh(i, ye.dem, se), Ne, st, i.id, ve.vertexBuffer, ve.indexBuffer, ve.segments)
          }
        }
        const Vl = [new s.P(0, 0), new s.P(s.$, 0), new s.P(s.$, s.$), new s.P(0, s.$)];

        function Go(p, e, i, l, u, f, g, C, T = !1, M = !1) {
          const z = l[l.length - 1].overscaledZ,
            R = p.context,
            D = R.gl,
            N = p.useProgram("raster"),
            H = p.transform,
            ie = p.style.projection,
            ne = p.colorModeForRenderPass(),
            se = !p.options.moving;
          for (const pe of l) {
            const ye = p.getDepthModeForSublayer(pe.overscaledZ - z, i.paint.get("raster-opacity") === 1 ? _r.ReadWrite : _r.ReadOnly, D.LESS),
              ge = e.getTile(pe);
            ge.registerFadeDuration(i.paint.get("raster-fade-duration"));
            const Te = e.findLoadedParent(pe, 0),
              Le = e.findLoadedSibling(pe),
              ve = au(ge, Te || Le || null, e, i, p.transform, p.style.map.terrain);
            let Ne, st;
            const Xe = i.paint.get("raster-resampling") === "nearest" ? D.NEAREST : D.LINEAR;
            R.activeTexture.set(D.TEXTURE0), ge.texture.bind(Xe, D.CLAMP_TO_EDGE, D.LINEAR_MIPMAP_NEAREST), R.activeTexture.set(D.TEXTURE1), Te ? (Te.texture.bind(Xe, D.CLAMP_TO_EDGE, D.LINEAR_MIPMAP_NEAREST), Ne = Math.pow(2, Te.tileID.overscaledZ - ge.tileID.overscaledZ), st = [ge.tileID.canonical.x * Ne % 1, ge.tileID.canonical.y * Ne % 1]) : ge.texture.bind(Xe, D.CLAMP_TO_EDGE, D.LINEAR_MIPMAP_NEAREST), ge.texture.useMipmap && R.extTextureFilterAnisotropic && p.transform.pitch > 20 && D.texParameterf(D.TEXTURE_2D, R.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, R.extTextureFilterAnisotropicMax);
            const Qe = p.style.map.terrain && p.style.map.terrain.getTerrainData(pe),
              at = H.getProjectionData({
                overscaledTileID: pe,
                aligned: se,
                applyGlobeMatrix: !M,
                applyTerrainMatrix: !0
              }),
              Ht = Hs(st || [0, 0], Ne || 1, ve, i, C),
              Xt = ie.getMeshFromTileID(R, pe.canonical, f, g, "raster");
            N.draw(R, D.TRIANGLES, ye, u ? u[pe.overscaledZ] : Wr.disabled, ne, T ? mr.frontCCW : mr.backCCW, Ht, Qe, at, i.id, Xt.vertexBuffer, Xt.indexBuffer, Xt.segments)
          }
        }

        function au(p, e, i, l, u, f) {
          const g = l.paint.get("raster-fade-duration");
          if (!f && g > 0) {
            const C = Q.now(),
              T = (C - p.timeAdded) / g,
              M = e ? (C - e.timeAdded) / g : -1,
              z = i.getSource(),
              R = qt(u, {
                tileSize: z.tileSize,
                roundZoom: z.roundZoom
              }),
              D = !e || Math.abs(e.tileID.overscaledZ - R) > Math.abs(p.tileID.overscaledZ - R),
              N = D && p.refreshedUponExpiration ? 1 : s.ah(D ? T : 1 - M, 0, 1);
            return p.refreshedUponExpiration && T >= 1 && (p.refreshedUponExpiration = !1), e ? {
              opacity: 1,
              mix: 1 - N
            } : {
              opacity: N,
              mix: 0
            }
          }
          return {
            opacity: 1,
            mix: 0
          }
        }
        const md = new s.bf(1, 0, 0, 1),
          _d = new s.bf(0, 1, 0, 1),
          ql = new s.bf(0, 0, 1, 1),
          ou = new s.bf(1, 0, 1, 1),
          rf = new s.bf(0, 1, 1, 1);

        function su(p, e, i, l) {
          $a(p, 0, e + i / 2, p.transform.width, i, l)
        }

        function Xn(p, e, i, l) {
          $a(p, e - i / 2, 0, i, p.transform.height, l)
        }

        function $a(p, e, i, l, u, f) {
          const g = p.context,
            C = g.gl;
          C.enable(C.SCISSOR_TEST), C.scissor(e * p.pixelRatio, i * p.pixelRatio, l * p.pixelRatio, u * p.pixelRatio), g.clear({
            color: f
          }), C.disable(C.SCISSOR_TEST)
        }

        function ma(p, e, i) {
          const l = p.context,
            u = l.gl,
            f = p.useProgram("debug"),
            g = _r.disabled,
            C = Wr.disabled,
            T = p.colorModeForRenderPass(),
            M = "$debug",
            z = p.style.map.terrain && p.style.map.terrain.getTerrainData(i);
          l.activeTexture.set(u.TEXTURE0);
          const R = e.getTileByID(i.key).latestRawTileData,
            D = Math.floor((R && R.byteLength || 0) / 1024),
            N = e.getTile(i).tileSize,
            H = 512 / Math.min(N, 512) * (i.overscaledZ / p.transform.zoom) * .5;
          let ie = i.canonical.toString();
          i.overscaledZ !== i.canonical.z && (ie += ` => ${i.overscaledZ}`), (function(se, pe) {
            se.initDebugOverlayCanvas();
            const ye = se.debugOverlayCanvas,
              ge = se.context.gl,
              Te = se.debugOverlayCanvas.getContext("2d");
            Te.clearRect(0, 0, ye.width, ye.height), Te.shadowColor = "white", Te.shadowBlur = 2, Te.lineWidth = 1.5, Te.strokeStyle = "white", Te.textBaseline = "top", Te.font = "bold 36px Open Sans, sans-serif", Te.fillText(pe, 5, 5), Te.strokeText(pe, 5, 5), se.debugOverlayTexture.update(ye), se.debugOverlayTexture.bind(ge.LINEAR, ge.CLAMP_TO_EDGE)
          })(p, `${ie} ${D}kB`);
          const ne = p.transform.getProjectionData({
            overscaledTileID: i,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0
          });
          f.draw(l, u.TRIANGLES, g, C, Xr.alphaBlended, mr.disabled, No(s.bf.transparent, H), null, ne, M, p.debugBuffer, p.quadTriangleIndexBuffer, p.debugSegments), f.draw(l, u.LINE_STRIP, g, C, T, mr.disabled, No(s.bf.red), z, ne, M, p.debugBuffer, p.tileBorderIndexBuffer, p.debugSegments)
        }

        function Ul(p, e, i, l) {
          const {
            isRenderingGlobe: u
          } = l, f = p.context, g = f.gl, C = p.transform, T = p.colorModeForRenderPass(), M = p.getDepthModeFor3D(), z = p.useProgram("terrain");
          f.bindFramebuffer.set(null), f.viewport.set([0, 0, p.width, p.height]);
          for (const R of i) {
            const D = e.getTerrainMesh(R.tileID),
              N = p.renderToTexture.getTexture(R),
              H = e.getTerrainData(R.tileID);
            f.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, N.texture);
            const ie = e.getMeshFrameDelta(C.zoom),
              ne = C.calculateFogMatrix(R.tileID.toUnwrapped()),
              se = kl(ie, ne, p.style.sky, C.pitch, u),
              pe = C.getProjectionData({
                overscaledTileID: R.tileID,
                applyTerrainMatrix: !1,
                applyGlobeMatrix: !0
              });
            z.draw(f, g.TRIANGLES, M, Wr.disabled, T, mr.backCCW, se, H, pe, "terrain", D.vertexBuffer, D.indexBuffer, D.segments)
          }
        }

        function il(p, e) {
          if (!e.mesh) {
            const i = new s.aL;
            i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1);
            const l = new s.aN;
            l.emplaceBack(0, 1, 2), l.emplaceBack(0, 2, 3), e.mesh = new Cn(p.createVertexBuffer(i, Rn.members), p.createIndexBuffer(l), s.aM.simpleSegment(0, 0, i.length, l.length))
          }
          return e.mesh
        }
        class gd {
          constructor(e, i) {
            this.context = new hd(e), this.transform = i, this._tileTextures = {}, this.terrainFacilitator = {
              dirty: !0,
              matrix: s.ag(new Float64Array(16)),
              renderTime: 0
            }, this.setup(), this.numSublayers = Ut.maxUnderzooming + Ut.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Va
          }
          resize(e, i, l) {
            if (this.width = Math.floor(e * l), this.height = Math.floor(i * l), this.pixelRatio = l, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const u of this.style._order) this.style._layers[u].resize()
          }
          setup() {
            const e = this.context,
              i = new s.aL;
            i.emplaceBack(0, 0), i.emplaceBack(s.$, 0), i.emplaceBack(0, s.$), i.emplaceBack(s.$, s.$), this.tileExtentBuffer = e.createVertexBuffer(i, Rn.members), this.tileExtentSegments = s.aM.simpleSegment(0, 0, 4, 2);
            const l = new s.aL;
            l.emplaceBack(0, 0), l.emplaceBack(s.$, 0), l.emplaceBack(0, s.$), l.emplaceBack(s.$, s.$), this.debugBuffer = e.createVertexBuffer(l, Rn.members), this.debugSegments = s.aM.simpleSegment(0, 0, 4, 5);
            const u = new s.c6;
            u.emplaceBack(0, 0, 0, 0), u.emplaceBack(s.$, 0, s.$, 0), u.emplaceBack(0, s.$, 0, s.$), u.emplaceBack(s.$, s.$, s.$, s.$), this.rasterBoundsBuffer = e.createVertexBuffer(u, Np.members), this.rasterBoundsSegments = s.aM.simpleSegment(0, 0, 4, 2);
            const f = new s.aL;
            f.emplaceBack(0, 0), f.emplaceBack(s.$, 0), f.emplaceBack(0, s.$), f.emplaceBack(s.$, s.$), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(f, Rn.members), this.rasterBoundsSegmentsPosOnly = s.aM.simpleSegment(0, 0, 4, 5);
            const g = new s.aL;
            g.emplaceBack(0, 0), g.emplaceBack(1, 0), g.emplaceBack(0, 1), g.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(g, Rn.members), this.viewportSegments = s.aM.simpleSegment(0, 0, 4, 2);
            const C = new s.c7;
            C.emplaceBack(0), C.emplaceBack(1), C.emplaceBack(3), C.emplaceBack(2), C.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(C);
            const T = new s.aN;
            T.emplaceBack(1, 0, 2), T.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(T);
            const M = this.context.gl;
            this.stencilClearMode = new Wr({
              func: M.ALWAYS,
              mask: 0
            }, 0, 255, M.ZERO, M.ZERO, M.ZERO), this.tileExtentMesh = new Cn(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments)
          }
          clearStencil() {
            const e = this.context,
              i = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const l = s.L();
            s.bY(l, 0, this.width, this.height, 0, 0, 1), s.N(l, l, [i.drawingBufferWidth, i.drawingBufferHeight, 0]);
            const u = {
              mainMatrix: l,
              tileMercatorCoords: [0, 0, 1, 1],
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: l
            };
            this.useProgram("clippingMask", null, !0).draw(e, i.TRIANGLES, _r.disabled, this.stencilClearMode, Xr.disabled, mr.disabled, null, null, u, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
          }
          _renderTileClippingMasks(e, i, l) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !i || !i.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + i.length > 256 && this.clearStencil();
            const u = this.context;
            u.setColorMode(Xr.disabled), u.setDepthMode(_r.disabled);
            const f = {};
            for (const g of i) f[g.key] = this.nextStencilID++;
            this._renderTileMasks(f, i, l, !0), this._renderTileMasks(f, i, l, !1), this._tileClippingMaskIDs = f
          }
          _renderTileMasks(e, i, l, u) {
            const f = this.context,
              g = f.gl,
              C = this.style.projection,
              T = this.transform,
              M = this.useProgram("clippingMask");
            for (const z of i) {
              const R = e[z.key],
                D = this.style.map.terrain && this.style.map.terrain.getTerrainData(z),
                N = C.getMeshFromTileID(this.context, z.canonical, u, !0, "stencil"),
                H = T.getProjectionData({
                  overscaledTileID: z,
                  applyGlobeMatrix: !l,
                  applyTerrainMatrix: !0
                });
              M.draw(f, g.TRIANGLES, _r.disabled, new Wr({
                func: g.ALWAYS,
                mask: 0
              }, R, 255, g.KEEP, g.KEEP, g.REPLACE), Xr.disabled, l ? mr.disabled : mr.backCCW, null, D, H, "$clipping", N.vertexBuffer, N.indexBuffer, N.segments)
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context,
              i = e.gl,
              l = this.style.projection,
              u = this.transform,
              f = this.useProgram("depth"),
              g = this.getDepthModeFor3D(),
              C = we(u, {
                tileSize: u.tileSize
              });
            for (const T of C) {
              const M = this.style.map.terrain && this.style.map.terrain.getTerrainData(T),
                z = l.getMeshFromTileID(this.context, T.canonical, !0, !0, "raster"),
                R = u.getProjectionData({
                  overscaledTileID: T,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0
                });
              f.draw(e, i.TRIANGLES, g, Wr.disabled, Xr.disabled, mr.backCCW, null, M, R, "$clipping", z.vertexBuffer, z.indexBuffer, z.segments)
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++,
              i = this.context.gl;
            return new Wr({
              func: i.NOTEQUAL,
              mask: 255
            }, e, 255, i.KEEP, i.KEEP, i.REPLACE)
          }
          stencilModeForClipping(e) {
            const i = this.context.gl;
            return new Wr({
              func: i.EQUAL,
              mask: 255
            }, this._tileClippingMaskIDs[e.key], 0, i.KEEP, i.KEEP, i.REPLACE)
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const i = this.context.gl,
              l = e.sort(((g, C) => C.overscaledZ - g.overscaledZ)),
              u = l[l.length - 1].overscaledZ,
              f = l[0].overscaledZ - u + 1;
            if (f > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + f > 256 && this.clearStencil();
              const g = {};
              for (let C = 0; C < f; C++) g[C + u] = new Wr({
                func: i.GEQUAL,
                mask: 255
              }, C + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);
              return this.nextStencilID += f, [g, l]
            }
            return [{
              [u]: Wr.disabled
            }, l]
          }
          stencilConfigForOverlapTwoPass(e) {
            const i = this.context.gl,
              l = e.sort(((g, C) => C.overscaledZ - g.overscaledZ)),
              u = l[l.length - 1].overscaledZ,
              f = l[0].overscaledZ - u + 1;
            if (this.clearStencil(), f > 1) {
              const g = {},
                C = {};
              for (let T = 0; T < f; T++) g[T + u] = new Wr({
                func: i.GREATER,
                mask: 255
              }, f + 1 + T, 255, i.KEEP, i.KEEP, i.REPLACE), C[T + u] = new Wr({
                func: i.GREATER,
                mask: 255
              }, 1 + T, 255, i.KEEP, i.KEEP, i.REPLACE);
              return this.nextStencilID = 2 * f + 1, [g, C, l]
            }
            return this.nextStencilID = 3, [{
              [u]: new Wr({
                func: i.GREATER,
                mask: 255
              }, 2, 255, i.KEEP, i.KEEP, i.REPLACE)
            }, {
              [u]: new Wr({
                func: i.GREATER,
                mask: 255
              }, 1, 255, i.KEEP, i.KEEP, i.REPLACE)
            }, l]
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new Xr([e.CONSTANT_COLOR, e.ONE], new s.bf(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Xr.unblended : Xr.alphaBlended
          }
          getDepthModeForSublayer(e, i, l) {
            if (!this.opaquePassEnabledForLayer()) return _r.disabled;
            const u = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new _r(l || this.context.gl.LEQUAL, i, [u, u])
          }
          getDepthModeFor3D() {
            return new _r(this.context.gl.LEQUAL, _r.ReadWrite, this.depthRangeFor3D)
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff
          }
          render(e, i) {
            var l, u;
            this.style = e, this.options = i, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(Q.now()), this.imageManager.beginFrame();
            const f = this.style._order,
              g = this.style.sourceCaches,
              C = {},
              T = {},
              M = {},
              z = {
                isRenderingToTexture: !1,
                isRenderingGlobe: ((l = e.projection) === null || l === void 0 ? void 0 : l.transitionState) > 0
              };
            for (const D in g) {
              const N = g[D];
              N.used && N.prepare(this.context), C[D] = N.getVisibleCoordinates(!1), T[D] = C[D].slice().reverse(), M[D] = N.getVisibleCoordinates(!0).reverse()
            }
            this.opaquePassCutoff = 1 / 0;
            for (let D = 0; D < f.length; D++)
              if (this.style._layers[f[D]].is3D()) {
                this.opaquePassCutoff = D;
                break
              } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const D of f) {
              const N = this.style._layers[D];
              if (!N.hasOffscreenPass() || N.isHidden(this.transform.zoom)) continue;
              const H = T[N.source];
              (N.type === "custom" || H.length) && this.renderLayer(this, g[N.source], N, H, z)
            }
            if ((u = this.style.projection) === null || u === void 0 || u.updateGPUdependent({
                context: this.context,
                useProgram: D => this.useProgram(D)
              }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({
                color: i.showOverdrawInspector ? s.bf.black : s.bf.transparent,
                depth: 1
              }), this.clearStencil(), this.style.sky && (function(D, N) {
                const H = D.context,
                  ie = H.gl,
                  ne = ((Le, ve, Ne) => {
                    const st = Math.cos(ve.rollInRadians),
                      Xe = Math.sin(ve.rollInRadians),
                      Qe = me(ve),
                      at = ve.getProjectionData({
                        overscaledTileID: null,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                      }).projectionTransition;
                    return {
                      u_sky_color: Le.properties.get("sky-color"),
                      u_horizon_color: Le.properties.get("horizon-color"),
                      u_horizon: [(ve.width / 2 - Qe * Xe) * Ne, (ve.height / 2 + Qe * st) * Ne],
                      u_horizon_normal: [-Xe, st],
                      u_sky_horizon_blend: Le.properties.get("sky-horizon-blend") * ve.height / 2 * Ne,
                      u_sky_blend: at
                    }
                  })(N, D.style.map.transform, D.pixelRatio),
                  se = new _r(ie.LEQUAL, _r.ReadWrite, [0, 1]),
                  pe = Wr.disabled,
                  ye = D.colorModeForRenderPass(),
                  ge = D.useProgram("sky"),
                  Te = il(H, N);
                ge.draw(H, ie.TRIANGLES, se, pe, ye, mr.disabled, ne, null, void 0, "sky", Te.vertexBuffer, Te.indexBuffer, Te.segments)
              })(this, this.style.sky), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = f.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const D = this.style._layers[f[this.currentLayer]],
                  N = g[D.source],
                  H = C[D.source];
                this._renderTileClippingMasks(D, H, !1), this.renderLayer(this, N, D, H, z)
              }
            this.renderPass = "translucent";
            let R = !1;
            for (this.currentLayer = 0; this.currentLayer < f.length; this.currentLayer++) {
              const D = this.style._layers[f[this.currentLayer]],
                N = g[D.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(D, z)) continue;
              this.opaquePassEnabledForLayer() || R || (R = !0, z.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const H = (D.type === "symbol" ? M : T)[D.source];
              this._renderTileClippingMasks(D, C[D.source], !!this.renderToTexture), this.renderLayer(this, N, D, H, z)
            }
            if (z.isRenderingGlobe && (function(D, N, H) {
                const ie = D.context,
                  ne = ie.gl,
                  se = D.useProgram("atmosphere"),
                  pe = new _r(ne.LEQUAL, _r.ReadOnly, [0, 1]),
                  ye = D.transform,
                  ge = (function(at, Ht) {
                    const Xt = at.properties.get("position"),
                      kt = [-Xt.x, -Xt.y, -Xt.z],
                      wr = s.ag(new Float64Array(16));
                    return at.properties.get("anchor") === "map" && (s.b6(wr, wr, Ht.rollInRadians), s.b7(wr, wr, -Ht.pitchInRadians), s.b6(wr, wr, Ht.bearingInRadians), s.b7(wr, wr, Ht.center.lat * Math.PI / 180), s.bz(wr, wr, -Ht.center.lng * Math.PI / 180)), s.c5(kt, kt, wr), kt
                  })(H, D.transform),
                  Te = ye.getProjectionData({
                    overscaledTileID: null,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0
                  }),
                  Le = N.properties.get("atmosphere-blend") * Te.projectionTransition;
                if (Le === 0) return;
                const ve = to(ye.worldSize, ye.center.lat),
                  Ne = ye.inverseProjectionMatrix,
                  st = new Float64Array(4);
                st[3] = 1, s.aw(st, st, ye.modelViewProjectionMatrix), st[0] /= st[3], st[1] /= st[3], st[2] /= st[3], st[3] = 1, s.aw(st, st, Ne), st[0] /= st[3], st[1] /= st[3], st[2] /= st[3], st[3] = 1;
                const Xe = ((at, Ht, Xt, kt, wr) => ({
                    u_sun_pos: at,
                    u_atmosphere_blend: Ht,
                    u_globe_position: Xt,
                    u_globe_radius: kt,
                    u_inv_proj_matrix: wr
                  }))(ge, Le, [st[0], st[1], st[2]], ve, Ne),
                  Qe = il(ie, N);
                se.draw(ie, ne.TRIANGLES, pe, Wr.disabled, Xr.alphaBlended, mr.disabled, Xe, null, null, "atmosphere", Qe.vertexBuffer, Qe.indexBuffer, Qe.segments)
              })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const D = (function(N, H) {
                let ie = null;
                const ne = Object.values(N._layers).flatMap((ge => ge.source && !ge.isHidden(H) ? [N.sourceCaches[ge.source]] : [])),
                  se = ne.filter((ge => ge.getSource().type === "vector")),
                  pe = ne.filter((ge => ge.getSource().type !== "vector")),
                  ye = ge => {
                    (!ie || ie.getSource().maxzoom < ge.getSource().maxzoom) && (ie = ge)
                  };
                return se.forEach((ge => ye(ge))), ie || pe.forEach((ge => ye(ge))), ie
              })(this.style, this.transform.zoom);
              D && (function(N, H, ie) {
                for (let ne = 0; ne < ie.length; ne++) ma(N, H, ie[ne])
              })(this, D, D.getVisibleCoordinates())
            }
            this.options.showPadding && (function(D) {
              const N = D.transform.padding;
              su(D, D.transform.height - (N.top || 0), 3, md), su(D, N.bottom || 0, 3, _d), Xn(D, N.left || 0, 3, ql), Xn(D, D.transform.width - (N.right || 0), 3, ou);
              const H = D.transform.centerPoint;
              (function(ie, ne, se, pe) {
                $a(ie, ne - 1, se - 10, 2, 20, pe), $a(ie, ne - 10, se - 1, 20, 2, pe)
              })(D, H.x, D.transform.height - H.y, rf)
            })(this), this.context.setDefault()
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const i = this.terrainFacilitator.matrix,
              l = this.transform.modelViewProjectionMatrix;
            let u = this.terrainFacilitator.dirty;
            u || (u = e ? !s.c8(i, l) : !s.c9(i, l)), u || (u = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), u && (s.ca(i, l), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(f, g) {
              const C = f.context,
                T = C.gl,
                M = f.transform,
                z = Xr.unblended,
                R = new _r(T.LEQUAL, _r.ReadWrite, [0, 1]),
                D = g.sourceCache.getRenderableTiles(),
                N = f.useProgram("terrainDepth");
              C.bindFramebuffer.set(g.getFramebuffer("depth").framebuffer), C.viewport.set([0, 0, f.width / devicePixelRatio, f.height / devicePixelRatio]), C.clear({
                color: s.bf.transparent,
                depth: 1
              });
              for (const H of D) {
                const ie = g.getTerrainMesh(H.tileID),
                  ne = g.getTerrainData(H.tileID),
                  se = M.getProjectionData({
                    overscaledTileID: H.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  }),
                  pe = {
                    u_ele_delta: g.getMeshFrameDelta(M.zoom)
                  };
                N.draw(C, T.TRIANGLES, R, Wr.disabled, z, mr.backCCW, pe, ne, se, "terrain", ie.vertexBuffer, ie.indexBuffer, ie.segments)
              }
              C.bindFramebuffer.set(null), C.viewport.set([0, 0, f.width, f.height])
            })(this, this.style.map.terrain), (function(f, g) {
              const C = f.context,
                T = C.gl,
                M = f.transform,
                z = Xr.unblended,
                R = new _r(T.LEQUAL, _r.ReadWrite, [0, 1]),
                D = g.getCoordsTexture(),
                N = g.sourceCache.getRenderableTiles(),
                H = f.useProgram("terrainCoords");
              C.bindFramebuffer.set(g.getFramebuffer("coords").framebuffer), C.viewport.set([0, 0, f.width / devicePixelRatio, f.height / devicePixelRatio]), C.clear({
                color: s.bf.transparent,
                depth: 1
              }), g.coordsIndex = [];
              for (const ie of N) {
                const ne = g.getTerrainMesh(ie.tileID),
                  se = g.getTerrainData(ie.tileID);
                C.activeTexture.set(T.TEXTURE0), T.bindTexture(T.TEXTURE_2D, D.texture);
                const pe = {
                    u_terrain_coords_id: (255 - g.coordsIndex.length) / 255,
                    u_texture: 0,
                    u_ele_delta: g.getMeshFrameDelta(M.zoom)
                  },
                  ye = M.getProjectionData({
                    overscaledTileID: ie.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  });
                H.draw(C, T.TRIANGLES, R, Wr.disabled, z, mr.backCCW, pe, se, ye, "terrain", ne.vertexBuffer, ne.indexBuffer, ne.segments), g.coordsIndex.push(ie.tileID.key)
              }
              C.bindFramebuffer.set(null), C.viewport.set([0, 0, f.width, f.height])
            })(this, this.style.map.terrain))
          }
          renderLayer(e, i, l, u, f) {
            l.isHidden(this.transform.zoom) || (l.type === "background" || l.type === "custom" || (u || []).length) && (this.id = l.id, s.cb(l) ? (function(g, C, T, M, z, R) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: D
              } = R, N = Wr.disabled, H = g.colorModeForRenderPass();
              (T._unevaluatedLayout.hasValue("text-variable-anchor") || T._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(ie, ne, se, pe, ye, ge, Te, Le, ve) {
                const Ne = ne.transform,
                  st = ne.style.map.terrain,
                  Xe = ye === "map",
                  Qe = ge === "map";
                for (const at of ie) {
                  const Ht = pe.getTile(at),
                    Xt = Ht.getBucket(se);
                  if (!Xt || !Xt.text || !Xt.text.segments.get().length) continue;
                  const kt = s.an(Xt.textSizeData, Ne.zoom),
                    wr = s.aC(Ht, 1, ne.transform.zoom),
                    dn = $r(Xe, ne.transform, wr),
                    Tn = se.layout.get("icon-text-fit") !== "none" && Xt.hasIconData();
                  if (kt) {
                    const kn = Math.pow(2, Ne.zoom - Ht.tileID.overscaledZ),
                      Sn = st ? (Gn, Yn) => st.getElevation(at, Gn, Yn) : null;
                    tu(Xt, Xe, Qe, ve, Ne, dn, kn, kt, Tn, s.aD(Ne, Ht, Te, Le), at.toUnwrapped(), Sn)
                  }
                }
              })(M, g, T, C, T.layout.get("text-rotation-alignment"), T.layout.get("text-pitch-alignment"), T.paint.get("text-translate"), T.paint.get("text-translate-anchor"), z), T.paint.get("icon-opacity").constantOr(1) !== 0 && Qs(g, C, T, M, !1, T.paint.get("icon-translate"), T.paint.get("icon-translate-anchor"), T.layout.get("icon-rotation-alignment"), T.layout.get("icon-pitch-alignment"), T.layout.get("icon-keep-upright"), N, H, D), T.paint.get("text-opacity").constantOr(1) !== 0 && Qs(g, C, T, M, !0, T.paint.get("text-translate"), T.paint.get("text-translate-anchor"), T.layout.get("text-rotation-alignment"), T.layout.get("text-pitch-alignment"), T.layout.get("text-keep-upright"), N, H, D), C.map.showCollisionBoxes && (dd(g, C, T, M, !0), dd(g, C, T, M, !1))
            })(e, i, l, u, this.style.placement.variableOffsets, f) : s.cc(l) ? (function(g, C, T, M, z) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: R
              } = z, D = T.paint.get("circle-opacity"), N = T.paint.get("circle-stroke-width"), H = T.paint.get("circle-stroke-opacity"), ie = !T.layout.get("circle-sort-key").isConstant();
              if (D.constantOr(1) === 0 && (N.constantOr(1) === 0 || H.constantOr(1) === 0)) return;
              const ne = g.context,
                se = ne.gl,
                pe = g.transform,
                ye = g.getDepthModeForSublayer(0, _r.ReadOnly),
                ge = Wr.disabled,
                Te = g.colorModeForRenderPass(),
                Le = [],
                ve = pe.getCircleRadiusCorrection();
              for (let Ne = 0; Ne < M.length; Ne++) {
                const st = M[Ne],
                  Xe = C.getTile(st),
                  Qe = Xe.getBucket(T);
                if (!Qe) continue;
                const at = T.paint.get("circle-translate"),
                  Ht = T.paint.get("circle-translate-anchor"),
                  Xt = s.aD(pe, Xe, at, Ht),
                  kt = Qe.programConfigurations.get(T.id),
                  wr = g.useProgram("circle", kt),
                  dn = Qe.layoutVertexBuffer,
                  Tn = Qe.indexBuffer,
                  kn = g.style.map.terrain && g.style.map.terrain.getTerrainData(st),
                  Sn = {
                    programConfiguration: kt,
                    program: wr,
                    layoutVertexBuffer: dn,
                    indexBuffer: Tn,
                    uniformValues: qp(g, Xe, T, Xt, ve),
                    terrainData: kn,
                    projectionData: pe.getProjectionData({
                      overscaledTileID: st,
                      applyGlobeMatrix: !R,
                      applyTerrainMatrix: !0
                    })
                  };
                if (ie) {
                  const Gn = Qe.segments.get();
                  for (const Yn of Gn) Le.push({
                    segments: new s.aM([Yn]),
                    sortKey: Yn.sortKey,
                    state: Sn
                  })
                } else Le.push({
                  segments: Qe.segments,
                  sortKey: 0,
                  state: Sn
                })
              }
              ie && Le.sort(((Ne, st) => Ne.sortKey - st.sortKey));
              for (const Ne of Le) {
                const {
                  programConfiguration: st,
                  program: Xe,
                  layoutVertexBuffer: Qe,
                  indexBuffer: at,
                  uniformValues: Ht,
                  terrainData: Xt,
                  projectionData: kt
                } = Ne.state;
                Xe.draw(ne, se.TRIANGLES, ye, ge, Te, mr.backCCW, Ht, Xt, kt, T.id, Qe, at, Ne.segments, T.paint, g.transform.zoom, st)
              }
            })(e, i, l, u, f) : s.cd(l) ? (function(g, C, T, M, z) {
              if (T.paint.get("heatmap-opacity") === 0) return;
              const R = g.context,
                {
                  isRenderingToTexture: D,
                  isRenderingGlobe: N
                } = z;
              if (g.style.map.terrain) {
                for (const H of M) {
                  const ie = C.getTile(H);
                  C.hasRenderableParent(H) || (g.renderPass === "offscreen" ? ru(g, ie, T, H, N) : g.renderPass === "translucent" && fd(g, T, H, D, N))
                }
                R.viewport.set([0, 0, g.width, g.height])
              } else g.renderPass === "offscreen" ? (function(H, ie, ne, se) {
                const pe = H.context,
                  ye = pe.gl,
                  ge = H.transform,
                  Te = Wr.disabled,
                  Le = new Xr([ye.ONE, ye.ONE], s.bf.transparent, [!0, !0, !0, !0]);
                (function(ve, Ne, st) {
                  const Xe = ve.gl;
                  ve.activeTexture.set(Xe.TEXTURE1), ve.viewport.set([0, 0, Ne.width / 4, Ne.height / 4]);
                  let Qe = st.heatmapFbos.get(s.c2);
                  Qe ? (Xe.bindTexture(Xe.TEXTURE_2D, Qe.colorAttachment.get()), ve.bindFramebuffer.set(Qe.framebuffer)) : (Qe = tl(ve, Ne.width / 4, Ne.height / 4), st.heatmapFbos.set(s.c2, Qe))
                })(pe, H, ne), pe.clear({
                  color: s.bf.transparent
                });
                for (let ve = 0; ve < se.length; ve++) {
                  const Ne = se[ve];
                  if (ie.hasRenderableParent(Ne)) continue;
                  const st = ie.getTile(Ne),
                    Xe = st.getBucket(ne);
                  if (!Xe) continue;
                  const Qe = Xe.programConfigurations.get(ne.id),
                    at = H.useProgram("heatmap", Qe),
                    Ht = ge.getProjectionData({
                      overscaledTileID: Ne,
                      applyGlobeMatrix: !0,
                      applyTerrainMatrix: !1
                    }),
                    Xt = ge.getCircleRadiusCorrection();
                  at.draw(pe, ye.TRIANGLES, _r.disabled, Te, Le, mr.backCCW, Jh(st, ge.zoom, ne.paint.get("heatmap-intensity"), Xt), null, Ht, ne.id, Xe.layoutVertexBuffer, Xe.indexBuffer, Xe.segments, ne.paint, ge.zoom, Qe)
                }
                pe.viewport.set([0, 0, H.width, H.height])
              })(g, C, T, M) : g.renderPass === "translucent" && (function(H, ie) {
                const ne = H.context,
                  se = ne.gl;
                ne.setColorMode(H.colorModeForRenderPass());
                const pe = ie.heatmapFbos.get(s.c2);
                pe && (ne.activeTexture.set(se.TEXTURE0), se.bindTexture(se.TEXTURE_2D, pe.colorAttachment.get()), ne.activeTexture.set(se.TEXTURE1), rl(ne, ie).bind(se.LINEAR, se.CLAMP_TO_EDGE), H.useProgram("heatmapTexture").draw(ne, se.TRIANGLES, _r.disabled, Wr.disabled, H.colorModeForRenderPass(), mr.disabled, Vc(H, ie, 0, 1), null, null, ie.id, H.viewportBuffer, H.quadTriangleIndexBuffer, H.viewportSegments, ie.paint, H.transform.zoom))
              })(g, T)
            })(e, i, l, u, f) : s.ce(l) ? (function(g, C, T, M, z) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: R
              } = z, D = T.paint.get("line-opacity"), N = T.paint.get("line-width");
              if (D.constantOr(1) === 0 || N.constantOr(1) === 0) return;
              const H = g.getDepthModeForSublayer(0, _r.ReadOnly),
                ie = g.colorModeForRenderPass(),
                ne = T.paint.get("line-dasharray"),
                se = T.paint.get("line-pattern"),
                pe = se.constantOr(1),
                ye = T.paint.get("line-gradient"),
                ge = T.getCrossfadeParameters(),
                Te = pe ? "linePattern" : ne ? "lineSDF" : ye ? "lineGradient" : "line",
                Le = g.context,
                ve = Le.gl,
                Ne = g.transform;
              let st = !0;
              for (const Xe of M) {
                const Qe = C.getTile(Xe);
                if (pe && !Qe.patternsLoaded()) continue;
                const at = Qe.getBucket(T);
                if (!at) continue;
                const Ht = at.programConfigurations.get(T.id),
                  Xt = g.context.program.get(),
                  kt = g.useProgram(Te, Ht),
                  wr = st || kt.program !== Xt,
                  dn = g.style.map.terrain && g.style.map.terrain.getTerrainData(Xe),
                  Tn = se.constantOr(null);
                if (Tn && Qe.imageAtlas) {
                  const un = Qe.imageAtlas,
                    Mn = un.patternPositions[Tn.to.toString()],
                    li = un.patternPositions[Tn.from.toString()];
                  Mn && li && Ht.setConstantPatternPositions(Mn, li)
                }
                const kn = Ne.getProjectionData({
                    overscaledTileID: Xe,
                    applyGlobeMatrix: !R,
                    applyTerrainMatrix: !0
                  }),
                  Sn = Ne.getPixelScale(),
                  Gn = pe ? Qh(g, Qe, T, Sn, ge) : ne ? Zo(g, Qe, T, Sn, ne, ge) : ye ? Kh(g, Qe, T, Sn, at.lineClipsArray.length) : zl(g, Qe, T, Sn);
                if (pe) Le.activeTexture.set(ve.TEXTURE0), Qe.imageAtlasTexture.bind(ve.LINEAR, ve.CLAMP_TO_EDGE), Ht.updatePaintBuffers(ge);
                else if (ne && (wr || g.lineAtlas.dirty)) Le.activeTexture.set(ve.TEXTURE0), g.lineAtlas.bind(Le);
                else if (ye) {
                  const un = at.gradients[T.id];
                  let Mn = un.texture;
                  if (T.gradientVersion !== un.version) {
                    let li = 256;
                    if (T.stepInterpolant) {
                      const mi = C.getSource().maxzoom,
                        xi = Xe.canonical.z === mi ? Math.ceil(1 << g.transform.maxZoom - Xe.canonical.z) : 1;
                      li = s.ah(s.c3(at.maxLineLength / s.$ * 1024 * xi), 256, Le.maxTextureSize)
                    }
                    un.gradient = s.c4({
                      expression: T.gradientExpression(),
                      evaluationKey: "lineProgress",
                      resolution: li,
                      image: un.gradient || void 0,
                      clips: at.lineClipsArray
                    }), un.texture ? un.texture.update(un.gradient) : un.texture = new s.T(Le, un.gradient, ve.RGBA), un.version = T.gradientVersion, Mn = un.texture
                  }
                  Le.activeTexture.set(ve.TEXTURE0), Mn.bind(T.stepInterpolant ? ve.NEAREST : ve.LINEAR, ve.CLAMP_TO_EDGE)
                }
                const Yn = g.stencilModeForClipping(Xe);
                kt.draw(Le, ve.TRIANGLES, H, Yn, ie, mr.disabled, Gn, dn, kn, T.id, at.layoutVertexBuffer, at.indexBuffer, at.segments, T.paint, g.transform.zoom, Ht, at.layoutVertexBuffer2), st = !1
              }
            })(e, i, l, u, f) : s.cf(l) ? (function(g, C, T, M, z) {
              const R = T.paint.get("fill-color"),
                D = T.paint.get("fill-opacity");
              if (D.constantOr(1) === 0) return;
              const {
                isRenderingToTexture: N
              } = z, H = g.colorModeForRenderPass(), ie = T.paint.get("fill-pattern"), ne = g.opaquePassEnabledForLayer() && !ie.constantOr(1) && R.constantOr(s.bf.transparent).a === 1 && D.constantOr(0) === 1 ? "opaque" : "translucent";
              if (g.renderPass === ne) {
                const se = g.getDepthModeForSublayer(1, g.renderPass === "opaque" ? _r.ReadWrite : _r.ReadOnly);
                Zl(g, C, T, M, se, H, !1, N)
              }
              if (g.renderPass === "translucent" && T.paint.get("fill-antialias")) {
                const se = g.getDepthModeForSublayer(T.getPaintProperty("fill-outline-color") ? 2 : 0, _r.ReadOnly);
                Zl(g, C, T, M, se, H, !0, N)
              }
            })(e, i, l, u, f) : s.cg(l) ? (function(g, C, T, M, z) {
              const R = T.paint.get("fill-extrusion-opacity");
              if (R === 0) return;
              const {
                isRenderingToTexture: D
              } = z;
              if (g.renderPass === "translucent") {
                const N = new _r(g.context.gl.LEQUAL, _r.ReadWrite, g.depthRangeFor3D);
                if (R !== 1 || T.paint.get("fill-extrusion-pattern").constantOr(1)) nu(g, C, T, M, N, Wr.disabled, Xr.disabled, D), nu(g, C, T, M, N, g.stencilModeFor3D(), g.colorModeForRenderPass(), D);
                else {
                  const H = g.colorModeForRenderPass();
                  nu(g, C, T, M, N, Wr.disabled, H, D)
                }
              }
            })(e, i, l, u, f) : s.ch(l) ? (function(g, C, T, M, z) {
              if (g.renderPass !== "offscreen" && g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: R
              } = z, D = g.context, N = g.style.projection.useSubdivision, H = g.getDepthModeForSublayer(0, _r.ReadOnly), ie = g.colorModeForRenderPass();
              if (g.renderPass === "offscreen")(function(ne, se, pe, ye, ge, Te, Le) {
                const ve = ne.context,
                  Ne = ve.gl;
                for (const st of pe) {
                  const Xe = se.getTile(st),
                    Qe = Xe.dem;
                  if (!Qe || !Qe.data || !Xe.needsHillshadePrepare) continue;
                  const at = Qe.dim,
                    Ht = Qe.stride,
                    Xt = Qe.getPixels();
                  if (ve.activeTexture.set(Ne.TEXTURE1), ve.pixelStoreUnpackPremultiplyAlpha.set(!1), Xe.demTexture = Xe.demTexture || ne.getTileTexture(Ht), Xe.demTexture) {
                    const wr = Xe.demTexture;
                    wr.update(Xt, {
                      premultiply: !1
                    }), wr.bind(Ne.NEAREST, Ne.CLAMP_TO_EDGE)
                  } else Xe.demTexture = new s.T(ve, Xt, Ne.RGBA, {
                    premultiply: !1
                  }), Xe.demTexture.bind(Ne.NEAREST, Ne.CLAMP_TO_EDGE);
                  ve.activeTexture.set(Ne.TEXTURE0);
                  let kt = Xe.fbo;
                  if (!kt) {
                    const wr = new s.T(ve, {
                      width: at,
                      height: at,
                      data: null
                    }, Ne.RGBA);
                    wr.bind(Ne.LINEAR, Ne.CLAMP_TO_EDGE), kt = Xe.fbo = ve.createFramebuffer(at, at, !0, !1), kt.colorAttachment.set(wr.texture)
                  }
                  ve.bindFramebuffer.set(kt.framebuffer), ve.viewport.set([0, 0, at, at]), ne.useProgram("hillshadePrepare").draw(ve, Ne.TRIANGLES, ge, Te, Le, mr.disabled, Xh(Xe.tileID, Qe), null, null, ye.id, ne.rasterBoundsBuffer, ne.quadTriangleIndexBuffer, ne.rasterBoundsSegments), Xe.needsHillshadePrepare = !1
                }
              })(g, C, M, T, H, Wr.disabled, ie), D.viewport.set([0, 0, g.width, g.height]);
              else if (g.renderPass === "translucent")
                if (N) {
                  const [ne, se, pe] = g.stencilConfigForOverlapTwoPass(M);
                  $o(g, C, T, pe, ne, H, ie, !1, R), $o(g, C, T, pe, se, H, ie, !0, R)
                } else {
                  const [ne, se] = g.getStencilConfigForOverlapAndUpdateStencilID(M);
                  $o(g, C, T, se, ne, H, ie, !1, R)
                }
            })(e, i, l, u, f) : s.ci(l) ? (function(g, C, T, M, z) {
              if (g.renderPass !== "translucent" || !M.length) return;
              const {
                isRenderingToTexture: R
              } = z, D = g.style.projection.useSubdivision, N = g.getDepthModeForSublayer(0, _r.ReadOnly), H = g.colorModeForRenderPass();
              if (D) {
                const [ie, ne, se] = g.stencilConfigForOverlapTwoPass(M);
                iu(g, C, T, se, ie, N, H, !1, R), iu(g, C, T, se, ne, N, H, !0, R)
              } else {
                const [ie, ne] = g.getStencilConfigForOverlapAndUpdateStencilID(M);
                iu(g, C, T, ne, ie, N, H, !1, R)
              }
            })(e, i, l, u, f) : s.cj(l) ? (function(g, C, T, M, z) {
              if (g.renderPass !== "translucent" || T.paint.get("raster-opacity") === 0 || !M.length) return;
              const {
                isRenderingToTexture: R
              } = z, D = C.getSource(), N = g.style.projection.useSubdivision;
              if (D instanceof Zt) Go(g, C, T, M, null, !1, !1, D.tileCoords, D.flippedWindingOrder, R);
              else if (N) {
                const [H, ie, ne] = g.stencilConfigForOverlapTwoPass(M);
                Go(g, C, T, ne, H, !1, !0, Vl, !1, R), Go(g, C, T, ne, ie, !0, !0, Vl, !1, R)
              } else {
                const [H, ie] = g.getStencilConfigForOverlapAndUpdateStencilID(M);
                Go(g, C, T, ie, H, !1, !0, Vl, !1, R)
              }
            })(e, i, l, u, f) : s.ck(l) ? (function(g, C, T, M, z) {
              const R = T.paint.get("background-color"),
                D = T.paint.get("background-opacity");
              if (D === 0) return;
              const {
                isRenderingToTexture: N
              } = z, H = g.context, ie = H.gl, ne = g.style.projection, se = g.transform, pe = se.tileSize, ye = T.paint.get("background-pattern");
              if (g.isPatternMissing(ye)) return;
              const ge = !ye && R.a === 1 && D === 1 && g.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (g.renderPass !== ge) return;
              const Te = Wr.disabled,
                Le = g.getDepthModeForSublayer(0, ge === "opaque" ? _r.ReadWrite : _r.ReadOnly),
                ve = g.colorModeForRenderPass(),
                Ne = g.useProgram(ye ? "backgroundPattern" : "background"),
                st = M || we(se, {
                  tileSize: pe,
                  terrain: g.style.map.terrain
                });
              ye && (H.activeTexture.set(ie.TEXTURE0), g.imageManager.bind(g.context));
              const Xe = T.getCrossfadeParameters();
              for (const Qe of st) {
                const at = se.getProjectionData({
                    overscaledTileID: Qe,
                    applyGlobeMatrix: !N,
                    applyTerrainMatrix: !0
                  }),
                  Ht = ye ? rd(D, g, ye, {
                    tileID: Qe,
                    tileSize: pe
                  }, Xe) : td(D, R),
                  Xt = g.style.map.terrain && g.style.map.terrain.getTerrainData(Qe),
                  kt = ne.getMeshFromTileID(H, Qe.canonical, !1, !0, "raster");
                Ne.draw(H, ie.TRIANGLES, Le, Te, ve, mr.backCCW, Ht, Xt, at, T.id, kt.vertexBuffer, kt.indexBuffer, kt.segments)
              }
            })(e, 0, l, u, f) : s.cl(l) && (function(g, C, T, M) {
              const {
                isRenderingGlobe: z
              } = M, R = g.context, D = T.implementation, N = g.style.projection, H = g.transform, ie = H.getProjectionDataForCustomLayer(z), ne = {
                farZ: H.farZ,
                nearZ: H.nearZ,
                fov: H.fov * Math.PI / 180,
                modelViewProjectionMatrix: H.modelViewProjectionMatrix,
                projectionMatrix: H.projectionMatrix,
                shaderData: {
                  variantName: N.shaderVariantName,
                  vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${N.shaderPreludeCode.vertexSource}`,
                  define: N.shaderDefine
                },
                defaultProjectionData: ie
              }, se = D.renderingMode ? D.renderingMode : "2d";
              if (g.renderPass === "offscreen") {
                const pe = D.prerender;
                pe && (g.setCustomLayerDefaults(), R.setColorMode(g.colorModeForRenderPass()), pe.call(D, R.gl, ne), R.setDirty(), g.setBaseState())
              } else if (g.renderPass === "translucent") {
                g.setCustomLayerDefaults(), R.setColorMode(g.colorModeForRenderPass()), R.setStencilMode(Wr.disabled);
                const pe = se === "3d" ? g.getDepthModeFor3D() : g.getDepthModeForSublayer(0, _r.ReadOnly);
                R.setDepthMode(pe), D.render(R.gl, ne), R.setDirty(), g.setBaseState(), R.bindFramebuffer.set(null)
              }
            })(e, 0, l, f))
          }
          saveTileTexture(e) {
            const i = this._tileTextures[e.size[0]];
            i ? i.push(e) : this._tileTextures[e.size[0]] = [e]
          }
          getTileTexture(e) {
            const i = this._tileTextures[e];
            return i && i.length > 0 ? i.pop() : null
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const i = this.imageManager.getPattern(e.from.toString()),
              l = this.imageManager.getPattern(e.to.toString());
            return !i || !l
          }
          useProgram(e, i, l = !1, u = []) {
            this.cache = this.cache || {};
            const f = !!this.style.map.terrain,
              g = this.style.projection,
              C = l ? Kt.projectionMercator : g.shaderPreludeCode,
              T = l ? Qn : g.shaderDefine,
              M = e + (i ? i.cacheKey : "") + `/${l?En:g.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (f ? "/terrain" : "") + (u ? `/${u.join("/")}` : "");
            return this.cache[M] || (this.cache[M] = new Zc(this.context, Kt[e], i, Wc[e], this._showOverdrawInspector, f, C, T, u)), this.cache[M]
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD)
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new s.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA))
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy()
          }
          overLimit() {
            const {
              drawingBufferWidth: e,
              drawingBufferHeight: i
            } = this.context.gl;
            return this.width !== e || this.height !== i
          }
        }

        function Wo(p, e) {
          let i, l = !1,
            u = null,
            f = null;
          const g = () => {
            u = null, l && (p.apply(f, i), u = setTimeout(g, e), l = !1)
          };
          return (...C) => (l = !0, f = this, i = C, u || g(), u)
        }
        class $l {
          constructor(e) {
            this._getCurrentHash = () => {
              const i = window.location.hash.replace("#", "");
              if (this._hashName) {
                let l;
                return i.split("&").map((u => u.split("="))).forEach((u => {
                  u[0] === this._hashName && (l = u)
                })), (l && l[1] || "").split("/")
              }
              return i.split("/")
            }, this._onHashChange = () => {
              const i = this._getCurrentHash();
              if (!this._isValidHash(i)) return !1;
              const l = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(i[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({
                center: [+i[2], +i[1]],
                zoom: +i[0],
                bearing: l,
                pitch: +(i[4] || 0)
              }), !0
            }, this._updateHashUnthrottled = () => {
              const i = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, i)
            }, this._removeHash = () => {
              const i = this._getCurrentHash();
              if (i.length === 0) return;
              const l = i.join("/");
              let u = l;
              u.split("&").length > 0 && (u = u.split("&")[0]), this._hashName && (u = `${this._hashName}=${l}`);
              let f = window.location.hash.replace(u, "");
              f.startsWith("#&") ? f = f.slice(0, 1) + f.slice(2) : f === "#" && (f = "");
              let g = window.location.href.replace(/(#.+)?$/, f);
              g = g.replace("&&", "&"), window.history.replaceState(window.history.state, null, g)
            }, this._updateHash = Wo(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e)
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this
          }
          getHashString(e) {
            const i = this._map.getCenter(),
              l = Math.round(100 * this._map.getZoom()) / 100,
              u = Math.ceil((l * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
              f = Math.pow(10, u),
              g = Math.round(i.lng * f) / f,
              C = Math.round(i.lat * f) / f,
              T = this._map.getBearing(),
              M = this._map.getPitch();
            let z = "";
            if (z += e ? `/${g}/${C}/${l}` : `${l}/${C}/${g}`, (T || M) && (z += "/" + Math.round(10 * T) / 10), M && (z += `/${Math.round(M)}`), this._hashName) {
              const R = this._hashName;
              let D = !1;
              const N = window.location.hash.slice(1).split("&").map((H => {
                const ie = H.split("=")[0];
                return ie === R ? (D = !0, `${ie}=${z}`) : H
              })).filter((H => H));
              return D || N.push(`${R}=${z}`), `#${N.join("&")}`
            }
            return `#${z}`
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new s.S(+e[2], +e[1])
            } catch {
              return !1
            }
            const i = +e[0],
              l = +(e[3] || 0),
              u = +(e[4] || 0);
            return i >= this._map.getMinZoom() && i <= this._map.getMaxZoom() && l >= -180 && l <= 180 && u >= this._map.getMinPitch() && u <= this._map.getMaxPitch()
          }
        }
        const io = {
            linearity: .3,
            easing: s.cm(0, 0, .3, 1)
          },
          lu = s.e({
            deceleration: 2500,
            maxSpeed: 1400
          }, io),
          vd = s.e({
            deceleration: 20,
            maxSpeed: 1400
          }, io),
          yd = s.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, io),
          xd = s.e({
            deceleration: 1e3,
            maxSpeed: 90
          }, io),
          bd = s.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, io);
        class wd {
          constructor(e) {
            this._map = e, this.clear()
          }
          clear() {
            this._inertiaBuffer = []
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({
              time: Q.now(),
              settings: e
            })
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer,
              i = Q.now();
            for (; e.length > 0 && i - e[0].time > 160;) e.shift()
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const i = {
              zoom: 0,
              bearing: 0,
              pitch: 0,
              roll: 0,
              pan: new s.P(0, 0),
              pinchAround: void 0,
              around: void 0
            };
            for (const {
                settings: f
              }
              of this._inertiaBuffer) i.zoom += f.zoomDelta || 0, i.bearing += f.bearingDelta || 0, i.pitch += f.pitchDelta || 0, i.roll += f.rollDelta || 0, f.panDelta && i.pan._add(f.panDelta), f.around && (i.around = f.around), f.pinchAround && (i.pinchAround = f.pinchAround);
            const l = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
              u = {};
            if (i.pan.mag()) {
              const f = gs(i.pan.mag(), l, s.e({}, lu, e || {})),
                g = i.pan.mult(f.amount / i.pan.mag()),
                C = this._map.cameraHelper.handlePanInertia(g, this._map.transform);
              u.center = C.easingCenter, u.offset = C.easingOffset, Sa(u, f)
            }
            if (i.zoom) {
              const f = gs(i.zoom, l, vd);
              u.zoom = this._map.transform.zoom + f.amount, Sa(u, f)
            }
            if (i.bearing) {
              const f = gs(i.bearing, l, yd);
              u.bearing = this._map.transform.bearing + s.ah(f.amount, -179, 179), Sa(u, f)
            }
            if (i.pitch) {
              const f = gs(i.pitch, l, xd);
              u.pitch = this._map.transform.pitch + f.amount, Sa(u, f)
            }
            if (i.roll) {
              const f = gs(i.roll, l, bd);
              u.roll = this._map.transform.roll + s.ah(f.amount, -179, 179), Sa(u, f)
            }
            if (u.zoom || u.bearing) {
              const f = i.pinchAround === void 0 ? i.around : i.pinchAround;
              u.around = f ? this._map.unproject(f) : this._map.getCenter()
            }
            return this.clear(), s.e(u, {
              noMoveStart: !0
            })
          }
        }

        function Sa(p, e) {
          (!p.duration || p.duration < e.duration) && (p.duration = e.duration, p.easing = e.easing)
        }

        function gs(p, e, i) {
          const {
            maxSpeed: l,
            linearity: u,
            deceleration: f
          } = i, g = s.ah(p * u / (e / 1e3), -l, l), C = Math.abs(g) / (f * u);
          return {
            easing: i.easing,
            duration: 1e3 * C,
            amount: g * (C / 2)
          }
        }
        class Yi extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, i, l, u = {}) {
            l = l instanceof MouseEvent ? l : new MouseEvent(e, l);
            const f = W.mousePos(i.getCanvas(), l),
              g = i.unproject(f);
            super(e, s.e({
              point: f,
              lngLat: g,
              originalEvent: l
            }, u)), this._defaultPrevented = !1, this.target = i
          }
        }
        class vs extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, i, l) {
            const u = e === "touchend" ? l.changedTouches : l.touches,
              f = W.touchPos(i.getCanvasContainer(), u),
              g = f.map((T => i.unproject(T))),
              C = f.reduce(((T, M, z, R) => T.add(M.div(R.length))), new s.P(0, 0));
            super(e, {
              points: f,
              point: C,
              lngLats: g,
              lngLat: i.unproject(C),
              originalEvent: l
            }), this._defaultPrevented = !1
          }
        }
        class cu extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, i, l) {
            super(e, {
              originalEvent: l
            }), this._defaultPrevented = !1
          }
        }
        class Cd {
          constructor(e, i) {
            this._map = e, this._clickTolerance = i.clickTolerance
          }
          reset() {
            delete this._mousedownPos
          }
          wheel(e) {
            return this._firePreventable(new cu(e.type, this._map, e))
          }
          mousedown(e, i) {
            return this._mousedownPos = i, this._firePreventable(new Yi(e.type, this._map, e))
          }
          mouseup(e) {
            this._map.fire(new Yi(e.type, this._map, e))
          }
          click(e, i) {
            this._mousedownPos && this._mousedownPos.dist(i) >= this._clickTolerance || this._map.fire(new Yi(e.type, this._map, e))
          }
          dblclick(e) {
            return this._firePreventable(new Yi(e.type, this._map, e))
          }
          mouseover(e) {
            this._map.fire(new Yi(e.type, this._map, e))
          }
          mouseout(e) {
            this._map.fire(new Yi(e.type, this._map, e))
          }
          touchstart(e) {
            return this._firePreventable(new vs(e.type, this._map, e))
          }
          touchmove(e) {
            this._map.fire(new vs(e.type, this._map, e))
          }
          touchend(e) {
            this._map.fire(new vs(e.type, this._map, e))
          }
          touchcancel(e) {
            this._map.fire(new vs(e.type, this._map, e))
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {}
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class Td {
          constructor(e) {
            this._map = e
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent
          }
          mousemove(e) {
            this._map.fire(new Yi(e.type, this._map, e))
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Yi("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Yi(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault()
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class ys {
          constructor(e) {
            this._map = e
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat
            }
          }
          get zoom() {
            return this.transform.zoom
          }
          get pitch() {
            return this.transform.pitch
          }
          get bearing() {
            return this.transform.bearing
          }
          unproject(e) {
            return this.transform.screenPointToLocation(s.P.convert(e), this._map.terrain)
          }
        }
        class uu {
          constructor(e, i) {
            this._map = e, this._tr = new ys(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = i.clickTolerance || 1
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
          enable() {
            this.isEnabled() || (this._enabled = !0)
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          mousedown(e, i) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (W.disableDrag(), this._startPos = this._lastPos = i, this._active = !0)
          }
          mousemoveWindow(e, i) {
            if (!this._active) return;
            const l = i;
            if (this._lastPos.equals(l) || !this._box && l.dist(this._startPos) < this._clickTolerance) return;
            const u = this._startPos;
            this._lastPos = l, this._box || (this._box = W.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const f = Math.min(u.x, l.x),
              g = Math.max(u.x, l.x),
              C = Math.min(u.y, l.y),
              T = Math.max(u.y, l.y);
            W.setTransform(this._box, `translate(${f}px,${C}px)`), this._box.style.width = g - f + "px", this._box.style.height = T - C + "px"
          }
          mouseupWindow(e, i) {
            if (!this._active || e.button !== 0) return;
            const l = this._startPos,
              u = i;
            if (this.reset(), W.suppressClick(), l.x !== u.x || l.y !== u.y) return this._map.fire(new s.l("boxzoomend", {
              originalEvent: e
            })), {
              cameraAnimation: f => f.fitScreenCoordinates(l, u, this._tr.bearing, {
                linear: !0
              })
            };
            this._fireEvent("boxzoomcancel", e)
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e))
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (W.remove(this._box), this._box = null), W.enableDrag(), delete this._startPos, delete this._lastPos
          }
          _fireEvent(e, i) {
            return this._map.fire(new s.l(e, {
              originalEvent: i
            }))
          }
        }

        function xs(p, e) {
          if (p.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${p.length}, points ${e.length}`);
          const i = {};
          for (let l = 0; l < p.length; l++) i[p[l].identifier] = e[l];
          return i
        }
        class Sd {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1
          }
          touchstart(e, i, l) {
            (this.centroid || l.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), l.length === this.numTouches && (this.centroid = (function(u) {
              const f = new s.P(0, 0);
              for (const g of u) f._add(g);
              return f.div(u.length)
            })(i), this.touches = xs(l, i)))
          }
          touchmove(e, i, l) {
            if (this.aborted || !this.centroid) return;
            const u = xs(l, i);
            for (const f in this.touches) {
              const g = u[f];
              (!g || g.dist(this.touches[f]) > 30) && (this.aborted = !0)
            }
          }
          touchend(e, i, l) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), l.length === 0) {
              const u = !this.aborted && this.centroid;
              if (this.reset(), u) return u
            }
          }
        }
        class Ki {
          constructor(e) {
            this.singleTap = new Sd(e), this.numTaps = e.numTaps, this.reset()
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset()
          }
          touchstart(e, i, l) {
            this.singleTap.touchstart(e, i, l)
          }
          touchmove(e, i, l) {
            this.singleTap.touchmove(e, i, l)
          }
          touchend(e, i, l) {
            const u = this.singleTap.touchend(e, i, l);
            if (u) {
              const f = e.timeStamp - this.lastTime < 500,
                g = !this.lastTap || this.lastTap.dist(u) < 30;
              if (f && g || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = u, this.count === this.numTaps) return this.reset(), u
            }
          }
        }
        class Ia {
          constructor(e) {
            this._tr = new ys(e), this._zoomIn = new Ki({
              numTouches: 1,
              numTaps: 2
            }), this._zoomOut = new Ki({
              numTouches: 2,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
          }
          touchstart(e, i, l) {
            this._zoomIn.touchstart(e, i, l), this._zoomOut.touchstart(e, i, l)
          }
          touchmove(e, i, l) {
            this._zoomIn.touchmove(e, i, l), this._zoomOut.touchmove(e, i, l)
          }
          touchend(e, i, l) {
            const u = this._zoomIn.touchend(e, i, l),
              f = this._zoomOut.touchend(e, i, l),
              g = this._tr;
            return u ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: C => C.easeTo({
                duration: 300,
                zoom: g.zoom + 1,
                around: g.unproject(u)
              }, {
                originalEvent: e
              })
            }) : f ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: C => C.easeTo({
                duration: 300,
                zoom: g.zoom - 1,
                around: g.unproject(f)
              }, {
                originalEvent: e
              })
            }) : void 0
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class bs {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset()
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e)
          }
          _move(...e) {
            const i = this._moveFunction(...e);
            if (i.bearingDelta || i.pitchDelta || i.rollDelta || i.around || i.panDelta) return this._active = !0, i
          }
          dragStart(e, i) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(i) ? i[0] : i, this._activateOnStart && this._lastPoint && (this._active = !0))
          }
          dragMove(e, i) {
            if (!this.isEnabled()) return;
            const l = this._lastPoint;
            if (!l) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const u = Array.isArray(i) ? i[0] : i;
            return !this._moved && u.dist(l) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = u, this._move(l, u))
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && W.suppressClick(), this.reset(e))
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          getClickTolerance() {
            return this._clickTolerance
          }
        }
        const Pa = 0,
          ws = 2,
          nf = {
            [Pa]: 1,
            [ws]: 2
          };
        class al {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent
          }
          startMove(e) {
            const i = W.mouseButton(e);
            this._eventButton = i
          }
          endMove(e) {
            delete this._eventButton
          }
          isValidStartEvent(e) {
            return this._correctEvent(e)
          }
          isValidMoveEvent(e) {
            return !(function(i, l) {
              const u = nf[l];
              return i.buttons === void 0 || (i.buttons & u) !== u
            })(e, this._eventButton)
          }
          isValidEndEvent(e) {
            return W.mouseButton(e) === this._eventButton
          }
        }
        class af {
          constructor() {
            this._firstTouch = void 0
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier
          }
          endMove(e) {
            delete this._firstTouch
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e)
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
        }
        class of {
          constructor(e = new al({
            checkCorrectEvent: () => !0
          }), i = new af) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = i
          }
          _executeRelevantHandler(e, i, l) {
            return e instanceof MouseEvent ? i(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? l(e) : void 0
          }
          startMove(e) {
            this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.startMove(i)), (i => this.oneFingerTouchMoveStateManager.startMove(i)))
          }
          endMove(e) {
            this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.endMove(i)), (i => this.oneFingerTouchMoveStateManager.endMove(i)))
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.isValidStartEvent(i)), (i => this.oneFingerTouchMoveStateManager.isValidStartEvent(i)))
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.isValidMoveEvent(i)), (i => this.oneFingerTouchMoveStateManager.isValidMoveEvent(i)))
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.isValidEndEvent(i)), (i => this.oneFingerTouchMoveStateManager.isValidEndEvent(i)))
          }
        }
        const ol = p => {
          p.mousedown = p.dragStart, p.mousemoveWindow = p.dragMove, p.mouseup = p.dragEnd, p.contextmenu = e => {
            e.preventDefault()
          }
        };
        class sl {
          constructor(e, i) {
            this._clickTolerance = e.clickTolerance || 1, this._map = i, this.reset()
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new s.P(0, 0)
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
          }
          touchstart(e, i, l) {
            return this._calculateTransform(e, i, l)
          }
          touchmove(e, i, l) {
            if (this._active) {
              if (!this._shouldBePrevented(l.length)) return e.preventDefault(), this._calculateTransform(e, i, l);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
            }
          }
          touchend(e, i, l) {
            this._calculateTransform(e, i, l), this._active && this._shouldBePrevented(l.length) && this.reset()
          }
          touchcancel() {
            this.reset()
          }
          _calculateTransform(e, i, l) {
            l.length > 0 && (this._active = !0);
            const u = xs(l, i),
              f = new s.P(0, 0),
              g = new s.P(0, 0);
            let C = 0;
            for (const M in u) {
              const z = u[M],
                R = this._touches[M];
              R && (f._add(z), g._add(z.sub(R)), C++, u[M] = z)
            }
            if (this._touches = u, this._shouldBePrevented(C) || !g.mag()) return;
            const T = g.div(C);
            return this._sum._add(T), this._sum.mag() < this._clickTolerance ? void 0 : {
              around: f.div(C),
              panDelta: T
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class ka {
          constructor() {
            this.reset()
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches
          }
          touchstart(e, i, l) {
            this._firstTwoTouches || l.length < 2 || (this._firstTwoTouches = [l[0].identifier, l[1].identifier], this._start([i[0], i[1]]))
          }
          touchmove(e, i, l) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [u, f] = this._firstTwoTouches, g = hr(l, i, u), C = hr(l, i, f);
            if (!g || !C) return;
            const T = this._aroundCenter ? null : g.add(C).div(2);
            return this._move([g, C], T, e)
          }
          touchend(e, i, l) {
            if (!this._firstTwoTouches) return;
            const [u, f] = this._firstTwoTouches, g = hr(l, i, u), C = hr(l, i, f);
            g && C || (this._active && W.suppressClick(), this.reset())
          }
          touchcancel() {
            this.reset()
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center"
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
        }

        function hr(p, e, i) {
          for (let l = 0; l < p.length; l++)
            if (p[l].identifier === i) return e[l]
        }

        function hu(p, e) {
          return Math.log(p / e) / Math.LN2
        }
        class Gl extends ka {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1])
          }
          _move(e, i) {
            const l = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(hu(this._distance, this._startDistance)) < .1)) return this._active = !0, {
              zoomDelta: hu(this._distance, l),
              pinchAround: i
            }
          }
        }

        function du(p, e) {
          return 180 * p.angleWith(e) / Math.PI
        }
        class Cs extends ka {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1])
          }
          _move(e, i, l) {
            const u = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
              bearingDelta: du(this._vector, u),
              pinchAround: i
            }
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const i = 25 / (Math.PI * this._minDiameter) * 360,
              l = du(e, this._startVector);
            return Math.abs(l) < i
          }
        }

        function Ho(p) {
          return Math.abs(p.y) > Math.abs(p.x)
        }
        class Wl extends ka {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints
          }
          touchstart(e, i, l) {
            super.touchstart(e, i, l), this._currentTouchCount = l.length
          }
          _start(e) {
            this._lastPoints = e, Ho(e[0].sub(e[1])) && (this._valid = !1)
          }
          _move(e, i, l) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const u = e[0].sub(this._lastPoints[0]),
              f = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(u, f, l.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, {
              pitchDelta: (u.y + f.y) / 2 * -.5
            }) : void 0
          }
          gestureBeginsVertically(e, i, l) {
            if (this._valid !== void 0) return this._valid;
            const u = e.mag() >= 2,
              f = i.mag() >= 2;
            if (!u && !f) return;
            if (!u || !f) return this._firstMove === void 0 && (this._firstMove = l), l - this._firstMove < 100 && void 0;
            const g = e.y > 0 == i.y > 0;
            return Ho(e) && Ho(i) && g
          }
        }
        const _n = {
          panStep: 100,
          bearingStep: 15,
          pitchStep: 10
        };
        class Hl {
          constructor(e) {
            this._tr = new ys(e);
            const i = _n;
            this._panStep = i.panStep, this._bearingStep = i.bearingStep, this._pitchStep = i.pitchStep, this._rotationDisabled = !1
          }
          reset() {
            this._active = !1
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let i = 0,
              l = 0,
              u = 0,
              f = 0,
              g = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                i = 1;
                break;
              case 189:
              case 109:
              case 173:
                i = -1;
                break;
              case 37:
                e.shiftKey ? l = -1 : (e.preventDefault(), f = -1);
                break;
              case 39:
                e.shiftKey ? l = 1 : (e.preventDefault(), f = 1);
                break;
              case 38:
                e.shiftKey ? u = 1 : (e.preventDefault(), g = -1);
                break;
              case 40:
                e.shiftKey ? u = -1 : (e.preventDefault(), g = 1);
                break;
              default:
                return
            }
            return this._rotationDisabled && (l = 0, u = 0), {
              cameraAnimation: C => {
                const T = this._tr;
                C.easeTo({
                  duration: 300,
                  easeId: "keyboardHandler",
                  easing: sf,
                  zoom: i ? Math.round(T.zoom) + i * (e.shiftKey ? 2 : 1) : T.zoom,
                  bearing: T.bearing + l * this._bearingStep,
                  pitch: T.pitch + u * this._pitchStep,
                  offset: [-f * this._panStep, -g * this._panStep],
                  center: T.center
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          disableRotation() {
            this._rotationDisabled = !0
          }
          enableRotation() {
            this._rotationDisabled = !1
          }
        }

        function sf(p) {
          return p * (2 - p)
        }
        const Jl = 4.000244140625,
          lf = 1 / 450;
        class Id {
          constructor(e, i) {
            this._onTimeout = l => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(l)
            }, this._map = e, this._tr = new ys(e), this._triggerRenderFrame = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = lf
          }
          setZoomRate(e) {
            this._defaultZoomRate = e
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0
          }
          isZooming() {
            return !!this._zooming
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center")
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let i = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const l = Q.now(),
              u = l - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = l, i !== 0 && i % Jl == 0 ? this._type = "wheel" : i !== 0 && Math.abs(i) < 4 ? this._type = "trackpad" : u > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(u * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), e.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = e, this._delta -= i, this._active || this._start(e)), e.preventDefault()
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const i = W.mousePos(this._map.getCanvas(), e),
              l = this._tr;
            this._aroundPoint = this._aroundCenter ? l.transform.locationToScreenPoint(s.S.convert(l.center)) : i, this._frameId || (this._frameId = !0, this._triggerRenderFrame())
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const C = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += C), typeof this._targetZoom == "number" && (this._targetZoom += C)
            }
            if (this._delta !== 0) {
              const C = this._type === "wheel" && Math.abs(this._delta) > Jl ? this._wheelZoomRate : this._defaultZoomRate;
              let T = 2 / (1 + Math.exp(-Math.abs(this._delta * C)));
              this._delta < 0 && T !== 0 && (T = 1 / T);
              const M = typeof this._targetZoom != "number" ? e.scale : s.af(this._targetZoom);
              this._targetZoom = e.getConstrained(e.getCameraLngLat(), s.ak(M * T)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0
            }
            const i = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom,
              l = this._startZoom,
              u = this._easing;
            let f, g = !1;
            if (this._type === "wheel" && l && u) {
              const C = Q.now() - this._lastWheelEventTime,
                T = Math.min((C + 5) / 200, 1),
                M = u(T);
              f = s.C.number(l, i, M), T < 1 ? this._frameId || (this._frameId = !0) : g = !0
            } else f = i, g = !0;
            return this._active = !0, g && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout
            }), 200)), this._lastExpectedZoom = f, {
              noInertia: !0,
              needsRenderFrame: !g,
              zoomDelta: f - e.zoom,
              around: this._aroundPoint,
              originalEvent: this._lastWheelEvent
            }
          }
          _smoothOutEasing(e) {
            let i = s.co;
            if (this._prevEase) {
              const l = this._prevEase,
                u = (Q.now() - l.start) / l.duration,
                f = l.easing(u + .01) - l.easing(u),
                g = .27 / Math.sqrt(f * f + 1e-4) * .01,
                C = Math.sqrt(.0729 - g * g);
              i = s.cm(g, C, .25, 1)
            }
            return this._prevEase = {
              start: Q.now(),
              duration: e,
              easing: i
            }, i
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout)
          }
        }
        class pu {
          constructor(e, i) {
            this._clickZoom = e, this._tapZoom = i
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable()
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable()
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive()
          }
        }
        class fu {
          constructor(e) {
            this._tr = new ys(e), this.reset()
          }
          reset() {
            this._active = !1
          }
          dblclick(e, i) {
            return e.preventDefault(), {
              cameraAnimation: l => {
                l.easeTo({
                  duration: 300,
                  zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                  around: this._tr.unproject(i)
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Pd {
          constructor() {
            this._tap = new Ki({
              numTouches: 1,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset()
          }
          touchstart(e, i, l) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const u = i[0],
                  f = e.timeStamp - this._tapTime < 500,
                  g = this._tapPoint.dist(u) < 30;
                f && g ? l.length > 0 && (this._swipePoint = u, this._swipeTouch = l[0].identifier) : this.reset()
              } else this._tap.touchstart(e, i, l)
          }
          touchmove(e, i, l) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (l[0].identifier !== this._swipeTouch) return;
                const u = i[0],
                  f = u.y - this._swipePoint.y;
                return this._swipePoint = u, e.preventDefault(), this._active = !0, {
                  zoomDelta: f / 128
                }
              }
            } else this._tap.touchmove(e, i, l)
          }
          touchend(e, i, l) {
            if (this._tapTime) this._swipePoint && l.length === 0 && this.reset();
            else {
              const u = this._tap.touchend(e, i, l);
              u && (this._tapTime = e.timeStamp, this._tapPoint = u)
            }
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class kd {
          constructor(e, i, l) {
            this._el = e, this._mousePan = i, this._touchPan = l
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan")
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan")
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled()
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive()
          }
        }
        class mu {
          constructor(e, i, l, u) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = i, this._mousePitch = l, this._mouseRoll = u
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable()
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable()
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
          }
        }
        class Md {
          constructor(e, i, l, u) {
            this._el = e, this._touchZoom = i, this._touchRotate = l, this._tapDragZoom = u, this._rotationDisabled = !1, this._enabled = !0
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate")
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate")
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable()
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
          }
        }
        class Ad {
          constructor(e, i) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = i, this._enabled = !1
          }
          isActive() {
            return !1
          }
          reset() {}
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = W.create("div", "maplibregl-cooperative-gesture-screen", e);
            let i = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (i = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const l = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"),
              u = document.createElement("div");
            u.className = "maplibregl-desktop-message", u.textContent = i, this._container.appendChild(u);
            const f = document.createElement("div");
            f.className = "maplibregl-mobile-message", f.textContent = l, this._container.appendChild(f), this._container.setAttribute("aria-hidden", "true")
          }
          _destroyUI() {
            this._container && (W.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container
          }
          enable() {
            this._setupUI(), this._enabled = !0
          }
          disable() {
            this._enabled = !1, this._destroyUI()
          }
          isEnabled() {
            return this._enabled
          }
          isBypassed(e) {
            return e[this._bypassKey]
          }
          notifyGestureBlocked(e, i) {
            this._enabled && (this._map.fire(new s.l("cooperativegestureprevented", {
              gestureType: e,
              originalEvent: i
            })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show")
            }), 100))
          }
        }
        const Ma = p => p.zoom || p.drag || p.roll || p.pitch || p.rotate;
        class Un extends s.l {}

        function Ts(p) {
          return p.panDelta && p.panDelta.mag() || p.zoomDelta || p.bearingDelta || p.pitchDelta || p.rollDelta
        }
        class _u {
          constructor(e, i) {
            this.handleWindowEvent = u => {
              this.handleEvent(u, `${u.type}Window`)
            }, this.handleEvent = (u, f) => {
              if (u.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const g = u.type === "renderFrame" ? void 0 : u,
                C = {
                  needsRenderFrame: !1
                },
                T = {},
                M = {};
              for (const {
                  handlerName: D,
                  handler: N,
                  allowed: H
                }
                of this._handlers) {
                if (!N.isEnabled()) continue;
                let ie;
                if (this._blockedByActive(M, H, D)) N.reset();
                else if (N[f || u.type]) {
                  if (s.cp(u, f || u.type)) {
                    const ne = W.mousePos(this._map.getCanvas(), u);
                    ie = N[f || u.type](u, ne)
                  } else if (s.cq(u, f || u.type)) {
                    const ne = this._getMapTouches(u.touches),
                      se = W.touchPos(this._map.getCanvas(), ne);
                    ie = N[f || u.type](u, se, ne)
                  } else s.cr(f || u.type) || (ie = N[f || u.type](u));
                  this.mergeHandlerResult(C, T, ie, D, g), ie && ie.needsRenderFrame && this._triggerRenderFrame()
                }(ie || N.isActive()) && (M[D] = N)
              }
              const z = {};
              for (const D in this._previousActiveHandlers) M[D] || (z[D] = g);
              this._previousActiveHandlers = M, (Object.keys(z).length || Ts(C)) && (this._changes.push([C, T, z]), this._triggerRenderFrame()), (Object.keys(M).length || Ts(C)) && this._map._stop(!0), this._updatingCamera = !1;
              const {
                cameraAnimation: R
              } = C;
              R && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], R(this._map))
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new wd(e), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i);
            const l = this._el;
            this._listeners = [
              [l, "touchstart", {
                passive: !0
              }],
              [l, "touchmove", {
                passive: !1
              }],
              [l, "touchend", void 0],
              [l, "touchcancel", void 0],
              [l, "mousedown", void 0],
              [l, "mousemove", void 0],
              [l, "mouseup", void 0],
              [document, "mousemove", {
                capture: !0
              }],
              [document, "mouseup", void 0],
              [l, "mouseover", void 0],
              [l, "mouseout", void 0],
              [l, "dblclick", void 0],
              [l, "click", void 0],
              [l, "keydown", {
                capture: !1
              }],
              [l, "keyup", void 0],
              [l, "wheel", {
                passive: !1
              }],
              [l, "contextmenu", void 0],
              [window, "blur", void 0]
            ];
            for (const [u, f, g] of this._listeners) W.addEventListener(u, f, u === document ? this.handleWindowEvent : this.handleEvent, g)
          }
          destroy() {
            for (const [e, i, l] of this._listeners) W.removeEventListener(e, i, e === document ? this.handleWindowEvent : this.handleEvent, l)
          }
          _addDefaultHandlers(e) {
            const i = this._map,
              l = i.getCanvasContainer();
            this._add("mapEvent", new Cd(i, e));
            const u = i.boxZoom = new uu(i, e);
            this._add("boxZoom", u), e.interactive && e.boxZoom && u.enable();
            const f = i.cooperativeGestures = new Ad(i, e.cooperativeGestures);
            this._add("cooperativeGestures", f), e.cooperativeGestures && f.enable();
            const g = new Ia(i),
              C = new fu(i);
            i.doubleClickZoom = new pu(C, g), this._add("tapZoom", g), this._add("clickZoom", C), e.interactive && e.doubleClickZoom && i.doubleClickZoom.enable();
            const T = new Pd;
            this._add("tapDragZoom", T);
            const M = i.touchPitch = new Wl(i);
            this._add("touchPitch", M), e.interactive && e.touchPitch && i.touchPitch.enable(e.touchPitch);
            const z = () => i.project(i.getCenter()),
              R = (function({
                enable: ge,
                clickTolerance: Te,
                aroundCenter: Le = !0,
                minPixelCenterThreshold: ve = 100,
                rotateDegreesPerPixelMoved: Ne = .8
              }, st) {
                const Xe = new al({
                  checkCorrectEvent: Qe => W.mouseButton(Qe) === 0 && Qe.ctrlKey || W.mouseButton(Qe) === 2 && !Qe.ctrlKey
                });
                return new bs({
                  clickTolerance: Te,
                  move: (Qe, at) => {
                    const Ht = st();
                    if (Le && Math.abs(Ht.y - Qe.y) > ve) return {
                      bearingDelta: s.cn(new s.P(Qe.x, at.y), at, Ht)
                    };
                    let Xt = (at.x - Qe.x) * Ne;
                    return Le && at.y < Ht.y && (Xt = -Xt), {
                      bearingDelta: Xt
                    }
                  },
                  moveStateManager: Xe,
                  enable: ge,
                  assignEvents: ol
                })
              })(e, z),
              D = (function({
                enable: ge,
                clickTolerance: Te,
                pitchDegreesPerPixelMoved: Le = -.5
              }) {
                const ve = new al({
                  checkCorrectEvent: Ne => W.mouseButton(Ne) === 0 && Ne.ctrlKey || W.mouseButton(Ne) === 2
                });
                return new bs({
                  clickTolerance: Te,
                  move: (Ne, st) => ({
                    pitchDelta: (st.y - Ne.y) * Le
                  }),
                  moveStateManager: ve,
                  enable: ge,
                  assignEvents: ol
                })
              })(e),
              N = (function({
                enable: ge,
                clickTolerance: Te,
                rollDegreesPerPixelMoved: Le = .3
              }, ve) {
                const Ne = new al({
                  checkCorrectEvent: st => W.mouseButton(st) === 2 && st.ctrlKey
                });
                return new bs({
                  clickTolerance: Te,
                  move: (st, Xe) => {
                    const Qe = ve();
                    let at = (Xe.x - st.x) * Le;
                    return Xe.y < Qe.y && (at = -at), {
                      rollDelta: at
                    }
                  },
                  moveStateManager: Ne,
                  enable: ge,
                  assignEvents: ol
                })
              })(e, z);
            i.dragRotate = new mu(e, R, D, N), this._add("mouseRotate", R, ["mousePitch"]), this._add("mousePitch", D, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", N, ["mousePitch"]), e.interactive && e.dragRotate && i.dragRotate.enable();
            const H = (function({
                enable: ge,
                clickTolerance: Te
              }) {
                const Le = new al({
                  checkCorrectEvent: ve => W.mouseButton(ve) === 0 && !ve.ctrlKey
                });
                return new bs({
                  clickTolerance: Te,
                  move: (ve, Ne) => ({
                    around: Ne,
                    panDelta: Ne.sub(ve)
                  }),
                  activateOnStart: !0,
                  moveStateManager: Le,
                  enable: ge,
                  assignEvents: ol
                })
              })(e),
              ie = new sl(e, i);
            i.dragPan = new kd(l, H, ie), this._add("mousePan", H), this._add("touchPan", ie, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && i.dragPan.enable(e.dragPan);
            const ne = new Cs,
              se = new Gl;
            i.touchZoomRotate = new Md(l, se, ne, T), this._add("touchRotate", ne, ["touchPan", "touchZoom"]), this._add("touchZoom", se, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && i.touchZoomRotate.enable(e.touchZoomRotate);
            const pe = i.scrollZoom = new Id(i, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", pe, ["mousePan"]), e.interactive && e.scrollZoom && i.scrollZoom.enable(e.scrollZoom);
            const ye = i.keyboard = new Hl(i);
            this._add("keyboard", ye), e.interactive && e.keyboard && i.keyboard.enable(), this._add("blockableMapEvent", new Td(i))
          }
          _add(e, i, l) {
            this._handlers.push({
              handlerName: e,
              handler: i,
              allowed: l
            }), this._handlersById[e] = i
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const {
                  handler: i
                }
                of this._handlers) i.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = []
            }
          }
          isActive() {
            for (const {
                handler: e
              }
              of this._handlers)
              if (e.isActive()) return !0;
            return !1
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
          }
          isRotating() {
            return !!this._eventsInProgress.rotate
          }
          isMoving() {
            return !!Ma(this._eventsInProgress) || this.isZooming()
          }
          _blockedByActive(e, i, l) {
            for (const u in e)
              if (u !== l && (!i || i.indexOf(u) < 0)) return !0;
            return !1
          }
          _getMapTouches(e) {
            const i = [];
            for (const l of e) this._el.contains(l.target) && i.push(l);
            return i
          }
          mergeHandlerResult(e, i, l, u, f) {
            if (!l) return;
            s.e(e, l);
            const g = {
              handlerName: u,
              originalEvent: l.originalEvent || f
            };
            l.zoomDelta !== void 0 && (i.zoom = g), l.panDelta !== void 0 && (i.drag = g), l.rollDelta !== void 0 && (i.roll = g), l.pitchDelta !== void 0 && (i.pitch = g), l.bearingDelta !== void 0 && (i.rotate = g)
          }
          _applyChanges() {
            const e = {},
              i = {},
              l = {};
            for (const [u, f, g] of this._changes) u.panDelta && (e.panDelta = (e.panDelta || new s.P(0, 0))._add(u.panDelta)), u.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + u.zoomDelta), u.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + u.bearingDelta), u.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + u.pitchDelta), u.rollDelta && (e.rollDelta = (e.rollDelta || 0) + u.rollDelta), u.around !== void 0 && (e.around = u.around), u.pinchAround !== void 0 && (e.pinchAround = u.pinchAround), u.noInertia && (e.noInertia = u.noInertia), s.e(i, f), s.e(l, g);
            this._updateMapTransform(e, i, l), this._changes = []
          }
          _updateMapTransform(e, i, l) {
            const u = this._map,
              f = u._getTransformForUpdate(),
              g = u.terrain;
            if (!(Ts(e) || g && this._terrainMovement)) return this._fireEvents(i, l, !0);
            u._stop(!0);
            let {
              panDelta: C,
              zoomDelta: T,
              bearingDelta: M,
              pitchDelta: z,
              rollDelta: R,
              around: D,
              pinchAround: N
            } = e;
            N !== void 0 && (D = N), D = D || u.transform.centerPoint, g && !f.isPointOnMapSurface(D) && (D = f.centerPoint);
            const H = {
              panDelta: C,
              zoomDelta: T,
              rollDelta: R,
              pitchDelta: z,
              bearingDelta: M,
              around: D
            };
            this._map.cameraHelper.useGlobeControls && !f.isPointOnMapSurface(D) && (D = f.centerPoint);
            const ie = D.distSqr(f.centerPoint) < .01 ? f.center : f.screenPointToLocation(C ? D.sub(C) : D);
            g ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(H, f), this._terrainMovement || !i.drag && !i.zoom ? i.drag && this._terrainMovement ? f.setCenter(f.screenPointToLocation(f.centerPoint.sub(C))) : this._map.cameraHelper.handleMapControlsPan(H, f, ie) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan(H, f, ie))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(H, f), this._map.cameraHelper.handleMapControlsPan(H, f, ie)), u._applyUpdatedTransform(f), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(i, l, !0)
          }
          _fireEvents(e, i, l) {
            const u = Ma(this._eventsInProgress),
              f = Ma(e),
              g = {};
            for (const R in e) {
              const {
                originalEvent: D
              } = e[R];
              this._eventsInProgress[R] || (g[`${R}start`] = D), this._eventsInProgress[R] = e[R]
            }!u && f && this._fireEvent("movestart", f.originalEvent);
            for (const R in g) this._fireEvent(R, g[R]);
            f && this._fireEvent("move", f.originalEvent);
            for (const R in e) {
              const {
                originalEvent: D
              } = e[R];
              this._fireEvent(R, D)
            }
            const C = {};
            let T;
            for (const R in this._eventsInProgress) {
              const {
                handlerName: D,
                originalEvent: N
              } = this._eventsInProgress[R];
              this._handlersById[D].isActive() || (delete this._eventsInProgress[R], T = i[D] || N, C[`${R}end`] = T)
            }
            for (const R in C) this._fireEvent(R, C[R]);
            const M = Ma(this._eventsInProgress),
              z = (u || f) && !M;
            if (z && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const R = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && R.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(R)
            }
            if (l && z) {
              this._updatingCamera = !0;
              const R = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                D = N => N !== 0 && -this._bearingSnap < N && N < this._bearingSnap;
              !R || !R.essential && Q.prefersReducedMotion ? (this._map.fire(new s.l("moveend", {
                originalEvent: T
              })), D(this._map.getBearing()) && this._map.resetNorth()) : (D(R.bearing || this._map.getBearing()) && (R.bearing = 0), R.freezeElevation = !0, this._map.easeTo(R, {
                originalEvent: T
              })), this._updatingCamera = !1
            }
          }
          _fireEvent(e, i) {
            this._map.fire(new s.l(e, i ? {
              originalEvent: i
            } : {}))
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e => {
              delete this._frameId, this.handleEvent(new Un("renderFrame", {
                timeStamp: e
              })), this._applyChanges()
            }))
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame())
          }
        }
        class Ed extends s.E {
          constructor(e, i, l) {
            super(), this._renderFrameCallback = () => {
              const u = Math.min((Q.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(u)), u < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = l.bearingSnap, this.cameraHelper = i, this.on("moveend", (() => {
              delete this._requestedCameraState
            }))
          }
          migrateProjection(e, i) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = i
          }
          getCenter() {
            return new s.S(this.transform.center.lng, this.transform.center.lat)
          }
          setCenter(e, i) {
            return this.jumpTo({
              center: e
            }, i)
          }
          getCenterElevation() {
            return this.transform.elevation
          }
          setCenterElevation(e, i) {
            return this.jumpTo({
              elevation: e
            }, i), this
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e
          }
          panBy(e, i, l) {
            return e = s.P.convert(e).mult(-1), this.panTo(this.transform.center, s.e({
              offset: e
            }, i), l)
          }
          panTo(e, i, l) {
            return this.easeTo(s.e({
              center: e
            }, i), l)
          }
          getZoom() {
            return this.transform.zoom
          }
          setZoom(e, i) {
            return this.jumpTo({
              zoom: e
            }, i), this
          }
          zoomTo(e, i, l) {
            return this.easeTo(s.e({
              zoom: e
            }, i), l)
          }
          zoomIn(e, i) {
            return this.zoomTo(this.getZoom() + 1, e, i), this
          }
          zoomOut(e, i) {
            return this.zoomTo(this.getZoom() - 1, e, i), this
          }
          getVerticalFieldOfView() {
            return this.transform.fov
          }
          setVerticalFieldOfView(e, i) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new s.l("movestart", i)).fire(new s.l("move", i)).fire(new s.l("moveend", i))), this
          }
          getBearing() {
            return this.transform.bearing
          }
          setBearing(e, i) {
            return this.jumpTo({
              bearing: e
            }, i), this
          }
          getPadding() {
            return this.transform.padding
          }
          setPadding(e, i) {
            return this.jumpTo({
              padding: e
            }, i), this
          }
          rotateTo(e, i, l) {
            return this.easeTo(s.e({
              bearing: e
            }, i), l)
          }
          resetNorth(e, i) {
            return this.rotateTo(0, s.e({
              duration: 1e3
            }, e), i), this
          }
          resetNorthPitch(e, i) {
            return this.easeTo(s.e({
              bearing: 0,
              pitch: 0,
              roll: 0,
              duration: 1e3
            }, e), i), this
          }
          snapToNorth(e, i) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, i) : this
          }
          getPitch() {
            return this.transform.pitch
          }
          setPitch(e, i) {
            return this.jumpTo({
              pitch: e
            }, i), this
          }
          getRoll() {
            return this.transform.roll
          }
          setRoll(e, i) {
            return this.jumpTo({
              roll: e
            }, i), this
          }
          cameraForBounds(e, i) {
            e = At.convert(e).adjustAntiMeridian();
            const l = i && i.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), l, i)
          }
          _cameraForBoxAndBearing(e, i, l, u) {
            const f = {
              top: 0,
              bottom: 0,
              right: 0,
              left: 0
            };
            if (typeof(u = s.e({
                padding: f,
                offset: [0, 0],
                maxZoom: this.transform.maxZoom
              }, u)).padding == "number") {
              const M = u.padding;
              u.padding = {
                top: M,
                bottom: M,
                right: M,
                left: M
              }
            }
            const g = s.e(f, u.padding);
            u.padding = g;
            const C = this.transform,
              T = new At(e, i);
            return this.cameraHelper.cameraForBoxAndBearing(u, g, T, l, C)
          }
          fitBounds(e, i, l) {
            return this._fitInternal(this.cameraForBounds(e, i), i, l)
          }
          fitScreenCoordinates(e, i, l, u, f) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(s.P.convert(e)), this.transform.screenPointToLocation(s.P.convert(i)), l, u), u, f)
          }
          _fitInternal(e, i, l) {
            return e ? (delete(i = s.e(e, i)).padding, i.linear ? this.easeTo(i, l) : this.flyTo(i, l)) : this
          }
          jumpTo(e, i) {
            this.stop();
            const l = this._getTransformForUpdate();
            let u = !1,
              f = !1,
              g = !1;
            const C = l.zoom;
            this.cameraHelper.handleJumpToCenterZoom(l, e);
            const T = l.zoom !== C;
            return "elevation" in e && l.elevation !== +e.elevation && l.setElevation(+e.elevation), "bearing" in e && l.bearing !== +e.bearing && (u = !0, l.setBearing(+e.bearing)), "pitch" in e && l.pitch !== +e.pitch && (f = !0, l.setPitch(+e.pitch)), "roll" in e && l.roll !== +e.roll && (g = !0, l.setRoll(+e.roll)), e.padding == null || l.isPaddingEqual(e.padding) || l.setPadding(e.padding), this._applyUpdatedTransform(l), this.fire(new s.l("movestart", i)).fire(new s.l("move", i)), T && this.fire(new s.l("zoomstart", i)).fire(new s.l("zoom", i)).fire(new s.l("zoomend", i)), u && this.fire(new s.l("rotatestart", i)).fire(new s.l("rotate", i)).fire(new s.l("rotateend", i)), f && this.fire(new s.l("pitchstart", i)).fire(new s.l("pitch", i)).fire(new s.l("pitchend", i)), g && this.fire(new s.l("rollstart", i)).fire(new s.l("roll", i)).fire(new s.l("rollend", i)), this.fire(new s.l("moveend", i))
          }
          calculateCameraOptionsFromTo(e, i, l, u = 0) {
            const f = s.a1.fromLngLat(e, i),
              g = s.a1.fromLngLat(l, u),
              C = g.x - f.x,
              T = g.y - f.y,
              M = g.z - f.z,
              z = Math.hypot(C, T, M);
            if (z === 0) throw new Error("Can't calculate camera options with same From and To");
            const R = Math.hypot(C, T),
              D = s.ak(this.transform.cameraToCenterDistance / z / this.transform.tileSize),
              N = 180 * Math.atan2(C, -T) / Math.PI;
            let H = 180 * Math.acos(R / z) / Math.PI;
            return H = M < 0 ? 90 - H : 90 + H, {
              center: g.toLngLat(),
              elevation: u,
              zoom: D,
              pitch: H,
              bearing: N
            }
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, i, l, u, f) {
            const g = this.transform.calculateCenterFromCameraLngLatAlt(e, i, l, u);
            return {
              center: g.center,
              elevation: g.elevation,
              zoom: g.zoom,
              bearing: l,
              pitch: u,
              roll: f
            }
          }
          easeTo(e, i) {
            this._stop(!1, e.easeId), ((e = s.e({
              offset: [0, 0],
              duration: 500,
              easing: s.co
            }, e)).animate === !1 || !e.essential && Q.prefersReducedMotion) && (e.duration = 0);
            const l = this._getTransformForUpdate(),
              u = this.getBearing(),
              f = l.pitch,
              g = l.roll,
              C = "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
              T = "pitch" in e ? +e.pitch : f,
              M = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
              z = "padding" in e ? e.padding : l.padding,
              R = s.P.convert(e.offset);
            let D, N;
            e.around && (D = s.S.convert(e.around), N = l.locationToScreenPoint(D));
            const H = {
                moving: this._moving,
                zooming: this._zooming,
                rotating: this._rotating,
                pitching: this._pitching,
                rolling: this._rolling
              },
              ie = this.cameraHelper.handleEaseTo(l, {
                bearing: C,
                pitch: T,
                roll: M,
                padding: z,
                around: D,
                aroundPoint: N,
                offsetAsPoint: R,
                offset: e.offset,
                zoom: e.zoom,
                center: e.center
              });
            return this._rotating = this._rotating || u !== C, this._pitching = this._pitching || T !== f, this._rolling = this._rolling || M !== g, this._padding = !l.isPaddingEqual(z), this._zooming = this._zooming || ie.isZooming, this._easeId = e.easeId, this._prepareEase(i, e.noMoveStart, H), this.terrain && this._prepareElevation(ie.elevationCenter), this._ease((ne => {
              ie.easeFunc(ne), this.terrain && !e.freezeElevation && this._updateElevation(ne), this._applyUpdatedTransform(l), this._fireMoveEvents(i)
            }), (ne => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i, ne)
            }), e), this
          }
          _prepareEase(e, i, l = {}) {
            this._moving = !0, i || l.moving || this.fire(new s.l("movestart", e)), this._zooming && !l.zooming && this.fire(new s.l("zoomstart", e)), this._rotating && !l.rotating && this.fire(new s.l("rotatestart", e)), this._pitching && !l.pitching && this.fire(new s.l("pitchstart", e)), this._rolling && !l.rolling && this.fire(new s.l("rollstart", e))
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0
          }
          _updateElevation(e) {
            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const i = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && i !== this._elevationTarget) {
              const l = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (l - (i - (l * e + this._elevationStart)) / (1 - e)), this._elevationTarget = i
            }
            this.transform.setElevation(s.C.number(this._elevationStart, this._elevationTarget, e))
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const i = e.getCameraLngLat(),
              l = e.getCameraAltitude(),
              u = this.terrain ? this.terrain.getElevationForLngLatZoom(i, e.zoom) : 0;
            if (l < u) {
              const f = this.calculateCameraOptionsFromTo(i, u, e.center, e.elevation);
              return {
                pitch: f.pitch,
                zoom: f.zoom
              }
            }
            return {}
          }
          _applyUpdatedTransform(e) {
            const i = [];
            if (i.push((u => this._elevateCameraIfInsideTerrain(u))), this.transformCameraUpdate && i.push((u => this.transformCameraUpdate(u))), !i.length) return;
            const l = e.clone();
            for (const u of i) {
              const f = l.clone(),
                {
                  center: g,
                  zoom: C,
                  roll: T,
                  pitch: M,
                  bearing: z,
                  elevation: R
                } = u(f);
              g && f.setCenter(g), R !== void 0 && f.setElevation(R), C !== void 0 && f.setZoom(C), T !== void 0 && f.setRoll(T), M !== void 0 && f.setPitch(M), z !== void 0 && f.setBearing(z), l.apply(f)
            }
            this.transform.apply(l)
          }
          _fireMoveEvents(e) {
            this.fire(new s.l("move", e)), this._zooming && this.fire(new s.l("zoom", e)), this._rotating && this.fire(new s.l("rotate", e)), this._pitching && this.fire(new s.l("pitch", e)), this._rolling && this.fire(new s.l("roll", e))
          }
          _afterEase(e, i) {
            if (this._easeId && i && this._easeId === i) return;
            delete this._easeId;
            const l = this._zooming,
              u = this._rotating,
              f = this._pitching,
              g = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, l && this.fire(new s.l("zoomend", e)), u && this.fire(new s.l("rotateend", e)), f && this.fire(new s.l("pitchend", e)), g && this.fire(new s.l("rollend", e)), this.fire(new s.l("moveend", e))
          }
          flyTo(e, i) {
            if (!e.essential && Q.prefersReducedMotion) {
              const at = s.Q(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(at, i)
            }
            this.stop(), e = s.e({
              offset: [0, 0],
              speed: 1.2,
              curve: 1.42,
              easing: s.co
            }, e);
            const l = this._getTransformForUpdate(),
              u = l.bearing,
              f = l.pitch,
              g = l.roll,
              C = l.padding,
              T = "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
              M = "pitch" in e ? +e.pitch : f,
              z = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
              R = "padding" in e ? e.padding : l.padding,
              D = s.P.convert(e.offset);
            let N = l.centerPoint.add(D);
            const H = l.screenPointToLocation(N),
              ie = this.cameraHelper.handleFlyTo(l, {
                bearing: T,
                pitch: M,
                roll: z,
                padding: R,
                locationAtOffset: H,
                offsetAsPoint: D,
                center: e.center,
                minZoom: e.minZoom,
                zoom: e.zoom
              });
            let ne = e.curve;
            const se = Math.max(l.width, l.height),
              pe = se / ie.scaleOfZoom,
              ye = ie.pixelPathLength;
            typeof ie.scaleOfMinZoom == "number" && (ne = Math.sqrt(se / ie.scaleOfMinZoom / ye * 2));
            const ge = ne * ne;

            function Te(at) {
              const Ht = (pe * pe - se * se + (at ? -1 : 1) * ge * ge * ye * ye) / (2 * (at ? pe : se) * ge * ye);
              return Math.log(Math.sqrt(Ht * Ht + 1) - Ht)
            }

            function Le(at) {
              return (Math.exp(at) - Math.exp(-at)) / 2
            }

            function ve(at) {
              return (Math.exp(at) + Math.exp(-at)) / 2
            }
            const Ne = Te(!1);
            let st = function(at) {
                return ve(Ne) / ve(Ne + ne * at)
              },
              Xe = function(at) {
                return se * ((ve(Ne) * (Le(Ht = Ne + ne * at) / ve(Ht)) - Le(Ne)) / ge) / ye;
                var Ht
              },
              Qe = (Te(!0) - Ne) / ne;
            if (Math.abs(ye) < 2e-6 || !isFinite(Qe)) {
              if (Math.abs(se - pe) < 1e-6) return this.easeTo(e, i);
              const at = pe < se ? -1 : 1;
              Qe = Math.abs(Math.log(pe / se)) / ne, Xe = () => 0, st = Ht => Math.exp(at * ne * Ht)
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * Qe / ("screenSpeed" in e ? +e.screenSpeed / ne : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = u !== T, this._pitching = M !== f, this._rolling = z !== g, this._padding = !l.isPaddingEqual(R), this._prepareEase(i, !1), this.terrain && this._prepareElevation(ie.targetCenter), this._ease((at => {
              const Ht = at * Qe,
                Xt = 1 / st(Ht),
                kt = Xe(Ht);
              this._rotating && l.setBearing(s.C.number(u, T, at)), this._pitching && l.setPitch(s.C.number(f, M, at)), this._rolling && l.setRoll(s.C.number(g, z, at)), this._padding && (l.interpolatePadding(C, R, at), N = l.centerPoint.add(D)), ie.easeFunc(at, Xt, kt, N), this.terrain && !e.freezeElevation && this._updateElevation(at), this._applyUpdatedTransform(l), this._fireMoveEvents(i)
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i)
            }), e), this
          }
          isEasing() {
            return !!this._easeFrameId
          }
          stop() {
            return this._stop()
          }
          _stop(e, i) {
            var l;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const u = this._onEaseEnd;
              delete this._onEaseEnd, u.call(this, i)
            }
            return e || (l = this.handlers) === null || l === void 0 || l.stop(!1), this
          }
          _ease(e, i, l) {
            l.animate === !1 || l.duration === 0 ? (e(1), i()) : (this._easeStart = Q.now(), this._easeOptions = l, this._onEaseFrame = e, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
          }
          _normalizeBearing(e, i) {
            e = s.aO(e, -180, 180);
            const l = Math.abs(e - i);
            return Math.abs(e - 360 - i) < l && (e -= 360), Math.abs(e + 360 - i) < l && (e += 360), e
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(s.S.convert(e), this.transform.tileZoom) : null
          }
        }
        const gu = {
          compact: !0,
          customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
        };
        class vu {
          constructor(e = gu) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")))
            }, this._updateData = i => {
              !i || i.sourceDataType !== "metadata" && i.sourceDataType !== "visibility" && i.dataType !== "style" && i.type !== "terrain" || this._updateAttributions()
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-right"
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = W.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = W.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = W.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container
          }
          onRemove() {
            W.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0
          }
          _setElementTitle(e, i) {
            const l = this._map._getUIString(`AttributionControl.${i}`);
            e.title = l, e.setAttribute("aria-label", l)
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((u => typeof u != "string" ? "" : u))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const u = this._map.style.stylesheet;
              this.styleOwner = u.owner, this.styleId = u.id
            }
            const i = this._map.style.sourceCaches;
            for (const u in i) {
              const f = i[u];
              if (f.used || f.usedForTerrain) {
                const g = f.getSource();
                g.attribution && e.indexOf(g.attribution) < 0 && e.push(g.attribution)
              }
            }
            e = e.filter((u => String(u).trim())), e.sort(((u, f) => u.length - f.length)), e = e.filter(((u, f) => {
              for (let g = f + 1; g < e.length; g++)
                if (e[g].indexOf(u) >= 0) return !1;
              return !0
            }));
            const l = e.join(" | ");
            l !== this._attribHTML && (this._attribHTML = l, e.length ? (this._innerContainer.innerHTML = W.sanitize(l), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null)
          }
        }
        class zd {
          constructor(e = {}) {
            this._updateCompact = () => {
              const i = this._container.children;
              if (i.length) {
                const l = i[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && l.classList.add("maplibregl-compact") : l.classList.remove("maplibregl-compact")
              }
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = W.create("div", "maplibregl-ctrl");
            const i = W.create("a", "maplibregl-ctrl-logo");
            return i.target = "_blank", i.rel = "noopener nofollow", i.href = "https://maplibre.org/", i.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), i.setAttribute("rel", "noopener nofollow"), this._container.appendChild(i), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
          }
          onRemove() {
            W.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0
          }
        }
        class Ga {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
          }
          add(e) {
            const i = ++this._id;
            return this._queue.push({
              callback: e,
              id: i,
              cancelled: !1
            }), i
          }
          remove(e) {
            const i = this._currentlyRunning,
              l = i ? this._queue.concat(i) : this._queue;
            for (const u of l)
              if (u.id === e) return void(u.cancelled = !0)
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const i = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const l of i)
              if (!l.cancelled && (l.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = []
          }
        }
        var Xl = s.aJ([{
          name: "a_pos3d",
          type: "Int16",
          components: 3
        }]);
        class Mr extends s.E {
          constructor(e) {
            super(), this._lastTilesetChange = Q.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize
          }
          destruct() {
            this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null
          }
          update(e, i) {
            this.sourceCache.update(e, i), this._renderableTilesKeys = [];
            const l = {};
            for (const u of we(e, {
                tileSize: this.tileSize,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                reparseOverscaled: !1,
                terrain: i,
                calculateTileZoom: this.sourceCache._source.calculateTileZoom
              })) l[u.key] = !0, this._renderableTilesKeys.push(u.key), this._tiles[u.key] || (u.terrainRttPosMatrix32f = new Float64Array(16), s.bY(u.terrainRttPosMatrix32f, 0, s.$, s.$, 0, 0, 1), this._tiles[u.key] = new qr(u, this.tileSize), this._lastTilesetChange = Q.now());
            for (const u in this._tiles) l[u] || delete this._tiles[u]
          }
          freeRtt(e) {
            for (const i in this._tiles) {
              const l = this._tiles[i];
              (!e || l.tileID.equals(e) || l.tileID.isChildOf(e) || e.isChildOf(l.tileID)) && (l.rtt = [])
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e => this.getTileByID(e)))
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          getTerrainCoords(e, i) {
            return i ? this._getTerrainCoordsForTileRanges(e, i) : this._getTerrainCoordsForRegularTile(e)
          }
          _getTerrainCoordsForRegularTile(e) {
            const i = {};
            for (const l of this._renderableTilesKeys) {
              const u = this._tiles[l].tileID,
                f = e.clone(),
                g = s.ba();
              if (u.canonical.equals(e.canonical)) s.bY(g, 0, s.$, s.$, 0, 0, 1);
              else if (u.canonical.isChildOf(e.canonical)) {
                const C = u.canonical.z - e.canonical.z,
                  T = u.canonical.x - (u.canonical.x >> C << C),
                  M = u.canonical.y - (u.canonical.y >> C << C),
                  z = s.$ >> C;
                s.bY(g, 0, z, z, 0, 0, 1), s.M(g, g, [-T * z, -M * z, 0])
              } else {
                if (!e.canonical.isChildOf(u.canonical)) continue;
                {
                  const C = e.canonical.z - u.canonical.z,
                    T = e.canonical.x - (e.canonical.x >> C << C),
                    M = e.canonical.y - (e.canonical.y >> C << C),
                    z = s.$ >> C;
                  s.bY(g, 0, s.$, s.$, 0, 0, 1), s.M(g, g, [T * z, M * z, 0]), s.N(g, g, [1 / 2 ** C, 1 / 2 ** C, 0])
                }
              }
              f.terrainRttPosMatrix32f = new Float32Array(g), i[l] = f
            }
            return i
          }
          _getTerrainCoordsForTileRanges(e, i) {
            const l = {};
            for (const u of this._renderableTilesKeys) {
              const f = this._tiles[u].tileID;
              if (!this._isWithinTileRanges(f, i)) continue;
              const g = e.clone(),
                C = s.ba();
              if (f.canonical.z === e.canonical.z) {
                const T = e.canonical.x - f.canonical.x,
                  M = e.canonical.y - f.canonical.y;
                s.bY(C, 0, s.$, s.$, 0, 0, 1), s.M(C, C, [T * s.$, M * s.$, 0])
              } else if (f.canonical.z > e.canonical.z) {
                const T = f.canonical.z - e.canonical.z,
                  M = f.canonical.x - (f.canonical.x >> T << T),
                  z = f.canonical.y - (f.canonical.y >> T << T),
                  R = e.canonical.x - (f.canonical.x >> T),
                  D = e.canonical.y - (f.canonical.y >> T),
                  N = s.$ >> T;
                s.bY(C, 0, N, N, 0, 0, 1), s.M(C, C, [-M * N + R * s.$, -z * N + D * s.$, 0])
              } else {
                const T = e.canonical.z - f.canonical.z,
                  M = e.canonical.x - (e.canonical.x >> T << T),
                  z = e.canonical.y - (e.canonical.y >> T << T),
                  R = (e.canonical.x >> T) - f.canonical.x,
                  D = (e.canonical.y >> T) - f.canonical.y,
                  N = s.$ << T;
                s.bY(C, 0, N, N, 0, 0, 1), s.M(C, C, [M * s.$ + R * N, z * s.$ + D * N, 0])
              }
              g.terrainRttPosMatrix32f = new Float32Array(C), l[u] = g
            }
            return l
          }
          getSourceTile(e, i) {
            const l = this.sourceCache._source;
            let u = e.overscaledZ - this.deltaZoom;
            if (u > l.maxzoom && (u = l.maxzoom), u < l.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(u).key);
            let f = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
            if ((!f || !f.dem) && i)
              for (; u >= l.minzoom && (!f || !f.dem);) f = this.sourceCache.getTileByID(e.scaledTo(u--).key);
            return f
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e
          }
          _isWithinTileRanges(e, i) {
            return i[e.canonical.z] && e.canonical.x >= i[e.canonical.z].minTileX && e.canonical.x <= i[e.canonical.z].maxTileX && e.canonical.y >= i[e.canonical.z].minTileY && e.canonical.y <= i[e.canonical.z].maxTileY
          }
        }
        class Gr {
          constructor(e, i, l) {
            this._meshCache = {}, this.painter = e, this.sourceCache = new Mr(i), this.options = l, this.exaggeration = typeof l.exaggeration == "number" ? l.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024
          }
          getDEMElevation(e, i, l, u = s.$) {
            var f;
            if (!(i >= 0 && i < u && l >= 0 && l < u)) return 0;
            const g = this.getTerrainData(e),
              C = (f = g.tile) === null || f === void 0 ? void 0 : f.dem;
            if (!C) return 0;
            const T = s.cs([], [i / u * s.$, l / u * s.$], g.u_terrain_matrix),
              M = [T[0] * C.dim, T[1] * C.dim],
              z = Math.floor(M[0]),
              R = Math.floor(M[1]),
              D = M[0] - z,
              N = M[1] - R;
            return C.get(z, R) * (1 - D) * (1 - N) + C.get(z + 1, R) * D * (1 - N) + C.get(z, R + 1) * (1 - D) * N + C.get(z + 1, R + 1) * D * N
          }
          getElevationForLngLatZoom(e, i) {
            if (!s.ct(i, e.wrap())) return 0;
            const {
              tileID: l,
              mercatorX: u,
              mercatorY: f
            } = this._getOverscaledTileIDFromLngLatZoom(e, i);
            return this.getElevation(l, u % s.$, f % s.$, s.$)
          }
          getElevation(e, i, l, u = s.$) {
            return this.getDEMElevation(e, i, l, u) * this.exaggeration
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const u = this.painter.context,
                f = new s.R({
                  width: 1,
                  height: 1
                }, new Uint8Array(4));
              this._emptyDepthTexture = new s.T(u, f, u.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new s.T(u, new s.R({
                width: 1,
                height: 1
              }), u.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = s.ag([])
            }
            const i = this.sourceCache.getSourceTile(e, !0);
            if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) {
              const u = this.painter.context;
              i.demTexture = this.painter.getTileTexture(i.dem.stride), i.demTexture ? i.demTexture.update(i.dem.getPixels(), {
                premultiply: !1
              }) : i.demTexture = new s.T(u, i.dem.getPixels(), u.gl.RGBA, {
                premultiply: !1
              }), i.demTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), i.needsTerrainPrepare = !1
            }
            const l = i && i + i.tileID.key + e.key;
            if (l && !this._demMatrixCache[l]) {
              const u = this.sourceCache.sourceCache._source.maxzoom;
              let f = e.canonical.z - i.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= u ? f = e.canonical.z - u : s.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const g = e.canonical.x - (e.canonical.x >> f << f),
                C = e.canonical.y - (e.canonical.y >> f << f),
                T = s.cu(new Float64Array(16), [1 / (s.$ << f), 1 / (s.$ << f), 0]);
              s.M(T, T, [g * s.$, C * s.$, 0]), this._demMatrixCache[e.key] = {
                matrix: T,
                coord: e
              }
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: i && i.dem && i.dem.dim || 1,
              u_terrain_matrix: l ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
              u_terrain_unpack: i && i.dem && i.dem.getUnpackVector() || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: (i && i.demTexture || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
              tile: i
            }
          }
          getFramebuffer(e) {
            const i = this.painter,
              l = i.width / devicePixelRatio,
              u = i.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === l && this._fbo.height === u || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new s.T(i.context, {
              width: l,
              height: u,
              data: null
            }, i.context.gl.RGBA, {
              premultiply: !1
            }), this._fboCoordsTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new s.T(i.context, {
              width: l,
              height: u,
              data: null
            }, i.context.gl.RGBA, {
              premultiply: !1
            }), this._fboDepthTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = i.context.createFramebuffer(l, u, !0, !1), this._fbo.depthAttachment.set(i.context.createRenderbuffer(i.context.gl.DEPTH_COMPONENT16, l, u))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const i = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let f = 0, g = 0; f < this._coordsTextureSize; f++)
              for (let C = 0; C < this._coordsTextureSize; C++, g += 4) i[g + 0] = 255 & C, i[g + 1] = 255 & f, i[g + 2] = C >> 8 << 4 | f >> 8, i[g + 3] = 0;
            const l = new s.R({
                width: this._coordsTextureSize,
                height: this._coordsTextureSize
              }, new Uint8Array(i.buffer)),
              u = new s.T(e, l, e.gl.RGBA, {
                premultiply: !1
              });
            return u.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = u, u
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const i = new Uint8Array(4),
              l = this.painter.context,
              u = l.gl,
              f = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio),
              g = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio),
              C = Math.round(this.painter.height / devicePixelRatio);
            l.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), u.readPixels(f, C - g - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, i), l.bindFramebuffer.set(null);
            const T = i[0] + (i[2] >> 4 << 8),
              M = i[1] + ((15 & i[2]) << 8),
              z = this.coordsIndex[255 - i[3]],
              R = z && this.sourceCache.getTileByID(z);
            if (!R) return null;
            const D = this._coordsTextureSize,
              N = (1 << R.tileID.canonical.z) * D;
            return new s.a1((R.tileID.canonical.x * D + T) / N + R.tileID.wrap, (R.tileID.canonical.y * D + M) / N, this.getElevation(R.tileID, T, M, D))
          }
          depthAtPoint(e) {
            const i = new Uint8Array(4),
              l = this.painter.context,
              u = l.gl;
            return l.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), u.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, i), l.bindFramebuffer.set(null), (i[0] / 16777216 + i[1] / 65536 + i[2] / 256 + i[3]) / 256
          }
          getTerrainMesh(e) {
            var i;
            const l = ((i = this.painter.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0,
              u = l && e.canonical.y === 0,
              f = l && e.canonical.y === (1 << e.canonical.z) - 1,
              g = `m_${u?"n":""}_${f?"s":""}`;
            if (this._meshCache[g]) return this._meshCache[g];
            const C = this.painter.context,
              T = new s.cv,
              M = new s.aN,
              z = this.meshSize,
              R = s.$ / z,
              D = z * z;
            for (let ve = 0; ve <= z; ve++)
              for (let Ne = 0; Ne <= z; Ne++) T.emplaceBack(Ne * R, ve * R, 0);
            for (let ve = 0; ve < D; ve += z + 1)
              for (let Ne = 0; Ne < z; Ne++) M.emplaceBack(Ne + ve, z + Ne + ve + 1, z + Ne + ve + 2), M.emplaceBack(Ne + ve, z + Ne + ve + 2, Ne + ve + 1);
            const N = T.length,
              H = N + (z + 1),
              ie = (z + 1) * z,
              ne = u ? s.bh : 0,
              se = u ? 0 : 1,
              pe = f ? s.bi : s.$,
              ye = f ? 0 : 1;
            for (let ve = 0; ve <= z; ve++) T.emplaceBack(ve * R, ne, se);
            for (let ve = 0; ve <= z; ve++) T.emplaceBack(ve * R, pe, ye);
            for (let ve = 0; ve < z; ve++) M.emplaceBack(ie + ve, H + ve, H + ve + 1), M.emplaceBack(ie + ve, H + ve + 1, ie + ve + 1), M.emplaceBack(0 + ve, N + ve + 1, N + ve), M.emplaceBack(0 + ve, 0 + ve + 1, N + ve + 1);
            const ge = T.length,
              Te = ge + 2 * (z + 1);
            for (const ve of [0, 1])
              for (let Ne = 0; Ne <= z; Ne++)
                for (const st of [0, 1]) T.emplaceBack(ve * s.$, Ne * R, st);
            for (let ve = 0; ve < 2 * z; ve += 2) M.emplaceBack(ge + ve, ge + ve + 1, ge + ve + 3), M.emplaceBack(ge + ve, ge + ve + 3, ge + ve + 2), M.emplaceBack(Te + ve, Te + ve + 3, Te + ve + 1), M.emplaceBack(Te + ve, Te + ve + 2, Te + ve + 3);
            const Le = new Cn(C.createVertexBuffer(T, Xl.members), C.createIndexBuffer(M), s.aM.simpleSegment(0, 0, T.length, M.length));
            return this._meshCache[g] = Le, Le
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * s.bu / Math.pow(2, Math.max(e, 0)) / 5
          }
          getMinTileElevationForLngLatZoom(e, i) {
            var l;
            const {
              tileID: u
            } = this._getOverscaledTileIDFromLngLatZoom(e, i);
            return (l = this.getMinMaxElevation(u).minElevation) !== null && l !== void 0 ? l : 0
          }
          getMinMaxElevation(e) {
            const i = this.getTerrainData(e).tile,
              l = {
                minElevation: null,
                maxElevation: null
              };
            return i && i.dem && (l.minElevation = i.dem.min * this.exaggeration, l.maxElevation = i.dem.max * this.exaggeration), l
          }
          _getOverscaledTileIDFromLngLatZoom(e, i) {
            const l = s.a1.fromLngLat(e.wrap()),
              u = (1 << i) * s.$,
              f = l.x * u,
              g = l.y * u,
              C = Math.floor(f / s.$),
              T = Math.floor(g / s.$);
            return {
              tileID: new s.Z(i, 0, i, C, T),
              mercatorX: f,
              mercatorY: g
            }
          }
        }
        class Yl {
          constructor(e, i, l) {
            this._context = e, this._size = i, this._tileSize = l, this._objects = [], this._recentlyUsed = [], this._stamp = 0
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy()
          }
          _createObject(e) {
            const i = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0),
              l = new s.T(this._context, {
                width: this._tileSize,
                height: this._tileSize,
                data: null
              }, this._context.gl.RGBA);
            return l.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), i.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), i.colorAttachment.set(l.texture), {
              id: e,
              fbo: i,
              texture: l,
              stamp: -1,
              inUse: !1
            }
          }
          getObjectForId(e) {
            return this._objects[e]
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((i => e.id !== i)), this._recentlyUsed.push(e.id)
          }
          stampObject(e) {
            e.stamp = ++this._stamp
          }
          getOrCreateFreeObject() {
            for (const i of this._recentlyUsed)
              if (!this._objects[i].inUse) return this._objects[i];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e
          }
          freeObject(e) {
            e.inUse = !1
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e)
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((e => !e.inUse)) === !1
          }
        }
        const wo = {
          background: !0,
          fill: !0,
          line: !0,
          raster: !0,
          hillshade: !0,
          "color-relief": !0
        };
        class Kl {
          constructor(e, i) {
            this.painter = e, this.terrain = i, this.pool = new Yl(e.context, 30, i.sourceCache.tileSize * i.qualityFactor)
          }
          destruct() {
            this.pool.destruct()
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
          }
          prepareForRender(e, i) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((l => !e._layers[l].isHidden(i))), this._coordsAscending = {};
            for (const l in e.sourceCaches) {
              this._coordsAscending[l] = {};
              const u = e.sourceCaches[l].getVisibleCoordinates(),
                f = e.sourceCaches[l].getSource(),
                g = f instanceof Zt ? f.terrainTileRanges : null;
              for (const C of u) {
                const T = this.terrain.sourceCache.getTerrainCoords(C, g);
                for (const M in T) this._coordsAscending[l][M] || (this._coordsAscending[l][M] = []), this._coordsAscending[l][M].push(T[M])
              }
            }
            this._coordsAscendingStr = {};
            for (const l of e._order) {
              const u = e._layers[l],
                f = u.source;
              if (wo[u.type] && !this._coordsAscendingStr[f]) {
                this._coordsAscendingStr[f] = {};
                for (const g in this._coordsAscending[f]) this._coordsAscendingStr[f][g] = this._coordsAscending[f][g].map((C => C.key)).sort().join()
              }
            }
            for (const l of this._renderableTiles)
              for (const u in this._coordsAscendingStr) {
                const f = this._coordsAscendingStr[u][l.tileID.key];
                f && f !== l.rttCoords[u] && (l.rtt = [])
              }
          }
          renderLayer(e, i) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const l = Object.assign(Object.assign({}, i), {
                isRenderingToTexture: !0
              }),
              u = e.type,
              f = this.painter,
              g = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (wo[u] && (this._prevType && wo[this._prevType] || this._stacks.push([]), this._prevType = u, this._stacks[this._stacks.length - 1].push(e.id), !g)) return !0;
            if (wo[this._prevType] || wo[u] && g) {
              this._prevType = u;
              const C = this._stacks.length - 1,
                T = this._stacks[C] || [];
              for (const M of this._renderableTiles) {
                if (this.pool.isFull() && (Ul(this.painter, this.terrain, this._rttTiles, l), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(M), M.rtt[C]) {
                  const R = this.pool.getObjectForId(M.rtt[C].id);
                  if (R.stamp === M.rtt[C].stamp) {
                    this.pool.useObject(R);
                    continue
                  }
                }
                const z = this.pool.getOrCreateFreeObject();
                this.pool.useObject(z), this.pool.stampObject(z), M.rtt[C] = {
                  id: z.id,
                  stamp: z.stamp
                }, f.context.bindFramebuffer.set(z.fbo.framebuffer), f.context.clear({
                  color: s.bf.transparent,
                  stencil: 0
                }), f.currentStencilSource = void 0;
                for (let R = 0; R < T.length; R++) {
                  const D = f.style._layers[T[R]],
                    N = D.source ? this._coordsAscending[D.source][M.tileID.key] : [M.tileID];
                  f.context.viewport.set([0, 0, z.fbo.width, z.fbo.height]), f._renderTileClippingMasks(D, N, !0), f.renderLayer(f, f.style.sourceCaches[D.source], D, N, l), D.source && (M.rttCoords[D.source] = this._coordsAscendingStr[D.source][M.tileID.key])
                }
              }
              return Ul(this.painter, this.terrain, this._rttTiles, l), this._rttTiles = [], this.pool.freeAllObjects(), wo[u]
            }
            return !1
          }
        }
        const Wi = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "MapLibre logo",
            "Map.Title": "Map",
            "Marker.Title": "Map marker",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "Popup.Close": "Close popup",
            "ScaleControl.Feet": "ft",
            "ScaleControl.Meters": "m",
            "ScaleControl.Kilometers": "km",
            "ScaleControl.Miles": "mi",
            "ScaleControl.NauticalMiles": "nm",
            "GlobeControl.Enable": "Enable globe",
            "GlobeControl.Disable": "Disable globe",
            "TerrainControl.Enable": "Enable terrain",
            "TerrainControl.Disable": "Disable terrain",
            "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
            "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map",
            "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
          },
          Ld = F,
          _a = {
            hash: !1,
            interactive: !0,
            bearingSnap: 7,
            attributionControl: gu,
            maplibreLogo: !1,
            refreshExpiredTiles: !0,
            canvasContextAttributes: {
              antialias: !1,
              preserveDrawingBuffer: !1,
              powerPreference: "high-performance",
              failIfMajorPerformanceCaveat: !1,
              desynchronized: !1,
              contextType: void 0
            },
            scrollZoom: !0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            trackResize: !0,
            center: [0, 0],
            elevation: 0,
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            renderWorldCopies: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: s.a.MAX_TILE_CACHE_ZOOM_LEVELS,
            transformRequest: null,
            transformCameraUpdate: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            clickTolerance: 3,
            localIdeographFontFamily: "sans-serif",
            pitchWithRotate: !0,
            rollEnabled: !1,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096],
            cancelPendingTileRequestsWhileZooming: !0,
            centerClampedToGround: !0
          },
          cf = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1,
            visualizeRoll: !0
          };
        class ll {
          constructor(e, i, l = !1) {
            this.mousedown = f => {
              this.startMove(f, W.mousePos(this.element, f)), W.addEventListener(window, "mousemove", this.mousemove), W.addEventListener(window, "mouseup", this.mouseup)
            }, this.mousemove = f => {
              this.move(f, W.mousePos(this.element, f))
            }, this.mouseup = f => {
              this._rotatePitchHandler.dragEnd(f), this.offTemp()
            }, this.touchstart = f => {
              f.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = W.touchPos(this.element, f.targetTouches)[0], this.startMove(f, this._startPos), W.addEventListener(window, "touchmove", this.touchmove, {
                passive: !1
              }), W.addEventListener(window, "touchend", this.touchend))
            }, this.touchmove = f => {
              f.targetTouches.length !== 1 ? this.reset() : (this._lastPos = W.touchPos(this.element, f.targetTouches)[0], this.move(f, this._lastPos))
            }, this.touchend = f => {
              f.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this._clickTolerance = 10, this.element = i;
            const u = new of;
            this._rotatePitchHandler = new bs({
              clickTolerance: 3,
              move: (f, g) => {
                const C = i.getBoundingClientRect(),
                  T = new s.P((C.bottom - C.top) / 2, (C.right - C.left) / 2);
                return {
                  bearingDelta: s.cn(new s.P(f.x, g.y), g, T),
                  pitchDelta: l ? -.5 * (g.y - f.y) : void 0
                }
              },
              moveStateManager: u,
              enable: !0,
              assignEvents: () => {}
            }), this.map = e, W.addEventListener(i, "mousedown", this.mousedown), W.addEventListener(i, "touchstart", this.touchstart, {
              passive: !1
            }), W.addEventListener(i, "touchcancel", this.reset)
          }
          startMove(e, i) {
            this._rotatePitchHandler.dragStart(e, i), W.disableDrag()
          }
          move(e, i) {
            const l = this.map,
              {
                bearingDelta: u,
                pitchDelta: f
              } = this._rotatePitchHandler.dragMove(e, i) || {};
            u && l.setBearing(l.getBearing() + u), f && l.setPitch(l.getPitch() + f)
          }
          off() {
            const e = this.element;
            W.removeEventListener(e, "mousedown", this.mousedown), W.removeEventListener(e, "touchstart", this.touchstart, {
              passive: !1
            }), W.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), W.removeEventListener(window, "touchend", this.touchend), W.removeEventListener(e, "touchcancel", this.reset), this.offTemp()
          }
          offTemp() {
            W.enableDrag(), W.removeEventListener(window, "mousemove", this.mousemove), W.removeEventListener(window, "mouseup", this.mouseup), W.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), W.removeEventListener(window, "touchend", this.touchend)
          }
        }
        let Pn;

        function ei(p, e, i, l = !1) {
          if (l || !i.getCoveringTilesDetailsProvider().allowWorldCopies()) return p == null ? void 0 : p.wrap();
          const u = new s.S(p.lng, p.lat);
          if (p = new s.S(p.lng, p.lat), e) {
            const f = new s.S(p.lng - 360, p.lat),
              g = new s.S(p.lng + 360, p.lat),
              C = i.locationToScreenPoint(p).distSqr(e);
            i.locationToScreenPoint(f).distSqr(e) < C ? p = f : i.locationToScreenPoint(g).distSqr(e) < C && (p = g)
          }
          for (; Math.abs(p.lng - i.center.lng) > 180;) {
            const f = i.locationToScreenPoint(p);
            if (f.x >= 0 && f.y >= 0 && f.x <= i.width && f.y <= i.height) break;
            p.lng > i.center.lng ? p.lng -= 360 : p.lng += 360
          }
          return p.lng !== u.lng && i.isPointOnMapSurface(i.locationToScreenPoint(p)) ? p : u
        }
        const Ql = {
          center: "translate(-50%,-50%)",
          top: "translate(-50%,0)",
          "top-left": "translate(0,0)",
          "top-right": "translate(-100%,0)",
          bottom: "translate(-50%,-100%)",
          "bottom-left": "translate(0,-100%)",
          "bottom-right": "translate(-100%,-100%)",
          left: "translate(0,-50%)",
          right: "translate(-100%,-50%)"
        };

        function Ss(p, e, i) {
          const l = p.classList;
          for (const u in Ql) l.remove(`maplibregl-${i}-anchor-${u}`);
          l.add(`maplibregl-${i}-anchor-${e}`)
        }
        class Is extends s.E {
          constructor(e) {
            if (super(), this._onKeyPress = i => {
                const l = i.code,
                  u = i.charCode || i.keyCode;
                l !== "Space" && l !== "Enter" && u !== 32 && u !== 13 || this.togglePopup()
              }, this._onMapClick = i => {
                const l = i.originalEvent.target,
                  u = this._element;
                this._popup && (l === u || u.contains(l)) && this.togglePopup()
              }, this._update = i => {
                if (!this._map) return;
                const l = this._map.loaded() && !this._map.isMoving();
                ((i == null ? void 0 : i.type) === "terrain" || (i == null ? void 0 : i.type) === "render" && !l) && this._map.once("render", this._update), this._lngLat = ei(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                let u = "";
                this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? u = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (u = `rotateZ(${this._rotation-this._map.getBearing()}deg)`);
                let f = "";
                this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? f = "rotateX(0deg)" : this._pitchAlignment === "map" && (f = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || i && i.type !== "moveend" || (this._pos = this._pos.round()), W.setTransform(this._element, `${Ql[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${f} ${u}`), Q.frameAsync(new AbortController).then((() => {
                  this._updateOpacity(i && i.type === "moveend")
                })).catch((() => {}))
              }, this._onMove = i => {
                if (!this._isDragging) {
                  const l = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = i.point.dist(this._pointerdownPos) >= l
                }
                this._isDragging && (this._pos = i.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.l("dragstart"))), this.fire(new s.l("drag")))
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new s.l("dragend")), this._state = "inactive"
              }, this._addDragHandler = i => {
                this._element.contains(i.originalEvent.target) && (i.preventDefault(), this._positionDelta = i.point.sub(this._pos).add(this._offset), this._pointerdownPos = i.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp))
              }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = s.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = W.create("div");
              const i = W.createNS("http://www.w3.org/2000/svg", "svg"),
                l = 41,
                u = 27;
              i.setAttributeNS(null, "display", "block"), i.setAttributeNS(null, "height", `${l}px`), i.setAttributeNS(null, "width", `${u}px`), i.setAttributeNS(null, "viewBox", `0 0 ${u} ${l}`);
              const f = W.createNS("http://www.w3.org/2000/svg", "g");
              f.setAttributeNS(null, "stroke", "none"), f.setAttributeNS(null, "stroke-width", "1"), f.setAttributeNS(null, "fill", "none"), f.setAttributeNS(null, "fill-rule", "evenodd");
              const g = W.createNS("http://www.w3.org/2000/svg", "g");
              g.setAttributeNS(null, "fill-rule", "nonzero");
              const C = W.createNS("http://www.w3.org/2000/svg", "g");
              C.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), C.setAttributeNS(null, "fill", "#000000");
              const T = [{
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "9.5",
                ry: "4.77275007"
              }, {
                rx: "8.5",
                ry: "4.29549936"
              }, {
                rx: "7.5",
                ry: "3.81822308"
              }, {
                rx: "6.5",
                ry: "3.34094679"
              }, {
                rx: "5.5",
                ry: "2.86367051"
              }, {
                rx: "4.5",
                ry: "2.38636864"
              }];
              for (const se of T) {
                const pe = W.createNS("http://www.w3.org/2000/svg", "ellipse");
                pe.setAttributeNS(null, "opacity", "0.04"), pe.setAttributeNS(null, "cx", "10.5"), pe.setAttributeNS(null, "cy", "5.80029008"), pe.setAttributeNS(null, "rx", se.rx), pe.setAttributeNS(null, "ry", se.ry), C.appendChild(pe)
              }
              const M = W.createNS("http://www.w3.org/2000/svg", "g");
              M.setAttributeNS(null, "fill", this._color);
              const z = W.createNS("http://www.w3.org/2000/svg", "path");
              z.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), M.appendChild(z);
              const R = W.createNS("http://www.w3.org/2000/svg", "g");
              R.setAttributeNS(null, "opacity", "0.25"), R.setAttributeNS(null, "fill", "#000000");
              const D = W.createNS("http://www.w3.org/2000/svg", "path");
              D.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), R.appendChild(D);
              const N = W.createNS("http://www.w3.org/2000/svg", "g");
              N.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), N.setAttributeNS(null, "fill", "#FFFFFF");
              const H = W.createNS("http://www.w3.org/2000/svg", "g");
              H.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const ie = W.createNS("http://www.w3.org/2000/svg", "circle");
              ie.setAttributeNS(null, "fill", "#000000"), ie.setAttributeNS(null, "opacity", "0.25"), ie.setAttributeNS(null, "cx", "5.5"), ie.setAttributeNS(null, "cy", "5.5"), ie.setAttributeNS(null, "r", "5.4999962");
              const ne = W.createNS("http://www.w3.org/2000/svg", "circle");
              ne.setAttributeNS(null, "fill", "#FFFFFF"), ne.setAttributeNS(null, "cx", "5.5"), ne.setAttributeNS(null, "cy", "5.5"), ne.setAttributeNS(null, "r", "5.4999962"), H.appendChild(ie), H.appendChild(ne), g.appendChild(C), g.appendChild(M), g.appendChild(R), g.appendChild(N), g.appendChild(H), i.appendChild(g), i.setAttributeNS(null, "height", l * this._scale + "px"), i.setAttributeNS(null, "width", u * this._scale + "px"), this._element.appendChild(i), this._offset = s.P.convert(e && e.offset || [0, -14])
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (i => {
                i.preventDefault()
              })), this._element.addEventListener("mousedown", (i => {
                i.preventDefault()
              })), Ss(this._element, this._anchor, "marker"), e && e.className)
              for (const i of e.className.split(" ")) this._element.classList.add(i);
            this._popup = null
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), W.remove(this._element), this._popup && this._popup.remove(), this
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(e) {
            return this._lngLat = s.S.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this
          }
          getElement() {
            return this._element
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const u = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? {
                  top: [0, 0],
                  "top-left": [0, 0],
                  "top-right": [0, 0],
                  bottom: [0, -38.1],
                  "bottom-left": [u, -1 * (38.1 - 13.5 + u)],
                  "bottom-right": [-u, -1 * (38.1 - 13.5 + u)],
                  left: [13.5, -1 * (38.1 - 13.5)],
                  right: [-13.5, -1 * (38.1 - 13.5)]
                } : this._offset
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress)
            }
            return this
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this
          }
          getPopup() {
            return this._popup
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this
          }
          _updateOpacity(e = !1) {
            var i, l;
            const u = (i = this._map) === null || i === void 0 ? void 0 : i.terrain,
              f = this._map.transform.isLocationOccluded(this._lngLat);
            if (!u || f) {
              const N = f ? this._opacityWhenCovered : this._opacity;
              return void(this._element.style.opacity !== N && (this._element.style.opacity = N))
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null
              }), 100)
            }
            const g = this._map,
              C = g.terrain.depthAtPoint(this._pos),
              T = g.terrain.getElevationForLngLatZoom(this._lngLat, g.transform.tileZoom);
            if (g.transform.lngLatToCameraDepth(this._lngLat, T) - C < .006) return void(this._element.style.opacity = this._opacity);
            const M = -this._offset.y / g.transform.pixelsPerMeter,
              z = Math.sin(g.getPitch() * Math.PI / 180) * M,
              R = g.terrain.depthAtPoint(new s.P(this._pos.x, this._pos.y - this._offset.y)),
              D = g.transform.lngLatToCameraDepth(this._lngLat, T + z) - R > .006;
            !((l = this._popup) === null || l === void 0) && l.isOpen() && D && this._popup.remove(), this._element.style.opacity = D ? this._opacityWhenCovered : this._opacity
          }
          getOffset() {
            return this._offset
          }
          setOffset(e) {
            return this._offset = s.P.convert(e), this._update(), this
          }
          addClassName(e) {
            this._element.classList.add(e)
          }
          removeClassName(e) {
            this._element.classList.remove(e)
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e)
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this
          }
          isDraggable() {
            return this._draggable
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this
          }
          getRotation() {
            return this._rotation
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this
          }
          getRotationAlignment() {
            return this._rotationAlignment
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this
          }
          getPitchAlignment() {
            return this._pitchAlignment
          }
          setOpacity(e, i) {
            return (this._opacity === void 0 || e === void 0 && i === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), i !== void 0 && (this._opacityWhenCovered = i), this._map && this._updateOpacity(!0), this
          }
        }
        const yu = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3
          },
          fitBoundsOptions: {
            maxZoom: 15
          },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0
        };
        let Ps = 0,
          Jo = !1;
        const cl = {
          maxWidth: 100,
          unit: "metric"
        };

        function ec(p, e, i) {
          const l = i && i.maxWidth || 100,
            u = p._container.clientHeight / 2,
            f = p._container.clientWidth / 2,
            g = p.unproject([f - l / 2, u]),
            C = p.unproject([f + l / 2, u]),
            T = Math.round(p.project(C).x - p.project(g).x),
            M = Math.min(l, T, p._container.clientWidth),
            z = g.distanceTo(C);
          if (i && i.unit === "imperial") {
            const R = 3.2808 * z;
            R > 5280 ? Xo(e, M, R / 5280, p._getUIString("ScaleControl.Miles")) : Xo(e, M, R, p._getUIString("ScaleControl.Feet"))
          } else i && i.unit === "nautical" ? Xo(e, M, z / 1852, p._getUIString("ScaleControl.NauticalMiles")) : z >= 1e3 ? Xo(e, M, z / 1e3, p._getUIString("ScaleControl.Kilometers")) : Xo(e, M, z, p._getUIString("ScaleControl.Meters"))
        }

        function Xo(p, e, i, l) {
          const u = (function(f) {
            const g = Math.pow(10, `${Math.floor(f)}`.length - 1);
            let C = f / g;
            return C = C >= 10 ? 10 : C >= 5 ? 5 : C >= 3 ? 3 : C >= 2 ? 2 : C >= 1 ? 1 : (function(T) {
              const M = Math.pow(10, Math.ceil(-Math.log(T) / Math.LN10));
              return Math.round(T * M) / M
            })(C), g * C
          })(i);
          p.style.width = e * (u / i) + "px", p.innerHTML = `${u}&nbsp;${l}`
        }
        const xu = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            subpixelPositioning: !1,
            locationOccludedOpacity: void 0
          },
          bu = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

        function tc(p) {
          if (p) {
            if (typeof p == "number") {
              const e = Math.round(Math.abs(p) / Math.SQRT2);
              return {
                center: new s.P(0, 0),
                top: new s.P(0, p),
                "top-left": new s.P(e, e),
                "top-right": new s.P(-e, e),
                bottom: new s.P(0, -p),
                "bottom-left": new s.P(e, -e),
                "bottom-right": new s.P(-e, -e),
                left: new s.P(p, 0),
                right: new s.P(-p, 0)
              }
            }
            if (p instanceof s.P || Array.isArray(p)) {
              const e = s.P.convert(p);
              return {
                center: e,
                top: e,
                "top-left": e,
                "top-right": e,
                bottom: e,
                "bottom-left": e,
                "bottom-right": e,
                left: e,
                right: e
              }
            }
            return {
              center: s.P.convert(p.center || [0, 0]),
              top: s.P.convert(p.top || [0, 0]),
              "top-left": s.P.convert(p["top-left"] || [0, 0]),
              "top-right": s.P.convert(p["top-right"] || [0, 0]),
              bottom: s.P.convert(p.bottom || [0, 0]),
              "bottom-left": s.P.convert(p["bottom-left"] || [0, 0]),
              "bottom-right": s.P.convert(p["bottom-right"] || [0, 0]),
              left: s.P.convert(p.left || [0, 0]),
              right: s.P.convert(p.right || [0, 0])
            }
          }
          return tc(new s.P(0, 0))
        }
        const wu = F;
        b.AJAXError = s.cz, b.Event = s.l, b.Evented = s.E, b.LngLat = s.S, b.MercatorCoordinate = s.a1, b.Point = s.P, b.addProtocol = s.cA, b.config = s.a, b.removeProtocol = s.cB, b.AttributionControl = vu, b.BoxZoomHandler = uu, b.CanvasSource = cr, b.CooperativeGesturesHandler = Ad, b.DoubleClickZoomHandler = pu, b.DragPanHandler = kd, b.DragRotateHandler = mu, b.EdgeInsets = Ai, b.FullscreenControl = class extends s.E {
          constructor(p = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let i = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = i == null ? void 0 : i.shadowRoot) === null || e === void 0) && e.fullscreenElement;) i = i.shadowRoot.fullscreenElement;
              i === this._container !== this._fullscreen && this._handleFullscreenChange()
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
            }, this._fullscreen = !1, p && p.container && (p.container instanceof HTMLElement ? this._container = p.container : s.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange")
          }
          onAdd(p) {
            return this._map = p, this._container || (this._container = this._map.getContainer()), this._controlContainer = W.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer
          }
          onRemove() {
            W.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _setupUI() {
            const p = this._fullscreenButton = W.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            W.create("span", "maplibregl-ctrl-icon", p).setAttribute("aria-hidden", "true"), p.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _updateTitle() {
            const p = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", p), this._fullscreenButton.title = p
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
          }
          _isFullscreen() {
            return this._fullscreen
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new s.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new s.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize()
          }
        }, b.GeoJSONSource = Rt, b.GeolocateControl = class extends s.E {
          constructor(p) {
            super(), this._onSuccess = e => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new s.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`)
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new s.l("geolocate", e)), this._finish()
              }
            }, this._updateCamera = e => {
              const i = new s.S(e.coords.longitude, e.coords.latitude),
                l = e.coords.accuracy,
                u = this._map.getBearing(),
                f = s.e({
                  bearing: u
                }, this.options.fitBoundsOptions),
                g = At.fromLngLat(i, l);
              this._map.fitBounds(g, f, {
                geolocateSource: !0
              })
            }, this._updateMarker = e => {
              if (e) {
                const i = new s.S(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
            }, this._onError = e => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), this._geolocationWatchID !== void 0 && this._clearWatch()
                } else {
                  if (e.code === 3 && Jo) return;
                  this.options.trackUserLocation && this._setErrorState()
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new s.l("error", e)), this._finish()
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e => e.preventDefault())), this._geolocateButton = W.create("button", "maplibregl-ctrl-geolocate", this._container), W.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0)
            }, this._finishSetupUI = e => {
              if (this._map) {
                if (e === !1) {
                  s.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i)
                } else {
                  const i = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i)
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = W.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Is({
                  element: this._dotElement
                }), this._circleElement = W.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Is({
                  element: this._circleElement,
                  pitchAlignment: "map"
                }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (i => {
                  const l = (i == null ? void 0 : i[0]) instanceof ResizeObserverEntry;
                  i.geolocateSource || this._watchState !== "ACTIVE_LOCK" || l || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new s.l("trackuserlocationend")), this.fire(new s.l("userlocationlostfocus")))
                }))
              }
            }, this.options = s.e({}, yu, p)
          }
          onAdd(p) {
            return this._map = p, this._container = W.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return s._(this, arguments, void 0, (function*(e = !1) {
                if (Pn !== void 0 && !e) return Pn;
                if (window.navigator.permissions === void 0) return Pn = !!window.navigator.geolocation, Pn;
                try {
                  Pn = (yield window.navigator.permissions.query({
                    name: "geolocation"
                  })).state !== "denied"
                } catch {
                  Pn = !!window.navigator.geolocation
                }
                return Pn
              }))
            })().then((e => this._finishSetupUI(e))), this._container
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), W.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ps = 0, Jo = !1
          }
          _isOutOfMapMaxBounds(p) {
            const e = this._map.getMaxBounds(),
              i = p.coords;
            return e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth())
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`)
            }
          }
          _updateCircleRadius() {
            const p = this._map.getBounds(),
              e = p.getSouthEast(),
              i = p.getNorthEast(),
              l = e.distanceTo(i),
              u = Math.ceil(this._accuracy / (l / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${u}px`, this._circleElement.style.height = `${u}px`
          }
          trigger() {
            if (!this._setup) return s.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new s.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Ps--, Jo = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new s.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.l("trackuserlocationstart")), this.fire(new s.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let p;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ps++, Ps > 1 ? (p = {
                  maximumAge: 6e5,
                  timeout: 0
                }, Jo = !0) : (p = this.options.positionOptions, Jo = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, p)
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
          }
        }, b.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var p;
              const e = (p = this._map.getProjection()) === null || p === void 0 ? void 0 : p.type;
              this._map.setProjection(e !== "mercator" && e ? {
                type: "mercator"
              } : {
                type: "globe"
              }), this._updateGlobeIcon()
            }, this._updateGlobeIcon = () => {
              var p;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((p = this._map.getProjection()) === null || p === void 0 ? void 0 : p.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
            }
          }
          onAdd(p) {
            return this._map = p, this._container = W.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = W.create("button", "maplibregl-ctrl-globe", this._container), W.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container
          }
          onRemove() {
            W.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0
          }
        }, b.Hash = $l, b.ImageSource = Zt, b.KeyboardHandler = Hl, b.LngLatBounds = At, b.LogoControl = zd, b.Map = class extends Ed {
          constructor(p) {
            var e, i;
            s.cw.mark(s.cx.create);
            const l = Object.assign(Object.assign(Object.assign({}, _a), p), {
              canvasContextAttributes: Object.assign(Object.assign({}, _a.canvasContextAttributes), p.canvasContextAttributes)
            });
            if (l.minZoom != null && l.maxZoom != null && l.minZoom > l.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (l.minPitch != null && l.maxPitch != null && l.minPitch > l.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (l.minPitch != null && l.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (l.maxPitch != null && l.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const u = new Jr,
              f = new pn;
            if (l.minZoom !== void 0 && u.setMinZoom(l.minZoom), l.maxZoom !== void 0 && u.setMaxZoom(l.maxZoom), l.minPitch !== void 0 && u.setMinPitch(l.minPitch), l.maxPitch !== void 0 && u.setMaxPitch(l.maxPitch), l.renderWorldCopies !== void 0 && u.setRenderWorldCopies(l.renderWorldCopies), super(u, f, {
                bearingSnap: l.bearingSnap
              }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Ga, this._controls = [], this._mapId = s.a7(), this._contextLost = C => {
                C.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new s.l("webglcontextlost", {
                  originalEvent: C
                }))
              }, this._contextRestored = C => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new s.l("webglcontextrestored", {
                  originalEvent: C
                }))
              }, this._onMapScroll = C => {
                if (C.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
              }, this._onWindowOnline = () => {
                this._update()
              }, this._interactive = l.interactive, this._maxTileCacheSize = l.maxTileCacheSize, this._maxTileCacheZoomLevels = l.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, l.canvasContextAttributes), this._trackResize = l.trackResize === !0, this._bearingSnap = l.bearingSnap, this._centerClampedToGround = l.centerClampedToGround, this._refreshExpiredTiles = l.refreshExpiredTiles === !0, this._fadeDuration = l.fadeDuration, this._crossSourceCollisions = l.crossSourceCollisions === !0, this._collectResourceTiming = l.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Wi), l.locale), this._clickTolerance = l.clickTolerance, this._overridePixelRatio = l.pixelRatio, this._maxCanvasSize = l.maxCanvasSize, this.transformCameraUpdate = l.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = l.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = De.addThrottleControl((() => this.isMoving())), this._requestManager = new $e(l.transformRequest), typeof l.container == "string") {
              if (this._container = document.getElementById(l.container), !this._container) throw new Error(`Container '${l.container}' not found.`)
            } else {
              if (!(l.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = l.container
            }
            if (l.maxBounds && this.setMaxBounds(l.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
                this.painter.terrainFacilitator.dirty = !0, this._update(!0)
              })), this.once("idle", (() => {
                this._idleTriggered = !0
              })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let C = !1;
              const T = Wo((M => {
                this._trackResize && !this._removed && (this.resize(M), this.redraw())
              }), 50);
              this._resizeObserver = new ResizeObserver((M => {
                C ? T(M) : C = !0
              })), this._resizeObserver.observe(this._container)
            }
            this.handlers = new _u(this, l), this._hash = l.hash && new $l(typeof l.hash == "string" && l.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
              center: l.center,
              elevation: l.elevation,
              zoom: l.zoom,
              bearing: l.bearing,
              pitch: l.pitch,
              roll: l.roll
            }), l.bounds && (this.resize(), this.fitBounds(l.bounds, s.e({}, l.fitBoundsOptions, {
              duration: 0
            }))));
            const g = typeof l.style == "string" || ((i = (e = l.style) === null || e === void 0 ? void 0 : e.projection) === null || i === void 0 ? void 0 : i.type) !== "globe";
            this.resize(null, g), this._localIdeographFontFamily = l.localIdeographFontFamily, this._validateStyle = l.validateStyle, l.style && this.setStyle(l.style, {
              localIdeographFontFamily: l.localIdeographFontFamily
            }), l.attributionControl && this.addControl(new vu(typeof l.attributionControl == "boolean" ? void 0 : l.attributionControl)), l.maplibreLogo && this.addControl(new zd, l.logoPosition), this.on("style.load", (() => {
              if (g || this._resizeTransform(), this.transform.unmodified) {
                const C = s.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(C)
              }
            })), this.on("data", (C => {
              this._update(C.dataType === "style"), this.fire(new s.l(`${C.dataType}data`, C))
            })), this.on("dataloading", (C => {
              this.fire(new s.l(`${C.dataType}dataloading`, C))
            })), this.on("dataabort", (C => {
              this.fire(new s.l("sourcedataabort", C))
            }))
          }
          _getMapId() {
            return this._mapId
          }
          setGlobalStateProperty(p, e) {
            return this.style.setGlobalStateProperty(p, e), this._update(!0)
          }
          getGlobalState() {
            return this.style.getGlobalState()
          }
          addControl(p, e) {
            if (e === void 0 && (e = p.getDefaultPosition ? p.getDefaultPosition() : "top-right"), !p || !p.onAdd) return this.fire(new s.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i = p.onAdd(this);
            this._controls.push(p);
            const l = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? l.insertBefore(i, l.firstChild) : l.appendChild(i), this
          }
          removeControl(p) {
            if (!p || !p.onRemove) return this.fire(new s.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(p);
            return e > -1 && this._controls.splice(e, 1), p.onRemove(this), this
          }
          hasControl(p) {
            return this._controls.indexOf(p) > -1
          }
          calculateCameraOptionsFromTo(p, e, i, l) {
            return l == null && this.terrain && (l = this.terrain.getElevationForLngLatZoom(i, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(p, e, i, l)
          }
          resize(p, e = !0) {
            const [i, l] = this._containerDimensions(), u = this._getClampedPixelRatio(i, l);
            if (this._resizeCanvas(i, l, u), this.painter.resize(i, l, u), this.painter.overLimit()) {
              const g = this.painter.context.gl;
              this._maxCanvasSize = [g.drawingBufferWidth, g.drawingBufferHeight];
              const C = this._getClampedPixelRatio(i, l);
              this._resizeCanvas(i, l, C), this.painter.resize(i, l, C)
            }
            this._resizeTransform(e);
            const f = !this._moving;
            return f && (this.stop(), this.fire(new s.l("movestart", p)).fire(new s.l("move", p))), this.fire(new s.l("resize", p)), f && this.fire(new s.l("moveend", p)), this
          }
          _resizeTransform(p = !0) {
            var e;
            const [i, l] = this._containerDimensions();
            this.transform.resize(i, l, p), (e = this._requestedCameraState) === null || e === void 0 || e.resize(i, l, p)
          }
          _getClampedPixelRatio(p, e) {
            const {
              0: i,
              1: l
            } = this._maxCanvasSize, u = this.getPixelRatio(), f = p * u, g = e * u;
            return Math.min(f > i ? i / f : 1, g > l ? l / g : 1) * u
          }
          getPixelRatio() {
            var p;
            return (p = this._overridePixelRatio) !== null && p !== void 0 ? p : devicePixelRatio
          }
          setPixelRatio(p) {
            this._overridePixelRatio = p, this.resize()
          }
          getBounds() {
            return this.transform.getBounds()
          }
          getMaxBounds() {
            return this.transform.getMaxBounds()
          }
          setMaxBounds(p) {
            return this.transform.setMaxBounds(At.convert(p)), this._update()
          }
          setMinZoom(p) {
            if ((p = p ?? -2) >= -2 && p <= this.transform.maxZoom) return this.transform.setMinZoom(p), this._update(), this.getZoom() < p && this.setZoom(p), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
          }
          getMinZoom() {
            return this.transform.minZoom
          }
          setMaxZoom(p) {
            if ((p = p ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(p), this._update(), this.getZoom() > p && this.setZoom(p), this;
            throw new Error("maxZoom must be greater than the current minZoom")
          }
          getMaxZoom() {
            return this.transform.maxZoom
          }
          setMinPitch(p) {
            if ((p = p ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (p >= 0 && p <= this.transform.maxPitch) return this.transform.setMinPitch(p), this._update(), this.getPitch() < p && this.setPitch(p), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
          }
          getMinPitch() {
            return this.transform.minPitch
          }
          setMaxPitch(p) {
            if ((p = p ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (p >= this.transform.minPitch) return this.transform.setMaxPitch(p), this._update(), this.getPitch() > p && this.setPitch(p), this;
            throw new Error("maxPitch must be greater than the current minPitch")
          }
          getMaxPitch() {
            return this.transform.maxPitch
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies
          }
          setRenderWorldCopies(p) {
            return this.transform.setRenderWorldCopies(p), this._update()
          }
          project(p) {
            return this.transform.locationToScreenPoint(s.S.convert(p), this.style && this.terrain)
          }
          unproject(p) {
            return this.transform.screenPointToLocation(s.P.convert(p), this.terrain)
          }
          isMoving() {
            var p;
            return this._moving || ((p = this.handlers) === null || p === void 0 ? void 0 : p.isMoving())
          }
          isZooming() {
            var p;
            return this._zooming || ((p = this.handlers) === null || p === void 0 ? void 0 : p.isZooming())
          }
          isRotating() {
            var p;
            return this._rotating || ((p = this.handlers) === null || p === void 0 ? void 0 : p.isRotating())
          }
          _createDelegatedListener(p, e, i) {
            if (p === "mouseenter" || p === "mouseover") {
              let l = !1;
              return {
                layers: e,
                listener: i,
                delegates: {
                  mousemove: f => {
                    const g = e.filter((T => this.getLayer(T))),
                      C = g.length !== 0 ? this.queryRenderedFeatures(f.point, {
                        layers: g
                      }) : [];
                    C.length ? l || (l = !0, i.call(this, new Yi(p, this, f.originalEvent, {
                      features: C
                    }))) : l = !1
                  },
                  mouseout: () => {
                    l = !1
                  }
                }
              }
            }
            if (p === "mouseleave" || p === "mouseout") {
              let l = !1;
              return {
                layers: e,
                listener: i,
                delegates: {
                  mousemove: g => {
                    const C = e.filter((T => this.getLayer(T)));
                    (C.length !== 0 ? this.queryRenderedFeatures(g.point, {
                      layers: C
                    }) : []).length ? l = !0 : l && (l = !1, i.call(this, new Yi(p, this, g.originalEvent)))
                  },
                  mouseout: g => {
                    l && (l = !1, i.call(this, new Yi(p, this, g.originalEvent)))
                  }
                }
              }
            } {
              const l = u => {
                const f = e.filter((C => this.getLayer(C))),
                  g = f.length !== 0 ? this.queryRenderedFeatures(u.point, {
                    layers: f
                  }) : [];
                g.length && (u.features = g, i.call(this, u), delete u.features)
              };
              return {
                layers: e,
                listener: i,
                delegates: {
                  [p]: l
                }
              }
            }
          }
          _saveDelegatedListener(p, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[p] = this._delegatedListeners[p] || [], this._delegatedListeners[p].push(e)
          }
          _removeDelegatedListener(p, e, i) {
            if (!this._delegatedListeners || !this._delegatedListeners[p]) return;
            const l = this._delegatedListeners[p];
            for (let u = 0; u < l.length; u++) {
              const f = l[u];
              if (f.listener === i && f.layers.length === e.length && f.layers.every((g => e.includes(g)))) {
                for (const g in f.delegates) this.off(g, f.delegates[g]);
                return void l.splice(u, 1)
              }
            }
          }
          on(p, e, i) {
            if (i === void 0) return super.on(p, e);
            const l = typeof e == "string" ? [e] : e,
              u = this._createDelegatedListener(p, l, i);
            this._saveDelegatedListener(p, u);
            for (const f in u.delegates) this.on(f, u.delegates[f]);
            return {
              unsubscribe: () => {
                this._removeDelegatedListener(p, l, i)
              }
            }
          }
          once(p, e, i) {
            if (i === void 0) return super.once(p, e);
            const l = typeof e == "string" ? [e] : e,
              u = this._createDelegatedListener(p, l, i);
            for (const f in u.delegates) {
              const g = u.delegates[f];
              u.delegates[f] = (...C) => {
                this._removeDelegatedListener(p, l, i), g(...C)
              }
            }
            this._saveDelegatedListener(p, u);
            for (const f in u.delegates) this.once(f, u.delegates[f]);
            return this
          }
          off(p, e, i) {
            return i === void 0 ? super.off(p, e) : (this._removeDelegatedListener(p, typeof e == "string" ? [e] : e, i), this)
          }
          queryRenderedFeatures(p, e) {
            if (!this.style) return [];
            let i;
            const l = p instanceof s.P || Array.isArray(p),
              u = l ? p : [
                [0, 0],
                [this.transform.width, this.transform.height]
              ];
            if (e = e || (l ? {} : p) || {}, u instanceof s.P || typeof u[0] == "number") i = [s.P.convert(u)];
            else {
              const f = s.P.convert(u[0]),
                g = s.P.convert(u[1]);
              i = [f, new s.P(g.x, f.y), g, new s.P(f.x, g.y), f]
            }
            return this.style.queryRenderedFeatures(i, e, this.transform)
          }
          querySourceFeatures(p, e) {
            return this.style.querySourceFeatures(p, e)
          }
          setStyle(p, e) {
            return (e = s.e({}, {
              localIdeographFontFamily: this._localIdeographFontFamily,
              validate: this._validateStyle
            }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && p ? (this._diffStyle(p, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(p, e))
          }
          setTransformRequest(p) {
            return this._requestManager.setTransformRequest(p), this
          }
          _getUIString(p) {
            const e = this._locale[p];
            if (e == null) throw new Error(`Missing UI string '${p}'`);
            return e
          }
          _updateStyle(p, e) {
            var i, l;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(p, e)));
            const u = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!p)), p ? (this.style = new jc(this, e || {}), this.style.setEventedParent(this, {
              style: this.style
            }), typeof p == "string" ? this.style.loadURL(p, e, u) : this.style.loadJSON(p, e, u), this) : ((l = (i = this.style) === null || i === void 0 ? void 0 : i.projection) === null || l === void 0 || l.destroy(), delete this.style, this)
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new jc(this, {}), this.style.setEventedParent(this, {
              style: this.style
            }), this.style.loadEmpty())
          }
          _diffStyle(p, e) {
            if (typeof p == "string") {
              const i = this._requestManager.transformRequest(p, "Style");
              s.j(i, new AbortController).then((l => {
                this._updateDiff(l.data, e)
              })).catch((l => {
                l && this.fire(new s.k(l))
              }))
            } else typeof p == "object" && this._updateDiff(p, e)
          }
          _updateDiff(p, e) {
            try {
              this.style.setState(p, e) && this._update(!0)
            } catch (i) {
              s.w(`Unable to perform style diff: ${i.message||i.error||i}.  Rebuilding the style from scratch.`), this._updateStyle(p, e)
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize()
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : s.w("There is no style added to the map.")
          }
          addSource(p, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(p, e), this._update(!0)
          }
          isSourceLoaded(p) {
            const e = this.style && this.style.sourceCaches[p];
            if (e !== void 0) return e.loaded();
            this.fire(new s.k(new Error(`There is no source with ID '${p}'`)))
          }
          setTerrain(p) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), p) {
              const e = this.style.sourceCaches[p.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${p.source}`);
              this.terrain === null && e.reload();
              for (const i in this.style._layers) {
                const l = this.style._layers[i];
                l.type === "hillshade" && l.source === p.source && s.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), l.type === "color-relief" && l.source === p.source && s.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
              }
              this.terrain = new Gr(this.painter, e, p), this.painter.renderToTexture = new Kl(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = i => {
                var l;
                i.dataType === "style" ? this.terrain.sourceCache.freeRtt() : i.dataType === "source" && i.tile && (i.sourceId !== p.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((l = i.source) === null || l === void 0 ? void 0 : l.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(i.tile.tileID))
              }, this.style.on("data", this._terrainDataCallback)
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new s.l("terrain", {
              terrain: p
            })), this
          }
          getTerrain() {
            var p, e;
            return (e = (p = this.terrain) === null || p === void 0 ? void 0 : p.options) !== null && e !== void 0 ? e : null
          }
          areTilesLoaded() {
            const p = this.style && this.style.sourceCaches;
            for (const e in p) {
              const i = p[e]._tiles;
              for (const l in i) {
                const u = i[l];
                if (u.state !== "loaded" && u.state !== "errored") return !1
              }
            }
            return !0
          }
          removeSource(p) {
            return this.style.removeSource(p), this._update(!0)
          }
          getSource(p) {
            return this.style.getSource(p)
          }
          setSourceTileLodParams(p, e, i) {
            if (i) {
              const l = this.getSource(i);
              if (!l) throw new Error(`There is no source with ID "${i}", cannot set LOD parameters`);
              l.calculateTileZoom = _t(Math.max(1, p), Math.max(1, e))
            } else
              for (const l in this.style.sourceCaches) this.style.sourceCaches[l].getSource().calculateTileZoom = _t(Math.max(1, p), Math.max(1, e));
            return this._update(!0), this
          }
          refreshTiles(p, e) {
            const i = this.style.sourceCaches[p];
            if (!i) throw new Error(`There is no source cache with ID "${p}", cannot refresh tile`);
            e === void 0 ? i.reload(!0) : i.refreshTiles(e.map((l => new s.a4(l.z, l.x, l.y))))
          }
          addImage(p, e, i = {}) {
            const {
              pixelRatio: l = 1,
              sdf: u = !1,
              stretchX: f,
              stretchY: g,
              content: C,
              textFitWidth: T,
              textFitHeight: M
            } = i;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || s.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const {
                  width: z,
                  height: R,
                  data: D
                } = e, N = e;
                return this.style.addImage(p, {
                  data: new s.R({
                    width: z,
                    height: R
                  }, new Uint8Array(D)),
                  pixelRatio: l,
                  stretchX: f,
                  stretchY: g,
                  content: C,
                  textFitWidth: T,
                  textFitHeight: M,
                  sdf: u,
                  version: 0,
                  userImage: N
                }), N.onAdd && N.onAdd(this, p), this
              }
            } {
              const {
                width: z,
                height: R,
                data: D
              } = Q.getImageData(e);
              this.style.addImage(p, {
                data: new s.R({
                  width: z,
                  height: R
                }, D),
                pixelRatio: l,
                stretchX: f,
                stretchY: g,
                content: C,
                textFitWidth: T,
                textFitHeight: M,
                sdf: u,
                version: 0
              })
            }
          }
          updateImage(p, e) {
            const i = this.style.getImage(p);
            if (!i) return this.fire(new s.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const l = e instanceof HTMLImageElement || s.b(e) ? Q.getImageData(e) : e,
              {
                width: u,
                height: f,
                data: g
              } = l;
            if (u === void 0 || f === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (u !== i.data.width || f !== i.data.height) return this.fire(new s.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const C = !(e instanceof HTMLImageElement || s.b(e));
            return i.data.replace(g, C), this.style.updateImage(p, i), this
          }
          getImage(p) {
            return this.style.getImage(p)
          }
          hasImage(p) {
            return p ? !!this.style.getImage(p) : (this.fire(new s.k(new Error("Missing required image id"))), !1)
          }
          removeImage(p) {
            this.style.removeImage(p)
          }
          loadImage(p) {
            return De.getImage(this._requestManager.transformRequest(p, "Image"), new AbortController)
          }
          listImages() {
            return this.style.listImages()
          }
          addLayer(p, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(p, e), this._update(!0)
          }
          moveLayer(p, e) {
            return this.style.moveLayer(p, e), this._update(!0)
          }
          removeLayer(p) {
            return this.style.removeLayer(p), this._update(!0)
          }
          getLayer(p) {
            return this.style.getLayer(p)
          }
          getLayersOrder() {
            return this.style.getLayersOrder()
          }
          setLayerZoomRange(p, e, i) {
            return this.style.setLayerZoomRange(p, e, i), this._update(!0)
          }
          setFilter(p, e, i = {}) {
            return this.style.setFilter(p, e, i), this._update(!0)
          }
          getFilter(p) {
            return this.style.getFilter(p)
          }
          setPaintProperty(p, e, i, l = {}) {
            return this.style.setPaintProperty(p, e, i, l), this._update(!0)
          }
          getPaintProperty(p, e) {
            return this.style.getPaintProperty(p, e)
          }
          setLayoutProperty(p, e, i, l = {}) {
            return this.style.setLayoutProperty(p, e, i, l), this._update(!0)
          }
          getLayoutProperty(p, e) {
            return this.style.getLayoutProperty(p, e)
          }
          setGlyphs(p, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(p, e), this._update(!0)
          }
          getGlyphs() {
            return this.style.getGlyphsUrl()
          }
          addSprite(p, e, i = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(p, e, i, (l => {
              l || this._update(!0)
            })), this
          }
          removeSprite(p) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(p), this._update(!0)
          }
          getSprite() {
            return this.style.getSprite()
          }
          setSprite(p, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(p, e, (i => {
              i || this._update(!0)
            })), this
          }
          setLight(p, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(p, e), this._update(!0)
          }
          getLight() {
            return this.style.getLight()
          }
          setSky(p, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(p, e), this._update(!0)
          }
          getSky() {
            return this.style.getSky()
          }
          setFeatureState(p, e) {
            return this.style.setFeatureState(p, e), this._update()
          }
          removeFeatureState(p, e) {
            return this.style.removeFeatureState(p, e), this._update()
          }
          getFeatureState(p) {
            return this.style.getFeatureState(p)
          }
          getContainer() {
            return this._container
          }
          getCanvasContainer() {
            return this._canvasContainer
          }
          getCanvas() {
            return this._canvas
          }
          _containerDimensions() {
            let p = 0,
              e = 0;
            return this._container && (p = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [p, e]
          }
          _setupContainer() {
            const p = this._container;
            p.classList.add("maplibregl-map");
            const e = this._canvasContainer = W.create("div", "maplibregl-canvas-container", p);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = W.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const i = this._containerDimensions(),
              l = this._getClampedPixelRatio(i[0], i[1]);
            this._resizeCanvas(i[0], i[1], l);
            const u = this._controlContainer = W.create("div", "maplibregl-control-container", p),
              f = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((g => {
              f[g] = W.create("div", `maplibregl-ctrl-${g} `, u)
            })), this._container.addEventListener("scroll", this._onMapScroll, !1)
          }
          _resizeCanvas(p, e, i) {
            this._canvas.width = Math.floor(i * p), this._canvas.height = Math.floor(i * e), this._canvas.style.width = `${p}px`, this._canvas.style.height = `${e}px`
          }
          _setupPainter() {
            const p = Object.assign(Object.assign({}, this._canvasContextAttributes), {
              alpha: !0,
              depth: !0,
              stencil: !0,
              premultipliedAlpha: !0
            });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", (l => {
              e = {
                requestedAttributes: p
              }, l && (e.statusMessage = l.statusMessage, e.type = l.type)
            }), {
              once: !0
            });
            let i = null;
            if (i = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, p) : this._canvas.getContext("webgl2", p) || this._canvas.getContext("webgl", p), !i) {
              const l = "Failed to initialize WebGL";
              throw e ? (e.message = l, new Error(JSON.stringify(e))) : new Error(l)
            }
            this.painter = new gd(i, this.transform), de.testSupport(i)
          }
          migrateProjection(p, e) {
            super.migrateProjection(p, e), this.painter.transform = p, this.fire(new s.l("projectiontransition", {
              newProjection: this.style.projection.name
            }))
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
          }
          _update(p) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || p, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
          }
          _requestRenderFrame(p) {
            return this._update(), this._renderTaskQueue.add(p)
          }
          _cancelRenderFrame(p) {
            this._renderTaskQueue.remove(p)
          }
          _render(p) {
            var e, i, l, u, f;
            const g = this._idleTriggered ? this._fadeDuration : 0,
              C = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(p), this._removed) return;
            let T = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const R = this.transform.zoom,
                D = Q.now();
              this.style.zoomHistory.update(R, D);
              const N = new s.F(R, {
                  now: D,
                  fadeDuration: g,
                  zoomHistory: this.style.zoomHistory,
                  transition: this.style.getTransition(),
                  globalState: this.style.getGlobalState()
                }),
                H = N.crossFadingFactor();
              H === 1 && H === this._crossFadingFactor || (T = !0, this._crossFadingFactor = H), this.style.update(N)
            }
            const M = ((i = this.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0 !== C;
            (l = this.style.projection) === null || l === void 0 || l.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((u = this.style.projection) === null || u === void 0 ? void 0 : u.transitionState, (f = this.style.projection) === null || f === void 0 ? void 0 : f.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || M) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, g, this._crossSourceCollisions, M), this.painter.render(this.style, {
              showTileBoundaries: this.showTileBoundaries,
              showOverdrawInspector: this._showOverdrawInspector,
              rotating: this.isRotating(),
              zooming: this.isZooming(),
              moving: this.isMoving(),
              fadeDuration: g,
              showPadding: this.showPadding
            }), this.fire(new s.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, s.cw.mark(s.cx.load), this.fire(new s.l("load"))), this.style && (this.style.hasTransitions() || T) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const z = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return z || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new s.l("idle")), !this._loaded || this._fullyLoaded || z || (this._fullyLoaded = !0, s.cw.mark(s.cx.fullLoad)), this
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this
          }
          remove() {
            var p;
            this._hash && this._hash.remove();
            for (const i of this._controls) i.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), De.removeThrottleControl(this._imageQueueHandle), (p = this._resizeObserver) === null || p === void 0 || p.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), W.remove(this._canvasContainer), W.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), s.cw.clearMetrics(), this._removed = !0, this.fire(new s.l("remove"))
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController, Q.frame(this._frameRequest, (p => {
              s.cw.frame(p), this._frameRequest = null;
              try {
                this._render(p)
              } catch (e) {
                if (!s.cy(e) && !(function(i) {
                    return i.message === Ks
                  })(e)) throw e
              }
            }), (() => {})))
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries
          }
          set showTileBoundaries(p) {
            this._showTileBoundaries !== p && (this._showTileBoundaries = p, this._update())
          }
          get showPadding() {
            return !!this._showPadding
          }
          set showPadding(p) {
            this._showPadding !== p && (this._showPadding = p, this._update())
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes
          }
          set showCollisionBoxes(p) {
            this._showCollisionBoxes !== p && (this._showCollisionBoxes = p, p ? this.style._generateCollisionBoxes() : this._update())
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector
          }
          set showOverdrawInspector(p) {
            this._showOverdrawInspector !== p && (this._showOverdrawInspector = p, this._update())
          }
          get repaint() {
            return !!this._repaint
          }
          set repaint(p) {
            this._repaint !== p && (this._repaint = p, this.triggerRepaint())
          }
          get vertices() {
            return !!this._vertices
          }
          set vertices(p) {
            this._vertices = p, this._update()
          }
          get version() {
            return Ld
          }
          getCameraTargetElevation() {
            return this.transform.elevation
          }
          getProjection() {
            return this.style.getProjection()
          }
          setProjection(p) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(p), this._update(!0)
          }
        }, b.MapMouseEvent = Yi, b.MapTouchEvent = vs, b.MapWheelEvent = cu, b.Marker = Is, b.NavigationControl = class {
          constructor(p) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(),
                i = e === this._map.getMaxZoom(),
                l = e === this._map.getMinZoom();
              this._zoomInButton.disabled = i, this._zoomOutButton.disabled = l, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", l.toString())
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing-this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
            }, this._setButtonTitle = (e, i) => {
              const l = this._map._getUIString(`NavigationControl.${i}`);
              e.title = l, e.setAttribute("aria-label", l)
            }, this.options = s.e({}, cf, p), this._container = W.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e => this._map.zoomIn({}, {
              originalEvent: e
            }))), W.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e => this._map.zoomOut({}, {
              originalEvent: e
            }))), W.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                originalEvent: e
              }) : this._map.resetNorth({}, {
                originalEvent: e
              })
            })), this._compassIcon = W.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"))
          }
          onAdd(p) {
            return this._map = p, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ll(this._map, this._compass, this.options.visualizePitch)), this._container
          }
          onRemove() {
            W.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map
          }
          _createButton(p, e) {
            const i = W.create("button", p, this._container);
            return i.type = "button", i.addEventListener("click", e), i
          }
        }, b.Popup = class extends s.E {
          constructor(p) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
            }, this.remove = () => (this._content && W.remove(this._content), this._container && (W.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new s.l("close"))), this), this._onMouseUp = e => {
              this._update(e.point)
            }, this._onMouseMove = e => {
              this._update(e.point)
            }, this._onDrag = e => {
              this._update(e.point)
            }, this._update = e => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = W.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = W.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const g of this.options.className.split(" ")) this._container.classList.add(g);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = ei(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const i = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let l = this.options.anchor;
              const u = tc(this.options.offset);
              if (!l) {
                const g = this._container.offsetWidth,
                  C = this._container.offsetHeight;
                let T;
                T = i.y + u.bottom.y < C ? ["top"] : i.y > this._map.transform.height - C ? ["bottom"] : [], i.x < g / 2 ? T.push("left") : i.x > this._map.transform.width - g / 2 && T.push("right"), l = T.length === 0 ? "bottom" : T.join("-")
              }
              let f = i.add(u[l]);
              this.options.subpixelPositioning || (f = f.round()), W.setTransform(this._container, `${Ql[l]} translate(${f.x}px,${f.y}px)`), Ss(this._container, l, "popup"), this._updateOpacity()
            }, this._onClose = () => {
              this.remove()
            }, this.options = s.e(Object.create(xu), p)
          }
          addTo(p) {
            return this._map && this.remove(), this._map = p, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new s.l("open")), this
          }
          isOpen() {
            return !!this._map
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(p) {
            return this._lngLat = s.S.convert(p), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this
          }
          getElement() {
            return this._container
          }
          setText(p) {
            return this.setDOMContent(document.createTextNode(p))
          }
          setHTML(p) {
            const e = document.createDocumentFragment(),
              i = document.createElement("body");
            let l;
            for (i.innerHTML = p; l = i.firstChild, l;) e.appendChild(l);
            return this.setDOMContent(e)
          }
          getMaxWidth() {
            var p;
            return (p = this._container) === null || p === void 0 ? void 0 : p.style.maxWidth
          }
          setMaxWidth(p) {
            return this.options.maxWidth = p, this._update(), this
          }
          setDOMContent(p) {
            if (this._content)
              for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = W.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(p), this._createCloseButton(), this._update(), this._focusFirstElement(), this
          }
          addClassName(p) {
            return this._container && this._container.classList.add(p), this
          }
          removeClassName(p) {
            return this._container && this._container.classList.remove(p), this
          }
          setOffset(p) {
            return this.options.offset = p, this._update(), this
          }
          toggleClassName(p) {
            if (this._container) return this._container.classList.toggle(p)
          }
          setSubpixelPositioning(p) {
            this.options.subpixelPositioning = p
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = W.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose))
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const p = this._container.querySelector(bu);
            p && p.focus()
          }
        }, b.RasterDEMTileSource = Dt, b.RasterTileSource = Ot, b.ScaleControl = class {
          constructor(p) {
            this._onMove = () => {
              ec(this._map, this._container, this.options)
            }, this.setUnit = e => {
              this.options.unit = e, ec(this._map, this._container, this.options)
            }, this.options = Object.assign(Object.assign({}, cl), p)
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(p) {
            return this._map = p, this._container = W.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", p.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container
          }
          onRemove() {
            W.remove(this._container), this._map.off("move", this._onMove), this._map = void 0
          }
        }, b.ScrollZoomHandler = Id, b.Style = jc, b.TerrainControl = class {
          constructor(p) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon()
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
            }, this.options = p
          }
          onAdd(p) {
            return this._map = p, this._container = W.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = W.create("button", "maplibregl-ctrl-terrain", this._container), W.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container
          }
          onRemove() {
            W.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0
          }
        }, b.TwoFingersTouchPitchHandler = Wl, b.TwoFingersTouchRotateHandler = Cs, b.TwoFingersTouchZoomHandler = Gl, b.TwoFingersTouchZoomRotateHandler = Md, b.VectorTileSource = Vt, b.VideoSource = Ft, b.addSourceType = (p, e) => s._(void 0, void 0, void 0, (function*() {
          if (Er(p)) throw new Error(`A source type called "${p}" already exists.`);
          ((i, l) => {
            ur[i] = l
          })(p, e)
        })), b.clearPrewarmedResources = function() {
          const p = ot;
          p && (p.isPreloaded() && p.numActive() === 1 ? (p.release(ke), ot = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
        }, b.createTileMesh = Bo, b.getMaxParallelImageRequests = function() {
          return s.a.MAX_PARALLEL_IMAGE_REQUESTS
        }, b.getRTLTextPluginStatus = function() {
          return Vr().getRTLTextPluginStatus()
        }, b.getVersion = function() {
          return wu
        }, b.getWorkerCount = function() {
          return qe.workerCount
        }, b.getWorkerUrl = function() {
          return s.a.WORKER_URL
        }, b.importScriptInWorkers = function(p) {
          return He().broadcast("IS", p)
        }, b.prewarm = function() {
          Pt().acquire(ke)
        }, b.setMaxParallelImageRequests = function(p) {
          s.a.MAX_PARALLEL_IMAGE_REQUESTS = p
        }, b.setRTLTextPlugin = function(p, e) {
          return Vr().setRTLTextPlugin(p, e)
        }, b.setWorkerCount = function(p) {
          qe.workerCount = p
        }, b.setWorkerUrl = function(p) {
          s.a.WORKER_URL = p
        }
      }));
      var E = h;
      return E
    }))
  })(sp)), sp.exports
}
var ak = ik();
const Kd = s_(ak);
class Sv {
  constructor(a) {
    Tr(this, "gm");
    Tr(this, "markers", new Map);
    Tr(this, "canvases", new Map);
    Tr(this, "canvasSize");
    Tr(this, "canvasOpacity", .8);
    this.input = a, this.gm = new Zs(this.input.tileSize);
    const h = L0(a.img);
    this.canvasSize = Math.ceil(2e3 / h)
  }
  place([a, h]) {
    const y = this.gm.latLonToPixelsFloor(a, h, this.input.zoom),
      k = this.getMarkerId(y),
      E = this.gm.latLonToPixelBoundsLatLon(a, h, this.input.zoom),
      b = this.input.map;
    if (this.input.markerFn && !this.markers.has(k)) {
      const X = this.input.markerFn();
      X.setLngLat({
        lat: E.min[0],
        lng: (E.max[1] + E.min[1]) / 2
      }).addTo(b), this.markers.set(k, X)
    }
    const {
      key: s,
      pos: F,
      innerPos: O
    } = this.getCanvasPos(y);
    let G = this.canvases.get(s);
    if (!G) {
      const X = this.canvasSize,
        Q = F.x * X,
        W = F.y * X,
        de = Q + X - 1,
        _e = W + X - 1,
        Ae = this.gm.pixelsToLatLon(Q, _e + 1, this.input.zoom),
        xe = this.gm.pixelsToLatLon(de + 1, W, this.input.zoom);
      G = new ok({
        id: `${this.input.id}-${s}`,
        img: this.input.img,
        canvasSize: this.canvasSize,
        coordinates: a_({
          min: Ae,
          max: xe
        }),
        layerPaint: {
          "raster-resampling": "nearest",
          "raster-opacity": this.canvasOpacity
        }
      }), G.addTo(this.input.map), this.canvases.set(s, G)
    }
    G.place(O.x, O.y)
  }
  clear() {
    const a = this.input.map;
    for (const h of this.canvases.values()) h.removeFrom(a), h.removeDOM();
    this.canvases.clear();
    for (const h of this.markers.values()) h.remove();
    this.markers.clear()
  }
  clearAndPlace(a) {
    this.clear(), this.place(a)
  }
  remove([a, h]) {
    let y = !1;
    const k = this.gm.latLonToPixelsFloor(a, h, this.input.zoom),
      {
        key: E,
        innerPos: b
      } = this.getCanvasPos(k),
      s = this.canvases.get(E);
    s && (y = s.remove(b.x, b.y), s.annotationsCount() === 0 && (this.canvases.delete(E), s.removeFrom(this.input.map), s.removeDOM()));
    const F = this.getMarkerId(k),
      O = this.markers.get(F);
    return O == null || O.remove(), this.markers.delete(F), y
  }
  setCanvasOpacity(a) {
    this.canvasOpacity = a;
    for (const h of this.canvases.values()) h.setOpacity(a)
  }
  getMarkerId([a, h]) {
    return `${this.input.id}:${a},${h}`
  }
  getCanvasPos([a, h]) {
    const y = {
        x: Math.floor(a / this.canvasSize),
        y: Math.floor(h / this.canvasSize)
      },
      k = {
        x: a % this.canvasSize,
        y: h % this.canvasSize
      },
      E = `${y.x},${y.y}`;
    return {
      pos: y,
      innerPos: k,
      key: E
    }
  }
}
class ok {
  constructor(a) {
    Tr(this, "annotations", new Set);
    Tr(this, "canvas");
    Tr(this, "imgSize");
    Tr(this, "maps", new Set);
    this.input = a, this.imgSize = L0(a.img), this.canvas = document.createElement("canvas"), this.canvas.width = this.input.canvasSize * this.imgSize, this.canvas.height = this.input.canvasSize * this.imgSize
  }
  place(a, h) {
    const y = this.getPixelKey(a, h);
    if (this.annotations.has(y)) return !1;
    const k = this.canvas.getContext("2d");
    if (k) {
      const E = a * this.imgSize,
        b = h * this.imgSize;
      k.drawImage(this.input.img, E, b)
    }
    return this.annotations.add(y), !0
  }
  remove(a, h) {
    const y = this.getPixelKey(a, h);
    if (!this.annotations.has(y)) return !1;
    const k = this.canvas.getContext("2d");
    if (k) {
      const E = a * this.imgSize,
        b = h * this.imgSize;
      k.clearRect(E, b, this.imgSize, this.imgSize)
    }
    return this.annotations.delete(y), !0
  }
  addTo(a) {
    const h = this.input.id;
    a.getSource(h) || a.addSource(h, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), a.getLayer(h) || a.addLayer({
      id: h,
      type: "raster",
      source: h,
      paint: this.input.layerPaint
    }), this.maps.add(a)
  }
  removeFrom(a) {
    const {
      id: h
    } = this.input;
    a.getLayer(h) && a.removeLayer(h), a.getSource(h) && a.removeSource(h), this.maps.delete(a)
  }
  removeDOM() {
    this.canvas.remove()
  }
  annotationsCount() {
    return this.annotations.size
  }
  setOpacity(a) {
    for (const h of this.maps.values()) h.setPaintProperty(this.input.id, "raster-opacity", a)
  }
  getPixelKey(a, h) {
    return `${a},${h}`
  }
}

function L0(d) {
  return Math.max(d.naturalWidth, d.naturalHeight)
}

function sk() {
  return window.matchMedia("(display-mode: standalone)").matches || "standalone" in window.navigator && window.navigator.standalone === !0
}

function lk(d) {
  const a = {
      opaque: !0
    },
    h = d.searchParams.get("lat"),
    y = d.searchParams.get("lng");
  h && y && (a.pos = {
    lat: parseFloat(h),
    lng: parseFloat(y)
  });
  const k = d.searchParams.get("zoom");
  k && (a.zoom = parseFloat(k));
  const E = d.searchParams.get("season");
  E && (a.season = parseInt(E));
  const b = d.searchParams.get("opaque");
  return b && (a.opaque = b !== "0"), d.searchParams.get("select") && (a.select = !0), d.searchParams.get("twitch-migration") && (a.twitchMigration = !0), a.newUser = !!d.searchParams.get("new-user"), a.discordLinked = !!d.searchParams.get("discord-linked"), a.alliance = !!d.searchParams.get("alliance"), a
}

function ck(d, a) {
  return d = new URL(d), a.pos !== void 0 && (d.searchParams.set("lat", a.pos.lat.toString()), d.searchParams.set("lng", a.pos.lng.toString())), a.zoom !== void 0 && d.searchParams.set("zoom", a.zoom.toString()), a.season !== void 0 && d.searchParams.set("season", a.season.toString()), a.opaque !== void 0 && d.searchParams.set("opaque", a.opaque ? "1" : "0"), a.newUser !== void 0 && d.searchParams.set("new-user", a.newUser ? "1" : "0"), a.alliance !== void 0 && d.searchParams.set("alliance", a.alliance ? "1" : "0"), a.select && d.searchParams.set("alliance", "1"), d
}
const lp = di({
  shouldReload: !0
});
var uk = (d, a) => {
    var h;
    (h = a()) == null || h.close()
  },
  hk = fe('<dialog class="modal"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function dk(d, a) {
  Ir(a, !0);
  let h = Tt(a, "ref", 15),
    y = rt(!1),
    k = rt(di(a.description)),
    E = rt(void 0);
  An(() => {
    const Ie = Pe => {
      var De;
      Pe.key === "Escape" && ((De = h()) == null || De.close())
    };
    return document.addEventListener("keydown", Ie), () => document.removeEventListener("keydown", Ie)
  });
  var b = hk(),
    s = P(b),
    F = P(s),
    O = P(F, !0);
  I(F);
  var G = B(F, 2),
    X = P(G),
    Q = P(X);
  {
    let Ie = ht(() => C0());
    l0(Q, {
      class: "h-24 rounded-lg",
      get placeholder() {
        return x(Ie)
      },
      max: 512,
      get value() {
        return x(k)
      },
      set value(Pe) {
        re(k, Pe, !0)
      },
      get validate() {
        return x(E)
      },
      set validate(Pe) {
        re(E, Pe, !0)
      }
    })
  }
  I(X);
  var W = B(X, 2),
    de = P(W);
  de.__click = [uk, h];
  var _e = P(de, !0);
  I(de);
  var Ae = B(de, 2),
    xe = P(Ae, !0);
  I(Ae), I(W), I(G), I(s), en(2), I(b), us(b, Ie => h(Ie), () => h()), Ze((Ie, Pe, De) => {
    ce(O, Ie), de.disabled = x(y), ce(_e, Pe), Ae.disabled = x(y), ce(xe, De)
  }, [() => Kx(), () => Zh(), () => fT()]), Zn("submit", G, async () => {
    var Ie, Pe, De;
    try {
      if (!((Ie = x(E)) != null && Ie())) return;
      re(y, !0), a.description !== x(k) && await nn.updateAllianceDescription(x(k)), await ((Pe = a.onsuccess) == null ? void 0 : Pe.call(a, x(k))), (De = h()) == null || De.close()
    } catch ($e) {
      Ar.error($e.message)
    } finally {
      re(y, !1)
    }
  }), Z(d, b), Pr()
}
Ln(["click"]);
var pk = (d, a, h) => {
    navigator.clipboard.writeText(x(a).toString()), re(h, !0), setTimeout(() => {
      re(h, !1)
    }, 1e3)
  },
  fk = fe('<span class="loading loading-spinner loading-md center-absolute absolute"></span>'),
  mk = fe('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function _k(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15),
    y = rt(""),
    k = rt(!1);
  const E = ht(() => ri.url.origin + `/join?id=${x(y)}`);
  Kr(() => {
    h() && nn.getAllianceInvites().then(tt => {
      re(y, tt[0], !0)
    }).catch(tt => {
      Ar.error(tt.message)
    })
  }), An(() => {
    const tt = Ve => {
      Ve.key === "Escape" && h(!1)
    };
    return document.addEventListener("keydown", tt), () => document.removeEventListener("keydown", tt)
  });
  var b = mk(),
    s = P(b),
    F = B(P(s), 2),
    O = P(F, !0);
  I(F);
  var G = B(F, 2),
    X = P(G, !0);
  I(G);
  var Q = B(G, 2),
    W = P(Q);
  let de;
  var _e = P(W);
  ya(_e);
  var Ae = B(_e, 2),
    xe = P(Ae);
  let Ie;
  xe.__click = [pk, E, k];
  var Pe = P(xe, !0);
  I(xe), I(Ae), I(W);
  var De = B(W, 2);
  {
    var $e = tt => {
      var Ve = fk();
      Z(tt, Ve)
    };
    Be(De, tt => {
      x(y) || tt($e)
    })
  }
  I(Q), I(s), en(2), I(b), pi(b, () => tt => {
    Kr(() => {
      h() ? tt.show() : tt.close()
    })
  }), Ze((tt, Ve, Re, Ue, Ce, We) => {
    ce(O, tt), ce(X, Ve), de = Or(W, 1, "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5", null, de, Re), fp(_e, Ue), Ie = Or(xe, 1, "btn btn-primary", null, Ie, Ce), ce(Pe, We)
  }, [() => mC(), () => vC(), () => ({
    invisible: !x(y)
  }), () => x(E).toString(), () => ({
    "btn-success": x(k)
  }), () => x(k) ? e_() : hm()]), Zn("close", b, () => h(!1)), Z(d, b), Pr()
}
Ln(["click"]);
var gk = xr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>');

function Yu(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = gk();
  lr(y, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    ...h
  })), Z(d, y)
}
var vk = fe('<span class="text-success">(Verified)</span>'),
  yk = fe('<a target="_blank" rel="noreferer" aria-label="Discord"><!></a>'),
  xk = async (d, a) => {
    await navigator.clipboard.writeText(a.username), Ar.info(bS())
  }, bk = fe("<button><!></button>"), wk = fe('<span class="tooltip h-4"><div class="tooltip-content"><span> </span> <!></div> <!></span>');

function Vh(d, a) {
  Ir(a, !0);
  const h = !!a.id;
  var y = wk(),
    k = P(y),
    E = P(k),
    b = P(E);
  I(E);
  var s = B(E, 2);
  {
    var F = Q => {
      var W = vk();
      Z(Q, W)
    };
    Be(s, Q => {
      h && Q(F)
    })
  }
  I(k);
  var O = B(k, 2);
  {
    var G = Q => {
        var W = yk(),
          de = P(W);
        Yu(de, {
          class: "size-4 opacity-70"
        }), I(W), Ze(_e => nr(W, "href", _e), [() => `https://discord.com/users/${encodeURIComponent(a.id)}`]), Z(Q, W)
      },
      X = Q => {
        var W = bk();
        W.__click = [xk, a];
        var de = P(W);
        Yu(de, {
          class: "size-4 opacity-70"
        }), I(W), Z(Q, W)
      };
    Be(O, Q => {
      h ? Q(G) : Q(X, !1)
    })
  }
  I(y), Ze(() => ce(b, `Discord: ${a.username??""}`)), Z(d, y), Pr()
}
Ln(["click"]);
var Ck = fe('<input type="radio" class="tab max-[380px]:px-3"/>'),
  Tk = fe('<div class="tabs tabs-border w-max font-medium"></div>');

function l_(d, a) {
  Ir(a, !0);
  const h = [];
  let y = Tt(a, "value", 15, "today"),
    k = [{
      value: "today",
      label: Rp()
    }, {
      value: "week",
      label: zC()
    }, {
      value: "month",
      label: RC()
    }, {
      value: "all-time",
      label: OC()
    }];
  var E = Tk();
  ai(E, 21, () => k, b => b.value, (b, s) => {
    var F = Ck();
    ya(F);
    var O;
    Ze(() => {
      nr(F, "aria-label", x(s).label), O !== (O = x(s).value) && (F.value = (F.__value = x(s).value) ?? "")
    }), Jm(h, [], F, () => (x(s).value, y()), y), Z(b, F)
  }), I(E), Z(d, E), Pr()
}
const Sk = typeof window < "u" ? window : void 0;

function Ik(d) {
  let a = d.activeElement;
  for (; a != null && a.shadowRoot;) {
    const h = a.shadowRoot.activeElement;
    if (h === a) break;
    a = h
  }
  return a
}
var kc, oh, t0;
let Pk = (t0 = class {
  constructor(a = {}) {
    Lr(this, kc);
    Lr(this, oh);
    const {
      window: h = Sk,
      document: y = h == null ? void 0 : h.document
    } = a;
    h !== void 0 && (ta(this, kc, y), ta(this, oh, a0(k => {
      const E = Hu(h, "focusin", k),
        b = Hu(h, "focusout", k);
      return () => {
        E(), b()
      }
    })))
  }
  get current() {
    var a;
    return (a = Ye(this, oh)) == null || a.call(this), Ye(this, kc) ? Ik(Ye(this, kc)) : null
  }
}, kc = new WeakMap, oh = new WeakMap, t0);
new Pk;

function kk(d, a) {
  switch (d) {
    case "post":
      Kr(a);
      break;
    case "pre":
      $m(a);
      break
  }
}

function D0(d, a, h, y = {}) {
  const {
    lazy: k = !1
  } = y;
  let E = !k,
    b = Array.isArray(d) ? [] : void 0;
  kk(a, () => {
    const s = Array.isArray(d) ? d.map(O => O()) : d();
    if (!E) {
      E = !0, b = s;
      return
    }
    const F = bl(() => h(s, b));
    return b = s, F
  })
}

function Cl(d, a, h) {
  D0(d, "post", a, h)
}

function Mk(d, a, h) {
  D0(d, "pre", a, h)
}
Cl.pre = Mk;
var Ak = fe('<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>'),
  Ek = fe('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  zk = fe('<span class="font-flag tooltip ml-0.5"> </span>'),
  Lk = (d, a, h) => {
    a.onlastpixelclick({
      lat: x(h).lastLatitude ?? 0,
      lng: x(h).lastLongitude ?? 0
    })
  },
  Dk = fe("<button><!></button>"),
  Rk = fe('<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>'),
  Bk = fe('<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>'),
  Fk = fe('<div><!> <div class="mt-4"><!></div></div>');

function Ok(d, a) {
  Ir(a, !0);
  let h = Tt(a, "reload", 15),
    y = rt(!0),
    k = rt([]),
    E = rt(0),
    b = rt("today"),
    s = {};
  h(F);

  function F() {
    const _e = x(b);
    nn.allianceLeaderboard(_e).then(Ae => {
      re(k, Ae), s = {
        [_e]: Ae
      }, re(y, !1)
    }).catch(Ae => {
      Ar.error(Ae.message)
    })
  }
  Cl(() => [x(b)], () => {
    const _e = x(b),
      Ae = s[_e];
    if (Ae) {
      re(k, Ae), re(y, !1);
      return
    }
    re(y, !0), nn.allianceLeaderboard(_e).then(xe => {
      re(k, xe), s[_e] = xe, re(y, !1)
    }).catch(xe => {
      Ar.error(xe.message)
    })
  });
  var O = Fk(),
    G = P(O);
  l_(G, {
    get value() {
      return x(b)
    },
    set value(_e) {
      re(b, _e, !0)
    }
  });
  var X = B(G, 2),
    Q = P(X);
  {
    var W = _e => {
        var Ae = Ak();
        Z(_e, Ae)
      },
      de = _e => {
        var Ae = or(),
          xe = pt(Ae);
        {
          var Ie = De => {
              var $e = Ek(),
                tt = P($e),
                Ve = B(tt);
              {
                var Re = Ce => {
                    var We = Ii();
                    Ze(Je => ce(We, Je), [() => Rp().toLowerCase()]), Z(Ce, We)
                  },
                  Ue = Ce => {
                    var We = or(),
                      Je = pt(We);
                    {
                      var Ge = mt => {
                          var K = Ii();
                          Ze(ee => ce(K, ee), [() => r_()]), Z(mt, K)
                        },
                        Ee = mt => {
                          var K = or(),
                            ee = pt(K);
                          {
                            var le = ae => {
                              var ke = Ii();
                              Ze(qe => ce(ke, qe), [() => n_()]), Z(ae, ke)
                            };
                            Be(ee, ae => {
                              x(b) === "month" && ae(le)
                            }, !0)
                          }
                          Z(mt, K)
                        };
                      Be(Je, mt => {
                        x(b) === "week" ? mt(Ge) : mt(Ee, !1)
                      }, !0)
                    }
                    Z(Ce, We)
                  };
                Be(Ve, Ce => {
                  x(b) === "today" ? Ce(Re) : Ce(Ue, !1)
                })
              }
              I($e), Ze(Ce => ce(tt, `${Ce??""} `), [() => t_()]), Z(De, $e)
            },
            Pe = De => {
              var $e = Bk(),
                tt = P($e),
                Ve = P(tt),
                Re = B(P(Ve)),
                Ue = P(Re, !0);
              I(Re);
              var Ce = B(Re),
                We = P(Ce, !0);
              I(Ce), I(Ve), I(tt);
              var Je = B(tt);
              ai(Je, 31, () => x(k), Ge => Ge.userId, (Ge, Ee, mt) => {
                const K = ht(() => {
                  var Ot;
                  return ((Ot = wt.data) == null ? void 0 : Ot.id) === x(Ee).userId
                });
                var ee = Rk();
                let le;
                var ae = P(ee),
                  ke = P(ae, !0);
                I(ae);
                var qe = B(ae),
                  lt = P(qe),
                  ot = P(lt);
                fo(ot, {
                  class: "size-10 border",
                  get userId() {
                    return x(Ee).userId
                  },
                  get pictureUrl() {
                    return x(Ee).picture
                  }
                });
                var dt = B(ot, 2),
                  Pt = P(dt),
                  Lt = B(Pt),
                  He = P(Lt);
                I(Lt), I(dt);
                var ut = B(dt, 2);
                {
                  var gt = Ot => {
                    const Dt = ht(() => Lo(x(Ee).equippedFlag));
                    var Rt = zk(),
                      Zt = P(Rt, !0);
                    I(Rt), Ze(() => {
                      nr(Rt, "data-tip", x(Dt).name), ce(Zt, x(Dt).flag)
                    }), Z(Ot, Rt)
                  };
                  Be(ut, Ot => {
                    x(Ee).equippedFlag && Ot(gt)
                  })
                }
                var St = B(ut, 2);
                {
                  var vt = Ot => {
                    Vh(Ot, {
                      get username() {
                        return x(Ee).discord
                      },
                      get id() {
                        return x(Ee).discordId
                      }
                    })
                  };
                  Be(St, Ot => {
                    x(Ee).discord && Ot(vt)
                  })
                }
                I(lt), I(qe);
                var Ct = B(qe),
                  At = P(Ct),
                  Bt = B(At);
                {
                  var Vt = Ot => {
                    var Dt = Dk();
                    let Rt;
                    Dt.__click = [Lk, a, Ee];
                    var Zt = P(Dt);
                    Wm(Zt, {
                      class: "size-4"
                    }), I(Dt), Ze((Ft, cr) => {
                      Rt = Or(Dt, 1, "btn btn-sm btn-ghost absolute -right-2 top-1/2 !-translate-y-1/2 sm:right-4", null, Rt, Ft), nr(Dt, "data-tip", cr)
                    }, [() => ({
                      tooltip: x(E) > 640
                    }), () => cb()]), Z(Ot, Dt)
                  };
                  Be(Bt, Ot => {
                    x(Ee).lastLatitude && x(Ee).lastLongitude && Ot(Vt)
                  })
                }
                I(Ct), I(ee), Ze((Ot, Dt, Rt) => {
                  var Zt;
                  le = Or(ee, 1, "", null, le, Ot), ce(ke, x(mt) + 1), Or(dt, 1, `font-semibold ${Dt??""} flex gap-1`), ce(Pt, `${(x(K)?((Zt=wt.data)==null?void 0:Zt.name)??x(Ee).name:x(Ee).name)??""} `), ce(He, `#${x(Ee).userId??""}`), ce(At, `${Rt??""} `)
                }, [() => ({
                  "bg-base-200": x(K)
                }), () => Ri(x(Ee).userId), () => x(Ee).pixelsPainted.toLocaleString("en-US")]), yl(ee, () => xl, () => ({
                  duration: 200
                })), Z(Ge, ee)
              }), I(Je), I($e), Ze((Ge, Ee) => {
                ce(Ue, Ge), ce(We, Ee)
              }, [() => Xm(), () => Hm()]), Z(De, $e)
            };
          Be(xe, De => {
            x(k).length === 0 ? De(Ie) : De(Pe, !1)
          }, !0)
        }
        Z(_e, Ae)
      };
    Be(Q, _e => {
      x(y) ? _e(W) : _e(de, !1)
    })
  }
  I(X), I(O), zp("innerWidth", _e => re(E, _e, !0)), Z(d, O), Pr()
}
Ln(["click"]);
var jk = xr('<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>');

function c_(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = jk();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var Nk = (d, a) => a.onclickback(),
  Zk = fe('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>'),
  Vk = async (d, a) => {
    try {
      x(a).loading = !0, await nn.giveAllianceAdmin(x(a).id), x(a).role = "admin"
    } catch {
      Ar.error($S())
    } finally {
      x(a).loading = !1
    }
  }, qk = async (d, a, h) => {
    try {
      x(a).loading = !0, await nn.banAllianceUser(x(a).id), h.data = h.data.filter(y => y.id !== x(a).id)
    } catch {
      Ar.error(gT())
    } finally {
      x(a).loading = !1
    }
  }, Uk = fe('<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>', 1), $k = fe('<li><button class="btn btn-ghost text-base-content/80"> </button></li>'), Gk = fe('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>'), Wk = fe('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'), Hk = (d, a, h) => {
    nn.unbanAllianceUser(x(a).id).then(() => {
      h.data = h.data.filter(y => y.id !== x(a).id)
    }).catch(y => Ar.error(y.message)).finally(() => {
      x(a).loading = !1
    })
  }, Jk = fe('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>'), Xk = fe('<div class="text-base-content/80 mt-4 flex justify-center"> </div>'), Yk = fe('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'), Kk = fe('<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>');

function Qk(d, a) {
  Ir(a, !0);
  let h = di({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    }),
    y = di({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    });
  var k = Kk(),
    E = P(k),
    b = P(E);
  b.__click = [Nk, a];
  var s = P(b);
  fb(s, {
    class: "size-5"
  }), I(b);
  var F = B(b, 2),
    O = P(F, !0);
  I(F), I(E);
  var G = B(E, 2),
    X = P(G);
  ya(X);
  var Q = B(X, 2),
    W = P(Q),
    de = P(W);
  ai(de, 21, () => h.data, Ue => Ue.id, (Ue, Ce, We) => {
    const Je = ht(() => {
      var gt;
      return ((gt = wt.data) == null ? void 0 : gt.id) === x(Ce).id
    });
    var Ge = Gk(),
      Ee = P(Ge),
      mt = P(Ee),
      K = P(mt);
    fo(K, {
      class: "size-10 border",
      get userId() {
        return x(Ce).id
      },
      get pictureUrl() {
        return x(Ce).picture
      }
    });
    var ee = B(K, 2),
      le = P(ee);
    I(ee);
    var ae = B(ee, 2);
    {
      var ke = gt => {
        var St = Zk();
        Z(gt, St)
      };
      Be(ae, gt => {
        x(Ce).role === "admin" && gt(ke)
      })
    }
    I(mt), I(Ee);
    var qe = B(Ee),
      lt = P(qe),
      ot = P(lt),
      dt = P(ot);
    c_(dt, {
      class: "size-4"
    }), I(ot);
    var Pt = B(ot, 2),
      Lt = P(Pt);
    {
      var He = gt => {
          var St = Uk(),
            vt = pt(St),
            Ct = P(vt);
          Ct.__click = [Vk, Ce];
          var At = P(Ct, !0);
          I(Ct), I(vt);
          var Bt = B(vt, 2),
            Vt = P(Bt);
          Vt.__click = [qk, Ce, h];
          var Ot = P(Vt, !0);
          I(Vt), I(Bt), Ze((Dt, Rt) => {
            Ct.disabled = x(Ce).loading, ce(At, Dt), Vt.disabled = x(Ce).loading, ce(Ot, Rt)
          }, [() => eT(), () => T0()]), Z(gt, St)
        },
        ut = gt => {
          var St = $k(),
            vt = P(St);
          vt.disabled = !0;
          var Ct = P(vt, !0);
          I(vt), I(St), Ze(At => ce(Ct, At), [() => aT()]), Z(gt, St)
        };
      Be(Lt, gt => {
        x(Ce).role === "member" ? gt(He) : gt(ut, !1)
      })
    }
    I(Pt), I(lt), I(qe), I(Ge), Ze(gt => {
      var St;
      Or(ee, 1, `font-semibold ${gt??""}`), ce(le, `${(x(Je)?((St=wt.data)==null?void 0:St.name)??x(Ce).name:x(Ce).name)??""} #${x(Ce).id??""}`)
    }, [() => Ri(x(Ce).id)]), Z(Ue, Ge)
  }), I(de), I(W);
  var _e = B(W, 2);
  {
    var Ae = Ue => {
      var Ce = or(),
        We = pt(Ce);
      Ju(We, () => h.page, Je => {
        var Ge = Wk();
        pi(Ge, () => Ee => {
          const mt = new IntersectionObserver(K => {
            K[0].isIntersecting && !h.loading && (h.loading = !0, nn.getAllianceMembers(h.page).then(ee => {
              h.data = [...h.data, ...ee.data], h.hasNextPage = ee.hasNext, h.page++
            }).catch(ee => {
              Ar.error(ee.message)
            }).finally(() => {
              h.loading = !1
            }))
          });
          return mt.observe(Ee), () => {
            mt.disconnect()
          }
        }), Z(Je, Ge)
      }), Z(Ue, Ce)
    };
    Be(_e, Ue => {
      h.hasNextPage && Ue(Ae)
    })
  }
  I(Q);
  var xe = B(Q, 2),
    Ie = B(xe, 2),
    Pe = P(Ie),
    De = P(Pe);
  ai(De, 21, () => y.data, Ue => Ue.id, (Ue, Ce, We) => {
    var Je = Jk(),
      Ge = P(Je),
      Ee = P(Ge),
      mt = P(Ee);
    fo(mt, {
      class: "size-10 border",
      get userId() {
        return x(Ce).id
      },
      get pictureUrl() {
        return x(Ce).picture
      }
    });
    var K = B(mt, 2),
      ee = P(K);
    I(K), I(Ee), I(Ge);
    var le = B(Ge),
      ae = P(le);
    ae.__click = [Hk, Ce, y];
    var ke = P(ae, !0);
    I(ae), I(le), I(Je), Ze((qe, lt) => {
      Or(K, 1, `font-semibold ${qe??""}`), ce(ee, `${x(Ce).name??""} #${x(Ce).id??""}`), ae.disabled = x(Ce).loading, ce(ke, lt)
    }, [() => Ri(x(Ce).id), () => lT()]), Z(Ue, Je)
  }), I(De), I(Pe);
  var $e = B(Pe, 2);
  {
    var tt = Ue => {
      var Ce = Xk(),
        We = P(Ce, !0);
      I(Ce), Ze(Je => ce(We, Je), [() => hT()]), Z(Ue, Ce)
    };
    Be($e, Ue => {
      !y.hasNextPage && y.data.length === 0 && Ue(tt)
    })
  }
  var Ve = B($e, 2);
  {
    var Re = Ue => {
      var Ce = or(),
        We = pt(Ce);
      Ju(We, () => y.page, Je => {
        var Ge = Yk();
        pi(Ge, () => Ee => {
          const mt = new IntersectionObserver(K => {
            K[0].isIntersecting && !y.loading && (y.loading = !0, nn.getAllianceBannedMembers(y.page).then(ee => {
              y.data = [...y.data, ...ee.data], y.hasNextPage = ee.hasNext, y.page++
            }).catch(ee => {
              Ar.error(ee.message)
            }).finally(() => {
              y.loading = !1
            }))
          });
          return mt.observe(Ee), () => {
            mt.disconnect()
          }
        }), Z(Je, Ge)
      }), Z(Ue, Ce)
    };
    Be(Ve, Ue => {
      y.hasNextPage && Ue(Re)
    })
  }
  I(Ie), I(G), I(k), Ze((Ue, Ce, We) => {
    ce(O, Ue), nr(X, "aria-label", Ce), nr(xe, "aria-label", We)
  }, [() => d0(), () => xT(), () => i_()]), Z(d, k), Pr()
}
Ln(["click"]);
var eM = fe('<span class="label"> </span>'),
  tM = fe('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>'),
  rM = fe('<p class="text-error ml-3 text-sm"> </p>'),
  nM = fe('<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>');

function _m(d, a) {
  Ir(a, !0);
  let h = Tt(a, "value", 15),
    y = Tt(a, "validate", 15),
    k = rt("");
  const E = ht(() => {
    var xe;
    return ((xe = h()) == null ? void 0 : xe.length) ?? 0
  });
  y(b);

  function b() {
    return a.min !== void 0 && x(E) < a.min ? (re(k, x(E) === 0 ? "Required" : `Min. characters: ${a.min}`, !0), !1) : a.max !== void 0 && x(E) > a.max ? (re(k, `Max. characters: ${a.max}`), !1) : !0
  }
  Kr(() => {
    var xe;
    a.max !== void 0 && x(E) > a.max && h((xe = h()) == null ? void 0 : xe.substring(0, a.max))
  });
  var s = nM(),
    F = P(s);
  let O;
  var G = P(F);
  {
    var X = xe => {
      var Ie = eM(),
        Pe = P(Ie, !0);
      I(Ie), Ze(() => ce(Pe, a.label)), Z(xe, Ie)
    };
    Be(G, xe => {
      a.label && xe(X)
    })
  }
  var Q = B(G, 2);
  ya(Q);
  var W = B(Q, 2);
  {
    var de = xe => {
      var Ie = tM(),
        Pe = P(Ie, !0);
      I(Ie), Ze(() => ce(Pe, a.max - x(E))), Z(xe, Ie)
    };
    Be(W, xe => {
      a.max !== void 0 && xe(de)
    })
  }
  I(F);
  var _e = B(F, 2);
  {
    var Ae = xe => {
      var Ie = rM(),
        Pe = P(Ie, !0);
      I(Ie), Ze(() => ce(Pe, x(k))), Z(xe, Ie)
    };
    Be(_e, xe => {
      x(k) && xe(Ae)
    })
  }
  I(s), Ze(xe => {
    O = Or(F, 1, "input w-full", null, O, xe), nr(Q, "placeholder", a.placeholder), nr(Q, "maxlength", a.max)
  }, [() => ({
    "input-error": !!x(k)
  })]), Mp(Q, h), Z(d, s), Pr()
}
var iM = (d, a) => {
    var h;
    (h = a()) == null || h.close()
  },
  aM = fe('<dialog class="modal"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function oM(d, a) {
  Ir(a, !0);
  let h = Tt(a, "ref", 15),
    y = rt(!1),
    k = rt(""),
    E = rt(void 0);
  An(() => {
    const Ie = Pe => {
      var De;
      Pe.key === "Escape" && ((De = h()) == null || De.close())
    };
    return document.addEventListener("keydown", Ie), () => document.removeEventListener("keydown", Ie)
  });
  var b = aM(),
    s = P(b),
    F = P(s),
    O = P(F, !0);
  I(F);
  var G = B(F, 2),
    X = P(G),
    Q = P(X);
  {
    let Ie = ht(() => fm()),
      Pe = ht(() => HC());
    _m(Q, {
      get label() {
        return x(Ie)
      },
      get placeholder() {
        return x(Pe)
      },
      min: 1,
      max: 16,
      get value() {
        return x(k)
      },
      set value(De) {
        re(k, De, !0)
      },
      get validate() {
        return x(E)
      },
      set validate(De) {
        re(E, De, !0)
      }
    })
  }
  I(X);
  var W = B(X, 2),
    de = P(W);
  de.__click = [iM, h];
  var _e = P(de, !0);
  I(de);
  var Ae = B(de, 2),
    xe = P(Ae, !0);
  I(Ae), I(W), I(G), I(s), en(2), I(b), us(b, Ie => h(Ie), () => h()), Ze((Ie, Pe, De) => {
    ce(O, Ie), de.disabled = x(y), ce(_e, Pe), Ae.disabled = x(y), ce(xe, De)
  }, [() => $C(), () => Zh(), () => YC()]), Zn("submit", G, async () => {
    var Ie, Pe;
    try {
      if (!((Ie = x(E)) != null && Ie())) return;
      re(y, !0);
      const {
        id: De
      } = await nn.createAlliance(x(k));
      await a.onsuccess(De), (Pe = h()) == null || Pe.close()
    } catch (De) {
      Ar.error(De.message)
    } finally {
      re(y, !1)
    }
  }), Z(d, b), Pr()
}
Ln(["click"]);
var sM = xr('<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>');

function qh(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = sM();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var lM = xr('<svg><path d="M160-160v-100.77l527.23-527.77q6.15-5.48 13.57-8.47 7.43-2.99 15.49-2.99t15.62 2.54q7.55 2.54 13.94 9.15l42.69 42.93q6.61 6.38 9.04 14 2.42 7.63 2.42 15.25 0 8.13-2.74 15.56-2.74 7.42-8.72 13.57L260.77-160H160Zm540.15-496.46L760-715.54 715.54-760l-59.08 59.85 43.69 43.69Z"></path></svg>'),
  cM = xr('<svg><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"></path></svg>');

function gm(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
  var y = or(),
    k = pt(y);
  {
    var E = s => {
        var F = lM();
        lr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...h
        })), Z(s, F)
      },
      b = s => {
        var F = cM();
        lr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...h
        })), Z(s, F)
      };
    Be(k, s => {
      a.filled ? s(E) : s(b, !1)
    })
  }
  Z(d, y)
}
var uM = xr('<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');

function hM(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = uM();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var dM = xr('<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>');

function pM(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = dM();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var fM = xr('<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>');

function mM(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = fM();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var _M = xr('<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>');

function Bp(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = _M();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}

function gM(d, a = "_blank") {
  return d.replaceAll(/https?:\/\/[^\s]+/g, h => `<a href="${h}"${a?` target="${a}"`:""}>${h}</a>`)
}
var vM = fe('<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>'),
  yM = async (d, a, h, y) => {
    try {
      re(a, !0), await nn.leaveAlliance(), re(h, !0), await y()
    } catch (k) {
      Ar.error(k.message)
    } finally {
      re(a, !1)
    }
  }, xM = (d, a) => {
    re(a, !0)
  }, bM = fe('<div class="tooltip"><button class="btn"><!></button></div>'), wM = (d, a) => {
    var h;
    (h = x(a)) == null || h.show()
  }, CM = fe('<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>'), TM = fe('<section class="text-base-content/80 highlight-link"><!> <!></section>'), SM = fe('<span class="font-semibold"> </span>'), IM = (d, a) => re(a, !0), PM = fe('<button class="text-primary font-semibold underline"> </button>'), kM = (d, a, h) => {
    var y;
    (y = x(a)) != null && y.hq ? h.onhqclick({
      lat: x(a).hq.latitude,
      lng: x(a).hq.longitude
    }) : h.onhqchange()
  }, MM = fe('<span class="text-primary underline"> </span>'), AM = fe('<span class="text-primary underline"> </span>'), EM = fe('<button class="text-base-content/80 p-1"><!></button>'), zM = fe('<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>'), LM = fe('<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>', 1), DM = (d, a) => {
    var h;
    (h = x(a)) == null || h.show()
  }, RM = fe('<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>', 1), BM = fe('<div class="h-full"><!></div>');

function FM(d, a) {
  Ir(a, !0);
  let h = rt(void 0),
    y = rt(!0),
    k = rt(void 0),
    E = rt(!1),
    b = rt(void 0),
    s = rt(!1),
    F = rt(!1),
    O = rt(() => {});
  Cl(() => a.open, () => {
    a.open && lp.shouldReload && G()
  }), An(() => {
    const _e = setInterval(() => {
      lp.shouldReload = !0
    }, 1e4);
    return () => {
      clearTimeout(_e)
    }
  });
  async function G() {
    try {
      re(h, await nn.getAlliance(), !0), x(h) && x(O)(), re(y, !1), lp.shouldReload = !1
    } catch (_e) {
      Ar.error(_e.message)
    }
  }
  var X = BM(),
    Q = P(X);
  {
    var W = _e => {
        var Ae = vM();
        Z(_e, Ae)
      },
      de = _e => {
        var Ae = or(),
          xe = pt(Ae);
        {
          var Ie = De => {
              Qk(De, {
                onclickback: () => re(F, !1)
              })
            },
            Pe = De => {
              var $e = or(),
                tt = pt($e);
              {
                var Ve = Ue => {
                    var Ce = LM(),
                      We = pt(Ce),
                      Je = P(We),
                      Ge = P(Je, !0);
                    I(Je);
                    var Ee = B(Je, 2),
                      mt = P(Ee),
                      K = P(mt),
                      ee = P(K);
                    c_(ee, {
                      class: "size-4"
                    }), I(K);
                    var le = B(K, 2),
                      ae = P(le),
                      ke = P(ae);
                    ke.__click = [yM, E, y, G];
                    var qe = P(ke, !0);
                    I(ke), I(ae), I(le), I(mt);
                    var lt = B(mt, 2);
                    {
                      var ot = ue => {
                        var V = bM(),
                          U = P(V);
                        U.__click = [xM, s];
                        var Y = P(U);
                        mM(Y, {
                          class: "size-4"
                        }), I(U), I(V), Ze(oe => nr(V, "data-tip", oe), [() => SC()]), Z(ue, V)
                      };
                      Be(lt, ue => {
                        x(h).role == "admin" && ue(ot)
                      })
                    }
                    I(Ee), I(We);
                    var dt = B(We, 2);
                    {
                      var Pt = ue => {
                        var V = TM(),
                          U = P(V);
                        Pp(U, () => gM(x(h).description || C0()));
                        var Y = B(U, 2);
                        {
                          var oe = me => {
                            var Se = CM();
                            Se.__click = [wM, b];
                            var Oe = P(Se);
                            gm(Oe, {
                              class: "size-4"
                            }), I(Se), Z(me, Se)
                          };
                          Be(Y, me => {
                            x(h).role === "admin" && me(oe)
                          })
                        }
                        I(V), Z(ue, V)
                      };
                      Be(dt, ue => {
                        (x(h).description || x(h).role === "admin") && ue(Pt)
                      })
                    }
                    var Lt = B(dt, 2),
                      He = P(Lt),
                      ut = P(He);
                    qh(ut, {
                      class: "inline size-4"
                    });
                    var gt = B(ut, 2),
                      St = P(gt),
                      vt = B(St),
                      Ct = P(vt, !0);
                    I(vt), I(gt), I(He);
                    var At = B(He, 2),
                      Bt = P(At);
                    Bp(Bt, {
                      class: "inline size-4"
                    });
                    var Vt = B(Bt, 2),
                      Ot = P(Vt),
                      Dt = B(Ot);
                    {
                      var Rt = ue => {
                          var V = SM(),
                            U = P(V, !0);
                          I(V), Ze(Y => ce(U, Y), [() => x(h).members.toLocaleString("en-US")]), Z(ue, V)
                        },
                        Zt = ue => {
                          var V = PM();
                          V.__click = [IM, F];
                          var U = P(V, !0);
                          I(V), Ze(Y => ce(U, Y), [() => x(h).members.toLocaleString("en-US")]), Z(ue, V)
                        };
                      Be(Dt, ue => {
                        x(h).role === "member" ? ue(Rt) : ue(Zt, !1)
                      })
                    }
                    I(Vt), I(At);
                    var Ft = B(At, 2);
                    {
                      var cr = ue => {
                        var V = zM(),
                          U = P(V);
                        hM(U, {
                          class: "inline size-4"
                        });
                        var Y = B(U, 2),
                          oe = P(Y),
                          me = B(oe);
                        me.__click = [kM, h, a];
                        var Se = P(me);
                        {
                          var Oe = it => {
                              var qt = MM(),
                                we = P(qt);
                              I(qt), Ze((Mt, Ut) => ce(we, `${Mt??""}, ${Ut??""}`), [() => x(h).hq.latitude.toFixed(3), () => x(h).hq.longitude.toFixed(3)]), Z(it, qt)
                            },
                            ze = it => {
                              var qt = AM(),
                                we = P(qt, !0);
                              I(qt), Ze(Mt => ce(we, Mt), [() => eC()]), Z(it, qt)
                            };
                          Be(Se, it => {
                            x(h).hq ? it(Oe) : it(ze, !1)
                          })
                        }
                        I(me), I(Y);
                        var Ke = B(Y, 2);
                        {
                          var _t = it => {
                            var qt = EM();
                            qt.__click = function(...Mt) {
                              var Ut;
                              (Ut = a.onhqchange) == null || Ut.apply(this, Mt)
                            };
                            var we = P(qt);
                            gm(we, {
                              class: "text-base-content/50 size-4"
                            }), I(qt), Z(it, qt)
                          };
                          Be(Ke, it => {
                            x(h).role === "admin" && it(_t)
                          })
                        }
                        I(V), Ze(it => ce(oe, `${it??""}: `), [() => Y3()]), Z(ue, V)
                      };
                      Be(Ft, ue => {
                        (x(h).hq || x(h).role === "admin") && ue(cr)
                      })
                    }
                    I(Lt);
                    var ur = B(Lt, 2),
                      Er = P(ur),
                      dr = P(Er, !0);
                    I(Er);
                    var pr = B(Er, 2),
                      vr = P(pr);
                    Ok(vr, {
                      get allianceId() {
                        return x(h).id
                      },
                      get onlastpixelclick() {
                        return a.onlastpixelclick
                      },
                      get reload() {
                        return x(O)
                      },
                      set reload(ue) {
                        re(O, ue, !0)
                      }
                    }), I(pr), I(ur);
                    var Vr = B(ur, 2);
                    dk(Vr, {
                      get description() {
                        return x(h).description
                      },
                      onsuccess: async ue => {
                        x(h) && (x(h).description = ue)
                      },
                      get ref() {
                        return x(b)
                      },
                      set ref(ue) {
                        re(b, ue, !0)
                      }
                    });
                    var qr = B(Vr, 2);
                    _k(qr, {
                      get open() {
                        return x(s)
                      },
                      set open(ue) {
                        re(s, ue, !0)
                      }
                    }), Ze((ue, V, U, Y, oe) => {
                      ce(Ge, x(h).name), ke.disabled = x(E), ce(qe, ue), ce(St, `${V??""}: `), ce(Ct, U), ce(Ot, `${Y??""}: `), ce(dr, oe)
                    }, [() => H3(), () => Hm(), () => x(h).pixelsPainted.toLocaleString("en-US"), () => d0(), () => Qm()]), Z(Ue, Ce)
                  },
                  Re = Ue => {
                    var Ce = RM(),
                      We = pt(Ce),
                      Je = P(We),
                      Ge = P(Je);
                    I(Je);
                    var Ee = B(Je, 2),
                      mt = P(Ee);
                    pM(mt, {
                      class: "size-5"
                    });
                    var K = B(mt, 1, !0);
                    I(Ee);
                    var ee = B(Ee, 2),
                      le = P(ee),
                      ae = P(le, !0);
                    I(le), I(ee);
                    var ke = B(ee, 2);
                    ke.__click = [DM, k];
                    var qe = P(ke);
                    p0(qe, {
                      class: "size-6"
                    });
                    var lt = B(qe);
                    I(ke), I(We);
                    var ot = B(We, 2);
                    oM(ot, {
                      onsuccess: G,
                      get ref() {
                        return x(k)
                      },
                      set ref(dt) {
                        re(k, dt, !0)
                      }
                    }), Ze((dt, Pt, Lt, He) => {
                      ce(Ge, `${dt??""}:`), ce(K, Pt), ce(ae, Lt), ce(lt, ` ${He??""}`)
                    }, [() => nC(), () => oC(), () => cC(), () => dC()]), Z(Ue, Ce)
                  };
                Be(tt, Ue => {
                  x(h) ? Ue(Ve) : Ue(Re, !1)
                }, !0)
              }
              Z(De, $e)
            };
          Be(xe, De => {
            x(F) ? De(Ie) : De(Pe, !1)
          }, !0)
        }
        Z(_e, Ae)
      };
    Be(Q, _e => {
      x(y) ? _e(W) : _e(de, !1)
    })
  }
  I(X), Z(d, X), Pr()
}
Ln(["click"]);
var OM = xr('<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>');

function Fp(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = OM();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var jM = fe('<dialog class="modal"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function NM(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15);
  An(() => {
    const X = Q => {
      Q.key === "Escape" && h(!1)
    };
    return document.addEventListener("keydown", X), () => document.removeEventListener("keydown", X)
  });
  var y = jM(),
    k = P(y),
    E = B(P(k), 2),
    b = P(E);
  Fp(b, {
    class: "size-5 max-sm:size-6"
  });
  var s = B(b, 2),
    F = P(s, !0);
  I(s), I(E);
  var O = B(E, 2),
    G = P(O);
  FM(G, {
    get open() {
      return h()
    },
    get onhqchange() {
      return a.onhqchange
    },
    get onhqclick() {
      return a.onhqclick
    },
    get onlastpixelclick() {
      return a.onlastpixelclick
    }
  }), I(O), I(k), en(2), I(y), pi(y, () => X => {
    Kr(() => {
      h() ? (X.show(), ri.url.searchParams.get("alliance") && (ri.url.searchParams.delete("alliance"), mp(ri.url.toString()))) : X.close()
    })
  }), Ze(X => ce(F, X), [() => Lp()]), Zn("close", y, () => h(!1)), Ni(2, O, () => va, () => ({
    duration: 300
  })), Z(d, y), Pr()
}

function ZM(d, a, h) {
  return new Promise((y, k) => {
    d.once("render", () => {
      const E = d.getCanvas().toDataURL(),
        b = document.createElement("img");
      b.src = E, b.onload = () => {
        const s = document.createElement("canvas");
        s.width = b.width, s.height = b.height;
        const F = s.getContext("2d");
        if (F) {
          F.drawImage(b, 0, 0);
          const [O, G, X, Q] = F.getImageData(a, h, 1, 1).data;
          y([O, G, X, Q])
        } else k(new Error("Could not get 2d context from canvas"));
        b.remove(), s.remove()
      }
    }), d.triggerRepaint()
  })
}

function u_(d, a) {
  return new Promise((h, y) => {
    d.once("render", () => {
      const k = d.getCanvas();
      let E = k;
      if (a != null && a.maxWidth || a != null && a.maxHeight) {
        const b = k.width,
          s = k.height,
          F = (a == null ? void 0 : a.maxWidth) ?? b,
          O = (a == null ? void 0 : a.maxHeight) ?? s;
        E = document.createElement("canvas");
        const G = Math.min(F / b, O / s);
        E.width = Math.floor(b * G), E.height = Math.floor(s * G);
        const X = E.getContext("2d");
        X && X.drawImage(k, 0, 0, E.width, E.height)
      }
      try {
        E.toBlob(b => {
          b && h(b)
        }, (a == null ? void 0 : a.type) ?? "image/png", (a == null ? void 0 : a.quality) ?? 1)
      } catch (b) {
        y(b)
      } finally {
        E !== k && E.remove()
      }
    })
  })
}
var VM = xr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>');

function qM(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = VM();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var UM = xr('<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>');

function R0(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = UM();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
const Sc = {
  hour: 3600 * 1e3,
  min: 60 * 1e3,
  sec: 1e3
};

function gp(d) {
  const a = Math.floor(d / Sc.hour);
  d -= a * Sc.hour;
  const h = Math.floor(d / Sc.min);
  d -= h * Sc.min;
  const k = Math.floor(d / Sc.sec).toString().padStart(2, "0");
  return a > 0 ? `${a}:${h.toString().padStart(2,"0")}:${k}` : `${h}:${k}`
}

function $M(d) {
  const a = d.getFullYear(),
    h = String(d.getMonth() + 1).padStart(2, "0"),
    y = String(d.getDate()).padStart(2, "0"),
    k = String(d.getHours()).padStart(2, "0"),
    E = String(d.getMinutes()).padStart(2, "0"),
    b = String(d.getSeconds()).padStart(2, "0");
  return `${a}-${h}-${y} ${k}:${E}:${b}`
}
var GM = (d, a, h) => {
    navigator.clipboard.writeText(a.url.toString()), re(h, !0), setTimeout(() => {
      re(h, !1)
    }, 1e3)
  },
  WM = fe('<img class="border-base-content/20 border" alt="Screenshot"/>'),
  HM = fe('<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>'),
  JM = async (d, a) => {
    x(a) && (await navigator.clipboard.write([new ClipboardItem({
      "image/png": x(a)
    })]), Ar.info(YI()))
  }, XM = fe('<div><h3 class="mb-1 mt-5 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>'), YM = fe('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function KM(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15),
    y = rt(!1);
  An(() => {
    const Pe = De => {
      De.key === "Escape" && h(!1)
    };
    return document.addEventListener("keydown", Pe), () => document.removeEventListener("keydown", Pe)
  });
  let k = rt(null),
    E = rt("");
  Kr(() => {
    h() ? (a.hideHover(), setTimeout(async () => {
      u_(a.map).then(Pe => {
        re(k, Pe, !0), re(E, URL.createObjectURL(x(k)), !0)
      }).finally(() => {
        a.showHover()
      })
    }, 500)) : x(E) && (URL.revokeObjectURL(x(E)), re(k, null), re(E, ""))
  });
  var b = YM(),
    s = P(b),
    F = B(P(s), 2),
    O = P(F);
  R0(O, {
    class: "size-5"
  });
  var G = B(O);
  I(F);
  var X = B(F, 2),
    Q = P(X);
  ya(Q);
  var W = B(Q, 2),
    de = P(W);
  let _e;
  de.__click = [GM, a, y];
  var Ae = P(de, !0);
  I(de), I(W), I(X);
  var xe = B(X, 2);
  {
    var Ie = Pe => {
      const De = ht(() => {
        var ae;
        return (ae = a.map) == null ? void 0 : ae.getCanvas()
      });
      var $e = XM(),
        tt = P($e),
        Ve = P(tt);
      qM(Ve, {
        class: "inline size-5"
      });
      var Re = B(Ve);
      I(tt);
      var Ue = B(tt, 2);
      {
        var Ce = ae => {
            var ke = WM();
            Ze(() => {
              nr(ke, "src", x(E)), nr(ke, "width", x(De).width), nr(ke, "height", x(De).height)
            }), Z(ae, ke)
          },
          We = ae => {
            var ke = HM();
            Ze(() => Bc(ke, `aspect-ratio: ${x(De).width/x(De).height}`)), Z(ae, ke)
          };
        Be(Ue, ae => {
          x(E) ? ae(Ce) : ae(We, !1)
        })
      }
      var Je = B(Ue, 2),
        Ge = P(Je);
      Ge.__click = [JM, k];
      var Ee = P(Ge);
      Ym(Ee, {
        class: "size-5"
      });
      var mt = B(Ee);
      I(Ge);
      var K = B(Ge, 2),
        ee = P(K);
      c0(ee, {
        class: "size-5"
      });
      var le = B(ee);
      I(K), I(Je), I($e), Ze((ae, ke, qe, lt) => {
        ce(Re, ` ${ae??""}`), ce(mt, ` ${ke??""}`), nr(K, "href", x(E)), nr(K, "download", `wplace_${qe??""}.png`), ce(le, ` ${lt??""}`)
      }, [() => $I(), () => hm(), () => $M(new Date).replaceAll(" ", "_").replaceAll(":", "-"), () => HI()]), Ni(2, $e, () => va, () => ({
        duration: 300
      })), Z(Pe, $e)
    };
    Be(xe, Pe => {
      h() && Pe(Ie)
    })
  }
  I(s), en(2), I(b), pi(b, () => Pe => {
    Kr(() => {
      h() ? Pe.show() : Pe.close()
    })
  }), Ze((Pe, De, $e, tt) => {
    ce(G, ` ${Pe??""}`), fp(Q, De), _e = Or(de, 1, "btn btn-primary", null, _e, $e), ce(Ae, tt)
  }, [() => oS(), () => a.url.toString(), () => ({
    "btn-success": x(y)
  }), () => x(y) ? e_() : hm()]), Zn("close", b, () => h(!1)), Z(d, b), Pr()
}
Ln(["click"]);
var QM = xr('<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>');

function eA(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = QM();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var tA = fe('<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>'),
  rA = fe('<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p> <p class="text-base-content/80 mt-0.5 text-sm"> <a class="link" href="/terms/code-of-conduct" target="_blank"> </a>.</p></div></div>');

function h_(d, a) {
  Ir(a, !1);
  const h = [k5(), S5(), E5(), D5(), F5(), N5(), q5()];
  Km();
  var y = rA(),
    k = P(y),
    E = P(k);
  eA(E, {
    class: "size-5"
  });
  var b = B(E, 2),
    s = P(b),
    F = B(s),
    O = P(F, !0);
  I(F), I(b), I(k);
  var G = B(k, 2),
    X = P(G);
  ai(X, 5, () => h, kp, (Ie, Pe) => {
    var De = tA(),
      $e = P(De, !0);
    I(De), Ze(() => ce($e, x(Pe))), Z(Ie, De)
  }), I(X);
  var Q = B(X, 2),
    W = P(Q, !0);
  I(Q);
  var de = B(Q, 2),
    _e = P(de),
    Ae = B(_e),
    xe = P(Ae, !0);
  I(Ae), en(), I(de), I(G), I(y), Ze((Ie, Pe, De, $e, tt) => {
    ce(s, `${Ie??""} `), ce(O, Pe), ce(W, De), ce(_e, `${$e??""} `), ce(xe, tt)
  }, [() => y5(), () => w5(), () => G5(), () => I4(), () => M4()]), Z(d, y), Pr()
}
var nA = (d, a) => {
    a(!1)
  },
  iA = fe('<dialog class="modal"><div class="modal-box sm:max-h-11/12"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex h-full flex-col gap-6"><h2 class="text-xl font-semibold">📑 Updated rules</h2> <section><!></section> <button class="btn btn-primary">Close</button></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function aA(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15);
  An(() => {
    const O = G => {
      G.key === "Escape" && h(!1)
    };
    return document.addEventListener("keydown", O), () => document.removeEventListener("keydown", O)
  });
  var y = iA(),
    k = P(y),
    E = B(P(k), 2),
    b = B(P(E), 2),
    s = P(b);
  h_(s, {}), I(b);
  var F = B(b, 2);
  F.__click = [nA, h], I(E), I(k), en(2), I(y), pi(y, () => O => {
    Kr(() => {
      h() ? O.show() : O.close()
    })
  }), Zn("close", y, () => h(!1)), Z(d, y), Pr()
}
Ln(["click"]);

function oA(d, a) {
  Ir(a, !1);
  let h = Tt(a, "map", 8),
    y = Tt(a, "season", 8),
    k = Tt(a, "eventName", 8);
  const E = Bi.seasons[y()].tileSize,
    b = Bi.seasons[y()].zoom,
    s = new Zs(E),
    F = `event-anchors-${k()}-src`,
    O = `event-anchors-${k()}-layer`;
  An(async () => {
    try {
      const Q = {
        type: "FeatureCollection",
        features: (await nn.getEventAnchors(k())).anchors.map(W => {
          const [de, _e] = s.pixelsToLatLon(W.globalX, W.globalY, b);
          return {
            type: "Feature",
            properties: {
              title: `${k()}`,
              tileX: W.tileX,
              tileY: W.tileY,
              pixelX: W.pixelX,
              pixelY: W.pixelY
            },
            geometry: {
              type: "Point",
              coordinates: [_e, de]
            }
          }
        })
      };
      h().getSource(F) ? h().getSource(F).setData(Q) : h().addSource(F, {
        type: "geojson",
        data: Q
      }), h().getLayer(O) || h().addLayer({
        id: O,
        type: "circle",
        source: F,
        paint: {
          "circle-radius": 5,
          "circle-color": "#ffa500",
          "circle-stroke-color": "#000",
          "circle-stroke-width": 1
        }
      }), h().on("click", O, W => {
        var _e, Ae, xe;
        const de = (xe = (Ae = (_e = W.features) == null ? void 0 : _e[0]) == null ? void 0 : Ae.geometry) == null ? void 0 : xe.coordinates;
        de && h().flyTo({
          center: {
            lng: de[0],
            lat: de[1]
          },
          zoom: b + 3
        })
      })
    } catch (G) {
      Ar.error((G == null ? void 0 : G.message) ?? "Erro ao carregar abóboras")
    }
  }), Tx(() => {
    h().getLayer(O) && h().removeLayer(O), h().getSource(F) && h().removeSource(F), h().off("click", O, () => {})
  }), Km(), Pr()
}
const Iv = "" + new URL("../assets/halloween-map.CECUvHOu.png", import.meta.url).href;
var sA = fe("<div><!></div>");

function Wa(d, a) {
  Ir(a, !0);
  let h = sr(a, ["$$slots", "$$events", "$$legacy", "children"]);
  var y = sA();
  lr(y, () => ({
    ...h,
    class: `bg-base-200/50 border-base-content/10 rounded-lg border p-4 ${a.class??""}`
  }));
  var k = P(y);
  Hn(k, () => a.children), I(y), Z(d, y), Pr()
}
var lA = xr('<svg><path d="M480-80q-75 0-140.5-28.5t-114-77q-48.5-48.5-77-114T120-440q0-75 28.5-140.5t77-114q48.5-48.5 114-77T480-800q75 0 140.5 28.5t114 77q48.5 48.5 77 114T840-440q0 75-28.5 140.5t-77 114q-48.5 48.5-114 77T480-80Zm0-360Zm112 168 56-56-128-128v-184h-80v216l152 152ZM224-866l56 56-170 170-56-56 170-170Zm512 0 170 170-56 56-170-170 56-56ZM480-160q117 0 198.5-81.5T760-440q0-117-81.5-198.5T480-720q-117 0-198.5 81.5T200-440q0 117 81.5 198.5T480-160Z"></path></svg>');

function Pv(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = lA();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var cA = xr('<svg><path d="M200-80q-33 0-56.5-23.5T120-160v-560q0-33 23.5-56.5T200-800h40v-80h80v80h320v-80h80v80h40q33 0 56.5 23.5T840-720v560q0 33-23.5 56.5T760-80H200Zm0-80h560v-400H200v400Zm0-480h560v-80H200v80Zm0 0v-80 80Z"></path></svg>');

function kv(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = cA();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var uA = xr('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm457-560 21-89-71-59 94-8 36-84 36 84 94 8-71 59 21 89-80-47-80 47ZM480-481Z"></path></svg>');

function Qd(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = uA();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var hA = xr('<svg><path d="M280-120v-80h160v-124q-49-11-87.5-41.5T296-442q-75-9-125.5-65.5T120-640v-40q0-33 23.5-56.5T200-760h80v-80h400v80h80q33 0 56.5 23.5T840-680v40q0 76-50.5 132.5T664-442q-18 46-56.5 76.5T520-324v124h160v80H280Zm0-408v-152h-80v40q0 38 22 68.5t58 43.5Zm200 128q50 0 85-35t35-85v-240H360v240q0 50 35 85t85 35Zm200-128q36-13 58-43.5t22-68.5v-40h-80v152Zm-200-52Z"></path></svg>');

function Mv(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = hA();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var dA = fe('<div class="bg-accent/10 rounded-lg p-2 max-sm:hidden"><!></div> <div><p class="text-base-content/80 text-sm font-semibold uppercase tracking-wide">Start</p> <p class="text-foreground text-base font-bold">Friday, Oct 31</p> <p class="text-base-content/80 text-xs">00:00 AM (UTC)</p></div>', 1),
  pA = fe('<div class="bg-warning/10 rounded-lg p-2 max-sm:hidden"><!></div> <div><p class="text-base-content/80 text-sm font-semibold uppercase tracking-wide">End</p> <p class="text-foreground text-base font-bold">Monday, Nov 3</p> <p class="text-base-content/80 text-xs">00:00 AM (UTC)</p></div>', 1),
  fA = fe(`<p class="text-base leading-relaxed">During this special Halloween event, <span class="text-primary font-bold">100 numbered pumpkins</span> will be scattered throughout the Wplace map — and be warned: they change their location every
					hour!</p>`),
  mA = fe('<h3 class="flex items-center gap-2 text-lg font-semibold"><img alt="Pumpkin head" class="pixelated inline size-7"/> <span class="mt-0.5">Your Progress</span></h3> <div class="tooltip w-full"><div class="relative mt-4 h-8"><progress class="progress progress-primary h-full w-full"></progress> <div class="text-base-content/80 center-absolute font absolute font-semibold"> </div></div></div>', 1),
  _A = fe('<img class="border-0" alt="Halloween map"/>'),
  gA = fe(`<div class="bg-primary/10 h-max w-max rounded-lg p-2 max-sm:hidden"><!></div> <div><h3 class="text-primary text-lg font-bold">Rewards</h3> <p>Earn <span class="text-primary font-bold">2,000 droplets</span> for every unique pumpkin
						you find!</p></div>`, 1),
  vA = fe('<div class="relative space-y-6"><div class="text-center"><div class="mb-2 flex items-center justify-center gap-2"><!> <div class="badge max-sm:badge-sm font-semibold">SPECIAL EVENT</div> <!></div> <h1 class="text-primary font-pixel flex items-center justify-center gap-3 text-3xl md:text-4xl"><img alt="Pumpkin head" class="pixelated inline size-10 animate-pulse sm:size-12"/> Pumpkin Hunt! <img alt="Pumpkin head" class="pixelated inline size-10 animate-pulse sm:size-12"/></h1> <p class="text-muted-foreground font-pixel text-lg md:text-xl">Halloween Event at Wplace</p></div></div> <div class="mt-6 grid grid-cols-2 gap-4"><!> <!></div> <!> <!> <section class="mt-6"><h3 class="text-lg font-semibold">Find the pumpkins</h3> <!></section> <!> <div class="text-base-content/80 mt-6 text-center text-sm">Search with the community where the pumpkins are hidden!</div> <div class="mx-auto mt-2 flex flex-col gap-4"><a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> Discord</a> <form method="dialog"><button class="btn btn-primary w-full">Close</button></form></div>', 1),
  yA = fe('<div class="bg-accent/10 rounded-lg p-2 max-sm:hidden"><!></div> <div><p class="text-base-content/80 text-sm font-semibold uppercase tracking-wide">Início</p> <p class="text-foreground text-base font-bold">Sexta, 31/10</p> <p class="text-base-content/80 text-xs">00:00 AM (UTC)</p></div>', 1),
  xA = fe('<div class="bg-warning/10 rounded-lg p-2 max-sm:hidden"><!></div> <div><p class="text-base-content/80 text-sm font-semibold uppercase tracking-wide">Fim</p> <p class="text-foreground text-base font-bold">Segunda, 03/10</p> <p class="text-base-content/80 text-xs">00:00 AM (UTC)</p></div>', 1),
  bA = fe('<p class="text-base leading-relaxed">Durante este evento especial de Halloween, <span class="text-primary font-bold">100 abóboras numeradas</span> serão espalhadas pelo mapa do Wplace — e atenção: elas mudam de lugar a cada hora!</p>'),
  wA = fe('<h3 class="flex items-center gap-2 text-lg font-semibold"><img alt="Pumpkin head" class="pixelated inline size-7"/> <span class="mt-0.5">Seu progresso</span></h3> <div class="tooltip w-full"><div class="relative mt-4 h-8"><progress class="progress progress-primary h-full w-full"></progress> <div class="text-base-content/80 center-absolute font absolute font-semibold"> </div></div></div>', 1),
  CA = fe('<img class="border-0" alt="Halloween map"/>'),
  TA = fe(`<div class="bg-primary/10 h-max w-max rounded-lg p-2 max-sm:hidden"><!></div> <div><h3 class="text-primary text-lg font-bold">Recompensas</h3> <p>Ganhe <span class="text-primary font-bold">2.000 droplets</span> para cada abóbora única
						encontrada!</p></div>`, 1),
  SA = fe('<div class="relative space-y-6"><div class="text-center"><div class="mb-2 flex items-center justify-center gap-2"><!> <div class="badge max-sm:badge-sm font-semibold">EVENTO ESPECIAL</div> <!></div> <h1 class="text-primary font-pixel flex items-center justify-center gap-3 text-3xl md:text-4xl"><img alt="Cabeça de abóbora" class="pixelated inline size-10 animate-pulse sm:size-12"/> Caça às Aboboras! <img alt="Cabeça de abóbora" class="pixelated inline size-10 animate-pulse sm:size-12"/></h1> <p class="text-muted-foreground font-pixel text-lg md:text-xl">Evento de Halloween no Wplace</p></div></div> <div class="mt-6 grid grid-cols-2 gap-4"><!> <!></div> <!> <!> <section class="mt-6"><h3 class="text-lg font-semibold">Encontre as aboboras</h3> <!></section> <!> <div class="text-base-content/80 mt-6 text-center text-sm">Procure com a comunidade onde as abóboras estão escondidas!</div> <div class="mx-auto mt-2 flex flex-col gap-4"><a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> Discord</a> <form method="dialog"><button class="btn btn-primary w-full">Fechar</button></form></div>', 1),
  IA = fe('<dialog class="modal"><div class="modal-box max-h-11/12 max-w-3xl max-sm:px-4"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2 z-10">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function PA(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15),
    y = rt(di([]));
  const k = 100;
  Kr(() => {
    h() && nn.getHalloweenPumpkinsClaimed().then(G => {
      G.sort((X, Q) => X - Q), re(y, G, !0)
    })
  });
  var E = IA(),
    b = P(E),
    s = B(P(b), 2);
  {
    var F = G => {
        var X = vA(),
          Q = pt(X),
          W = P(Q),
          de = P(W),
          _e = P(de);
        Qd(_e, {
          class: "text-primary size-5 animate-pulse sm:size-6"
        });
        var Ae = B(_e, 4);
        Qd(Ae, {
          class: "text-primary size-5 animate-pulse sm:size-6"
        }), I(de);
        var xe = B(de, 2),
          Ie = P(xe),
          Pe = B(Ie, 2);
        I(xe), en(2), I(W), I(Q);
        var De = B(Q, 2),
          $e = P(De);
        Wa($e, {
          class: "flex items-start gap-3",
          children: (K, ee) => {
            var le = dA(),
              ae = pt(le),
              ke = P(ae);
            kv(ke, {
              class: "text-accent size-5"
            }), I(ae), en(2), Z(K, le)
          },
          $$slots: {
            default: !0
          }
        });
        var tt = B($e, 2);
        Wa(tt, {
          class: "flex items-start gap-3",
          children: (K, ee) => {
            var le = pA(),
              ae = pt(le),
              ke = P(ae);
            Pv(ke, {
              class: "text-warning size-5"
            }), I(ae), en(2), Z(K, le)
          },
          $$slots: {
            default: !0
          }
        }), I(De);
        var Ve = B(De, 2);
        Wa(Ve, {
          class: "mt-4",
          children: (K, ee) => {
            var le = fA();
            Z(K, le)
          },
          $$slots: {
            default: !0
          }
        });
        var Re = B(Ve, 2);
        {
          var Ue = K => {
            Wa(K, {
              class: "mt-4",
              children: (ee, le) => {
                var ae = mA(),
                  ke = pt(ae),
                  qe = P(ke);
                en(2), I(ke);
                var lt = B(ke, 2),
                  ot = P(lt),
                  dt = P(ot);
                nr(dt, "max", k);
                var Pt = B(dt, 2),
                  Lt = P(Pt);
                I(Pt), I(ot), I(lt), Ze(He => {
                  nr(qe, "src", rs), nr(lt, "data-tip", He), fp(dt, x(y).length), ce(Lt, `${x(y).length??""}/100`)
                }, [() => x(y).length ? `Claimed: ${x(y).map(He=>`#${He}`).join(", ")}` : ""]), Z(ee, ae)
              },
              $$slots: {
                default: !0
              }
            })
          };
          Be(Re, K => {
            wt.data && K(Ue)
          })
        }
        var Ce = B(Re, 2),
          We = B(P(Ce), 2);
        Wa(We, {
          class: "mt-1.5",
          children: (K, ee) => {
            var le = _A();
            Ze(() => nr(le, "src", Iv)), Z(K, le)
          },
          $$slots: {
            default: !0
          }
        }), I(Ce);
        var Je = B(Ce, 2);
        Wa(Je, {
          class: "mt-4 flex gap-3",
          children: (K, ee) => {
            var le = gA(),
              ae = pt(le),
              ke = P(ae);
            Mv(ke, {
              class: "text-primary size-8"
            }), I(ae), en(2), Z(K, le)
          },
          $$slots: {
            default: !0
          }
        });
        var Ge = B(Je, 4),
          Ee = P(Ge),
          mt = P(Ee);
        Yu(mt, {
          class: "size-5"
        }), en(), I(Ee), en(2), I(Ge), Ze(() => {
          nr(Ie, "src", rs), nr(Pe, "src", rs)
        }), Z(G, X)
      },
      O = G => {
        var X = SA(),
          Q = pt(X),
          W = P(Q),
          de = P(W),
          _e = P(de);
        Qd(_e, {
          class: "text-primary size-5 animate-pulse sm:size-6"
        });
        var Ae = B(_e, 4);
        Qd(Ae, {
          class: "text-primary size-5 animate-pulse sm:size-6"
        }), I(de);
        var xe = B(de, 2),
          Ie = P(xe),
          Pe = B(Ie, 2);
        I(xe), en(2), I(W), I(Q);
        var De = B(Q, 2),
          $e = P(De);
        Wa($e, {
          class: "flex items-start gap-3",
          children: (K, ee) => {
            var le = yA(),
              ae = pt(le),
              ke = P(ae);
            kv(ke, {
              class: "text-accent size-5"
            }), I(ae), en(2), Z(K, le)
          },
          $$slots: {
            default: !0
          }
        });
        var tt = B($e, 2);
        Wa(tt, {
          class: "flex items-start gap-3",
          children: (K, ee) => {
            var le = xA(),
              ae = pt(le),
              ke = P(ae);
            Pv(ke, {
              class: "text-warning size-5"
            }), I(ae), en(2), Z(K, le)
          },
          $$slots: {
            default: !0
          }
        }), I(De);
        var Ve = B(De, 2);
        Wa(Ve, {
          class: "mt-4",
          children: (K, ee) => {
            var le = bA();
            Z(K, le)
          },
          $$slots: {
            default: !0
          }
        });
        var Re = B(Ve, 2);
        {
          var Ue = K => {
            Wa(K, {
              class: "mt-4",
              children: (ee, le) => {
                var ae = wA(),
                  ke = pt(ae),
                  qe = P(ke);
                en(2), I(ke);
                var lt = B(ke, 2),
                  ot = P(lt),
                  dt = P(ot);
                nr(dt, "max", k);
                var Pt = B(dt, 2),
                  Lt = P(Pt);
                I(Pt), I(ot), I(lt), Ze(He => {
                  nr(qe, "src", rs), nr(lt, "data-tip", He), fp(dt, x(y).length), ce(Lt, `${x(y).length??""}/100`)
                }, [() => x(y).length ? `Resgatadas: ${x(y).map(He=>`#${He}`).join(", ")}` : ""]), Z(ee, ae)
              },
              $$slots: {
                default: !0
              }
            })
          };
          Be(Re, K => {
            wt.data && K(Ue)
          })
        }
        var Ce = B(Re, 2),
          We = B(P(Ce), 2);
        Wa(We, {
          class: "mt-1.5",
          children: (K, ee) => {
            var le = CA();
            Ze(() => nr(le, "src", Iv)), Z(K, le)
          },
          $$slots: {
            default: !0
          }
        }), I(Ce);
        var Je = B(Ce, 2);
        Wa(Je, {
          class: "mt-4 flex gap-3",
          children: (K, ee) => {
            var le = TA(),
              ae = pt(le),
              ke = P(ae);
            Mv(ke, {
              class: "text-primary size-8"
            }), I(ae), en(2), Z(K, le)
          },
          $$slots: {
            default: !0
          }
        });
        var Ge = B(Je, 4),
          Ee = P(Ge),
          mt = P(Ee);
        Yu(mt, {
          class: "size-5"
        }), en(), I(Ee), en(2), I(Ge), Ze(() => {
          nr(Ie, "src", rs), nr(Pe, "src", rs)
        }), Z(G, X)
      };
    Be(s, G => {
      Fe() !== "pt" ? G(F) : G(O, !1)
    })
  }
  I(b), en(2), I(E), pi(E, () => G => {
    Kr(() => {
      h() ? G.showModal() : G.close()
    })
  }), Zn("close", E, () => h(!1)), Z(d, E), Pr()
}
var kA = () => {
    ri.url.searchParams.delete("new-user"), mp(ri.url.toString())
  },
  MA = fe('<dialog class="modal"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>');

function AA(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15);
  An(() => {
    const _e = Ae => {
      Ae.key === "Escape" && h(!1)
    };
    return document.addEventListener("keydown", _e), () => document.removeEventListener("keydown", _e)
  });
  var y = MA(),
    k = P(y),
    E = P(k),
    b = P(E),
    s = P(b),
    F = P(s, !0);
  I(s);
  var O = B(s, 2);
  g0(O, {
    hasText: !0,
    size: "medium"
  }), I(b), I(E);
  var G = B(E, 2),
    X = P(G);
  h_(X, {}), I(G);
  var Q = B(G, 2),
    W = P(Q);
  W.__click = [kA];
  var de = P(W, !0);
  I(W), I(Q), I(k), I(y), pi(y, () => _e => {
    Kr(() => {
      h() ? _e.show() : _e.close()
    })
  }), Ze((_e, Ae) => {
    ce(F, _e), ce(de, Ae)
  }, [() => _5(), () => J5()]), Zn("close", y, () => h(!1)), Z(d, y), Pr()
}
Ln(["click"]);

function EA() {
  const d = navigator.userAgent,
    a = navigator.vendor;
  return /Chrome/.test(d) && /Google Inc/.test(a) ? "Chrome" : /Safari/.test(d) && /Apple Computer/.test(a) ? "Safari" : /Firefox/.test(d) ? "Firefox" : /Edge/.test(d) ? "Edge" : /Opera|OPR/.test(d) ? "Opera" : "Unknown"
}
var zA = xr('<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>');

function LA(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = zA();
  lr(y, () => ({
    viewBox: "0 0 512 512",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...h
  })), Z(d, y)
}
var DA = xr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z"></path></svg>');

function vm(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = DA();
  lr(y, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var RA = xr('<svg><path d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>');

function BA(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = RA();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    preserveAspectRatio: "xMidYMid",
    viewBox: "0 0 260 260",
    ...h
  })), Z(d, y)
}
var FA = xr('<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>');

function vp(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = FA();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var OA = xr(`<svg><path d="M12.75 2c.39 0 .708.316.75.704a5.735 5.735 0 0 0 
  4.112 4.751c.257.077.523.127.801.149.394.028.713.35.713.744v2.289a.75.75 
  0 0 1-.826.746 8.89 8.89 0 0 1-3.546-1.239v6.43a5.465 5.465 0 
  1 1-5.465-5.465c.388 0 .765.042 1.128.122a.75.75 0 0 
  1 .593.732v2.289a.75.75 0 0 1-.979.715 1.549 1.549 0 0 
  0-.482-.077 1.962 1.962 0 1 0 1.962 1.962V2.75a.75.75 0 0 1 
  .75-.75h1.239Z"></path></svg>`);

function jA(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = OA();
  lr(y, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "Tiktok",
    ...h
  })), Z(d, y)
}
var NA = xr(`<svg><path d="M23.498 6.186a2.986 2.986 0 0 0-2.103-2.115C19.505 
    3.5 12 3.5 12 3.5s-7.505 0-9.395.571a2.986 2.986 0 0 0-2.103 
    2.115C0 8.082 0 12 0 12s0 3.918.502 5.814a2.986 2.986 0 0 0 
    2.103 2.115C4.495 20.5 12 20.5 12 20.5s7.505 0 9.395-.571a2.986 
    2.986 0 0 0 2.103-2.115C24 15.918 24 12 24 12s0-3.918-.502-5.814zM9.75 
    15.021v-6.042L15.5 12l-5.75 3.021z"></path></svg>`);

function ZA(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = NA();
  lr(y, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "YouTube",
    ...h
  })), Z(d, y)
}
var VA = fe(' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>', 1),
  qA = fe('<span class="link cursor-auto">chrome://settings/system</span>.', 1),
  UA = fe('<span class="link cursor-auto">edge://settings/system/manageSystem</span>.', 1),
  $A = fe(' <kbd class="kbd kbd-sm"> </kbd> <!>', 1),
  GA = fe('<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a href="https://discord.gg/wplacelive" target="_blank" class="text-nowrap"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank" class="text-nowrap"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank" class="text-nowrap"><!> <span class="link">Instagram</span></a> <span class="mx-0.5">|</span> <a href="https://www.youtube.com/@WplaceLive" target="_blank" class="text-nowrap"><!> <span class="link">Youtube</span></a> <span class="mx-0.5">|</span> <a href="https://www.tiktok.com/@wplace5" target="_blank" class="text-nowrap"><!> <span class="link">Tiktok</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm max-sm:pb-4"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span> · <a class="link" target="_blank"> </a> · <a class="link" target="_blank"> </a> · <a class="link" target="_blank"> </a> · <a class="link" href="https://forms.gle/tpDWwewuK5i9C52s8" target="_blank"> </a> · <a class="link" href="https://forms.gle/EVG7A1ZoSyJWAjX96" target="_blank"> </a> · <a class="link" href="https://forms.gle/uinGA5Gj4SpPYa2R6" target="_blank"> </a></section></div>'),
  WA = fe('<dialog class="modal"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function HA(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15);
  An(() => {
    const X = Q => {
      Q.key === "Escape" && h(!1)
    };
    return document.addEventListener("keydown", X), () => document.removeEventListener("keydown", X)
  });
  const y = EA();
  var k = WA(),
    E = P(k),
    b = B(P(E), 2);
  {
    var s = X => {
      var Q = GA(),
        W = P(Q),
        de = P(W);
      g0(de, {
        hasText: !0,
        size: "medium"
      });
      var _e = B(de, 2),
        Ae = P(_e),
        xe = B(Ae, 4);
      en(), I(_e);
      var Ie = B(_e, 2),
        Pe = P(Ie),
        De = P(Pe),
        $e = P(De);
      vm($e, {
        class: "text-base-content mr-0.5 inline size-4"
      }), en(2), I(De);
      var tt = B(De, 4),
        Ve = P(tt);
      LA(Ve, {
        class: "size-4.5 mr-0.5 inline"
      }), en(2), I(tt);
      var Re = B(tt, 4),
        Ue = P(Re);
      BA(Ue, {
        class: "mr-0.5 inline size-3.5"
      }), en(2), I(Re);
      var Ce = B(Re, 4),
        We = P(Ce);
      ZA(We, {
        class: "mr-0.5 inline size-3.5"
      }), en(2), I(Ce);
      var Je = B(Ce, 4),
        Ge = P(Je);
      jA(Ge, {
        class: "mr-0.5 inline size-3.5"
      }), en(2), I(Je), I(Pe), I(Ie), I(W);
      var Ee = B(W, 2),
        mt = P(Ee),
        K = P(mt, !0);
      I(mt);
      var ee = B(mt, 2);
      I(Ee);
      var le = B(Ee, 2),
        ae = P(le),
        ke = P(ae, !0);
      I(ae);
      var qe = B(ae, 2),
        lt = P(qe),
        ot = B(lt),
        dt = P(ot);
      vp(dt, {
        class: "size-5"
      }), I(ot);
      var Pt = B(ot);
      I(qe);
      var Lt = B(qe, 2),
        He = P(Lt),
        ut = B(He),
        gt = P(ut, !0);
      I(ut);
      var St = B(ut);
      I(Lt), I(le);
      var vt = B(le, 2),
        Ct = P(vt),
        At = P(Ct, !0);
      I(Ct);
      var Bt = B(Ct, 2),
        Vt = P(Bt);
      {
        var Ot = oe => {
            var me = VA(),
              Se = pt(me);
            en(), Ze(Oe => ce(Se, `${Oe??""}: `), [() => dP()]), Z(oe, me)
          },
          Dt = oe => {
            var me = $A(),
              Se = pt(me),
              Oe = B(Se),
              ze = P(Oe, !0);
            I(Oe);
            var Ke = B(Oe),
              _t = B(Ke);
            {
              var it = we => {
                  var Mt = qA();
                  en(), Z(we, Mt)
                },
                qt = we => {
                  var Mt = or(),
                    Ut = pt(Mt);
                  {
                    var jt = fr => {
                      var Ur = UA();
                      en(), Z(fr, Ur)
                    };
                    Be(Ut, fr => {
                      y === "Edge" && fr(jt)
                    }, !0)
                  }
                  Z(we, Mt)
                };
              Be(_t, we => {
                y === "Chrome" ? we(it) : we(qt, !1)
              })
            }
            Ze((we, Mt, Ut) => {
              ce(Se, `${we??""} `), ce(ze, Mt), ce(Ke, ` ${Ut??""} `)
            }, [() => nP(), () => oP(), () => cP()]), Z(oe, me)
          };
        Be(Vt, oe => {
          y !== "Chrome" && y !== "Edge" ? oe(Ot) : oe(Dt, !1)
        })
      }
      I(Bt), I(vt);
      var Rt = B(vt, 2),
        Zt = P(Rt);
      h_(Zt, {}), I(Rt);
      var Ft = B(Rt, 4),
        cr = B(P(Ft), 2),
        ur = P(cr, !0);
      I(cr);
      var Er = B(cr, 2),
        dr = P(Er, !0);
      I(Er);
      var pr = B(Er, 2),
        vr = P(pr, !0);
      I(pr);
      var Vr = B(pr, 2),
        qr = P(Vr, !0);
      I(Vr);
      var ue = B(Vr, 2),
        V = P(ue, !0);
      I(ue);
      var U = B(ue, 2),
        Y = P(U, !0);
      I(U), I(Ft), I(Q), Ze((oe, me, Se, Oe, ze, Ke, _t, it, qt, we, Mt, Ut, jt, fr, Ur, Dr, jr) => {
        ce(Ae, `${oe??""} `), ce(xe, ` ©
						${me??""} `), ce(K, Se), nr(ee, "src", Zi.language === "pt" ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9" : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"), ce(ke, Oe), ce(lt, `${ze??""} `), ce(Pt, ` ${Ke??""}`), ce(He, `${_t??""} `), ce(gt, it), ce(St, ` ${qt??""}`), ce(At, we), nr(cr, "href", `${ri.url.origin??""}/terms/terms-of-service`), ce(ur, Mt), nr(Er, "href", `${ri.url.origin??""}/terms/privacy`), ce(dr, Ut), nr(pr, "href", jt), ce(vr, fr), ce(qr, Ur), ce(V, Dr), ce(Y, jr)
      }, [() => y2(), () => w2(), () => S2(), () => k2(), () => E2(), () => D2(), () => F2(), () => N2(), () => q2(), () => eP(), () => vP(), () => bP(), () => f0(ri.url.origin), () => P0(), () => A0(), () => x4(), () => C4()]), Ni(2, Q, () => va, () => ({
        duration: 300
      })), Z(X, Q)
    };
    Be(b, X => {
      h() && X(s)
    })
  }
  I(E);
  var F = B(E, 2),
    O = P(F),
    G = P(O, !0);
  I(O), I(F), I(k), pi(k, () => X => {
    Kr(() => {
      h() ? X.show() : X.close()
    })
  }), Ze(X => ce(G, X), [() => cs()]), Zn("close", k, () => h(!1)), Z(d, k), Pr()
}

function JA(d) {
  return typeof d == "function"
}

function Uh(d) {
  return d !== null && typeof d == "object"
}
const XA = ["string", "number", "bigint", "boolean"];

function ym(d) {
  return d == null || XA.includes(typeof d) ? !0 : Array.isArray(d) ? d.every(a => ym(a)) : typeof d == "object" ? Object.getPrototypeOf(d) === Object.prototype : !1
}
const Ku = Symbol("box"),
  d_ = Symbol("is-writable");

function YA(d) {
  return Uh(d) && Ku in d
}

function KA(d) {
  return Sr.isBox(d) && d_ in d
}

function Sr(d) {
  let a = rt(di(d));
  return {
    [Ku]: !0,
    [d_]: !0,
    get current() {
      return x(a)
    },
    set current(h) {
      re(a, h, !0)
    }
  }
}

function QA(d, a) {
  const h = ht(d);
  return a ? {
    [Ku]: !0,
    [d_]: !0,
    get current() {
      return x(h)
    },
    set current(y) {
      a(y)
    }
  } : {
    [Ku]: !0,
    get current() {
      return d()
    }
  }
}

function e8(d) {
  return Sr.isBox(d) ? d : JA(d) ? Sr.with(d) : Sr(d)
}

function t8(d) {
  return Object.entries(d).reduce((a, [h, y]) => Sr.isBox(y) ? (Sr.isWritableBox(y) ? Object.defineProperty(a, h, {
    get() {
      return y.current
    },
    set(k) {
      y.current = k
    }
  }) : Object.defineProperty(a, h, {
    get() {
      return y.current
    }
  }), a) : Object.assign(a, {
    [h]: y
  }), {})
}

function r8(d) {
  return Sr.isWritableBox(d) ? {
    [Ku]: !0,
    get current() {
      return d.current
    }
  } : d
}
Sr.from = e8;
Sr.with = QA;
Sr.flatten = t8;
Sr.readonly = r8;
Sr.isBox = YA;
Sr.isWritableBox = KA;

function n8(...d) {
  return function(a) {
    var h;
    for (const y of d)
      if (y) {
        if (a.defaultPrevented) return;
        typeof y == "function" ? y.call(this, a) : (h = y.current) == null || h.call(this, a)
      }
  }
}
var yc = {},
  Kf, Av;

function i8() {
  if (Av) return Kf;
  Av = 1;
  var d = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
    a = /\n/g,
    h = /^\s*/,
    y = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
    k = /^:\s*/,
    E = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
    b = /^[;\s]*/,
    s = /^\s+|\s+$/g,
    F = `
`,
    O = "/",
    G = "*",
    X = "",
    Q = "comment",
    W = "declaration";
  Kf = function(_e, Ae) {
    if (typeof _e != "string") throw new TypeError("First argument must be a string");
    if (!_e) return [];
    Ae = Ae || {};
    var xe = 1,
      Ie = 1;

    function Pe(Ge) {
      var Ee = Ge.match(a);
      Ee && (xe += Ee.length);
      var mt = Ge.lastIndexOf(F);
      Ie = ~mt ? Ge.length - mt : Ie + Ge.length
    }

    function De() {
      var Ge = {
        line: xe,
        column: Ie
      };
      return function(Ee) {
        return Ee.position = new $e(Ge), Re(), Ee
      }
    }

    function $e(Ge) {
      this.start = Ge, this.end = {
        line: xe,
        column: Ie
      }, this.source = Ae.source
    }
    $e.prototype.content = _e;

    function tt(Ge) {
      var Ee = new Error(Ae.source + ":" + xe + ":" + Ie + ": " + Ge);
      if (Ee.reason = Ge, Ee.filename = Ae.source, Ee.line = xe, Ee.column = Ie, Ee.source = _e, !Ae.silent) throw Ee
    }

    function Ve(Ge) {
      var Ee = Ge.exec(_e);
      if (Ee) {
        var mt = Ee[0];
        return Pe(mt), _e = _e.slice(mt.length), Ee
      }
    }

    function Re() {
      Ve(h)
    }

    function Ue(Ge) {
      var Ee;
      for (Ge = Ge || []; Ee = Ce();) Ee !== !1 && Ge.push(Ee);
      return Ge
    }

    function Ce() {
      var Ge = De();
      if (!(O != _e.charAt(0) || G != _e.charAt(1))) {
        for (var Ee = 2; X != _e.charAt(Ee) && (G != _e.charAt(Ee) || O != _e.charAt(Ee + 1));) ++Ee;
        if (Ee += 2, X === _e.charAt(Ee - 1)) return tt("End of comment missing");
        var mt = _e.slice(2, Ee - 2);
        return Ie += 2, Pe(mt), _e = _e.slice(Ee), Ie += 2, Ge({
          type: Q,
          comment: mt
        })
      }
    }

    function We() {
      var Ge = De(),
        Ee = Ve(y);
      if (Ee) {
        if (Ce(), !Ve(k)) return tt("property missing ':'");
        var mt = Ve(E),
          K = Ge({
            type: W,
            property: de(Ee[0].replace(d, X)),
            value: mt ? de(mt[0].replace(d, X)) : X
          });
        return Ve(b), K
      }
    }

    function Je() {
      var Ge = [];
      Ue(Ge);
      for (var Ee; Ee = We();) Ee !== !1 && (Ge.push(Ee), Ue(Ge));
      return Ge
    }
    return Re(), Je()
  };

  function de(_e) {
    return _e ? _e.replace(s, X) : X
  }
  return Kf
}
var Ev;

function a8() {
  if (Ev) return yc;
  Ev = 1;
  var d = yc && yc.__importDefault || function(y) {
    return y && y.__esModule ? y : {
      default: y
    }
  };
  Object.defineProperty(yc, "__esModule", {
    value: !0
  }), yc.default = h;
  var a = d(i8());

  function h(y, k) {
    var E = null;
    if (!y || typeof y != "string") return E;
    var b = (0, a.default)(y),
      s = typeof k == "function";
    return b.forEach(function(F) {
      if (F.type === "declaration") {
        var O = F.property,
          G = F.value;
        s ? k(O, G, F) : G && (E = E || {}, E[O] = G)
      }
    }), E
  }
  return yc
}
var o8 = a8();
const zv = s_(o8),
  s8 = zv.default || zv,
  l8 = /\d/,
  c8 = ["-", "_", "/", "."];

function u8(d = "") {
  if (!l8.test(d)) return d !== d.toLowerCase()
}

function h8(d) {
  const a = [];
  let h = "",
    y, k;
  for (const E of d) {
    const b = c8.includes(E);
    if (b === !0) {
      a.push(h), h = "", y = void 0;
      continue
    }
    const s = u8(E);
    if (k === !1) {
      if (y === !1 && s === !0) {
        a.push(h), h = E, y = s;
        continue
      }
      if (y === !0 && s === !1 && h.length > 1) {
        const F = h.at(-1);
        a.push(h.slice(0, Math.max(0, h.length - 1))), h = F + E, y = s;
        continue
      }
    }
    h += E, y = s, k = b
  }
  return a.push(h), a
}

function B0(d) {
  return d ? h8(d).map(a => p8(a)).join("") : ""
}

function d8(d) {
  return f8(B0(d || ""))
}

function p8(d) {
  return d ? d[0].toUpperCase() + d.slice(1) : ""
}

function f8(d) {
  return d ? d[0].toLowerCase() + d.slice(1) : ""
}

function ep(d) {
  if (!d) return {};
  const a = {};

  function h(y, k) {
    if (y.startsWith("-moz-") || y.startsWith("-webkit-") || y.startsWith("-ms-") || y.startsWith("-o-")) {
      a[B0(y)] = k;
      return
    }
    if (y.startsWith("--")) {
      a[y] = k;
      return
    }
    a[d8(y)] = k
  }
  return s8(d, h), a
}

function m8(...d) {
  return (...a) => {
    for (const h of d) typeof h == "function" && h(...a)
  }
}

function _8(d, a) {
  const h = RegExp(d, "g");
  return y => {
    if (typeof y != "string") throw new TypeError(`expected an argument of type string, but got ${typeof y}`);
    return y.match(h) ? y.replace(h, a) : y
  }
}
const g8 = _8(/[A-Z]/, d => `-${d.toLowerCase()}`);

function v8(d) {
  if (!d || typeof d != "object" || Array.isArray(d)) throw new TypeError(`expected an argument of type object, but got ${typeof d}`);
  return Object.keys(d).map(a => `${g8(a)}: ${d[a]};`).join(`
`)
}

function F0(d = {}) {
  return v8(d).replace(`
`, " ")
}
const O0 = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
F0(O0);
const y8 = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"],
  x8 = new Set(y8);

function b8(d) {
  return x8.has(d)
}

function Na(...d) {
  const a = {
    ...d[0]
  };
  for (let h = 1; h < d.length; h++) {
    const y = d[h];
    if (y) {
      for (const k of Object.keys(y)) {
        const E = a[k],
          b = y[k],
          s = typeof E == "function",
          F = typeof b == "function";
        if (s && b8(k)) {
          const O = E,
            G = b;
          a[k] = n8(O, G)
        } else if (s && F) a[k] = m8(E, b);
        else if (k === "class") {
          const O = ym(E),
            G = ym(b);
          O && G ? a[k] = Wu(E, b) : O ? a[k] = Wu(E) : G && (a[k] = Wu(b))
        } else if (k === "style") {
          const O = typeof E == "object",
            G = typeof b == "object",
            X = typeof E == "string",
            Q = typeof b == "string";
          if (O && G) a[k] = {
            ...E,
            ...b
          };
          else if (O && Q) {
            const W = ep(b);
            a[k] = {
              ...E,
              ...W
            }
          } else if (X && G) {
            const W = ep(E);
            a[k] = {
              ...W,
              ...b
            }
          } else if (X && Q) {
            const W = ep(E),
              de = ep(b);
            a[k] = {
              ...W,
              ...de
            }
          } else O ? a[k] = E : G ? a[k] = b : X ? a[k] = E : Q && (a[k] = b)
        } else a[k] = b !== void 0 ? b : E
      }
      for (const k of Object.getOwnPropertySymbols(y)) {
        const E = a[k],
          b = y[k];
        a[k] = b !== void 0 ? b : E
      }
    }
  }
  return typeof a.style == "object" && (a.style = F0(a.style).replaceAll(`
`, " ")), a.hidden !== !0 && (a.hidden = void 0, delete a.hidden), a.disabled !== !0 && (a.disabled = void 0, delete a.disabled), a
}
const w8 = typeof window < "u" ? window : void 0;

function C8(d) {
  let a = d.activeElement;
  for (; a != null && a.shadowRoot;) {
    const h = a.shadowRoot.activeElement;
    if (h === a) break;
    a = h
  }
  return a
}
var Mc, sh;
class T8 {
  constructor(a = {}) {
    Lr(this, Mc);
    Lr(this, sh);
    const {
      window: h = w8,
      document: y = h == null ? void 0 : h.document
    } = a;
    h !== void 0 && (ta(this, Mc, y), ta(this, sh, a0(k => {
      const E = Hu(h, "focusin", k),
        b = Hu(h, "focusout", k);
      return () => {
        E(), b()
      }
    })))
  }
  get current() {
    var a;
    return (a = Ye(this, sh)) == null || a.call(this), Ye(this, Mc) ? C8(Ye(this, Mc)) : null
  }
}
Mc = new WeakMap, sh = new WeakMap;
new T8;
var lh, as;
class p_ {
  constructor(a) {
    Lr(this, lh);
    Lr(this, as);
    ta(this, lh, a), ta(this, as, Symbol(a))
  }
  get key() {
    return Ye(this, as)
  }
  exists() {
    return Lx(Ye(this, as))
  }
  get() {
    const a = mv(Ye(this, as));
    if (a === void 0) throw new Error(`Context "${Ye(this,lh)}" not found`);
    return a
  }
  getOr(a) {
    const h = mv(Ye(this, as));
    return h === void 0 ? a : h
  }
  set(a) {
    return Dx(Ye(this, as), a)
  }
}
lh = new WeakMap, as = new WeakMap;

function S8(d, a) {
  switch (d) {
    case "post":
      Kr(a);
      break;
    case "pre":
      $m(a);
      break
  }
}

function j0(d, a, h, y = {}) {
  const {
    lazy: k = !1
  } = y;
  let E = !k,
    b = Array.isArray(d) ? [] : void 0;
  S8(a, () => {
    const s = Array.isArray(d) ? d.map(O => O()) : d();
    if (!E) {
      E = !0, b = s;
      return
    }
    const F = bl(() => h(s, b));
    return b = s, F
  })
}

function js(d, a, h) {
  j0(d, "post", a, h)
}

function I8(d, a, h) {
  j0(d, "pre", a, h)
}
js.pre = I8;
var Ac;
class P8 {
  constructor(a, h) {
    Lr(this, Ac, rt(void 0));
    h !== void 0 && re(Ye(this, Ac), h, !0), js(() => a(), (y, k) => {
      re(Ye(this, Ac), k, !0)
    })
  }
  get current() {
    return x(Ye(this, Ac))
  }
}
Ac = new WeakMap;

function k8(d, a) {
  return setTimeout(a, d)
}

function xc(d) {
  r0().then(d)
}
const M8 = 1,
  A8 = 9,
  E8 = 11;

function z8(d) {
  return Uh(d) && d.nodeType === M8 && typeof d.nodeName == "string"
}

function N0(d) {
  return Uh(d) && d.nodeType === A8
}

function L8(d) {
  var a;
  return Uh(d) && ((a = d.constructor) == null ? void 0 : a.name) === "VisualViewport"
}

function D8(d) {
  return Uh(d) && d.nodeType !== void 0
}

function R8(d) {
  return D8(d) && d.nodeType === E8 && "host" in d
}

function B8(d) {
  return N0(d) ? d : L8(d) ? d.document : (d == null ? void 0 : d.ownerDocument) ?? document
}

function Z0(d) {
  var a;
  return R8(d) ? Z0(d.host) : N0(d) ? d.defaultView ?? window : z8(d) ? ((a = d.ownerDocument) == null ? void 0 : a.defaultView) ?? window : window
}

function F8(d) {
  let a = d.activeElement;
  for (; a != null && a.shadowRoot;) {
    const h = a.shadowRoot.activeElement;
    if (h === a) break;
    a = h
  }
  return a
}
var ch;
class O8 {
  constructor(a) {
    Tr(this, "element");
    Lr(this, ch, ht(() => this.element.current ? this.element.current.getRootNode() ?? document : document));
    Tr(this, "getDocument", () => B8(this.root));
    Tr(this, "getWindow", () => this.getDocument().defaultView ?? window);
    Tr(this, "getActiveElement", () => F8(this.root));
    Tr(this, "isActiveElement", a => a === this.getActiveElement());
    Tr(this, "querySelector", a => this.root ? this.root.querySelector(a) : null);
    Tr(this, "querySelectorAll", a => this.root ? this.root.querySelectorAll(a) : []);
    Tr(this, "setTimeout", (a, h) => this.getWindow().setTimeout(a, h));
    Tr(this, "clearTimeout", a => this.getWindow().clearTimeout(a));
    typeof a == "function" ? this.element = Sr.with(a) : this.element = a
  }
  get root() {
    return x(Ye(this, ch))
  }
  set root(a) {
    re(Ye(this, ch), a)
  }
  getElementById(a) {
    return this.root.getElementById(a)
  }
}
ch = new WeakMap;

function Ya(d, a) {
  return {
    [kb()]: h => Sr.isBox(d) ? (d.current = h, bl(() => a == null ? void 0 : a(h)), () => {
      "isConnected" in h && h.isConnected || (d.current = null, a == null || a(null))
    }) : (d(h), bl(() => a == null ? void 0 : a(h)), () => {
      "isConnected" in h && h.isConnected || (d(null), a == null || a(null))
    })
  }
}

function j8(d) {
  return d ? "true" : "false"
}

function N8(d) {
  return d ? "true" : "false"
}

function Z8(d) {
  return d ? "" : void 0
}

function V8(d) {
  return d ? "true" : "false"
}

function q8(d) {
  return d ? "" : void 0
}

function U8(d) {
  return d ? !0 : void 0
}
var Ec, uh;
class $8 {
  constructor(a) {
    Lr(this, Ec);
    Lr(this, uh);
    Tr(this, "attrs");
    ta(this, Ec, a.getVariant ? a.getVariant() : null), ta(this, uh, Ye(this, Ec) ? `data-${Ye(this,Ec)}-` : `data-${a.component}-`), this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(a.parts.map(h => [h, this.getAttr(h)]))
  }
  getAttr(a, h) {
    return h ? `data-${h}-${a}` : `${Ye(this,uh)}${a}`
  }
  selector(a, h) {
    return `[${this.getAttr(a,h)}]`
  }
}
Ec = new WeakMap, uh = new WeakMap;

function V0(d) {
  const a = new $8(d);
  return {
    ...a.attrs,
    selector: a.selector,
    getAttr: a.getAttr
  }
}
const G8 = "ArrowDown",
  W8 = "ArrowLeft",
  H8 = "ArrowRight",
  J8 = "ArrowUp",
  X8 = "End",
  Y8 = "Enter",
  K8 = "Home",
  Q8 = "p",
  eE = "n",
  tE = "j",
  rE = "k",
  nE = "h",
  iE = "l";

function Qu() {}

function Ka(d, a) {
  return `bits-${d}`
}

function aE(d) {
  if (!d) return null;
  for (const a of d.childNodes)
    if (a.nodeType !== Node.COMMENT_NODE) return a;
  return null
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = {
  current: 0
});

function oE(d = "bits") {
  return globalThis.bitsIdCounter.current++, `${d}-${globalThis.bitsIdCounter.current}`
}

function sE(d, a) {
  let h = d.nextElementSibling;
  for (; h;) {
    if (h.matches(a)) return h;
    h = h.nextElementSibling
  }
}

function lE(d, a) {
  let h = d.previousElementSibling;
  for (; h;) {
    if (h.matches(a)) return h;
    h = h.previousElementSibling
  }
}

function q0(d) {
  if (typeof CSS < "u" && typeof CSS.escape == "function") return CSS.escape(d);
  const a = d.length;
  let h = -1,
    y, k = "";
  const E = d.charCodeAt(0);
  if (a === 1 && E === 45) return "\\" + d;
  for (; ++h < a;) {
    if (y = d.charCodeAt(h), y === 0) {
      k += "�";
      continue
    }
    if (y >= 1 && y <= 31 || y === 127 || h === 0 && y >= 48 && y <= 57 || h === 1 && y >= 48 && y <= 57 && E === 45) {
      k += "\\" + y.toString(16) + " ";
      continue
    }
    if (y >= 128 || y === 45 || y === 95 || y >= 48 && y <= 57 || y >= 65 && y <= 90 || y >= 97 && y <= 122) {
      k += d.charAt(h);
      continue
    }
    k += "\\" + d.charAt(h)
  }
  return k
}
const vl = "data-value",
  xa = V0({
    component: "command",
    parts: ["root", "list", "input", "separator", "loading", "empty", "group", "group-items", "group-heading", "item", "viewport", "input-label"]
  }),
  bc = xa.selector("group"),
  Qf = xa.selector("group-items"),
  Lv = xa.selector("group-heading"),
  U0 = xa.selector("item"),
  em = `${xa.selector("item")}:not([aria-disabled="true"])`,
  Sl = new p_("Command.Root"),
  cE = new p_("Command.List"),
  eh = new p_("Command.Group"),
  Dv = {
    search: "",
    value: "",
    filtered: {
      count: 0,
      items: new Map,
      groups: new Set
    }
  };
var zc, hh, dh, ph, fh, mh, _h, gh, yr, $0, cp, bm, up, hp, dp, Bs, G0, W0, wm, qu, Cm, Tm, H0, Uu, Sm, Im, J0, $u, Gu, vh;
const b_ = class b_ {
  constructor(a) {
    Lr(this, yr);
    Tr(this, "opts");
    Tr(this, "attachment");
    Lr(this, zc, !1);
    Lr(this, hh, !0);
    Tr(this, "sortAfterTick", !1);
    Tr(this, "sortAndFilterAfterTick", !1);
    Tr(this, "allItems", new Set);
    Tr(this, "allGroups", new Map);
    Tr(this, "allIds", new Map);
    Lr(this, dh, rt(0));
    Lr(this, ph, rt(null));
    Lr(this, fh, rt(null));
    Lr(this, mh, rt(null));
    Lr(this, _h, rt(Dv));
    Lr(this, gh, rt(di(Dv)));
    Lr(this, vh, ht(() => ({
      id: this.opts.id.current,
      role: "application",
      [xa.root]: "",
      tabindex: -1,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = a, this.attachment = Ya(this.opts.ref);
    const h = {
      ...this._commandState,
      value: this.opts.value.current ?? ""
    };
    this._commandState = h, this.commandState = h, this.onkeydown = this.onkeydown.bind(this)
  }
  static create(a) {
    return Sl.set(new b_(a))
  }
  get key() {
    return x(Ye(this, dh))
  }
  set key(a) {
    re(Ye(this, dh), a, !0)
  }
  get viewportNode() {
    return x(Ye(this, ph))
  }
  set viewportNode(a) {
    re(Ye(this, ph), a, !0)
  }
  get inputNode() {
    return x(Ye(this, fh))
  }
  set inputNode(a) {
    re(Ye(this, fh), a, !0)
  }
  get labelNode() {
    return x(Ye(this, mh))
  }
  set labelNode(a) {
    re(Ye(this, mh), a, !0)
  }
  get commandState() {
    return x(Ye(this, _h))
  }
  set commandState(a) {
    re(Ye(this, _h), a)
  }
  get _commandState() {
    return x(Ye(this, gh))
  }
  set _commandState(a) {
    re(Ye(this, gh), a, !0)
  }
  setState(a, h, y) {
    Object.is(this._commandState[a], h) || (this._commandState[a] = h, a === "search" ? (Nr(this, yr, dp).call(this), Nr(this, yr, up).call(this)) : a === "value" && (y || Nr(this, yr, G0).call(this)), Nr(this, yr, cp).call(this))
  }
  setValue(a, h) {
    a !== this.opts.value.current && a === "" && xc(() => {
      this.key++
    }), this.setState("value", a, h), this.opts.value.current = a
  }
  getValidItems() {
    const a = this.opts.ref.current;
    return a ? Array.from(a.querySelectorAll(em)).filter(y => !!y) : []
  }
  getVisibleItems() {
    const a = this.opts.ref.current;
    return a ? Array.from(a.querySelectorAll(U0)).filter(y => !!y) : []
  }
  get itemsGrid() {
    var s, F, O, G;
    if (!this.isGrid) return [];
    const a = this.opts.columns.current ?? 1,
      h = this.getVisibleItems(),
      y = [
        []
      ];
    let k = (s = h[0]) == null ? void 0 : s.getAttribute("data-group"),
      E = 0,
      b = 0;
    for (let X = 0; X < h.length; X++) {
      const Q = h[X],
        W = Q == null ? void 0 : Q.getAttribute("data-group");
      k !== W ? (k = W, E = 1, b++, y.push([{
        index: X,
        firstRowOfGroup: !0,
        ref: Q
      }])) : (E++, E > a && (b++, E = 1, y.push([])), (G = y[b]) == null || G.push({
        index: X,
        firstRowOfGroup: ((O = (F = y[b]) == null ? void 0 : F[0]) == null ? void 0 : O.firstRowOfGroup) ?? X === 0,
        ref: Q
      }))
    }
    return y
  }
  updateSelectedToIndex(a) {
    const h = this.getValidItems()[a];
    h && this.setValue(h.getAttribute(vl) ?? "")
  }
  updateSelectedByItem(a) {
    const h = Nr(this, yr, Bs).call(this),
      y = this.getValidItems(),
      k = y.findIndex(b => b === h);
    let E = y[k + a];
    this.opts.loop.current && (E = k + a < 0 ? y[y.length - 1] : k + a === y.length ? y[0] : y[k + a]), E && this.setValue(E.getAttribute(vl) ?? "")
  }
  updateSelectedByGroup(a) {
    const h = Nr(this, yr, Bs).call(this);
    let y = h == null ? void 0 : h.closest(bc),
      k;
    for (; y && !k;) y = a > 0 ? sE(y, bc) : lE(y, bc), k = y == null ? void 0 : y.querySelector(em);
    k ? this.setValue(k.getAttribute(vl) ?? "") : this.updateSelectedByItem(a)
  }
  registerValue(a, h) {
    var y;
    return a && a === ((y = this.allIds.get(a)) == null ? void 0 : y.value) || this.allIds.set(a, {
      value: a,
      keywords: h
    }), this._commandState.filtered.items.set(a, Nr(this, yr, bm).call(this, a, h)), this.sortAfterTick || (this.sortAfterTick = !0, xc(() => {
      Nr(this, yr, up).call(this), this.sortAfterTick = !1
    })), () => {
      this.allIds.delete(a)
    }
  }
  registerItem(a, h) {
    return this.allItems.add(a), h && (this.allGroups.has(h) ? this.allGroups.get(h).add(a) : this.allGroups.set(h, new Set([a]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, xc(() => {
      Nr(this, yr, dp).call(this), Nr(this, yr, up).call(this), this.sortAndFilterAfterTick = !1
    })), Nr(this, yr, cp).call(this), () => {
      const y = Nr(this, yr, Bs).call(this);
      this.allIds.delete(a), this.allItems.delete(a), this.commandState.filtered.items.delete(a), Nr(this, yr, dp).call(this), (y == null ? void 0 : y.getAttribute("id")) === a && Nr(this, yr, hp).call(this), Nr(this, yr, cp).call(this)
    }
  }
  registerGroup(a) {
    return this.allGroups.has(a) || this.allGroups.set(a, new Set), () => {
      this.allIds.delete(a), this.allGroups.delete(a)
    }
  }
  get isGrid() {
    return this.opts.columns.current !== null
  }
  onkeydown(a) {
    const h = this.opts.vimBindings.current && a.ctrlKey;
    switch (a.key) {
      case eE:
      case tE: {
        h && (this.isGrid ? Nr(this, yr, Cm).call(this, a) : Nr(this, yr, qu).call(this, a));
        break
      }
      case iE: {
        h && this.isGrid && Nr(this, yr, qu).call(this, a);
        break
      }
      case G8:
        this.isGrid ? Nr(this, yr, Cm).call(this, a) : Nr(this, yr, qu).call(this, a);
        break;
      case H8:
        if (!this.isGrid) break;
        Nr(this, yr, qu).call(this, a);
        break;
      case Q8:
      case rE: {
        h && (this.isGrid ? Nr(this, yr, Im).call(this, a) : Nr(this, yr, Gu).call(this, a));
        break
      }
      case nE: {
        h && this.isGrid && Nr(this, yr, Gu).call(this, a);
        break
      }
      case J8:
        this.isGrid ? Nr(this, yr, Im).call(this, a) : Nr(this, yr, Gu).call(this, a);
        break;
      case W8:
        if (!this.isGrid) break;
        Nr(this, yr, Gu).call(this, a);
        break;
      case K8:
        a.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case X8:
        a.preventDefault(), Nr(this, yr, wm).call(this);
        break;
      case Y8:
        if (!a.isComposing && a.keyCode !== 229) {
          a.preventDefault();
          const y = Nr(this, yr, Bs).call(this);
          y && (y == null || y.click())
        }
    }
  }
  get props() {
    return x(Ye(this, vh))
  }
  set props(a) {
    re(Ye(this, vh), a)
  }
};
zc = new WeakMap, hh = new WeakMap, dh = new WeakMap, ph = new WeakMap, fh = new WeakMap, mh = new WeakMap, _h = new WeakMap, gh = new WeakMap, yr = new WeakSet, $0 = function() {
  return Pb(this._commandState)
}, cp = function() {
  Ye(this, zc) || (ta(this, zc, !0), xc(() => {
    var y, k;
    ta(this, zc, !1);
    const a = Nr(this, yr, $0).call(this);
    !Object.is(this.commandState, a) && (this.commandState = a, (k = (y = this.opts.onStateChange) == null ? void 0 : y.current) == null || k.call(y, a))
  }))
}, bm = function(a, h) {
  const y = this.opts.filter.current ?? K0;
  return a ? y(a, this._commandState.search, h) : 0
}, up = function() {
  var b;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    Nr(this, yr, hp).call(this);
    return
  }
  const a = this._commandState.filtered.items,
    h = [];
  for (const s of this._commandState.filtered.groups) {
    const F = this.allGroups.get(s);
    let O = 0;
    if (!F) {
      h.push([s, O]);
      continue
    }
    for (const G of F) {
      const X = a.get(G);
      O = Math.max(X ?? 0, O)
    }
    h.push([s, O])
  }
  const y = this.viewportNode,
    k = this.getValidItems().sort((s, F) => {
      const O = s.getAttribute("data-value"),
        G = F.getAttribute("data-value"),
        X = a.get(O) ?? 0;
      return (a.get(G) ?? 0) - X
    });
  for (const s of k) {
    const F = s.closest(Qf);
    if (F) {
      const O = s.parentElement === F ? s : s.closest(`${Qf} > *`);
      O && F.appendChild(O)
    } else {
      const O = s.parentElement === y ? s : s.closest(`${Qf} > *`);
      O && (y == null || y.appendChild(O))
    }
  }
  const E = h.sort((s, F) => F[1] - s[1]);
  for (const s of E) {
    const F = y == null ? void 0 : y.querySelector(`${bc}[${vl}="${q0(s[0])}"]`);
    (b = F == null ? void 0 : F.parentElement) == null || b.appendChild(F)
  }
  Nr(this, yr, hp).call(this)
}, hp = function() {
  xc(() => {
    const a = this.getValidItems().find(k => k.getAttribute("aria-disabled") !== "true"),
      h = a == null ? void 0 : a.getAttribute(vl),
      y = Ye(this, hh) && this.opts.disableInitialScroll.current;
    this.setValue(h ?? "", y), ta(this, hh, !1)
  })
}, dp = function() {
  var h, y;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    this._commandState.filtered.count = this.allItems.size;
    return
  }
  this._commandState.filtered.groups = new Set;
  let a = 0;
  for (const k of this.allItems) {
    const E = ((h = this.allIds.get(k)) == null ? void 0 : h.value) ?? "",
      b = ((y = this.allIds.get(k)) == null ? void 0 : y.keywords) ?? [],
      s = Nr(this, yr, bm).call(this, E, b);
    this._commandState.filtered.items.set(k, s), s > 0 && a++
  }
  for (const [k, E] of this.allGroups)
    for (const b of E) {
      const s = this._commandState.filtered.items.get(b);
      if (s && s > 0) {
        this._commandState.filtered.groups.add(k);
        break
      }
    }
  this._commandState.filtered.count = a
}, Bs = function() {
  const a = this.opts.ref.current;
  if (!a) return;
  const h = a.querySelector(`${em}[data-selected]`);
  if (h) return h
}, G0 = function() {
  xc(() => {
    var y, k, E, b, s;
    const a = Nr(this, yr, Bs).call(this);
    if (!a) return;
    const h = (y = a.parentElement) == null ? void 0 : y.parentElement;
    if (h) {
      if (this.isGrid) {
        const F = Nr(this, yr, W0).call(this, a);
        if (a.scrollIntoView({
            block: "nearest"
          }), F) {
          const O = (k = a == null ? void 0 : a.closest(bc)) == null ? void 0 : k.querySelector(Lv);
          O == null || O.scrollIntoView({
            block: "nearest"
          });
          return
        }
      } else {
        const F = aE(h);
        if (F && ((E = F.dataset) == null ? void 0 : E.value) === ((b = a.dataset) == null ? void 0 : b.value)) {
          const O = (s = a == null ? void 0 : a.closest(bc)) == null ? void 0 : s.querySelector(Lv);
          O == null || O.scrollIntoView({
            block: "nearest"
          });
          return
        }
      }
      a.scrollIntoView({
        block: "nearest"
      })
    }
  })
}, W0 = function(a) {
  const h = this.itemsGrid;
  if (h.length === 0) return !1;
  for (let y = 0; y < h.length; y++) {
    const k = h[y];
    if (k !== void 0)
      for (let E = 0; E < k.length; E++) {
        const b = k[E];
        if (!(b === void 0 || b.ref !== a)) return b.firstRowOfGroup
      }
  }
  return !1
}, wm = function() {
  return this.updateSelectedToIndex(this.getValidItems().length - 1)
}, qu = function(a) {
  a.preventDefault(), a.metaKey ? Nr(this, yr, wm).call(this) : a.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1)
}, Cm = function(a) {
  this.opts.columns.current !== null && (a.preventDefault(), a.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(Nr(this, yr, H0).call(this, a)))
}, Tm = function(a, h) {
  if (h.length === 0) return null;
  for (let y = 0; y < h.length; y++) {
    const k = h[y];
    if (k !== void 0)
      for (let E = 0; E < k.length; E++) {
        const b = k[E];
        if (!(b === void 0 || b.ref !== a)) return {
          columnIndex: E,
          rowIndex: y
        }
      }
  }
  return null
}, H0 = function(a) {
  const h = this.itemsGrid,
    y = Nr(this, yr, Bs).call(this);
  if (!y) return 0;
  const k = Nr(this, yr, Tm).call(this, y, h);
  if (!k) return 0;
  let E = null;
  const b = a.altKey ? 1 : 0;
  if (a.altKey && k.rowIndex === h.length - 2 && !this.opts.loop.current) E = Nr(this, yr, Uu).call(this, {
    start: h.length - 1,
    end: h.length,
    expectedColumnIndex: k.columnIndex,
    grid: h
  });
  else if (k.rowIndex === h.length - 1) {
    if (!this.opts.loop.current) return 0;
    E = Nr(this, yr, Uu).call(this, {
      start: 0 + b,
      end: k.rowIndex,
      expectedColumnIndex: k.columnIndex,
      grid: h
    })
  } else E = Nr(this, yr, Uu).call(this, {
    start: k.rowIndex + 1 + b,
    end: h.length,
    expectedColumnIndex: k.columnIndex,
    grid: h
  }), E === null && this.opts.loop.current && (E = Nr(this, yr, Uu).call(this, {
    start: 0,
    end: k.rowIndex,
    expectedColumnIndex: k.columnIndex,
    grid: h
  }));
  return Nr(this, yr, Sm).call(this, y, E)
}, Uu = function({
  start: a,
  end: h,
  grid: y,
  expectedColumnIndex: k
}) {
  var b;
  let E = null;
  for (let s = a; s < h; s++) {
    const F = y[s];
    if (E = ((b = F[k]) == null ? void 0 : b.ref) ?? null, E !== null && tp(E)) {
      E = null;
      continue
    }
    if (E === null)
      for (let O = F.length - 1; O >= 0; O--) {
        const G = F[F.length - 1];
        if (!(G === void 0 || tp(G.ref))) {
          E = G.ref;
          break
        }
      }
    break
  }
  return E
}, Sm = function(a, h) {
  if (h === null) return 0;
  const y = this.getValidItems(),
    k = y.findIndex(b => b === a);
  return y.findIndex(b => b === h) - k
}, Im = function(a) {
  this.opts.columns.current !== null && (a.preventDefault(), a.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(Nr(this, yr, J0).call(this, a)))
}, J0 = function(a) {
  const h = this.itemsGrid,
    y = Nr(this, yr, Bs).call(this);
  if (y === void 0) return 0;
  const k = Nr(this, yr, Tm).call(this, y, h);
  if (k === null) return 0;
  let E = null;
  const b = a.altKey ? 1 : 0;
  if (a.altKey && k.rowIndex === 1 && this.opts.loop.current === !1) E = Nr(this, yr, $u).call(this, {
    start: 0,
    end: 0,
    expectedColumnIndex: k.columnIndex,
    grid: h
  });
  else if (k.rowIndex === 0) {
    if (this.opts.loop.current === !1) return 0;
    E = Nr(this, yr, $u).call(this, {
      start: h.length - 1 - b,
      end: k.rowIndex + 1,
      expectedColumnIndex: k.columnIndex,
      grid: h
    })
  } else E = Nr(this, yr, $u).call(this, {
    start: k.rowIndex - 1 - b,
    end: 0,
    expectedColumnIndex: k.columnIndex,
    grid: h
  }), E === null && this.opts.loop.current && (E = Nr(this, yr, $u).call(this, {
    start: h.length - 1,
    end: k.rowIndex + 1,
    expectedColumnIndex: k.columnIndex,
    grid: h
  }));
  return Nr(this, yr, Sm).call(this, y, E)
}, $u = function({
  start: a,
  end: h,
  grid: y,
  expectedColumnIndex: k
}) {
  var b;
  let E = null;
  for (let s = a; s >= h; s--) {
    const F = y[s];
    if (F !== void 0) {
      if (E = ((b = F[k]) == null ? void 0 : b.ref) ?? null, E !== null && tp(E)) {
        E = null;
        continue
      }
      if (E === null)
        for (let O = F.length - 1; O >= 0; O--) {
          const G = F[F.length - 1];
          if (!(G === void 0 || tp(G.ref))) {
            E = G.ref;
            break
          }
        }
      break
    }
  }
  return E
}, Gu = function(a) {
  a.preventDefault(), a.metaKey ? this.updateSelectedToIndex(0) : a.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1)
}, vh = new WeakMap;
let xm = b_;

function tp(d) {
  return d.getAttribute("aria-disabled") === "true"
}
var yh, xh, bh;
const w_ = class w_ {
  constructor(a, h) {
    Tr(this, "opts");
    Tr(this, "root");
    Tr(this, "attachment");
    Lr(this, yh, ht(() => this.root._commandState.filtered.count === 0 && Ye(this, xh) === !1 || this.opts.forceMount.current));
    Lr(this, xh, !0);
    Lr(this, bh, ht(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [xa.empty]: "",
      ...this.attachment
    })));
    this.opts = a, this.root = h, this.attachment = Ya(this.opts.ref), $m(() => {
      ta(this, xh, !1)
    })
  }
  static create(a) {
    return new w_(a, Sl.get())
  }
  get shouldRender() {
    return x(Ye(this, yh))
  }
  set shouldRender(a) {
    re(Ye(this, yh), a)
  }
  get props() {
    return x(Ye(this, bh))
  }
  set props(a) {
    re(Ye(this, bh), a)
  }
};
yh = new WeakMap, xh = new WeakMap, bh = new WeakMap;
let Pm = w_;
var wh, Ch, Th, Sh;
const C_ = class C_ {
  constructor(a, h) {
    Tr(this, "opts");
    Tr(this, "root");
    Tr(this, "attachment");
    Lr(this, wh, ht(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue)));
    Lr(this, Ch, rt(null));
    Lr(this, Th, rt(""));
    Lr(this, Sh, ht(() => ({
      id: this.opts.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : !0,
      "data-value": this.trueValue,
      [xa.group]: "",
      ...this.attachment
    })));
    this.opts = a, this.root = h, this.attachment = Ya(this.opts.ref), this.trueValue = a.value.current ?? a.id.current, js(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), Kr(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)))
  }
  static create(a) {
    return eh.set(new C_(a, Sl.get()))
  }
  get shouldRender() {
    return x(Ye(this, wh))
  }
  set shouldRender(a) {
    re(Ye(this, wh), a)
  }
  get headingNode() {
    return x(Ye(this, Ch))
  }
  set headingNode(a) {
    re(Ye(this, Ch), a, !0)
  }
  get trueValue() {
    return x(Ye(this, Th))
  }
  set trueValue(a) {
    re(Ye(this, Th), a, !0)
  }
  get props() {
    return x(Ye(this, Sh))
  }
  set props(a) {
    re(Ye(this, Sh), a)
  }
};
wh = new WeakMap, Ch = new WeakMap, Th = new WeakMap, Sh = new WeakMap;
let km = C_;
var Ih;
const T_ = class T_ {
  constructor(a, h) {
    Tr(this, "opts");
    Tr(this, "group");
    Tr(this, "attachment");
    Lr(this, Ih, ht(() => ({
      id: this.opts.id.current,
      [xa["group-heading"]]: "",
      ...this.attachment
    })));
    this.opts = a, this.group = h, this.attachment = Ya(this.opts.ref, y => this.group.headingNode = y)
  }
  static create(a) {
    return new T_(a, eh.get())
  }
  get props() {
    return x(Ye(this, Ih))
  }
  set props(a) {
    re(Ye(this, Ih), a)
  }
};
Ih = new WeakMap;
let Mm = T_;
var Ph;
const S_ = class S_ {
  constructor(a, h) {
    Tr(this, "opts");
    Tr(this, "group");
    Tr(this, "attachment");
    Lr(this, Ph, ht(() => {
      var a;
      return {
        id: this.opts.id.current,
        role: "group",
        [xa["group-items"]]: "",
        "aria-labelledby": ((a = this.group.headingNode) == null ? void 0 : a.id) ?? void 0,
        ...this.attachment
      }
    }));
    this.opts = a, this.group = h, this.attachment = Ya(this.opts.ref)
  }
  static create(a) {
    return new S_(a, eh.get())
  }
  get props() {
    return x(Ye(this, Ph))
  }
  set props(a) {
    re(Ye(this, Ph), a)
  }
};
Ph = new WeakMap;
let Am = S_;
var bp, kh;
const I_ = class I_ {
  constructor(a, h) {
    Tr(this, "opts");
    Tr(this, "root");
    Tr(this, "attachment");
    Lr(this, bp, ht(() => {
      var h;
      const a = (h = this.root.viewportNode) == null ? void 0 : h.querySelector(`${U0}[${vl}="${q0(this.root.opts.value.current)}"]`);
      if (a != null) return a.getAttribute("id") ?? void 0
    }));
    Lr(this, kh, ht(() => {
      var a, h;
      return {
        id: this.opts.id.current,
        type: "text",
        [xa.input]: "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": N8(!0),
        "aria-controls": ((a = this.root.viewportNode) == null ? void 0 : a.id) ?? void 0,
        "aria-labelledby": ((h = this.root.labelNode) == null ? void 0 : h.id) ?? void 0,
        "aria-activedescendant": x(Ye(this, bp)),
        ...this.attachment
      }
    }));
    this.opts = a, this.root = h, this.attachment = Ya(this.opts.ref, y => this.root.inputNode = y), js(() => this.opts.ref.current, () => {
      const y = this.opts.ref.current;
      y && this.opts.autofocus.current && k8(10, () => y.focus())
    }), js(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current)
    })
  }
  static create(a) {
    return new I_(a, Sl.get())
  }
  get props() {
    return x(Ye(this, kh))
  }
  set props(a) {
    re(Ye(this, kh), a)
  }
};
bp = new WeakMap, kh = new WeakMap;
let Em = I_;
var Fs, wp, Mh, Ah, Eh, Tl, X0, Lm, zh;
const P_ = class P_ {
  constructor(a, h) {
    Lr(this, Tl);
    Tr(this, "opts");
    Tr(this, "root");
    Tr(this, "attachment");
    Lr(this, Fs, null);
    Lr(this, wp, ht(() => {
      var a;
      return this.opts.forceMount.current || ((a = Ye(this, Fs)) == null ? void 0 : a.opts.forceMount.current) === !0
    }));
    Lr(this, Mh, ht(() => {
      if (this.opts.ref.current, x(Ye(this, wp)) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search) return !0;
      const a = this.root.commandState.filtered.items.get(this.trueValue);
      return a === void 0 ? !1 : a > 0
    }));
    Lr(this, Ah, ht(() => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
    Lr(this, Eh, rt(""));
    Lr(this, zh, ht(() => {
      var a;
      return {
        id: this.opts.id.current,
        "aria-disabled": j8(this.opts.disabled.current),
        "aria-selected": V8(this.isSelected),
        "data-disabled": Z8(this.opts.disabled.current),
        "data-selected": q8(this.isSelected),
        "data-value": this.trueValue,
        "data-group": (a = Ye(this, Fs)) == null ? void 0 : a.trueValue,
        [xa.item]: "",
        role: "option",
        onpointermove: this.onpointermove,
        onclick: this.onclick,
        ...this.attachment
      }
    }));
    this.opts = a, this.root = h, ta(this, Fs, eh.getOr(null)), this.trueValue = a.value.current, this.attachment = Ya(this.opts.ref), js([() => this.trueValue, () => {
      var y;
      return (y = Ye(this, Fs)) == null ? void 0 : y.trueValue
    }, () => this.opts.forceMount.current], () => {
      var y;
      if (!this.opts.forceMount.current) return this.root.registerItem(this.trueValue, (y = Ye(this, Fs)) == null ? void 0 : y.trueValue)
    }), js([() => this.opts.value.current, () => this.opts.ref.current], () => {
      var y, k;
      !this.opts.value.current && ((y = this.opts.ref.current) != null && y.textContent) && (this.trueValue = this.opts.ref.current.textContent.trim()), this.root.registerValue(this.trueValue, a.keywords.current.map(E => E.trim())), (k = this.opts.ref.current) == null || k.setAttribute(vl, this.trueValue)
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this)
  }
  static create(a) {
    const h = eh.getOr(null);
    return new P_({
      ...a,
      group: h
    }, Sl.get())
  }
  get shouldRender() {
    return x(Ye(this, Mh))
  }
  set shouldRender(a) {
    re(Ye(this, Mh), a)
  }
  get isSelected() {
    return x(Ye(this, Ah))
  }
  set isSelected(a) {
    re(Ye(this, Ah), a)
  }
  get trueValue() {
    return x(Ye(this, Eh))
  }
  set trueValue(a) {
    re(Ye(this, Eh), a, !0)
  }
  onpointermove(a) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || Nr(this, Tl, Lm).call(this)
  }
  onclick(a) {
    this.opts.disabled.current || Nr(this, Tl, X0).call(this)
  }
  get props() {
    return x(Ye(this, zh))
  }
  set props(a) {
    re(Ye(this, zh), a)
  }
};
Fs = new WeakMap, wp = new WeakMap, Mh = new WeakMap, Ah = new WeakMap, Eh = new WeakMap, Tl = new WeakSet, X0 = function() {
  var a;
  this.opts.disabled.current || (Nr(this, Tl, Lm).call(this), (a = this.opts.onSelect) == null || a.current())
}, Lm = function() {
  this.opts.disabled.current || this.root.setValue(this.trueValue, !0)
}, zh = new WeakMap;
let zm = P_;
var Lh;
const k_ = class k_ {
  constructor(a, h) {
    Tr(this, "opts");
    Tr(this, "root");
    Tr(this, "attachment");
    Lr(this, Lh, ht(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-label": this.opts.ariaLabel.current,
      [xa.list]: "",
      ...this.attachment
    })));
    this.opts = a, this.root = h, this.attachment = Ya(this.opts.ref)
  }
  static create(a) {
    return cE.set(new k_(a, Sl.get()))
  }
  get props() {
    return x(Ye(this, Lh))
  }
  set props(a) {
    re(Ye(this, Lh), a)
  }
};
Lh = new WeakMap;
let Dm = k_;
var Dh;
const M_ = class M_ {
  constructor(a, h) {
    Tr(this, "opts");
    Tr(this, "root");
    Tr(this, "attachment");
    Lr(this, Dh, ht(() => {
      var a;
      return {
        id: this.opts.id.current,
        [xa["input-label"]]: "",
        for: (a = this.opts.for) == null ? void 0 : a.current,
        style: O0,
        ...this.attachment
      }
    }));
    this.opts = a, this.root = h, this.attachment = Ya(this.opts.ref, y => this.root.labelNode = y)
  }
  static create(a) {
    return new M_(a, Sl.get())
  }
  get props() {
    return x(Ye(this, Dh))
  }
  set props(a) {
    re(Ye(this, Dh), a)
  }
};
Dh = new WeakMap;
let Rm = M_;
var uE = fe("<label><!></label>");

function hE(d, a) {
  const h = mo();
  Ir(a, !0);
  let y = Tt(a, "id", 19, () => Ka(h)),
    k = Tt(a, "ref", 15, null),
    E = sr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
  const b = Rm.create({
      id: Sr.with(() => y()),
      ref: Sr.with(() => k(), G => k(G))
    }),
    s = ht(() => Na(E, b.props));
  var F = uE();
  lr(F, () => ({
    ...x(s)
  }));
  var O = P(F);
  Hn(O, () => a.children ?? ra), I(F), Z(d, F), Pr()
}
var dE = fe("<!> <!>", 1),
  pE = fe("<div><!> <!></div>");

function fE(d, a) {
  const h = mo();
  Ir(a, !0);
  const y = Je => {
    hE(Je, {
      children: (Ge, Ee) => {
        en();
        var mt = Ii();
        Ze(() => ce(mt, Q())), Z(Ge, mt)
      },
      $$slots: {
        default: !0
      }
    })
  };
  let k = Tt(a, "id", 19, () => Ka(h)),
    E = Tt(a, "ref", 15, null),
    b = Tt(a, "value", 15, ""),
    s = Tt(a, "onValueChange", 3, Qu),
    F = Tt(a, "onStateChange", 3, Qu),
    O = Tt(a, "loop", 3, !1),
    G = Tt(a, "shouldFilter", 3, !0),
    X = Tt(a, "filter", 3, K0),
    Q = Tt(a, "label", 3, ""),
    W = Tt(a, "vimBindings", 3, !0),
    de = Tt(a, "disablePointerSelection", 3, !1),
    _e = Tt(a, "disableInitialScroll", 3, !1),
    Ae = Tt(a, "columns", 3, null),
    xe = sr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "onValueChange", "onStateChange", "loop", "shouldFilter", "filter", "label", "vimBindings", "disablePointerSelection", "disableInitialScroll", "columns", "children", "child"]);
  const Ie = xm.create({
      id: Sr.with(() => k()),
      ref: Sr.with(() => E(), Je => E(Je)),
      filter: Sr.with(() => X()),
      shouldFilter: Sr.with(() => G()),
      loop: Sr.with(() => O()),
      value: Sr.with(() => b(), Je => {
        b() !== Je && (b(Je), s()(Je))
      }),
      vimBindings: Sr.with(() => W()),
      disablePointerSelection: Sr.with(() => de()),
      disableInitialScroll: Sr.with(() => _e()),
      onStateChange: Sr.with(() => F()),
      columns: Sr.with(() => Ae())
    }),
    Pe = Je => Ie.updateSelectedToIndex(Je),
    De = Je => Ie.updateSelectedByGroup(Je),
    $e = Je => Ie.updateSelectedByItem(Je),
    tt = () => Ie.getValidItems(),
    Ve = ht(() => Na(xe, Ie.props));
  var Re = or(),
    Ue = pt(Re);
  {
    var Ce = Je => {
        var Ge = dE(),
          Ee = pt(Ge);
        y(Ee);
        var mt = B(Ee, 2);
        Hn(mt, () => a.child, () => ({
          props: x(Ve)
        })), Z(Je, Ge)
      },
      We = Je => {
        var Ge = pE();
        lr(Ge, () => ({
          ...x(Ve)
        }));
        var Ee = P(Ge);
        y(Ee);
        var mt = B(Ee, 2);
        Hn(mt, () => a.children ?? ra), I(Ge), Z(Je, Ge)
      };
    Be(Ue, Je => {
      a.child ? Je(Ce) : Je(We, !1)
    })
  }
  return Z(d, Re), Pr({
    updateSelectedToIndex: Pe,
    updateSelectedByGroup: De,
    updateSelectedByItem: $e,
    getValidItems: tt
  })
}
var mE = fe("<div><!></div>");

function _E(d, a) {
  const h = mo();
  Ir(a, !0);
  let y = Tt(a, "id", 19, () => Ka(h)),
    k = Tt(a, "ref", 15, null),
    E = Tt(a, "forceMount", 3, !1),
    b = sr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child", "forceMount"]);
  const s = Pm.create({
      id: Sr.with(() => y()),
      ref: Sr.with(() => k(), Q => k(Q)),
      forceMount: Sr.with(() => E())
    }),
    F = ht(() => Na(s.props, b));
  var O = or(),
    G = pt(O);
  {
    var X = Q => {
      var W = or(),
        de = pt(W);
      {
        var _e = xe => {
            var Ie = or(),
              Pe = pt(Ie);
            Hn(Pe, () => a.child, () => ({
              props: x(F)
            })), Z(xe, Ie)
          },
          Ae = xe => {
            var Ie = mE();
            lr(Ie, () => ({
              ...x(F)
            }));
            var Pe = P(Ie);
            Hn(Pe, () => a.children ?? ra), I(Ie), Z(xe, Ie)
          };
        Be(de, xe => {
          a.child ? xe(_e) : xe(Ae, !1)
        })
      }
      Z(Q, W)
    };
    Be(G, Q => {
      s.shouldRender && Q(X)
    })
  }
  Z(d, O), Pr()
}
var gE = fe("<div><!></div>");

function vE(d, a) {
  const h = mo();
  Ir(a, !0);
  let y = Tt(a, "id", 19, () => Ka(h)),
    k = Tt(a, "ref", 15, null),
    E = Tt(a, "value", 3, ""),
    b = Tt(a, "forceMount", 3, !1),
    s = sr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "forceMount", "children", "child"]);
  const F = km.create({
      id: Sr.with(() => y()),
      ref: Sr.with(() => k(), de => k(de)),
      forceMount: Sr.with(() => b()),
      value: Sr.with(() => E())
    }),
    O = ht(() => Na(s, F.props));
  var G = or(),
    X = pt(G);
  {
    var Q = de => {
        var _e = or(),
          Ae = pt(_e);
        Hn(Ae, () => a.child, () => ({
          props: x(O)
        })), Z(de, _e)
      },
      W = de => {
        var _e = gE();
        lr(_e, () => ({
          ...x(O)
        }));
        var Ae = P(_e);
        Hn(Ae, () => a.children ?? ra), I(_e), Z(de, _e)
      };
    Be(X, de => {
      a.child ? de(Q) : de(W, !1)
    })
  }
  Z(d, G), Pr()
}
var yE = fe("<div><!></div>");

function xE(d, a) {
  const h = mo();
  Ir(a, !0);
  let y = Tt(a, "id", 19, () => Ka(h)),
    k = Tt(a, "ref", 15, null),
    E = sr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const b = Mm.create({
      id: Sr.with(() => y()),
      ref: Sr.with(() => k(), Q => k(Q))
    }),
    s = ht(() => Na(E, b.props));
  var F = or(),
    O = pt(F);
  {
    var G = Q => {
        var W = or(),
          de = pt(W);
        Hn(de, () => a.child, () => ({
          props: x(s)
        })), Z(Q, W)
      },
      X = Q => {
        var W = yE();
        lr(W, () => ({
          ...x(s)
        }));
        var de = P(W);
        Hn(de, () => a.children ?? ra), I(W), Z(Q, W)
      };
    Be(O, Q => {
      a.child ? Q(G) : Q(X, !1)
    })
  }
  Z(d, F), Pr()
}
var bE = fe("<div><!></div>"),
  wE = fe('<div style="display: contents;"><!></div>');

function CE(d, a) {
  const h = mo();
  Ir(a, !0);
  let y = Tt(a, "id", 19, () => Ka(h)),
    k = Tt(a, "ref", 15, null),
    E = sr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const b = Am.create({
      id: Sr.with(() => y()),
      ref: Sr.with(() => k(), Q => k(Q))
    }),
    s = ht(() => Na(E, b.props));
  var F = wE(),
    O = P(F);
  {
    var G = Q => {
        var W = or(),
          de = pt(W);
        Hn(de, () => a.child, () => ({
          props: x(s)
        })), Z(Q, W)
      },
      X = Q => {
        var W = bE();
        lr(W, () => ({
          ...x(s)
        }));
        var de = P(W);
        Hn(de, () => a.children ?? ra), I(W), Z(Q, W)
      };
    Be(O, Q => {
      a.child ? Q(G) : Q(X, !1)
    })
  }
  I(F), Z(d, F), Pr()
}
var TE = fe("<input/>");

function SE(d, a) {
  const h = mo();
  Ir(a, !0);
  let y = Tt(a, "value", 15, ""),
    k = Tt(a, "autofocus", 3, !1),
    E = Tt(a, "id", 19, () => Ka(h)),
    b = Tt(a, "ref", 15, null),
    s = sr(a, ["$$slots", "$$events", "$$legacy", "value", "autofocus", "id", "ref", "child"]);
  const F = Em.create({
      id: Sr.with(() => E()),
      ref: Sr.with(() => b(), de => b(de)),
      value: Sr.with(() => y(), de => {
        y(de)
      }),
      autofocus: Sr.with(() => k() ?? !1)
    }),
    O = ht(() => Na(s, F.props));
  var G = or(),
    X = pt(G);
  {
    var Q = de => {
        var _e = or(),
          Ae = pt(_e);
        Hn(Ae, () => a.child, () => ({
          props: x(O)
        })), Z(de, _e)
      },
      W = de => {
        var _e = TE();
        ya(_e), lr(_e, () => ({
          ...x(O)
        })), Mp(_e, y), Z(de, _e)
      };
    Be(X, de => {
      a.child ? de(Q) : de(W, !1)
    })
  }
  Z(d, G), Pr()
}
var IE = fe("<div><!></div>"),
  PE = fe('<div style="display: contents;" data-item-wrapper=""><!></div>');

function kE(d, a) {
  const h = mo();
  Ir(a, !0);
  let y = Tt(a, "id", 19, () => Ka(h)),
    k = Tt(a, "ref", 15, null),
    E = Tt(a, "value", 3, ""),
    b = Tt(a, "disabled", 3, !1),
    s = Tt(a, "onSelect", 3, Qu),
    F = Tt(a, "forceMount", 3, !1),
    O = Tt(a, "keywords", 19, () => []),
    G = sr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "disabled", "children", "child", "onSelect", "forceMount", "keywords"]);
  const X = zm.create({
      id: Sr.with(() => y()),
      ref: Sr.with(() => k(), _e => k(_e)),
      value: Sr.with(() => E()),
      disabled: Sr.with(() => b()),
      onSelect: Sr.with(() => s()),
      forceMount: Sr.with(() => F()),
      keywords: Sr.with(() => O())
    }),
    Q = ht(() => Na(G, X.props));
  var W = or(),
    de = pt(W);
  Ju(de, () => X.root.key, _e => {
    var Ae = PE(),
      xe = P(Ae);
    {
      var Ie = Pe => {
        var De = or(),
          $e = pt(De);
        {
          var tt = Re => {
              var Ue = or(),
                Ce = pt(Ue);
              Hn(Ce, () => a.child, () => ({
                props: x(Q)
              })), Z(Re, Ue)
            },
            Ve = Re => {
              var Ue = IE();
              lr(Ue, () => ({
                ...x(Q)
              }));
              var Ce = P(Ue);
              Hn(Ce, () => a.children ?? ra), I(Ue), Z(Re, Ue)
            };
          Be($e, Re => {
            a.child ? Re(tt) : Re(Ve, !1)
          })
        }
        Z(Pe, De)
      };
      Be(xe, Pe => {
        X.shouldRender && Pe(Ie)
      })
    }
    I(Ae), Ze(() => nr(Ae, "data-value", X.trueValue)), Z(_e, Ae)
  }), Z(d, W), Pr()
}
var ME = fe("<div><!></div>");

function AE(d, a) {
  const h = mo();
  Ir(a, !0);
  let y = Tt(a, "id", 19, () => Ka(h)),
    k = Tt(a, "ref", 15, null),
    E = sr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "aria-label"]);
  const b = Dm.create({
      id: Sr.with(() => y()),
      ref: Sr.with(() => k(), G => k(G)),
      ariaLabel: Sr.with(() => a["aria-label"] ?? "Suggestions...")
    }),
    s = ht(() => Na(E, b.props));
  var F = or(),
    O = pt(F);
  Ju(O, () => b.root._commandState.search === "", G => {
    var X = or(),
      Q = pt(X);
    {
      var W = _e => {
          var Ae = or(),
            xe = pt(Ae);
          Hn(xe, () => a.child, () => ({
            props: x(s)
          })), Z(_e, Ae)
        },
        de = _e => {
          var Ae = ME();
          lr(Ae, () => ({
            ...x(s)
          }));
          var xe = P(Ae);
          Hn(xe, () => a.children ?? ra), I(Ae), Z(_e, Ae)
        };
      Be(Q, _e => {
        a.child ? _e(W) : _e(de, !1)
      })
    }
    Z(G, X)
  }), Z(d, F), Pr()
}
const Rv = 1,
  EE = .9,
  zE = .8,
  LE = .17,
  tm = .1,
  rm = .999,
  DE = .9999,
  RE = .99,
  BE = /[\\/_+.#"@[({&]/,
  FE = /[\\/_+.#"@[({&]/g,
  OE = /[\s-]/,
  Y0 = /[\s-]/g;

function Bm(d, a, h, y, k, E, b) {
  if (E === a.length) return k === d.length ? Rv : RE;
  const s = `${k},${E}`;
  if (b[s] !== void 0) return b[s];
  const F = y.charAt(E);
  let O = h.indexOf(F, k),
    G = 0,
    X, Q, W, de;
  for (; O >= 0;) X = Bm(d, a, h, y, O + 1, E + 1, b), X > G && (O === k ? X *= Rv : BE.test(d.charAt(O - 1)) ? (X *= zE, W = d.slice(k, O - 1).match(FE), W && k > 0 && (X *= rm ** W.length)) : OE.test(d.charAt(O - 1)) ? (X *= EE, de = d.slice(k, O - 1).match(Y0), de && k > 0 && (X *= rm ** de.length)) : (X *= LE, k > 0 && (X *= rm ** (O - k))), d.charAt(O) !== a.charAt(E) && (X *= DE)), (X < tm && h.charAt(O - 1) === y.charAt(E + 1) || y.charAt(E + 1) === y.charAt(E) && h.charAt(O - 1) !== y.charAt(E)) && (Q = Bm(d, a, h, y, O + 1, E + 2, b), Q * tm > X && (X = Q * tm)), X > G && (G = X), O = h.indexOf(F, O + 1);
  return b[s] = G, G
}

function Bv(d) {
  return d.toLowerCase().replace(Y0, " ")
}

function K0(d, a, h) {
  return d = h && h.length > 0 ? `${`${d} ${h==null?void 0:h.join(" ")}`}` : d, Bm(d, a, Bv(d), Bv(a), 0, 0, {})
}
const jE = 18,
  Q0 = 40,
  NE = `${Q0}px`,
  ZE = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");

function VE({
  containerRef: d,
  inputRef: a,
  pushPasswordManagerStrategy: h,
  isFocused: y,
  domContext: k
}) {
  let E = rt(!1),
    b = rt(!1),
    s = rt(!1);

  function F() {
    const G = h.current;
    return G === "none" ? !1 : G === "increase-width" && x(E) && x(b)
  }

  function O() {
    const G = d.current,
      X = a.current;
    if (!G || !X || x(s) || h.current === "none") return;
    const Q = G,
      W = Q.getBoundingClientRect().left + Q.offsetWidth,
      de = Q.getBoundingClientRect().top + Q.offsetHeight / 2,
      _e = W - jE,
      Ae = de;
    k.querySelectorAll(ZE).length === 0 && k.getDocument().elementFromPoint(_e, Ae) === G || (re(E, !0), re(s, !0))
  }
  return Kr(() => {
    const G = d.current;
    if (!G || h.current === "none") return;

    function X() {
      const de = Z0(G).innerWidth - G.getBoundingClientRect().right;
      re(b, de >= Q0)
    }
    X();
    const Q = setInterval(X, 1e3);
    return () => {
      clearInterval(Q)
    }
  }), Kr(() => {
    const G = y.current || k.getActiveElement() === a.current;
    if (h.current === "none" || !G) return;
    const X = setTimeout(O, 0),
      Q = setTimeout(O, 2e3),
      W = setTimeout(O, 5e3),
      de = setTimeout(() => {
        re(s, !0)
      }, 6e3);
    return () => {
      clearTimeout(X), clearTimeout(Q), clearTimeout(W), clearTimeout(de)
    }
  }), {
    get hasPwmBadge() {
      return x(E)
    },
    get willPushPwmBadge() {
      return F()
    },
    PWM_BADGE_SPACE_WIDTH: NE
  }
}
const ey = V0({
    component: "pin-input",
    parts: ["root", "cell"]
  }),
  qE = ["Backspace", "Delete", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End", "Escape", "Enter", "Tab", "Shift", "Control", "Meta"];
var Ja, Lc, os, Oa, Xa, Dc, Eo, ss, Os, Rc, Cp, Rh, Bh, Tp, Sp, ty, Fh, Oh, Ip, jh;
const A_ = class A_ {
  constructor(a) {
    Lr(this, Sp);
    Tr(this, "opts");
    Tr(this, "attachment");
    Lr(this, Ja, Sr(null));
    Lr(this, Lc, rt(!1));
    Tr(this, "inputAttachment", Ya(Ye(this, Ja)));
    Lr(this, os, Sr(!1));
    Lr(this, Oa, rt(null));
    Lr(this, Xa, rt(null));
    Lr(this, Dc, new P8(() => this.opts.value.current ?? ""));
    Lr(this, Eo, ht(() => typeof this.opts.pattern.current == "string" ? new RegExp(this.opts.pattern.current) : this.opts.pattern.current));
    Lr(this, ss, rt(di({
      prev: [null, null, "none"],
      willSyntheticBlur: !1
    })));
    Lr(this, Os);
    Lr(this, Rc);
    Tr(this, "domContext");
    Tr(this, "onkeydown", a => {
      const h = a.key;
      qE.includes(h) || a.ctrlKey || a.metaKey || h && x(Ye(this, Eo)) && !x(Ye(this, Eo)).test(h) && a.preventDefault()
    });
    Lr(this, Cp, ht(() => ({
      position: "relative",
      cursor: this.opts.disabled.current ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })));
    Lr(this, Rh, ht(() => ({
      id: this.opts.id.current,
      [ey.root]: "",
      style: x(Ye(this, Cp)),
      ...this.attachment
    })));
    Lr(this, Bh, ht(() => ({
      style: {
        position: "absolute",
        inset: 0,
        pointerEvents: "none"
      }
    })));
    Lr(this, Tp, ht(() => ({
      position: "absolute",
      inset: 0,
      width: Ye(this, Os).willPushPwmBadge ? `calc(100% + ${Ye(this,Os).PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: Ye(this, Os).willPushPwmBadge ? `inset(0 ${Ye(this,Os).PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: this.opts.textAlign.current,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--bits-pin-input-root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })));
    Lr(this, Fh, () => {
      var _e;
      const a = Ye(this, Ja).current,
        h = this.opts.ref.current;
      if (!a || !h) return;
      if (this.domContext.getActiveElement() !== a) {
        re(Ye(this, Oa), null), re(Ye(this, Xa), null);
        return
      }
      const y = a.selectionStart,
        k = a.selectionEnd,
        E = a.selectionDirection ?? "none",
        b = a.maxLength,
        s = a.value,
        F = x(Ye(this, ss)).prev;
      let O = -1,
        G = -1,
        X;
      if (s.length !== 0 && y !== null && k !== null) {
        const Ae = y === k,
          xe = y === s.length && s.length < b;
        if (Ae && !xe) {
          const Ie = y;
          if (Ie === 0) O = 0, G = 1, X = "forward";
          else if (Ie === b) O = Ie - 1, G = Ie, X = "backward";
          else if (b > 1 && s.length > 1) {
            let Pe = 0;
            if (F[0] !== null && F[1] !== null) {
              X = Ie < F[0] ? "backward" : "forward";
              const De = F[0] === F[1] && F[0] < b;
              X === "backward" && !De && (Pe = -1)
            }
            O = Pe - Ie, G = Pe + Ie + 1
          }
        }
        O !== -1 && G !== -1 && O !== G && ((_e = Ye(this, Ja).current) == null || _e.setSelectionRange(O, G, X))
      }
      const Q = O !== -1 ? O : y,
        W = G !== -1 ? G : k,
        de = X ?? E;
      re(Ye(this, Oa), Q, !0), re(Ye(this, Xa), W, !0), x(Ye(this, ss)).prev = [Q, W, de]
    });
    Tr(this, "oninput", a => {
      const h = a.currentTarget.value.slice(0, this.opts.maxLength.current);
      if (h.length > 0 && x(Ye(this, Eo)) && !x(Ye(this, Eo)).test(h)) {
        a.preventDefault();
        return
      }
      typeof Ye(this, Dc).current == "string" && h.length < Ye(this, Dc).current.length && this.domContext.getDocument().dispatchEvent(new Event("selectionchange")), this.opts.value.current = h
    });
    Tr(this, "onfocus", a => {
      const h = Ye(this, Ja).current;
      if (h) {
        const y = Math.min(h.value.length, this.opts.maxLength.current - 1),
          k = h.value.length;
        h.setSelectionRange(y, k), re(Ye(this, Oa), y, !0), re(Ye(this, Xa), k, !0)
      }
      Ye(this, os).current = !0
    });
    Tr(this, "onpaste", a => {
      var G, X, Q, W;
      const h = Ye(this, Ja).current;
      if (!h) return;
      const y = de => {
          const _e = h.selectionStart === null ? void 0 : h.selectionStart,
            Ae = h.selectionEnd === null ? void 0 : h.selectionEnd,
            xe = _e !== Ae,
            Ie = this.opts.value.current;
          return (xe ? Ie.slice(0, _e) + de + Ie.slice(Ae) : Ie.slice(0, _e) + de + Ie.slice(_e)).slice(0, this.opts.maxLength.current)
        },
        k = de => de.length > 0 && x(Ye(this, Eo)) && !x(Ye(this, Eo)).test(de);
      if (!((G = this.opts.pasteTransformer) != null && G.current) && (!Ye(this, Rc).isIOS || !a.clipboardData || !h)) {
        const de = y((X = a.clipboardData) == null ? void 0 : X.getData("text/plain"));
        k(de) && a.preventDefault();
        return
      }
      const E = ((Q = a.clipboardData) == null ? void 0 : Q.getData("text/plain")) ?? "",
        b = (W = this.opts.pasteTransformer) != null && W.current ? this.opts.pasteTransformer.current(E) : E;
      a.preventDefault();
      const s = y(b);
      if (k(s)) return;
      h.value = s, this.opts.value.current = s;
      const F = Math.min(s.length, this.opts.maxLength.current - 1),
        O = s.length;
      h.setSelectionRange(F, O), re(Ye(this, Oa), F, !0), re(Ye(this, Xa), O, !0)
    });
    Tr(this, "onmouseover", a => {
      re(Ye(this, Lc), !0)
    });
    Tr(this, "onmouseleave", a => {
      re(Ye(this, Lc), !1)
    });
    Tr(this, "onblur", a => {
      if (x(Ye(this, ss)).willSyntheticBlur) {
        x(Ye(this, ss)).willSyntheticBlur = !1;
        return
      }
      Ye(this, os).current = !1
    });
    Lr(this, Oh, ht(() => {
      var a;
      return {
        id: this.opts.inputId.current,
        style: x(Ye(this, Tp)),
        autocomplete: this.opts.autocomplete.current || "one-time-code",
        "data-pin-input-input": "",
        "data-pin-input-input-mss": x(Ye(this, Oa)),
        "data-pin-input-input-mse": x(Ye(this, Xa)),
        inputmode: this.opts.inputmode.current,
        pattern: (a = x(Ye(this, Eo))) == null ? void 0 : a.source,
        maxlength: this.opts.maxLength.current,
        value: this.opts.value.current,
        disabled: U8(this.opts.disabled.current),
        onpaste: this.onpaste,
        oninput: this.oninput,
        onkeydown: this.onkeydown,
        onmouseover: this.onmouseover,
        onmouseleave: this.onmouseleave,
        onfocus: this.onfocus,
        onblur: this.onblur,
        ...this.inputAttachment
      }
    }));
    Lr(this, Ip, ht(() => Array.from({
      length: this.opts.maxLength.current
    }).map((a, h) => {
      const y = Ye(this, os).current && x(Ye(this, Oa)) !== null && x(Ye(this, Xa)) !== null && (x(Ye(this, Oa)) === x(Ye(this, Xa)) && h === x(Ye(this, Oa)) || h >= x(Ye(this, Oa)) && h < x(Ye(this, Xa))),
        k = this.opts.value.current[h] !== void 0 ? this.opts.value.current[h] : null;
      return {
        char: k,
        isActive: y,
        hasFakeCaret: y && k === null
      }
    })));
    Lr(this, jh, ht(() => ({
      cells: x(Ye(this, Ip)),
      isFocused: Ye(this, os).current,
      isHovering: x(Ye(this, Lc))
    })));
    var h;
    this.opts = a, this.attachment = Ya(this.opts.ref), this.domContext = new O8(a.ref), ta(this, Rc, {
      value: this.opts.value,
      isIOS: typeof window < "u" && ((h = window == null ? void 0 : window.CSS) == null ? void 0 : h.supports("-webkit-touch-callout", "none"))
    }), ta(this, Os, VE({
      containerRef: this.opts.ref,
      inputRef: Ye(this, Ja),
      isFocused: Ye(this, os),
      pushPasswordManagerStrategy: this.opts.pushPasswordManagerStrategy,
      domContext: this.domContext
    })), An(() => {
      const y = Ye(this, Ja).current,
        k = this.opts.ref.current;
      if (!y || !k) return;
      Ye(this, Rc).value.current !== y.value && (this.opts.value.current = y.value), x(Ye(this, ss)).prev = [y.selectionStart, y.selectionEnd, y.selectionDirection ?? "none"];
      const E = Hu(this.domContext.getDocument(), "selectionchange", Ye(this, Fh), {
        capture: !0
      });
      Ye(this, Fh).call(this), this.domContext.getActiveElement() === y && (Ye(this, os).current = !0), this.domContext.getElementById("pin-input-style") || Nr(this, Sp, ty).call(this);
      const b = () => {
        k && k.style.setProperty("--bits-pin-input-root-height", `${y.clientHeight}px`)
      };
      b();
      const s = new ResizeObserver(b);
      return s.observe(y), () => {
        E(), s.disconnect()
      }
    }), js([() => this.opts.value.current, () => Ye(this, Ja).current], () => {
      UE(() => {
        const y = Ye(this, Ja).current;
        if (!y) return;
        y.dispatchEvent(new Event("input"));
        const k = y.selectionStart,
          E = y.selectionEnd,
          b = y.selectionDirection ?? "none";
        k !== null && E !== null && (re(Ye(this, Oa), k, !0), re(Ye(this, Xa), E, !0), x(Ye(this, ss)).prev = [k, E, b])
      }, this.domContext)
    }), Kr(() => {
      const y = this.opts.value.current,
        k = Ye(this, Dc).current,
        E = this.opts.maxLength.current,
        b = this.opts.onComplete.current;
      k !== void 0 && y !== k && k.length < E && y.length === E && b(y)
    })
  }
  static create(a) {
    return new A_(a)
  }
  get rootProps() {
    return x(Ye(this, Rh))
  }
  set rootProps(a) {
    re(Ye(this, Rh), a)
  }
  get inputWrapperProps() {
    return x(Ye(this, Bh))
  }
  set inputWrapperProps(a) {
    re(Ye(this, Bh), a)
  }
  get inputProps() {
    return x(Ye(this, Oh))
  }
  set inputProps(a) {
    re(Ye(this, Oh), a)
  }
  get snippetProps() {
    return x(Ye(this, jh))
  }
  set snippetProps(a) {
    re(Ye(this, jh), a)
  }
};
Ja = new WeakMap, Lc = new WeakMap, os = new WeakMap, Oa = new WeakMap, Xa = new WeakMap, Dc = new WeakMap, Eo = new WeakMap, ss = new WeakMap, Os = new WeakMap, Rc = new WeakMap, Cp = new WeakMap, Rh = new WeakMap, Bh = new WeakMap, Tp = new WeakMap, Sp = new WeakSet, ty = function() {
  const a = this.domContext.getDocument(),
    h = a.createElement("style");
  if (h.id = "pin-input-style", a.head.appendChild(h), h.sheet) {
    const y = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
    Zu(h.sheet, "[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }"), Zu(h.sheet, `[data-pin-input-input]:autofill { ${y} }`), Zu(h.sheet, `[data-pin-input-input]:-webkit-autofill { ${y} }`), Zu(h.sheet, "@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), Zu(h.sheet, "[data-pin-input-input] + * { pointer-events: all !important; }")
  }
}, Fh = new WeakMap, Oh = new WeakMap, Ip = new WeakMap, jh = new WeakMap;
let Fm = A_;
var Nh;
const E_ = class E_ {
  constructor(a) {
    Tr(this, "opts");
    Tr(this, "attachment");
    Lr(this, Nh, ht(() => ({
      id: this.opts.id.current,
      [ey.cell]: "",
      "data-active": this.opts.cell.current.isActive ? "" : void 0,
      "data-inactive": this.opts.cell.current.isActive ? void 0 : "",
      ...this.attachment
    })));
    this.opts = a, this.attachment = Ya(this.opts.ref)
  }
  static create(a) {
    return new E_(a)
  }
  get props() {
    return x(Ye(this, Nh))
  }
  set props(a) {
    re(Ye(this, Nh), a)
  }
};
Nh = new WeakMap;
let Om = E_;

function UE(d, a) {
  const h = a.setTimeout(d, 0),
    y = a.setTimeout(d, 10),
    k = a.setTimeout(d, 50);
  return [h, y, k]
}

function Zu(d, a) {
  try {
    d.insertRule(a)
  } catch {
    console.error("pin input could not insert CSS rule:", a)
  }
}
var $E = fe("<div><!> <div><input/></div></div>");

function GE(d, a) {
  const h = mo();
  Ir(a, !0);
  let y = Tt(a, "id", 19, () => Ka(h)),
    k = Tt(a, "inputId", 19, () => `${Ka(h)}-input`),
    E = Tt(a, "ref", 15, null),
    b = Tt(a, "maxlength", 3, 6),
    s = Tt(a, "textalign", 3, "left"),
    F = Tt(a, "inputmode", 3, "numeric"),
    O = Tt(a, "onComplete", 3, Qu),
    G = Tt(a, "pushPasswordManagerStrategy", 3, "increase-width"),
    X = Tt(a, "class", 3, ""),
    Q = Tt(a, "autocomplete", 3, "one-time-code"),
    W = Tt(a, "disabled", 3, !1),
    de = Tt(a, "value", 15, ""),
    _e = Tt(a, "onValueChange", 3, Qu),
    Ae = sr(a, ["$$slots", "$$events", "$$legacy", "id", "inputId", "ref", "maxlength", "textalign", "pattern", "inputmode", "onComplete", "pushPasswordManagerStrategy", "class", "children", "autocomplete", "disabled", "value", "onValueChange", "pasteTransformer"]);
  const xe = Fm.create({
      id: Sr.with(() => y()),
      ref: Sr.with(() => E(), Ue => E(Ue)),
      inputId: Sr.with(() => k()),
      autocomplete: Sr.with(() => Q()),
      maxLength: Sr.with(() => b()),
      textAlign: Sr.with(() => s()),
      disabled: Sr.with(() => W()),
      inputmode: Sr.with(() => F()),
      pattern: Sr.with(() => a.pattern),
      onComplete: Sr.with(() => O()),
      value: Sr.with(() => de(), Ue => {
        de(Ue), _e()(Ue)
      }),
      pushPasswordManagerStrategy: Sr.with(() => G()),
      pasteTransformer: Sr.with(() => a.pasteTransformer)
    }),
    Ie = ht(() => Na(Ae, xe.inputProps)),
    Pe = ht(() => Na(xe.rootProps, {
      class: X()
    })),
    De = ht(() => Na(xe.inputWrapperProps, {}));
  var $e = $E();
  lr($e, () => ({
    ...x(Pe)
  }));
  var tt = P($e);
  Hn(tt, () => a.children ?? ra, () => xe.snippetProps);
  var Ve = B(tt, 2);
  lr(Ve, () => ({
    ...x(De)
  }));
  var Re = P(Ve);
  ya(Re), lr(Re, () => ({
    ...x(Ie)
  })), I(Ve), I($e), Z(d, $e), Pr()
}
var WE = fe("<div><!></div>");

function HE(d, a) {
  const h = mo();
  Ir(a, !0);
  let y = Tt(a, "id", 19, () => Ka(h)),
    k = Tt(a, "ref", 15, null),
    E = sr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "cell", "child", "children"]);
  const b = Om.create({
      id: Sr.with(() => y()),
      ref: Sr.with(() => k(), Q => k(Q)),
      cell: Sr.with(() => a.cell)
    }),
    s = ht(() => Na(E, b.props));
  var F = or(),
    O = pt(F);
  {
    var G = Q => {
        var W = or(),
          de = pt(W);
        Hn(de, () => a.child, () => ({
          props: x(s)
        })), Z(Q, W)
      },
      X = Q => {
        var W = WE();
        lr(W, () => ({
          ...x(s)
        }));
        var de = P(W);
        Hn(de, () => a.children ?? ra), I(W), Z(Q, W)
      };
    Be(O, Q => {
      a.child ? Q(G) : Q(X, !1)
    })
  }
  Z(d, F), Pr()
}

function Fc(...d) {
  return h0(Wu(d))
}

function JE(d, a) {
  Ir(a, !0);
  let h = Tt(a, "ref", 15, null),
    y = Tt(a, "value", 15, ""),
    k = sr(a, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
  var E = or(),
    b = pt(E);
  {
    let s = ht(() => Fc("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", a.class));
    yi(b, () => fE, (F, O) => {
      O(F, Ns({
        "data-slot": "command",
        get class() {
          return x(s)
        }
      }, () => k, {
        get value() {
          return y()
        },
        set value(G) {
          y(G)
        },
        get ref() {
          return h()
        },
        set ref(G) {
          h(G)
        }
      }))
    })
  }
  Z(d, E), Pr()
}
var XE = xr('<svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"></path></svg>');

function Il(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = XE();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}

function YE(d, a) {
  Ir(a, !0);
  let h = Tt(a, "ref", 15, null),
    y = sr(a, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var k = or(),
    E = pt(k);
  {
    let b = ht(() => Fc("py-6 text-center text-sm", a.class));
    yi(E, () => _E, (s, F) => {
      F(s, Ns({
        "data-slot": "command-empty",
        get class() {
          return x(b)
        }
      }, () => y, {
        get ref() {
          return h()
        },
        set ref(O) {
          h(O)
        }
      }))
    })
  }
  Z(d, k), Pr()
}
var KE = fe("<!> <!>", 1);

function QE(d, a) {
  Ir(a, !0);
  let h = Tt(a, "ref", 15, null),
    y = sr(a, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "heading", "value"]);
  var k = or(),
    E = pt(k);
  {
    let b = ht(() => Fc("text-foreground overflow-hidden p-1", a.class)),
      s = ht(() => a.value ?? a.heading ?? `----${oE()}`);
    yi(E, () => vE, (F, O) => {
      O(F, Ns({
        "data-slot": "command-group",
        get class() {
          return x(b)
        },
        get value() {
          return x(s)
        }
      }, () => y, {
        get ref() {
          return h()
        },
        set ref(G) {
          h(G)
        },
        children: (G, X) => {
          var Q = KE(),
            W = pt(Q);
          {
            var de = Ae => {
              var xe = or(),
                Ie = pt(xe);
              yi(Ie, () => xE, (Pe, De) => {
                De(Pe, {
                  class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                  children: ($e, tt) => {
                    en();
                    var Ve = Ii();
                    Ze(() => ce(Ve, a.heading)), Z($e, Ve)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), Z(Ae, xe)
            };
            Be(W, Ae => {
              a.heading && Ae(de)
            })
          }
          var _e = B(W, 2);
          yi(_e, () => CE, (Ae, xe) => {
            xe(Ae, {
              get children() {
                return a.children
              }
            })
          }), Z(G, Q)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  Z(d, k), Pr()
}

function ez(d, a) {
  Ir(a, !0);
  let h = Tt(a, "ref", 15, null),
    y = sr(a, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var k = or(),
    E = pt(k);
  {
    let b = ht(() => Fc("aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", a.class));
    yi(E, () => kE, (s, F) => {
      F(s, Ns({
        "data-slot": "command-item",
        get class() {
          return x(b)
        }
      }, () => y, {
        get ref() {
          return h()
        },
        set ref(O) {
          h(O)
        }
      }))
    })
  }
  Z(d, k), Pr()
}
var tz = xr('<svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"></path></svg>');

function rz(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = tz();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var nz = fe('<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>');

function iz(d, a) {
  Ir(a, !0);
  let h = Tt(a, "ref", 15, null),
    y = Tt(a, "value", 15, ""),
    k = sr(a, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var E = nz(),
    b = P(E);
  rz(b, {
    class: "size-5 opacity-50"
  });
  var s = B(b, 2);
  {
    let F = ht(() => Fc("placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", a.class));
    yi(s, () => SE, (O, G) => {
      G(O, Ns({
        "data-slot": "command-input",
        get class() {
          return x(F)
        }
      }, () => k, {
        get ref() {
          return h()
        },
        set ref(X) {
          h(X)
        },
        get value() {
          return y()
        },
        set value(X) {
          y(X)
        }
      }))
    })
  }
  I(E), Z(d, E), Pr()
}

function az(d, a) {
  Ir(a, !0);
  let h = Tt(a, "ref", 15, null),
    y = sr(a, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var k = or(),
    E = pt(k);
  {
    let b = ht(() => Fc("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", a.class));
    yi(E, () => AE, (s, F) => {
      F(s, Ns({
        "data-slot": "command-list",
        get class() {
          return x(b)
        }
      }, () => y, {
        get ref() {
          return h()
        },
        set ref(O) {
          h(O)
        }
      }))
    })
  }
  Z(d, k), Pr()
}
var oz = xr('<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>');

function sz(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = oz();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var lz = fe("<span> </span> <!>", 1),
  cz = fe('<span class="font-flag ml-0.5"> </span> ', 1),
  uz = fe('<span class="flex gap-1.5"><span class="font-flag"> </span> </span>'),
  hz = fe("<!> <!>", 1),
  dz = fe("<!> <!>", 1),
  pz = (d, a) => {
    a(0)
  },
  fz = fe('<button class="btn btn-xs btn-circle btn-ghost"><!></button>'),
  mz = fe('<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>');

function Fv(d, a) {
  Ir(a, !0);
  let h = Tt(a, "countryId", 15, 0),
    y = Tt(a, "dropdownDirection", 3, "right"),
    k = rt(null),
    E = rt(null),
    b = rt("");

  function s() {
    r0().then(() => {
      var Pe;
      (Pe = document.activeElement) == null || Pe.blur(), re(b, "")
    })
  }
  var F = mz(),
    O = P(F),
    G = P(O),
    X = P(G);
  {
    var Q = Pe => {
        var De = lz(),
          $e = pt(De),
          tt = P($e, !0);
        I($e);
        var Ve = B($e, 2);
        sz(Ve, {
          class: "size-3.5"
        }), Ze(Re => ce(tt, Re), [() => x0()]), Z(Pe, De)
      },
      W = Pe => {
        const De = ht(() => Lo(h()));
        var $e = cz(),
          tt = pt($e),
          Ve = P(tt, !0);
        I(tt);
        var Re = B(tt);
        Ze(() => {
          ce(Ve, x(De).flag), ce(Re, ` ${x(De).name??""}`)
        }), Z(Pe, $e)
      };
    Be(X, Pe => {
      h() === 0 ? Pe(Q) : Pe(W, !1)
    })
  }
  I(G);
  var de = B(G, 2);
  let _e;
  var Ae = P(de);
  yi(Ae, () => JE, (Pe, De) => {
    De(Pe, {
      children: ($e, tt) => {
        var Ve = dz(),
          Re = pt(Ve);
        yi(Re, () => iz, (Ce, We) => {
          We(Ce, {
            placeholder: "Country",
            get ref() {
              return x(k)
            },
            set ref(Je) {
              re(k, Je)
            },
            get value() {
              return x(b)
            },
            set value(Je) {
              re(b, Je, !0)
            }
          })
        });
        var Ue = B(Re, 2);
        yi(Ue, () => az, (Ce, We) => {
          We(Ce, {
            children: (Je, Ge) => {
              var Ee = hz(),
                mt = pt(Ee);
              yi(mt, () => YE, (ee, le) => {
                le(ee, {
                  children: (ae, ke) => {
                    en();
                    var qe = Ii();
                    Ze(lt => ce(qe, lt), [() => p5()]), Z(ae, qe)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              });
              var K = B(mt, 2);
              yi(K, () => QE, (ee, le) => {
                le(ee, {
                  children: (ae, ke) => {
                    var qe = or(),
                      lt = pt(qe);
                    ai(lt, 17, () => Bi.countries, ot => ot.id, (ot, dt) => {
                      var Pt = or(),
                        Lt = pt(Pt);
                      yi(Lt, () => ez, (He, ut) => {
                        ut(He, {
                          get value() {
                            return x(dt).name
                          },
                          onSelect: () => {
                            h(x(dt).id), s()
                          },
                          children: (gt, St) => {
                            var vt = uz(),
                              Ct = P(vt),
                              At = P(Ct, !0);
                            I(Ct);
                            var Bt = B(Ct);
                            I(vt), Ze(() => {
                              ce(At, x(dt).flag), ce(Bt, ` ${x(dt).name??""}`)
                            }), Z(gt, vt)
                          },
                          $$slots: {
                            default: !0
                          }
                        })
                      }), Z(ot, Pt)
                    }), Z(ae, qe)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), Z(Je, Ee)
            },
            $$slots: {
              default: !0
            }
          })
        }), Z($e, Ve)
      },
      $$slots: {
        default: !0
      }
    })
  }), I(de), I(O);
  var xe = B(O, 2);
  {
    var Ie = Pe => {
      var De = fz();
      De.__click = [pz, h];
      var $e = P(De);
      Il($e, {
        class: "size-3.5"
      }), I(De), Z(Pe, De)
    };
    Be(xe, Pe => {
      h() != 0 && Pe(Ie)
    })
  }
  I(F), us(F, Pe => re(E, Pe), () => x(E)), Ze(Pe => _e = Or(de, 1, "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm", null, _e, Pe), [() => ({
    "right-1": y() === "left"
  })]), Zn("focus", G, () => {
    x(k).focus()
  }), Z(d, F), Pr()
}
Ln(["click"]);
var _z = xr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>');

function gz(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = _z();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var vz = xr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>'),
  yz = xr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function th(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
  var y = or(),
    k = pt(y);
  {
    var E = s => {
        var F = vz();
        lr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...h
        })), Z(s, F)
      },
      b = s => {
        var F = yz();
        lr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...h
        })), Z(s, F)
      };
    Be(k, s => {
      a.filled ? s(E) : s(b, !1)
    })
  }
  Z(d, y)
}
var xz = fe('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  bz = fe('<div class="mb-2"><!></div>'),
  wz = fe('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  Cz = (d, a, h) => {
    a.onvisitclick({
      lat: x(h).lastLatitude,
      lng: x(h).lastLongitude
    })
  },
  Tz = fe('<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>'),
  Sz = fe('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>'),
  Iz = fe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  Pz = fe('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>'),
  kz = fe('<span class="font-flag tooltip ml-0.5"> </span>'),
  Mz = fe("<span> </span>"),
  Az = fe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  Ez = fe('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  zz = fe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  Lz = fe('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  Dz = fe('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  Rz = fe('<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>', 1);

function Bz(d, a) {
  Ir(a, !0);
  const h = [];
  let y = rt(1e3);
  const k = ht(() => x(y) <= 640);
  let E = rt("today"),
    b = {
      regions: {
        label: ST(),
        icon: Wm
      },
      countries: {
        label: kT(),
        icon: gz
      },
      players: {
        label: S0(),
        icon: Bp
      },
      alliances: {
        label: I0(),
        icon: Fp
      }
    },
    s = rt("regions"),
    F = rt(0),
    O = di({
      players: {},
      alliances: {},
      regions: {},
      countries: {}
    }),
    G = ht(() => {
      var Ve, Re, Ue;
      return x(s) === "regions" ? (Re = (Ve = O[x(s)][x(F)]) == null ? void 0 : Ve[x(E)]) == null ? void 0 : Re.entries : (Ue = O[x(s)][x(E)]) == null ? void 0 : Ue.entries
    });
  const X = 5 * 1e3;
  Kr(() => {
    var Ce;
    if (!a.open) return;
    const Ve = x(E),
      Re = x(s),
      Ue = x(F);
    Re === "players" && (!O[Re][Ve] || Date.now() - O[Re][Ve].time > X) ? nn.leaderboardPlayers(Ve).then(We => {
      O[Re][Ve] = {
        time: Date.now(),
        entries: We
      }
    }).catch(We => Ar.error(We.message)) : Re === "alliances" && (!O[Re][Ve] || Date.now() - O[Re][Ve].time > X) ? nn.leaderboardAlliances(Ve).then(We => {
      O[Re][Ve] = {
        time: Date.now(),
        entries: We
      }
    }).catch(We => Ar.error(We.message)) : Re === "countries" && (!O[Re][Ve] || Date.now() - O[Re][Ve].time > X) ? nn.leaderboardCountries(Ve).then(We => {
      O[Re][Ve] = {
        time: Date.now(),
        entries: We
      }
    }).catch(We => Ar.error(We.message)) : Re === "regions" && (!((Ce = O[Re][Ue]) != null && Ce[Ve]) || Date.now() - O[Re][Ue][Ve].time > X) && nn.leaderboardRegions(Ve, Ue).then(We => {
      O[Re][Ue] || (O[Re][Ue] = {}), O[Re][Ue][Ve] = {
        time: Date.now(),
        entries: We
      }
    }).catch(We => Ar.error(We.message))
  });
  var Q = Rz(),
    W = pt(Q);
  ai(W, 21, () => Object.entries(b), ([Ve, {
    label: Re,
    icon: Ue
  }]) => Ve, (Ve, Re) => {
    var Ue = ht(() => n0(x(Re), 2));
    let Ce = () => x(Ue)[0],
      We = () => x(Ue)[1].label,
      Je = () => x(Ue)[1].icon;
    const Ge = ht(Je);
    var Ee = xz(),
      mt = P(Ee);
    ya(mt);
    var K, ee = B(mt, 2);
    yi(ee, () => x(Ge), (ae, ke) => {
      ke(ae, {
        get this() {
          return Je()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var le = B(ee);
    I(Ee), Ze(() => {
      nr(mt, "aria-label", We()), K !== (K = Ce()) && (mt.value = (mt.__value = Ce()) ?? ""), ce(le, ` ${We()??""}`)
    }), Jm(h, [], mt, () => (Ce(), x(s)), ae => re(s, ae)), Z(Ve, Ee)
  }), I(W);
  var de = B(W, 2),
    _e = P(de);
  l_(_e, {
    get value() {
      return x(E)
    },
    set value(Ve) {
      re(E, Ve, !0)
    }
  });
  var Ae = B(_e, 2);
  {
    var xe = Ve => {
      Fv(Ve, {
        dropdownDirection: "left",
        get countryId() {
          return x(F)
        },
        set countryId(Re) {
          re(F, Re, !0)
        }
      })
    };
    Be(Ae, Ve => {
      x(s) === "regions" && !x(k) && Ve(xe)
    })
  }
  I(de);
  var Ie = B(de, 2);
  {
    var Pe = Ve => {
      var Re = bz(),
        Ue = P(Re);
      Fv(Ue, {
        get countryId() {
          return x(F)
        },
        set countryId(Ce) {
          re(F, Ce, !0)
        }
      }), I(Re), Z(Ve, Re)
    };
    Be(Ie, Ve => {
      x(s) === "regions" && x(k) && Ve(Pe)
    })
  }
  var De = B(Ie, 2);
  {
    var $e = Ve => {
        var Re = wz(),
          Ue = P(Re),
          Ce = B(Ue);
        {
          var We = Ge => {
              var Ee = Ii();
              Ze(mt => ce(Ee, mt), [() => Rp().toLowerCase()]), Z(Ge, Ee)
            },
            Je = Ge => {
              var Ee = or(),
                mt = pt(Ee);
              {
                var K = le => {
                    var ae = Ii();
                    Ze(ke => ce(ae, ke), [() => r_()]), Z(le, ae)
                  },
                  ee = le => {
                    var ae = or(),
                      ke = pt(ae);
                    {
                      var qe = lt => {
                        var ot = Ii();
                        Ze(dt => ce(ot, dt), [() => n_()]), Z(lt, ot)
                      };
                      Be(ke, lt => {
                        x(E) === "month" && lt(qe)
                      }, !0)
                    }
                    Z(le, ae)
                  };
                Be(mt, le => {
                  x(E) === "week" ? le(K) : le(ee, !1)
                }, !0)
              }
              Z(Ge, Ee)
            };
          Be(Ce, Ge => {
            x(E) === "today" ? Ge(We) : Ge(Je, !1)
          })
        }
        I(Re), Ze(Ge => ce(Ue, `${Ge??""} `), [() => t_()]), Z(Ve, Re)
      },
      tt = Ve => {
        var Re = or(),
          Ue = pt(Re);
        {
          var Ce = Je => {
              var Ge = or(),
                Ee = pt(Ge);
              {
                var mt = ee => {
                    const le = ht(() => x(G));
                    var ae = Sz(),
                      ke = P(ae),
                      qe = P(ke),
                      lt = B(P(qe)),
                      ot = P(lt, !0);
                    I(lt);
                    var dt = B(lt),
                      Pt = P(dt),
                      Lt = B(Pt, 2),
                      He = B(Lt),
                      ut = P(He);
                    th(ut, {
                      class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                    }), I(He), I(dt), en(), I(qe), I(ke);
                    var gt = B(ke);
                    ai(gt, 31, () => x(le), St => St.id, (St, vt, Ct) => {
                      const At = ht(() => Lo(x(vt).countryId));
                      var Bt = Tz(),
                        Vt = P(Bt),
                        Ot = P(Vt, !0);
                      I(Vt);
                      var Dt = B(Vt),
                        Rt = P(Dt),
                        Zt = P(Rt, !0);
                      I(Rt);
                      var Ft = B(Rt, 2),
                        cr = P(Ft),
                        ur = B(cr),
                        Er = P(ur);
                      I(ur), I(Ft), I(Dt);
                      var dr = B(Dt),
                        pr = P(dr, !0);
                      I(dr);
                      var vr = B(dr),
                        Vr = P(vr);
                      Vr.__click = [Cz, a, vt];
                      var qr = P(Vr, !0);
                      I(Vr), I(vr), I(Bt), Ze((ue, V, U) => {
                        ce(Ot, x(Ct) + 1), nr(Rt, "data-tip", x(At).name), ce(Zt, x(At).flag), Or(Ft, 1, `font-semibold ${ue??""}`), ce(cr, `${x(vt).name??""} `), ce(Er, `#${x(vt).number??""}`), ce(pr, V), ce(qr, U)
                      }, [() => Ri(x(vt).cityId), () => x(vt).pixelsPainted.toLocaleString("en-US"), () => ub()]), yl(Bt, () => xl, () => ({
                        duration: 200
                      })), Z(St, Bt)
                    }), I(gt), I(ae), Ze((St, vt, Ct, At) => {
                      ce(ot, St), ce(Pt, `${vt??""} `), ce(Lt, `${Ct??""} `), nr(He, "data-tip", At)
                    }, [() => RT(), () => Ic(), () => Pc().toLowerCase(), () => VT()]), Z(ee, ae)
                  },
                  K = ee => {
                    var le = or(),
                      ae = pt(le);
                    {
                      var ke = lt => {
                          var ot = Pz(),
                            dt = P(ot),
                            Pt = P(dt),
                            Lt = B(P(Pt)),
                            He = P(Lt, !0);
                          I(Lt);
                          var ut = B(Lt),
                            gt = P(ut),
                            St = B(gt, 2),
                            vt = B(St),
                            Ct = P(vt);
                          th(Ct, {
                            class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                          }), I(vt), I(ut), I(Pt), I(dt);
                          var At = B(dt);
                          ai(At, 31, () => x(G), Bt => Bt.id, (Bt, Vt, Ot) => {
                            const Dt = ht(() => Lo(x(Vt).id) ?? {
                              name: `Pais ID: ${x(Vt).id}`,
                              flag: "🏳️",
                              code: "XX"
                            });
                            var Rt = Iz(),
                              Zt = P(Rt),
                              Ft = P(Zt, !0);
                            I(Zt);
                            var cr = B(Zt),
                              ur = P(cr),
                              Er = P(ur, !0);
                            I(ur);
                            var dr = B(ur, 2),
                              pr = P(dr, !0);
                            I(dr), I(cr);
                            var vr = B(cr),
                              Vr = P(vr, !0);
                            I(vr), I(Rt), Ze((qr, ue) => {
                              ce(Ft, x(Ot) + 1), nr(ur, "data-tip", x(Dt).name), ce(Er, x(Dt).flag), Or(dr, 1, `font-semibold ${qr??""}`), ce(pr, x(Dt).name), ce(Vr, ue)
                            }, [() => Ri(x(Vt).id), () => x(Vt).pixelsPainted.toLocaleString("en-US")]), yl(Rt, () => xl, () => ({
                              duration: 200
                            })), Z(Bt, Rt)
                          }), I(At), I(ot), Ze((Bt, Vt, Ot, Dt) => {
                            ce(He, Bt), ce(gt, `${Vt??""} `), ce(St, `${Ot??""} `), nr(vt, "data-tip", Dt)
                          }, [() => x0(), () => Ic(), () => Pc().toLowerCase(), () => vS()]), Z(lt, ot)
                        },
                        qe = lt => {
                          var ot = or(),
                            dt = pt(ot);
                          {
                            var Pt = He => {
                                const ut = ht(() => x(G));
                                var gt = Ez(),
                                  St = P(gt),
                                  vt = P(St),
                                  Ct = B(P(vt)),
                                  At = P(Ct, !0);
                                I(Ct);
                                var Bt = B(Ct),
                                  Vt = P(Bt),
                                  Ot = B(Vt, 2, !0);
                                I(Bt), I(vt), I(St);
                                var Dt = B(St);
                                ai(Dt, 31, () => x(ut), Rt => Rt.id, (Rt, Zt, Ft) => {
                                  const cr = ht(() => {
                                    var we;
                                    return ((we = wt.data) == null ? void 0 : we.id) === x(Zt).id
                                  });
                                  var ur = Az();
                                  let Er;
                                  var dr = P(ur),
                                    pr = P(dr, !0);
                                  I(dr);
                                  var vr = B(dr),
                                    Vr = P(vr),
                                    qr = P(Vr);
                                  fo(qr, {
                                    class: "size-8 border sm:size-10",
                                    get userId() {
                                      return x(Zt).id
                                    },
                                    get pictureUrl() {
                                      return x(Zt).picture
                                    }
                                  });
                                  var ue = B(qr, 2),
                                    V = P(ue),
                                    U = P(V),
                                    Y = B(U),
                                    oe = P(Y);
                                  I(Y), I(V);
                                  var me = B(V, 2);
                                  {
                                    var Se = we => {
                                      const Mt = ht(() => Lo(x(Zt).equippedFlag));
                                      var Ut = or(),
                                        jt = pt(Ut);
                                      {
                                        var fr = Ur => {
                                          var Dr = kz(),
                                            jr = P(Dr, !0);
                                          I(Dr), Ze(() => {
                                            nr(Dr, "data-tip", x(Mt).name), ce(jr, x(Mt).flag)
                                          }), Z(Ur, Dr)
                                        };
                                        Be(jt, Ur => {
                                          x(Mt) && Ur(fr)
                                        })
                                      }
                                      Z(we, Ut)
                                    };
                                    Be(me, we => {
                                      x(Zt).equippedFlag && we(Se)
                                    })
                                  }
                                  var Oe = B(me, 2);
                                  {
                                    var ze = we => {
                                      Vh(we, {
                                        get username() {
                                          return x(Zt).discord
                                        },
                                        get id() {
                                          return x(Zt).discordId
                                        }
                                      })
                                    };
                                    Be(Oe, we => {
                                      x(Zt).discord && we(ze)
                                    })
                                  }
                                  var Ke = B(Oe, 2);
                                  {
                                    var _t = we => {
                                      var Mt = Mz(),
                                        Ut = P(Mt, !0);
                                      I(Mt), Ze((jt, fr) => {
                                        Or(Mt, 1, `badge badge-sm ml-0.5 border-0 ${jt??""} ${fr??""}`), ce(Ut, x(Zt).allianceName)
                                      }, [() => Ap(x(Zt).allianceId), () => Ri(x(Zt).allianceId)]), Z(we, Mt)
                                    };
                                    Be(Ke, we => {
                                      "allianceName" in x(Zt) && x(Zt).allianceName && we(_t)
                                    })
                                  }
                                  I(ue), I(Vr), I(vr);
                                  var it = B(vr),
                                    qt = P(it, !0);
                                  I(it), I(ur), Ze((we, Mt, Ut) => {
                                    Er = Or(ur, 1, "", null, Er, we), ce(pr, x(Ft) + 1), Or(V, 1, `font-semibold max-sm:ml-2 ${Mt??""} flex gap-1`), ce(U, `${x(Zt).name??""} `), ce(oe, `#${x(Zt).id??""}`), ce(qt, Ut)
                                  }, [() => ({
                                    "bg-base-200": x(cr)
                                  }), () => Ri(x(Zt).id), () => x(Zt).pixelsPainted.toLocaleString("en-US")]), yl(ur, () => xl, () => ({
                                    duration: 200
                                  })), Z(Rt, ur)
                                }), I(Dt), I(gt), Ze((Rt, Zt, Ft) => {
                                  ce(At, Rt), ce(Vt, `${Zt??""} `), ce(Ot, Ft)
                                }, [() => Xm(), () => Ic(), () => Pc().toLowerCase()]), Z(He, gt)
                              },
                              Lt = He => {
                                var ut = or(),
                                  gt = pt(ut);
                                {
                                  var St = vt => {
                                    var Ct = Lz(),
                                      At = P(Ct),
                                      Bt = P(At),
                                      Vt = B(P(Bt)),
                                      Ot = P(Vt, !0);
                                    I(Vt);
                                    var Dt = B(Vt),
                                      Rt = P(Dt),
                                      Zt = B(Rt, 2, !0);
                                    I(Dt), I(Bt), I(At);
                                    var Ft = B(At);
                                    ai(Ft, 31, () => x(G), cr => cr.id, (cr, ur, Er) => {
                                      const dr = ht(() => {
                                        var me;
                                        return ((me = wt.data) == null ? void 0 : me.allianceId) === x(ur).id
                                      });
                                      var pr = zz();
                                      let vr;
                                      var Vr = P(pr),
                                        qr = P(Vr, !0);
                                      I(Vr);
                                      var ue = B(Vr),
                                        V = P(ue),
                                        U = P(V, !0);
                                      I(V), I(ue);
                                      var Y = B(ue),
                                        oe = P(Y, !0);
                                      I(Y), I(pr), Ze((me, Se, Oe) => {
                                        vr = Or(pr, 1, "", null, vr, me), ce(qr, x(Er) + 1), Or(V, 1, `font-semibold ${Se??""}`), ce(U, x(ur).name), ce(oe, Oe)
                                      }, [() => ({
                                        "bg-base-200": x(dr)
                                      }), () => Ri(x(ur).id), () => x(ur).pixelsPainted.toLocaleString("en-US")]), yl(pr, () => xl, () => ({
                                        duration: 200
                                      })), Z(cr, pr)
                                    }), I(Ft), I(Ct), Ze((cr, ur, Er) => {
                                      ce(Ot, cr), ce(Rt, `${ur??""} `), ce(Zt, Er)
                                    }, [() => Lp(), () => Ic(), () => Pc().toLowerCase()]), Z(vt, Ct)
                                  };
                                  Be(gt, vt => {
                                    x(s) === "alliances" && vt(St)
                                  }, !0)
                                }
                                Z(He, ut)
                              };
                            Be(dt, He => {
                              x(s) === "players" ? He(Pt) : He(Lt, !1)
                            }, !0)
                          }
                          Z(lt, ot)
                        };
                      Be(ae, lt => {
                        x(s) === "countries" ? lt(ke) : lt(qe, !1)
                      }, !0)
                    }
                    Z(ee, le)
                  };
                Be(Ee, ee => {
                  x(s) === "regions" ? ee(mt) : ee(K, !1)
                })
              }
              Z(Je, Ge)
            },
            We = Je => {
              var Ge = Dz();
              Z(Je, Ge)
            };
          Be(Ue, Je => {
            x(G) ? Je(Ce) : Je(We, !1)
          }, !0)
        }
        Z(Ve, Re)
      };
    Be(De, Ve => {
      x(G) && x(G).length === 0 ? Ve($e) : Ve(tt, !1)
    })
  }
  zp("innerWidth", Ve => re(y, Ve, !0)), Z(d, Q), Pr()
}
Ln(["click"]);
var Fz = xr('<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>');

function ry(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = Fz();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var Oz = fe('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function jz(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15);
  An(() => {
    const X = Q => {
      Q.key === "Escape" && h(!1)
    };
    return document.addEventListener("keydown", X), () => document.removeEventListener("keydown", X)
  });
  var y = Oz(),
    k = P(y),
    E = B(P(k), 2),
    b = P(E);
  ry(b, {
    class: "size-6"
  });
  var s = B(b, 2),
    F = P(s, !0);
  I(s), I(E);
  var O = B(E, 2),
    G = P(O);
  Bz(G, {
    get onvisitclick() {
      return a.onvisitclick
    },
    get open() {
      return h()
    }
  }), I(O), I(k), en(2), I(y), pi(y, () => X => {
    Kr(() => {
      h() ? X.show() : X.close()
    })
  }), Ze(X => ce(F, X), [() => Qm()]), Zn("close", y, () => h(!1)), Z(d, y), Pr()
}
var Nz = fe("<div><!></div>"),
  Zz = fe('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Vz(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15);
  An(() => {
    const s = F => {
      F.key === "Escape" && h(!1)
    };
    return document.addEventListener("keydown", s), () => document.removeEventListener("keydown", s)
  });
  var y = Zz(),
    k = P(y),
    E = B(P(k), 2);
  {
    var b = s => {
      var F = Nz(),
        O = P(F);
      xb(O, {}), I(F), Ni(2, F, () => va, () => ({
        duration: 300
      })), Z(s, F)
    };
    Be(E, s => {
      h() && s(b)
    })
  }
  I(k), en(2), I(y), pi(y, () => s => {
    Kr(() => {
      h() ? s.show() : s.close()
    })
  }), Zn("close", y, () => h(!1)), Z(d, y), Pr()
}
var qz = fe("<p>You don't have charges to paint. <br/> </p>");

function Uz(d, a) {
  Ir(a, !1), Km();
  var h = qz(),
    y = B(P(h), 2);
  I(h), Ze(k => ce(y, ` Next charge in ${k??""}`), [() => gp(wt.cooldown ?? 0)]), Z(d, h), Pr()
}
var $z = fe('<form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form>'),
  Gz = fe('<form method="dialog" class="modal-backdrop"><button> </button></form>'),
  Wz = fe("<dialog><div><!> <!></div> <!></dialog>");

function f_(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15),
    y = Tt(a, "hasBackdrop", 3, !0),
    k = Tt(a, "hasCloseButton", 3, !0);
  var E = Wz(),
    b = P(E),
    s = P(b);
  {
    var F = Q => {
      var W = $z();
      Z(Q, W)
    };
    Be(s, Q => {
      k() && Q(F)
    })
  }
  var O = B(s, 2);
  Hn(O, () => a.children ?? ra), I(b);
  var G = B(b, 2);
  {
    var X = Q => {
      var W = Gz(),
        de = P(W),
        _e = P(de, !0);
      I(de), I(W), Ze(Ae => ce(_e, Ae), [() => cs()]), Z(Q, W)
    };
    Be(G, Q => {
      y() && Q(X)
    })
  }
  I(E), pi(E, () => Q => {
    Kr(() => {
      h() ? Q.show() : Q.close()
    })
  }), Ze(() => {
    Or(E, 1, `modal ${a.dialogClass??""}`), Or(b, 1, `modal-box ${a.modalBoxClass??""}`)
  }), Zn("close", E, () => h(!1)), Z(d, E), Pr()
}
var Hz = (d, a) => {
    a(!1)
  },
  Jz = fe('<div class="flex h-full flex-col gap-4"><span class="text-xl font-semibold"> </span> <span><!></span> <button class="btn btn-primary mx-auto w-max px-10"> </button></div>');

function Xz(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15),
    y = Tt(a, "buttonText", 3, "OK");
  f_(d, {
    dialogClass: "!bg-black/80",
    modalBoxClass: "max-h-11/12",
    get open() {
      return h()
    },
    set open(k) {
      h(k)
    },
    children: (k, E) => {
      var b = Jz(),
        s = P(b),
        F = P(s, !0);
      I(s);
      var O = B(s, 2),
        G = P(O);
      Hn(G, () => a.message), I(O);
      var X = B(O, 2);
      X.__click = [Hz, h];
      var Q = P(X, !0);
      I(X), I(b), Ze(() => {
        ce(F, a.title), ce(Q, y())
      }), Z(k, b)
    },
    $$slots: {
      default: !0
    }
  }), Pr()
}
Ln(["click"]);

function Yz(d) {
  const a = new Date;
  return d.getDate() === a.getDate() && d.getMonth() === a.getMonth() && d.getFullYear() === a.getFullYear() ? d.toLocaleTimeString(void 0, {
    timeStyle: "short"
  }) : d.toLocaleDateString(void 0, {
    dateStyle: "medium"
  })
}
var Kz = (d, a, h) => {
    a(!0), h.onclick()
  },
  Qz = fe('<span class="size-2 rounded-full bg-red-400"></span>'),
  eL = fe('<button class="hover:bg-base-content/10 flex gap-3 px-6 py-3"><div class="bg-primary/30 flex size-10 min-h-10 min-w-10 items-center justify-center rounded-full"><!></div> <div class="grow text-sm"><div class="flex items-baseline justify-between"><h3 class="font-semibold"> </h3> <div class="text-base-content/80 flex items-center gap-1.5 text-xs"><span> </span> <!></div></div> <p class="mt-0.5 text-left"> </p></div></button>');

function tL(d, a) {
  Ir(a, !0);
  let h = Tt(a, "read", 15);
  var y = eL();
  y.__click = [Kz, h, a];
  var k = P(y),
    E = P(k);
  Hn(E, () => a.icon), I(k);
  var b = B(k, 2),
    s = P(b),
    F = P(s),
    O = P(F, !0);
  I(F);
  var G = B(F, 2),
    X = P(G),
    Q = P(X, !0);
  I(X);
  var W = B(X, 2);
  {
    var de = xe => {
      var Ie = Qz();
      Z(xe, Ie)
    };
    Be(W, xe => {
      h() || xe(de)
    })
  }
  I(G), I(s);
  var _e = B(s, 2),
    Ae = P(_e, !0);
  I(_e), I(b), I(y), Ze(xe => {
    ce(O, a.title), ce(Q, xe), ce(Ae, a.message)
  }, [() => Yz(a.createdAt)]), Z(d, y), Pr()
}
Ln(["click"]);
var rL = xr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h168q13-36 43.5-58t68.5-22q38 0 68.5 22t43.5 58h168q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm80-80h280v-80H280v80Zm0-160h400v-80H280v80Zm0-160h400v-80H280v80Zm200-190q13 0 21.5-8.5T510-820q0-13-8.5-21.5T480-850q-13 0-21.5 8.5T450-820q0 13 8.5 21.5T480-790ZM200-200v-560 560Z"></path></svg>');

function nL(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = rL();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var iL = fe('<button class="btn btn-sm btn-ghost"> </button>'),
  aL = fe('<p class="text-base-content/80 mt-4 text-center text-sm"> </p>'),
  oL = fe("<!> <!>", 1),
  sL = fe('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  lL = fe('<div class="flex items-center justify-between gap-2 px-6"><h3 class="text-xl font-bold"> </h3> <!></div> <section class="mt-4"><!> <!></section>', 1),
  cL = fe("<p> </p>"),
  uL = fe("<!> <!>", 1);

function hL(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15),
    y = rt(!1),
    k = rt(void 0),
    E = rt(void 0),
    b = rt(!1);
  var s = uL(),
    F = pt(s);
  f_(F, {
    modalBoxClass: "h-11/12 max-h-11/12 px-0",
    get open() {
      return h()
    },
    set open(G) {
      h(G)
    },
    children: (G, X) => {
      var Q = lL(),
        W = pt(Q),
        de = P(W),
        _e = P(de, !0);
      I(de);
      var Ae = B(de, 2);
      {
        var xe = Ve => {
          var Re = iL();
          Re.__click = async () => {
            if (nn.postNotificationMarkReadAll(), wt.notificiationCount = 0, x(k))
              for (const Ce of x(k)) Ce.read = !0
          };
          var Ue = P(Re, !0);
          I(Re), Ze(Ce => ce(Ue, Ce), [() => P6()]), Z(Ve, Re)
        };
        Be(Ae, Ve => {
          wt.notificiationCount !== 0 && Ve(xe)
        })
      }
      I(W);
      var Ie = B(W, 2),
        Pe = P(Ie);
      {
        var De = Ve => {
          var Re = oL(),
            Ue = pt(Re);
          ai(Ue, 17, () => x(k), Je => Je.id, (Je, Ge, Ee) => {
            var mt = or(),
              K = pt(mt);
            {
              var ee = le => {
                {
                  const ae = ot => {
                    nL(ot, {
                      class: "size-5"
                    })
                  };
                  let ke = ht(() => bv()),
                    qe = ht(() => wv()),
                    lt = ht(() => new Date(x(Ge).createdAt));
                  tL(le, {
                    get title() {
                      return x(ke)
                    },
                    get message() {
                      return x(qe)
                    },
                    get createdAt() {
                      return x(lt)
                    },
                    onclick: () => {
                      re(b, !0)
                    },
                    get read() {
                      return x(Ge).read
                    },
                    set read(ot) {
                      x(Ge).read = ot
                    },
                    icon: ae,
                    $$slots: {
                      icon: !0
                    }
                  })
                }
              };
              Be(K, le => {
                x(Ge).type === "report_feedback" && le(ee)
              })
            }
            Z(Je, mt)
          });
          var Ce = B(Ue, 2);
          {
            var We = Je => {
              var Ge = aL(),
                Ee = P(Ge, !0);
              I(Ge), Ze(mt => ce(Ee, mt), [() => g6()]), Z(Je, Ge)
            };
            Be(Ce, Je => {
              x(k).length === 0 && !x(y) && Je(We)
            })
          }
          Z(Ve, Re)
        };
        Be(Pe, Ve => {
          x(k) && Ve(De)
        })
      }
      var $e = B(Pe, 2);
      {
        var tt = Ve => {
          var Re = sL();
          pi(Re, () => Ue => {
            const Ce = new IntersectionObserver(We => {
              We[0].isIntersecting && !x(y) && (re(y, !0), nn.getNotificationPage(x(E)).then(Je => {
                re(k, [...x(k) ?? [], ...Je.notifications], !0), re(E, Je.nextCursor, !0);
                const Ge = Je.notifications.filter(Ee => !Ee.read).map(Ee => Ee.id);
                Ge.length > 0 && (nn.postNotificationMarkRead(Ge), wt.notificiationCount && (wt.notificiationCount = Math.max(0, Ge.length - Ge.length)))
              }).catch(Je => {
                Ar.error(Je.message)
              }).finally(() => {
                re(y, !1)
              }))
            });
            return Ce.observe(Ue), () => {
              Ce.disconnect()
            }
          }), Z(Ve, Re)
        };
        Be($e, Ve => {
          h() && (x(k) === void 0 || x(E) !== void 0) && Ve(tt)
        })
      }
      I(Ie), Ze(Ve => ce(_e, Ve), [() => f6()]), Z(G, Q)
    },
    $$slots: {
      default: !0
    }
  });
  var O = B(F, 2);
  {
    const G = Q => {
      var W = cL(),
        de = P(W);
      I(W), Ze((_e, Ae) => ce(de, `${_e??""} ${Ae??""}`), [() => wv(), () => T6()]), Z(Q, W)
    };
    let X = ht(() => bv());
    Xz(O, {
      get title() {
        return x(X)
      },
      get open() {
        return x(b)
      },
      set open(Q) {
        re(b, Q, !0)
      },
      message: G,
      $$slots: {
        message: !0
      }
    })
  }
  Z(d, s), Pr()
}
Ln(["click"]);
var dL = fe("<canvas></canvas>");

function ny(d, a) {
  Ir(a, !0);
  let h = Tt(a, "width", 15, 0),
    y = sr(a, ["$$slots", "$$events", "$$legacy", "value", "fontSize", "color", "weight", "mono", "width"]),
    k = ht(() => Math.ceil(a.fontSize)),
    E = rt(null);
  const b = window.devicePixelRatio ?? 1,
    s = '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
    F = '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  Kr(() => {
    const G = x(E).getContext("2d");
    G.textBaseline = "top", G.font = `${a.weight??"normal"} ${a.fontSize}px ${a.mono?F:s}`, G.fillStyle = a.color ?? "#394e6a", G.setTransform(b, 0, 0, b, 0, 0), G.clearRect(0, 0, h(), x(k)), G.fillText(a.value, 0, 0);
    const X = G.measureText(a.value);
    h(Math.ceil(X.actualBoundingBoxRight)), re(k, X.actualBoundingBoxDescent)
  });
  var O = dL();
  lr(O, () => ({
    width: h() * b,
    height: x(k) * b,
    style: `width: ${h()??""}px; height: ${x(k)??""}px`,
    ...y
  })), us(O, G => re(E, G), () => x(E)), Z(d, O), Pr()
}
var pL = fe('<span class="w-7 text-xs"> </span>'),
  fL = fe('<span class="flex items-center gap-1 sm:mt-[1px]"><span><!></span> <!></span>'),
  mL = fe('<span class="loading loading-spinner center-absolute absolute"></span>'),
  _L = fe('<button><!> <div class="flex items-center gap-2"> <!></div> <!></button>');

function iy(d, a) {
  Ir(a, !0);
  let h = sr(a, ["$$slots", "$$events", "$$legacy", "loading", "charges"]),
    y = rt(0);
  var k = _L();
  lr(k, () => ({
    ...h,
    class: `btn btn-primary btn-lg sm:btn-xl relative ${a.class??""}`
  }));
  var E = P(k);
  qh(E, {
    class: "size-6"
  });
  var b = B(E, 2),
    s = P(b),
    F = B(s);
  {
    var O = Q => {
      const W = ht(() => `${Math.floor(a.charges)}/${wt.data.charges.max}`);
      var de = fL(),
        _e = P(de),
        Ae = P(_e);
      {
        let Pe = ht(() => a.disabled ? "#394e6a33" : "#ffffff");
        ny(Ae, {
          weight: 600,
          fontSize: 16,
          get value() {
            return x(W)
          },
          get color() {
            return x(Pe)
          },
          get width() {
            return x(y)
          },
          set width(De) {
            re(y, De, !0)
          }
        })
      }
      I(_e);
      var xe = B(_e, 2);
      {
        var Ie = Pe => {
          var De = pL(),
            $e = P(De);
          I(De), Ze(tt => ce($e, `(${tt??""})`), [() => gp(wt.cooldown)]), Z(Pe, De)
        };
        Be(xe, Pe => {
          a.charges < wt.data.charges.max && wt.cooldown !== void 0 && Pe(Ie)
        })
      }
      I(de), Ze(Pe => Bc(_e, `width: ${Pe??""}px`), [() => (Math.floor(x(y) / 5) + 1) * 5]), Z(Q, de)
    };
    Be(F, Q => {
      a.charges !== void 0 && wt.data && Q(O)
    })
  }
  I(b);
  var G = B(b, 2);
  {
    var X = Q => {
      var W = mL();
      Z(Q, W)
    };
    Be(G, Q => {
      a.loading && Q(X)
    })
  }
  I(k), Ze(Q => ce(s, `${Q??""} `), [() => w0()]), Z(d, k), Pr()
}
const gL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII=",
  vL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC",
  yL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC",
  xL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
class bL {
  constructor(a) {
    Tr(this, "gm");
    Tr(this, "opacity", 1);
    Tr(this, "id", `paint-preview-${Math.random()}`);
    Tr(this, "tiles", new Map);
    this.input = a, this.gm = new Zs(this.input.tileSize)
  }
  place([a, h], y) {
    const {
      tile: k,
      pixel: E
    } = this.gm.latLonToTileAndPixel(a, h, this.input.tileZoom), b = this.getTileKey(k[0], k[1]);
    let s = this.tiles.get(b);
    if (!s) {
      const F = this.gm.tileBoundsLatLon(k[0], k[1], this.input.tileZoom),
        O = a_(F, !0),
        G = new wL({
          coordinates: O,
          id: `${this.id}-${b}`,
          layerPaint: {
            "raster-opacity": this.opacity,
            "raster-resampling": "nearest"
          },
          tileSize: this.input.tileSize,
          beforeLayerId: this.input.beforeLayerId
        });
      G.addTo(this.input.map), this.tiles.set(b, G), s = G
    }
    s.place(E[0], this.input.tileSize - E[1] - 1, y)
  }
  clear() {
    const a = this.input.map;
    for (const h of this.tiles.values()) h.removeFrom(a), h.removeDOM();
    this.tiles.clear()
  }
  clearAndPlace(a, h) {
    this.clear(), this.place(a, h)
  }
  remove([a, h]) {
    const {
      tile: y,
      pixel: k
    } = this.gm.latLonToTileAndPixel(a, h, this.input.tileZoom), E = this.getTileKey(y[0], y[1]), b = this.tiles.get(E);
    b && b.remove(k[0], this.input.tileSize - k[1] - 1)
  }
  setCanvasOpacity(a) {
    this.opacity = a;
    for (const h of this.tiles.values()) h.setOpacity(a)
  }
  getTileKey(a, h) {
    return `${a},${h}`
  }
}
class wL {
  constructor(a) {
    Tr(this, "canvas");
    Tr(this, "maps", new Set);
    this.input = a;
    const h = this.input.tileSize;
    this.canvas = document.createElement("canvas"), this.canvas.width = h, this.canvas.height = h
  }
  place(a, h, y) {
    var b;
    const k = ((b = Bi.colors) == null ? void 0 : b[y]) ?? Bi.colors[0],
      E = this.canvas.getContext("2d");
    if (E) {
      const s = E.createImageData(1, 1),
        [F, O, G] = k.rgb,
        X = y === 0 ? 0 : 255;
      s.data[0] = F, s.data[1] = O, s.data[2] = G, s.data[3] = X, E.putImageData(s, a, h)
    }
  }
  remove(a, h) {
    const y = this.canvas.getContext("2d");
    y && y.clearRect(a, h, 1, 1)
  }
  addTo(a) {
    const h = this.input.id;
    a.getSource(h) || a.addSource(h, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), a.getLayer(h) || (a.addLayer({
      id: h,
      type: "raster",
      source: h,
      paint: this.input.layerPaint
    }), this.input.beforeLayerId && a.moveLayer(h, this.input.beforeLayerId)), this.maps.add(a)
  }
  removeFrom(a) {
    const {
      id: h
    } = this.input;
    a.getLayer(h) && a.removeLayer(h), a.getSource(h) && a.removeSource(h), this.maps.delete(a)
  }
  removeDOM() {
    this.canvas.remove()
  }
  setOpacity(a) {
    for (const h of this.maps.values()) h.setPaintProperty(this.input.id, "raster-opacity", a)
  }
}
var CL = xr('<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>');

function TL(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = CL();
  lr(y, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...h
  })), Z(d, y)
}
var SL = xr('<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>');

function IL(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = SL();
  lr(y, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...h
  })), Z(d, y)
}
var PL = fe("<div><!></div>");

function gl(d, a) {
  Ir(a, !0);
  var h = PL(),
    y = P(h);
  Hn(y, () => a.children ?? ra), I(h), Ze(() => Or(h, 1, `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${a.class??""}`)), Z(d, h), Pr()
}
var kL = fe('<div class="confetti svelte-15ksp55"></div>'),
  ML = fe("<div></div>");

function m_(d, a) {
  Ir(a, !0);
  const h = Tt(a, "size", 3, 10),
    y = Tt(a, "x", 19, () => [-.5, .5]),
    k = Tt(a, "y", 19, () => [.25, 1]),
    E = Tt(a, "duration", 3, 2e3),
    b = Tt(a, "infinite", 3, !1),
    s = Tt(a, "delay", 19, () => [0, 50]),
    F = Tt(a, "colorRange", 19, () => [0, 360]),
    O = Tt(a, "colorArray", 19, () => []),
    G = Tt(a, "amount", 3, 50),
    X = Tt(a, "iterationCount", 3, 1),
    Q = Tt(a, "fallDistance", 3, "100px"),
    W = Tt(a, "rounded", 3, !1),
    de = Tt(a, "cone", 3, !1),
    _e = Tt(a, "noGravity", 3, !1),
    Ae = Tt(a, "xSpread", 3, .15),
    xe = Tt(a, "destroyOnComplete", 3, !0),
    Ie = Tt(a, "disableForReducedMotion", 3, !1);
  let Pe = rt(!1);
  An(() => {
    !xe() || b() || typeof X() == "string" || setTimeout(() => re(Pe, !0), (E() + s()[1]) * X())
  });

  function De(Ue, Ce) {
    return Math.random() * (Ce - Ue) + Ue
  }

  function $e() {
    return O().length ? O()[Math.round(Math.random() * (O().length - 1))] : `hsl(${Math.round(De(F()[0],F()[1]))}, 75%, 50%)`
  }
  var tt = or(),
    Ve = pt(tt);
  {
    var Re = Ue => {
      var Ce = ML();
      let We;
      ai(Ce, 21, () => ({
        length: G()
      }), kp, (Je, Ge) => {
        var Ee = kL();
        Ze((mt, K, ee, le, ae, ke, qe, lt, ot, dt, Pt) => Bc(Ee, `
        --color: ${mt??""};
        --skew: ${K??""}deg,${ee??""}deg;
        --rotation-xyz: ${le??""}, ${ae??""}, ${ke??""};
        --rotation-deg: ${qe??""}deg;
        --translate-y-multiplier: ${lt??""};
        --translate-x-multiplier: ${ot??""};
        --scale: ${dt??""};
        --transition-delay: ${Pt??""}ms;
        --transition-duration: ${b()?`calc(${E()}ms * var(--scale))`:`${E()}ms`};`), [$e, () => De(-45, 45), () => De(-45, 45), () => De(-10, 10), () => De(-10, 10), () => De(-10, 10), () => De(0, 360), () => De(k()[0], k()[1]), () => De(y()[0], y()[1]), () => .1 * De(2, 10), () => De(s()[0], s()[1])]), Z(Je, Ee)
      }), I(Ce), Ze(Je => {
        We = Or(Ce, 1, "confetti-holder svelte-15ksp55", null, We, Je), Bc(Ce, `
    --fall-distance: ${Q()??""};
    --size: ${h()??""}px;
    --x-spread: ${1-Ae()};
    --transition-iteration-count: ${(b()?"infinite":X())??""};`)
      }, [() => ({
        rounded: W(),
        cone: de(),
        "no-gravity": _e(),
        "reduced-motion": Ie()
      })]), Z(Ue, Ce)
    };
    Be(Ve, Ue => {
      x(Pe) || Ue(Re)
    })
  }
  Z(d, tt), Pr()
}
var AL = async (d, a, h, y) => {
  try {
    re(a, !0), await nn.purchase({
      id: h,
      amount: 1,
      variant: y.colorIdx
    }), await wt.refresh(), Vi.notification1.play()
  } catch (k) {
    Ar.error(k.message)
  } finally {
    re(a, !1)
  }
}, EL = fe('<span class="loading loading-spinner center-absolute absolute"></span>'), zL = fe('<!> <span class="text-sm">Droplets</span>', 1), LL = fe('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1), DL = (d, a) => a(!1), RL = fe('<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>'), BL = fe('<dialog class="modal !bg-black/80"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function FL(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15);
  const y = ht(() => Bi.colors[a.colorIdx]),
    k = ht(() => {
      var W;
      return ((W = wt.data) == null ? void 0 : W.droplets) ?? 0
    });
  let E = rt(!1);
  const b = ht(() => (x(E), wt.hasColor(a.colorIdx)));
  An(() => {
    const W = de => {
      de.key === "Escape" && h(!1)
    };
    return document.addEventListener("keydown", W), () => document.removeEventListener("keydown", W)
  });
  const s = 100,
    F = Bi.products[s];
  var O = BL(),
    G = P(O),
    X = B(P(G), 2);
  {
    var Q = W => {
      var de = RL(),
        _e = P(de),
        Ae = P(_e),
        xe = P(Ae);
      vp(xe, {
        class: "size-6"
      });
      var Ie = B(xe, 4),
        Pe = P(Ie);
      m0(Pe, {
        get value() {
          return x(k)
        }
      }), I(Ie), I(Ae), en(2), I(_e);
      var De = B(_e, 2),
        $e = P(De),
        tt = P($e);
      I($e);
      var Ve = B($e, 2),
        Re = P(Ve, !0);
      I(Ve);
      var Ue = B(Ve, 2),
        Ce = P(Ue);
      let We;
      var Je = P(Ce);
      Je.__click = [AL, E, s, a];
      var Ge = P(Je);
      {
        var Ee = ae => {
          var ke = EL();
          Z(ae, ke)
        };
        Be(Ge, ae => {
          x(E) && ae(Ee)
        })
      }
      var mt = B(Ge, 2);
      {
        var K = ae => {
            var ke = zL(),
              qe = pt(ke);
            Ep(qe, {
              class: "size-5"
            });
            var lt = B(qe);
            en(), Ze(ot => ce(lt, ` ${ot??""} `), [() => F.price.toLocaleString("en-US")]), Z(ae, ke)
          },
          ee = ae => {
            var ke = LL(),
              qe = pt(ke);
            vp(qe, {
              class: "size-5"
            });
            var lt = B(qe, 2),
              ot = P(lt);
            m_(ot, {}), I(lt), Z(ae, ke)
          };
        Be(mt, ae => {
          x(b) ? ae(ee, !1) : ae(K)
        })
      }
      I(Je), I(Ce);
      var le = B(Ce, 2);
      le.__click = [DL, h], I(Ue), I(De), I(de), Ze((ae, ke) => {
        Bc(tt, `background: rgb(${x(y).rgb[0]} ${x(y).rgb[1]} ${x(y).rgb[2]})`), nr(tt, "aria-label", x(y).name), ce(Re, x(y).name), nr(Ce, "data-tip", ae), We = Or(Ce, 1, "", null, We, ke), Je.disabled = x(k) < F.price || x(E) || x(b)
      }, [() => Dp(), () => ({
        tooltip: !x(b) && x(k) < F.price
      })]), Z(W, de)
    };
    Be(X, W => {
      wt.data && W(Q)
    })
  }
  I(G), en(2), I(O), pi(O, () => W => {
    Kr(() => {
      h() ? W.show() : W.close()
    })
  }), Zn("close", O, () => h(!1)), Z(d, O), Pr()
}
Ln(["click"]);
var jm = function() {
  return jm = Object.assign || function(a) {
    for (var h, y = 1, k = arguments.length; y < k; y++) {
      h = arguments[y];
      for (var E in h) Object.prototype.hasOwnProperty.call(h, E) && (a[E] = h[E])
    }
    return a
  }, jm.apply(this, arguments)
};

function Do(d, a, h, y) {
  function k(E) {
    return E instanceof h ? E : new h(function(b) {
      b(E)
    })
  }
  return new(h || (h = Promise))(function(E, b) {
    function s(G) {
      try {
        O(y.next(G))
      } catch (X) {
        b(X)
      }
    }

    function F(G) {
      try {
        O(y.throw(G))
      } catch (X) {
        b(X)
      }
    }

    function O(G) {
      G.done ? E(G.value) : k(G.value).then(s, F)
    }
    O((y = y.apply(d, a || [])).next())
  })
}

function Ro(d, a) {
  var h = {
      label: 0,
      sent: function() {
        if (E[0] & 1) throw E[1];
        return E[1]
      },
      trys: [],
      ops: []
    },
    y, k, E, b = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return b.next = s(0), b.throw = s(1), b.return = s(2), typeof Symbol == "function" && (b[Symbol.iterator] = function() {
    return this
  }), b;

  function s(O) {
    return function(G) {
      return F([O, G])
    }
  }

  function F(O) {
    if (y) throw new TypeError("Generator is already executing.");
    for (; b && (b = 0, O[0] && (h = 0)), h;) try {
      if (y = 1, k && (E = O[0] & 2 ? k.return : O[0] ? k.throw || ((E = k.return) && E.call(k), 0) : k.next) && !(E = E.call(k, O[1])).done) return E;
      switch (k = 0, E && (O = [O[0] & 2, E.value]), O[0]) {
        case 0:
        case 1:
          E = O;
          break;
        case 4:
          return h.label++, {
            value: O[1],
            done: !1
          };
        case 5:
          h.label++, k = O[1], O = [0];
          continue;
        case 7:
          O = h.ops.pop(), h.trys.pop();
          continue;
        default:
          if (E = h.trys, !(E = E.length > 0 && E[E.length - 1]) && (O[0] === 6 || O[0] === 2)) {
            h = 0;
            continue
          }
          if (O[0] === 3 && (!E || O[1] > E[0] && O[1] < E[3])) {
            h.label = O[1];
            break
          }
          if (O[0] === 6 && h.label < E[1]) {
            h.label = E[1], E = O;
            break
          }
          if (E && h.label < E[2]) {
            h.label = E[2], h.ops.push(O);
            break
          }
          E[2] && h.ops.pop(), h.trys.pop();
          continue
      }
      O = a.call(d, h)
    } catch (G) {
      O = [6, G], k = 0
    } finally {
      y = E = 0
    }
    if (O[0] & 5) throw O[1];
    return {
      value: O[0] ? O[1] : void 0,
      done: !0
    }
  }
}

function ay(d, a, h) {
  if (h || arguments.length === 2)
    for (var y = 0, k = a.length, E; y < k; y++)(E || !(y in a)) && (E || (E = Array.prototype.slice.call(a, 0, y)), E[y] = a[y]);
  return d.concat(E || Array.prototype.slice.call(a))
}
var oy = "4.6.2";

function yp(d, a) {
  return new Promise(function(h) {
    return setTimeout(h, d, a)
  })
}

function OL() {
  return new Promise(function(d) {
    var a = new MessageChannel;
    a.port1.onmessage = function() {
      return d()
    }, a.port2.postMessage(null)
  })
}

function jL(d, a) {
  a === void 0 && (a = 1 / 0);
  var h = window.requestIdleCallback;
  return h ? new Promise(function(y) {
    return h.call(window, function() {
      return y()
    }, {
      timeout: a
    })
  }) : yp(Math.min(d, a))
}

function sy(d) {
  return !!d && typeof d.then == "function"
}

function Ov(d, a) {
  try {
    var h = d();
    sy(h) ? h.then(function(y) {
      return a(!0, y)
    }, function(y) {
      return a(!1, y)
    }) : a(!0, h)
  } catch (y) {
    a(!1, y)
  }
}

function jv(d, a, h) {
  return h === void 0 && (h = 16), Do(this, void 0, void 0, function() {
    var y, k, E, b;
    return Ro(this, function(s) {
      switch (s.label) {
        case 0:
          y = Array(d.length), k = Date.now(), E = 0, s.label = 1;
        case 1:
          return E < d.length ? (y[E] = a(d[E], E), b = Date.now(), b >= k + h ? (k = b, [4, OL()]) : [3, 3]) : [3, 4];
        case 2:
          s.sent(), s.label = 3;
        case 3:
          return ++E, [3, 1];
        case 4:
          return [2, y]
      }
    })
  })
}

function rh(d) {
  return d.then(void 0, function() {}), d
}

function NL(d, a) {
  for (var h = 0, y = d.length; h < y; ++h)
    if (d[h] === a) return !0;
  return !1
}

function ZL(d, a) {
  return !NL(d, a)
}

function __(d) {
  return parseInt(d)
}

function ho(d) {
  return parseFloat(d)
}

function ns(d, a) {
  return typeof d == "number" && isNaN(d) ? a : d
}

function ca(d) {
  return d.reduce(function(a, h) {
    return a + (h ? 1 : 0)
  }, 0)
}

function ly(d, a) {
  if (a === void 0 && (a = 1), Math.abs(a) >= 1) return Math.round(d / a) * a;
  var h = 1 / a;
  return Math.round(d * h) / h
}

function VL(d) {
  for (var a, h, y = "Unexpected syntax '".concat(d, "'"), k = /^\s*([a-z-]*)(.*)$/i.exec(d), E = k[1] || void 0, b = {}, s = /([.:#][\w-]+|\[.+?\])/gi, F = function(Q, W) {
      b[Q] = b[Q] || [], b[Q].push(W)
    };;) {
    var O = s.exec(k[2]);
    if (!O) break;
    var G = O[0];
    switch (G[0]) {
      case ".":
        F("class", G.slice(1));
        break;
      case "#":
        F("id", G.slice(1));
        break;
      case "[": {
        var X = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(G);
        if (X) F(X[1], (h = (a = X[4]) !== null && a !== void 0 ? a : X[5]) !== null && h !== void 0 ? h : "");
        else throw new Error(y);
        break
      }
      default:
        throw new Error(y)
    }
  }
  return [E, b]
}

function qL(d) {
  for (var a = new Uint8Array(d.length), h = 0; h < d.length; h++) {
    var y = d.charCodeAt(h);
    if (y > 127) return new TextEncoder().encode(d);
    a[h] = y
  }
  return a
}

function Rs(d, a) {
  var h = d[0] >>> 16,
    y = d[0] & 65535,
    k = d[1] >>> 16,
    E = d[1] & 65535,
    b = a[0] >>> 16,
    s = a[0] & 65535,
    F = a[1] >>> 16,
    O = a[1] & 65535,
    G = 0,
    X = 0,
    Q = 0,
    W = 0;
  W += E + O, Q += W >>> 16, W &= 65535, Q += k + F, X += Q >>> 16, Q &= 65535, X += y + s, G += X >>> 16, X &= 65535, G += h + b, G &= 65535, d[0] = G << 16 | X, d[1] = Q << 16 | W
}

function Ha(d, a) {
  var h = d[0] >>> 16,
    y = d[0] & 65535,
    k = d[1] >>> 16,
    E = d[1] & 65535,
    b = a[0] >>> 16,
    s = a[0] & 65535,
    F = a[1] >>> 16,
    O = a[1] & 65535,
    G = 0,
    X = 0,
    Q = 0,
    W = 0;
  W += E * O, Q += W >>> 16, W &= 65535, Q += k * O, X += Q >>> 16, Q &= 65535, Q += E * F, X += Q >>> 16, Q &= 65535, X += y * O, G += X >>> 16, X &= 65535, X += k * F, G += X >>> 16, X &= 65535, X += E * s, G += X >>> 16, X &= 65535, G += h * O + y * F + k * s + E * b, G &= 65535, d[0] = G << 16 | X, d[1] = Q << 16 | W
}

function wc(d, a) {
  var h = d[0];
  a %= 64, a === 32 ? (d[0] = d[1], d[1] = h) : a < 32 ? (d[0] = h << a | d[1] >>> 32 - a, d[1] = d[1] << a | h >>> 32 - a) : (a -= 32, d[0] = d[1] << a | h >>> 32 - a, d[1] = h << a | d[1] >>> 32 - a)
}

function Fa(d, a) {
  a %= 64, a !== 0 && (a < 32 ? (d[0] = d[1] >>> 32 - a, d[1] = d[1] << a) : (d[0] = d[1] << a - 32, d[1] = 0))
}

function ti(d, a) {
  d[0] ^= a[0], d[1] ^= a[1]
}
var UL = [4283543511, 3981806797],
  $L = [3301882366, 444984403];

function Nv(d) {
  var a = [0, d[0] >>> 1];
  ti(d, a), Ha(d, UL), a[1] = d[0] >>> 1, ti(d, a), Ha(d, $L), a[1] = d[0] >>> 1, ti(d, a)
}
var rp = [2277735313, 289559509],
  np = [1291169091, 658871167],
  Zv = [0, 5],
  GL = [0, 1390208809],
  WL = [0, 944331445];

function HL(d, a) {
  var h = qL(d);
  a = a || 0;
  var y = [0, h.length],
    k = y[1] % 16,
    E = y[1] - k,
    b = [0, a],
    s = [0, a],
    F = [0, 0],
    O = [0, 0],
    G;
  for (G = 0; G < E; G = G + 16) F[0] = h[G + 4] | h[G + 5] << 8 | h[G + 6] << 16 | h[G + 7] << 24, F[1] = h[G] | h[G + 1] << 8 | h[G + 2] << 16 | h[G + 3] << 24, O[0] = h[G + 12] | h[G + 13] << 8 | h[G + 14] << 16 | h[G + 15] << 24, O[1] = h[G + 8] | h[G + 9] << 8 | h[G + 10] << 16 | h[G + 11] << 24, Ha(F, rp), wc(F, 31), Ha(F, np), ti(b, F), wc(b, 27), Rs(b, s), Ha(b, Zv), Rs(b, GL), Ha(O, np), wc(O, 33), Ha(O, rp), ti(s, O), wc(s, 31), Rs(s, b), Ha(s, Zv), Rs(s, WL);
  F[0] = 0, F[1] = 0, O[0] = 0, O[1] = 0;
  var X = [0, 0];
  switch (k) {
    case 15:
      X[1] = h[G + 14], Fa(X, 48), ti(O, X);
    case 14:
      X[1] = h[G + 13], Fa(X, 40), ti(O, X);
    case 13:
      X[1] = h[G + 12], Fa(X, 32), ti(O, X);
    case 12:
      X[1] = h[G + 11], Fa(X, 24), ti(O, X);
    case 11:
      X[1] = h[G + 10], Fa(X, 16), ti(O, X);
    case 10:
      X[1] = h[G + 9], Fa(X, 8), ti(O, X);
    case 9:
      X[1] = h[G + 8], ti(O, X), Ha(O, np), wc(O, 33), Ha(O, rp), ti(s, O);
    case 8:
      X[1] = h[G + 7], Fa(X, 56), ti(F, X);
    case 7:
      X[1] = h[G + 6], Fa(X, 48), ti(F, X);
    case 6:
      X[1] = h[G + 5], Fa(X, 40), ti(F, X);
    case 5:
      X[1] = h[G + 4], Fa(X, 32), ti(F, X);
    case 4:
      X[1] = h[G + 3], Fa(X, 24), ti(F, X);
    case 3:
      X[1] = h[G + 2], Fa(X, 16), ti(F, X);
    case 2:
      X[1] = h[G + 1], Fa(X, 8), ti(F, X);
    case 1:
      X[1] = h[G], ti(F, X), Ha(F, rp), wc(F, 31), Ha(F, np), ti(b, F)
  }
  return ti(b, y), ti(s, y), Rs(b, s), Rs(s, b), Nv(b), Nv(s), Rs(b, s), Rs(s, b), ("00000000" + (b[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (b[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[1] >>> 0).toString(16)).slice(-8)
}

function JL(d) {
  var a;
  return jm({
    name: d.name,
    message: d.message,
    stack: (a = d.stack) === null || a === void 0 ? void 0 : a.split(`
`)
  }, d)
}

function XL(d) {
  return /^function\s.*?\{\s*\[native code]\s*}$/.test(String(d))
}

function YL(d) {
  return typeof d != "function"
}

function KL(d, a) {
  var h = rh(new Promise(function(y) {
    var k = Date.now();
    Ov(d.bind(null, a), function() {
      for (var E = [], b = 0; b < arguments.length; b++) E[b] = arguments[b];
      var s = Date.now() - k;
      if (!E[0]) return y(function() {
        return {
          error: E[1],
          duration: s
        }
      });
      var F = E[1];
      if (YL(F)) return y(function() {
        return {
          value: F,
          duration: s
        }
      });
      y(function() {
        return new Promise(function(O) {
          var G = Date.now();
          Ov(F, function() {
            for (var X = [], Q = 0; Q < arguments.length; Q++) X[Q] = arguments[Q];
            var W = s + Date.now() - G;
            if (!X[0]) return O({
              error: X[1],
              duration: W
            });
            O({
              value: X[1],
              duration: W
            })
          })
        })
      })
    })
  }));
  return function() {
    return h.then(function(k) {
      return k()
    })
  }
}

function QL(d, a, h, y) {
  var k = Object.keys(d).filter(function(b) {
      return ZL(h, b)
    }),
    E = rh(jv(k, function(b) {
      return KL(d[b], a)
    }, y));
  return function() {
    return Do(this, void 0, void 0, function() {
      var s, F, O, G, X;
      return Ro(this, function(Q) {
        switch (Q.label) {
          case 0:
            return [4, E];
          case 1:
            return s = Q.sent(), [4, jv(s, function(W) {
              return rh(W())
            }, y)];
          case 2:
            return F = Q.sent(), [4, Promise.all(F)];
          case 3:
            for (O = Q.sent(), G = {}, X = 0; X < k.length; ++X) G[k[X]] = O[X];
            return [2, G]
        }
      })
    })
  }
}

function cy() {
  var d = window,
    a = navigator;
  return ca(["MSCSSMatrix" in d, "msSetImmediate" in d, "msIndexedDB" in d, "msMaxTouchPoints" in a, "msPointerEnabled" in a]) >= 4
}

function eD() {
  var d = window,
    a = navigator;
  return ca(["msWriteProfilerMark" in d, "MSStream" in d, "msLaunchUri" in a, "msSaveBlob" in a]) >= 3 && !cy()
}

function $h() {
  var d = window,
    a = navigator;
  return ca(["webkitPersistentStorage" in a, "webkitTemporaryStorage" in a, (a.vendor || "").indexOf("Google") === 0, "webkitResolveLocalFileSystemURL" in d, "BatteryManager" in d, "webkitMediaStream" in d, "webkitSpeechGrammar" in d]) >= 5
}

function _o() {
  var d = window,
    a = navigator;
  return ca(["ApplePayError" in d, "CSSPrimitiveValue" in d, "Counter" in d, a.vendor.indexOf("Apple") === 0, "RGBColor" in d, "WebKitMediaKeys" in d]) >= 4
}

function g_() {
  var d = window,
    a = d.HTMLElement,
    h = d.Document;
  return ca(["safari" in d, !("ongestureend" in d), !("TouchEvent" in d), !("orientation" in d), a && !("autocapitalize" in a.prototype), h && "pointerLockElement" in h.prototype]) >= 4
}

function Gh() {
  var d = window;
  return XL(d.print) && String(d.browser) === "[object WebPageNamespace]"
}

function uy() {
  var d, a, h = window;
  return ca(["buildID" in navigator, "MozAppearance" in ((a = (d = document.documentElement) === null || d === void 0 ? void 0 : d.style) !== null && a !== void 0 ? a : {}), "onmozfullscreenchange" in h, "mozInnerScreenX" in h, "CSSMozDocumentRule" in h, "CanvasCaptureMediaStream" in h]) >= 4
}

function tD() {
  var d = window;
  return ca([!("MediaSettingsRange" in d), "RTCEncodedAudioFrame" in d, "" + d.Intl == "[object Intl]", "" + d.Reflect == "[object Reflect]"]) >= 3
}

function rD() {
  var d = window,
    a = d.URLPattern;
  return ca(["union" in Set.prototype, "Iterator" in d, a && "hasRegExpGroups" in a.prototype, "RGB8" in WebGLRenderingContext.prototype]) >= 3
}

function nD() {
  var d = window;
  return ca(["DOMRectList" in d, "RTCPeerConnectionIceEvent" in d, "SVGGeometryElement" in d, "ontransitioncancel" in d]) >= 3
}

function Wh() {
  var d = window,
    a = navigator,
    h = d.CSS,
    y = d.HTMLButtonElement;
  return ca([!("getStorageUpdates" in a), y && "popover" in y.prototype, "CSSCounterStyleRule" in d, h.supports("font-size-adjust: ex-height 0.5"), h.supports("text-transform: full-width")]) >= 4
}

function iD() {
  if (navigator.platform === "iPad") return !0;
  var d = screen,
    a = d.width / d.height;
  return ca(["MediaSource" in window, !!Element.prototype.webkitRequestFullscreen, a > .65 && a < 1.53]) >= 2
}

function aD() {
  var d = document;
  return d.fullscreenElement || d.msFullscreenElement || d.mozFullScreenElement || d.webkitFullscreenElement || null
}

function oD() {
  var d = document;
  return (d.exitFullscreen || d.msExitFullscreen || d.mozCancelFullScreen || d.webkitExitFullscreen).call(d)
}

function v_() {
  var d = $h(),
    a = uy(),
    h = window,
    y = navigator,
    k = "connection";
  return d ? ca([!("SharedWorker" in h), y[k] && "ontypechange" in y[k], !("sinkId" in new Audio)]) >= 2 : a ? ca(["onorientationchange" in h, "orientation" in h, /android/i.test(y.appVersion)]) >= 2 : !1
}

function sD() {
  var d = navigator,
    a = window,
    h = Audio.prototype,
    y = a.visualViewport;
  return ca(["srLatency" in h, "srChannelCount" in h, "devicePosture" in d, y && "segments" in y, "getTextInformation" in Image.prototype]) >= 3
}

function lD() {
  return hD() ? -4 : cD()
}

function cD() {
  var d = window,
    a = d.OfflineAudioContext || d.webkitOfflineAudioContext;
  if (!a) return -2;
  if (uD()) return -1;
  var h = 4500,
    y = 5e3,
    k = new a(1, y, 44100),
    E = k.createOscillator();
  E.type = "triangle", E.frequency.value = 1e4;
  var b = k.createDynamicsCompressor();
  b.threshold.value = -50, b.knee.value = 40, b.ratio.value = 12, b.attack.value = 0, b.release.value = .25, E.connect(b), b.connect(k.destination), E.start(0);
  var s = dD(k),
    F = s[0],
    O = s[1],
    G = rh(F.then(function(X) {
      return pD(X.getChannelData(0).subarray(h))
    }, function(X) {
      if (X.name === "timeout" || X.name === "suspended") return -3;
      throw X
    }));
  return function() {
    return O(), G
  }
}

function uD() {
  return _o() && !g_() && !nD()
}

function hD() {
  return _o() && Wh() && Gh() || $h() && sD() && rD()
}

function dD(d) {
  var a = 3,
    h = 500,
    y = 500,
    k = 5e3,
    E = function() {},
    b = new Promise(function(s, F) {
      var O = !1,
        G = 0,
        X = 0;
      d.oncomplete = function(de) {
        return s(de.renderedBuffer)
      };
      var Q = function() {
          setTimeout(function() {
            return F(Vv("timeout"))
          }, Math.min(y, X + k - Date.now()))
        },
        W = function() {
          try {
            var de = d.startRendering();
            switch (sy(de) && rh(de), d.state) {
              case "running":
                X = Date.now(), O && Q();
                break;
              case "suspended":
                document.hidden || G++, O && G >= a ? F(Vv("suspended")) : setTimeout(W, h);
                break
            }
          } catch (_e) {
            F(_e)
          }
        };
      W(), E = function() {
        O || (O = !0, X > 0 && Q())
      }
    });
  return [b, E]
}

function pD(d) {
  for (var a = 0, h = 0; h < d.length; ++h) a += Math.abs(d[h]);
  return a
}

function Vv(d) {
  var a = new Error(d);
  return a.name = d, a
}

function hy(d, a, h) {
  var y, k, E;
  return h === void 0 && (h = 50), Do(this, void 0, void 0, function() {
    var b, s;
    return Ro(this, function(F) {
      switch (F.label) {
        case 0:
          b = document, F.label = 1;
        case 1:
          return b.body ? [3, 3] : [4, yp(h)];
        case 2:
          return F.sent(), [3, 1];
        case 3:
          s = b.createElement("iframe"), F.label = 4;
        case 4:
          return F.trys.push([4, , 10, 11]), [4, new Promise(function(O, G) {
            var X = !1,
              Q = function() {
                X = !0, O()
              },
              W = function(Ae) {
                X = !0, G(Ae)
              };
            s.onload = Q, s.onerror = W;
            var de = s.style;
            de.setProperty("display", "block", "important"), de.position = "absolute", de.top = "0", de.left = "0", de.visibility = "hidden", a && "srcdoc" in s ? s.srcdoc = a : s.src = "about:blank", b.body.appendChild(s);
            var _e = function() {
              var Ae, xe;
              X || (((xe = (Ae = s.contentWindow) === null || Ae === void 0 ? void 0 : Ae.document) === null || xe === void 0 ? void 0 : xe.readyState) === "complete" ? Q() : setTimeout(_e, 10))
            };
            _e()
          })];
        case 5:
          F.sent(), F.label = 6;
        case 6:
          return !((k = (y = s.contentWindow) === null || y === void 0 ? void 0 : y.document) === null || k === void 0) && k.body ? [3, 8] : [4, yp(h)];
        case 7:
          return F.sent(), [3, 6];
        case 8:
          return [4, d(s, s.contentWindow)];
        case 9:
          return [2, F.sent()];
        case 10:
          return (E = s.parentNode) === null || E === void 0 || E.removeChild(s), [7];
        case 11:
          return [2]
      }
    })
  })
}

function fD(d) {
  for (var a = VL(d), h = a[0], y = a[1], k = document.createElement(h ?? "div"), E = 0, b = Object.keys(y); E < b.length; E++) {
    var s = b[E],
      F = y[s].join(" ");
    s === "style" ? mD(k.style, F) : k.setAttribute(s, F)
  }
  return k
}

function mD(d, a) {
  for (var h = 0, y = a.split(";"); h < y.length; h++) {
    var k = y[h],
      E = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(k);
    if (E) {
      var b = E[1],
        s = E[2],
        F = E[4];
      d.setProperty(b, s, F || "")
    }
  }
}

function _D() {
  for (var d = window;;) {
    var a = d.parent;
    if (!a || a === d) return !1;
    try {
      if (a.location.origin !== d.location.origin) return !0
    } catch (h) {
      if (h instanceof Error && h.name === "SecurityError") return !0;
      throw h
    }
    d = a
  }
}
var gD = "mmMwWLliI0O&1",
  vD = "48px",
  Cc = ["monospace", "sans-serif", "serif"],
  qv = ["sans-serif-thin", "ARNO PRO", "Agency FB", "Arabic Typesetting", "Arial Unicode MS", "AvantGarde Bk BT", "BankGothic Md BT", "Batang", "Bitstream Vera Sans Mono", "Calibri", "Century", "Century Gothic", "Clarendon", "EUROSTILE", "Franklin Gothic", "Futura Bk BT", "Futura Md BT", "GOTHAM", "Gill Sans", "HELV", "Haettenschweiler", "Helvetica Neue", "Humanst521 BT", "Leelawadee", "Letter Gothic", "Levenim MT", "Lucida Bright", "Lucida Sans", "Menlo", "MS Mincho", "MS Outlook", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MYRIAD PRO", "Marlett", "Meiryo UI", "Microsoft Uighur", "Minion Pro", "Monotype Corsiva", "PMingLiU", "Pristina", "SCRIPTINA", "Segoe UI Light", "Serifa", "SimHei", "Small Fonts", "Staccato222 BT", "TRAJAN PRO", "Univers CE 55 Medium", "Vrinda", "ZWAdobeF"];

function yD() {
  var d = this;
  return hy(function(a, h) {
    var y = h.document;
    return Do(d, void 0, void 0, function() {
      var k, E, b, s, F, O, G, X, Q, W, de, _e;
      return Ro(this, function(Ae) {
        for (k = y.body, k.style.fontSize = vD, E = y.createElement("div"), E.style.setProperty("visibility", "hidden", "important"), b = {}, s = {}, F = function(xe) {
            var Ie = y.createElement("span"),
              Pe = Ie.style;
            return Pe.position = "absolute", Pe.top = "0", Pe.left = "0", Pe.fontFamily = xe, Ie.textContent = gD, E.appendChild(Ie), Ie
          }, O = function(xe, Ie) {
            return F("'".concat(xe, "',").concat(Ie))
          }, G = function() {
            return Cc.map(F)
          }, X = function() {
            for (var xe = {}, Ie = function(tt) {
                xe[tt] = Cc.map(function(Ve) {
                  return O(tt, Ve)
                })
              }, Pe = 0, De = qv; Pe < De.length; Pe++) {
              var $e = De[Pe];
              Ie($e)
            }
            return xe
          }, Q = function(xe) {
            return Cc.some(function(Ie, Pe) {
              return xe[Pe].offsetWidth !== b[Ie] || xe[Pe].offsetHeight !== s[Ie]
            })
          }, W = G(), de = X(), k.appendChild(E), _e = 0; _e < Cc.length; _e++) b[Cc[_e]] = W[_e].offsetWidth, s[Cc[_e]] = W[_e].offsetHeight;
        return [2, qv.filter(function(xe) {
          return Q(de[xe])
        })]
      })
    })
  })
}

function xD() {
  var d = navigator.plugins;
  if (d) {
    for (var a = [], h = 0; h < d.length; ++h) {
      var y = d[h];
      if (y) {
        for (var k = [], E = 0; E < y.length; ++E) {
          var b = y[E];
          k.push({
            type: b.type,
            suffixes: b.suffixes
          })
        }
        a.push({
          name: y.name,
          description: y.description,
          mimeTypes: k
        })
      }
    }
    return a
  }
}

function bD() {
  return wD(MD())
}

function wD(d) {
  var a, h = !1,
    y, k, E = CD(),
    b = E[0],
    s = E[1];
  return TD(b, s) ? (h = SD(s), d ? y = k = "skipped" : (a = ID(b, s), y = a[0], k = a[1])) : y = k = "unsupported", {
    winding: h,
    geometry: y,
    text: k
  }
}

function CD() {
  var d = document.createElement("canvas");
  return d.width = 1, d.height = 1, [d, d.getContext("2d")]
}

function TD(d, a) {
  return !!(a && d.toDataURL)
}

function SD(d) {
  return d.rect(0, 0, 10, 10), d.rect(2, 2, 6, 6), !d.isPointInPath(5, 5, "evenodd")
}

function ID(d, a) {
  PD(d, a);
  var h = nm(d),
    y = nm(d);
  if (h !== y) return ["unstable", "unstable"];
  kD(d, a);
  var k = nm(d);
  return [k, h]
}

function PD(d, a) {
  d.width = 240, d.height = 60, a.textBaseline = "alphabetic", a.fillStyle = "#f60", a.fillRect(100, 1, 62, 20), a.fillStyle = "#069", a.font = '11pt "Times New Roman"';
  var h = "Cwm fjordbank gly ".concat("😃");
  a.fillText(h, 2, 15), a.fillStyle = "rgba(102, 204, 0, 0.2)", a.font = "18pt Arial", a.fillText(h, 4, 45)
}

function kD(d, a) {
  d.width = 122, d.height = 110, a.globalCompositeOperation = "multiply";
  for (var h = 0, y = [
      ["#f2f", 40, 40],
      ["#2ff", 80, 40],
      ["#ff2", 60, 80]
    ]; h < y.length; h++) {
    var k = y[h],
      E = k[0],
      b = k[1],
      s = k[2];
    a.fillStyle = E, a.beginPath(), a.arc(b, s, 40, 0, Math.PI * 2, !0), a.closePath(), a.fill()
  }
  a.fillStyle = "#f9c", a.arc(60, 60, 60, 0, Math.PI * 2, !0), a.arc(60, 60, 20, 0, Math.PI * 2, !0), a.fill("evenodd")
}

function nm(d) {
  return d.toDataURL()
}

function MD() {
  return _o() && Wh() && Gh()
}

function AD() {
  var d = navigator,
    a = 0,
    h;
  d.maxTouchPoints !== void 0 ? a = __(d.maxTouchPoints) : d.msMaxTouchPoints !== void 0 && (a = d.msMaxTouchPoints);
  try {
    document.createEvent("TouchEvent"), h = !0
  } catch {
    h = !1
  }
  var y = "ontouchstart" in window;
  return {
    maxTouchPoints: a,
    touchEvent: h,
    touchStart: y
  }
}

function ED() {
  return navigator.oscpu
}

function zD() {
  var d = navigator,
    a = [],
    h = d.language || d.userLanguage || d.browserLanguage || d.systemLanguage;
  if (h !== void 0 && a.push([h]), Array.isArray(d.languages)) $h() && tD() || a.push(d.languages);
  else if (typeof d.languages == "string") {
    var y = d.languages;
    y && a.push(y.split(","))
  }
  return a
}

function LD() {
  return window.screen.colorDepth
}

function DD() {
  return ns(ho(navigator.deviceMemory), void 0)
}

function RD() {
  if (!(_o() && Wh() && Gh())) return BD()
}

function BD() {
  var d = screen,
    a = function(y) {
      return ns(__(y), null)
    },
    h = [a(d.width), a(d.height)];
  return h.sort().reverse(), h
}
var FD = 2500,
  OD = 10,
  pp, im;

function jD() {
  if (im === void 0) {
    var d = function() {
      var a = Nm();
      Zm(a) ? im = setTimeout(d, FD) : (pp = a, im = void 0)
    };
    d()
  }
}

function ND() {
  var d = this;
  return jD(),
    function() {
      return Do(d, void 0, void 0, function() {
        var a;
        return Ro(this, function(h) {
          switch (h.label) {
            case 0:
              return a = Nm(), Zm(a) ? pp ? [2, ay([], pp, !0)] : aD() ? [4, oD()] : [3, 2] : [3, 2];
            case 1:
              h.sent(), a = Nm(), h.label = 2;
            case 2:
              return Zm(a) || (pp = a), [2, a]
          }
        })
      })
    }
}

function ZD() {
  var d = this;
  if (_o() && Wh() && Gh()) return function() {
    return Promise.resolve(void 0)
  };
  var a = ND();
  return function() {
    return Do(d, void 0, void 0, function() {
      var h, y;
      return Ro(this, function(k) {
        switch (k.label) {
          case 0:
            return [4, a()];
          case 1:
            return h = k.sent(), y = function(E) {
              return E === null ? null : ly(E, OD)
            }, [2, [y(h[0]), y(h[1]), y(h[2]), y(h[3])]]
        }
      })
    })
  }
}

function Nm() {
  var d = screen;
  return [ns(ho(d.availTop), null), ns(ho(d.width) - ho(d.availWidth) - ns(ho(d.availLeft), 0), null), ns(ho(d.height) - ho(d.availHeight) - ns(ho(d.availTop), 0), null), ns(ho(d.availLeft), null)]
}

function Zm(d) {
  for (var a = 0; a < 4; ++a)
    if (d[a]) return !1;
  return !0
}

function VD() {
  return ns(__(navigator.hardwareConcurrency), void 0)
}

function qD() {
  var d, a = (d = window.Intl) === null || d === void 0 ? void 0 : d.DateTimeFormat;
  if (a) {
    var h = new a().resolvedOptions().timeZone;
    if (h) return h
  }
  var y = -UD();
  return "UTC".concat(y >= 0 ? "+" : "").concat(y)
}

function UD() {
  var d = new Date().getFullYear();
  return Math.max(ho(new Date(d, 0, 1).getTimezoneOffset()), ho(new Date(d, 6, 1).getTimezoneOffset()))
}

function $D() {
  try {
    return !!window.sessionStorage
  } catch {
    return !0
  }
}

function GD() {
  try {
    return !!window.localStorage
  } catch {
    return !0
  }
}

function WD() {
  if (!(cy() || eD())) try {
    return !!window.indexedDB
  } catch {
    return !0
  }
}

function HD() {
  return !!window.openDatabase
}

function JD() {
  return navigator.cpuClass
}

function XD() {
  var d = navigator.platform;
  return d === "MacIntel" && _o() && !g_() ? iD() ? "iPad" : "iPhone" : d
}

function YD() {
  return navigator.vendor || ""
}

function KD() {
  for (var d = [], a = 0, h = ["chrome", "safari", "__crWeb", "__gCrWeb", "yandex", "__yb", "__ybro", "__firefox__", "__edgeTrackingPreventionStatistics", "webkit", "oprt", "samsungAr", "ucweb", "UCShellJava", "puffinDevice"]; a < h.length; a++) {
    var y = h[a],
      k = window[y];
    k && typeof k == "object" && d.push(y)
  }
  return d.sort()
}

function QD() {
  var d = document;
  try {
    d.cookie = "cookietest=1; SameSite=Strict;";
    var a = d.cookie.indexOf("cookietest=") !== -1;
    return d.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", a
  } catch {
    return !1
  }
}

function eR() {
  var d = atob;
  return {
    abpIndo: ["#Iklan-Melayang", "#Kolom-Iklan-728", "#SidebarIklan-wrapper", '[title="ALIENBOLA" i]', d("I0JveC1CYW5uZXItYWRz")],
    abpvn: [".quangcao", "#mobileCatfish", d("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
    adBlockFinland: [".mainostila", d("LnNwb25zb3JpdA=="), ".ylamainos", d("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"), d("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")],
    adBlockPersian: ["#navbar_notice_50", ".kadr", 'TABLE[width="140px"]', "#divAgahi", d("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")],
    adBlockWarningRemoval: ["#adblock-honeypot", ".adblocker-root", ".wp_adblock_detect", d("LmhlYWRlci1ibG9ja2VkLWFk"), d("I2FkX2Jsb2NrZXI=")],
    adGuardAnnoyances: [".hs-sosyal", "#cookieconsentdiv", 'div[class^="app_gdpr"]', ".as-oil", '[data-cypress="soft-push-notification-modal"]'],
    adGuardBase: [".BetterJsPopOverlay", d("I2FkXzMwMFgyNTA="), d("I2Jhbm5lcmZsb2F0MjI="), d("I2NhbXBhaWduLWJhbm5lcg=="), d("I0FkLUNvbnRlbnQ=")],
    adGuardChinese: [d("LlppX2FkX2FfSA=="), d("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"), "#widget-quan", d("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"), d("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")],
    adGuardFrench: ["#pavePub", d("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"), ".mobile_adhesion", ".widgetadv", d("LmFkc19iYW4=")],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: ["#kauli_yad_1", d("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="), d("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="), d("LmFkZ29vZ2xl"), d("Ll9faXNib29zdFJldHVybkFk")],
    adGuardMobile: [d("YW1wLWF1dG8tYWRz"), d("LmFtcF9hZA=="), 'amp-embed[type="24smi"]', "#mgid_iframe1", d("I2FkX2ludmlld19hcmVh")],
    adGuardRussian: [d("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="), d("LnJlY2xhbWE="), 'div[id^="smi2adblock"]', d("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"), "#psyduckpockeball"],
    adGuardSocial: [d("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="), d("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="), ".etsy-tweet", "#inlineShare", ".popup-social"],
    adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
    adGuardTrackingProtection: ["#qoo-counter", d("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="), d("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="), d("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="), "#top100counter"],
    adGuardTurkish: ["#backkapat", d("I3Jla2xhbWk="), d("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="), d("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"), d("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")],
    bulgarian: [d("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
    easyList: [".yb-floorad", d("LndpZGdldF9wb19hZHNfd2lkZ2V0"), d("LnRyYWZmaWNqdW5reS1hZA=="), ".textad_headline", d("LnNwb25zb3JlZC10ZXh0LWxpbmtz")],
    easyListChina: [d("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="), d("LmZyb250cGFnZUFkdk0="), "#taotaole", "#aafoot.top_box", ".cfa_popup"],
    easyListCookie: [".ezmob-footer", ".cc-CookieWarning", "[data-cookie-number]", d("LmF3LWNvb2tpZS1iYW5uZXI="), ".sygnal24-gdpr-modal-wrap"],
    easyListCzechSlovak: ["#onlajny-stickers", d("I3Jla2xhbW5pLWJveA=="), d("LnJla2xhbWEtbWVnYWJvYXJk"), ".sklik", d("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")],
    easyListDutch: [d("I2FkdmVydGVudGll"), d("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="), ".adstekst", d("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="), "#semilo-lrectangle"],
    easyListGermany: ["#SSpotIMPopSlider", d("LnNwb25zb3JsaW5rZ3J1ZW4="), d("I3dlcmJ1bmdza3k="), d("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"), d("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")],
    easyListItaly: [d("LmJveF9hZHZfYW5udW5jaQ=="), ".sb-box-pubbliredazionale", d("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"), d("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"), d("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")],
    easyListLithuania: [d("LnJla2xhbW9zX3RhcnBhcw=="), d("LnJla2xhbW9zX251b3JvZG9z"), d("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"), d("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"), d("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")],
    estonian: [d("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [".open.pushModal", "#issuem-leaky-paywall-articles-zero-remaining-nag", "#sovrn_container", 'div[class$="-hide"][zoompage-fontsize][style="display: block;"]', ".BlockNag__Card"],
    fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
    frellwitSwedish: [d("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="), d("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="), "article.category-samarbete", d("ZGl2LmhvbGlkQWRz"), "ul.adsmodern"],
    greekAdBlock: [d("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"), d("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="), d("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"), "DIV.agores300", "TABLE.advright"],
    hungarian: ["#cemp_doboz", ".optimonk-iframe-container", d("LmFkX19tYWlu"), d("W2NsYXNzKj0iR29vZ2xlQWRzIl0="), "#hirdetesek_box"],
    iDontCareAboutCookies: ['.alert-info[data-block-track*="CookieNotice"]', ".ModuleTemplateCookieIndicator", ".o--cookies--container", "#cookies-policy-sticky", "#stickyCookieBar"],
    icelandicAbp: [d("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
    latvian: [d("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="), d("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")],
    listKr: [d("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="), d("I2xpdmVyZUFkV3JhcHBlcg=="), d("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="), d("aW5zLmZhc3R2aWV3LWFk"), ".revenue_unit_item.dable"],
    listeAr: [d("LmdlbWluaUxCMUFk"), ".right-and-left-sponsers", d("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="), d("YVtocmVmKj0iYm9vcmFxLm9yZyJd"), d("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")],
    listeFr: [d("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="), d("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="), d("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="), ".site-pub-interstitiel", 'div[id^="crt-"][data-criteo-id]'],
    officialPolish: ["#ceneo-placeholder-ceneo-12", d("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"), d("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="), d("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="), d("ZGl2I3NrYXBpZWNfYWQ=")],
    ro: [d("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"), d("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"), d("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="), d("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"), 'a[href^="/url/"]'],
    ruAd: [d("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"), d("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="), d("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="), "#pgeldiz", ".yandex-rtb-block"],
    thaiAds: ["a[href*=macau-uta-popup]", d("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="), d("LmFkczMwMHM="), ".bumq", ".img-kosana"],
    webAnnoyancesUltralist: ["#mod-social-share-2", "#social-tools", d("LmN0cGwtZnVsbGJhbm5lcg=="), ".zergnet-recommend", ".yt.btn-link.btn-md.btn"]
  }
}

function tR(d) {
  var a = d === void 0 ? {} : d,
    h = a.debug;
  return Do(this, void 0, void 0, function() {
    var y, k, E, b, s, F;
    return Ro(this, function(O) {
      switch (O.label) {
        case 0:
          return rR() ? (y = eR(), k = Object.keys(y), E = (F = []).concat.apply(F, k.map(function(G) {
            return y[G]
          })), [4, nR(E)]) : [2, void 0];
        case 1:
          return b = O.sent(), h && iR(y, b), s = k.filter(function(G) {
            var X = y[G],
              Q = ca(X.map(function(W) {
                return b[W]
              }));
            return Q > X.length * .6
          }), s.sort(), [2, s]
      }
    })
  })
}

function rR() {
  return _o() || v_()
}

function nR(d) {
  var a;
  return Do(this, void 0, void 0, function() {
    var h, y, k, E, F, b, s, F;
    return Ro(this, function(O) {
      switch (O.label) {
        case 0:
          for (h = document, y = h.createElement("div"), k = new Array(d.length), E = {}, Uv(y), F = 0; F < d.length; ++F) b = fD(d[F]), b.tagName === "DIALOG" && b.show(), s = h.createElement("div"), Uv(s), s.appendChild(b), y.appendChild(s), k[F] = b;
          O.label = 1;
        case 1:
          return h.body ? [3, 3] : [4, yp(50)];
        case 2:
          return O.sent(), [3, 1];
        case 3:
          h.body.appendChild(y);
          try {
            for (F = 0; F < d.length; ++F) k[F].offsetParent || (E[d[F]] = !0)
          } finally {
            (a = y.parentNode) === null || a === void 0 || a.removeChild(y)
          }
          return [2, E]
      }
    })
  })
}

function Uv(d) {
  d.style.setProperty("visibility", "hidden", "important"), d.style.setProperty("display", "block", "important")
}

function iR(d, a) {
  for (var h = "DOM blockers debug:\n```", y = 0, k = Object.keys(d); y < k.length; y++) {
    var E = k[y];
    h += `
`.concat(E, ":");
    for (var b = 0, s = d[E]; b < s.length; b++) {
      var F = s[b];
      h += `
  `.concat(a[F] ? "🚫" : "➡️", " ").concat(F)
    }
  }
  console.log("".concat(h, "\n```"))
}

function aR() {
  for (var d = 0, a = ["rec2020", "p3", "srgb"]; d < a.length; d++) {
    var h = a[d];
    if (matchMedia("(color-gamut: ".concat(h, ")")).matches) return h
  }
}

function oR() {
  if ($v("inverted")) return !0;
  if ($v("none")) return !1
}

function $v(d) {
  return matchMedia("(inverted-colors: ".concat(d, ")")).matches
}

function sR() {
  if (Gv("active")) return !0;
  if (Gv("none")) return !1
}

function Gv(d) {
  return matchMedia("(forced-colors: ".concat(d, ")")).matches
}
var lR = 100;

function cR() {
  if (matchMedia("(min-monochrome: 0)").matches) {
    for (var d = 0; d <= lR; ++d)
      if (matchMedia("(max-monochrome: ".concat(d, ")")).matches) return d;
    throw new Error("Too high value")
  }
}

function uR() {
  if (Tc("no-preference")) return 0;
  if (Tc("high") || Tc("more")) return 1;
  if (Tc("low") || Tc("less")) return -1;
  if (Tc("forced")) return 10
}

function Tc(d) {
  return matchMedia("(prefers-contrast: ".concat(d, ")")).matches
}

function hR() {
  if (Wv("reduce")) return !0;
  if (Wv("no-preference")) return !1
}

function Wv(d) {
  return matchMedia("(prefers-reduced-motion: ".concat(d, ")")).matches
}

function dR() {
  if (Hv("reduce")) return !0;
  if (Hv("no-preference")) return !1
}

function Hv(d) {
  return matchMedia("(prefers-reduced-transparency: ".concat(d, ")")).matches
}

function pR() {
  if (Jv("high")) return !0;
  if (Jv("standard")) return !1
}

function Jv(d) {
  return matchMedia("(dynamic-range: ".concat(d, ")")).matches
}
var zn = Math,
  la = function() {
    return 0
  };

function fR() {
  var d = zn.acos || la,
    a = zn.acosh || la,
    h = zn.asin || la,
    y = zn.asinh || la,
    k = zn.atanh || la,
    E = zn.atan || la,
    b = zn.sin || la,
    s = zn.sinh || la,
    F = zn.cos || la,
    O = zn.cosh || la,
    G = zn.tan || la,
    X = zn.tanh || la,
    Q = zn.exp || la,
    W = zn.expm1 || la,
    de = zn.log1p || la,
    _e = function(Re) {
      return zn.pow(zn.PI, Re)
    },
    Ae = function(Re) {
      return zn.log(Re + zn.sqrt(Re * Re - 1))
    },
    xe = function(Re) {
      return zn.log(Re + zn.sqrt(Re * Re + 1))
    },
    Ie = function(Re) {
      return zn.log((1 + Re) / (1 - Re)) / 2
    },
    Pe = function(Re) {
      return zn.exp(Re) - 1 / zn.exp(Re) / 2
    },
    De = function(Re) {
      return (zn.exp(Re) + 1 / zn.exp(Re)) / 2
    },
    $e = function(Re) {
      return zn.exp(Re) - 1
    },
    tt = function(Re) {
      return (zn.exp(2 * Re) - 1) / (zn.exp(2 * Re) + 1)
    },
    Ve = function(Re) {
      return zn.log(1 + Re)
    };
  return {
    acos: d(.12312423423423424),
    acosh: a(1e308),
    acoshPf: Ae(1e154),
    asin: h(.12312423423423424),
    asinh: y(1),
    asinhPf: xe(1),
    atanh: k(.5),
    atanhPf: Ie(.5),
    atan: E(.5),
    sin: b(-1e300),
    sinh: s(1),
    sinhPf: Pe(1),
    cos: F(10.000000000123),
    cosh: O(1),
    coshPf: De(1),
    tan: G(-1e300),
    tanh: X(1),
    tanhPf: tt(1),
    exp: Q(1),
    expm1: W(1),
    expm1Pf: $e(1),
    log1p: de(10),
    log1pPf: Ve(10),
    powPI: _e(-100)
  }
}
var mR = "mmMwWLliI0fiflO&1",
  am = {
    default: [],
    apple: [{
      font: "-apple-system-body"
    }],
    serif: [{
      fontFamily: "serif"
    }],
    sans: [{
      fontFamily: "sans-serif"
    }],
    mono: [{
      fontFamily: "monospace"
    }],
    min: [{
      fontSize: "1px"
    }],
    system: [{
      fontFamily: "system-ui"
    }]
  };

function _R() {
  return gR(function(d, a) {
    for (var h = {}, y = {}, k = 0, E = Object.keys(am); k < E.length; k++) {
      var b = E[k],
        s = am[b],
        F = s[0],
        O = F === void 0 ? {} : F,
        G = s[1],
        X = G === void 0 ? mR : G,
        Q = d.createElement("span");
      Q.textContent = X, Q.style.whiteSpace = "nowrap";
      for (var W = 0, de = Object.keys(O); W < de.length; W++) {
        var _e = de[W],
          Ae = O[_e];
        Ae !== void 0 && (Q.style[_e] = Ae)
      }
      h[b] = Q, a.append(d.createElement("br"), Q)
    }
    for (var xe = 0, Ie = Object.keys(am); xe < Ie.length; xe++) {
      var b = Ie[xe];
      y[b] = h[b].getBoundingClientRect().width
    }
    return y
  })
}

function gR(d, a) {
  return a === void 0 && (a = 4e3), hy(function(h, y) {
    var k = y.document,
      E = k.body,
      b = E.style;
    b.width = "".concat(a, "px"), b.webkitTextSizeAdjust = b.textSizeAdjust = "none", $h() ? E.style.zoom = "".concat(1 / y.devicePixelRatio) : _o() && (E.style.zoom = "reset");
    var s = k.createElement("div");
    return s.textContent = ay([], Array(a / 20 << 0), !0).map(function() {
      return "word"
    }).join(" "), E.appendChild(s), d(k, E)
  }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
}

function vR() {
  return navigator.pdfViewerEnabled
}

function yR() {
  var d = new Float32Array(1),
    a = new Uint8Array(d.buffer);
  return d[0] = 1 / 0, d[0] = d[0] - d[0], a[3]
}

function xR() {
  var d = window.ApplePaySession;
  if (typeof(d == null ? void 0 : d.canMakePayments) != "function") return -1;
  if (bR()) return -3;
  try {
    return d.canMakePayments() ? 1 : 0
  } catch (a) {
    return wR(a)
  }
}
var bR = _D;

function wR(d) {
  if (d instanceof Error && d.name === "InvalidAccessError" && /\bfrom\b.*\binsecure\b/i.test(d.message)) return -2;
  throw d
}

function CR() {
  var d, a = document.createElement("a"),
    h = (d = a.attributionSourceId) !== null && d !== void 0 ? d : a.attributionsourceid;
  return h === void 0 ? void 0 : String(h)
}
var dy = -1,
  py = -2,
  TR = new Set([10752, 2849, 2884, 2885, 2886, 2928, 2929, 2930, 2931, 2932, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2978, 3024, 3042, 3088, 3089, 3106, 3107, 32773, 32777, 32777, 32823, 32824, 32936, 32937, 32938, 32939, 32968, 32969, 32970, 32971, 3317, 33170, 3333, 3379, 3386, 33901, 33902, 34016, 34024, 34076, 3408, 3410, 3411, 3412, 3413, 3414, 3415, 34467, 34816, 34817, 34818, 34819, 34877, 34921, 34930, 35660, 35661, 35724, 35738, 35739, 36003, 36004, 36005, 36347, 36348, 36349, 37440, 37441, 37443, 7936, 7937, 7938]),
  SR = new Set([34047, 35723, 36063, 34852, 34853, 34854, 34229, 36392, 36795, 38449]),
  IR = ["FRAGMENT_SHADER", "VERTEX_SHADER"],
  PR = ["LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT", "LOW_INT", "MEDIUM_INT", "HIGH_INT"],
  fy = "WEBGL_debug_renderer_info",
  kR = "WEBGL_polygon_mode";

function MR(d) {
  var a, h, y, k, E, b, s = d.cache,
    F = my(s);
  if (!F) return dy;
  if (!gy(F)) return py;
  var O = _y() ? null : F.getExtension(fy);
  return {
    version: ((a = F.getParameter(F.VERSION)) === null || a === void 0 ? void 0 : a.toString()) || "",
    vendor: ((h = F.getParameter(F.VENDOR)) === null || h === void 0 ? void 0 : h.toString()) || "",
    vendorUnmasked: O ? (y = F.getParameter(O.UNMASKED_VENDOR_WEBGL)) === null || y === void 0 ? void 0 : y.toString() : "",
    renderer: ((k = F.getParameter(F.RENDERER)) === null || k === void 0 ? void 0 : k.toString()) || "",
    rendererUnmasked: O ? (E = F.getParameter(O.UNMASKED_RENDERER_WEBGL)) === null || E === void 0 ? void 0 : E.toString() : "",
    shadingLanguageVersion: ((b = F.getParameter(F.SHADING_LANGUAGE_VERSION)) === null || b === void 0 ? void 0 : b.toString()) || ""
  }
}

function AR(d) {
  var a = d.cache,
    h = my(a);
  if (!h) return dy;
  if (!gy(h)) return py;
  var y = h.getSupportedExtensions(),
    k = h.getContextAttributes(),
    E = [],
    b = [],
    s = [],
    F = [],
    O = [];
  if (k)
    for (var G = 0, X = Object.keys(k); G < X.length; G++) {
      var Q = X[G];
      b.push("".concat(Q, "=").concat(k[Q]))
    }
  for (var W = Xv(h), de = 0, _e = W; de < _e.length; de++) {
    var Ae = _e[de],
      xe = h[Ae];
    s.push("".concat(Ae, "=").concat(xe).concat(TR.has(xe) ? "=".concat(h.getParameter(xe)) : ""))
  }
  if (y)
    for (var Ie = 0, Pe = y; Ie < Pe.length; Ie++) {
      var De = Pe[Ie];
      if (!(De === fy && _y() || De === kR && LR())) {
        var $e = h.getExtension(De);
        if (!$e) {
          E.push(De);
          continue
        }
        for (var tt = 0, Ve = Xv($e); tt < Ve.length; tt++) {
          var Ae = Ve[tt],
            xe = $e[Ae];
          F.push("".concat(Ae, "=").concat(xe).concat(SR.has(xe) ? "=".concat(h.getParameter(xe)) : ""))
        }
      }
    }
  for (var Re = 0, Ue = IR; Re < Ue.length; Re++)
    for (var Ce = Ue[Re], We = 0, Je = PR; We < Je.length; We++) {
      var Ge = Je[We],
        Ee = ER(h, Ce, Ge);
      O.push("".concat(Ce, ".").concat(Ge, "=").concat(Ee.join(",")))
    }
  return F.sort(), s.sort(), {
    contextAttributes: b,
    parameters: s,
    shaderPrecisions: O,
    extensions: y,
    extensionParameters: F,
    unsupportedExtensions: E
  }
}

function my(d) {
  if (d.webgl) return d.webgl.context;
  var a = document.createElement("canvas"),
    h;
  a.addEventListener("webglCreateContextError", function() {
    return h = void 0
  });
  for (var y = 0, k = ["webgl", "experimental-webgl"]; y < k.length; y++) {
    var E = k[y];
    try {
      h = a.getContext(E)
    } catch {}
    if (h) break
  }
  return d.webgl = {
    context: h
  }, h
}

function ER(d, a, h) {
  var y = d.getShaderPrecisionFormat(d[a], d[h]);
  return y ? [y.rangeMin, y.rangeMax, y.precision] : []
}

function Xv(d) {
  var a = Object.keys(d.__proto__);
  return a.filter(zR)
}

function zR(d) {
  return typeof d == "string" && !d.match(/[^A-Z0-9_x]/)
}

function _y() {
  return uy()
}

function LR() {
  return $h() || _o()
}

function gy(d) {
  return typeof d.getParameter == "function"
}

function DR() {
  var d = v_() || _o();
  if (!d) return -2;
  if (!window.AudioContext) return -1;
  var a = new AudioContext().baseLatency;
  return a == null ? -1 : isFinite(a) ? a : -3
}

function RR() {
  if (!window.Intl) return -1;
  var d = window.Intl.DateTimeFormat;
  if (!d) return -2;
  var a = d().resolvedOptions().locale;
  return !a && a !== "" ? -3 : a
}
var BR = {
  fonts: yD,
  domBlockers: tR,
  fontPreferences: _R,
  audio: lD,
  screenFrame: ZD,
  canvas: bD,
  osCpu: ED,
  languages: zD,
  colorDepth: LD,
  deviceMemory: DD,
  screenResolution: RD,
  hardwareConcurrency: VD,
  timezone: qD,
  sessionStorage: $D,
  localStorage: GD,
  indexedDB: WD,
  openDatabase: HD,
  cpuClass: JD,
  platform: XD,
  plugins: xD,
  touchSupport: AD,
  vendor: YD,
  vendorFlavors: KD,
  cookiesEnabled: QD,
  colorGamut: aR,
  invertedColors: oR,
  forcedColors: sR,
  monochrome: cR,
  contrast: uR,
  reducedMotion: hR,
  reducedTransparency: dR,
  hdr: pR,
  math: fR,
  pdfViewerEnabled: vR,
  architecture: yR,
  applePay: xR,
  privateClickMeasurement: CR,
  audioBaseLatency: DR,
  dateTimeLocale: RR,
  webGlBasics: MR,
  webGlExtensions: AR
};

function FR(d) {
  return QL(BR, d, [])
}
var OR = "$ if upgrade to Pro: https://fpjs.dev/pro";

function jR(d) {
  var a = NR(d),
    h = ZR(a);
  return {
    score: a,
    comment: OR.replace(/\$/g, "".concat(h))
  }
}

function NR(d) {
  if (v_()) return .4;
  if (_o()) return g_() && !(Wh() && Gh()) ? .5 : .3;
  var a = "value" in d.platform ? d.platform.value : "";
  return /^Win/.test(a) ? .6 : /^Mac/.test(a) ? .5 : .7
}

function ZR(d) {
  return ly(.99 + .01 * d, 1e-4)
}

function VR(d) {
  for (var a = "", h = 0, y = Object.keys(d).sort(); h < y.length; h++) {
    var k = y[h],
      E = d[k],
      b = "error" in E ? "error" : JSON.stringify(E.value);
    a += "".concat(a ? "|" : "").concat(k.replace(/([:|\\])/g, "\\$1"), ":").concat(b)
  }
  return a
}

function vy(d) {
  return JSON.stringify(d, function(a, h) {
    return h instanceof Error ? JL(h) : h
  }, 2)
}

function yy(d) {
  return HL(VR(d))
}

function qR(d) {
  var a, h = jR(d);
  return {
    get visitorId() {
      return a === void 0 && (a = yy(this.components)), a
    },
    set visitorId(y) {
      a = y
    },
    confidence: h,
    components: d,
    version: oy
  }
}

function UR(d) {
  return d === void 0 && (d = 50), jL(d, d * 2)
}

function $R(d, a) {
  var h = Date.now();
  return {
    get: function(y) {
      return Do(this, void 0, void 0, function() {
        var k, E, b;
        return Ro(this, function(s) {
          switch (s.label) {
            case 0:
              return k = Date.now(), [4, d()];
            case 1:
              return E = s.sent(), b = qR(E), (a || y != null && y.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(b.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(k - h, `
visitorId: `).concat(b.visitorId, `
components: `).concat(vy(E), "\n```")), [2, b]
          }
        })
      })
    }
  }
}

function GR() {
  if (!(window.__fpjs_d_m || Math.random() >= .001)) try {
    var d = new XMLHttpRequest;
    d.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(oy, "/npm-monitoring"), !0), d.send()
  } catch (a) {
    console.error(a)
  }
}

function WR(d) {
  var a;
  return d === void 0 && (d = {}), Do(this, void 0, void 0, function() {
    var h, y, k;
    return Ro(this, function(E) {
      switch (E.label) {
        case 0:
          return (!((a = d.monitoring) !== null && a !== void 0) || a) && GR(), h = d.delayFallback, y = d.debug, [4, UR(h)];
        case 1:
          return E.sent(), k = FR({
            cache: {},
            debug: y
          }), [2, $R(k, y)]
      }
    })
  })
}
var HR = {
  load: WR,
  hashComponents: yy,
  componentsToDebugString: vy
};
let om = null;
async function JR() {
  return om || (om = HR.load()), om
}
async function XR() {
  return (await (await JR()).get()).visitorId
}
var YR = xr('<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>');

function nh(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = YR();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var KR = xr('<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>');

function Yv(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = KR();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var QR = xr('<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>');

function xy(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = QR();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var e7 = xr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>'),
  t7 = xr('<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>');

function by(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
  var y = or(),
    k = pt(y);
  {
    var E = s => {
        var F = e7();
        lr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...h
        })), Z(s, F)
      },
      b = s => {
        var F = t7();
        lr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...h
        })), Z(s, F)
      };
    Be(k, s => {
      a.filled ? s(E) : s(b, !1)
    })
  }
  Z(d, y)
}
var r7 = xr('<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>');

function Vm(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = r7();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var n7 = xr('<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>');

function wy(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = n7();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var i7 = xr('<svg><path d="m356-160-56-56 180-180 180 180-56 56-124-124-124 124Zm124-404L300-744l56-56 124 124 124-124 56 56-180 180Z"></path></svg>');

function a7(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = i7();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var o7 = xr('<svg><path d="M480-120 300-300l58-58 122 122 122-122 58 58-180 180ZM358-598l-58-58 180-180 180 180-58 58-122-122-122 122Z"></path></svg>');

function s7(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = o7();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var l7 = fe("<!> ", 1),
  c7 = fe("<!> ", 1),
  u7 = fe("<!> ", 1),
  h7 = fe('<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ', 1),
  d7 = fe("<!> ", 1),
  p7 = fe("<!> <!>", 1),
  f7 = (d, a) => re(a, !x(a)),
  m7 = (d, a) => {
    re(a, "colorpicker")
  },
  _7 = (d, a) => {
    a(!a())
  },
  g7 = (d, a) => {
    re(a, "cleararea")
  },
  v7 = fe('<div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button><!></button></div>'),
  y7 = (d, a) => {
    Vi.smallPlop.play(), a()
  },
  x7 = (d, a, h) => {
    a(x(h).idx)
  },
  b7 = fe('<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>', 1),
  w7 = fe("<div><button><!></button></div>"),
  C7 = (d, a) => {
    re(a, !x(a))
  },
  T7 = (d, a) => {
    re(a, x(a) === "eraser" ? "pencil" : "eraser", !0)
  },
  S7 = fe('<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1"><h2 class="select-none text-xl"> <!></h2> <div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip"><button title="Toggle art opacity"><!></button></div> <!></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>', 1);

function I7(d, a) {
  Ir(a, !0);
  let h = Tt(a, "screenLocked", 15),
    y = Tt(a, "opaquePixelArt", 15);
  const k = ht(() => new Zs(a.tileSize));
  let E = rt(1),
    b = rt("pencil");
  const s = new Map,
    F = new Map;
  let O = rt(0),
    G = rt(!1),
    X = rt(!0),
    Q = ht(() => wt.charges ?? 0),
    W = ht(() => x(Q) - x(O)),
    de = rt(!1),
    _e = !1,
    Ae = rt(!1),
    xe = rt(di([]));
  const Ie = ht(() => x(b) === "pencil"),
    Pe = ht(() => x(b) === "eraser"),
    De = ht(() => x(b) === "colorpicker"),
    $e = ht(() => x(b) === "cleararea"),
    tt = ht(() => {
      var zt, nt;
      return ja((nt = (zt = wt) == null ? void 0 : zt.data) == null ? void 0 : nt.role, ["admin", "global_moderator", "moderator"])
    });
  let Ve = rt(!1),
    Re = rt(0),
    Ue = rt(void 0),
    Ce = rt(void 0);
  const We = [1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42, 12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49, 23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52, 61, 62, 63, 58, 59, 60, 0].map(zt => ({
      ...Bi.colors[zt],
      idx: zt
    })),
    Je = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0].map(zt => ({
      ...Bi.colors[zt],
      idx: zt
    }));
  let Ge = rt(!1);
  const Ee = ht(() => x(Ge) ? We : Je),
    mt = "show-all-colors";
  An(() => {
    re(Ge, localStorage.getItem(mt) === "true")
  }), Kr(() => {
    localStorage.setItem(mt, x(Ge) ? "true" : "false")
  });
  const K = "selected-color";
  An(() => {
    const zt = Number(localStorage.getItem(K));
    !isNaN(zt) && zt < Bi.colors.length && zt > 0 && re(E, zt, !0)
  }), Kr(() => {
    localStorage.setItem(K, x(E).toString())
  });
  const ee = new bL({
    map: a.map,
    tileSize: a.tileSize,
    tileZoom: a.tileZoom,
    beforeLayerId: a.hoverLayerId
  });
  Kr(() => {
    const zt = y() ? 1 : 0;
    ee.setCanvasOpacity(zt)
  }), Kr(() => {
    y() ? um() : dt([...s.values()])
  });
  let le = !1;
  An(() => {
    zo(a.map.getCenter(), a.map.getZoom());
    const zt = a.map.on("click", Yt => {
      var an;
      a.zoom < a.tileZoom + 2 && ((an = wt.data) == null ? void 0 : an.role) === "user" && a.map.easeTo({
        center: Yt.lngLat,
        zoom: 17
      });
      const tn = [Yt.lngLat.lat, Yt.lngLat.lng];
      if (x(Ie)) ke([tn], x(E));
      else if (x(Pe)) qe([tn]);
      else if (x(De)) lt(tn, Yt.point);
      else if (x($e) && (x(xe).push(tn), ke([tn], 0), x(xe).length >= 2)) {
        const [ln, Pi] = x(xe), [In, fi] = x(k).latLonToPixelsFloor(ln[0], ln[1], a.tileZoom), [Dn, ni] = x(k).latLonToPixelsFloor(Pi[0], Pi[1], a.tileZoom), qi = Math.min(In, Dn), Ui = Math.max(In, Dn), ki = Math.min(fi, ni), Mi = Math.max(fi, ni), $i = [];
        for (let na = ki; na <= Mi; na++) {
          const ua = x(k).pixelsToLatLon(qi + .5, na + .5, a.tileZoom),
            ba = x(k).pixelsToLatLon(Ui + .5, na + .5, a.tileZoom),
            wa = nt({
              lat: ua[0],
              lng: ua[1]
            }, {
              lat: ba[0],
              lng: ba[1]
            }).slice(0, x(W) - $i.length);
          if ($i.push(...wa), $i.length >= x(W)) break
        }
        ke($i, 0), re(xe, [], !0), re(b, "pencil")
      }
      re(de, !0)
    });

    function nt(Yt, tn) {
      const an = x(k).latLonToPixels(Yt.lat, Yt.lng, a.tileZoom),
        ln = tn ? x(k).latLonToPixels(tn.lat, tn.lng, a.tileZoom) : an;
      return mb(an, ln).map(In => x(k).pixelsToLatLon(In[0] + .5, In[1] + .5, a.tileZoom))
    }

    function $t(Yt, tn) {
      const an = nt(Yt, tn);
      x(Ie) ? ke(an, x(E)) : x(Pe) && qe(an), re(de, !0)
    }
    let Gt;

    function xt(Yt) {
      const tn = a.map.unproject([Yt.clientX, Yt.clientY]);
      if (x(Ae)) {
        const an = nt(tn, Gt);
        qe(an)
      }(le || _e) && $t(tn, Gt), Gt = tn
    }
    window.addEventListener("mousemove", xt);
    let It = !1;
    const Wt = a.map.on("touchstart", Yt => {
        if (Yt.points.length == 2) {
          h(!1), ut(), It = !0, setTimeout(() => It = !1, 150);
          return
        }
        h() && setTimeout(() => {
          !It && $t(Yt.lngLat)
        }, 150), Gt = Yt.lngLat
      }),
      Nt = a.map.on("touchmove", Yt => {
        h() && $t(Yt.lngLat, Gt), Gt = Yt.lngLat
      }),
      gr = Yt => {
        Yt.code === "Space" && (le || Gt && $t(Gt), le = !0, Yt.preventDefault())
      };
    document.addEventListener("keydown", gr);
    const Qr = Yt => {
      Yt.code === "Space" && (le = !1, ae = !1, x(O) === 0 && x(Pe) && re(b, "pencil"))
    };
    document.addEventListener("keyup", Qr);

    function zr(Yt) {
      if (Yt.button === 2) {
        re(Ae, !0);
        const an = a.map.unproject([Yt.clientX, Yt.clientY]);
        qe([
          [an.lat, an.lng]
        ])
      }
    }
    document.addEventListener("mousedown", zr);

    function Hr(Yt) {
      Yt.button === 2 && re(Ae, !1)
    }
    document.addEventListener("mouseup", Hr);
    const hn = Yt => {
      switch (Yt.code) {
        case "KeyE":
          x(O) > 0 && (x(Pe) ? re(b, "pencil") : re(b, "eraser"));
          return;
        case "KeyI":
          re(b, "colorpicker");
          return;
        case "KeyC":
          x(tt) && re(b, "cleararea");
          return
      }
    };
    return document.addEventListener("keypress", hn), () => {
      Nt.unsubscribe(), Wt.unsubscribe(), zt.unsubscribe(), document.removeEventListener("mousemove", xt), document.removeEventListener("keydown", gr), document.removeEventListener("keyup", Qr), document.removeEventListener("keypress", hn), document.removeEventListener("mousedown", zr), document.removeEventListener("mouseup", Hr), Pt()
    }
  });
  let ae = !1;

  function ke(zt, nt) {
    let $t = !1;
    const Gt = nt === 0;
    for (let xt of zt) {
      const [It, Wt] = xt, Nt = db(nt), {
        tile: gr,
        pixel: Qr
      } = x(k).latLonToTileAndPixel(It, Wt, a.tileZoom), zr = {
        color: Nt,
        tile: gr,
        pixel: Qr,
        season: a.season,
        colorIdx: nt
      }, Hr = Yf(zr), hn = s.get(Hr), Yt = x(Q) - s.size;
      if (!hn && Yt < 1) {
        if (ae && (le || h())) continue;
        ae = !0, Ar.info(TS());
        continue
      }
      hn && hn.colorIdx === nt || (Vi.plop.play(), $t || a.hidePixelHover(), s.set(Hr, zr), ee.place(xt, nt), a.crosshair.place(xt), $t = !0, Gt && F.set(Hr, zr))
    }
    re(O, s.size, !0), $t && !y() ? dt([...s.values()]) : $t && y() && Gt && dt([...F.values()])
  }

  function qe(zt) {
    let nt = !1,
      $t = !1;
    for (let Gt of zt) {
      const [xt, It] = Gt, {
        tile: Wt,
        pixel: Nt
      } = x(k).latLonToTileAndPixel(xt, It, a.tileZoom), gr = Yf({
        tile: Wt,
        pixel: Nt,
        season: a.season
      }), Qr = s.get(gr);
      Qr && (Vi.plop.play(), a.hidePixelHover(), s.delete(gr), F.delete(gr), ee.remove([xt, It]), a.crosshair.remove(Gt), nt = !0, Qr.colorIdx === 0 && ($t = !0)), s.size === 0 && !(le || _e || h()) && re(b, "pencil")
    }
    re(O, s.size, !0), nt && !y() ? dt([...s.values()]) : nt && y() && $t && dt([...F.values()])
  }

  function lt(zt, nt) {
    const {
      tile: $t,
      pixel: Gt
    } = x(k).latLonToTileAndPixel(zt[0], zt[1], a.tileZoom), xt = Yf({
      tile: $t,
      pixel: Gt,
      season: a.season
    }), It = s.get(xt);
    if (It) {
      gt(It.colorIdx), requestAnimationFrame(() => {
        var Qr;
        (Qr = document.getElementById(`color-${It.colorIdx}`)) == null || Qr.focus()
      });
      return
    }
    const Wt = window.devicePixelRatio,
      Nt = Math.floor(nt.x * Wt),
      gr = Math.floor(nt.y * Wt);
    a.hidePixelHover(), ZM(a.map, Nt, gr).then(([Qr, zr, Hr]) => {
      const hn = pb({
        r: Qr,
        g: zr,
        b: Hr
      });
      gt(hn), requestAnimationFrame(() => {
        var Yt;
        (Yt = document.getElementById(`color-${hn}`)) == null || Yt.focus()
      })
    })
  }
  Cl(() => x(E), () => {
    a.clickedLatLon && !x(de) && (x(E) === void 0 && re(E, 1), ke([a.clickedLatLon], x(E)))
  }), Kr(() => {
    const zt = x(X) ? .8 : 0;
    a.crosshair.setCanvasOpacity(zt)
  });
  let ot = rt(16.5);
  Kr(() => {
    if (x(Ue) && x(Ce) && a.clickedLatLon) {
      const zt = a.map.getZoom();
      if (zt < x(ot)) {
        const [nt, $t] = a.clickedLatLon, Gt = x(k).latLonToPixelBoundsLatLon(nt, $t, a.tileZoom), xt = o_(Gt), It = x(Ue) - x(Ce).clientHeight, Wt = x(Ue) / 2 - It / 2;
        a.map.flyTo({
          center: {
            lat: xt[0],
            lng: xt[1]
          },
          zoom: 17.5,
          offset: zt > 11 ? [0, -Wt] : [0, 0]
        })
      }
      re(ot, a.tileZoom, !0)
    }
  }), An(() => {
    const zt = () => {
      !document.hidden && (console.log("Tab visible again"), y() ? dt([...F.values()]) : dt([...s.values()]))
    };
    return document.addEventListener("visibilitychange", zt), () => document.removeEventListener("visibilitychange", zt)
  }), Kr(() => {
    switch (x(b)) {
      case "pencil":
        a.map.getCanvas().style.cursor = `url('${yL}') 8 8, default`, a.map.setPaintProperty(a.hoverLayerId, "raster-opacity", .4);
        return;
      case "colorpicker":
        a.map.getCanvas().style.cursor = `url('${gL}') 0 16, default`, a.map.setPaintProperty(a.hoverLayerId, "raster-opacity", 0);
        return;
      case "eraser":
        a.map.getCanvas().style.cursor = `url('${vL}') 2 14, default`, a.map.setPaintProperty(a.hoverLayerId, "raster-opacity", .4);
        return
    }
  }), Kr(() => {
    h() ? He() : ut()
  });
  async function dt(zt) {
    await Jx(zt), a.refreshPixelArt()
  }
  async function Pt() {
    await um(), ee.clear(), a.refreshPixelArt(), a.crosshair.clear()
  }
  async function Lt() {
    await Pt(), ut(), a.map.getCanvas().style.cursor = "default", a.map.setPaintProperty(a.hoverLayerId, "raster-opacity", .4), a.onclose()
  }

  function He() {
    a.map.dragPan.disable(), a.map.touchZoomRotate.disable(), document.documentElement.style.overscrollBehavior = "none"
  }

  function ut() {
    a.map.dragPan.enable(), a.map.touchZoomRotate.enable(), document.documentElement.style.overscrollBehavior = ""
  }

  function gt(zt) {
    return zt >= 32 && re(Ge, !0), wt.hasColor(zt) ? (Vi.smallDropplet.play(), re(E, zt, !0), re(b, "pencil"), !0) : (Vi.smallDropplet.play(), re(Ve, !0), re(Re, zt, !0), !1)
  }
  Fx(zt => {
    zt.type === "leave" && x(O) > 0 && zt.cancel()
  });
  const St = "show-paint-more-than-one-pixel-msg";
  let vt = rt(!1);
  An(() => {
    var zt;
    re(vt, !localStorage.getItem(St) && (((zt = wt.data) == null ? void 0 : zt.pixelsPainted) ?? 0) < 100, !0)
  }), Kr(() => {
    x(O) > 1 && (re(vt, !1), localStorage.setItem(St, "false"))
  });
  const Ct = "lp";
  An(() => {
    var nt;
    const zt = localStorage.getItem(Ct);
    if (zt) try {
      const $t = JSON.parse(atob(zt)),
        Gt = ($t == null ? void 0 : $t.time) ?? 0,
        xt = 60 * 1e3;
      ($t == null ? void 0 : $t.userId) !== ((nt = wt.data) == null ? void 0 : nt.id) && Date.now() - Gt < 30 * xt && !Mb && (Ar.error(PS()), Lt())
    } catch ($t) {
      console.error($t)
    }
  });

  function At() {
    var nt;
    const zt = btoa(JSON.stringify({
      userId: (nt = wt.data) == null ? void 0 : nt.id,
      time: Date.now()
    }));
    localStorage.setItem(Ct, zt)
  }
  var Bt = S7(),
    Vt = pt(Bt),
    Ot = P(Vt);
  {
    var Dt = zt => {
        gl(zt, {
          children: (nt, $t) => {
            var Gt = l7(),
              xt = pt(Gt);
            xy(xt, {
              class: "inline size-5"
            });
            var It = B(xt);
            Ze(Wt => ce(It, ` ${Wt??""}`), [() => r3()]), Z(nt, Gt)
          },
          $$slots: {
            default: !0
          }
        })
      },
      Rt = zt => {
        var nt = or(),
          $t = pt(nt);
        {
          var Gt = It => {
              gl(It, {
                class: "not-touchscreen:hidden",
                children: (Wt, Nt) => {
                  var gr = c7(),
                    Qr = pt(gr);
                  vv(Qr, {
                    class: "inline size-5"
                  });
                  var zr = B(Qr);
                  Ze(Hr => ce(zr, ` ${Hr??""}`), [() => a3()]), Z(Wt, gr)
                },
                $$slots: {
                  default: !0
                }
              })
            },
            xt = It => {
              var Wt = or(),
                Nt = pt(Wt);
              {
                var gr = zr => {
                    gl(zr, {
                      class: "not-touchscreen:hidden",
                      children: (Hr, hn) => {
                        var Yt = u7(),
                          tn = pt(Yt);
                        Yv(tn, {
                          class: "inline size-5"
                        });
                        var an = B(tn, 1, !0);
                        Ze(ln => ce(an, ln), [() => l3()]), Z(Hr, Yt)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  },
                  Qr = zr => {
                    var Hr = or(),
                      hn = pt(Hr);
                    {
                      var Yt = an => {
                          gl(an, {
                            class: "touchscreen:hidden",
                            children: (ln, Pi) => {
                              var In = h7(),
                                fi = pt(In);
                              wy(fi, {
                                class: "inline size-5"
                              });
                              var Dn = B(fi),
                                ni = P(Dn, !0);
                              I(Dn);
                              var qi = B(Dn, 2),
                                Ui = P(qi),
                                ki = B(Ui),
                                Mi = P(ki, !0);
                              I(ki), I(qi);
                              var $i = B(qi);
                              Ze((na, ua, ba, wa) => {
                                ce(ni, na), ce(Ui, `${ua??""} `), ce(Mi, ba), ce($i, ` ${wa??""}`)
                              }, [() => h3(), () => g3(), () => f3(), () => x3()]), Z(ln, In)
                            },
                            $$slots: {
                              default: !0
                            }
                          })
                        },
                        tn = an => {
                          var ln = or(),
                            Pi = pt(ln);
                          {
                            var In = Dn => {
                                gl(Dn, {
                                  class: "bg-warning text-warning-content animate-bounce",
                                  children: (ni, qi) => {
                                    var Ui = d7(),
                                      ki = pt(Ui);
                                    qh(ki, {
                                      class: "inline size-5"
                                    });
                                    var Mi = B(ki);
                                    Ze($i => ce(Mi, ` ${$i??""}`), [() => C3()]), Z(ni, Ui)
                                  },
                                  $$slots: {
                                    default: !0
                                  }
                                })
                              },
                              fi = Dn => {
                                var ni = or(),
                                  qi = pt(ni);
                                {
                                  var Ui = ki => {
                                    gl(ki, {
                                      class: "bg-warning text-warning-content animate-bounce",
                                      children: (Mi, $i) => {
                                        var na = p7(),
                                          ua = pt(na);
                                        nh(ua, {
                                          class: "inline size-5"
                                        });
                                        var ba = B(ua, 2);
                                        {
                                          var wa = ha => {
                                              var da = Ii();
                                              Ze(pa => ce(da, pa), [() => k0()]), Z(ha, da)
                                            },
                                            Ca = ha => {
                                              var da = or(),
                                                pa = pt(da);
                                              {
                                                var go = Za => {
                                                  var hs = Ii();
                                                  Ze(Va => ce(hs, Va), [() => M0()]), Z(Za, hs)
                                                };
                                                Be(pa, Za => {
                                                  x(xe).length === 1 && Za(go)
                                                }, !0)
                                              }
                                              Z(ha, da)
                                            };
                                          Be(ba, ha => {
                                            x(xe).length === 0 ? ha(wa) : ha(Ca, !1)
                                          })
                                        }
                                        Z(Mi, na)
                                      },
                                      $$slots: {
                                        default: !0
                                      }
                                    })
                                  };
                                  Be(qi, ki => {
                                    x($e) && ki(Ui)
                                  }, !0)
                                }
                                Z(Dn, ni)
                              };
                            Be(Pi, Dn => {
                              x(vt) ? Dn(In) : Dn(fi, !1)
                            }, !0)
                          }
                          Z(an, ln)
                        };
                      Be(hn, an => {
                        x(Ie) && x(O) === 0 ? an(Yt) : an(tn, !1)
                      }, !0)
                    }
                    Z(zr, Hr)
                  };
                Be(Nt, zr => {
                  x(De) ? zr(gr) : zr(Qr, !1)
                }, !0)
              }
              Z(It, Wt)
            };
          Be($t, It => {
            x(Pe) ? It(Gt) : It(xt, !1)
          }, !0)
        }
        Z(zt, nt)
      };
    Be(Ot, zt => {
      x(Pe) && x(O) === 0 ? zt(Dt) : zt(Rt, !1)
    })
  }
  var Zt = B(Ot, 2),
    Ft = P(Zt);
  Ft.__click = [f7, X];
  var cr = P(Ft);
  {
    var ur = zt => {
        TL(zt, {
          class: "size-4"
        })
      },
      Er = zt => {
        IL(zt, {
          class: "size-4"
        })
      };
    Be(cr, zt => {
      x(X) ? zt(ur) : zt(Er, !1)
    })
  }
  I(Ft);
  var dr = B(Ft, 2),
    pr = P(dr),
    vr = P(pr),
    Vr = B(vr);
  ny(Vr, {
    class: "inline",
    fontSize: 14,
    get value() {
      return `(${x(O)??""})`
    },
    mono: !0
  }), I(pr);
  var qr = B(pr, 2),
    ue = P(qr),
    V = P(ue);
  en(), I(ue);
  var U = B(ue, 2);
  U.__click = [m7, b];
  var Y = P(U);
  Yv(Y, {
    class: "size-4.5"
  }), I(U), I(qr);
  var oe = B(qr, 2),
    me = P(oe);
  let Se;
  me.__click = [_7, y];
  var Oe = P(me);
  {
    let zt = ht(() => !y());
    by(Oe, {
      class: "size-4.5",
      get filled() {
        return x(zt)
      }
    })
  }
  I(me), I(oe);
  var ze = B(oe, 2);
  {
    var Ke = zt => {
      var nt = v7(),
        $t = P(nt),
        Gt = P($t);
      en(), I($t);
      var xt = B($t, 2);
      xt.__click = [g7, b];
      var It = P(xt);
      nh(It, {
        class: "size-4.5"
      }), I(xt), I(nt), Ze(Wt => {
        ce(Gt, `${Wt??""} `), Or(xt, 1, ls({
          "btn btn-circle btn-sm": !0,
          "btn-ghost": !x($e),
          "btn-primary": x($e)
        }))
      }, [() => IP()]), Z(zt, nt)
    };
    Be(ze, zt => {
      x(tt) && zt(Ke)
    })
  }
  I(dr);
  var _t = B(dr, 2);
  _t.__click = [y7, Lt];
  var it = P(_t);
  Il(it, {
    class: "size-4"
  }), I(_t), I(Zt);
  var qt = B(Zt, 2),
    we = P(qt);
  ai(we, 23, () => x(Ee), zt => zt.idx, (zt, nt, $t) => {
    const Gt = ht(() => {
        const [Hr, hn, Yt] = x(nt).rgb;
        return {
          r: Hr,
          g: hn,
          b: Yt
        }
      }),
      xt = ht(() => x(E) === x(nt).idx && x(Ie)),
      It = ht(() => x(nt).idx === 0),
      Wt = ht(() => wt.hasColor(x(nt).idx));
    var Nt = w7(),
      gr = P(Nt);
    gr.__click = [x7, gt, nt];
    var Qr = P(gr);
    {
      var zr = Hr => {
        var hn = b7(),
          Yt = pt(hn);
        Vm(Yt, {
          class: "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6"
        });
        var tn = B(Yt, 2),
          an = P(tn);
        Vm(an, {
          class: "text-base-content/80 size-4"
        }), I(tn), Z(Hr, hn)
      };
      Be(Qr, Hr => {
        x(Wt) || Hr(zr)
      })
    }
    I(gr), I(Nt), Ze(() => {
      Or(Nt, 1, ls({
        tooltip: !0,
        "max-sm:h-6": x(Ge),
        "max-sm:before:translate-x-1/4": x($t) % 8 === 0 && x(nt).name.length > 7,
        "max-sm:before:-translate-x-1/4": (x($t) - 7) % 8 === 0 && x(nt).name.length > 7,
        "max-xl:before:translate-x-1/4": x($t) % 16 === 0 && x(nt).name.length > 7,
        "max-xl:before:-translate-x-1/4": (x($t) - 15) % 16 === 0 && x(nt).name.length > 7,
        "xl:before:translate-x-1/4": x(Ge) && x($t) % 32 === 0 && x(nt).name.length > 7,
        "xl:before:-translate-x-1/4": x(Ge) && (x($t) - 31) % 32 === 0 && x(nt).name.length > 7
      })), nr(Nt, "data-tip", x(nt).name), Or(gr, 1, ls({
        "btn relative aspect-square w-full rounded-xl": !0,
        "border-primary ring-primary ring-2": x(xt),
        "border-base-300": !x(xt) && x(It),
        "border-base-content/20": !x(xt) && !x(It),
        "max-sm:h-6 max-sm:rounded-md": x(Ge)
      })), Bc(gr, x(It) ? `background-image: url(${xL}); background-size: cover; image-rendering: pixelated;` : `background: rgb(${x(Gt).r} ${x(Gt).g} ${x(Gt).b})`), nr(gr, "aria-label", x(nt).name), nr(gr, "id", `color-${x(nt).idx??""}`)
    }), Zn("focus", gr, () => {
      x(Wt) && (re(E, x(nt).idx, !0), re(b, "pencil"))
    }), Z(zt, Nt)
  }), I(we), I(qt);
  var Mt = B(qt, 2),
    Ut = P(Mt);
  Ut.__click = [C7, Ge];
  var jt = P(Ut);
  {
    var fr = zt => {
        a7(zt, {
          class: "size-5"
        })
      },
      Ur = zt => {
        s7(zt, {
          class: "size-5"
        })
      };
    Be(jt, zt => {
      x(Ge) ? zt(fr) : zt(Ur, !1)
    })
  }
  I(Ut);
  var Dr = B(Ut, 2),
    jr = P(Dr);
  {
    let zt = ht(() => x(O) > 100 ? "animate-pulse" : ""),
      nt = ht(() => x(O) === 0 || x(G) || x(W) < 0);
    iy(jr, {
      get class() {
        return x(zt)
      },
      get charges() {
        return x(W)
      },
      get disabled() {
        return x(nt)
      },
      get loading() {
        return x(G)
      },
      onclick: async () => {
        Vi.droppletAndPlop.play();
        const $t = [...s.values()];
        re(G, !0);
        try {
          const Gt = await XR();
          await nn.paint($t, Gt), await Xx($t), At(), wt.refresh(), lp.shouldReload = !0, await Lt()
        } catch (Gt) {
          Ar.error(`${Gt.message}`, {
            duration: 7e3
          })
        } finally {
          re(G, !1)
        }
      }
    })
  }
  I(Dr);
  var $r = B(Dr, 2),
    Br = P($r),
    Fr = P(Br),
    vn = P(Fr);
  en(), I(Fr);
  var bt = B(Fr, 2);
  let bn;
  bt.__click = [T7, b];
  var fn = P(bt);
  vv(fn, {
    class: "size-5",
    get filled() {
      return x(Pe)
    }
  }), I(bt), I(Br), I($r), I(Mt), I(Vt), us(Vt, zt => re(Ce, zt), () => x(Ce));
  var $n = B(Vt, 2);
  FL($n, {
    get colorIdx() {
      return x(Re)
    },
    get open() {
      return x(Ve)
    },
    set open(zt) {
      re(Ve, zt, !0)
    }
  }), Ze((zt, nt, $t, Gt, xt, It) => {
    ce(vr, `${zt??""} `), ce(V, `${nt??""} `), Or(U, 1, ls({
      "btn btn-circle btn-sm": !0,
      "btn-ghost": !x(De),
      "btn-primary": x(De)
    })), nr(oe, "data-tip", $t), Se = Or(me, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, Se, Gt), Or(we, 1, ls({
      "md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
      "xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": x(Ge),
      "gap-1": !x(Ge)
    })), ce(vn, `${xt??""} `), bn = Or(bt, 1, "btn btn-lg btn-square sm:btn-xl shadow-md", null, bn, It), bt.disabled = x(O) === 0
  }, [() => I3(), () => M3(), () => b0(), () => ({
    "text-primary": !y()
  }), () => _b(), () => ({
    "btn-primary": x(Pe)
  })]), zp("innerHeight", zt => re(Ue, zt, !0)), Z(d, Bt), Pr()
}
Ln(["click"]);

function y_(...d) {
  return h0(Wu(d))
}
var P7 = fe("<div><!></div>");

function k7(d, a) {
  Ir(a, !0);
  let h = Tt(a, "ref", 15, null),
    y = sr(a, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]);
  var k = P7();
  lr(k, b => ({
    class: b,
    ...y
  }), [() => y_("flex items-center", a.class)]);
  var E = P(k);
  Hn(E, () => a.children ?? ra), I(k), us(k, b => h(b), () => h()), Z(d, k), Pr()
}
var M7 = fe('<div class="pointer-events-none absolute inset-0 flex items-center justify-center"><div class="animate-caret-blink bg-base-content/80 h-4 w-px duration-1000"></div></div>'),
  A7 = fe(" <!>", 1);

function E7(d, a) {
  Ir(a, !0);
  let h = Tt(a, "ref", 15, null),
    y = sr(a, ["$$slots", "$$events", "$$legacy", "ref", "cell", "class"]);
  var k = or(),
    E = pt(k);
  {
    let b = ht(() => y_("border-input relative flex size-12 items-center justify-center border-y border-r text-xl transition-all first:rounded-l-md first:border-l last:rounded-r-md", a.cell.isActive && "ring-base-content/40 z-10 ring-2", a.class));
    yi(E, () => HE, (s, F) => {
      F(s, Ns({
        get cell() {
          return a.cell
        },
        get class() {
          return x(b)
        }
      }, () => y, {
        get ref() {
          return h()
        },
        set ref(O) {
          h(O)
        },
        children: (O, G) => {
          en();
          var X = A7(),
            Q = pt(X),
            W = B(Q);
          {
            var de = _e => {
              var Ae = M7();
              Z(_e, Ae)
            };
            Be(W, _e => {
              a.cell.hasFakeCaret && _e(de)
            })
          }
          Ze(() => ce(Q, `${a.cell.char??""} `)), Z(O, X)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  Z(d, k), Pr()
}

function z7(d, a) {
  Ir(a, !0);
  let h = Tt(a, "ref", 15, null),
    y = Tt(a, "value", 15, ""),
    k = sr(a, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var E = or(),
    b = pt(E);
  {
    let s = ht(() => y_("flex items-center gap-2 has-[:disabled]:opacity-50 [&_input]:disabled:cursor-not-allowed", a.class));
    yi(b, () => GE, (F, O) => {
      O(F, Ns({
        get class() {
          return x(s)
        }
      }, () => k, {
        get ref() {
          return h()
        },
        set ref(G) {
          h(G)
        },
        get value() {
          return y()
        },
        set value(G) {
          y(G)
        }
      }))
    })
  }
  Z(d, E), Pr()
}
var sm = {
    exports: {}
  },
  Kv;

function L7() {
  return Kv || (Kv = 1, (function(d) {
    (function(a) {
      d.exports ? d.exports = a() : window.intlTelInput = a()
    })(() => {
      var a = (() => {
        var h = Object.defineProperty,
          y = Object.getOwnPropertyDescriptor,
          k = Object.getOwnPropertyNames,
          E = Object.prototype.hasOwnProperty,
          b = (K, ee) => {
            for (var le in ee) h(K, le, {
              get: ee[le],
              enumerable: !0
            })
          },
          s = (K, ee, le, ae) => {
            if (ee && typeof ee == "object" || typeof ee == "function")
              for (let ke of k(ee)) !E.call(K, ke) && ke !== le && h(K, ke, {
                get: () => ee[ke],
                enumerable: !(ae = y(ee, ke)) || ae.enumerable
              });
            return K
          },
          F = K => s(h({}, "__esModule", {
            value: !0
          }), K),
          O = {};
        b(O, {
          Iti: () => Je,
          default: () => mt
        });
        var G = [
            ["af", "93"],
            ["ax", "358", 1],
            ["al", "355"],
            ["dz", "213"],
            ["as", "1", 5, ["684"]],
            ["ad", "376"],
            ["ao", "244"],
            ["ai", "1", 6, ["264"]],
            ["ag", "1", 7, ["268"]],
            ["ar", "54"],
            ["am", "374"],
            ["aw", "297"],
            ["ac", "247"],
            ["au", "61", 0, null, "0"],
            ["at", "43"],
            ["az", "994"],
            ["bs", "1", 8, ["242"]],
            ["bh", "973"],
            ["bd", "880"],
            ["bb", "1", 9, ["246"]],
            ["by", "375"],
            ["be", "32"],
            ["bz", "501"],
            ["bj", "229"],
            ["bm", "1", 10, ["441"]],
            ["bt", "975"],
            ["bo", "591"],
            ["ba", "387"],
            ["bw", "267"],
            ["br", "55"],
            ["io", "246"],
            ["vg", "1", 11, ["284"]],
            ["bn", "673"],
            ["bg", "359"],
            ["bf", "226"],
            ["bi", "257"],
            ["kh", "855"],
            ["cm", "237"],
            ["ca", "1", 1, ["204", "226", "236", "249", "250", "263", "289", "306", "343", "354", "365", "367", "368", "382", "387", "403", "416", "418", "428", "431", "437", "438", "450", "584", "468", "474", "506", "514", "519", "548", "579", "581", "584", "587", "604", "613", "639", "647", "672", "683", "705", "709", "742", "753", "778", "780", "782", "807", "819", "825", "867", "873", "879", "902", "905"]],
            ["cv", "238"],
            ["bq", "599", 1, ["3", "4", "7"]],
            ["ky", "1", 12, ["345"]],
            ["cf", "236"],
            ["td", "235"],
            ["cl", "56"],
            ["cn", "86"],
            ["cx", "61", 2, ["89164"], "0"],
            ["cc", "61", 1, ["89162"], "0"],
            ["co", "57"],
            ["km", "269"],
            ["cg", "242"],
            ["cd", "243"],
            ["ck", "682"],
            ["cr", "506"],
            ["ci", "225"],
            ["hr", "385"],
            ["cu", "53"],
            ["cw", "599", 0],
            ["cy", "357"],
            ["cz", "420"],
            ["dk", "45"],
            ["dj", "253"],
            ["dm", "1", 13, ["767"]],
            ["do", "1", 2, ["809", "829", "849"]],
            ["ec", "593"],
            ["eg", "20"],
            ["sv", "503"],
            ["gq", "240"],
            ["er", "291"],
            ["ee", "372"],
            ["sz", "268"],
            ["et", "251"],
            ["fk", "500"],
            ["fo", "298"],
            ["fj", "679"],
            ["fi", "358", 0],
            ["fr", "33"],
            ["gf", "594"],
            ["pf", "689"],
            ["ga", "241"],
            ["gm", "220"],
            ["ge", "995"],
            ["de", "49"],
            ["gh", "233"],
            ["gi", "350"],
            ["gr", "30"],
            ["gl", "299"],
            ["gd", "1", 14, ["473"]],
            ["gp", "590", 0],
            ["gu", "1", 15, ["671"]],
            ["gt", "502"],
            ["gg", "44", 1, ["1481", "7781", "7839", "7911"], "0"],
            ["gn", "224"],
            ["gw", "245"],
            ["gy", "592"],
            ["ht", "509"],
            ["hn", "504"],
            ["hk", "852"],
            ["hu", "36"],
            ["is", "354"],
            ["in", "91"],
            ["id", "62"],
            ["ir", "98"],
            ["iq", "964"],
            ["ie", "353"],
            ["im", "44", 2, ["1624", "74576", "7524", "7924", "7624"], "0"],
            ["il", "972"],
            ["it", "39", 0],
            ["jm", "1", 4, ["876", "658"]],
            ["jp", "81"],
            ["je", "44", 3, ["1534", "7509", "7700", "7797", "7829", "7937"], "0"],
            ["jo", "962"],
            ["kz", "7", 1, ["33", "7"], "8"],
            ["ke", "254"],
            ["ki", "686"],
            ["xk", "383"],
            ["kw", "965"],
            ["kg", "996"],
            ["la", "856"],
            ["lv", "371"],
            ["lb", "961"],
            ["ls", "266"],
            ["lr", "231"],
            ["ly", "218"],
            ["li", "423"],
            ["lt", "370"],
            ["lu", "352"],
            ["mo", "853"],
            ["mg", "261"],
            ["mw", "265"],
            ["my", "60"],
            ["mv", "960"],
            ["ml", "223"],
            ["mt", "356"],
            ["mh", "692"],
            ["mq", "596"],
            ["mr", "222"],
            ["mu", "230"],
            ["yt", "262", 1, ["269", "639"], "0"],
            ["mx", "52"],
            ["fm", "691"],
            ["md", "373"],
            ["mc", "377"],
            ["mn", "976"],
            ["me", "382"],
            ["ms", "1", 16, ["664"]],
            ["ma", "212", 0, null, "0"],
            ["mz", "258"],
            ["mm", "95"],
            ["na", "264"],
            ["nr", "674"],
            ["np", "977"],
            ["nl", "31"],
            ["nc", "687"],
            ["nz", "64"],
            ["ni", "505"],
            ["ne", "227"],
            ["ng", "234"],
            ["nu", "683"],
            ["nf", "672"],
            ["kp", "850"],
            ["mk", "389"],
            ["mp", "1", 17, ["670"]],
            ["no", "47", 0],
            ["om", "968"],
            ["pk", "92"],
            ["pw", "680"],
            ["ps", "970"],
            ["pa", "507"],
            ["pg", "675"],
            ["py", "595"],
            ["pe", "51"],
            ["ph", "63"],
            ["pl", "48"],
            ["pt", "351"],
            ["pr", "1", 3, ["787", "939"]],
            ["qa", "974"],
            ["re", "262", 0, null, "0"],
            ["ro", "40"],
            ["ru", "7", 0, null, "8"],
            ["rw", "250"],
            ["ws", "685"],
            ["sm", "378"],
            ["st", "239"],
            ["sa", "966"],
            ["sn", "221"],
            ["rs", "381"],
            ["sc", "248"],
            ["sl", "232"],
            ["sg", "65"],
            ["sx", "1", 21, ["721"]],
            ["sk", "421"],
            ["si", "386"],
            ["sb", "677"],
            ["so", "252"],
            ["za", "27"],
            ["kr", "82"],
            ["ss", "211"],
            ["es", "34"],
            ["lk", "94"],
            ["bl", "590", 1],
            ["sh", "290"],
            ["kn", "1", 18, ["869"]],
            ["lc", "1", 19, ["758"]],
            ["mf", "590", 2],
            ["pm", "508"],
            ["vc", "1", 20, ["784"]],
            ["sd", "249"],
            ["sr", "597"],
            ["sj", "47", 1, ["79"]],
            ["se", "46"],
            ["ch", "41"],
            ["sy", "963"],
            ["tw", "886"],
            ["tj", "992"],
            ["tz", "255"],
            ["th", "66"],
            ["tl", "670"],
            ["tg", "228"],
            ["tk", "690"],
            ["to", "676"],
            ["tt", "1", 22, ["868"]],
            ["tn", "216"],
            ["tr", "90"],
            ["tm", "993"],
            ["tc", "1", 23, ["649"]],
            ["tv", "688"],
            ["ug", "256"],
            ["ua", "380"],
            ["ae", "971"],
            ["gb", "44", 0, null, "0"],
            ["us", "1", 0],
            ["uy", "598"],
            ["vi", "1", 24, ["340"]],
            ["uz", "998"],
            ["vu", "678"],
            ["va", "39", 1, ["06698"]],
            ["ve", "58"],
            ["vn", "84"],
            ["wf", "681"],
            ["eh", "212", 1, ["5288", "5289"], "0"],
            ["ye", "967"],
            ["zm", "260"],
            ["zw", "263"]
          ],
          X = [];
        for (let K = 0; K < G.length; K++) {
          const ee = G[K];
          X[K] = {
            name: "",
            iso2: ee[0],
            dialCode: ee[1],
            priority: ee[2] || 0,
            areaCodes: ee[3] || null,
            nodeById: {},
            nationalPrefix: ee[4] || null
          }
        }
        var Q = X,
          W = {
            ad: "Andorra",
            ae: "United Arab Emirates",
            af: "Afghanistan",
            ag: "Antigua & Barbuda",
            ai: "Anguilla",
            al: "Albania",
            am: "Armenia",
            ao: "Angola",
            ar: "Argentina",
            as: "American Samoa",
            at: "Austria",
            au: "Australia",
            aw: "Aruba",
            ax: "Åland Islands",
            az: "Azerbaijan",
            ba: "Bosnia & Herzegovina",
            bb: "Barbados",
            bd: "Bangladesh",
            be: "Belgium",
            bf: "Burkina Faso",
            bg: "Bulgaria",
            bh: "Bahrain",
            bi: "Burundi",
            bj: "Benin",
            bl: "St. Barthélemy",
            bm: "Bermuda",
            bn: "Brunei",
            bo: "Bolivia",
            bq: "Caribbean Netherlands",
            br: "Brazil",
            bs: "Bahamas",
            bt: "Bhutan",
            bw: "Botswana",
            by: "Belarus",
            bz: "Belize",
            ca: "Canada",
            cc: "Cocos (Keeling) Islands",
            cd: "Congo - Kinshasa",
            cf: "Central African Republic",
            cg: "Congo - Brazzaville",
            ch: "Switzerland",
            ci: "Côte d’Ivoire",
            ck: "Cook Islands",
            cl: "Chile",
            cm: "Cameroon",
            cn: "China",
            co: "Colombia",
            cr: "Costa Rica",
            cu: "Cuba",
            cv: "Cape Verde",
            cw: "Curaçao",
            cx: "Christmas Island",
            cy: "Cyprus",
            cz: "Czechia",
            de: "Germany",
            dj: "Djibouti",
            dk: "Denmark",
            dm: "Dominica",
            do: "Dominican Republic",
            dz: "Algeria",
            ec: "Ecuador",
            ee: "Estonia",
            eg: "Egypt",
            eh: "Western Sahara",
            er: "Eritrea",
            es: "Spain",
            et: "Ethiopia",
            fi: "Finland",
            fj: "Fiji",
            fk: "Falkland Islands",
            fm: "Micronesia",
            fo: "Faroe Islands",
            fr: "France",
            ga: "Gabon",
            gb: "United Kingdom",
            gd: "Grenada",
            ge: "Georgia",
            gf: "French Guiana",
            gg: "Guernsey",
            gh: "Ghana",
            gi: "Gibraltar",
            gl: "Greenland",
            gm: "Gambia",
            gn: "Guinea",
            gp: "Guadeloupe",
            gq: "Equatorial Guinea",
            gr: "Greece",
            gt: "Guatemala",
            gu: "Guam",
            gw: "Guinea-Bissau",
            gy: "Guyana",
            hk: "Hong Kong SAR China",
            hn: "Honduras",
            hr: "Croatia",
            ht: "Haiti",
            hu: "Hungary",
            id: "Indonesia",
            ie: "Ireland",
            il: "Israel",
            im: "Isle of Man",
            in: "India",
            io: "British Indian Ocean Territory",
            iq: "Iraq",
            ir: "Iran",
            is: "Iceland",
            it: "Italy",
            je: "Jersey",
            jm: "Jamaica",
            jo: "Jordan",
            jp: "Japan",
            ke: "Kenya",
            kg: "Kyrgyzstan",
            kh: "Cambodia",
            ki: "Kiribati",
            km: "Comoros",
            kn: "St. Kitts & Nevis",
            kp: "North Korea",
            kr: "South Korea",
            kw: "Kuwait",
            ky: "Cayman Islands",
            kz: "Kazakhstan",
            la: "Laos",
            lb: "Lebanon",
            lc: "St. Lucia",
            li: "Liechtenstein",
            lk: "Sri Lanka",
            lr: "Liberia",
            ls: "Lesotho",
            lt: "Lithuania",
            lu: "Luxembourg",
            lv: "Latvia",
            ly: "Libya",
            ma: "Morocco",
            mc: "Monaco",
            md: "Moldova",
            me: "Montenegro",
            mf: "St. Martin",
            mg: "Madagascar",
            mh: "Marshall Islands",
            mk: "North Macedonia",
            ml: "Mali",
            mm: "Myanmar (Burma)",
            mn: "Mongolia",
            mo: "Macao SAR China",
            mp: "Northern Mariana Islands",
            mq: "Martinique",
            mr: "Mauritania",
            ms: "Montserrat",
            mt: "Malta",
            mu: "Mauritius",
            mv: "Maldives",
            mw: "Malawi",
            mx: "Mexico",
            my: "Malaysia",
            mz: "Mozambique",
            na: "Namibia",
            nc: "New Caledonia",
            ne: "Niger",
            nf: "Norfolk Island",
            ng: "Nigeria",
            ni: "Nicaragua",
            nl: "Netherlands",
            no: "Norway",
            np: "Nepal",
            nr: "Nauru",
            nu: "Niue",
            nz: "New Zealand",
            om: "Oman",
            pa: "Panama",
            pe: "Peru",
            pf: "French Polynesia",
            pg: "Papua New Guinea",
            ph: "Philippines",
            pk: "Pakistan",
            pl: "Poland",
            pm: "St. Pierre & Miquelon",
            pr: "Puerto Rico",
            ps: "Palestinian Territories",
            pt: "Portugal",
            pw: "Palau",
            py: "Paraguay",
            qa: "Qatar",
            re: "Réunion",
            ro: "Romania",
            rs: "Serbia",
            ru: "Russia",
            rw: "Rwanda",
            sa: "Saudi Arabia",
            sb: "Solomon Islands",
            sc: "Seychelles",
            sd: "Sudan",
            se: "Sweden",
            sg: "Singapore",
            sh: "St. Helena",
            si: "Slovenia",
            sj: "Svalbard & Jan Mayen",
            sk: "Slovakia",
            sl: "Sierra Leone",
            sm: "San Marino",
            sn: "Senegal",
            so: "Somalia",
            sr: "Suriname",
            ss: "South Sudan",
            st: "São Tomé & Príncipe",
            sv: "El Salvador",
            sx: "Sint Maarten",
            sy: "Syria",
            sz: "Eswatini",
            tc: "Turks & Caicos Islands",
            td: "Chad",
            tg: "Togo",
            th: "Thailand",
            tj: "Tajikistan",
            tk: "Tokelau",
            tl: "Timor-Leste",
            tm: "Turkmenistan",
            tn: "Tunisia",
            to: "Tonga",
            tr: "Turkey",
            tt: "Trinidad & Tobago",
            tv: "Tuvalu",
            tw: "Taiwan",
            tz: "Tanzania",
            ua: "Ukraine",
            ug: "Uganda",
            us: "United States",
            uy: "Uruguay",
            uz: "Uzbekistan",
            va: "Vatican City",
            vc: "St. Vincent & Grenadines",
            ve: "Venezuela",
            vg: "British Virgin Islands",
            vi: "U.S. Virgin Islands",
            vn: "Vietnam",
            vu: "Vanuatu",
            wf: "Wallis & Futuna",
            ws: "Samoa",
            ye: "Yemen",
            yt: "Mayotte",
            za: "South Africa",
            zm: "Zambia",
            zw: "Zimbabwe"
          },
          de = W,
          _e = {
            selectedCountryAriaLabel: "Selected country",
            noCountrySelected: "No country selected",
            countryListAriaLabel: "List of countries",
            searchPlaceholder: "Search",
            zeroSearchResults: "No results found",
            oneSearchResult: "1 result found",
            multipleSearchResults: "${count} results found",
            ac: "Ascension Island",
            xk: "Kosovo"
          },
          Ae = _e,
          xe = {
            ...de,
            ...Ae
          },
          Ie = xe;
        for (let K = 0; K < Q.length; K++) Q[K].name = Ie[Q[K].iso2];
        var Pe = 0,
          De = {
            allowDropdown: !0,
            autoPlaceholder: "polite",
            containerClass: "",
            countryOrder: null,
            countrySearch: !0,
            customPlaceholder: null,
            dropdownContainer: null,
            excludeCountries: [],
            fixDropdownWidth: !0,
            formatAsYouType: !0,
            formatOnDisplay: !0,
            geoIpLookup: null,
            hiddenInput: null,
            i18n: {},
            initialCountry: "",
            loadUtils: null,
            nationalMode: !0,
            onlyCountries: [],
            placeholderNumberType: "MOBILE",
            showFlags: !0,
            separateDialCode: !1,
            strictMode: !1,
            useFullscreenPopup: typeof navigator < "u" && typeof window < "u" ? /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 500 : !1,
            validationNumberTypes: ["MOBILE"]
          },
          $e = ["800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889"],
          tt = K => K.replace(/\D/g, ""),
          Ve = (K = "") => K.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase(),
          Re = K => {
            const ee = tt(K);
            if (ee.charAt(0) === "1") {
              const le = ee.substr(1, 3);
              return $e.includes(le)
            }
            return !1
          },
          Ue = (K, ee, le, ae) => {
            if (le === 0 && !ae) return 0;
            let ke = 0;
            for (let qe = 0; qe < ee.length; qe++) {
              if (/[+0-9]/.test(ee[qe]) && ke++, ke === K && !ae) return qe + 1;
              if (ae && ke === K + 1) return qe
            }
            return ee.length
          },
          Ce = (K, ee, le) => {
            const ae = document.createElement(K);
            return ee && Object.entries(ee).forEach(([ke, qe]) => ae.setAttribute(ke, qe)), le && le.appendChild(ae), ae
          },
          We = (K, ...ee) => {
            const {
              instances: le
            } = Ee;
            Object.values(le).forEach(ae => ae[K](...ee))
          },
          Je = class {
            constructor(K, ee = {}) {
              this.id = Pe++, this.telInput = K, this.highlightedItem = null, this.options = Object.assign({}, De, ee), this.hadInitialPlaceholder = !!K.getAttribute("placeholder")
            }
            _init() {
              this.options.useFullscreenPopup && (this.options.fixDropdownWidth = !1), this.options.onlyCountries.length === 1 && (this.options.initialCountry = this.options.onlyCountries[0]), this.options.separateDialCode && (this.options.nationalMode = !1), this.options.allowDropdown && !this.options.showFlags && !this.options.separateDialCode && (this.options.nationalMode = !1), this.options.useFullscreenPopup && !this.options.dropdownContainer && (this.options.dropdownContainer = document.body), this.isAndroid = typeof navigator < "u" ? /Android/i.test(navigator.userAgent) : !1, this.isRTL = !!this.telInput.closest("[dir=rtl]");
              const K = this.options.allowDropdown || this.options.separateDialCode;
              this.showSelectedCountryOnLeft = this.isRTL ? !K : K, this.options.separateDialCode && (this.isRTL ? this.originalPaddingRight = this.telInput.style.paddingRight : this.originalPaddingLeft = this.telInput.style.paddingLeft), this.options.i18n = {
                ...Ie,
                ...this.options.i18n
              };
              const ee = new Promise((ae, ke) => {
                  this.resolveAutoCountryPromise = ae, this.rejectAutoCountryPromise = ke
                }),
                le = new Promise((ae, ke) => {
                  this.resolveUtilsScriptPromise = ae, this.rejectUtilsScriptPromise = ke
                });
              this.promise = Promise.all([ee, le]), this.selectedCountryData = {}, this._processCountryData(), this._generateMarkup(), this._setInitialState(), this._initListeners(), this._initRequests()
            }
            _processCountryData() {
              this._processAllCountries(), this._processDialCodes(), this._translateCountryNames(), this._sortCountries()
            }
            _sortCountries() {
              this.options.countryOrder && (this.options.countryOrder = this.options.countryOrder.map(K => K.toLowerCase())), this.countries.sort((K, ee) => {
                const {
                  countryOrder: le
                } = this.options;
                if (le) {
                  const ae = le.indexOf(K.iso2),
                    ke = le.indexOf(ee.iso2),
                    qe = ae > -1,
                    lt = ke > -1;
                  if (qe || lt) return qe && lt ? ae - ke : qe ? -1 : 1
                }
                return K.name.localeCompare(ee.name)
              })
            }
            _addToDialCodeMap(K, ee, le) {
              ee.length > this.dialCodeMaxLen && (this.dialCodeMaxLen = ee.length), this.dialCodeToIso2Map.hasOwnProperty(ee) || (this.dialCodeToIso2Map[ee] = []);
              for (let ke = 0; ke < this.dialCodeToIso2Map[ee].length; ke++)
                if (this.dialCodeToIso2Map[ee][ke] === K) return;
              const ae = le !== void 0 ? le : this.dialCodeToIso2Map[ee].length;
              this.dialCodeToIso2Map[ee][ae] = K
            }
            _processAllCountries() {
              const {
                onlyCountries: K,
                excludeCountries: ee
              } = this.options;
              if (K.length) {
                const le = K.map(ae => ae.toLowerCase());
                this.countries = Q.filter(ae => le.includes(ae.iso2))
              } else if (ee.length) {
                const le = ee.map(ae => ae.toLowerCase());
                this.countries = Q.filter(ae => !le.includes(ae.iso2))
              } else this.countries = Q
            }
            _translateCountryNames() {
              for (let K = 0; K < this.countries.length; K++) {
                const ee = this.countries[K].iso2.toLowerCase();
                this.options.i18n.hasOwnProperty(ee) && (this.countries[K].name = this.options.i18n[ee])
              }
            }
            _processDialCodes() {
              this.dialCodes = {}, this.dialCodeMaxLen = 0, this.dialCodeToIso2Map = {};
              for (let K = 0; K < this.countries.length; K++) {
                const ee = this.countries[K];
                this.dialCodes[ee.dialCode] || (this.dialCodes[ee.dialCode] = !0), this._addToDialCodeMap(ee.iso2, ee.dialCode, ee.priority)
              }
              for (let K = 0; K < this.countries.length; K++) {
                const ee = this.countries[K];
                if (ee.areaCodes) {
                  const le = this.dialCodeToIso2Map[ee.dialCode][0];
                  for (let ae = 0; ae < ee.areaCodes.length; ae++) {
                    const ke = ee.areaCodes[ae];
                    for (let qe = 1; qe < ke.length; qe++) {
                      const lt = ke.substr(0, qe),
                        ot = ee.dialCode + lt;
                      this._addToDialCodeMap(le, ot), this._addToDialCodeMap(ee.iso2, ot)
                    }
                    this._addToDialCodeMap(ee.iso2, ee.dialCode + ke)
                  }
                }
              }
            }
            _generateMarkup() {
              var ut, gt, St;
              this.telInput.classList.add("iti__tel-input"), !this.telInput.hasAttribute("autocomplete") && !(this.telInput.form && this.telInput.form.hasAttribute("autocomplete")) && this.telInput.setAttribute("autocomplete", "off");
              const {
                allowDropdown: K,
                separateDialCode: ee,
                showFlags: le,
                containerClass: ae,
                hiddenInput: ke,
                dropdownContainer: qe,
                fixDropdownWidth: lt,
                useFullscreenPopup: ot,
                countrySearch: dt,
                i18n: Pt
              } = this.options;
              let Lt = "iti";
              K && (Lt += " iti--allow-dropdown"), le && (Lt += " iti--show-flags"), ae && (Lt += ` ${ae}`), ot || (Lt += " iti--inline-dropdown");
              const He = Ce("div", {
                class: Lt
              });
              if ((ut = this.telInput.parentNode) == null || ut.insertBefore(He, this.telInput), K || le || ee) {
                this.countryContainer = Ce("div", {
                  class: "iti__country-container"
                }, He), this.showSelectedCountryOnLeft ? this.countryContainer.style.left = "0px" : this.countryContainer.style.right = "0px", K ? (this.selectedCountry = Ce("button", {
                  type: "button",
                  class: "iti__selected-country",
                  "aria-expanded": "false",
                  "aria-label": this.options.i18n.selectedCountryAriaLabel,
                  "aria-haspopup": "true",
                  "aria-controls": `iti-${this.id}__dropdown-content`,
                  role: "combobox"
                }, this.countryContainer), this.telInput.disabled && this.selectedCountry.setAttribute("disabled", "true")) : this.selectedCountry = Ce("div", {
                  class: "iti__selected-country"
                }, this.countryContainer);
                const vt = Ce("div", {
                  class: "iti__selected-country-primary"
                }, this.selectedCountry);
                if (this.selectedCountryInner = Ce("div", {
                    class: "iti__flag"
                  }, vt), this.selectedCountryA11yText = Ce("span", {
                    class: "iti__a11y-text"
                  }, this.selectedCountryInner), K && (this.dropdownArrow = Ce("div", {
                    class: "iti__arrow",
                    "aria-hidden": "true"
                  }, vt)), ee && (this.selectedDialCode = Ce("div", {
                    class: "iti__selected-dial-code"
                  }, this.selectedCountry)), K) {
                  const Ct = lt ? "" : "iti--flexible-dropdown-width";
                  if (this.dropdownContent = Ce("div", {
                      id: `iti-${this.id}__dropdown-content`,
                      class: `iti__dropdown-content iti__hide ${Ct}`
                    }), dt && (this.searchInput = Ce("input", {
                      type: "text",
                      class: "iti__search-input",
                      placeholder: Pt.searchPlaceholder,
                      role: "combobox",
                      "aria-expanded": "true",
                      "aria-label": Pt.searchPlaceholder,
                      "aria-controls": `iti-${this.id}__country-listbox`,
                      "aria-autocomplete": "list",
                      autocomplete: "off"
                    }, this.dropdownContent), this.searchResultsA11yText = Ce("span", {
                      class: "iti__a11y-text"
                    }, this.dropdownContent)), this.countryList = Ce("ul", {
                      class: "iti__country-list",
                      id: `iti-${this.id}__country-listbox`,
                      role: "listbox",
                      "aria-label": Pt.countryListAriaLabel
                    }, this.dropdownContent), this._appendListItems(), dt && this._updateSearchResultsText(), qe) {
                    let At = "iti iti--container";
                    ot ? At += " iti--fullscreen-popup" : At += " iti--inline-dropdown", this.dropdown = Ce("div", {
                      class: At
                    }), this.dropdown.appendChild(this.dropdownContent)
                  } else this.countryContainer.appendChild(this.dropdownContent)
                }
              }
              if (He.appendChild(this.telInput), this._updateInputPadding(), ke) {
                const vt = this.telInput.getAttribute("name") || "",
                  Ct = ke(vt);
                if (Ct.phone) {
                  const At = (gt = this.telInput.form) == null ? void 0 : gt.querySelector(`input[name="${Ct.phone}"]`);
                  At ? this.hiddenInput = At : (this.hiddenInput = Ce("input", {
                    type: "hidden",
                    name: Ct.phone
                  }), He.appendChild(this.hiddenInput))
                }
                if (Ct.country) {
                  const At = (St = this.telInput.form) == null ? void 0 : St.querySelector(`input[name="${Ct.country}"]`);
                  At ? this.hiddenInputCountry = At : (this.hiddenInputCountry = Ce("input", {
                    type: "hidden",
                    name: Ct.country
                  }), He.appendChild(this.hiddenInputCountry))
                }
              }
            }
            _appendListItems() {
              for (let K = 0; K < this.countries.length; K++) {
                const ee = this.countries[K],
                  le = K === 0 ? "iti__highlight" : "",
                  ae = Ce("li", {
                    id: `iti-${this.id}__item-${ee.iso2}`,
                    class: `iti__country ${le}`,
                    tabindex: "-1",
                    role: "option",
                    "data-dial-code": ee.dialCode,
                    "data-country-code": ee.iso2,
                    "aria-selected": "false"
                  }, this.countryList);
                ee.nodeById[this.id] = ae;
                let ke = "";
                this.options.showFlags && (ke += `<div class='iti__flag iti__${ee.iso2}'></div>`), ke += `<span class='iti__country-name'>${ee.name}</span>`, ke += `<span class='iti__dial-code'>+${ee.dialCode}</span>`, ae.insertAdjacentHTML("beforeend", ke)
              }
            }
            _setInitialState(K = !1) {
              const ee = this.telInput.getAttribute("value"),
                le = this.telInput.value,
                ke = ee && ee.charAt(0) === "+" && (!le || le.charAt(0) !== "+") ? ee : le,
                qe = this._getDialCode(ke),
                lt = Re(ke),
                {
                  initialCountry: ot,
                  geoIpLookup: dt
                } = this.options,
                Pt = ot === "auto" && dt;
              if (qe && !lt) this._updateCountryFromNumber(ke);
              else if (!Pt || K) {
                const Lt = ot ? ot.toLowerCase() : "";
                Lt && this._getCountryData(Lt, !0) ? this._setCountry(Lt) : qe && lt ? this._setCountry("us") : this._setCountry()
              }
              ke && this._updateValFromNumber(ke)
            }
            _initListeners() {
              this._initTelInputListeners(), this.options.allowDropdown && this._initDropdownListeners(), (this.hiddenInput || this.hiddenInputCountry) && this.telInput.form && this._initHiddenInputListener()
            }
            _initHiddenInputListener() {
              var K;
              this._handleHiddenInputSubmit = () => {
                this.hiddenInput && (this.hiddenInput.value = this.getNumber()), this.hiddenInputCountry && (this.hiddenInputCountry.value = this.getSelectedCountryData().iso2 || "")
              }, (K = this.telInput.form) == null || K.addEventListener("submit", this._handleHiddenInputSubmit)
            }
            _initDropdownListeners() {
              this._handleLabelClick = ee => {
                this.dropdownContent.classList.contains("iti__hide") ? this.telInput.focus() : ee.preventDefault()
              };
              const K = this.telInput.closest("label");
              K && K.addEventListener("click", this._handleLabelClick), this._handleClickSelectedCountry = () => {
                this.dropdownContent.classList.contains("iti__hide") && !this.telInput.disabled && !this.telInput.readOnly && this._openDropdown()
              }, this.selectedCountry.addEventListener("click", this._handleClickSelectedCountry), this._handleCountryContainerKeydown = ee => {
                this.dropdownContent.classList.contains("iti__hide") && ["ArrowUp", "ArrowDown", " ", "Enter"].includes(ee.key) && (ee.preventDefault(), ee.stopPropagation(), this._openDropdown()), ee.key === "Tab" && this._closeDropdown()
              }, this.countryContainer.addEventListener("keydown", this._handleCountryContainerKeydown)
            }
            _initRequests() {
              let {
                loadUtils: K,
                initialCountry: ee,
                geoIpLookup: le
              } = this.options;
              K && !Ee.utils ? (this._handlePageLoad = () => {
                var ke;
                window.removeEventListener("load", this._handlePageLoad), (ke = Ee.attachUtils(K)) == null || ke.catch(() => {})
              }, Ee.documentReady() ? this._handlePageLoad() : window.addEventListener("load", this._handlePageLoad)) : this.resolveUtilsScriptPromise(), ee === "auto" && le && !this.selectedCountryData.iso2 ? this._loadAutoCountry() : this.resolveAutoCountryPromise()
            }
            _loadAutoCountry() {
              Ee.autoCountry ? this.handleAutoCountry() : Ee.startedLoadingAutoCountry || (Ee.startedLoadingAutoCountry = !0, typeof this.options.geoIpLookup == "function" && this.options.geoIpLookup((K = "") => {
                const ee = K.toLowerCase();
                ee && this._getCountryData(ee, !0) ? (Ee.autoCountry = ee, setTimeout(() => We("handleAutoCountry"))) : (this._setInitialState(!0), We("rejectAutoCountryPromise"))
              }, () => {
                this._setInitialState(!0), We("rejectAutoCountryPromise")
              }))
            }
            _openDropdownWithPlus() {
              this._openDropdown(), this.searchInput.value = "+", this._filterCountries("", !0)
            }
            _initTelInputListeners() {
              const {
                strictMode: K,
                formatAsYouType: ee,
                separateDialCode: le,
                formatOnDisplay: ae,
                allowDropdown: ke,
                countrySearch: qe
              } = this.options;
              let lt = !1;
              new RegExp("\\p{L}", "u").test(this.telInput.value) && (lt = !0), this._handleInputEvent = ot => {
                if (this.isAndroid && (ot == null ? void 0 : ot.data) === "+" && le && ke && qe) {
                  const He = this.telInput.selectionStart || 0,
                    ut = this.telInput.value.substring(0, He - 1),
                    gt = this.telInput.value.substring(He);
                  this.telInput.value = ut + gt, this._openDropdownWithPlus();
                  return
                }
                this._updateCountryFromNumber(this.telInput.value) && this._triggerCountryChange();
                const dt = (ot == null ? void 0 : ot.data) && /[^+0-9]/.test(ot.data),
                  Pt = (ot == null ? void 0 : ot.inputType) === "insertFromPaste" && this.telInput.value;
                dt || Pt && !K ? lt = !0 : /[^+0-9]/.test(this.telInput.value) || (lt = !1);
                const Lt = (ot == null ? void 0 : ot.detail) && ot.detail.isSetNumber && !ae;
                if (ee && !lt && !Lt) {
                  const He = this.telInput.selectionStart || 0,
                    gt = this.telInput.value.substring(0, He).replace(/[^+0-9]/g, "").length,
                    St = (ot == null ? void 0 : ot.inputType) === "deleteContentForward",
                    vt = this._formatNumberAsYouType(),
                    Ct = Ue(gt, vt, He, St);
                  this.telInput.value = vt, this.telInput.setSelectionRange(Ct, Ct)
                }
              }, this.telInput.addEventListener("input", this._handleInputEvent), (K || le) && (this._handleKeydownEvent = ot => {
                if (ot.key && ot.key.length === 1 && !ot.altKey && !ot.ctrlKey && !ot.metaKey) {
                  if (le && ke && qe && ot.key === "+") {
                    ot.preventDefault(), this._openDropdownWithPlus();
                    return
                  }
                  if (K) {
                    const dt = this.telInput.value,
                      Pt = dt.charAt(0) === "+",
                      Lt = !Pt && this.telInput.selectionStart === 0 && ot.key === "+",
                      He = /^[0-9]$/.test(ot.key),
                      ut = le ? He : Lt || He,
                      gt = dt.slice(0, this.telInput.selectionStart) + ot.key + dt.slice(this.telInput.selectionEnd),
                      St = this._getFullNumber(gt),
                      vt = Ee.utils.getCoreNumber(St, this.selectedCountryData.iso2),
                      Ct = this.maxCoreNumberLength && vt.length > this.maxCoreNumberLength;
                    let At = !1;
                    if (Pt) {
                      const Bt = this.selectedCountryData.iso2;
                      At = this._getCountryFromNumber(St) !== Bt
                    }(!ut || Ct && !At && !Lt) && ot.preventDefault()
                  }
                }
              }, this.telInput.addEventListener("keydown", this._handleKeydownEvent))
            }
            _cap(K) {
              const ee = parseInt(this.telInput.getAttribute("maxlength") || "", 10);
              return ee && K.length > ee ? K.substr(0, ee) : K
            }
            _trigger(K, ee = {}) {
              const le = new CustomEvent(K, {
                bubbles: !0,
                cancelable: !0,
                detail: ee
              });
              this.telInput.dispatchEvent(le)
            }
            _openDropdown() {
              const {
                fixDropdownWidth: K,
                countrySearch: ee
              } = this.options;
              if (K && (this.dropdownContent.style.width = `${this.telInput.offsetWidth}px`), this.dropdownContent.classList.remove("iti__hide"), this.selectedCountry.setAttribute("aria-expanded", "true"), this._setDropdownPosition(), ee) {
                const le = this.countryList.firstElementChild;
                le && (this._highlightListItem(le, !1), this.countryList.scrollTop = 0), this.searchInput.focus()
              }
              this._bindDropdownListeners(), this.dropdownArrow.classList.add("iti__arrow--up"), this._trigger("open:countrydropdown")
            }
            _setDropdownPosition() {
              if (this.options.dropdownContainer && this.options.dropdownContainer.appendChild(this.dropdown), !this.options.useFullscreenPopup) {
                const K = this.telInput.getBoundingClientRect(),
                  ee = this.telInput.offsetHeight;
                this.options.dropdownContainer && (this.dropdown.style.top = `${K.top+ee}px`, this.dropdown.style.left = `${K.left}px`, this._handleWindowScroll = () => this._closeDropdown(), window.addEventListener("scroll", this._handleWindowScroll))
              }
            }
            _bindDropdownListeners() {
              this._handleMouseoverCountryList = ae => {
                var qe;
                const ke = (qe = ae.target) == null ? void 0 : qe.closest(".iti__country");
                ke && this._highlightListItem(ke, !1)
              }, this.countryList.addEventListener("mouseover", this._handleMouseoverCountryList), this._handleClickCountryList = ae => {
                var qe;
                const ke = (qe = ae.target) == null ? void 0 : qe.closest(".iti__country");
                ke && this._selectListItem(ke)
              }, this.countryList.addEventListener("click", this._handleClickCountryList);
              let K = !0;
              this._handleClickOffToClose = () => {
                K || this._closeDropdown(), K = !1
              }, document.documentElement.addEventListener("click", this._handleClickOffToClose);
              let ee = "",
                le = null;
              if (this._handleKeydownOnDropdown = ae => {
                  ["ArrowUp", "ArrowDown", "Enter", "Escape"].includes(ae.key) && (ae.preventDefault(), ae.stopPropagation(), ae.key === "ArrowUp" || ae.key === "ArrowDown" ? this._handleUpDownKey(ae.key) : ae.key === "Enter" ? this._handleEnterKey() : ae.key === "Escape" && this._closeDropdown()), !this.options.countrySearch && /^[a-zA-ZÀ-ÿа-яА-Я ]$/.test(ae.key) && (ae.stopPropagation(), le && clearTimeout(le), ee += ae.key.toLowerCase(), this._searchForCountry(ee), le = setTimeout(() => {
                    ee = ""
                  }, 1e3))
                }, document.addEventListener("keydown", this._handleKeydownOnDropdown), this.options.countrySearch) {
                const ae = () => {
                  const qe = this.searchInput.value.trim();
                  qe ? this._filterCountries(qe) : this._filterCountries("", !0)
                };
                let ke = null;
                this._handleSearchChange = () => {
                  ke && clearTimeout(ke), ke = setTimeout(() => {
                    ae(), ke = null
                  }, 100)
                }, this.searchInput.addEventListener("input", this._handleSearchChange), this.searchInput.addEventListener("click", qe => qe.stopPropagation())
              }
            }
            _searchForCountry(K) {
              for (let ee = 0; ee < this.countries.length; ee++) {
                const le = this.countries[ee];
                if (le.name.substr(0, K.length).toLowerCase() === K) {
                  const ke = le.nodeById[this.id];
                  this._highlightListItem(ke, !1), this._scrollTo(ke);
                  break
                }
              }
            }
            _filterCountries(K, ee = !1) {
              let le = !0;
              this.countryList.innerHTML = "";
              const ae = Ve(K);
              for (let ke = 0; ke < this.countries.length; ke++) {
                const qe = this.countries[ke],
                  lt = Ve(qe.name),
                  ot = qe.name.split(/[^a-zA-ZÀ-ÿа-яА-Я]/).map(Pt => Pt[0]).join("").toLowerCase(),
                  dt = `+${qe.dialCode}`;
                if (ee || lt.includes(ae) || dt.includes(ae) || qe.iso2.includes(ae) || ot.includes(ae)) {
                  const Pt = qe.nodeById[this.id];
                  Pt && this.countryList.appendChild(Pt), le && (this._highlightListItem(Pt, !1), le = !1)
                }
              }
              le && this._highlightListItem(null, !1), this.countryList.scrollTop = 0, this._updateSearchResultsText()
            }
            _updateSearchResultsText() {
              const {
                i18n: K
              } = this.options, ee = this.countryList.childElementCount;
              let le;
              ee === 0 ? le = K.zeroSearchResults : ee === 1 ? le = K.oneSearchResult : le = K.multipleSearchResults.replace("${count}", ee.toString()), this.searchResultsA11yText.textContent = le
            }
            _handleUpDownKey(K) {
              var le, ae;
              let ee = K === "ArrowUp" ? (le = this.highlightedItem) == null ? void 0 : le.previousElementSibling : (ae = this.highlightedItem) == null ? void 0 : ae.nextElementSibling;
              !ee && this.countryList.childElementCount > 1 && (ee = K === "ArrowUp" ? this.countryList.lastElementChild : this.countryList.firstElementChild), ee && (this._scrollTo(ee), this._highlightListItem(ee, !1))
            }
            _handleEnterKey() {
              this.highlightedItem && this._selectListItem(this.highlightedItem)
            }
            _updateValFromNumber(K) {
              let ee = K;
              if (this.options.formatOnDisplay && Ee.utils && this.selectedCountryData) {
                const le = this.options.nationalMode || ee.charAt(0) !== "+" && !this.options.separateDialCode,
                  {
                    NATIONAL: ae,
                    INTERNATIONAL: ke
                  } = Ee.utils.numberFormat,
                  qe = le ? ae : ke;
                ee = Ee.utils.formatNumber(ee, this.selectedCountryData.iso2, qe)
              }
              ee = this._beforeSetNumber(ee), this.telInput.value = ee
            }
            _updateCountryFromNumber(K) {
              const ee = this._getCountryFromNumber(K);
              return ee !== null ? this._setCountry(ee) : !1
            }
            _ensureHasDialCode(K) {
              const {
                dialCode: ee,
                nationalPrefix: le
              } = this.selectedCountryData;
              if (K.charAt(0) === "+" || !ee) return K;
              const qe = le && K.charAt(0) === le && !this.options.separateDialCode ? K.substring(1) : K;
              return `+${ee}${qe}`
            }
            _getCountryFromNumber(K) {
              const ee = K.indexOf("+");
              let le = ee ? K.substring(ee) : K;
              const ae = this.selectedCountryData.iso2,
                ke = this.selectedCountryData.dialCode;
              le = this._ensureHasDialCode(le);
              const qe = this._getDialCode(le, !0),
                lt = tt(le);
              if (qe) {
                const ot = tt(qe),
                  dt = this.dialCodeToIso2Map[ot];
                if (!ae && this.defaultCountry && dt.includes(this.defaultCountry)) return this.defaultCountry;
                const Pt = ae && dt.includes(ae) && (lt.length === ot.length || !this.selectedCountryData.areaCodes);
                if (!(ke === "1" && Re(lt)) && !Pt) {
                  for (let He = 0; He < dt.length; He++)
                    if (dt[He]) return dt[He]
                }
              } else {
                if (le.charAt(0) === "+" && lt.length) return "";
                if ((!le || le === "+") && !this.selectedCountryData.iso2) return this.defaultCountry
              }
              return null
            }
            _highlightListItem(K, ee) {
              const le = this.highlightedItem;
              if (le && (le.classList.remove("iti__highlight"), le.setAttribute("aria-selected", "false")), this.highlightedItem = K, this.highlightedItem) {
                this.highlightedItem.classList.add("iti__highlight"), this.highlightedItem.setAttribute("aria-selected", "true");
                const ae = this.highlightedItem.getAttribute("id") || "";
                this.selectedCountry.setAttribute("aria-activedescendant", ae), this.options.countrySearch && this.searchInput.setAttribute("aria-activedescendant", ae)
              }
              ee && this.highlightedItem.focus()
            }
            _getCountryData(K, ee) {
              for (let le = 0; le < this.countries.length; le++)
                if (this.countries[le].iso2 === K) return this.countries[le];
              if (ee) return null;
              throw new Error(`No country data for '${K}'`)
            }
            _setCountry(K) {
              const {
                separateDialCode: ee,
                showFlags: le,
                i18n: ae
              } = this.options, ke = this.selectedCountryData.iso2 ? this.selectedCountryData : {};
              if (this.selectedCountryData = K ? this._getCountryData(K, !1) || {} : {}, this.selectedCountryData.iso2 && (this.defaultCountry = this.selectedCountryData.iso2), this.selectedCountryInner) {
                let qe = "",
                  lt = "";
                K && le ? (qe = `iti__flag iti__${K}`, lt = `${this.selectedCountryData.name} +${this.selectedCountryData.dialCode}`) : (qe = "iti__flag iti__globe", lt = ae.noCountrySelected), this.selectedCountryInner.className = qe, this.selectedCountryA11yText.textContent = lt
              }
              if (this._setSelectedCountryTitleAttribute(K, ee), ee) {
                const qe = this.selectedCountryData.dialCode ? `+${this.selectedCountryData.dialCode}` : "";
                this.selectedDialCode.innerHTML = qe, this._updateInputPadding()
              }
              return this._updatePlaceholder(), this._updateMaxLength(), ke.iso2 !== K
            }
            _updateInputPadding() {
              if (this.selectedCountry) {
                const ee = (this.selectedCountry.offsetWidth || this._getHiddenSelectedCountryWidth()) + 6;
                this.showSelectedCountryOnLeft ? this.telInput.style.paddingLeft = `${ee}px` : this.telInput.style.paddingRight = `${ee}px`
              }
            }
            _updateMaxLength() {
              const {
                strictMode: K,
                placeholderNumberType: ee,
                validationNumberTypes: le
              } = this.options, {
                iso2: ae
              } = this.selectedCountryData;
              if (K && Ee.utils)
                if (ae) {
                  const ke = Ee.utils.numberType[ee];
                  let qe = Ee.utils.getExampleNumber(ae, !1, ke, !0),
                    lt = qe;
                  for (; Ee.utils.isPossibleNumber(qe, ae, le);) lt = qe, qe += "0";
                  const ot = Ee.utils.getCoreNumber(lt, ae);
                  this.maxCoreNumberLength = ot.length, ae === "by" && (this.maxCoreNumberLength = ot.length + 1)
                } else this.maxCoreNumberLength = null
            }
            _setSelectedCountryTitleAttribute(K = null, ee) {
              if (!this.selectedCountry) return;
              let le;
              K && !ee ? le = `${this.selectedCountryData.name}: +${this.selectedCountryData.dialCode}` : K ? le = this.selectedCountryData.name : le = "Unknown", this.selectedCountry.setAttribute("title", le)
            }
            _getHiddenSelectedCountryWidth() {
              if (this.telInput.parentNode) {
                const K = this.telInput.parentNode.cloneNode(!1);
                K.style.visibility = "hidden", document.body.appendChild(K);
                const ee = this.countryContainer.cloneNode();
                K.appendChild(ee);
                const le = this.selectedCountry.cloneNode(!0);
                ee.appendChild(le);
                const ae = le.offsetWidth;
                return document.body.removeChild(K), ae
              }
              return 0
            }
            _updatePlaceholder() {
              const {
                autoPlaceholder: K,
                placeholderNumberType: ee,
                nationalMode: le,
                customPlaceholder: ae
              } = this.options, ke = K === "aggressive" || !this.hadInitialPlaceholder && K === "polite";
              if (Ee.utils && ke) {
                const qe = Ee.utils.numberType[ee];
                let lt = this.selectedCountryData.iso2 ? Ee.utils.getExampleNumber(this.selectedCountryData.iso2, le, qe) : "";
                lt = this._beforeSetNumber(lt), typeof ae == "function" && (lt = ae(lt, this.selectedCountryData)), this.telInput.setAttribute("placeholder", lt)
              }
            }
            _selectListItem(K) {
              const ee = this._setCountry(K.getAttribute("data-country-code"));
              this._closeDropdown(), this._updateDialCode(K.getAttribute("data-dial-code")), this.telInput.focus(), ee && this._triggerCountryChange()
            }
            _closeDropdown() {
              this.dropdownContent.classList.add("iti__hide"), this.selectedCountry.setAttribute("aria-expanded", "false"), this.selectedCountry.removeAttribute("aria-activedescendant"), this.highlightedItem && this.highlightedItem.setAttribute("aria-selected", "false"), this.options.countrySearch && this.searchInput.removeAttribute("aria-activedescendant"), this.dropdownArrow.classList.remove("iti__arrow--up"), document.removeEventListener("keydown", this._handleKeydownOnDropdown), this.options.countrySearch && this.searchInput.removeEventListener("input", this._handleSearchChange), document.documentElement.removeEventListener("click", this._handleClickOffToClose), this.countryList.removeEventListener("mouseover", this._handleMouseoverCountryList), this.countryList.removeEventListener("click", this._handleClickCountryList), this.options.dropdownContainer && (this.options.useFullscreenPopup || window.removeEventListener("scroll", this._handleWindowScroll), this.dropdown.parentNode && this.dropdown.parentNode.removeChild(this.dropdown)), this._handlePageLoad && window.removeEventListener("load", this._handlePageLoad), this._trigger("close:countrydropdown")
            }
            _scrollTo(K) {
              const ee = this.countryList,
                le = document.documentElement.scrollTop,
                ae = ee.offsetHeight,
                ke = ee.getBoundingClientRect().top + le,
                qe = ke + ae,
                lt = K.offsetHeight,
                ot = K.getBoundingClientRect().top + le,
                dt = ot + lt,
                Pt = ot - ke + ee.scrollTop;
              if (ot < ke) ee.scrollTop = Pt;
              else if (dt > qe) {
                const Lt = ae - lt;
                ee.scrollTop = Pt - Lt
              }
            }
            _updateDialCode(K) {
              const ee = this.telInput.value,
                le = `+${K}`;
              let ae;
              if (ee.charAt(0) === "+") {
                const ke = this._getDialCode(ee);
                ke ? ae = ee.replace(ke, le) : ae = le, this.telInput.value = ae
              }
            }
            _getDialCode(K, ee) {
              let le = "";
              if (K.charAt(0) === "+") {
                let ae = "";
                for (let ke = 0; ke < K.length; ke++) {
                  const qe = K.charAt(ke);
                  if (!isNaN(parseInt(qe, 10))) {
                    if (ae += qe, ee) this.dialCodeToIso2Map[ae] && (le = K.substr(0, ke + 1));
                    else if (this.dialCodes[ae]) {
                      le = K.substr(0, ke + 1);
                      break
                    }
                    if (ae.length === this.dialCodeMaxLen) break
                  }
                }
              }
              return le
            }
            _getFullNumber(K) {
              const ee = K || this.telInput.value.trim(),
                {
                  dialCode: le
                } = this.selectedCountryData;
              let ae;
              const ke = tt(ee);
              return this.options.separateDialCode && ee.charAt(0) !== "+" && le && ke ? ae = `+${le}` : ae = "", ae + ee
            }
            _beforeSetNumber(K) {
              let ee = K;
              if (this.options.separateDialCode) {
                let le = this._getDialCode(ee);
                if (le) {
                  le = `+${this.selectedCountryData.dialCode}`;
                  const ae = ee[le.length] === " " || ee[le.length] === "-" ? le.length + 1 : le.length;
                  ee = ee.substr(ae)
                }
              }
              return this._cap(ee)
            }
            _triggerCountryChange() {
              this._trigger("countrychange")
            }
            _formatNumberAsYouType() {
              const K = this._getFullNumber(),
                ee = Ee.utils ? Ee.utils.formatNumberAsYouType(K, this.selectedCountryData.iso2) : K,
                {
                  dialCode: le
                } = this.selectedCountryData;
              return this.options.separateDialCode && this.telInput.value.charAt(0) !== "+" && ee.includes(`+${le}`) ? (ee.split(`+${le}`)[1] || "").trim() : ee
            }
            handleAutoCountry() {
              this.options.initialCountry === "auto" && Ee.autoCountry && (this.defaultCountry = Ee.autoCountry, this.selectedCountryData.iso2 || this.selectedCountryInner.classList.contains("iti__globe") || this.setCountry(this.defaultCountry), this.resolveAutoCountryPromise())
            }
            handleUtils() {
              Ee.utils && (this.telInput.value && this._updateValFromNumber(this.telInput.value), this.selectedCountryData.iso2 && (this._updatePlaceholder(), this._updateMaxLength())), this.resolveUtilsScriptPromise()
            }
            destroy() {
              var ke, qe;
              const {
                allowDropdown: K,
                separateDialCode: ee
              } = this.options;
              if (K) {
                this._closeDropdown(), this.selectedCountry.removeEventListener("click", this._handleClickSelectedCountry), this.countryContainer.removeEventListener("keydown", this._handleCountryContainerKeydown);
                const lt = this.telInput.closest("label");
                lt && lt.removeEventListener("click", this._handleLabelClick)
              }
              const {
                form: le
              } = this.telInput;
              this._handleHiddenInputSubmit && le && le.removeEventListener("submit", this._handleHiddenInputSubmit), this.telInput.removeEventListener("input", this._handleInputEvent), this._handleKeydownEvent && this.telInput.removeEventListener("keydown", this._handleKeydownEvent), this.telInput.removeAttribute("data-intl-tel-input-id"), ee && (this.isRTL ? this.telInput.style.paddingRight = this.originalPaddingRight : this.telInput.style.paddingLeft = this.originalPaddingLeft);
              const ae = this.telInput.parentNode;
              (ke = ae == null ? void 0 : ae.parentNode) == null || ke.insertBefore(this.telInput, ae), (qe = ae == null ? void 0 : ae.parentNode) == null || qe.removeChild(ae), delete Ee.instances[this.id]
            }
            getExtension() {
              return Ee.utils ? Ee.utils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2) : ""
            }
            getNumber(K) {
              if (Ee.utils) {
                const {
                  iso2: ee
                } = this.selectedCountryData;
                return Ee.utils.formatNumber(this._getFullNumber(), ee, K)
              }
              return ""
            }
            getNumberType() {
              return Ee.utils ? Ee.utils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2) : -99
            }
            getSelectedCountryData() {
              return this.selectedCountryData
            }
            getValidationError() {
              if (Ee.utils) {
                const {
                  iso2: K
                } = this.selectedCountryData;
                return Ee.utils.getValidationError(this._getFullNumber(), K)
              }
              return -99
            }
            isValidNumber() {
              if (!this.selectedCountryData.iso2) return !1;
              const K = this._getFullNumber(),
                ee = K.search(new RegExp("\\p{L}", "u"));
              if (ee > -1) {
                const le = K.substring(0, ee),
                  ae = this._utilsIsPossibleNumber(le),
                  ke = this._utilsIsPossibleNumber(K);
                return ae && ke
              }
              return this._utilsIsPossibleNumber(K)
            }
            _utilsIsPossibleNumber(K) {
              return Ee.utils ? Ee.utils.isPossibleNumber(K, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
            }
            isValidNumberPrecise() {
              if (!this.selectedCountryData.iso2) return !1;
              const K = this._getFullNumber(),
                ee = K.search(new RegExp("\\p{L}", "u"));
              if (ee > -1) {
                const le = K.substring(0, ee),
                  ae = this._utilsIsValidNumber(le),
                  ke = this._utilsIsValidNumber(K);
                return ae && ke
              }
              return this._utilsIsValidNumber(K)
            }
            _utilsIsValidNumber(K) {
              return Ee.utils ? Ee.utils.isValidNumber(K, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
            }
            setCountry(K) {
              const ee = K == null ? void 0 : K.toLowerCase(),
                le = this.selectedCountryData.iso2;
              (K && ee !== le || !K && le) && (this._setCountry(ee), this._updateDialCode(this.selectedCountryData.dialCode), this._triggerCountryChange())
            }
            setNumber(K) {
              const ee = this._updateCountryFromNumber(K);
              this._updateValFromNumber(K), ee && this._triggerCountryChange(), this._trigger("input", {
                isSetNumber: !0
              })
            }
            setPlaceholderNumberType(K) {
              this.options.placeholderNumberType = K, this._updatePlaceholder()
            }
            setDisabled(K) {
              this.telInput.disabled = K, K ? this.selectedCountry.setAttribute("disabled", "true") : this.selectedCountry.removeAttribute("disabled")
            }
          },
          Ge = K => {
            if (!Ee.utils && !Ee.startedLoadingUtilsScript) {
              let ee;
              if (typeof K == "function") try {
                ee = Promise.resolve(K())
              } catch (le) {
                return Promise.reject(le)
              } else return Promise.reject(new TypeError(`The argument passed to attachUtils must be a function that returns a promise for the utilities module, not ${typeof K}`));
              return Ee.startedLoadingUtilsScript = !0, ee.then(le => {
                const ae = le == null ? void 0 : le.default;
                if (!ae || typeof ae != "object") throw new TypeError("The loader function passed to attachUtils did not resolve to a module object with utils as its default export.");
                return Ee.utils = ae, We("handleUtils"), !0
              }).catch(le => {
                throw We("rejectUtilsScriptPromise", le), le
              })
            }
            return null
          },
          Ee = Object.assign((K, ee) => {
            const le = new Je(K, ee);
            return le._init(), K.setAttribute("data-intl-tel-input-id", le.id.toString()), Ee.instances[le.id] = le, le
          }, {
            defaults: De,
            documentReady: () => document.readyState === "complete",
            getCountryData: () => Q,
            getInstance: K => {
              const ee = K.getAttribute("data-intl-tel-input-id");
              return ee ? Ee.instances[ee] : null
            },
            instances: {},
            attachUtils: Ge,
            startedLoadingUtilsScript: !1,
            startedLoadingAutoCountry: !1,
            version: "25.3.2"
          }),
          mt = Ee;
        return F(O)
      })();
      return a.default
    })
  })(sm)), sm.exports
}
var D7 = L7();
const R7 = s_(D7);
var B7 = fe('<div><span class="loading loading-spinner loading-xl"></span></div>'),
  F7 = fe('<span class="w-8"> </span>'),
  O7 = fe('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="text-base-content/80 mt-0.5 text-sm"> </p></div> <form class="mt-8 flex w-full flex-col gap-3"><input class="input pl-12! w-full" type="tel" id="phone"/> <button class="btn btn-primary w-full"> <!></button></form>', 1),
  j7 = async (d, a, h) => {
    await a(x(h))
  }, N7 = fe('<span class="w-8"> </span>'), Z7 = (d, a) => {
    re(a, "")
  }, V7 = fe('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="mt-0.5 text-sm"> </p></div> <div class="mt-4"><!></div> <div class="mt-3 flex flex-col items-center gap-1"><button class="btn btn-ghost w-max"> <!></button> <button class="text-primary cursor-pointer text-xs"> </button></div>', 1), q7 = fe('<div class="flex h-full w-full flex-col items-center justify-center"><!></div>');

function U7(d, a) {
  Ir(a, !0);
  let h = rt(!0),
    y = rt(""),
    k = rt(0),
    E = rt(!1);
  const b = ht(() => x(k) > 0 || x(E));
  let s = rt(!1),
    F = rt(""),
    O = rt(void 0);
  const G = ht(() => {
    var Ae;
    return `phone:${(Ae=wt.data)==null?void 0:Ae.id}`
  });
  Kr(() => {
    const Ae = localStorage.getItem(x(G));
    Ae && re(y, Ae, !0)
  }), An(() => {
    nn.getOtpCooldown().then(Ie => {
      re(k, Ie.cooldownMs, !0)
    }).catch(Ie => {
      Ar.error(Ie.message)
    }).finally(() => {
      re(h, !1)
    });
    const Ae = 1e3,
      xe = setInterval(() => {
        re(k, Math.max(0, x(k) - Ae), !0)
      }, Ae);
    return () => {
      clearInterval(xe)
    }
  });
  async function X(Ae) {
    try {
      re(E, !0);
      const xe = await nn.sendOtp(Ae);
      Ar.info(`${AS()} ${xe.phone}`), re(y, xe.phone, !0), re(k, xe.cooldownMs, !0), localStorage.setItem(x(G), x(y))
    } catch (xe) {
      Ar.error(xe.message)
    } finally {
      re(E, !1)
    }
  }
  Kr(() => {
    x(F).length === 6 && (re(s, !0), (async () => {
      try {
        await nn.verifyOtp(x(F)), await wt.refresh(), Ar.success(LS()), localStorage.removeItem(x(G)), a.onsuccess(x(y))
      } catch (Ae) {
        Ar.error(Ae.message)
      } finally {
        re(F, ""), re(s, !1)
      }
    })())
  });
  var Q = q7(),
    W = P(Q);
  {
    var de = Ae => {
        var xe = B7();
        Z(Ae, xe)
      },
      _e = Ae => {
        var xe = or(),
          Ie = pt(xe);
        {
          var Pe = $e => {
              var tt = O7(),
                Ve = pt(tt),
                Re = P(Ve),
                Ue = P(Re, !0);
              I(Re);
              var Ce = B(Re, 2),
                We = P(Ce, !0);
              I(Ce), I(Ve);
              var Je = B(Ve, 2),
                Ge = P(Je);
              pi(Ge, () => le => (re(O, R7(le, {
                strictMode: !0,
                initialCountry: "br",
                loadUtils: () => bb(() => import("../chunks/CB6dGgTk.js"), [], import.meta.url),
                containerClass: "w-full",
                dropdownContainer: document.body
              })), () => {
                var ae;
                (ae = x(O)) == null || ae.destroy()
              }));
              var Ee = B(Ge, 2),
                mt = P(Ee),
                K = B(mt);
              {
                var ee = le => {
                  var ae = F7(),
                    ke = P(ae);
                  I(ae), Ze(qe => ce(ke, `(${qe??""})`), [() => gp(x(k))]), Z(le, ae)
                };
                Be(K, le => {
                  x(k) > 0 && le(ee)
                })
              }
              I(Ee), I(Je), Ze((le, ae, ke) => {
                ce(Ue, le), ce(We, ae), Ee.disabled = x(b), ce(mt, `${ke??""} `)
              }, [() => bI(), () => TI(), () => PI()]), Zn("submit", Je, async () => {
                var ae;
                if (x(b)) return;
                if (!((ae = x(O)) != null && ae.isValidNumber())) {
                  Ar.error(BS());
                  return
                }
                const le = x(O).getNumber();
                await X(le)
              }), Z($e, tt)
            },
            De = $e => {
              var tt = V7(),
                Ve = pt(tt),
                Re = P(Ve),
                Ue = P(Re, !0);
              I(Re);
              var Ce = B(Re, 2),
                We = P(Ce);
              I(Ce), I(Ve);
              var Je = B(Ve, 2),
                Ge = P(Je);
              {
                const qe = (lt, ot) => {
                  let dt = () => ot == null ? void 0 : ot().cells;
                  var Pt = or(),
                    Lt = pt(Pt);
                  yi(Lt, () => k7, (He, ut) => {
                    ut(He, {
                      class: "border-primary",
                      children: (gt, St) => {
                        var vt = or(),
                          Ct = pt(vt);
                        ai(Ct, 16, dt, At => At, (At, Bt) => {
                          var Vt = or(),
                            Ot = pt(Vt);
                          yi(Ot, () => E7, (Dt, Rt) => {
                            Rt(Dt, {
                              get cell() {
                                return Bt
                              },
                              class: "border-base-content/20 size-11 sm:size-12"
                            })
                          }), Z(At, Vt)
                        }), Z(gt, vt)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  }), Z(lt, Pt)
                };
                yi(Ge, () => z7, (lt, ot) => {
                  ot(lt, {
                    maxlength: 6,
                    class: "mx-auto w-max",
                    get disabled() {
                      return x(s)
                    },
                    get value() {
                      return x(F)
                    },
                    set value(dt) {
                      re(F, dt, !0)
                    },
                    children: qe,
                    $$slots: {
                      default: !0
                    }
                  })
                })
              }
              I(Je);
              var Ee = B(Je, 2),
                mt = P(Ee);
              mt.__click = [j7, X, y];
              var K = P(mt),
                ee = B(K);
              {
                var le = qe => {
                  var lt = N7(),
                    ot = P(lt);
                  I(lt), Ze(dt => ce(ot, `(${dt??""})`), [() => gp(x(k))]), Z(qe, lt)
                };
                Be(ee, qe => {
                  x(k) > 0 && qe(le)
                })
              }
              I(mt);
              var ae = B(mt, 2);
              ae.__click = [Z7, y];
              var ke = P(ae, !0);
              I(ae), I(Ee), Ze((qe, lt, ot, dt) => {
                ce(Ue, qe), ce(We, `${lt??""} ${x(y)??""}`), mt.disabled = x(b), ce(K, `${ot??""} `), ce(ke, dt)
              }, [() => AI(), () => LI(), () => BI(), () => jI()]), Z($e, tt)
            };
          Be(Ie, $e => {
            x(y) ? $e(De, !1) : $e(Pe)
          }, !0)
        }
        Z(Ae, xe)
      };
    Be(W, Ae => {
      x(h) ? Ae(de) : Ae(_e, !1)
    })
  }
  I(Q), Z(d, Q), Pr()
}
Ln(["click"]);
var $7 = fe('<dialog class="modal"><div class="modal-box h-72 max-w-sm"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div></dialog>');

function G7(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15);
  var y = $7(),
    k = P(y),
    E = B(P(k), 2);
  {
    var b = s => {
      U7(s, {
        onsuccess: () => h(!1)
      })
    };
    Be(E, s => {
      h() && s(b)
    })
  }
  I(k), I(y), pi(y, () => s => {
    Kr(() => {
      h() ? s.show() : s.close()
    })
  }), Zn("close", y, () => h(!1)), Z(d, y), Pr()
}
var W7 = (d, a) => {
    a(!1)
  },
  H7 = fe('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><p class="whitespace-pre-wrap"><!></p> <div class="mt-4"><!></div> <div class="mt-2 flex justify-end gap-2"><button class="btn btn-soft tooltip" type="button"> </button> <div class="tooltip tooltip-top"><div class="tooltip-content translate-x-[-30%] p-2"> </div> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog>');

function J7(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15),
    y = rt(!1),
    k = rt(""),
    E = rt(0),
    b = rt(!1);
  Kr(() => {
    h() && (async () => {
      try {
        re(y, !0);
        const Re = await nn.getUserLastAppeal();
        if (Re === null) {
          re(b, !1), re(E, 0);
          return
        }
        const Ue = new Date(Re),
          Ce = 1440 * 60 * 1e3;
        Date.now() - Ue.getTime() < 90 * Ce ? (re(b, !0), re(E, Math.ceil((Ue.getTime() + 90 * Ce - Date.now()) / Ce), !0)) : re(E, 0)
      } catch (Re) {
        Ar.error(Re.message)
      } finally {
        re(y, !1)
      }
    })()
  });
  var s = H7(),
    F = P(s),
    O = B(P(F), 2),
    G = P(O, !0);
  I(O);
  var X = B(O, 2),
    Q = P(X),
    W = P(Q);
  Pp(W, () => U4()), I(Q);
  var de = B(Q, 2),
    _e = P(de);
  {
    let Re = ht(() => W4()),
      Ue = ht(() => X4()),
      Ce = ht(() => x(y) || x(b));
    l0(_e, {
      get label() {
        return x(Re)
      },
      get placeholder() {
        return x(Ue)
      },
      min: 1,
      max: 2056,
      class: "h-32",
      get disabled() {
        return x(Ce)
      },
      get value() {
        return x(k)
      },
      set value(We) {
        re(k, We, !0)
      }
    })
  }
  I(de);
  var Ae = B(de, 2),
    xe = P(Ae);
  xe.__click = [W7, h];
  var Ie = P(xe, !0);
  I(xe);
  var Pe = B(xe, 2),
    De = P(Pe),
    $e = P(De, !0);
  I(De);
  var tt = B(De, 2),
    Ve = P(tt, !0);
  I(tt), I(Pe), I(Ae), I(X), I(F), I(s), pi(s, () => Re => {
    Kr(() => {
      h() ? Re.show() : Re.close()
    })
  }), Ze((Re, Ue, Ce, We) => {
    ce(G, Re), xe.disabled = x(y), ce(Ie, Ue), ce($e, Ce), tt.disabled = x(y) || x(b) || x(k).length <= 1, ce(Ve, We)
  }, [() => a.userData.banned ? A0() : Z4(), () => cs(), () => x(b) ? l6({
    days: x(E)
  }) : "", () => Q4()]), Zn("close", s, () => h(!1)), Zn("submit", X, async () => {
    try {
      re(y, !0), await nn.submitBanAppeal(x(k)), Ar.success(r6()), h(!1)
    } catch (Re) {
      Ar.error(Re.message, {
        duration: 5e3
      })
    } finally {
      re(y, !1)
    }
  }), Z(d, s), Pr()
}
Ln(["click"]);
var X7 = fe("<span> </span>");

function Qv(d, a) {
  Ir(a, !0);
  var h = X7(),
    y = P(h, !0);
  I(h), Ze(() => {
    Or(h, 1, `size-4 items-center justify-center rounded-full bg-red-500 font-semibold text-red-50 ${a.count<10?"text-xs":"text-[10px]"} ${a.class??""}`), ce(y, a.count < 10 ? a.count : "9+")
  }), Z(d, h), Pr()
}
var Y7 = fe('<p class="text-error mt-1 text-sm"> </p>'),
  K7 = (d, a) => {
    a(!1)
  },
  Q7 = async (d, a, h, y, k, E) => {
    if (x(a) !== x(h)) {
      re(y, Nx(), !0);
      return
    }
    try {
      re(k, !0), await nn.deleteMe(x(h)), Ar.warning(cI()), await wt.logout(), E(!1)
    } catch (b) {
      Ar.error(b.message)
    } finally {
      re(k, !1)
    }
  }, e9 = fe('<span class="loading loading-spinner center-absolute absolute"></span>'), t9 = fe('<dialog class="modal !bg-black/80"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex items-center gap-2"><!> <h3 class="text-lg font-bold"> </h3></div> <p class="mt-4"><b> </b> </p> <p class="mt-2"> </p> <div class="rounded-box border-base-content/20 border-1 mt-6 w-full py-1.5 text-center"> </div> <input class="input input-bordered mt-2 w-full" type="text"/> <!> <div class="mt-6 flex justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-error relative"> <!></button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function r9(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15),
    y = rt(""),
    k = rt(null),
    E = rt(!1),
    b = ht(() => {
      var le;
      return ((le = wt.data) == null ? void 0 : le.name) ?? ""
    });
  Kr(() => {
    h() || (re(y, ""), re(k, null))
  });
  var s = t9(),
    F = P(s),
    O = B(P(F), 2),
    G = P(O);
  Qx(G, {
    class: "text-error size-5"
  });
  var X = B(G, 2),
    Q = P(X, !0);
  I(X), I(O);
  var W = B(O, 2),
    de = P(W),
    _e = P(de, !0);
  I(de);
  var Ae = B(de);
  I(W);
  var xe = B(W, 2),
    Ie = P(xe);
  I(xe);
  var Pe = B(xe, 2),
    De = P(Pe, !0);
  I(Pe);
  var $e = B(Pe, 2);
  ya($e);
  var tt = B($e, 2);
  {
    var Ve = le => {
      var ae = Y7(),
        ke = P(ae, !0);
      I(ae), Ze(() => ce(ke, x(k))), Z(le, ae)
    };
    Be(tt, le => {
      x(k) && le(Ve)
    })
  }
  var Re = B(tt, 2),
    Ue = P(Re);
  Ue.__click = [K7, h];
  var Ce = P(Ue, !0);
  I(Ue);
  var We = B(Ue, 2);
  We.__click = [Q7, y, b, k, E, h];
  var Je = P(We),
    Ge = B(Je);
  {
    var Ee = le => {
      var ae = e9();
      Z(le, ae)
    };
    Be(Ge, le => {
      x(E) && le(Ee)
    })
  }
  I(We), I(Re), I(F);
  var mt = B(F, 2),
    K = P(mt),
    ee = P(K, !0);
  I(K), I(mt), I(s), pi(s, () => le => {
    Kr(() => {
      h() ? le.show() : le.close()
    })
  }), Ze((le, ae, ke, qe, lt, ot, dt, Pt, Lt) => {
    ce(Q, le), ce(_e, ae), ce(Ae, ` ${ke??""}`), ce(Ie, `${qe??""} ${lt??""}`), ce(De, x(b)), nr($e, "placeholder", ot), ce(Ce, dt), We.disabled = x(E), ce(Je, `${Pt??""} `), ce(ee, Lt)
  }, [() => pm(), () => Uw(), () => Ww(), () => o4(), () => c4(), () => d4(), () => Zh(), () => pm(), () => cs()]), Zn("close", s, () => h(!1)), Mp($e, () => x(y), le => re(y, le)), Z(d, s), Pr()
}
Ln(["click"]);
var n9 = fe('<p class="text-base-content/80 text-sm"> </p>'),
  i9 = async (d, a, h, y) => {
    try {
      re(a, !0), h(await y.onConfirm())
    } finally {
      re(a, !1)
    }
  }, a9 = fe('<span class="loading loading-spinner center-absolute absolute"></span>'), o9 = fe('<h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <!> <div class="mt-4 flex justify-end gap-2"><form method="dialog"><button class="btn btn-soft"> </button></form> <button> <!></button></div>', 1);

function s9(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15),
    y = Tt(a, "type", 3, "confirmation"),
    k = Tt(a, "buttonText", 19, () => v0()),
    E = rt(!1);
  f_(d, {
    dialogClass: "!bg-black/80",
    get open() {
      return h()
    },
    set open(b) {
      h(b)
    },
    children: (b, s) => {
      var F = o9(),
        O = pt(F),
        G = P(O, !0);
      I(O);
      var X = B(O, 2),
        Q = P(X, !0);
      I(X);
      var W = B(X, 2);
      {
        var de = Re => {
          var Ue = n9(),
            Ce = P(Ue, !0);
          I(Ue), Ze(() => ce(Ce, a.subDescription)), Z(Re, Ue)
        };
        Be(W, Re => {
          a.subDescription && Re(de)
        })
      }
      var _e = B(W, 2),
        Ae = P(_e),
        xe = P(Ae),
        Ie = P(xe, !0);
      I(xe), I(Ae);
      var Pe = B(Ae, 2);
      let De;
      Pe.__click = [i9, E, h, a];
      var $e = P(Pe),
        tt = B($e);
      {
        var Ve = Re => {
          var Ue = a9();
          Z(Re, Ue)
        };
        Be(tt, Re => {
          x(E) && Re(Ve)
        })
      }
      I(Pe), I(_e), Ze((Re, Ue) => {
        ce(G, a.title), ce(Q, a.description), ce(Ie, Re), De = Or(Pe, 1, "btn relative", null, De, Ue), Pe.disabled = x(E), ce($e, `${k()??""} `)
      }, [() => Zh(), () => ({
        "btn-error": y() === "warning",
        "btn-primary": y() === "confirmation"
      })]), Z(b, F)
    },
    $$slots: {
      default: !0
    }
  }), Pr()
}
Ln(["click"]);

function l9(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15);
  {
    let y = ht(() => u0()),
      k = ht(() => e4()),
      E = ht(() => m4());
    s9(d, {
      type: "warning",
      get title() {
        return x(y)
      },
      get description() {
        return x(k)
      },
      get subDescription() {
        return x(E)
      },
      onConfirm: async () => {
        try {
          return await nn.deleteSessions(), Ar.success(eb()), await wt.logout(), !0
        } catch {
          return Ar.error(tb()), !1
        }
      },
      get open() {
        return h()
      },
      set open(b) {
        h(b)
      }
    })
  }
  Pr()
}
var c9 = (d, a) => {
    a()
  },
  u9 = fe('<span class="center-absolute loading loading-spinner absolute"></span>'),
  h9 = fe('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  d9 = (d, a, h) => {
    a(x(h).id)
  },
  p9 = fe('<span class="center-absolute loading loading-spinner absolute"></span>'),
  f9 = fe('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  m9 = fe('<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>'),
  _9 = fe('<a class="btn border-0 bg-[#5865F2] text-white"><!> </a>'),
  g9 = async (d, a, h) => {
    try {
      re(a, !0), await nn.unlinkDiscord(), wt.refresh(), Ar.success(eI()), re(h, !1)
    } catch (y) {
      Ar.error(y.message, {
        duration: 5e3
      })
    } finally {
      re(a, !1)
    }
  }, v9 = fe('<button class="btn btn-error btn-soft"><!> </button>'), y9 = (d, a) => {
    re(a, !0)
  }, x9 = (d, a) => {
    re(a, !0)
  }, b9 = (d, a) => {
    a(!1)
  }, w9 = fe('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative w-max"><!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <!></div> <div class="tooltip flex w-full flex-col gap-3 max-sm:overflow-x-hidden"><!> <!> <label class="label text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="col mt-4 flex flex-wrap justify-between gap-2"><div class="dropdown dropdown-top max-sm:dropdown-top col ml-1 mt-4 flex gap-2"><button tabindex="0" class="btn btn-sm btn-soft"> </button> <ul class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 font-medium shadow-sm"><li><button type="button" class="text-error py-2"> </button></li> <li><button type="button" class="text-error py-2"> </button></li></ul></div> <div class="col mt-4 flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <!> <!>', 1);

function C9(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15),
    y = rt(di(a.userData.name)),
    k = rt(di(a.userData.discord)),
    E = rt(di(a.userData.showLastPixel)),
    b = rt(!1),
    s = rt(void 0),
    F = rt(!1),
    O = rt(!1);
  const G = Zx("2025-09_discord_linking");
  let X = rt(!!a.userData.discordId),
    Q = rt(void 0),
    W = rt(void 0);
  Kr(() => {
    re(y, a.userData.name, !0), re(E, a.userData.showLastPixel, !0)
  }), Kr(() => {
    h() && !x(s) && nn.getMyProfilePictures().then(Ft => {
      re(s, Ft, !0)
    }).catch(Ft => {
      Ar.error(Ft.message)
    })
  });
  let de = rt(!1);
  async function _e(Ft) {
    try {
      re(de, !0), await nn.changeProfilePicture(Ft), await wt.refresh()
    } finally {
      re(de, !1)
    }
  }
  var Ae = w9(),
    xe = pt(Ae),
    Ie = P(xe),
    Pe = B(P(Ie), 2),
    De = P(Pe, !0);
  I(Pe);
  var $e = B(Pe, 2),
    tt = P($e),
    Ve = P(tt),
    Re = P(Ve),
    Ue = P(Re);
  fo(Ue, {
    class: "size-30",
    get userId() {
      return a.userData.id
    },
    get pictureUrl() {
      return a.userData.picture
    }
  });
  var Ce = B(Ue, 2),
    We = P(Ce);
  p0(We, {
    class: "size-5"
  }), I(Ce), I(Re);
  var Je = B(Re, 2);
  {
    var Ge = Ft => {
      var cr = m9(),
        ur = P(cr),
        Er = P(ur, !0);
      I(ur);
      var dr = B(ur, 2),
        pr = P(dr);
      {
        var vr = qr => {
          var ue = h9();
          ue.__click = [c9, _e];
          var V = P(ue);
          fo(V, {
            class: "size-10 border",
            get userId() {
              return a.userData.id
            }
          });
          var U = B(V, 2);
          {
            var Y = oe => {
              var me = u9();
              Z(oe, me)
            };
            Be(U, oe => {
              x(de) && oe(Y)
            })
          }
          I(ue), Ze(() => ue.disabled = x(de)), Z(qr, ue)
        };
        Be(pr, qr => {
          a.userData.picture && qr(vr)
        })
      }
      var Vr = B(pr, 2);
      ai(Vr, 17, () => x(s), qr => qr.id, (qr, ue) => {
        var V = or(),
          U = pt(V);
        {
          var Y = oe => {
            var me = f9();
            me.__click = [d9, _e, ue];
            var Se = P(me);
            fo(Se, {
              class: "size-10 border",
              get userId() {
                return a.userData.id
              },
              get pictureUrl() {
                return x(ue).url
              }
            });
            var Oe = B(Se, 2);
            {
              var ze = Ke => {
                var _t = p9();
                Z(Ke, _t)
              };
              Be(Oe, Ke => {
                x(de) && Ke(ze)
              })
            }
            I(me), Ze(() => me.disabled = x(de)), Z(oe, me)
          };
          Be(U, oe => {
            a.userData.picture !== x(ue).url && oe(Y)
          })
        }
        Z(qr, V)
      }), I(dr), I(cr), Ze(qr => ce(Er, qr), [() => Bw()]), Z(Ft, cr)
    };
    Be(Je, Ft => {
      var cr;
      (cr = x(s)) != null && cr.length && Ft(Ge)
    })
  }
  I(Ve);
  var Ee = B(Ve, 2),
    mt = P(Ee);
  {
    let Ft = ht(() => fm()),
      cr = ht(() => fm());
    _m(mt, {
      get label() {
        return x(Ft)
      },
      get placeholder() {
        return x(cr)
      },
      min: 1,
      max: 16,
      get value() {
        return x(y)
      },
      set value(ur) {
        re(y, ur, !0)
      },
      get validate() {
        return x(Q)
      },
      set validate(ur) {
        re(Q, ur, !0)
      }
    })
  }
  var K = B(mt, 2);
  {
    var ee = Ft => {
        var cr = or(),
          ur = pt(cr);
        {
          var Er = pr => {
              var vr = _9(),
                Vr = P(vr);
              vm(Vr, {
                class: "size-4.5"
              });
              var qr = B(Vr);
              I(vr), Ze((ue, V) => {
                nr(vr, "href", ue), ce(qr, ` ${V??""}`)
              }, [() => Vx("/discord/authorize"), () => nI()]), Z(pr, vr)
            },
            dr = pr => {
              var vr = v9();
              vr.__click = [g9, b, X];
              var Vr = P(vr);
              vm(Vr, {
                class: "size-4.5"
              });
              var qr = B(Vr);
              I(vr), Ze(ue => {
                vr.disabled = x(b), ce(qr, ` ${ue??""}`)
              }, [() => {
                var ue;
                return oI({
                  username: ((ue = a.userData) == null ? void 0 : ue.discord) ?? ""
                })
              }]), Z(pr, vr)
            };
          Be(ur, pr => {
            x(X) ? pr(dr, !1) : pr(Er)
          })
        }
        Z(Ft, cr)
      },
      le = Ft => {
        {
          let cr = ht(() => F3());
          _m(Ft, {
            label: "Discord",
            get placeholder() {
              return x(cr)
            },
            max: 32,
            get value() {
              return x(k)
            },
            set value(ur) {
              re(k, ur, !0)
            },
            get validate() {
              return x(W)
            },
            set validate(ur) {
              re(W, ur, !0)
            }
          })
        }
      };
    Be(K, Ft => {
      G ? Ft(ee) : Ft(le, !1)
    })
  }
  var ae = B(K, 2),
    ke = P(ae);
  ya(ke);
  var qe = B(ke);
  I(ae), I(Ee), I(tt);
  var lt = B(tt, 2),
    ot = P(lt),
    dt = P(ot),
    Pt = P(dt, !0);
  I(dt);
  var Lt = B(dt, 2),
    He = P(Lt),
    ut = P(He);
  ut.__click = [y9, O];
  var gt = P(ut, !0);
  I(ut), I(He);
  var St = B(He, 2),
    vt = P(St);
  vt.__click = [x9, F];
  var Ct = P(vt, !0);
  I(vt), I(St), I(Lt), I(ot);
  var At = B(ot, 2),
    Bt = P(At);
  Bt.__click = [b9, h];
  var Vt = P(Bt, !0);
  I(Bt);
  var Ot = B(Bt, 2),
    Dt = P(Ot, !0);
  I(Ot), I(At), I(lt), I($e), I(Ie), I(xe), pi(xe, () => Ft => {
    Kr(() => {
      h() ? Ft.show() : Ft.close()
    })
  });
  var Rt = B(xe, 2);
  r9(Rt, {
    get open() {
      return x(F)
    },
    set open(Ft) {
      re(F, Ft, !0)
    }
  });
  var Zt = B(Rt, 2);
  l9(Zt, {
    get open() {
      return x(O)
    },
    set open(Ft) {
      re(O, Ft, !0)
    }
  }), Ze((Ft, cr, ur, Er, dr, pr, vr, Vr, qr) => {
    ce(De, Ft), nr(Ce, "data-tip", cr), nr(Ee, "data-tip", ur), ce(qe, ` ${Er??""}`), ce(Pt, dr), ce(gt, pr), ce(Ct, vr), Bt.disabled = x(b), ce(Vt, Vr), Ot.disabled = x(b), ce(Dt, qr)
  }, [() => VI(), () => gb(), () => R4(), () => jw(), () => n4(), () => u0(), () => pm(), () => cs(), () => hb()]), Zn("close", xe, () => h(!1)), Zn("submit", $e, async () => {
    var Ft;
    try {
      if (!((Ft = x(Q)) != null && Ft())) return;
      re(b, !0), await nn.updateMe({
        name: x(y),
        showLastPixel: x(E)
      }), wt.refresh(), Ar.success(HS()), h(!1)
    } catch (cr) {
      Ar.error(cr.message, {
        duration: 5e3
      })
    } finally {
      re(b, !1)
    }
  }), lb(ke, () => x(E), Ft => re(E, Ft)), Z(d, Ae), Pr()
}
Ln(["click"]);
var T9 = xr('<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>');

function S9(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = T9();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var I9 = xr('<svg><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Zm-10-270Z"></path></svg>');

function P9(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = I9();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var k9 = xr('<svg><path d="M480-360q50 0 85-35t35-85q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 50 35 85t85 35Zm0 80q-83 0-141.5-58.5T280-480q0-83 58.5-141.5T480-680q83 0 141.5 58.5T680-480q0 83-58.5 141.5T480-280ZM200-440H40v-80h160v80Zm720 0H760v-80h160v80ZM440-760v-160h80v160h-80Zm0 720v-160h80v160h-80ZM256-650l-101-97 57-59 96 100-52 56Zm492 496-97-101 53-55 101 97-57 59Zm-98-550 97-101 59 57-100 96-56-52ZM154-212l101-97 55 53-97 101-59-57Zm326-268Z"></path></svg>');

function M9(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = k9();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var A9 = xr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>');

function Cy(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = A9();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var E9 = xr('<svg><path d="M160-200v-80h80v-280q0-83 50-147.5T420-792v-28q0-25 17.5-42.5T480-880q25 0 42.5 17.5T540-820v28q80 20 130 84.5T720-560v280h80v80H160Zm320-300Zm0 420q-33 0-56.5-23.5T400-160h160q0 33-23.5 56.5T480-80ZM320-280h320v-280q0-66-47-113t-113-47q-66 0-113 47t-47 113v280Z"></path></svg>');

function z9(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = E9();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var L9 = xr('<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>');

function D9(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = L9();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var R9 = xr('<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>');

function B9(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = R9();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    viewBox: "0 0 216 216",
    ...h
  }), void 0, void 0, "svelte-1977t4s"), Z(d, y)
}
var F9 = xr('<svg><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240ZM330-120 120-330v-300l210-210h300l210 210v300L630-120H330Zm34-80h232l164-164v-232L596-760H364L200-596v232l164 164Zm116-280Z"></path></svg>');

function qm(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = F9();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var O9 = xr('<svg><path d="M480-440q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0-80q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0 440q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-400Zm0-315-240 90v189q0 54 15 105t41 96q42-21 88-33t96-12q50 0 96 12t88 33q26-45 41-96t15-105v-189l-240-90Zm0 515q-36 0-70 8t-65 22q29 30 63 52t72 34q38-12 72-34t63-52q-31-14-65-22t-70-8Z"></path></svg>');

function lm(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = O9();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var j9 = xr('<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>');

function N9(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = j9();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var Z9 = xr('<svg><path fill="#fff" d="m2200 1300-400 400h-400l-350 350v-350H600V200h1600z"></path><g fill="#9146ff"><path d="M500 0 0 500v1800h600v500l500-500h400l900-900V0H500zm1700 1300-400 400h-400l-350 350v-350H600V200h1600v1100z"></path><path d="M1700 550h200v600h-200zm-550 0h200v600h-200z"></path></g></svg>');

function V9(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = Z9();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xml:space": "preserve",
    viewBox: "0 0 2400 2800",
    ...h
  })), Z(d, y)
}
var q9 = xr('<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>');

function U9(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = q9();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var $9 = xr('<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>');

function G9(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = $9();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var W9 = (d, a) => {
    re(a, !0)
  },
  H9 = fe('<span class="tooltip font-flag ml-0.5"> </span>'),
  J9 = fe('<div class="mt-1"><!></div>'),
  X9 = fe('<p class="w-full"> <!></p>'),
  Y9 = fe('<p class="w-full"><!></p>'),
  K9 = (d, a) => {
    var h;
    (h = a.onbanappeal) == null || h.call(a)
  },
  Q9 = fe('<div class=" flex items-center gap-[8px]"><!> <!> <button class="btn btn-error btn-sm"><!> </button></div>'),
  eB = (d, a, h) => {
    localStorage.setItem(Yx, x(a).key), re(h, x(a).key, !0), location.reload()
  },
  tB = fe('<span class="center-absolute loading loading-spinner loading-xs absolute"></span>'),
  rB = fe("<li><button><!> </button></li>"),
  nB = fe('<div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div>'),
  iB = async (d, a) => {
    var h;
    try {
      const y = await ((h = x(a)) == null ? void 0 : h.prompt());
      (y == null ? void 0 : y.outcome) === "accepted" && re(a, void 0)
    } catch (y) {
      Ar.error(Tw({
        error: y.message
      }))
    }
  }, aB = fe('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>'), oB = fe('<a class="btn w-full" target="_blank"><!> </a>'), sB = fe('<a class="btn w-full" target="_blank"><!> </a>'), lB = fe('<a class="btn w-full" target="_blank"><!> </a>'), cB = fe('<form class="w-full" method="POST"><button class="btn w-full"><!> </button></form> <a class="btn w-full" target="_blank"><!> </a>', 1), uB = async (d, a, h, y) => {
    var k;
    try {
      re(a, !0), await h.user.logout(), y(), Ar.warning(dI(), {
        icon: Cy
      }), (k = h.onlogout) == null || k.call(h)
    } catch {
      Ar.error(mI())
    } finally {
      re(a, !1)
    }
  }, hB = fe('<div class="dropdown"><div tabindex="0" role="button"><!> <!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 relative right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="0"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><!> <div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 w-max rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><img alt="Pumpkin" class="pixelated size-4"/></button></div> <!> <button class="btn btn-sm btn-circle relative"><!> <!></button></div></div>  <!> <!> <!> <!> <a class="btn w-full" href="https://www.twitch.tv/directory/category/wplace" target="_blank"><!> </a> <a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> Discord</a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> Reddit</a> <!> <button class="btn"><!> </button></section></div></div> <!>', 1);

function dB(d, a) {
  Ir(a, !0);
  let h = rt(!1),
    y = rt(!1);

  function k() {
    var Q;
    (Q = document.activeElement) == null || Q.blur()
  }
  const E = [{
    label: "🇺🇸 English",
    key: "en"
  }, {
    label: "🇧🇷 Português",
    key: "pt"
  }];
  let b = rt(""),
    s = rt(void 0);
  const F = ht(() => {
    var Q;
    return !!((Q = a.user.data) != null && Q.banned) || !!a.user.timeoutUntil
  });
  var O = or(),
    G = pt(O);
  {
    var X = Q => {
      var W = hB(),
        de = pt(W),
        _e = P(de);
      let Ae;
      var xe = P(_e);
      _0(xe, {
        get userId() {
          return a.user.data.id
        },
        get level() {
          return a.user.data.level
        },
        get pictureUrl() {
          return a.user.data.picture
        }
      });
      var Ie = B(xe, 2);
      {
        var Pe = xt => {
          Qv(xt, {
            class: "absolute -right-0.5 -top-0.5",
            get count() {
              return a.user.notificiationCount
            }
          })
        };
        Be(Ie, xt => {
          a.user.notificiationCount && xt(Pe)
        })
      }
      I(_e);
      var De = B(_e, 2),
        $e = P(De);
      $e.__click = k;
      var tt = P($e);
      Il(tt, {
        class: "size-5"
      }), I($e);
      var Ve = B($e, 2),
        Re = P(Ve),
        Ue = P(Re);
      fo(Ue, {
        get userId() {
          return a.user.data.id
        },
        get pictureUrl() {
          return a.user.data.picture
        },
        get isSuspended() {
          return x(F)
        }
      });
      var Ce = B(Ue, 2);
      Ce.__click = [W9, h];
      var We = P(Ce);
      gm(We, {
        class: "size-4"
      }), I(Ce), I(Re);
      var Je = B(Re, 2),
        Ge = P(Je),
        Ee = P(Ge),
        mt = P(Ee, !0);
      I(Ee);
      var K = B(Ee, 2),
        ee = P(K);
      I(K);
      var le = B(K, 2);
      {
        var ae = xt => {
          const It = ht(() => Lo(a.user.data.equippedFlag));
          var Wt = H9(),
            Nt = P(Wt, !0);
          I(Wt), Ze(() => {
            nr(Wt, "data-tip", x(It).name), ce(Nt, x(It).flag)
          }), Z(xt, Wt)
        };
        Be(le, xt => {
          a.user.data.equippedFlag && xt(ae)
        })
      }
      var ke = B(le, 2);
      {
        var qe = xt => {
          var It = J9(),
            Wt = P(It);
          Vh(Wt, {
            get username() {
              return a.user.data.discord
            },
            get id() {
              return a.user.data.discordId
            }
          }), I(It), Z(xt, It)
        };
        Be(ke, xt => {
          a.user.data.discord && xt(qe)
        })
      }
      I(Ge);
      var lt = B(Ge, 2),
        ot = P(lt);
      qh(ot, {
        class: "inline size-4"
      });
      var dt = B(ot, 2),
        Pt = P(dt),
        Lt = B(Pt),
        He = P(Lt, !0);
      I(Lt), I(dt), I(lt);
      var ut = B(lt, 2),
        gt = P(ut);
      S9(gt, {
        class: "inline size-4"
      });
      var St = B(gt, 2),
        vt = P(St),
        Ct = P(vt);
      I(vt);
      var At = B(vt),
        Bt = B(At),
        Vt = P(Bt);
      th(Vt, {
        class: "mb-0.5 inline size-4 opacity-50"
      }), I(Bt), I(St), I(ut), I(Je), I(Ve);
      var Ot = B(Ve, 2),
        Dt = P(Ot);
      {
        var Rt = xt => {
          var It = Q9(),
            Wt = P(It);
          qm(Wt, {
            class: "size-6 text-red-500"
          });
          var Nt = B(Wt, 2);
          {
            var gr = Yt => {
                var tn = X9(),
                  an = P(tn),
                  ln = B(an);
                {
                  var Pi = In => {
                    var fi = Ii();
                    Ze(Dn => ce(fi, `(${Dn??""})`), [() => BP({
                      reason: $x()
                    })]), Z(In, fi)
                  };
                  Be(ln, In => {
                    a.user.data.suspensionReason === "bot" && In(Pi)
                  })
                }
                I(tn), Ze(In => ce(an, `${In??""} `), [() => qx()]), Z(Yt, tn)
              },
              Qr = Yt => {
                var tn = or(),
                  an = pt(tn);
                {
                  var ln = Pi => {
                    var In = Y9(),
                      fi = P(In);
                    Pp(fi, () => Ux({
                      until: `<span class="text-secondary font-medium text-nowrap">${a.user.timeoutUntil.toLocaleString()}</span>`
                    })), I(In), Z(Pi, In)
                  };
                  Be(an, Pi => {
                    a.user.timeoutUntil && Pi(ln)
                  }, !0)
                }
                Z(Yt, tn)
              };
            Be(Nt, Yt => {
              var tn;
              (tn = a.user.data) != null && tn.banned ? Yt(gr) : Yt(Qr, !1)
            })
          }
          var zr = B(Nt, 2);
          zr.__click = [K9, a];
          var Hr = P(zr);
          qm(Hr, {
            class: "size-5 text-red-500"
          });
          var hn = B(Hr, 1, !0);
          I(zr), I(It), Ze(Yt => ce(hn, Yt), [() => h6()]), Z(xt, It)
        };
        Be(Dt, xt => {
          x(F) && xt(Rt)
        })
      }
      var Zt = B(Dt, 2),
        Ft = P(Zt),
        cr = P(Ft, !0);
      I(Ft);
      var ur = B(Ft, 2),
        Er = P(ur),
        dr = P(Er),
        pr = P(dr);
      N9(pr, {
        class: "size-4"
      }), I(dr);
      var vr = B(dr, 2);
      ai(vr, 21, () => E, kp, (xt, It) => {
        const Wt = ht(() => x(b) === x(It).key);
        var Nt = rB(),
          gr = P(Nt);
        let Qr;
        gr.__click = [eB, It, b];
        var zr = P(gr);
        {
          var Hr = Yt => {
            var tn = tB();
            Z(Yt, tn)
          };
          Be(zr, Yt => {
            x(Wt) && Yt(Hr)
          })
        }
        var hn = B(zr);
        I(gr), I(Nt), Ze(Yt => {
          Qr = Or(gr, 1, "font-flag relative font-medium", null, Qr, Yt), ce(hn, ` ${x(It).label??""}`)
        }, [() => ({
          "bg-base-200": x(Wt)
        })]), Z(xt, Nt)
      }), I(vr), I(Er);
      var Vr = B(Er, 2),
        qr = P(Vr);
      qr.__click = () => {
        Zi.muted = !Zi.muted
      };
      var ue = P(qr);
      {
        var V = xt => {
            U9(xt, {
              class: "size-4"
            })
          },
          U = xt => {
            G9(xt, {
              class: "size-4"
            })
          };
        Be(ue, xt => {
          Zi.muted ? xt(V) : xt(U, !1)
        })
      }
      I(qr), I(Vr);
      var Y = B(Vr, 2),
        oe = P(Y);
      oe.__click = () => {
        Vi.smallDropplet.play(), Zi.theme = Zi.theme === "halloween" ? "custom-winter" : "halloween"
      };
      var me = P(oe);
      I(oe), I(Y);
      var Se = B(Y, 2);
      {
        var Oe = xt => {
          var It = nB(),
            Wt = P(It);
          Wt.__click = () => {
            Zi.theme = Zi.theme === "dark" ? "custom-winter" : "dark"
          };
          var Nt = P(Wt);
          {
            var gr = zr => {
                M9(zr, {
                  class: "size-4"
                })
              },
              Qr = zr => {
                P9(zr, {
                  class: "size-4"
                })
              };
            Be(Nt, zr => {
              Zi.theme === "dark" ? zr(gr) : zr(Qr, !1)
            })
          }
          I(Wt), I(It), Ze(zr => nr(It, "data-tip", zr), [() => Zi.theme === "dark" ? YP() : HP()]), Z(xt, It)
        };
        Be(Se, xt => {
          var It, Wt;
          ja((Wt = (It = a.user) == null ? void 0 : It.data) == null ? void 0 : Wt.role, ["admin", "moderator", "global_moderator"]) && xt(Oe)
        })
      }
      var ze = B(Se, 2);
      ze.__click = function(...xt) {
        var It;
        (It = a.onnotificationclick) == null || It.apply(this, xt)
      };
      var Ke = P(ze);
      z9(Ke, {
        class: "size-4"
      });
      var _t = B(Ke, 2);
      {
        var it = xt => {
          Qv(xt, {
            class: "absolute -right-1 -top-1",
            get count() {
              return a.user.notificiationCount
            }
          })
        };
        Be(_t, xt => {
          a.user.notificiationCount && xt(it)
        })
      }
      I(ze), I(ur), I(Zt);
      var qt = B(Zt, 2);
      {
        var we = xt => {
          var It = aB();
          It.__click = [iB, s];
          var Wt = P(It);
          c0(Wt, {
            class: "size-5"
          });
          var Nt = B(Wt);
          I(It), Ze(gr => ce(Nt, ` ${gr??""}`), [() => Pw()]), Z(xt, It)
        };
        Be(qt, xt => {
          x(s) && xt(we)
        })
      }
      var Mt = B(qt, 2);
      {
        var Ut = xt => {
          var It = oB(),
            Wt = P(It);
          lm(Wt, {
            class: "size-5"
          });
          var Nt = B(Wt);
          I(It), Ze(gr => {
            nr(It, "href", `${ri.url.origin??""}/admin/dashboard`), ce(Nt, ` ${gr??""}`)
          }, [() => LP()]), Z(xt, It)
        };
        Be(Mt, xt => {
          var It, Wt;
          ja((Wt = (It = a.user) == null ? void 0 : It.data) == null ? void 0 : Wt.role, ["admin"]) && xt(Ut)
        })
      }
      var jt = B(Mt, 2);
      {
        var fr = xt => {
          var It = sB(),
            Wt = P(It);
          lm(Wt, {
            class: "size-5"
          });
          var Nt = B(Wt);
          I(It), Ze(gr => {
            nr(It, "href", `${ri.url.origin??""}/moderation`), ce(Nt, ` ${gr??""}`)
          }, [() => mP()]), Z(xt, It)
        };
        Be(jt, xt => {
          var It;
          ja((It = a.user.data) == null ? void 0 : It.role, ["admin", "moderator", "global_moderator"]) && xt(fr)
        })
      }
      var Ur = B(jt, 2);
      {
        var Dr = xt => {
          var It = lB(),
            Wt = P(It);
          lm(Wt, {
            class: "size-5"
          });
          var Nt = B(Wt);
          I(It), Ze(gr => {
            nr(It, "href", `${ri.url.origin??""}/appeal`), ce(Nt, ` ${gr??""}`)
          }, [() => a6()]), Z(xt, It)
        };
        Be(Ur, xt => {
          var It, Wt;
          ja((Wt = (It = a.user) == null ? void 0 : It.data) == null ? void 0 : Wt.role, ["admin"]) && xt(Dr)
        })
      }
      var jr = B(Ur, 2),
        $r = P(jr);
      V9($r, {
        class: "size-5"
      });
      var Br = B($r);
      I(jr);
      var Fr = B(jr, 2),
        vn = P(Fr);
      Yu(vn, {
        class: "size-5"
      }), en(), I(Fr);
      var bt = B(Fr, 2),
        bn = P(bt);
      B9(bn, {
        class: "size-5"
      }), en(), I(bt);
      var fn = B(bt, 2);
      {
        var $n = xt => {
          var It = cB(),
            Wt = pt(It),
            Nt = P(Wt),
            gr = P(Nt);
          D9(gr, {
            class: "size-5"
          });
          var Qr = B(gr);
          I(Nt), I(Wt);
          var zr = B(Wt, 2),
            Hr = P(zr);
          th(Hr, {
            class: "size-5"
          });
          var hn = B(Hr);
          I(zr), Ze((Yt, tn, an) => {
            nr(Wt, "action", `${Ox}/payment/create-portal-session`), ce(Qr, ` ${Yt??""}`), nr(zr, "href", tn), ce(hn, ` ${an??""}`)
          }, [() => nb(), () => f0(ri.url.origin), () => P0()]), Z(xt, It)
        };
        Be(fn, xt => {
          var It;
          (It = a.user.data) != null && It.isCustomer && xt($n)
        })
      }
      var zt = B(fn, 2);
      zt.__click = [uB, y, a, k];
      var nt = P(zt);
      Cy(nt, {
        class: "size-5"
      });
      var $t = B(nt);
      I(zt), I(Ot), I(De), I(de);
      var Gt = B(de, 2);
      C9(Gt, {
        get userData() {
          return a.user.data
        },
        get open() {
          return x(h)
        },
        set open(xt) {
          re(h, xt, !0)
        }
      }), Ze((xt, It, Wt, Nt, gr, Qr, zr, Hr, hn, Yt, tn, an, ln) => {
        Ae = Or(_e, 1, "btn relative size-12 p-0 shadow-md", null, Ae, xt), nr(_e, "title", It), nr(Ee, "title", a.user.data.name), ce(mt, a.user.data.name), Or(K, 1, Wt), ce(ee, `#${a.user.data.id??""}`), ce(Pt, `${Nt??""}: `), ce(He, gr), ce(Ct, `Level ${Qr??""}`), ce(At, ` (${zr??""}%) `), nr(Bt, "data-tip", Hr), ce(cr, hn), nr(Vr, "data-tip", Yt), nr(Y, "data-tip", tn), nr(me, "src", rs), ce(Br, ` ${an??""}`), zt.disabled = x(y), ce($t, ` ${ln??""}`)
      }, [() => ({
        "bg-red-500": x(F)
      }), () => vw(), () => ls(Ri(a.user.data.id)), () => Hm(), () => a.user.data.pixelsPainted.toLocaleString("en-US"), () => Math.floor(a.user.data.level), () => Math.floor(a.user.data.level % 1 * 100), () => z3(), () => bw(), () => Zi.muted ? dS() : cS(), () => Zi.theme === "halloween" ? $6() : H6(), () => Aw(), () => rb()]), Zn("focus", _e, () => {
        re(s, window.pwaInstallPrompt, !0)
      }), Z(Q, W)
    };
    Be(G, Q => {
      a.user.data && a.user.charges !== void 0 && Q(X)
    })
  }
  Z(d, O), Pr()
}
Ln(["click"]);
var pB = xr('<svg><path d="M100-240v-480l360 240-360 240Zm400 0v-480l360 240-360 240ZM180-480Zm400 0Zm-400 90 136-90-136-90v180Zm400 0 136-90-136-90v180Z"></path></svg>');

function fB(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = pB();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var mB = xr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>');

function _B(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = mB();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var gB = async (d, a, h, y, k, E) => {
  if (x(a)) {
    h.map.easeTo(x(a)), re(a, void 0);
    return
  }
  re(y, !0);
  try {
    zo(h.map.getCenter(), h.map.getZoom());
    const b = new Zs(x(k)),
      {
        tile: s,
        pixel: F
      } = await nn.getRandomTile(h.season),
      O = s.x * x(k) + F.x,
      G = s.y * x(k) + F.y,
      [X, Q] = b.pixelsToLatLon(O, G, x(E)),
      W = {
        lat: X,
        lng: Q
      },
      de = x(E) + 2;
    re(a, {
      zoom: de,
      center: W
    }, !0), h.map.flyTo(x(a)), wl.isEmpty() && wl.push({
      pos: h.map.getCenter(),
      zoom: h.map.getZoom()
    }), setTimeout(() => {
      re(a, void 0)
    }, 2500), wl.push({
      pos: W,
      zoom: de
    })
  } catch (b) {
    Ar.error(b.message)
  } finally {
    re(y, !1)
  }
}, vB = fe('<button class="btn btn-square shadow-md"><!></button>');

function yB(d, a) {
  Ir(a, !0);
  const h = ht(() => Bi.seasons[a.season].tileSize),
    y = ht(() => Bi.seasons[a.season].zoom);
  let k = rt(!1),
    E = rt(void 0);
  var b = vB();
  b.__click = [gB, E, a, k, h, y];
  var s = P(b);
  {
    var F = G => {
        _B(G, {
          class: "size-5"
        })
      },
      O = G => {
        fB(G, {
          class: "size-5"
        })
      };
    Be(s, G => {
      x(E) ? G(O, !1) : G(F)
    })
  }
  I(b), Ze(G => {
    nr(b, "title", G), b.disabled = x(k)
  }, [() => G2()]), Z(d, b), Pr()
}
Ln(["click"]);
var xB = fe('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  bB = fe('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  wB = fe('<span class="font-flag tooltip ml-0.5"> </span>'),
  CB = fe("<span> </span>"),
  TB = fe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  SB = fe('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  IB = fe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  PB = fe('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  kB = fe('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  MB = fe('<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>', 1);

function AB(d, a) {
  Ir(a, !0);
  const h = [];
  let y = rt("today"),
    k = {
      players: {
        label: S0(),
        icon: Bp
      },
      alliances: {
        label: I0(),
        icon: Fp
      }
    },
    E = rt("players"),
    b = di({
      players: {},
      alliances: {}
    });
  const s = ht(() => b[x(E)][x(y)]);
  Kr(() => {
    if (x(s)) return;
    const _e = x(y),
      Ae = x(E);
    Ae === "players" ? nn.leaderboardRegionPlayers(a.regionId, _e).then(xe => {
      b[Ae][_e] = xe
    }).catch(xe => {
      Ar.error(xe.message)
    }) : Ae === "alliances" && nn.leaderboardRegionAlliances(a.regionId, _e).then(xe => {
      b[Ae][_e] = xe
    }).catch(xe => {
      Ar.error(xe.message)
    })
  });
  var F = MB(),
    O = pt(F);
  ai(O, 21, () => Object.entries(k), ([_e, {
    label: Ae,
    icon: xe
  }]) => _e, (_e, Ae) => {
    var xe = ht(() => n0(x(Ae), 2));
    let Ie = () => x(xe)[0],
      Pe = () => x(xe)[1].label,
      De = () => x(xe)[1].icon;
    const $e = ht(De);
    var tt = xB(),
      Ve = P(tt);
    ya(Ve);
    var Re, Ue = B(Ve, 2);
    yi(Ue, () => x($e), (We, Je) => {
      Je(We, {
        get this() {
          return De()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var Ce = B(Ue);
    I(tt), Ze(() => {
      nr(Ve, "aria-label", Pe()), Re !== (Re = Ie()) && (Ve.value = (Ve.__value = Ie()) ?? ""), ce(Ce, ` ${Pe()??""}`)
    }), Jm(h, [], Ve, () => (Ie(), x(E)), We => re(E, We)), Z(_e, tt)
  }), I(O);
  var G = B(O, 2),
    X = P(G);
  l_(X, {
    get value() {
      return x(y)
    },
    set value(_e) {
      re(y, _e, !0)
    }
  }), I(G);
  var Q = B(G, 2);
  {
    var W = _e => {
        var Ae = bB(),
          xe = P(Ae),
          Ie = B(xe);
        {
          var Pe = $e => {
              var tt = Ii();
              Ze(Ve => ce(tt, Ve), [() => Rp().toLowerCase()]), Z($e, tt)
            },
            De = $e => {
              var tt = or(),
                Ve = pt(tt);
              {
                var Re = Ce => {
                    var We = Ii();
                    Ze(Je => ce(We, Je), [() => r_()]), Z(Ce, We)
                  },
                  Ue = Ce => {
                    var We = or(),
                      Je = pt(We);
                    {
                      var Ge = Ee => {
                        var mt = Ii();
                        Ze(K => ce(mt, K), [() => n_()]), Z(Ee, mt)
                      };
                      Be(Je, Ee => {
                        x(y) === "month" && Ee(Ge)
                      }, !0)
                    }
                    Z(Ce, We)
                  };
                Be(Ve, Ce => {
                  x(y) === "week" ? Ce(Re) : Ce(Ue, !1)
                }, !0)
              }
              Z($e, tt)
            };
          Be(Ie, $e => {
            x(y) === "today" ? $e(Pe) : $e(De, !1)
          })
        }
        I(Ae), Ze($e => ce(xe, `${$e??""} `), [() => t_()]), Z(_e, Ae)
      },
      de = _e => {
        var Ae = or(),
          xe = pt(Ae);
        {
          var Ie = De => {
              var $e = or(),
                tt = pt($e);
              {
                var Ve = Ue => {
                    const Ce = ht(() => x(s));
                    var We = SB(),
                      Je = P(We),
                      Ge = P(Je),
                      Ee = B(P(Ge)),
                      mt = P(Ee, !0);
                    I(Ee);
                    var K = B(Ee),
                      ee = P(K),
                      le = B(ee, 2, !0);
                    I(K), I(Ge), I(Je);
                    var ae = B(Je);
                    ai(ae, 31, () => x(Ce), ke => ke.id, (ke, qe, lt) => {
                      const ot = ht(() => {
                        var dr;
                        return ((dr = wt.data) == null ? void 0 : dr.id) === x(qe).id
                      });
                      var dt = TB();
                      let Pt;
                      var Lt = P(dt),
                        He = P(Lt, !0);
                      I(Lt);
                      var ut = B(Lt),
                        gt = P(ut),
                        St = P(gt);
                      fo(St, {
                        class: "size-10 border",
                        get userId() {
                          return x(qe).id
                        },
                        get pictureUrl() {
                          return x(qe).picture
                        }
                      });
                      var vt = B(St, 2),
                        Ct = P(vt),
                        At = P(Ct),
                        Bt = B(At),
                        Vt = P(Bt);
                      I(Bt), I(Ct);
                      var Ot = B(Ct, 2);
                      {
                        var Dt = dr => {
                          const pr = ht(() => Lo(x(qe).equippedFlag));
                          var vr = wB(),
                            Vr = P(vr, !0);
                          I(vr), Ze(() => {
                            nr(vr, "data-tip", x(pr).name), ce(Vr, x(pr).flag)
                          }), Z(dr, vr)
                        };
                        Be(Ot, dr => {
                          "equippedFlag" in x(qe) && x(qe).equippedFlag && dr(Dt)
                        })
                      }
                      var Rt = B(Ot, 2);
                      {
                        var Zt = dr => {
                          Vh(dr, {
                            get username() {
                              return x(qe).discord
                            },
                            get id() {
                              return x(qe).discordId
                            }
                          })
                        };
                        Be(Rt, dr => {
                          x(qe).discord && dr(Zt)
                        })
                      }
                      var Ft = B(Rt, 2);
                      {
                        var cr = dr => {
                          var pr = CB(),
                            vr = P(pr, !0);
                          I(pr), Ze((Vr, qr) => {
                            Or(pr, 1, `badge badge-sm ml-0.5 border-0 ${Vr??""} ${qr??""}`), ce(vr, x(qe).allianceName)
                          }, [() => Ap(x(qe).allianceId), () => Ri(x(qe).allianceId)]), Z(dr, pr)
                        };
                        Be(Ft, dr => {
                          "allianceName" in x(qe) && x(qe).allianceName && dr(cr)
                        })
                      }
                      I(vt), I(gt), I(ut);
                      var ur = B(ut),
                        Er = P(ur, !0);
                      I(ur), I(dt), Ze((dr, pr, vr) => {
                        Pt = Or(dt, 1, "", null, Pt, dr), ce(He, x(lt) + 1), Or(Ct, 1, `font-semibold max-sm:ml-2 ${pr??""} flex gap-1`), ce(At, `${x(qe).name??""} `), ce(Vt, `#${x(qe).id??""}`), ce(Er, vr)
                      }, [() => ({
                        "bg-base-200": x(ot)
                      }), () => Ri(x(qe).id), () => x(qe).pixelsPainted.toLocaleString("en-US")]), yl(dt, () => xl, () => ({
                        duration: 200
                      })), Z(ke, dt)
                    }), I(ae), I(We), Ze((ke, qe, lt) => {
                      ce(mt, ke), ce(ee, `${qe??""} `), ce(le, lt)
                    }, [() => Xm(), () => Ic(), () => Pc().toLowerCase()]), Z(Ue, We)
                  },
                  Re = Ue => {
                    var Ce = or(),
                      We = pt(Ce);
                    {
                      var Je = Ge => {
                        var Ee = PB(),
                          mt = P(Ee),
                          K = P(mt),
                          ee = B(P(K)),
                          le = P(ee, !0);
                        I(ee);
                        var ae = B(ee),
                          ke = P(ae),
                          qe = B(ke, 2, !0);
                        I(ae), I(K), I(mt);
                        var lt = B(mt);
                        ai(lt, 31, () => x(s), ot => ot.id, (ot, dt, Pt) => {
                          const Lt = ht(() => {
                            var Ot;
                            return ((Ot = wt.data) == null ? void 0 : Ot.allianceId) === x(dt).id
                          });
                          var He = IB();
                          let ut;
                          var gt = P(He),
                            St = P(gt, !0);
                          I(gt);
                          var vt = B(gt),
                            Ct = P(vt),
                            At = P(Ct, !0);
                          I(Ct), I(vt);
                          var Bt = B(vt),
                            Vt = P(Bt, !0);
                          I(Bt), I(He), Ze((Ot, Dt, Rt) => {
                            ut = Or(He, 1, "", null, ut, Ot), ce(St, x(Pt) + 1), Or(Ct, 1, `font-semibold ${Dt??""}`), ce(At, x(dt).name), ce(Vt, Rt)
                          }, [() => ({
                            "bg-base-200": x(Lt)
                          }), () => Ri(x(dt).id), () => x(dt).pixelsPainted.toLocaleString("en-US")]), yl(He, () => xl, () => ({
                            duration: 200
                          })), Z(ot, He)
                        }), I(lt), I(Ee), Ze((ot, dt, Pt) => {
                          ce(le, ot), ce(ke, `${dt??""} `), ce(qe, Pt)
                        }, [() => Lp(), () => Ic(), () => Pc().toLowerCase()]), Z(Ge, Ee)
                      };
                      Be(We, Ge => {
                        x(E) === "alliances" && Ge(Je)
                      }, !0)
                    }
                    Z(Ue, Ce)
                  };
                Be(tt, Ue => {
                  x(E) === "players" ? Ue(Ve) : Ue(Re, !1)
                })
              }
              Z(De, $e)
            },
            Pe = De => {
              var $e = kB();
              Z(De, $e)
            };
          Be(xe, De => {
            x(s) ? De(Ie) : De(Pe, !1)
          }, !0)
        }
        Z(_e, Ae)
      };
    Be(Q, _e => {
      x(s) && x(s).length === 0 ? _e(W) : _e(de, !1)
    })
  }
  Z(d, F), Pr()
}
var EB = fe('<div class="mt-5"><!></div>'),
  zB = fe('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function LB(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15);
  const y = ht(() => Lo(a.region.countryId));
  An(() => {
    const _e = Ae => {
      Ae.key === "Escape" && h(!1)
    };
    return document.addEventListener("keydown", _e), () => document.removeEventListener("keydown", _e)
  });
  var k = zB(),
    E = P(k),
    b = B(P(E), 2),
    s = P(b),
    F = P(s, !0);
  I(s);
  var O = B(s, 2),
    G = P(O, !0);
  I(O);
  var X = B(O, 2),
    Q = P(X);
  I(X), I(b);
  var W = B(b, 2);
  {
    var de = _e => {
      var Ae = EB(),
        xe = P(Ae);
      AB(xe, {
        get regionId() {
          return a.region.id
        }
      }), I(Ae), Ni(2, Ae, () => va, () => ({
        duration: 300
      })), Z(_e, Ae)
    };
    Be(W, _e => {
      h() && _e(de)
    })
  }
  I(E), en(2), I(k), pi(k, () => _e => {
    Kr(() => {
      h() ? _e.show() : _e.close()
    })
  }), Ze(_e => {
    Or(b, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${_e??""}`), nr(s, "data-tip", x(y).name), ce(F, x(y).flag), ce(G, a.region.name), ce(Q, `#${a.region.number??""}`)
  }, [() => Ri(a.region.cityId)]), Zn("close", k, () => h(!1)), Z(d, k), Pr()
}
var DB = fe("<!> <!>", 1),
  RB = fe('<div class="mt-3 flex justify-center"><span class="loading loading-spinner"></span></div>'),
  BB = fe('<div class="mt-3 flex justify-center"><p class="text-base-content/80 text-sm">No one has painted in this area yet.</p></div>'),
  FB = (d, a, h, y, k, E) => {
    switch (x(a)) {
      case "none":
        for (const b of x(h)) y.set(b.id, b);
        break;
      case "some":
      case "all":
        y.clear();
        break
    }
    k.crosshair.clear(), E(y.values())
  },
  OB = (d, a) => {
    navigator.clipboard.writeText([...a.keys()].filter(h => h !== 0).join(", ")), Ar.success("Player IDs copied to clipboard")
  },
  jB = (d, a, h) => {
    a([...h.values()], "timeout")
  },
  NB = (d, a, h) => {
    a([...h.values()], "ban")
  },
  ZB = fe('<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom ml-0.5" data-tip="Ban selected players"><!></button>'),
  VB = (d, a, h, y, k, E) => {
    x(a) ? h.delete(x(y).id) : h.set(x(y).id, x(y)), k.crosshair.clear(), E(h.values())
  },
  qB = fe('<div class="size-5"></div> <div class="text-base-content/80 ml-0.5">Not painted</div>', 1),
  UB = fe("<span> </span>"),
  $B = fe('<span class="badge badge-sm badge-error ml-0.5 border-0">DELETED</span>'),
  GB = fe('<span class="tooltip"><!></span>'),
  WB = fe('<span class="tooltip"><!></span>'),
  HB = fe('<!> <div class="ml-0.5 flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!> <!> <div class="ml-0.5 flex items-center"><!></div></div>', 1),
  JB = fe('<tr><th class="w-1"><input type="checkbox" class="checkbox-sm checkbox pointer-event-none"/></th><td class="flex items-center gap-1"><!></td><td class="text-center"> </td></tr>'),
  XB = fe('<div class="max-h-[27vh] overflow-y-auto"><table class="table"><thead><tr><th class="w-1"><input type="checkbox" class="checkbox-sm checkbox"/></th><th>Player <button class="btn btn-xs btn-circle btn-ghost tooltip tooltip-bottom ml-0.5" data-tip="Copy selected players IDs"><!></button> <button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom" data-tip="Timeout selected players"><!></button> <!></th><th class="text-center">Pixels Painted</th></tr></thead><tbody></tbody></table></div>'),
  YB = fe('<div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t sm:mb-3 sm:shadow-xl"><div class="p-3"><div class="flex justify-between gap-1"><h2 class="flex items-center gap-1 pl-1 text-lg"><div class="bg-base-content/20 flex size-6 items-center justify-center rounded-full"><!></div> <span class="ml-0.5">Selected area</span> <span class="text-base-content/80 ml-0.5 text-sm"> </span></h2> <button class="btn btn-circle btn-sm"><!></button></div> <div class="pb-3"><!></div></div></div>');

function KB(d, a) {
  Ir(a, !0);
  let h = di([]),
    y = rt(di([])),
    k = rt(!1),
    E = rt(!1);
  const b = new dm,
    s = ht(() => b.size === 0 ? "none" : b.size === x(y).length ? "all" : "some");
  An(() => {
    Vi.droppletAndPlop.play();
    const xe = a.map.on("click", async Ie => {
      if (h.length >= 2) {
        a.onclose();
        return
      }
      if (h.push(Ie.lngLat), a.crosshair.place([Ie.lngLat.lat, Ie.lngLat.lng]), Vi.plop.play(), h.length === 2) try {
        re(k, !0), re(y, await O(h[0], h[1]), !0);
        for (const Pe of x(y)) b.set(Pe.id, Pe);
        G(x(y))
      } finally {
        re(k, !1)
      }
    });
    return () => {
      xe.unsubscribe(), a.crosshair.clear()
    }
  });

  function F() {
    x(E) || a.onclose()
  }
  async function O(xe, Ie) {
    const Pe = new Zs(a.tileSize),
      [De, $e] = Pe.latLonToPixelsFloor(xe.lat, xe.lng, a.pixelArtZoom),
      [tt, Ve] = Pe.latLonToPixelsFloor(Ie.lat, Ie.lng, a.pixelArtZoom),
      [Re, Ue] = [Math.min(De, tt), Math.min($e, Ve)],
      [Ce, We] = [Math.max(De, tt), Math.max($e, Ve)],
      Je = Ce - Re,
      Ge = We - Ue;
    if (Je * Ge > 1e6) return Ar.error("The selected area is too big. Please select an area smaller than 1,000,000 pixels."), [];
    const mt = Math.floor(Re / a.tileSize),
      K = Math.floor(Ue / a.tileSize),
      ee = Math.floor(Ce / a.tileSize),
      le = Math.floor(We / a.tileSize),
      ae = ee - mt + 1,
      ke = le - K + 1,
      qe = new Array(ke).fill(0).flatMap((He, ut) => new Array(ae).fill(0).map(async (gt, St) => {
        const vt = mt + St,
          Ct = K + ut;
        let At = 0,
          Bt = 0,
          Vt = a.tileSize - 1,
          Ot = a.tileSize - 1;
        Ct === K && (Bt = Ue % a.tileSize), vt === mt && (At = Re % a.tileSize), Ct === le && (Ot = We % a.tileSize), vt === ee && (Vt = Ce % a.tileSize);
        const cr = [vt, Ct],
          ur = [At, Bt],
          Er = [Vt, Ot];
        return {
          response: await nn.getPixelAreaInfo({
            season: a.season,
            tile: cr,
            p0: ur,
            p1: Er
          }),
          tile: cr,
          p0: ur,
          p1: Er
        }
      })),
      lt = await Promise.all(qe),
      ot = new Map;
    for (const {
        response: He,
        p0: ut,
        p1: gt,
        tile: St
      }
      of lt) {
      const [vt, Ct] = St, [At, Bt] = ut, [Vt, Ot] = gt, Dt = Vt - At + 1, Rt = Ot - Bt + 1;
      for (let Zt = 0; Zt < Rt; Zt++)
        for (let Ft = 0; Ft < Dt; Ft++) {
          const cr = Zt * Dt + Ft,
            ur = He.paintedBy[cr];
          let Er = ot.get(ur);
          Er || (Er = {
            latitudes: [],
            longitudes: []
          }, ot.set(ur, Er));
          const [dr, pr] = Pe.pixelsToLatLon(vt * a.tileSize + (At + Ft + .5), Ct * a.tileSize + (Bt + Zt + .5), a.pixelArtZoom);
          Er.latitudes.push(dr), Er.longitudes.push(pr)
        }
    }
    const {
      users: dt
    } = await nn.getMultipleUsersInfoById([...ot.keys()]), Pt = Gx(dt, He => He.id), Lt = [...ot.entries()].map(([He, ut]) => ({
      ...Pt[He] ?? {
        id: He,
        name: "Player",
        deleted: !0
      },
      painted: ut
    }));
    return Lt.sort((He, ut) => He.id === 0 ? 1 : ut.id === 0 ? -1 : ut.painted.latitudes.length - He.painted.latitudes.length), Lt
  }

  function G(xe) {
    for (const Ie of xe) X(Ie.painted)
  }

  function X(xe) {
    for (let Ie = 0; Ie < xe.latitudes.length; Ie++) a.crosshair.place([xe.latitudes[Ie], xe.longitudes[Ie]]);
    Vi.plop.play()
  }
  async function Q(xe, Ie) {
    try {
      re(E, !0), xe = xe.filter(We => We.id !== 0);
      const Pe = xe.flatMap(We => We.painted.latitudes),
        De = xe.flatMap(We => We.painted.longitudes),
        $e = Math.min(...Pe),
        tt = Math.max(...Pe),
        Ve = Math.min(...De),
        Re = Math.max(...De);
      a.map.fitBounds([{
        lat: $e,
        lng: Ve
      }, {
        lat: tt,
        lng: Re
      }], {
        padding: 100,
        duration: 0
      });
      const Ue = await u_(a.map, {
          maxHeight: 1080,
          maxWidth: 1080,
          quality: .8,
          type: "image/jpeg"
        }),
        Ce = await Wx(Ue);
      await nn.postUsersSuspend({
        userIds: xe.map(We => We.id),
        suspension: Ie,
        imageBase64: Ce,
        latitude: ($e + tt) / 2,
        longitude: (Ve + Re) / 2,
        zoom: a.map.getZoom()
      });
      for (const We of xe) Ie === "ban" ? We.banned = !0 : Ie === "timeout" && (We.timedOut = !0);
      Ar.success("Users suspended successfully")
    } catch (Pe) {
      Ar.error(Pe.message)
    } finally {
      re(E, !1)
    }
  }
  var W = or();
  Zn("keydown", Gm, xe => xe.code === "Escape" && F());
  var de = pt(W);
  {
    var _e = xe => {
        gl(xe, {
          class: "bg-warning animate-bounce",
          children: (Ie, Pe) => {
            var De = DB(),
              $e = pt(De);
            nh($e, {
              class: "inline size-5"
            });
            var tt = B($e, 2);
            {
              var Ve = Ue => {
                  var Ce = Ii();
                  Ze(We => ce(Ce, We), [() => k0()]), Z(Ue, Ce)
                },
                Re = Ue => {
                  var Ce = or(),
                    We = pt(Ce);
                  {
                    var Je = Ge => {
                      var Ee = Ii();
                      Ze(mt => ce(Ee, mt), [() => M0()]), Z(Ge, Ee)
                    };
                    Be(We, Ge => {
                      h.length === 1 && Ge(Je)
                    }, !0)
                  }
                  Z(Ue, Ce)
                };
              Be(tt, Ue => {
                h.length === 0 ? Ue(Ve) : Ue(Re, !1)
              })
            }
            Z(Ie, De)
          },
          $$slots: {
            default: !0
          }
        })
      },
      Ae = xe => {
        var Ie = YB(),
          Pe = P(Ie),
          De = P(Pe),
          $e = P(De),
          tt = P($e),
          Ve = P(tt);
        nh(Ve, {
          class: "size-4"
        }), I(tt);
        var Re = B(tt, 4),
          Ue = P(Re);
        I(Re), I($e);
        var Ce = B($e, 2);
        Ce.__click = F;
        var We = P(Ce);
        Il(We, {
          class: "size-4"
        }), I(Ce), I(De);
        var Je = B(De, 2),
          Ge = P(Je);
        {
          var Ee = K => {
              var ee = RB();
              Z(K, ee)
            },
            mt = K => {
              var ee = or(),
                le = pt(ee);
              {
                var ae = qe => {
                    var lt = BB();
                    Z(qe, lt)
                  },
                  ke = qe => {
                    var lt = XB(),
                      ot = P(lt),
                      dt = P(ot),
                      Pt = P(dt),
                      Lt = P(Pt),
                      He = P(Lt);
                    ya(He), He.__click = [FB, s, y, b, a, G], I(Lt);
                    var ut = B(Lt),
                      gt = B(P(ut));
                    gt.__click = [OB, b];
                    var St = P(gt);
                    Ym(St, {
                      class: "size-3"
                    }), I(gt);
                    var vt = B(gt, 2);
                    vt.__click = [jB, Q, b];
                    var Ct = P(vt);
                    Xu(Ct, {
                      class: "size-4"
                    }), I(vt);
                    var At = B(vt, 2);
                    {
                      var Bt = Ot => {
                        var Dt = ZB();
                        Dt.__click = [NB, Q, b];
                        var Rt = P(Dt);
                        _p(Rt, {
                          class: "size-4"
                        }), I(Dt), Ze(() => Dt.disabled = x(E)), Z(Ot, Dt)
                      };
                      Be(At, Ot => {
                        var Dt;
                        ja((Dt = wt.data) == null ? void 0 : Dt.role, ["admin"]) && Ot(Bt)
                      })
                    }
                    I(ut), en(), I(Pt), I(dt);
                    var Vt = B(dt);
                    ai(Vt, 23, () => x(y), Ot => Ot.id, (Ot, Dt, Rt, Zt) => {
                      const Ft = ht(() => b.has(x(Dt).id));
                      var cr = JB();
                      let ur;
                      cr.__click = [VB, Ft, b, Dt, a, G];
                      var Er = P(cr),
                        dr = P(Er);
                      ya(dr), I(Er);
                      var pr = B(Er),
                        vr = P(pr);
                      {
                        var Vr = U => {
                            var Y = qB();
                            en(2), Z(U, Y)
                          },
                          qr = U => {
                            var Y = HB(),
                              oe = pt(Y);
                            fo(oe, {
                              class: "size-5 border-0",
                              get userId() {
                                return x(Dt).id
                              },
                              get pictureUrl() {
                                return x(Dt).picture
                              }
                            });
                            var me = B(oe, 2),
                              Se = P(me),
                              Oe = P(Se),
                              ze = P(Oe, !0);
                            I(Oe);
                            var Ke = B(Oe, 2),
                              _t = P(Ke);
                            I(Ke), I(Se);
                            var it = B(Se, 2);
                            {
                              var qt = Dr => {
                                var jr = UB(),
                                  $r = P(jr, !0);
                                I(jr), Ze((Br, Fr) => {
                                  Or(jr, 1, `badge badge-sm ml-0.5 border-0 ${Br??""} ${Fr??""}`), ce($r, x(Dt).allianceName)
                                }, [() => Ap(x(Dt).allianceId), () => Ri(x(Dt).allianceId)]), Z(Dr, jr)
                              };
                              Be(it, Dr => {
                                x(Dt).allianceId && Dr(qt)
                              })
                            }
                            var we = B(it, 2);
                            {
                              var Mt = Dr => {
                                var jr = $B();
                                Z(Dr, jr)
                              };
                              Be(we, Dr => {
                                x(Dt).deleted && Dr(Mt)
                              })
                            }
                            var Ut = B(we, 2),
                              jt = P(Ut);
                            {
                              var fr = Dr => {
                                  var jr = GB(),
                                    $r = P(jr);
                                  _p($r, {
                                    class: "text-error size-4"
                                  }), I(jr), Ze(Br => nr(jr, "data-tip", Br), [() => i_()]), Z(Dr, jr)
                                },
                                Ur = Dr => {
                                  var jr = or(),
                                    $r = pt(jr);
                                  {
                                    var Br = Fr => {
                                      var vn = WB(),
                                        bt = P(vn);
                                      Xu(bt, {
                                        class: "text-error size-4"
                                      }), I(vn), Ze(bn => nr(vn, "data-tip", bn), [() => o0()]), Z(Fr, vn)
                                    };
                                    Be($r, Fr => {
                                      x(Dt).timedOut && Fr(Br)
                                    }, !0)
                                  }
                                  Z(Dr, jr)
                                };
                              Be(jt, Dr => {
                                x(Dt).banned ? Dr(fr) : Dr(Ur, !1)
                              })
                            }
                            I(Ut), I(me), Ze(Dr => {
                              Or(Se, 1, `font-medium ${Dr??""} flex gap-1.5`), ce(ze, x(Dt).name), ce(_t, `#${x(Dt).id??""}`)
                            }, [() => Ri(x(Dt).id)]), Z(U, Y)
                          };
                        Be(vr, U => {
                          x(Dt).id === 0 ? U(Vr) : U(qr, !1)
                        })
                      }
                      I(pr);
                      var ue = B(pr),
                        V = P(ue, !0);
                      I(ue), I(cr), Ze((U, Y) => {
                        ur = Or(cr, 1, "hover:bg-base-300 cursor-pointer", null, ur, U), _v(dr, x(Ft)), ce(V, Y)
                      }, [() => ({
                        "bg-base-200": x(Ft)
                      }), () => x(Dt).painted.latitudes.length.toLocaleString()]), Z(Ot, cr)
                    }), I(Vt), I(ot), I(lt), Ze(() => {
                      _v(He, x(s) !== "none"), He.indeterminate = x(s) === "some", vt.disabled = x(E)
                    }), Z(qe, lt)
                  };
                Be(le, qe => {
                  x(y).length === 0 ? qe(ae) : qe(ke, !1)
                }, !0)
              }
              Z(K, ee)
            };
          Be(Ge, K => {
            x(k) ? K(Ee) : K(mt, !1)
          })
        }
        I(Je), I(Pe), I(Ie), Ze(K => ce(Ue, `(Pixels: ${K??""})`), [() => [...b.values()].reduce((K, ee) => K + ee.painted.latitudes.length, 0)]), Ni(3, Ie, () => ip, () => ({
          duration: 100
        })), Z(xe, Ie)
      };
    Be(de, xe => {
      h.length < 2 ? xe(_e) : xe(Ae, !1)
    })
  }
  Z(d, W), Pr()
}
Ln(["click"]);
var QB = xr('<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>');

function Ty(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = QB();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var eF = xr('<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>');

function tF(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = eF();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var rF = xr('<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>'),
  nF = xr('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>');

function iF(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
  var y = or(),
    k = pt(y);
  {
    var E = s => {
        var F = rF();
        lr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...h
        })), Z(s, F)
      },
      b = s => {
        var F = nF();
        lr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...h
        })), Z(s, F)
      };
    Be(k, s => {
      a.filled ? s(E) : s(b, !1)
    })
  }
  Z(d, y)
}
var aF = (d, a, h, y, k) => {
    if (x(a) && x(h)) {
      const E = x(a) - x(h).clientHeight,
        b = x(a) / 2 - E / 2;
      y.map.flyTo({
        center: {
          lat: x(k).center[0],
          lng: x(k).center[1]
        },
        zoom: 17.5,
        offset: [0, -b]
      })
    }
  },
  oF = (d, a, h) => a.onclickregion(x(h)),
  sF = fe('<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button>'),
  lF = fe('<div class="skeleton h-5 w-16"></div>'),
  cF = fe('<div class="skeleton mt-1 h-5 w-32"></div>'),
  uF = fe('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><div class="bg-base-content/20 flex size-5 items-center justify-center rounded-full text-sm"><img alt="Pumpkin" class="size-5"/></div></div> <div class="flex flex-wrap items-center gap-1"><span class="flex gap-1.5 font-medium text-orange-500"><span> </span> <span> </span></span></div></div>'),
  hF = fe('<span class="font-flag tooltip ml-0.5"> </span>'),
  dF = fe('<span class="badge badge-sm bg-primary/20 text-primary tooltip ml-0.5 border-0"> </span>'),
  pF = (d, a) => {
    navigator.clipboard.writeText(x(a).allianceId.toString()), Ar.success(e_())
  },
  fF = fe("<button><!></button>"),
  mF = fe("<span> </span> <!>", 1),
  _F = fe('<span class="tooltip"><!></span>'),
  gF = fe('<span class="tooltip"><!></span>'),
  vF = (d, a) => {
    a("report-user")
  },
  yF = fe("<li><button><!> </button></li>"),
  xF = (d, a) => {
    a("timeout")
  },
  bF = fe("<li><button><!> </button></li>"),
  wF = (d, a) => {
    a("ban")
  },
  CF = fe("<li><button><!> </button></li>"),
  TF = async (d, a, h, y, k, E) => {
    re(a, !0);
    try {
      await nn.banAllianceUser(x(h).id), await y({
        ...x(k),
        season: E.season
      })
    } catch (b) {
      Ar.error(b.message)
    } finally {
      re(a, !1)
    }
  }, SF = fe('<li><button class="text-error font-medium"><!> </button></li>'), IF = fe('<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left ml-1"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 shadow-sm"></ul></div>'), PF = fe('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><!></div> <div class="flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!> <!> <!> <!> <!></div> <!></div>'), kF = (d, a) => a.onclickpaint(a.latLon), MF = fe('<button class="btn btn-primary"><!> </button>'), AF = (d, a) => a(), EF = fe("<!> ", 1), zF = fe("<!> ", 1), LF = fe('<button class="btn btn-primary"><!></button>'), DF = async (d, a, h, y) => {
    try {
      re(a, !0), x(h) ? (await nn.deleteFavoriteLocation(x(h).id), Ar.warning(jS())) : (await nn.favoriteLocation(x(y).center), Ar.success(VS())), Vi.smallPlop.play(), wt.refresh()
    } catch (k) {
      Ar.error(k.message)
    } finally {
      re(a, !1)
    }
  }, RF = fe("<button><!> </button>"), BF = (d, a, h) => a.onclickshare(ck(ri.url, {
    pos: {
      lat: x(h).center[0],
      lng: x(h).center[1]
    },
    zoom: a.zoom
  })), FF = fe('<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><!> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>');

function OF(d, a) {
  Ir(a, !0);
  let h = rt(void 0);
  const y = ht(() => new Zs(a.tileSize));
  let k = rt(void 0),
    E = rt(void 0),
    b = rt(!1),
    s = rt(!1);
  const F = ht(() => {
      var He, ut, gt;
      return !!((ut = (He = x(h)) == null ? void 0 : He.paintedBy) != null && ut.id) && ((gt = wt.data) == null ? void 0 : gt.id) === x(h).paintedBy.id
    }),
    O = ht(() => {
      const [He, ut] = a.latLon ?? [0, 0], gt = x(y).latLonToPixelBoundsLatLon(He, ut, a.pixelArtZoom), St = o_(gt), {
        tile: vt,
        pixel: Ct
      } = x(y).latLonToTileAndPixel(He, ut, a.pixelArtZoom), At = x(y).latLonToRegionAndPixel(He, ut, a.pixelArtZoom);
      return {
        bounds: gt,
        center: St,
        tile: vt,
        pixel: Ct,
        regionPixel: At.pixel
      }
    });
  Kr(() => {
    Vi.plop.play(), a.crosshair.clearAndPlace(a.latLon)
  });
  let G = 0;
  const X = ({
    pixel: He,
    tile: ut,
    season: gt
  }) => `s${gt}:p(${He[0]},${He[1]}):t(${ut[0]},${ut[1]})`;
  let Q;
  Cl(() => [x(O), a.season], () => {
    const He = {
        ...x(O),
        season: a.season
      },
      ut = X(He);
    if (re(h, a.pixelInfoCache.get(ut), !0), x(h) !== void 0) return;
    a.pixelInfoCache.size === 0 && (G = 0), G++, G > 6 ? (clearTimeout(Q), Q = setTimeout(async () => W(He), 500)) : W(He)
  });
  async function W(He) {
    var St;
    const ut = await nn.getPixelInfo({
      ...He,
      isModerator: ja((St = wt.data) == null ? void 0 : St.role, ["admin", "global_moderator", "moderator"])
    });
    if (ut.paintedBy !== void 0) {
      const vt = X(He);
      a.pixelInfoCache.set(vt, ut)
    }
    const gt = X({
      ...x(O),
      season: a.season
    });
    return re(h, a.pixelInfoCache.get(gt), !0), ut
  }
  An(() => () => {
    a.crosshair.clear(), Vi.smallPlop.play()
  });
  const de = ht(() => {
    var St, vt, Ct, At, Bt;
    const He = [],
      ut = (vt = (St = wt) == null ? void 0 : St.data) == null ? void 0 : vt.role;
    ja(ut, ["admin"]) && !x(F) && He.push("ban-user"), ja(ut, ["admin", "global_moderator", "moderator"]) && !x(F) && He.push("timeout-user"), !x(F) && wt.data && He.push("report-user");
    const gt = (Ct = x(h)) == null ? void 0 : Ct.paintedBy;
    return (gt == null ? void 0 : gt.allianceId) === ((At = wt.data) == null ? void 0 : At.allianceId) && ((Bt = wt.data) == null ? void 0 : Bt.allianceRole) === "admin" && wt.data.id !== (gt == null ? void 0 : gt.id) && !x(F) && He.push("ban-alliance"), He
  });

  function _e(He) {
    const ut = (async () => await u_(a.map, {
      maxHeight: 1080,
      maxWidth: 1080,
      quality: .8,
      type: "image/jpeg"
    }))();
    a.onclickmodaction(x(h), ut, a.latLon, He)
  }
  async function Ae() {
    try {
      await nn.claimEventPixel({
        ...x(O),
        season: a.season
      }), Ar.success(j6({
        droplets: 2e3.toLocaleString()
      })), await W({
        ...x(O),
        season: a.season
      }), await wt.refresh()
    } catch (He) {
      Ar.error(He.message)
    }
  }
  var xe = FF();
  Zn("keypress", Gm, He => {
    He.key === "Escape" && a.onclose()
  });
  var Ie = P(xe),
    Pe = P(Ie),
    De = P(Pe);
  De.__click = [aF, k, E, a, O];
  var $e = P(De);
  Wm($e, {
    class: "fill-primary size-5"
  }), I(De);
  var tt = B(De, 2),
    Ve = P(tt),
    Re = P(Ve);
  I(Ve);
  var Ue = B(Ve, 2);
  {
    var Ce = He => {
        const ut = ht(() => x(h).region),
          gt = ht(() => Lo(x(ut).countryId));
        var St = sF();
        St.__click = [oF, a, ut];
        var vt = P(St),
          Ct = P(vt, !0);
        I(vt);
        var At = B(vt, 2),
          Bt = P(At, !0);
        I(At);
        var Vt = B(At, 2),
          Ot = P(Vt);
        I(Vt), I(St), Ze(Dt => {
          Or(St, 1, `btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${Dt??""}`), nr(vt, "data-tip", x(gt).name), ce(Ct, x(gt).flag), ce(Bt, x(ut).name), ce(Ot, `#${x(ut).number??""}`)
        }, [() => Ri(x(ut).cityId)]), Z(He, St)
      },
      We = He => {
        var ut = lF();
        Z(He, ut)
      };
    Be(Ue, He => {
      var ut;
      (ut = x(h)) != null && ut.region ? He(Ce) : He(We, !1)
    })
  }
  I(tt), I(Pe);
  var Je = B(Pe, 2);
  Je.__click = function(...He) {
    var ut;
    (ut = a.onclose) == null || ut.apply(this, He)
  };
  var Ge = P(Je);
  Il(Ge, {
    class: "size-4"
  }), I(Je), I(Ie);
  var Ee = B(Ie, 2),
    mt = P(Ee);
  {
    var K = He => {
        var ut = cF();
        Z(He, ut)
      },
      ee = He => {
        var ut = or(),
          gt = pt(ut);
        {
          var St = Ct => {
              var At = Ii();
              Ze(Bt => ce(At, Bt), [() => $T()]), Z(Ct, At)
            },
            vt = Ct => {
              var At = or(),
                Bt = pt(At);
              {
                var Vt = Dt => {
                    var Rt = uF(),
                      Zt = P(Rt),
                      Ft = P(Zt);
                    I(Zt);
                    var cr = B(Zt, 2),
                      ur = P(cr),
                      Er = P(ur);
                    I(ur), I(cr);
                    var dr = B(cr, 2),
                      pr = P(dr),
                      vr = P(pr),
                      Vr = P(vr, !0);
                    I(vr);
                    var qr = B(vr, 2),
                      ue = P(qr);
                    I(qr), I(pr), I(dr), I(Rt), Ze((V, U) => {
                      ce(Ft, `${V??""}:`), nr(Er, "src", rs), ce(Vr, U), ce(ue, `#${x(h).paintedBy.eventClaimNumber??""}`)
                    }, [() => V6(), () => A6()]), Z(Dt, Rt)
                  },
                  Ot = Dt => {
                    const Rt = ht(() => x(h).paintedBy);
                    var Zt = PF(),
                      Ft = P(Zt),
                      cr = P(Ft);
                    I(Ft);
                    var ur = B(Ft, 2),
                      Er = P(ur);
                    fo(Er, {
                      class: "size-5 border-0",
                      get userId() {
                        return x(Rt).id
                      },
                      get pictureUrl() {
                        return x(Rt).picture
                      }
                    }), I(ur);
                    var dr = B(ur, 2),
                      pr = P(dr),
                      vr = P(pr),
                      Vr = P(vr, !0);
                    I(vr);
                    var qr = B(vr, 2),
                      ue = P(qr);
                    I(qr), I(pr);
                    var V = B(pr, 2);
                    {
                      var U = Mt => {
                        const Ut = ht(() => Lo(x(Rt).equippedFlag));
                        var jt = hF(),
                          fr = P(jt, !0);
                        I(jt), Ze(() => {
                          nr(jt, "data-tip", x(Ut).name), ce(fr, x(Ut).flag)
                        }), Z(Mt, jt)
                      };
                      Be(V, Mt => {
                        x(Rt).equippedFlag && Mt(U)
                      })
                    }
                    var Y = B(V, 2);
                    {
                      var oe = Mt => {
                        Vh(Mt, {
                          get username() {
                            return x(Rt).discord
                          },
                          get id() {
                            return x(Rt).discordId
                          }
                        })
                      };
                      Be(Y, Mt => {
                        x(Rt).discord && Mt(oe)
                      })
                    }
                    var me = B(Y, 2);
                    {
                      var Se = Mt => {
                        var Ut = dF(),
                          jt = P(Ut, !0);
                        I(Ut), Ze(() => {
                          nr(Ut, "data-tip", x(Rt).role), ce(jt, s0[x(Rt).role])
                        }), Z(Mt, Ut)
                      };
                      Be(me, Mt => {
                        x(Rt).role && x(Rt).role !== "user" && Mt(Se)
                      })
                    }
                    var Oe = B(me, 2);
                    {
                      var ze = Mt => {
                        var Ut = mF(),
                          jt = pt(Ut),
                          fr = P(jt, !0);
                        I(jt);
                        var Ur = B(jt, 2);
                        {
                          var Dr = jr => {
                            var $r = fF();
                            $r.__click = [pF, Rt];
                            var Br = P($r);
                            Ym(Br, {
                              class: "size-3"
                            }), I($r), Ze((Fr, vn) => {
                              Or($r, 1, Fr), nr($r, "title", vn)
                            }, [() => ls(Ri(x(Rt).allianceId)), () => yb({
                              allianceId: x(Rt).allianceId
                            })]), Z(jr, $r)
                          };
                          Be(Ur, jr => {
                            var $r, Br, Fr;
                            ((($r = wt.data) == null ? void 0 : $r.role) === "admin" || ((Br = wt.data) == null ? void 0 : Br.role) === "moderator" || ((Fr = wt.data) == null ? void 0 : Fr.role) === "global_moderator") && jr(Dr)
                          })
                        }
                        Ze((jr, $r) => {
                          Or(jt, 1, `badge badge-sm ml-0.5 border-0 ${jr??""} ${$r??""}`), ce(fr, x(Rt).allianceName)
                        }, [() => Ap(x(Rt).allianceId), () => Ri(x(Rt).allianceId)]), Z(Mt, Ut)
                      };
                      Be(Oe, Mt => {
                        x(Rt).allianceId && Mt(ze)
                      })
                    }
                    var Ke = B(Oe, 2);
                    {
                      var _t = Mt => {
                          var Ut = _F(),
                            jt = P(Ut);
                          _p(jt, {
                            class: "text-error size-4"
                          }), I(Ut), Ze(fr => nr(Ut, "data-tip", fr), [() => i_()]), Z(Mt, Ut)
                        },
                        it = Mt => {
                          var Ut = or(),
                            jt = pt(Ut);
                          {
                            var fr = Ur => {
                              var Dr = gF(),
                                jr = P(Dr);
                              Xu(jr, {
                                class: "text-error size-4"
                              }), I(Dr), Ze($r => nr(Dr, "data-tip", $r), [() => o0()]), Z(Ur, Dr)
                            };
                            Be(jt, Ur => {
                              x(h).paintedBy.timedOut && Ur(fr)
                            }, !0)
                          }
                          Z(Mt, Ut)
                        };
                      Be(Ke, Mt => {
                        x(h).paintedBy.banned ? Mt(_t) : Mt(it, !1)
                      })
                    }
                    I(dr);
                    var qt = B(dr, 2);
                    {
                      var we = Mt => {
                        var Ut = IF(),
                          jt = P(Ut),
                          fr = P(jt);
                        c_(fr, {
                          class: "size-4"
                        }), I(jt);
                        var Ur = B(jt, 2);
                        ai(Ur, 21, () => x(de), kp, (Dr, jr) => {
                          var $r = or(),
                            Br = pt($r);
                          {
                            var Fr = bt => {
                                var bn = yF(),
                                  fn = P(bn);
                                let $n;
                                fn.__click = [vF, _e];
                                var zt = P(fn);
                                qm(zt, {
                                  class: "size-5"
                                });
                                var nt = B(zt);
                                I(fn), I(bn), Ze(($t, Gt) => {
                                  $n = Or(fn, 1, "text-error py-2 font-medium", null, $n, $t), ce(nt, ` ${Gt??""}`)
                                }, [() => ({
                                  "cursor-not-allowed": x(F)
                                }), () => ib()]), Z(bt, bn)
                              },
                              vn = bt => {
                                var bn = or(),
                                  fn = pt(bn);
                                {
                                  var $n = nt => {
                                      var $t = bF(),
                                        Gt = P($t);
                                      let xt;
                                      Gt.__click = [xF, _e];
                                      var It = P(Gt);
                                      Xu(It, {
                                        class: "size-5"
                                      });
                                      var Wt = B(It);
                                      I(Gt), I($t), Ze((Nt, gr) => {
                                        xt = Or(Gt, 1, "text-error font-medium", null, xt, Nt), ce(Wt, ` ${gr??""}`)
                                      }, [() => ({
                                        "cursor-not-allowed": x(F)
                                      }), () => ab()]), Z(nt, $t)
                                    },
                                    zt = nt => {
                                      var $t = or(),
                                        Gt = pt($t);
                                      {
                                        var xt = Wt => {
                                            var Nt = CF(),
                                              gr = P(Nt);
                                            let Qr;
                                            gr.__click = [wF, _e];
                                            var zr = P(gr);
                                            _p(zr, {
                                              class: "size-5"
                                            });
                                            var Hr = B(zr);
                                            I(gr), I(Nt), Ze((hn, Yt) => {
                                              Qr = Or(gr, 1, "text-error font-medium", null, Qr, hn), ce(Hr, ` ${Yt??""}`)
                                            }, [() => ({
                                              "cursor-not-allowed": x(F)
                                            }), () => ob()]), Z(Wt, Nt)
                                          },
                                          It = Wt => {
                                            var Nt = or(),
                                              gr = pt(Nt);
                                            {
                                              var Qr = zr => {
                                                var Hr = SF(),
                                                  hn = P(Hr);
                                                hn.__click = [TF, s, Rt, W, O, a];
                                                var Yt = P(hn);
                                                tF(Yt, {
                                                  class: "size-5"
                                                });
                                                var tn = B(Yt);
                                                I(hn), I(Hr), Ze(an => ce(tn, ` ${an??""}`), [() => T0()]), Z(zr, Hr)
                                              };
                                              Be(gr, zr => {
                                                x(jr) === "ban-alliance" && zr(Qr)
                                              }, !0)
                                            }
                                            Z(Wt, Nt)
                                          };
                                        Be(Gt, Wt => {
                                          x(jr) === "ban-user" ? Wt(xt) : Wt(It, !1)
                                        }, !0)
                                      }
                                      Z(nt, $t)
                                    };
                                  Be(fn, nt => {
                                    x(jr) === "timeout-user" ? nt($n) : nt(zt, !1)
                                  }, !0)
                                }
                                Z(bt, bn)
                              };
                            Be(Br, bt => {
                              x(jr) === "report-user" ? bt(Fr) : bt(vn, !1)
                            })
                          }
                          Z(Dr, $r)
                        }), I(Ur), I(Ut), Z(Mt, Ut)
                      };
                      Be(qt, Mt => {
                        x(de).length > 0 && Mt(we)
                      })
                    }
                    I(Zt), Ze((Mt, Ut) => {
                      var jt;
                      ce(cr, `${Mt??""}:`), Or(pr, 1, `font-medium ${Ut??""} flex gap-1.5`), ce(Vr, ((jt = wt.data) == null ? void 0 : jt.id) === x(Rt).id ? wt.data.name : x(Rt).name), ce(ue, `#${x(Rt).id??""}`)
                    }, [() => HT(), () => Ri(x(Rt).id)]), Z(Dt, Zt)
                  };
                Be(Bt, Dt => {
                  x(h).paintedBy.event ? Dt(Vt) : Dt(Ot, !1)
                }, !0)
              }
              Z(Ct, At)
            };
          Be(gt, Ct => {
            x(h).paintedBy.id === 0 ? Ct(St) : Ct(vt, !1)
          }, !0)
        }
        Z(He, ut)
      };
    Be(mt, He => {
      x(h) === void 0 ? He(K) : He(ee, !1)
    })
  }
  I(Ee);
  var le = B(Ee, 2),
    ae = P(le);
  {
    var ke = He => {
        var ut = MF();
        ut.__click = [kF, a];
        var gt = P(ut);
        qh(gt, {
          class: "size-4.5"
        });
        var St = B(gt);
        I(ut), Ze(vt => {
          ut.disabled = wt.loading, ce(St, ` ${vt??""}`)
        }, [() => w0()]), Z(He, ut)
      },
      qe = He => {
        var ut = or(),
          gt = pt(ut);
        {
          var St = vt => {
            var Ct = LF();
            Ct.__click = [AF, Ae];
            var At = P(Ct);
            {
              var Bt = Ot => {
                  var Dt = EF(),
                    Rt = pt(Dt);
                  wb(Rt, {
                    class: "size-4.5"
                  });
                  var Zt = B(Rt);
                  Ze(Ft => ce(Zt, ` ${Ft??""}`), [() => B6()]), Z(Ot, Dt)
                },
                Vt = Ot => {
                  var Dt = zF(),
                    Rt = pt(Dt);
                  Ty(Rt, {
                    class: "size-4.5"
                  });
                  var Zt = B(Rt);
                  Ze(Ft => ce(Zt, ` ${Ft??""}`), [() => L6()]), Z(Ot, Dt)
                };
              Be(At, Ot => {
                x(h).paintedBy.claimed ? Ot(Bt) : Ot(Vt, !1)
              })
            }
            I(Ct), Ze(() => Ct.disabled = wt.loading || x(h).paintedBy.claimed), Z(vt, Ct)
          };
          Be(gt, vt => {
            wt.data && vt(St)
          }, !0)
        }
        Z(He, ut)
      };
    Be(ae, He => {
      var ut;
      (ut = x(h)) != null && ut.paintedBy.event ? He(qe, !1) : He(ke)
    })
  }
  var lt = B(ae, 2);
  {
    var ot = He => {
      const ut = ht(() => wt.data.favoriteLocations.find(Bt => Math.abs(Bt.latitude - x(O).center[0]) < 5e-5 && Math.abs(Bt.longitude - x(O).center[1]) < 5e-5)),
        gt = ht(() => !x(ut) && wt.data.favoriteLocations.length >= wt.data.maxFavoriteLocations);
      var St = RF();
      let vt;
      St.__click = [DF, b, ut, O];
      var Ct = P(St);
      {
        let Bt = ht(() => !!x(ut));
        iF(Ct, {
          class: "size-4.5",
          get filled() {
            return x(Bt)
          }
        })
      }
      var At = B(Ct);
      I(St), Ze((Bt, Vt) => {
        vt = Or(St, 1, "btn btn-primary btn-soft", null, vt, Bt), St.disabled = x(b) || x(gt), ce(At, ` ${Vt??""}`)
      }, [() => ({
        "text-yellow-400": !!x(ut)
      }), () => x(gt) ? YT() : eS()]), Z(He, St)
    };
    Be(lt, He => {
      wt.data && He(ot)
    })
  }
  var dt = B(lt, 2);
  dt.__click = [BF, a, O];
  var Pt = P(dt);
  R0(Pt, {
    class: "size-4.5"
  });
  var Lt = B(Pt);
  I(dt), I(le), I(xe), us(xe, He => re(E, He), () => x(E)), Ze(He => {
    ce(Re, `Pixel: ${x(O).regionPixel[0]??""}, ${x(O).regionPixel[1]??""}`), ce(Lt, ` ${He??""}`)
  }, [() => nS()]), zp("innerHeight", He => re(k, He, !0)), Z(d, xe), Pr()
}
Ln(["click"]);

function jF(d) {
  var y;
  const a = document.createElement("div");
  (y = d.parentElement) == null || y.insertBefore(a, d.nextSibling);
  const h = new IntersectionObserver(k => {
    k[0].isIntersecting ? d.classList.remove("stuck") : d.classList.add("stuck")
  }, {
    threshold: 0,
    rootMargin: "0px"
  });
  return h.observe(a), () => {
    a.remove(), h.disconnect()
  }
}
var Um;
(d => {
  function a() {
    let h, y;
    return {
      promise: new Promise((E, b) => {
        h = E, y = b
      }),
      resolve: h,
      reject: y
    }
  }
  d.withResolvers = a
})(Um || (Um = {}));
var NF = xr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>'),
  ZF = xr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>');

function VF(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
  var y = or(),
    k = pt(y);
  {
    var E = s => {
        var F = NF();
        lr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...h
        })), Z(s, F)
      },
      b = s => {
        var F = ZF();
        lr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...h
        })), Z(s, F)
      };
    Be(k, s => {
      a.filled ? s(E) : s(b, !1)
    })
  }
  Z(d, y)
}
var qF = fe("<p><!></p>"),
  UF = fe('<span class="loading loading-spinner center-absolute absolute"></span>'),
  $F = fe('<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <span class="text-sm">Droplets</span></button>'),
  GF = fe('<span class="loading loading-spinner center-absolute absolute"></span>'),
  WF = fe('<!> <span class="text-sm"> </span>', 1),
  HF = fe('<span class="text-sm"> </span>'),
  JF = fe('<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>'),
  XF = fe('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <h3 class="mt-2 text-center text-xl font-bold"> <!></h3> <!> <div><!></div></div>'),
  YF = (d, a) => {
    re(a, !x(a))
  },
  KF = fe('<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium">Flags</h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>');

function QF(d, a) {
  Ir(a, !0);
  const h = (De, $e = ra, tt = ra) => {
      const Ve = ht(() => {
          var dt;
          return (((dt = wt.data) == null ? void 0 : dt.droplets) ?? 0) >= s.price
        }),
        Re = ht(() => x(O) === $e().id),
        Ue = ht(() => y.has($e().id));
      var Ce = XF(),
        We = P(Ce),
        Je = P(We, !0);
      I(We);
      var Ge = B(We, 2),
        Ee = P(Ge),
        mt = B(Ee);
      {
        var K = dt => {
          var Pt = qF(),
            Lt = P(Pt);
          th(Lt, {
            class: "text-base-content/60 size-4.5 inline pb-0.5"
          }), I(Pt), Ze(He => {
            Or(Pt, 1, ls({
              "tooltip inline": !0,
              "lg:before:-translate-x-1/3": (tt() + 1) % 4 === 0,
              "lg:before:translate-x-1/3": tt() % 4 === 0,
              "before:-translate-x-1/3": (tt() + 1) % 2 === 0,
              "before:translate-x-1/3": tt() % 2 === 0
            })), nr(Pt, "data-tip", He)
          }, [() => jP()]), Z(dt, Pt)
        };
        Be(mt, dt => {
          x(Ue) && dt(K)
        })
      }
      I(Ge);
      var ee = B(Ge, 2);
      {
        var le = dt => {
          m_(dt, {})
        };
        Be(ee, dt => {
          $e().id === x(G) && dt(le)
        })
      }
      var ae = B(ee, 2);
      let ke;
      var qe = P(ae);
      {
        var lt = dt => {
            var Pt = $F();
            Pt.__click = async () => {
              if (!(x(Ue) && !await a.promptUserConfirmation($e().name))) try {
                const St = $e().id;
                re(O, St, !0), await nn.purchase({
                  id: b,
                  amount: 1,
                  variant: St
                }), wt.refresh(), Vi.notification1.play();
                const vt = E.find(Ct => Ct.id === St);
                vt && (vt.owned = !0), re(G, St, !0)
              } catch (St) {
                Ar.error(St.message)
              } finally {
                re(O, void 0)
              }
            };
            var Lt = P(Pt);
            {
              var He = St => {
                var vt = UF();
                Z(St, vt)
              };
              Be(Lt, St => {
                x(Re) && St(He)
              })
            }
            var ut = B(Lt, 2);
            Ep(ut, {
              class: "size-4"
            });
            var gt = B(ut);
            en(), I(Pt), Ze(St => {
              Pt.disabled = !x(Ve) || x(Re), ce(gt, ` ${St??""} `)
            }, [() => s.price.toLocaleString("en-US")]), Z(dt, Pt)
          },
          ot = dt => {
            const Pt = ht(() => {
              var Vt;
              return ((Vt = wt.data) == null ? void 0 : Vt.equippedFlag) === $e().id
            });
            var Lt = JF();
            let He;
            Lt.__click = async () => {
              try {
                re(O, $e().id, !0);
                const Vt = x(Pt) ? 0 : $e().id;
                await nn.equipFlag(Vt), wt.data && (wt.data.equippedFlag = Vt), wt.refresh()
              } catch (Vt) {
                Ar.error(Vt.message)
              } finally {
                re(O, void 0)
              }
            };
            var ut = P(Lt),
              gt = P(ut, !0);
            I(ut);
            var St = B(ut, 2);
            {
              var vt = Vt => {
                var Ot = GF();
                Z(Vt, Ot)
              };
              Be(St, Vt => {
                x(Re) && Vt(vt)
              })
            }
            var Ct = B(St, 2);
            {
              var At = Vt => {
                  var Ot = WF(),
                    Dt = pt(Ot);
                  Il(Dt, {
                    class: "size-4"
                  });
                  var Rt = B(Dt, 2),
                    Zt = P(Rt, !0);
                  I(Rt), Ze(Ft => ce(Zt, Ft), [() => a5()]), Z(Vt, Ot)
                },
                Bt = Vt => {
                  var Ot = HF(),
                    Dt = P(Ot, !0);
                  I(Ot), Ze(Rt => ce(Dt, Rt), [() => l5()]), Z(Vt, Ot)
                };
              Be(Ct, Vt => {
                x(Pt) ? Vt(At) : Vt(Bt, !1)
              })
            }
            I(Lt), Ze((Vt, Ot) => {
              He = Or(Lt, 1, "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10", null, He, Vt), Lt.disabled = x(Re), ce(gt, Ot)
            }, [() => ({
              "btn-warning": x(Pt)
            }), () => r5()]), Z(dt, Lt)
          };
        Be(qe, dt => {
          $e().owned ? dt(ot, !1) : dt(lt)
        })
      }
      I(ae), I(Ce), Ze((dt, Pt) => {
        ce(Je, $e().flag), ce(Ee, `${$e().name??""} `), ke = Or(ae, 1, "mt-3", null, ke, dt), nr(ae, "data-tip", Pt)
      }, [() => ({
        tooltip: !x(Ve)
      }), () => Dp()]), Z(De, Ce)
    },
    y = new Set([8, 30, 32, 84, 96, 125, 143, 146, 150, 192, 200, 236, 240, 251]),
    k = Bi.countries.map(De => ({
      ...De,
      owned: wt.flagsBitmap.get(De.id)
    }));
  k.sort((De, $e) => Number($e.owned) - Number(De.owned));
  const E = di(k),
    b = 110,
    s = Bi.products[b];
  let F = rt(!1),
    O = rt(void 0),
    G = rt(void 0);
  var X = KF(),
    Q = P(X),
    W = P(Q);
  VF(W, {
    class: "size-5.5",
    filled: !0
  }), en(2), I(Q);
  var de = B(Q, 2),
    _e = P(de, !0);
  I(de);
  var Ae = B(de, 2);
  ai(Ae, 23, () => E, De => De.id, (De, $e, tt) => {
    var Ve = or(),
      Re = pt(Ve);
    {
      var Ue = Ce => {
        h(Ce, () => x($e), () => x(tt))
      };
      Be(Re, Ce => {
        (x(tt) < 8 || x(F)) && Ce(Ue)
      })
    }
    Z(De, Ve)
  }), I(Ae);
  var xe = B(Ae, 2),
    Ie = P(xe);
  Ie.__click = [YF, F];
  var Pe = P(Ie, !0);
  I(Ie), I(xe), I(X), Ze(De => {
    ce(_e, De), ce(Pe, x(F) ? "Show less" : "Show more")
  }, [() => Qw()]), Z(d, X), Pr()
}
Ln(["click"]);
var eO = fe('<p class="mt-1 text-center text-sm"> </p>'),
  tO = (d, a) => {
    i0(a, -1)
  },
  rO = (d, a) => {
    i0(a)
  },
  nO = (d, a, h) => {
    a(x(h))
  },
  iO = fe('<button class="text-base-content/80 absolute left-full top-1/2 ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>'),
  aO = async (d, a, h, y) => {
    try {
      re(a, !0), await nn.purchase({
        id: h.productId,
        amount: y()
      }), Vi.notification1.play(), h.onpurchasecompleted(y())
    } catch (k) {
      Ar.error(k.message)
    } finally {
      re(a, !1)
    }
  }, oO = fe('<span class="loading loading-spinner center-absolute absolute"></span>'), sO = fe('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>');

function e0(d, a) {
  Ir(a, !0);
  let h = Tt(a, "amount", 15, 1);
  const y = ht(() => h() * a.unitPrice),
    k = ht(() => Math.floor(a.userDroplets / a.unitPrice));
  let E = rt(!1);
  Kr(() => {
    h() < 0 && h(0)
  });
  var b = sO(),
    s = P(b),
    F = P(s);
  Hn(F, () => a.icon ?? ra), I(s);
  var O = B(s, 2),
    G = P(O, !0);
  I(O);
  var X = B(O, 2);
  {
    var Q = Ce => {
      var We = eO(),
        Je = P(We, !0);
      I(We), Ze(() => ce(Je, a.subtitle)), Z(Ce, We)
    };
    Be(X, Ce => {
      a.subtitle && Ce(Q)
    })
  }
  var W = B(X, 2),
    de = P(W);
  de.__click = [tO, h];
  var _e = B(de, 2);
  ya(_e);
  var Ae = B(_e, 2);
  Ae.__click = [rO, h];
  var xe = B(Ae, 2);
  {
    var Ie = Ce => {
      var We = iO();
      We.__click = [nO, h, k], Z(Ce, We)
    };
    Be(xe, Ce => {
      h() < x(k) && Ce(Ie)
    })
  }
  I(W);
  var Pe = B(W, 2);
  let De;
  var $e = P(Pe);
  $e.__click = [aO, E, a, h];
  var tt = P($e);
  {
    var Ve = Ce => {
      var We = oO();
      Z(Ce, We)
    };
    Be(tt, Ce => {
      x(E) && Ce(Ve)
    })
  }
  var Re = B(tt, 2);
  Ep(Re, {
    class: "size-4"
  });
  var Ue = B(Re);
  en(), I($e), I(Pe), I(b), Ze((Ce, We, Je, Ge) => {
    ce(G, Ce), Ae.disabled = h() >= x(k), nr(Pe, "data-tip", We), De = Or(Pe, 1, "", null, De, Je), $e.disabled = a.userDroplets < x(y) || x(E) || !h(), ce(Ue, ` ${Ge??""} `)
  }, [() => a.title(h()), () => Dp(), () => ({
    tooltip: a.userDroplets < x(y)
  }), () => x(y).toLocaleString("en-US")]), Mp(_e, h), Z(d, b), Pr()
}
Ln(["click"]);
var lO = xr('<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>');

function cO(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = lO();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var uO = xr('<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>');

function Sy(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = uO();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var hO = xr('<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>');

function dO(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = hO();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var pO = xr('<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>');

function fO(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = pO();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var mO = fe('<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost">✕</button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>'),
  _O = fe('<span class="center-absolute absolute"><!></span>'),
  gO = (d, a, h) => {
    var y;
    (y = x(a)) == null || y.resolve(!1), x(h).close()
  },
  vO = (d, a, h) => {
    var y;
    (y = x(a)) == null || y.resolve(!0), x(h).close()
  },
  yO = fe('<dialog class="modal"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><h3 class="mb-2 text-lg font-bold"> </h3> <p class="text-sm opacity-80"><!></p> <div class="mt-5 flex justify-end gap-2"><button class="btn btn-ghost"> </button> <button class="btn btn-primary"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function xO(d, a) {
  Ir(a, !0);
  let h = Tt(a, "open", 15),
    y = rt(null),
    k = rt(di({
      name: xv(),
      prev: 1e3,
      new: 1e5
    }));
  An(() => {
    const Zt = Ft => {
      Ft.key === "Escape" && h(!1)
    };
    return document.addEventListener("keydown", Zt), () => document.removeEventListener("keydown", Zt)
  });
  const E = {
      id: 70,
      product: Bi.products[70]
    },
    b = {
      id: 80,
      product: Bi.products[80]
    },
    s = {
      product: Bi.products[120]
    };
  let F = rt(null),
    O = rt(null),
    G = rt("");
  async function X(Zt) {
    return x(F).showModal(), re(O, Um.withResolvers(), !0), re(G, Zt, !0), x(O).promise
  }
  var Q = yO(),
    W = pt(Q),
    de = P(W),
    _e = P(de);
  {
    var Ae = Zt => {
      var Ft = mO(),
        cr = P(Ft),
        ur = P(cr),
        Er = P(ur);
      Sy(Er, {
        class: "size-8"
      });
      var dr = B(Er, 2),
        pr = P(dr, !0);
      I(dr);
      var vr = B(dr, 2),
        Vr = P(vr);
      {
        let xt = ht(() => {
          var It;
          return ((It = wt.data) == null ? void 0 : It.droplets) ?? 0
        });
        m0(Vr, {
          get value() {
            return x(xt)
          }
        })
      }
      I(vr), en(2), I(ur), I(cr), pi(cr, () => jF);
      var qr = B(cr, 2),
        ue = P(qr),
        V = P(ue),
        U = P(V);
      cO(U, {
        class: "size-5.5",
        filled: !0
      });
      var Y = B(U, 2),
        oe = P(Y, !0);
      I(Y), I(V);
      var me = B(V, 2),
        Se = P(me, !0);
      I(me);
      var Oe = B(me, 2),
        ze = P(Oe);
      {
        const xt = Wt => {
          fO(Wt, {
            class: "text-primary size-26"
          })
        };
        let It = ht(() => sw());
        e0(ze, {
          get productId() {
            return E.id
          },
          title: Wt => iw({
            amount: E.product.items[0].amount * Wt
          }),
          get subtitle() {
            return x(It)
          },
          get unitPrice() {
            return E.product.price
          },
          get userDroplets() {
            return wt.data.droplets
          },
          onpurchasecompleted: async Wt => {
            var Qr, zr, Hr, hn;
            const Nt = (zr = (Qr = wt.data) == null ? void 0 : Qr.charges) == null ? void 0 : zr.max;
            await wt.refresh();
            const gr = (hn = (Hr = wt.data) == null ? void 0 : Hr.charges) == null ? void 0 : hn.max;
            Nt !== void 0 && gr !== void 0 && (re(k, {
              name: xv(),
              prev: Nt,
              new: gr
            }, !0), x(y).show())
          },
          icon: xt,
          $$slots: {
            icon: !0
          }
        })
      }
      var Ke = B(ze, 2);
      {
        const xt = Wt => {
          xy(Wt, {
            class: "text-primary my-3 size-20"
          })
        };
        let It = ht(() => J2());
        e0(Ke, {
          get productId() {
            return b.id
          },
          title: Wt => $3({
            amount: b.product.items[0].amount * Wt
          }),
          get subtitle() {
            return x(It)
          },
          get unitPrice() {
            return b.product.price
          },
          get userDroplets() {
            return wt.data.droplets
          },
          onpurchasecompleted: async Wt => {
            var gr, Qr, zr;
            const Nt = (Qr = (gr = wt.data) == null ? void 0 : gr.charges) == null ? void 0 : Qr.count;
            await wt.refresh(), Nt !== void 0 && (re(k, {
              name: V3(),
              prev: Math.floor(Nt),
              new: Math.floor(Nt + b.product.items[0].amount * Wt)
            }, !0), (zr = x(y)) == null || zr.show())
          },
          icon: xt,
          $$slots: {
            icon: !0
          }
        })
      }
      I(Oe), I(ue);
      var _t = B(ue, 2),
        it = P(_t),
        qt = P(it);
      Bp(qt, {
        class: "size-5.5",
        filled: !0
      });
      var we = B(qt, 2),
        Mt = P(we, !0);
      I(we), I(it);
      var Ut = B(it, 2),
        jt = P(Ut),
        fr = P(jt),
        Ur = P(fr),
        Dr = P(Ur),
        jr = P(Dr);
      _0(jr, {
        get userId() {
          return wt.data.id
        },
        get level() {
          return wt.data.level
        },
        get pictureUrl() {
          return wt.data.picture
        }
      }), I(Dr), I(Ur), I(fr);
      var $r = B(fr, 2),
        Br = P($r, !0);
      I($r);
      var Fr = B($r, 2),
        vn = P(Fr, !0);
      I(Fr);
      var bt = B(Fr, 2);
      let bn;
      var fn = P(bt),
        $n = P(fn),
        zt = P($n);
      Ep(zt, {
        class: "size-4"
      });
      var nt = B(zt);
      en(), I($n), I(fn), I(bt), I(jt), I(Ut), I(_t);
      var $t = B(_t, 2),
        Gt = P($t);
      QF(Gt, {
        promptUserConfirmation: X
      }), I($t), I(qr), I(Ft), Ze((xt, It, Wt, Nt, gr, Qr, zr, Hr, hn) => {
        ce(pr, xt), ce(oe, It), ce(Se, Wt), ce(Mt, Nt), ce(Br, gr), ce(vn, Qr), nr(bt, "data-tip", zr), bn = Or(bt, 1, "", null, bn, Hr), $n.disabled = wt.data.droplets < s.product.price, ce(nt, ` ${hn??""} `)
      }, [() => y0(), () => K2(), () => tw(), () => Xw(), () => uw(), () => pw(), () => Dp(), () => ({
        tooltip: wt.data.droplets < s.product.price
      }), () => s.product.price.toLocaleString("en-US")]), Ni(2, Ft, () => va), Z(Zt, Ft)
    };
    Be(_e, Zt => {
      wt.data && h() && Zt(Ae)
    })
  }
  I(de);
  var xe = B(de, 2),
    Ie = P(xe),
    Pe = P(Ie, !0);
  I(Ie), I(xe), I(W), pi(W, () => Zt => {
    Kr(() => {
      h() ? Zt.show() : Zt.close()
    })
  });
  var De = B(W, 2),
    $e = P(De),
    tt = P($e),
    Ve = P(tt),
    Re = P(Ve, !0);
  I(Ve);
  var Ue = B(Ve, 2),
    Ce = P(Ue),
    We = P(Ce),
    Je = B(We),
    Ge = P(Je);
  I(Je), I(Ce);
  var Ee = B(Ce, 2),
    mt = P(Ee);
  dO(mt, {
    class: "size-5"
  }), I(Ee);
  var K = B(Ee, 2),
    ee = P(K, !0);
  I(K), I(Ue);
  var le = B(Ue, 2),
    ae = P(le),
    ke = P(ae),
    qe = B(ke);
  Ju(qe, () => x(k).new, Zt => {
    var Ft = _O(),
      cr = P(Ft);
    m_(cr, {}), I(Ft), Z(Zt, Ft)
  }), I(ae), I(le), I(tt), I($e);
  var lt = B($e, 2),
    ot = P(lt),
    dt = P(ot, !0);
  I(ot), I(lt), I(De), us(De, Zt => re(y, Zt), () => x(y));
  var Pt = B(De, 2),
    Lt = P(Pt),
    He = P(Lt),
    ut = P(He, !0);
  I(He);
  var gt = B(He, 2),
    St = P(gt);
  Pp(St, () => $P({
    country: x(G)
  })), I(gt);
  var vt = B(gt, 2),
    Ct = P(vt);
  Ct.__click = [gO, O, F];
  var At = P(Ct, !0);
  I(Ct);
  var Bt = B(Ct, 2);
  Bt.__click = [vO, O, F];
  var Vt = P(Bt, !0);
  I(Bt), I(vt), I(Lt);
  var Ot = B(Lt, 2),
    Dt = P(Ot),
    Rt = P(Dt, !0);
  I(Dt), I(Ot), I(Pt), us(Pt, Zt => re(F, Zt), () => x(F)), Ze((Zt, Ft, cr, ur, Er, dr, pr) => {
    ce(Pe, Zt), ce(Re, x(k).name), ce(We, `${x(k).prev??""} `), ce(Ge, `(+${x(k).new-x(k).prev})`), ce(ee, x(k).new), ce(ke, `${Ft??""} `), ce(dt, cr), ce(ut, ur), ce(At, Er), ce(Vt, dr), ce(Rt, pr)
  }, [() => cs(), () => cs(), () => cs(), () => VP(), () => Zh(), () => v0(), () => cs()]), Zn("close", W, () => h(!1)), Z(d, Q), Pr()
}
Ln(["click"]);
var bO = xr('<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>');

function wO(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = bO();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var CO = xr('<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>');

function TO(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = CO();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var SO = xr('<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>');

function IO(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = SO();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var PO = xr('<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>');

function kO(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = PO();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var MO = xr('<svg><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"></path></svg>');

function AO(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = MO();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}
var EO = xr('<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>');

function zO(d, a) {
  let h = sr(a, ["$$slots", "$$events", "$$legacy"]);
  var y = EO();
  lr(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...h
  })), Z(d, y)
}

function cm(d) {
  const a = document.createElement("img");
  return a.src = d, new Promise((h, y) => {
    a.addEventListener("load", () => {
      h(a)
    }), a.addEventListener("error", k => {
      y(k)
    })
  })
}

function LO(d) {
  const a = document.createElement("canvas");
  a.width = d.naturalWidth, a.height = d.naturalHeight;
  const h = a.getContext("2d");
  return h == null || h.drawImage(d, 0, 0), a
}

function DO(d, a, h) {
  return d < a ? a : d > h ? h : d
}

function RO(d, a) {
  const h = 10 ** a;
  return Math.round(d * h) / h
}
var BO = fe('<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>', 1),
  FO = (d, a) => {
    re(a, !x(a))
  },
  OO = fe("<button><!></button>"),
  jO = async (d, a, h, y) => {
    var k;
    x(a) || re(a, await new Promise((E, b) => {
      navigator.geolocation.getCurrentPosition(s => {
        E(s)
      }, s => {
        b(s)
      })
    })), x(a) && (zo({
      lat: x(a).coords.latitude,
      lng: x(a).coords.longitude
    }, x(h)), (k = x(y)) == null || k.flyTo({
      center: {
        lat: x(a).coords.latitude,
        lng: x(a).coords.longitude
      },
      zoom: 16.5
    }))
  }, NO = fe('<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>'), ZO = fe('<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>'), VO = (d, a, h, y) => {
    var k;
    re(a, !0), x(h) && zo((k = x(h)) == null ? void 0 : k.getCenter(), x(y))
  }, qO = fe('<button class="btn btn-primary shadow-xl"> </button>'), UO = fe('<a class="badge badge-secondary absolute -left-2 top-0 -translate-x-full translate-y-1/2 font-semibold" target="_blank"> </a>'), $O = fe('<span class="tooltip badge badge-secondary tooltip-left absolute -left-2 top-0 -translate-x-full translate-y-1/2 font-semibold">CL</span>'), GO = (d, a) => {
    re(a, !x(a))
  }, WO = fe('<button class="btn btn-square shadow-md"><!></button>'), HO = fe('<div class="relative"><!> <!></div> <!>', 1), JO = (d, a, h, y) => {
    var E;
    re(a, !0);
    const k = (E = x(h)) == null ? void 0 : E.getCenter();
    k && zo(k, x(y))
  }, XO = fe('<button class="btn btn-square shadow-md"><!></button>'), YO = (d, a) => {
    re(a, !0)
  }, KO = fe('<button class="btn btn-square relative shadow-md"><!></button>'), QO = (d, a) => {
    re(a, !0)
  }, ej = fe('<div class="flex flex-col items-center gap-3"><!> <!> <!> <button class="btn btn-square relative shadow-md"><!></button></div>'), tj = (d, a) => {
    re(a, !x(a))
  }, rj = fe('<div class="flex flex-col gap-3"><button><!></button></div>'), nj = (d, a) => {
    re(a, !0)
  }, ij = fe('<button class="btn btn-sm btn-circle"><!></button>'), aj = (d, a) => {
    var h;
    (h = x(a)) == null || h.zoomIn()
  }, oj = (d, a) => {
    var h;
    (h = x(a)) == null || h.zoomOut()
  }, sj = (d, a) => {
    re(a, !0)
  }, lj = (d, a) => {
    re(a, {
      name: "selectArea"
    }, !0)
  }, cj = fe('<div class="tooltip tooltip-right"><div class="tooltip-content">Select Area <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button class="btn btn-sm btn-circle" title="Select area"><!></button></div>'), uj = fe('<button class="btn btn-sm btn-circle"><!></button>'), hj = () => {
    window.location.replace(ri.url.origin)
  }, dj = fe('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>'), pj = (d, a) => {
    x(a) && wl.goToPrev(x(a))
  }, fj = fe('<button class="btn btn-sm btn-circle"><!></button>'), mj = fe('<div class="btn btn-sm btn-error w-max cursor-auto text-nowrap text-xs sm:text-base"><!> </div>'), _j = (d, a, h) => {
    var y;
    (y = x(a)) == null || y.flyTo({
      center: x(a).getCenter(),
      zoom: h
    })
  }, gj = fe('<button class="btn sm:btn-lg duration text-nowrap text-xs transition-opacity sm:text-base"><!> </button>'), vj = fe("<span></span>"), yj = fe('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><!></div></div>'), xj = fe('<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>'), bj = fe('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-xl"><!></div>'), wj = (d, a) => {
    re(a, {
      name: "mainMenu"
    }, !0)
  }, Cj = fe('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pb-2 pt-1"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>'), Tj = fe('<div class="disable-pinch-zoom relative h-full overflow-hidden svelte-6wmtgk"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <div><button title="Halloween" class="btn btn-sm btn-circle items-center"><img alt="Pumpkin head" class="pixelated size-5"/></button></div> <!> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>', 1);

function _N(d, a) {
  Ir(a, !0);
  const h = Xf,
    y = Hx,
    k = new Zs(y),
    E = h - .4,
    b = lk(ri.url),
    s = b.season ?? gv,
    F = new Map;
  let O = rt(void 0),
    G = rt(14.5),
    X = rt(!1);
  const Q = ht(() => {
    var ft;
    return ((ft = wt.data) == null ? void 0 : ft.id) === 401
  });
  let W = rt(!1),
    de = rt(di(b.select && b.pos ? {
      name: "pixelSelected",
      latLon: [b.pos.lat, b.pos.lng]
    } : {
      name: "mainMenu"
    }));
  An(() => {
    Ie().then(er => re(O, er));
    let ft = [0, 0];

    function Kt(er) {
      var Cn;
      if (x(O) && x(G) > h + 1) {
        const {
          lat: Rn,
          lng: Qn
        } = x(O).unproject([er.clientX, er.clientY]), En = k.latLonToPixels(Rn, Qn, h), kr = Math.floor(En[0]), Ai = Math.floor(En[1]);
        if (ft[0] !== kr || ft[1] !== Ai) {
          const br = k.latLonToPixelBoundsLatLon(Rn, Qn, h),
            ir = a_(br, !0);
          (Cn = x(O).getSource($e)) == null || Cn.setCoordinates(ir), ft = [kr, Ai]
        }
      }
    }
    return window.addEventListener("mousemove", Kt), () => {
      var er;
      (er = x(O)) == null || er.remove(), window.removeEventListener("mousemove", Kt), xe && clearInterval(xe), um()
    }
  }), Cl(() => [Zi.theme], () => {
    if (x(O)) {
      Ae = !1;
      const ft = _e(Zi.theme);
      x(O).setStyle(ft)
    }
  });

  function _e(ft) {
    return ft === "halloween" ? X6 : `https://maps.wplace.live/styles/${ft==="custom-winter"?"liberty":"fiord"}`
  }
  let Ae = !1,
    xe;
  async function Ie() {
    const ft = b.pos ? {
      ...b.pos,
      zoom: x(G)
    } : await K6();
    b.zoom !== void 0 && (ft.zoom = b.zoom);
    const Kt = await new Promise(En => {
        const kr = new Kd.Map({
          style: _e(Zi.theme),
          center: ft,
          zoom: ft.zoom,
          container: "map",
          dragRotate: !1,
          doubleClickZoom: !1,
          pitch: 0,
          maxPitch: 0,
          attributionControl: !1
        });
        kr.touchZoomRotate.disableRotation(), kr.on("styledata", Ai => {
          Ae || (Zi.theme === "custom-winter" && (kr.setLayoutProperty("poi_transit", "visibility", "none"), kr.setLayoutProperty("poi_r20", "visibility", "none"), kr.setLayoutProperty("poi_r7", "visibility", "none"), kr.setLayoutProperty("poi_r1", "visibility", "none"), kr.setLayoutProperty("building", "visibility", "none"), kr.setLayoutProperty("building-3d", "visibility", "none"), kr.setLayoutProperty("landuse_pitch", "visibility", "none"), kr.setLayoutProperty("landuse_hospital", "visibility", "none"), kr.setLayoutProperty("landuse_school", "visibility", "none"), kr.setLayoutProperty("landuse_residential", "visibility", "none"), kr.setLayoutProperty("waterway_tunnel", "visibility", "none"), kr.setFilter("water", ["all", ["!=", "brunnel", "tunnel"],
            ["!=", "class", "swimming_pool"]
          ])), De(kr), Ue(), Ae = !0)
        }), kr.on("style.load", () => {
          En(kr)
        })
      }),
      er = Bi.refreshIntervalMs;

    function Cn() {
      let En = x(G) > h + 1.5 ? er : 2.5 * er;
      try {
        document.visibilityState === "visible" && De(Kt)
      } finally {
        setTimeout(Cn, En)
      }
    }
    xe = setTimeout(Cn, er), Kt.on("load", () => {
      b.discordLinked && (Ar.success(YS()), ri.url.searchParams.delete("discord-linked"), mp(ri.url.toString())), b.twitchMigration && (Ar.success(O4()), ri.url.searchParams.delete("twitch-migration"), mp(ri.url.toString()))
    });
    let Rn = x(G);
    Kt.on("zoom", () => {
      re(G, Kt.getZoom(), !0);
      const En = RO(x(G), 1);
      En != Rn && (x(K) && x(K).setOpacity(ee(Rn)), Rn = En)
    });
    let Qn = "default";
    return Kt.on("dragstart", () => {
      const En = Kt.getCanvas();
      Qn = En.style.cursor, En.style.cursor = "move"
    }), Kt.on("dragend", () => {
      Kt.getCanvas().style.cursor = Qn
    }), Kt.on("mouseout", () => {
      Ce()
    }), Kt.on("click", async En => {
      var rn;
      const kr = En.lngLat.lat,
        Ai = En.lngLat.lng,
        br = [kr, Ai];
      if (x(de).name === "paintingPixel" || x(de).name === "selectArea") return;
      if (x(de).name === "selectHq") {
        x(de).hq = br, (rn = x(le)) == null || rn.clearAndPlace(br);
        return
      }
      const ir = Kt.getZoom();
      if (ir < E) {
        Ar.info(vI());
        return
      }
      zo({
        lat: kr,
        lng: Ai
      }, ir), re(de, {
        name: "pixelSelected",
        latLon: br
      }, !0)
    }), Kt
  }
  const Pe = "pixel-art-layer";

  function De(ft) {
    const Kt = window.innerWidth,
      er = `${jx}/s${gv}/tiles/{x}/{y}.png`;
    if (F.clear(), !ft.style) return;
    ft.getSource(Pe) ? ft.refreshTiles(Pe) : ft.addSource(Pe, {
      type: "raster",
      tiles: [er],
      minzoom: h,
      maxzoom: h,
      tileSize: Kt > 640 ? 550 : 400
    }), ft.getLayer(Pe) || ft.addLayer({
      id: Pe,
      type: "raster",
      source: Pe,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": x(Je)
      }
    })
  }
  const $e = "pixel-hover",
    tt = 1e-5,
    Ve = [
      [0, 0],
      [tt, 0],
      [tt, -tt],
      [0, -tt]
    ],
    Re = .4;
  async function Ue() {
    var ft, Kt, er, Cn;
    if (!((ft = x(O)) != null && ft.getSource($e))) {
      const Rn = LO(await cm(J6));
      (Kt = x(O)) == null || Kt.addSource($e, {
        type: "canvas",
        canvas: Rn,
        coordinates: Ve
      })
    }(er = x(O)) != null && er.getLayer($e) || (Cn = x(O)) == null || Cn.addLayer({
      id: $e,
      type: "raster",
      source: $e,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": Re
      }
    })
  }

  function Ce() {
    var ft, Kt;
    (Kt = (ft = x(O)) == null ? void 0 : ft.getSource($e)) == null || Kt.setCoordinates(Ve)
  }
  let We = rt(di(b.opaque ?? !0)),
    Je = ht(() => x(We) ? 1 : .1);
  Kr(() => {
    var ft;
    (ft = x(O)) != null && ft.getLayer(Pe) && x(O).setPaintProperty(Pe, "raster-opacity", x(Je))
  });
  let Ge = rt(void 0),
    Ee = rt(void 0),
    mt = rt(void 0);
  An(() => (navigator.permissions.query({
    name: "geolocation"
  }).then(ft => {
    ft.state === "granted" && re(mt, navigator.geolocation.watchPosition(Kt => {
      re(Ge, Kt)
    }, Kt => {
      re(Ee, Kt)
    }, {
      enableHighAccuracy: !1,
      maximumAge: 1e3,
      timeout: 6e3
    }), !0)
  }), () => {
    x(mt) && navigator.geolocation.clearWatch(x(mt))
  }));
  let K = rt(void 0);
  Cl(() => [x(Ge), x(O)], () => {
    var ft, Kt;
    if (x(Ge) && x(O)) {
      const er = {
          lat: x(Ge).coords.latitude,
          lng: x(Ge).coords.longitude
        },
        Cn = ee(x(G));
      if (!x(K)) {
        const Rn = document.createElement("div");
        Rn.classList.add("maplibregl-user-location-dot"), Rn.classList.add("cursor-auto"), re(K, new Kd.Marker({
          element: Rn,
          opacity: Cn
        }).setLngLat(er).addTo(x(O)))
      }(Kt = (ft = x(K)) == null ? void 0 : ft.setLngLat(er)) == null || Kt.setOpacity(Cn)
    }
  });

  function ee(ft) {
    return ft < h ? "1.0" : DO((ft - h) * .2, .5, 1).toFixed(2)
  }
  let le = rt(void 0);
  Kr(() => {
    var ft;
    x(O) && ((ft = bl(() => x(le))) == null || ft.clear(), cm(Cv).then(Kt => {
      re(le, new Sv({
        id: "select-crosshair",
        map: x(O),
        tileSize: y,
        zoom: h,
        img: Kt,
        markerFn: () => {
          const er = new Kd.Marker({
            color: "#0069ff"
          });
          return er.addClassName("z-20"), er
        }
      }))
    }))
  });
  let ae = rt(void 0);
  Kr(() => {
    var ft;
    x(O) && ((ft = bl(() => x(le))) == null || ft.clear(), cm(Cv).then(Kt => {
      re(ae, new Sv({
        id: "paint-crosshair",
        map: x(O),
        tileSize: y,
        zoom: h,
        img: Kt
      }))
    }))
  });
  let ke = rt(!1),
    qe = rt(!1),
    lt = rt(!1),
    ot = rt(!!b.newUser),
    dt = rt(!1),
    Pt = rt(!!b.alliance),
    Lt = rt(!1);
  const He = "halloween-2025-popup";
  let ut = rt(!1);
  Kr(() => {
    const ft = localStorage.getItem(He),
      Kt = Date.now() > new Date("2025-11-03T00:00:00Z").getTime();
    wt.data && !ft && !Kt && (re(ut, !0), localStorage.setItem(He, "true"))
  });
  let gt = rt(!1),
    St = rt(di(ri.url)),
    vt = rt(di({
      cityId: 0,
      countryId: 1,
      id: 0,
      name: "None",
      number: 1
    })),
    Ct = rt(!1);
  const At = "view-rules";
  let Bt = !1;
  Kr(() => {
    wt.data && (!Bt && wt.data.pixelsPainted > 1 && (localStorage.getItem(At) || (re(Ct, !0), localStorage.setItem(At, "true"))), Bt = !0)
  });
  let Vt = rt(!1);
  Kr(() => {
    var ft;
    re(Vt, !!((ft = wt.data) != null && ft.needsPhoneVerification))
  });
  let Ot = rt([]),
    Dt = ht(() => x(G) < E ? "1.0" : x(G) < E + 2 ? "0.5" : "0.3");
  Kr(() => {
    var Kt;
    const ft = (Kt = wt.data) == null ? void 0 : Kt.favoriteLocations;
    if (ft && x(O)) {
      for (const er of bl(() => x(Ot))) er.remove();
      re(Ot, ft.map(er => {
        const Cn = document.createElement("div");
        Cn.classList.add("text-yellow-400"), Cn.classList.add("cursor-pointer"), Cn.classList.add("z-10"), Cn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`;
        const Rn = {
          lat: er.latitude,
          lng: er.longitude
        };
        return Cn.addEventListener("click", En => {
          En.stopPropagation(), Rt([er.latitude, er.longitude])
        }), new Kd.Marker({
          element: Cn,
          opacity: x(Dt)
        }).setLngLat(Rn).addTo(x(O))
      }))
    }
  });

  function Rt(ft) {
    var er;
    const Kt = {
      lat: ft[0],
      lng: ft[1]
    };
    (er = x(O)) == null || er.flyTo({
      center: Kt,
      zoom: Math.max(x(G), 15)
    }), zo(Kt, x(G)), re(de, {
      name: "pixelSelected",
      latLon: [Kt.lat, Kt.lng]
    }, !0)
  }
  Kr(() => {
    if (x(de).name === "paintingPixel")
      for (const ft of x(Ot)) ft.addClassName("hidden");
    else
      for (const ft of x(Ot)) ft.removeClassName("hidden"), ft.setOpacity(x(Dt))
  });
  let Zt = Number.MAX_VALUE;
  Kr(() => {
    if (wt.charges !== void 0 && wt.data) {
      const ft = wt.data.charges.max,
        Kt = wt.charges;
      Zt < ft && Kt >= ft && Vi.notification1.play(), Zt = wt.charges
    }
  });
  let Ft = rt(!1),
    cr = Date.now();
  An(() => {
    const ft = sk(),
      Kt = () => {
        var Cn;
        if (!document.hidden && Date.now() - cr > 30 * Sc.min) {
          if (ft) {
            const Qn = (Cn = x(O)) == null ? void 0 : Cn.getCenter();
            Qn && zo(Qn, x(G)), window.location.replace(ri.url.origin)
          } else wt.refresh();
          cr = Date.now()
        }
      };
    return document.addEventListener("visibilitychange", Kt), () => document.removeEventListener("visibilitychange", Kt)
  }), An(() => {
    function ft() {
      nn.online = !0
    }
    window.addEventListener("online", ft);

    function Kt() {
      nn.online = !1
    }
    return window.addEventListener("offline", Kt), () => {
      window.removeEventListener("online", ft), window.removeEventListener("offline", Kt)
    }
  }), Kr(() => {
    if (!nn.online) {
      const ft = setInterval(() => {
        nn.health().then(() => {
          nn.online = !0, !wt.data && !wt.loading && wt.refresh()
        })
      }, 5e3);
      return () => {
        clearInterval(ft)
      }
    }
  }), An(() => {
    function ft(Kt) {
      Kt.data.type && x(O) && De(x(O))
    }
    return navigator.serviceWorker.addEventListener("message", ft), () => {
      navigator.serviceWorker.removeEventListener("message", ft)
    }
  });
  let ur = rt(!1),
    Er = rt("report-user"),
    dr = rt(void 0),
    pr = rt(void 0),
    vr = rt(void 0),
    Vr = rt(0);
  const qr = ht(() => {
    var ft;
    return ja((ft = wt.data) == null ? void 0 : ft.role, ["admin", "global_moderator", "moderator"])
  });
  let ue = rt(!1);
  const V = ht(() => {
    var ft;
    return ja((ft = wt.data) == null ? void 0 : ft.role, ["admin"])
  });
  let U = "halloween",
    Y = rt(!1),
    oe = rt(!1);
  var me = Tj();
  Zn("keypress", Gm, ft => {
    switch (ft.code) {
      case "KeyC":
        if (!x(qr) || x(de).name === "paintingPixel") return;
        re(de, {
          name: "selectArea"
        }, !0);
        break
    }
  }), Bx(ft => {
    var Kt = BO();
    Rx.title = "Wplace - Paint the world", en(6), Z(ft, Kt)
  });
  var Se = pt(me);
  {
    const ft = br => {
        var ir = OO();
        ir.__click = [FO, We];
        var rn = P(ir);
        {
          let sn = ht(() => !x(We));
          by(rn, {
            class: "size-5",
            get filled() {
              return x(sn)
            }
          })
        }
        I(ir), Ze(sn => {
          nr(ir, "title", sn), Or(ir, 1, ls({
            "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
            "text-base-content/80": x(We),
            "btn-primary btn-soft": !x(We)
          }))
        }, [() => b0()]), Z(br, ir)
      },
      Kt = br => {
        var ir = ZO();
        ir.__click = [jO, Ge, G, O];
        var rn = P(ir);
        {
          var sn = cn => {
              IO(cn, {
                class: "size-5.5 fill-blue-800"
              })
            },
            yn = cn => {
              var Jr = NO(),
                Jn = P(Jr);
              TO(Jn, {
                class: "size-5.5 fill-red-400"
              }), en(2), I(Jr), Z(cn, Jr)
            };
          Be(rn, cn => {
            x(Ge) ? cn(sn) : cn(yn, !1)
          })
        }
        I(ir), Ze(cn => nr(ir, "title", cn), [() => p2()]), Z(br, ir)
      };
    var Oe = B(P(Se), 2);
    let er;
    var ze = P(Oe);
    let Cn;
    var Ke = P(ze);
    {
      var _t = br => {
          var ir = qO();
          ir.__click = [VO, ke, O, G];
          var rn = P(ir, !0);
          I(ir), Ze(sn => ce(rn, sn), [() => zb()]), Z(br, ir)
        },
        it = br => {
          var ir = or(),
            rn = pt(ir);
          {
            var sn = yn => {
              var cn = HO(),
                Jr = pt(cn),
                Jn = P(Jr);
              {
                var Bn = mr => {
                    var _r = UO(),
                      Vn = P(_r, !0);
                    I(_r), Ze(Wr => {
                      var jn;
                      nr(_r, "href", ((jn = wt.data) == null ? void 0 : jn.role) === "admin" ? `${ri.url.origin}/admin/dashboard` : `${ri.url.origin}/moderation`), ce(Vn, Wr)
                    }, [() => {
                      var Wr;
                      return s0[((Wr = wt.data) == null ? void 0 : Wr.role) ?? "moderator"].toUpperCase()
                    }]), Z(mr, _r)
                  },
                  xn = mr => {
                    var _r = or(),
                      Vn = pt(_r);
                    {
                      var Wr = jn => {
                        var qn = $O();
                        Ze(oi => nr(qn, "data-tip", oi), [() => z4()]), Z(jn, qn)
                      };
                      Be(Vn, jn => {
                        var qn;
                        ja((qn = wt.data) == null ? void 0 : qn.role, ["community_leader"]) && jn(Wr)
                      }, !0)
                    }
                    Z(mr, _r)
                  };
                Be(Jn, mr => {
                  var _r;
                  ja((_r = wt.data) == null ? void 0 : _r.role, ["admin", "moderator", "global_moderator"]) ? mr(Bn) : mr(xn, !1)
                })
              }
              var pn = B(Jn, 2);
              dB(pn, {
                get user() {
                  return wt
                },
                onlogout: () => {
                  re(de, {
                    name: "mainMenu"
                  }, !0)
                },
                onbanappeal: () => {
                  re(Y, !0)
                },
                onnotificationclick: () => {
                  re(oe, !0)
                }
              }), I(Jr);
              var Xr = B(Jr, 2);
              {
                var On = mr => {
                  var _r = WO();
                  _r.__click = [GO, ue];
                  var Vn = P(_r);
                  {
                    var Wr = qn => {
                        var oi = Ii("❌");
                        Z(qn, oi)
                      },
                      jn = qn => {
                        var oi = Ii("🎃");
                        Z(qn, oi)
                      };
                    Be(Vn, qn => {
                      x(ue) ? qn(Wr) : qn(jn, !1)
                    })
                  }
                  I(_r), Ze(() => nr(_r, "title", x(ue) ? "Ocultar abóboras" : "Mostrar abóboras")), Z(mr, _r)
                };
                Be(Xr, mr => {
                  x(V) && mr(On)
                })
              }
              Ni(3, Jr, () => va, () => ({
                duration: 150
              })), Z(yn, cn)
            };
            Be(rn, yn => {
              wt.data && x(O) && x(de).name !== "paintingPixel" && yn(sn)
            }, !0)
          }
          Z(br, ir)
        };
      Be(Ke, br => {
        !wt.loading && !wt.data ? br(_t) : br(it, !1)
      })
    }
    var qt = B(Ke, 2);
    {
      var we = br => {
          var ir = ej(),
            rn = P(ir);
          {
            var sn = xn => {
              var pn = XO();
              pn.__click = [JO, qe, O, G];
              var Xr = P(pn);
              Sy(Xr, {
                class: "size-5"
              }), I(pn), Ze(On => nr(pn, "title", On), [() => y0()]), Z(xn, pn)
            };
            Be(rn, xn => {
              wt.data && xn(sn)
            })
          }
          var yn = B(rn, 2);
          {
            var cn = xn => {
              var pn = KO();
              pn.__click = [YO, Pt];
              var Xr = P(pn);
              Fp(Xr, {
                class: "size-5"
              }), I(pn), Ze(On => nr(pn, "title", On), [() => Lp()]), Z(xn, pn)
            };
            Be(yn, xn => {
              wt.data && xn(cn)
            })
          }
          var Jr = B(yn, 2);
          yB(Jr, {
            get map() {
              return x(O)
            },
            get season() {
              return s
            }
          });
          var Jn = B(Jr, 2);
          Jn.__click = [QO, lt];
          var Bn = P(Jn);
          ry(Bn, {
            class: "size-5"
          }), I(Jn), I(ir), Ze(xn => nr(Jn, "title", xn), [() => Qm()]), Ni(3, ir, () => va, () => ({
            duration: 150
          })), Z(br, ir)
        },
        Mt = br => {
          var ir = or(),
            rn = pt(ir);
          {
            var sn = yn => {
              var cn = rj(),
                Jr = P(cn);
              let Jn;
              Jr.__click = [tj, X];
              var Bn = P(Jr);
              {
                var xn = Xr => {
                    Vm(Xr, {
                      class: "size-5"
                    })
                  },
                  pn = Xr => {
                    vp(Xr, {
                      class: "size-5"
                    })
                  };
                Be(Bn, Xr => {
                  x(X) ? Xr(xn) : Xr(pn, !1)
                })
              }
              I(Jr), I(cn), Ze((Xr, On) => {
                nr(Jr, "title", Xr), Jn = Or(Jr, 1, "btn btn-square not-touchscreen:hidden shadow-md", null, Jn, On)
              }, [() => x(X) ? Zb() : Ub(), () => ({
                "btn-primary": x(X)
              })]), Ni(1, cn, () => va, () => ({
                delay: 150,
                duration: 150
              })), Z(yn, cn)
            };
            Be(rn, yn => {
              x(O) && x(de).name === "paintingPixel" && yn(sn)
            }, !0)
          }
          Z(br, ir)
        };
      Be(qt, br => {
        x(O) && x(de).name !== "paintingPixel" ? br(we) : br(Mt, !1)
      })
    }
    I(ze), I(Oe);
    var Ut = B(Oe, 2);
    let Rn;
    var jt = P(Ut);
    {
      var fr = br => {
        var ir = ij();
        ir.__click = [nj, dt];
        var rn = P(ir);
        wO(rn, {
          class: "size-3.5"
        }), I(ir), Ze(sn => nr(ir, "title", sn), [() => Wb()]), Z(br, ir)
      };
      Be(jt, br => {
        x(de).name !== "paintingPixel" && br(fr)
      })
    }
    var Ur = B(jt, 2),
      Dr = P(Ur);
    Dr.__click = [aj, O];
    var jr = B(Dr, 2);
    jr.__click = [oj, O], I(Ur);
    var $r = B(Ur, 2),
      Br = P($r);
    Br.__click = [sj, ut];
    var Fr = P(Br);
    I(Br), I($r);
    var vn = B($r, 2);
    {
      var bt = br => {
        var ir = cj(),
          rn = B(P(ir), 2);
        rn.__click = [lj, de];
        var sn = P(rn);
        nh(sn, {
          class: "size-4"
        }), I(rn), I(ir), Z(br, ir)
      };
      Be(vn, br => {
        x(de).name !== "paintingPixel" && x(qr) && br(bt)
      })
    }
    var bn = B(vn, 2);
    {
      var fn = br => {
        var ir = uj(),
          rn = P(ir);
        zO(rn, {
          class: "size-4",
          onclick: () => {
            re(W, !x(W))
          }
        }), I(ir), Ze(sn => nr(ir, "title", sn), [() => Lw()]), Z(br, ir)
      };
      Be(bn, br => {
        x(Q) && br(fn)
      })
    }
    var $n = B(bn, 2);
    {
      var zt = br => {
        var ir = dj();
        ir.__click = [hj];
        var rn = P(ir);
        Cb(rn, {
          class: "size-3"
        }), I(ir), Ze(sn => nr(ir, "title", sn), [() => Sb()]), Z(br, ir)
      };
      Be($n, br => {
        x(de).name !== "paintingPixel" && br(zt)
      })
    }
    var nt = B($n, 2);
    {
      var $t = br => {
        var ir = fj();
        ir.__click = [pj, O];
        var rn = P(ir);
        AO(rn, {
          class: "size-3"
        }), I(ir), Ze((sn, yn) => {
          nr(ir, "title", sn), ir.disabled = yn
        }, [() => r2(), () => !wl.hasPrev()]), Ni(1, ir, () => va, () => ({
          delay: 1e3,
          duration: 300
        })), Ni(2, ir, () => va, () => ({
          duration: 300
        })), Z(br, ir)
      };
      Be(nt, br => {
        wl.hasPrev() && x(de).name !== "paintingPixel" && br($t)
      })
    }
    I(Ut);
    var Gt = B(Ut, 2);
    let Qn;
    var xt = P(Gt);
    {
      var It = br => {
        var ir = mj(),
          rn = P(ir);
        Tb(rn, {
          class: "size-5"
        });
        var sn = B(rn);
        I(ir), Ze(yn => ce(sn, ` ${yn??""}`), [() => a2()]), Ni(1, ir, () => va, () => ({
          duration: 1e3
        })), Ni(2, ir, () => va), Z(br, ir)
      };
      Be(xt, br => {
        nn.online || br(It)
      })
    }
    var Wt = B(xt, 2);
    {
      var Nt = br => {
        var ir = gj();
        ir.__click = [_j, O, h];
        var rn = P(ir);
        kO(rn, {
          class: "size-5"
        });
        var sn = B(rn);
        I(ir), Ze(yn => ce(sn, ` ${yn??""}`), [() => l2()]), Ni(3, ir, () => va, () => ({
          duration: 300
        })), Z(br, ir)
      };
      Be(Wt, br => {
        x(G) < E && br(Nt)
      })
    }
    I(Gt);
    var gr = B(Gt, 2);
    let En;
    var Qr = P(gr);
    ft(Qr), I(gr);
    var zr = B(gr, 2);
    let kr;
    var Hr = P(zr);
    {
      var hn = br => {
          iy(br, {
            class: "z-30",
            onclick: () => {
              var ir;
              (ir = wt.data) != null && ir.needsPhoneVerification ? (re(Vt, !0), Ar.warning(yv())) : wt.charges !== void 0 && wt.charges < 1 ? Ar.warning(Uz, {
                icon: Xu
              }) : x(O) && wt.data ? (Vi.smallDropplet.play(), re(de, {
                name: "paintingPixel"
              }, !0)) : (re(ke, !0), x(O) && zo(x(O).getCenter(), x(G)))
            },
            get disabled() {
              return wt.loading
            },
            get loading() {
              return wt.loading
            },
            get charges() {
              return wt.charges
            }
          })
        },
        Yt = br => {
          var ir = vj();
          Z(br, ir)
        };
      Be(Hr, br => {
        x(de).name === "mainMenu" ? br(hn) : br(Yt, !1)
      })
    }
    I(zr);
    var tn = B(zr, 2);
    let Ai;
    var an = P(tn);
    Kt(an), I(tn);
    var ln = B(tn, 2);
    {
      var Pi = br => {
        var ir = or(),
          rn = pt(ir);
        {
          var sn = cn => {
              var Jr = yj(),
                Jn = P(Jr),
                Bn = P(Jn);
              OF(Bn, {
                get latLon() {
                  return x(de).latLon
                },
                get map() {
                  return x(O)
                },
                get crosshair() {
                  return x(le)
                },
                get pixelInfoCache() {
                  return F
                },
                get season() {
                  return s
                },
                get tileSize() {
                  return y
                },
                get pixelArtZoom() {
                  return h
                },
                get zoom() {
                  return x(G)
                },
                get opaquePixelArt() {
                  return x(We)
                },
                onclose: () => re(de, {
                  name: "mainMenu"
                }, !0),
                onclickshare: xn => {
                  re(St, xn, !0), re(gt, !0)
                },
                onclickpaint: ([xn, pn]) => {
                  var On, mr, _r;
                  if (!wt.data) {
                    re(ke, !0);
                    return
                  }
                  if ((On = wt.data) != null && On.needsPhoneVerification) {
                    re(Vt, !0), Ar.warning(yv());
                    return
                  }
                  if (wt.charges !== void 0 && wt.charges < 1) {
                    Ar.warning(_2());
                    return
                  }
                  const Xr = o_(k.latLonToPixelBoundsLatLon(xn, pn, h));
                  (mr = x(O)) == null || mr.flyTo({
                    center: {
                      lat: Xr[0],
                      lon: Xr[1]
                    }
                  }), re(de, {
                    name: "paintingPixel",
                    clickedLatLon: [xn, pn]
                  }, !0), (_r = x(le)) == null || _r.clear()
                },
                onclickregion: xn => {
                  re(vt, xn, !0), re(Lt, !0)
                },
                onclickmodaction: (xn, pn, Xr, On) => {
                  var _r, Vn, Wr;
                  (_r = x(O)) == null || _r.setZoom(Math.max(x(G), h + 3.5));
                  const mr = k.latLonToPixelBoundsLatLon(Xr[0], Xr[1], h);
                  (Vn = x(O)) == null || Vn.setCenter({
                    lat: mr.min[0],
                    lng: (mr.max[1] + mr.min[1]) / 2
                  }), re(dr, pn, !0), re(pr, xn, !0), re(vr, Xr, !0), re(Vr, ((Wr = x(O)) == null ? void 0 : Wr.getZoom()) ?? 0, !0), re(Er, On, !0), re(ur, !0)
                }
              }), I(Jn), I(Jr), Ni(3, Jn, () => ip, () => ({
                duration: 100
              })), Z(cn, Jr)
            },
            yn = cn => {
              var Jr = or(),
                Jn = pt(Jr);
              {
                var Bn = pn => {
                    var Xr = xj(),
                      On = P(Xr),
                      mr = P(On);
                    I7(mr, {
                      get map() {
                        return x(O)
                      },
                      get clickedLatLon() {
                        return x(de).clickedLatLon
                      },
                      get tileSize() {
                        return y
                      },
                      get tileZoom() {
                        return h
                      },
                      get season() {
                        return s
                      },
                      get zoom() {
                        return x(G)
                      },
                      get crosshair() {
                        return x(ae)
                      },
                      refreshPixelArt: () => x(O) && De(x(O)),
                      hidePixelHover: Ce,
                      hoverLayerId: $e,
                      onclose: () => {
                        re(de, {
                          name: "mainMenu"
                        }, !0), Ce()
                      },
                      get screenLocked() {
                        return x(X)
                      },
                      set screenLocked(_r) {
                        re(X, _r, !0)
                      },
                      get opaquePixelArt() {
                        return x(We)
                      },
                      set opaquePixelArt(_r) {
                        re(We, _r, !0)
                      }
                    }), I(On), I(Xr), Ni(3, On, () => ip, () => ({
                      duration: 100
                    })), Z(pn, Xr)
                  },
                  xn = pn => {
                    var Xr = or(),
                      On = pt(Xr);
                    {
                      var mr = Vn => {
                          var Wr = bj(),
                            jn = P(Wr);
                          KB(jn, {
                            get map() {
                              return x(O)
                            },
                            get tileSize() {
                              return y
                            },
                            get pixelArtZoom() {
                              return Xf
                            },
                            get season() {
                              return s
                            },
                            get crosshair() {
                              return x(ae)
                            },
                            onclose: () => {
                              re(de, {
                                name: "mainMenu"
                              }, !0), Ce()
                            }
                          }), I(Wr), Z(Vn, Wr)
                        },
                        _r = Vn => {
                          var Wr = or(),
                            jn = pt(Wr);
                          {
                            var qn = oi => {
                              var vo = Cj(),
                                Bo = P(vo),
                                Qa = P(Bo),
                                eo = P(Qa),
                                yo = P(eo),
                                Fo = P(yo);
                              wy(Fo, {
                                class: "inline size-4"
                              });
                              var ds = B(Fo);
                              I(yo);
                              var Gi = B(yo, 2);
                              Gi.__click = [wj, de];
                              var si = P(Gi);
                              Il(si, {
                                class: "size-4"
                              }), I(Gi), I(eo);
                              var to = B(eo, 2),
                                qa = P(to);
                              qa.__click = async () => {
                                var Fn;
                                if (x(de).name === "selectHq") {
                                  const ps = x(de).hq;
                                  if (ps) try {
                                    re(Ft, !0), await nn.updateAllianceHeadquarters(ps[0], ps[1]), (Fn = x(le)) == null || Fn.clear(), re(Pt, !0), re(de, {
                                      name: "mainMenu"
                                    }, !0)
                                  } catch (Oo) {
                                    Ar.error(Oo.message)
                                  } finally {
                                    re(Ft, !1)
                                  }
                                }
                              };
                              var ro = P(qa);
                              Ty(ro, {
                                class: "size-6"
                              }), I(qa), I(to), I(Qa), I(Bo), I(vo), Ze(Fn => {
                                ce(ds, ` ${Fn??""}`), qa.disabled = x(de).hq === void 0 || x(Ft)
                              }, [() => mS()]), Ni(3, Bo, () => ip, () => ({
                                duration: 100
                              })), Z(oi, vo)
                            };
                            Be(jn, oi => {
                              x(de).name === "selectHq" && oi(qn)
                            }, !0)
                          }
                          Z(Vn, Wr)
                        };
                      Be(On, Vn => {
                        x(de).name === "selectArea" ? Vn(mr) : Vn(_r, !1)
                      }, !0)
                    }
                    Z(pn, Xr)
                  };
                Be(Jn, pn => {
                  x(de).name === "paintingPixel" && x(ae) ? pn(Bn) : pn(xn, !1)
                }, !0)
              }
              Z(cn, Jr)
            };
          Be(rn, cn => {
            x(de).name === "pixelSelected" && x(le) ? cn(sn) : cn(yn, !1)
          })
        }
        Z(br, ir)
      };
      Be(ln, br => {
        x(O) && br(Pi)
      })
    }
    I(Se), Ze((br, ir, rn, sn, yn, cn, Jr, Jn, Bn) => {
      er = Or(Oe, 1, "absolute right-2 top-2 z-30", null, er, br), Cn = Or(ze, 1, "flex flex-col gap-4", null, Cn, ir), Rn = Or(Ut, 1, "absolute left-2 top-2 z-30 flex flex-col gap-3", null, Rn, rn), nr(Dr, "title", sn), nr(jr, "title", yn), nr(Fr, "src", rs), Qn = Or(Gt, 1, "absolute left-1/2 top-2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2", null, Qn, cn), En = Or(gr, 1, "absolute bottom-3 left-3 z-30", null, En, Jr), kr = Or(zr, 1, "absolute bottom-3 left-1/2 z-30 -translate-x-1/2", null, kr, Jn), Ai = Or(tn, 1, "absolute bottom-3 right-3 z-30", null, Ai, Bn)
    }, [() => ({
      hidden: x(W)
    }), () => ({
      "items-end": !wt.data,
      "items-center": wt.data
    }), () => ({
      hidden: x(W)
    }), () => Xb(), () => Qb(), () => ({
      hidden: x(W)
    }), () => ({
      hidden: x(W)
    }), () => ({
      hidden: x(W)
    }), () => ({
      hidden: x(W)
    })])
  }
  var In = B(Se, 2);
  Vz(In, {
    get open() {
      return x(ke)
    },
    set open(ft) {
      re(ke, ft, !0)
    }
  });
  var fi = B(In, 2);
  xO(fi, {
    get open() {
      return x(qe)
    },
    set open(ft) {
      re(qe, ft, !0)
    }
  });
  var Dn = B(fi, 2);
  AA(Dn, {
    get open() {
      return x(ot)
    },
    set open(ft) {
      re(ot, ft, !0)
    }
  });
  var ni = B(Dn, 2);
  HA(ni, {
    get open() {
      return x(dt)
    },
    set open(ft) {
      re(dt, ft, !0)
    }
  });
  var qi = B(ni, 2);
  aA(qi, {
    get open() {
      return x(Ct)
    },
    set open(ft) {
      re(Ct, ft, !0)
    }
  });
  var Ui = B(qi, 2);
  jz(Ui, {
    onvisitclick: ft => {
      var Kt;
      (Kt = x(O)) == null || Kt.flyTo({
        center: ft,
        zoom: Xf + 1
      }), zo(ft, x(G)), wl.push({
        pos: ft,
        zoom: x(G)
      }), re(lt, !1)
    },
    get open() {
      return x(lt)
    },
    set open(ft) {
      re(lt, ft, !0)
    }
  });
  var ki = B(Ui, 2);
  LB(ki, {
    get region() {
      return x(vt)
    },
    get open() {
      return x(Lt)
    },
    set open(ft) {
      re(Lt, ft, !0)
    }
  });
  var Mi = B(ki, 2);
  vb(Mi, {
    get open() {
      return Zi.dropletsDialogOpen
    },
    set open(ft) {
      Zi.dropletsDialogOpen = ft
    }
  });
  var $i = B(Mi, 2);
  {
    var na = ft => {
      NM(ft, {
        onhqchange: () => {
          re(de, {
            name: "selectHq"
          }, !0), re(Pt, !1)
        },
        onhqclick: Kt => {
          var er;
          (er = x(O)) == null || er.flyTo({
            center: Kt,
            zoom: Math.max(x(G), 15)
          }), re(de, {
            name: "pixelSelected",
            latLon: [Kt.lat, Kt.lng]
          }, !0), re(Pt, !1)
        },
        onlastpixelclick: Kt => {
          var er;
          (er = x(O)) == null || er.flyTo({
            center: Kt,
            zoom: Math.max(x(G), 15)
          }), re(de, {
            name: "pixelSelected",
            latLon: [Kt.lat, Kt.lng]
          }, !0), re(Pt, !1)
        },
        get open() {
          return x(Pt)
        },
        set open(Kt) {
          re(Pt, Kt, !0)
        }
      })
    };
    Be($i, ft => {
      x(O) && ft(na)
    })
  }
  var ua = B($i, 2);
  G7(ua, {
    get open() {
      return x(Vt)
    },
    set open(ft) {
      re(Vt, ft, !0)
    }
  });
  var ba = B(ua, 2);
  {
    var wa = ft => {
      KM(ft, {
        get url() {
          return x(St)
        },
        get map() {
          return x(O)
        },
        hideHover: () => {
          var Kt, er;
          (Kt = x(O)) == null || Kt.setPaintProperty($e, "raster-opacity", 0), (er = x(le)) == null || er.setCanvasOpacity(0)
        },
        showHover: () => {
          var Kt, er;
          (Kt = x(O)) == null || Kt.setPaintProperty($e, "raster-opacity", Re), (er = x(le)) == null || er.setCanvasOpacity(1)
        },
        get open() {
          return x(gt)
        },
        set open(Kt) {
          re(gt, Kt, !0)
        }
      })
    };
    Be(ba, ft => {
      x(O) && ft(wa)
    })
  }
  var Ca = B(ba, 2);
  {
    var ha = ft => {
      sb(ft, {
        get image() {
          return x(dr)
        },
        get paintedBy() {
          return x(pr).paintedBy
        },
        get latLon() {
          return x(vr)
        },
        get zoom() {
          return x(Vr)
        },
        get action() {
          return x(Er)
        },
        get open() {
          return x(ur)
        },
        set open(Kt) {
          re(ur, Kt, !0)
        }
      })
    };
    Be(Ca, ft => {
      x(pr) && x(dr) && x(vr) && ft(ha)
    })
  }
  var da = B(Ca, 2);
  {
    var pa = ft => {
      J7(ft, {
        get userData() {
          return wt.data
        },
        get open() {
          return x(Y)
        },
        set open(Kt) {
          re(Y, Kt, !0)
        }
      })
    };
    Be(da, ft => {
      wt.data && ft(pa)
    })
  }
  var go = B(da, 2);
  hL(go, {
    get open() {
      return x(oe)
    },
    set open(ft) {
      re(oe, ft, !0)
    }
  });
  var Za = B(go, 2);
  {
    var hs = ft => {
      oA(ft, {
        get map() {
          return x(O)
        },
        get season() {
          return s
        },
        eventName: U
      })
    };
    Be(Za, ft => {
      x(O) && x(ue) && ft(hs)
    })
  }
  var Va = B(Za, 2);
  PA(Va, {
    get open() {
      return x(ut)
    },
    set open(ft) {
      re(ut, ft, !0)
    }
  }), Z(d, me), Pr()
}
Ln(["click"]);
export {
  _N as component
};