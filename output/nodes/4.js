var Jx = Object.defineProperty;
var Qx = Object.getPrototypeOf;
var eb = Reflect.get;
var Dv = m => {
  throw TypeError(m)
};
var tb = (m, a, d) => a in m ? Jx(m, a, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: d
}) : m[a] = d;
var Nr = (m, a, d) => tb(m, typeof a != "symbol" ? a + "" : a, d),
  dm = (m, a, d) => a.has(m) || Dv("Cannot " + d);
var Qe = (m, a, d) => (dm(m, a, "read from private field"), d ? d.call(m) : a.get(m)),
  Zr = (m, a, d) => a.has(m) ? Dv("Cannot add the same private member more than once") : a instanceof WeakSet ? a.add(m) : a.set(m, d),
  oa = (m, a, d, x) => (dm(m, a, "write to private field"), x ? x.call(m, d) : a.set(m, d), d),
  en = (m, a, d) => (dm(m, a, "access private method"), d);
var Rv = (m, a, d) => eb(Qx(m), d, a);
import "../chunks/nL0VRVfA.js";
import {
  o as ri,
  a as rb,
  s as bi
} from "../chunks/CvD_1lQ4.js";
import {
  ad as nb,
  bm as ib,
  bB as ab,
  bo as ob,
  bC as sb,
  aY as lb,
  bD as cb,
  l as et,
  bE as Fv,
  ab as ub,
  g as _,
  o as Y,
  a_ as Xu,
  z as jr,
  b as Z,
  p as Wr,
  aa as ma,
  bF as pm,
  bG as hb,
  f as me,
  v as Ln,
  by as Zs,
  a as xt,
  d as I,
  r as C,
  s as O,
  n as wn,
  c as $r,
  t as Ue,
  F as Aa,
  w as or,
  bH as Bv,
  I as db,
  bI as pb,
  q as qi,
  m as zi,
  k as ni,
  u as ut,
  D as tn,
  bz as nh,
  C as ug,
  aF as fb,
  aE as Ov,
  aG as mb,
  M as hg,
  bJ as Ao,
  x as wa,
  bK as I0,
  e as gb,
  $ as _b
} from "../chunks/BAiyaAMH.js";
import {
  s as ce,
  c as M0
} from "../chunks/CNpnuP0x.js";
import {
  i as Ee
} from "../chunks/Cyn8dEpB.js";
import {
  h as vb
} from "../chunks/Cf7wl3d-.js";
import {
  d as _r,
  a as qr,
  s as cr,
  f as bs,
  r as za,
  g as dg,
  b as yb,
  e as Di,
  h as rh,
  c as ys,
  i as Nv
} from "../chunks/2yNgY6tU.js";
import {
  a as wl,
  t as ba
} from "../chunks/0M8Auwyd.js";
import {
  g as Rp,
  b as xb
} from "../chunks/DCV76Xxl.js";
import {
  p as Ni
} from "../chunks/CRoDH7i5.js";
import {
  g as ka,
  P as bb,
  b as A0
} from "../chunks/BvVJohsJ.js";
import {
  S as La,
  t as Xt,
  a as fn,
  u as Dt,
  p as qo,
  q as wb,
  r as Tb,
  v as Sb,
  y as Pb,
  w as Cb,
  e as Ib,
  x as Mb,
  c as Ab,
  z as kb,
  C as jv,
  P as fm,
  A as Eb
} from "../chunks/iLzBt2TM.js";
import {
  A as xi,
  p as pg,
  c as Im,
  g as mm,
  a as Lb
} from "../chunks/CuL8EIps.js";
import {
  f as Tl,
  h as Ea,
  R as k0
} from "../chunks/X3kaORp4.js";
import "../chunks/U5DskRAm.js";
import {
  e as fi,
  i as $h
} from "../chunks/BgAaA0Ce.js";
import {
  a as E0,
  c as fg,
  b as Xh
} from "../chunks/ByA3pUpn.js";
import {
  b as lo
} from "../chunks/DzOWYdWp.js";
import {
  i as mg
} from "../chunks/mY9WtndT.js";
import {
  r as fr,
  p as At,
  s as Hs,
  u as qv
} from "../chunks/PxFakNOO.js";
import {
  U as zb,
  A as L0,
  D as z0,
  a as Yp,
  r as Db,
  I as Mm,
  e as Rb,
  c as Fb,
  P as D0,
  b as Bb
} from "../chunks/CQJzVDOA.js";
import {
  b as R0,
  c as gg,
  g as ea,
  a as Kp
} from "../chunks/CEKbFYuY.js";
import {
  h as Jp
} from "../chunks/jpKm5NkQ.js";
import {
  L as F0
} from "../chunks/B4wdA-Fn.js";
import {
  g as Ne,
  l as Ob
} from "../chunks/Dc6DF1Sc.js";
import {
  c as Yh
} from "../chunks/B94_KVVF.js";
import {
  d as Nb,
  L as Qp,
  p as _g
} from "../chunks/BRXq2IAT.js";
import {
  c as Am,
  b as vg,
  D as yg,
  W as jb,
  s as qb,
  d as Vb,
  l as B0,
  a as Ub,
  p as Zb,
  r as Gb,
  t as Hb,
  e as Wb,
  R as $b,
  f as Vv
} from "../chunks/j3Xspr_d.js";
import {
  P as Mo,
  t as O0
} from "../chunks/Dvv6ryDT.js";
import {
  l as Xb,
  p as xg,
  m as N0,
  v as Yb,
  s as Kb
} from "../chunks/CT1RHJvq.js";
import {
  k as ih
} from "../chunks/BtzD0DMh.js";
import {
  A as j0,
  c as xs
} from "../chunks/BGRMyB1I.js";
import {
  f as so,
  s as Sp
} from "../chunks/BE5NOQST.js";
import {
  C as bg,
  c as Jb
} from "../chunks/X1FSj3je.js";
import {
  L as wg
} from "../chunks/wki_Kg10.js";
import {
  t as Qb,
  r as q0
} from "../chunks/DwjcRsxT.js";
import {
  c as ji
} from "../chunks/DFdETaOn.js";
import {
  L as e2
} from "../chunks/co5T4RTx.js";
import {
  _ as t2
} from "../chunks/BCduqL3q.js";
import {
  c as V0
} from "../chunks/DWkBcjrZ.js";
import {
  s as U0
} from "../chunks/UzjcWt45.js";
import {
  T as ah,
  G as Fp,
  t as Z0
} from "../chunks/BZUlDuX4.js";
import {
  C as r2
} from "../chunks/CCkW1sBK.js";
import {
  R as n2
} from "../chunks/BJEOUTBQ.js";
import {
  W as i2
} from "../chunks/Cw6-owCy.js";
import {
  r as a2
} from "../chunks/BbhnMY_3.js";
(function() {
  try {
    var m = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
    m.SENTRY_RELEASE = {
      id: "ac7618a676a9d262ff8724cf2a3a13f62011007a"
    }
  } catch {}
})();
try {
  (function() {
    var m = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {},
      a = new m.Error().stack;
    a && (m._sentryDebugIds = m._sentryDebugIds || {}, m._sentryDebugIds[a] = "2d97492a-d25a-47e1-a313-25cd1da3c752", m._sentryDebugIdIdentifier = "sentry-dbid-2d97492a-d25a-47e1-a313-25cd1da3c752")
  })()
} catch {}
const o2 = [];

function s2(m, a = !1, d = !1) {
  return Pp(m, new Map, "", o2, null, d)
}

function Pp(m, a, d, x, A = null, z = !1) {
  if (typeof m == "object" && m !== null) {
    var b = a.get(m);
    if (b !== void 0) return b;
    if (m instanceof Map) return new Map(m);
    if (m instanceof Set) return new Set(m);
    if (nb(m)) {
      var s = Array(m.length);
      a.set(m, s), A !== null && a.set(A, s);
      for (var F = 0; F < m.length; F += 1) {
        var q = m[F];
        F in m && (s[F] = Pp(q, a, d, x, null, z))
      }
      return s
    }
    if (ib(m) === ab) {
      s = {}, a.set(m, s), A !== null && a.set(A, s);
      for (var J in m) s[J] = Pp(m[J], a, d, x, null, z);
      return s
    }
    if (m instanceof Date) return structuredClone(m);
    if (typeof m.toJSON == "function" && !z) return Pp(m.toJSON(), a, d, x, m)
  }
  if (m instanceof EventTarget) return m;
  try {
    return structuredClone(m)
  } catch {
    return m
  }
}

function l2() {
  return Symbol(ob)
}

function ef(m, a) {
  sb(window, ["resize"], () => lb(() => a(window[m])))
}

function c2(m) {
  return function(...a) {
    var d = a[0];
    return d.preventDefault(), m == null ? void 0 : m.apply(this, a)
  }
}
const u2 = cb;
var Oo, No, ms, Vp, Io, Ku, Cp;
const Ug = class Ug extends Map {
  constructor(d) {
    super();
    Zr(this, Io);
    Zr(this, Oo, new Map);
    Zr(this, No, et(0));
    Zr(this, ms, et(0));
    Zr(this, Vp, Fv || -1);
    if (d) {
      for (var [x, A] of d) super.set(x, A);
      Qe(this, ms).v = super.size
    }
  }
  has(d) {
    var x = Qe(this, Oo),
      A = x.get(d);
    if (A === void 0) {
      var z = super.get(d);
      if (z !== void 0) A = en(this, Io, Ku).call(this, 0), x.set(d, A);
      else return _(Qe(this, No)), !1
    }
    return _(A), !0
  }
  forEach(d, x) {
    en(this, Io, Cp).call(this), super.forEach(d, x)
  }
  get(d) {
    var x = Qe(this, Oo),
      A = x.get(d);
    if (A === void 0) {
      var z = super.get(d);
      if (z !== void 0) A = en(this, Io, Ku).call(this, 0), x.set(d, A);
      else {
        _(Qe(this, No));
        return
      }
    }
    return _(A), super.get(d)
  }
  set(d, x) {
    var te;
    var A = Qe(this, Oo),
      z = A.get(d),
      b = super.get(d),
      s = super.set(d, x),
      F = Qe(this, No);
    if (z === void 0) z = en(this, Io, Ku).call(this, 0), A.set(d, z), Y(Qe(this, ms), super.size), Xu(F);
    else if (b !== x) {
      Xu(z);
      var q = F.reactions === null ? null : new Set(F.reactions),
        J = q === null || !((te = z.reactions) != null && te.every(ae => q.has(ae)));
      J && Xu(F)
    }
    return s
  }
  delete(d) {
    var x = Qe(this, Oo),
      A = x.get(d),
      z = super.delete(d);
    return A !== void 0 && (x.delete(d), Y(Qe(this, ms), super.size), Y(A, -1), Xu(Qe(this, No))), z
  }
  clear() {
    if (super.size !== 0) {
      super.clear();
      var d = Qe(this, Oo);
      Y(Qe(this, ms), 0);
      for (var x of d.values()) Y(x, -1);
      Xu(Qe(this, No)), d.clear()
    }
  }
  keys() {
    return _(Qe(this, No)), super.keys()
  }
  values() {
    return en(this, Io, Cp).call(this), super.values()
  }
  entries() {
    return en(this, Io, Cp).call(this), super.entries()
  } [Symbol.iterator]() {
    return this.entries()
  }
  get size() {
    return _(Qe(this, ms)), super.size
  }
};
Oo = new WeakMap, No = new WeakMap, ms = new WeakMap, Vp = new WeakMap, Io = new WeakSet, Ku = function(d) {
  return Fv === Qe(this, Vp) ? et(d) : ub(d)
}, Cp = function() {
  _(Qe(this, No));
  var d = Qe(this, Oo);
  if (Qe(this, ms).v !== d.size) {
    for (var x of Rv(Ug.prototype, this, "keys").call(this))
      if (!d.has(x)) {
        var A = en(this, Io, Ku).call(this, 0);
        d.set(x, A)
      }
  }
  for ([, A] of Qe(this, Oo)) _(A)
};
let Bp = Ug;
const h2 = () => "Log in",
  d2 = () => "Entrar",
  p2 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? h2() : d2(),
  f2 = () => "Store",
  m2 = () => "Loja",
  G0 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? f2() : m2(),
  g2 = () => "Alliance",
  _2 = () => "Alian√ßa",
  tf = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? g2() : _2(),
  v2 = () => "Leaderboard",
  y2 = () => "Ranking",
  Tg = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? v2() : y2(),
  x2 = () => "Unlock",
  b2 = () => "Destravar",
  w2 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? x2() : b2(),
  T2 = () => "Lock",
  S2 = () => "Travar",
  P2 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? T2() : S2(),
  C2 = () => "Info",
  I2 = () => "Informa√ß√µes",
  M2 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? C2() : I2(),
  A2 = () => "Zoom in",
  k2 = () => "Aumentar zoom",
  E2 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? A2() : k2(),
  L2 = () => "Zoom out",
  z2 = () => "Diminuir zoom",
  D2 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? L2() : z2(),
  R2 = () => "Offline",
  F2 = () => "Offline",
  B2 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? R2() : F2(),
  O2 = () => "Zoom in to see the pixels",
  N2 = () => "Amplie para ver os pixels",
  j2 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? O2() : N2(),
  q2 = () => "Phone verification required",
  V2 = () => "Verifica√ß√£o de telefone necess√°ria",
  Uv = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? q2() : V2(),
  U2 = () => "My location",
  Z2 = () => "Minha localiza√ß√£o",
  G2 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? U2() : Z2(),
  H2 = () => "You don't have charges to paint. Wait to recharge.",
  W2 = () => "Voc√™ n√£o possui tinta para pintar. Aguarde para carrega-las.",
  $2 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? H2() : W2(),
  X2 = () => "Map powered by:",
  Y2 = () => "Mapa fornecido por:",
  K2 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? X2() : Y2(),
  J2 = () => "OpenMapTiles Data from",
  Q2 = () => "OpenMapTiles com dados do",
  ew = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? J2() : Q2(),
  tw = () => "Overview",
  rw = () => "Vis√£o Geral",
  nw = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? tw() : rw(),
  iw = () => "How to paint faster",
  aw = () => "Como pintar mais r√°pido",
  ow = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? iw() : aw(),
  sw = () => "When painting, click on the button",
  lw = () => "Quando pintar clique no bot√£o",
  cw = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? sw() : lw(),
  uw = () => "on the top right corner of the screen. This will lock the screen but it'll also enable painting by moving your finger over the map.",
  hw = () => "no canto superior direito da tela. Isso bloquear√° a tela, mas tamb√©m permitir√° pintar movendo o dedo sobre o mapa.",
  dw = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? uw() : hw(),
  pw = () => "Hold",
  fw = () => "Segure",
  mw = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? pw() : fw(),
  gw = () => "SPACE",
  _w = () => "Espa√ßo",
  vw = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? gw() : _w(),
  yw = () => "and move your cursor over the map.",
  xw = () => "e mova seu cursor sobre o mapa.",
  bw = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? yw() : xw(),
  ww = () => "Recharge paint charges",
  Tw = () => "Recarga de tinta",
  Sw = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? ww() : Tw(),
  Pw = () => "Items",
  Cw = () => "Itens",
  Iw = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? Pw() : Cw(),
  Mw = () => "Get more charges",
  Aw = () => "Recarregue tinta para pintar",
  kw = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? Mw() : Aw(),
  Ew = m => `+${m.amount} Max. Charges`,
  Lw = m => `+${m.amount} Tinta m√°xima`,
  zw = (m, a = {}) => (a.locale ?? Ne()) === "en" ? Ew(m) : Lw(m),
  Dw = () => "Increase your maximum paint charges capacity",
  Rw = () => "Aumente sua capacidade m√°xima de tinta",
  Fw = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? Dw() : Rw(),
  Bw = () => "Profile picture",
  Ow = () => "Imagem de perfil",
  Nw = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? Bw() : Ow(),
  jw = () => "Add a new 16x16 profile picture",
  qw = () => "Adicionar uma nova imagem de perfil 16x16",
  Vw = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? jw() : qw(),
  Uw = () => "Not enough droplets",
  Zw = () => "Droplets insuficientes",
  rf = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? Uw() : Zw(),
  Gw = () => "Show profile",
  Hw = () => "Exibir perfil",
  Ww = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? Gw() : Hw(),
  $w = () => "Menu",
  Xw = () => "Menu",
  Yw = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? $w() : Xw(),
  Kw = m => `Could not install the app: ${m.error}`,
  Jw = m => `N√£o pode instalar o app: ${m.error}`,
  Qw = (m, a = {}) => (a.locale ?? Ne()) === "en" ? Kw(m) : Jw(m),
  e5 = () => "Install App",
  t5 = () => "Instalar App",
  r5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? e5() : t5(),
  n5 = () => "Livestreams",
  i5 = () => "Livestreams",
  a5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? n5() : i5(),
  o5 = () => "Hide UI",
  s5 = () => "Esconder UI",
  l5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? o5() : s5(),
  c5 = () => "Change picture:",
  u5 = () => "Change picture:",
  h5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? c5() : u5(),
  d5 = () => "Show last painted pixel on alliance",
  p5 = () => "Mostrar √∫ltimo pixel pintado na alian√ßa",
  f5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? d5() : p5(),
  m5 = () => "Delete Account",
  g5 = () => "Deletar Conta",
  km = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? m5() : g5(),
  _5 = () => "Are you absolutely sure?",
  v5 = () => "Voc√™ tem certeza absoluta?",
  y5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? _5() : v5(),
  x5 = () => "This will permanently delete your account and all associated data. This action cannot be undone.",
  b5 = () => "Isso excluir√° permanentemente sua conta e todos os dados associados. Esta a√ß√£o n√£o pode ser desfeita.",
  w5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? x5() : b5(),
  T5 = () => "Profile",
  S5 = () => "Perfil",
  P5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? T5() : S5(),
  C5 = () => "Display your country‚Äôs flag next to your username. Plus, when painting in regions where you own the corresponding flag, you recover 10% of the charges spent.",
  I5 = () => "Exiba a bandeira do seu pa√≠s ao lado do seu nome de usu√°rio. Al√©m disso, ao pintar em regi√µes onde voc√™ possui a bandeira correspondente, voc√™ recupera 10% das tintas gastas.",
  M5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? C5() : I5(),
  A5 = () => "Does not need to be equipped to provide the bonus",
  k5 = () => "N√£o precisa estar equipada para obter o b√¥nus",
  E5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? A5() : k5(),
  L5 = () => "Equipped",
  z5 = () => "Equipado",
  D5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? L5() : z5(),
  R5 = () => "Equip",
  F5 = () => "Equipar",
  B5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? R5() : F5(),
  O5 = () => "Country",
  N5 = () => "Pa√≠s",
  Sg = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? O5() : N5(),
  j5 = () => "No country found.",
  q5 = () => "Pa√≠s n√£o encontrado.",
  V5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? j5() : q5(),
  U5 = () => "Welcome to",
  Z5 = () => "Bem vindo ao",
  G5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? U5() : Z5(),
  H5 = () => "Rules",
  W5 = () => "Regras",
  $5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? H5() : W5(),
  X5 = () => "Important",
  Y5 = () => "Importante",
  K5 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? X5() : Y5(),
  J5 = () => "üö´ No inappropriate content (+18, hate speech, inappropriate links, highly suggestive material, ...)",
  Q5 = () => "üö´ Conte√∫do inapropriado n√£o permitido (+18, discurso de √≥dio, links inapropriados, conte√∫do altamente sugestivo, ...)",
  e3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? J5() : Q5(),
  t3 = () => "üòà Do not paint over other artworks using random colors or patterns just to mess things up",
  r3 = () => "üòà N√£o desenhe por cima de outras artes usando cores ou padr√µes aleat√≥rios s√≥ para bagun√ßar",
  n3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? t3() : r3(),
  i3 = () => "üßë‚Äçü§ù‚Äçüßë Do not paint with more than one account",
  a3 = () => "üßë‚Äçü§ù‚Äçüßë N√£o desenhe com mais de uma conta",
  o3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? i3() : a3(),
  s3 = () => "ü§ñ Use of bots is not allowed",
  l3 = () => "ü§ñ Usar bots n√£o √© permitido",
  c3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? s3() : l3(),
  u3 = () => "üôÖ Disclosing other's personal information is not allowed",
  h3 = () => "üôÖ Divulgar informa√ß√µes pessoais dos outros n√£o √© permitido",
  d3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? u3() : h3(),
  p3 = () => "‚úÖ Painting over other artworks to complement them or create a new drawing is allowed",
  f3 = () => "‚úÖ Desenhar sobre outras artes para complementar ou criar novas artes √© permitido",
  m3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? p3() : f3(),
  g3 = () => "‚úÖ Griefing political party flags or portraits of politicians is allowed",
  _3 = () => "‚úÖ Desenhar sobre bandeiras de partidos e retratos de pol√≠ticos √© permitido",
  v3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? g3() : _3(),
  y3 = () => "Violations of these rules may lead to suspension of your account or removal of drawings.",
  x3 = () => "A viola√ß√£o destas regras pode levar √† suspens√£o da conta ou √† remo√ß√£o de desenhos.",
  b3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? y3() : x3(),
  w3 = () => "Understood",
  T3 = () => "Entendido",
  S3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? w3() : T3(),
  P3 = () => "Toggle art opacity",
  C3 = () => "Alterar opacidade",
  H0 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? P3() : C3(),
  I3 = () => "Paint",
  M3 = () => "Pintar",
  W0 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? I3() : M3(),
  A3 = () => "Select a color",
  k3 = () => "Selecione uma color",
  E3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? A3() : k3(),
  L3 = () => "Select a pixel to erase",
  z3 = () => "Selecione um pixel para apagar",
  D3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? L3() : z3(),
  R3 = () => "Pick a color from the map",
  F3 = () => "Escolha uma cor do mapa",
  B3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? R3() : F3(),
  O3 = () => "Click",
  N3 = () => "Clique",
  j3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? O3() : N3(),
  q3 = () => "SPACE",
  V3 = () => "ESPA√áO",
  U3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? q3() : V3(),
  Z3 = () => "or hold",
  G3 = () => "ou segure",
  H3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? Z3() : G3(),
  W3 = () => "to paint,",
  $3 = () => "para pintar",
  X3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? W3() : $3(),
  Y3 = () => "You can paint more than 1 pixel",
  K3 = () => "Voc√™ pode pintar mais de 1 pixel",
  J3 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? Y3() : K3(),
  Q3 = () => "Paint pixel",
  eT = () => "Pintar pixel",
  tT = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? Q3() : eT(),
  rT = () => "Color Picker",
  nT = () => "Conta Gotas",
  iT = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? rT() : nT(),
  aT = () => "+2 max. charge/level",
  oT = () => "+2 tinta m√°xima/level",
  sT = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? aT() : oT(),
  lT = () => "Name",
  cT = () => "Nome",
  Em = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? lT() : cT(),
  uT = () => "Discord Username",
  hT = () => "Usu√°rio do Discord",
  dT = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? uT() : hT(),
  pT = () => "Max. Charges",
  fT = () => "Tinta m√°xima",
  Zv = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? pT() : fT(),
  mT = () => "Paint Charges",
  gT = () => "Tintas",
  _T = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? mT() : gT(),
  vT = m => `+${m.amount} Paint Charges`,
  yT = m => `+${m.amount} Tintas`,
  xT = (m, a = {}) => (a.locale ?? Ne()) === "en" ? vT(m) : yT(m),
  bT = () => "Leave alliance",
  wT = () => "Sair da alian√ßa",
  TT = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? bT() : wT(),
  ST = () => "Headquarters",
  PT = () => "Quartel General",
  CT = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? ST() : PT(),
  IT = () => "Not set",
  MT = () => "N√£o configurado",
  AT = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? IT() : MT(),
  kT = () => "You are not in an alliance",
  ET = () => "Voc√™ n√£o est√° em uma alian√ßa",
  LT = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? kT() : ET(),
  zT = () => "Get invited to an alliance",
  DT = () => "Seja convidado para uma alian√ßa",
  RT = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? zT() : DT(),
  FT = () => "OR",
  BT = () => "OU",
  OT = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? FT() : BT(),
  NT = () => "Create an alliance",
  jT = () => "Crie uma alian√ßa",
  qT = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? NT() : jT(),
  VT = () => "Invite link",
  UT = () => "Link de convite",
  ZT = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? VT() : UT(),
  GT = () => "Send the link below to everybody you want to invite to the alliance",
  HT = () => "Envie o link abaixo para quem voc√™ deseja convidar para a alian√ßa",
  WT = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? GT() : HT(),
  $T = () => "Copied",
  XT = () => "Copiado",
  Pg = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? $T() : XT(),
  YT = () => "No description",
  KT = () => "Sem descri√ß√£o",
  $0 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? YT() : KT(),
  JT = () => "Invite",
  QT = () => "Convite",
  eS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? JT() : QT(),
  tS = () => "No pixels painted",
  rS = () => "Nenhum pixel pintado",
  Cg = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? tS() : rS(),
  nS = () => "Today",
  iS = () => "Hoje",
  nf = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? nS() : iS(),
  aS = () => "Week",
  oS = () => "Semana",
  sS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? aS() : oS(),
  lS = () => "Month",
  cS = () => "M√™s",
  uS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? lS() : cS(),
  hS = () => "All time",
  dS = () => "Geral",
  pS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? hS() : dS(),
  fS = () => "this week",
  mS = () => "nesta semana",
  Ig = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? fS() : mS(),
  gS = () => "this month",
  _S = () => "neste m√™s",
  Mg = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? gS() : _S(),
  vS = () => "Create alliance",
  yS = () => "Criar alian√ßa",
  xS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? vS() : yS(),
  bS = () => "Alliance Name",
  wS = () => "Nome da alian√ßa",
  TS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? bS() : wS(),
  SS = () => "Create",
  PS = () => "Criar",
  CS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? SS() : PS(),
  IS = () => "Give admin",
  MS = () => "Tornar admin",
  AS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? IS() : MS(),
  kS = () => "Ban from alliance",
  ES = () => "Banir da alian√ßa",
  X0 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? kS() : ES(),
  LS = () => "No action",
  zS = () => "Sem op√ß√£o",
  DS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? LS() : zS(),
  RS = () => "Unban",
  FS = () => "Desbanir",
  BS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? RS() : FS(),
  OS = () => "No banned users",
  NS = () => "Sem usu√°rios banidos",
  jS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? OS() : NS(),
  qS = () => "Update",
  VS = () => "Atualizar",
  US = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? qS() : VS(),
  ZS = () => "Error giving admin to user",
  GS = () => "Erro ao tornar usu√°rio admin",
  HS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? ZS() : GS(),
  WS = () => "Users",
  $S = () => "Usu√°rios",
  XS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? WS() : $S(),
  YS = () => "Regions",
  KS = () => "Regi√µes",
  JS = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? YS() : KS(),
  QS = () => "Countries",
  eP = () => "Pa√≠ses",
  tP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? QS() : eP(),
  rP = () => "Players",
  nP = () => "Jogadores",
  Y0 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? rP() : nP(),
  iP = () => "Alliances",
  aP = () => "Alian√ßas",
  K0 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? iP() : aP(),
  oP = () => "Region",
  sP = () => "Regi√£o",
  lP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? oP() : sP(),
  cP = () => "Pixels",
  uP = () => "Pixels",
  Lc = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? cP() : uP(),
  hP = () => "Painted",
  dP = () => "Pintados",
  zc = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? hP() : dP(),
  pP = () => "Pixels painted inside the region",
  fP = () => "Pixels pintados dentro da regi√£o",
  mP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? pP() : fP(),
  gP = () => "Not painted",
  _P = () => "N√£o pintado",
  vP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? gP() : _P(),
  yP = () => "Painted by",
  xP = () => "Pintado por",
  bP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? yP() : xP(),
  wP = () => "Limit reached",
  TP = () => "Limite atingido",
  SP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? wP() : TP(),
  PP = () => "Favorite",
  CP = () => "Favoritar",
  IP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? PP() : CP(),
  MP = () => "Share",
  AP = () => "Compartilhar",
  kP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? MP() : AP(),
  EP = () => "Share place",
  LP = () => "Compartilhar local",
  zP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? EP() : LP(),
  DP = () => "Mute",
  RP = () => "Mutar",
  FP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? DP() : RP(),
  BP = () => "Unmute",
  OP = () => "Desmutar",
  NP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? BP() : OP(),
  jP = () => "Select the headquarters location",
  qP = () => "Selecione a localiza√ß√£o do quartel general",
  VP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? jP() : qP(),
  UP = () => "Pixels painted inside the country",
  ZP = () => "Pixels pintados dentro do pa√≠s",
  GP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? UP() : ZP(),
  HP = () => "Username copied to clipboard",
  WP = () => "Usu√°rio copiado",
  $P = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? HP() : WP(),
  XP = () => "No more charges",
  YP = () => "Acabou a tinta",
  KP = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? XP() : YP(),
  JP = () => "You are not allowed to use multiple accounts. Use your main account to paint.",
  QP = () => "N√£o √© permitido usar v√°rias contas. Use sua conta principal para pintar.",
  eC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? JP() : QP(),
  tC = () => "SMS sent to",
  rC = () => "SMS enviado para",
  nC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? tC() : rC(),
  iC = () => "Phone successfully verified",
  aC = () => "Telefone verificado com sucesso",
  oC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? iC() : aC(),
  sC = () => "Not a valid phone number",
  lC = () => "N√£o √© um n√∫mero v√°lido",
  cC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? sC() : lC(),
  uC = () => "Location unfavorited",
  hC = () => "Localiza√ß√£o desfavoritada",
  dC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? uC() : hC(),
  pC = () => "Location favorited",
  fC = () => "Localiza√ß√£o favoritada",
  mC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? pC() : fC(),
  gC = () => "Giving admin to user",
  _C = () => "Tornar usu√°rio um admin",
  vC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? gC() : _C(),
  yC = () => "Profile updated",
  xC = () => "Perfil atualizado",
  bC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? yC() : xC(),
  wC = () => "Successfully linked your Discord account.",
  TC = () => "A sua conta Discord foi conectada com sucesso.",
  SC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? wC() : TC(),
  PC = () => "Discord unlinked",
  CC = () => "Discord desconectado",
  IC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? PC() : CC(),
  MC = () => "Link your Discord",
  AC = () => "Conectar Discord",
  kC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? MC() : AC(),
  EC = m => `Unlink Discord (${m.username})`,
  LC = m => `Desconectar Discord (${m.username})`,
  zC = (m, a = {}) => (a.locale ?? Ne()) === "en" ? EC(m) : LC(m),
  DC = () => "Account successfully deleted",
  RC = () => "Conta deletada com sucesso",
  FC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? DC() : RC(),
  BC = () => "Logged out",
  OC = () => "Logout feito",
  NC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? BC() : OC(),
  jC = () => "Could not logout. Try refreshing the page.",
  qC = () => "N√£o foi poss√≠vel sair da conta. Tente recarregar a p√°gina.",
  VC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? jC() : qC(),
  UC = () => "You need to zoom in to select a pixel",
  ZC = () => "D√™ zoom para selecionar um pixel",
  GC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? UC() : ZC(),
  HC = () => "Phone verification",
  WC = () => "Verifica√ß√£o de telefone",
  $C = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? HC() : WC(),
  XC = () => "Please verify your phone number to continue playing. This helps us keep bots out and ensure a safe, creative experience for everyone.",
  YC = () => "Por favor, verifique com seu telefone para continuar jogando. Isso nos ajuda a filtrar bots e manter um experi√™ncia segura e criativa para todos.",
  KC = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? XC() : YC(),
  JC = () => "Send Code",
  QC = () => "Enviar o c√≥digo",
  eI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? JC() : QC(),
  tI = () => "Input the code",
  rI = () => "Insira o c√≥digo",
  nI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? tI() : rI(),
  iI = () => "Sent to",
  aI = () => "Enviar para",
  oI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? iI() : aI(),
  sI = () => "Resend Code",
  lI = () => "Reenviar C√≥digo",
  cI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? sI() : lI(),
  uI = () => "Try another number",
  hI = () => "Tentar outro n√∫mero",
  dI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? uI() : hI(),
  pI = () => "Edit profile",
  fI = () => "Editar perfil",
  mI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? pI() : fI(),
  gI = () => "Image",
  _I = () => "Imagem",
  vI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? gI() : _I(),
  yI = () => "Download",
  xI = () => "Download",
  bI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? yI() : xI(),
  wI = () => "Image copied to clipboard",
  TI = () => "Imagem copiada para a √°rea de transfer√™ncia",
  SI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? wI() : TI(),
  PI = () => "My map is lagging",
  CI = () => "Meu mapa est√° travando",
  II = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? PI() : CI(),
  MI = () => "Verify if",
  AI = () => "Verifique se",
  kI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? MI() : AI(),
  EI = () => "Use hardware acceleration when available",
  LI = () => "Usar acelera√ß√£o gr√°fica quando dispon√≠vel",
  zI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? EI() : LI(),
  DI = () => "is enabled on",
  RI = () => "est√° habilitado em",
  FI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? DI() : RI(),
  BI = () => "Follow the instructions to enable hardware acceleration",
  OI = () => "Siga a instru√ß√£o para habilitar a acelera√ß√£o de hardware",
  NI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? BI() : OI(),
  jI = () => "Moderation",
  qI = () => "Modera√ß√£o",
  VI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? jI() : qI(),
  UI = () => "Terms",
  ZI = () => "Termos",
  GI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? UI() : ZI(),
  HI = () => "Privacy",
  WI = () => "Privacidade",
  $I = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? HI() : WI(),
  XI = () => "Refund",
  YI = () => "Reembolso",
  J0 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? XI() : YI(),
  KI = () => "Clear area",
  JI = () => "Limpar √°rea",
  QI = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? KI() : JI(),
  e4 = () => "Select the area's first corner",
  t4 = () => "Selecione o primeiro canto da √°rea",
  Q0 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? e4() : t4(),
  r4 = () => "Select the area's opposite corner",
  n4 = () => "Selecione o canto oposto da √°rea",
  ey = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? r4() : n4(),
  i4 = () => "Admin",
  a4 = () => "Administra√ß√£o",
  o4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? i4() : a4(),
  s4 = m => `Reason: ${m.reason}`,
  l4 = m => `Motivo: ${m.reason}`,
  Gv = (m, a = {}) => (a.locale ?? Ne()) === "en" ? s4(m) : l4(m),
  c4 = () => "No corresponding region on the map (cosmetic effect only)",
  u4 = () => "N√£o possui regi√£o no mapa (apenas efeito cosm√©tico)",
  h4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? c4() : u4(),
  d4 = () => "Flag without region on the map",
  p4 = () => "Bandeira sem regi√£o no mapa",
  f4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? d4() : p4(),
  m4 = m => `The flag of <b>${m.country}</b> does not have corresponding areas on the map and will only have cosmetic effects.`,
  g4 = m => `A bandeira <b>${m.country}</b> n√£o possui regi√µes correspondente no mapa e s√≥ ter√° efeito cosm√©tico.`,
  _4 = (m, a = {}) => (a.locale ?? Ne()) === "en" ? m4(m) : g4(m),
  v4 = () => "Dark mode",
  y4 = () => "Modo escuro",
  x4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? v4() : y4(),
  b4 = () => "Light mode",
  w4 = () => "Modo claro",
  T4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? b4() : w4(),
  S4 = () => "This action will log your account out from all devices.",
  P4 = () => "Essa a√ß√£o ira desconectar sua conta de todos os dispositivos.",
  C4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? S4() : P4(),
  I4 = () => "More",
  M4 = () => "Mais",
  A4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? I4() : M4(),
  k4 = () => "This action is irreversible, do you want to proceed?",
  E4 = () => "Esta a√ß√£o √© irrevers√≠vel, voc√™ deseja prosseguir?",
  L4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? k4() : E4(),
  z4 = () => "Please confirm by entering your username:",
  D4 = () => "Por favor, confirme digitando seu nome de usu√°rio:",
  R4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? z4() : D4(),
  F4 = () => "Type your username",
  B4 = () => "Digite seu nome de usu√°rio",
  O4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? F4() : B4(),
  N4 = () => "This action may take some time to be completed.",
  j4 = () => "Essa a√ß√£o pode levar algum tempo para ser realizada.",
  q4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? N4() : j4(),
  V4 = () => "Ban appeal",
  U4 = () => "Revis√£o de banimento",
  ty = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? V4() : U4(),
  Z4 = () => "Suggestions",
  G4 = () => "Sugest√µes",
  H4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? Z4() : G4(),
  W4 = () => "Bug report",
  $4 = () => "Reportar bug",
  X4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? W4() : $4(),
  Y4 = () => "For more details, see our",
  K4 = () => "Para mais detalhes, veja nossa",
  J4 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? Y4() : K4(),
  Q4 = () => "Account Enforcement Policy and Code of Conduct",
  eM = () => "Pol√≠tica de Aplica√ß√£o da Conta e C√≥digo de Conduta",
  tM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? Q4() : eM(),
  rM = () => "Community Leader",
  nM = () => "L√≠der de Comunidade",
  iM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? rM() : nM(),
  aM = () => "Your name is how other users will see you in Wplace. It can be changed every 60 days.",
  oM = () => "Seu nome √© como outros usu√°rios o ver√£o no Wplace. Voc√™ pode alter√°-lo a cada 60 dias.",
  sM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? aM() : oM(),
  lM = () => "Twitch account migrated successfully.",
  cM = () => "Conta da Twitch migrada com sucesso.",
  uM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? lM() : cM(),
  hM = () => "Timeout appeal",
  dM = () => "Revis√£o de suspens√£o",
  pM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? hM() : dM(),
  fM = () => `If you believe your suspension was a mistake, you can send one appeal <b>every 90 days</b> to have your case reviewed again.

Please note that submitting an appeal <b>does not guarantee that your suspension will be lifted</b>; however, our team will review your situation.

Reviews usually take up to <b>a week</b>.`,
  mM = () => `Se voc√™ acredita que sua suspens√£o foi um erro, voc√™ pode enviar um apelo <b>a cada 90 dias</b> para que seu caso seja revisado novamente.

Por favor, note que enviar um recurso <b>n√£o garante que sua suspens√£o ser√° removida</b>; no entanto, nossa equipe analisar√° a sua situa√ß√£o novamente.

As revis√µes geralmente levam at√© <b>uma semana</b>.`,
  gM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? fM() : mM(),
  _M = () => "Why your suspension should be lifted?",
  vM = () => "Por que sua suspens√£o deve ser reconsiderada?",
  yM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? _M() : vM(),
  xM = () => "Tell us why you think your suspension should be reconsidered",
  bM = () => "Explique por que voc√™ acha que sua suspens√£o deve ser reconsiderada",
  wM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? xM() : bM(),
  TM = () => "Submit",
  SM = () => "Enviar",
  PM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? TM() : SM(),
  CM = () => "Appeal sent successfully",
  IM = () => "Apelo enviado com sucesso",
  MM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? CM() : IM(),
  AM = () => "User appeal",
  kM = () => "Apelo do usu√°rio",
  EM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? AM() : kM(),
  LM = m => `You can send another appeal in ${m.days} days`,
  zM = m => `Voc√™ pode enviar outro apelo em ${m.days} dias`,
  DM = (m, a = {}) => (a.locale ?? Ne()) === "en" ? LM(m) : zM(m),
  RM = () => "Appeal",
  FM = () => "Apelar",
  BM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? RM() : FM(),
  OM = () => "Notifications",
  NM = () => "Notifica√ß√µes",
  ry = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? OM() : NM(),
  jM = () => "No notifications",
  qM = () => "Nenhuma notifica√ß√£o",
  VM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? jM() : qM(),
  UM = () => "Report feedback",
  ZM = () => "Feedback de report",
  Hv = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? UM() : ZM(),
  GM = () => "A player reported by you recently has been punished.",
  HM = () => "Um jogador denunciado recentemente por voc√™ foi punido.",
  Wv = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? GM() : HM(),
  WM = () => "Thank you for helping keep the community fair and safe!",
  $M = () => "Obrigado por ajudar a manter a comunidade justa e segura!",
  XM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? WM() : $M(),
  YM = () => "Mark all as read",
  KM = () => "Marcar tudo como lido",
  JM = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? YM() : KM(),
  QM = () => "Recent",
  e6 = () => "Recente",
  t6 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? QM() : e6(),
  r6 = () => "Random place",
  n6 = () => "Local aleat√≥rio",
  i6 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? r6() : n6(),
  a6 = () => "No place found",
  o6 = () => "Nenhum local encontrado",
  s6 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? a6() : o6(),
  l6 = () => "No recent locations",
  c6 = () => "Nenhum local recente",
  u6 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? l6() : c6(),
  h6 = () => "Coordinates",
  d6 = () => "Coordenadas",
  ny = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? h6() : d6(),
  p6 = () => "Pumpkin",
  f6 = () => "Ab√≥bora",
  m6 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? p6() : f6(),
  g6 = () => "Claim",
  _6 = () => "Resgatar",
  v6 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? g6() : _6(),
  y6 = () => "Claimed",
  x6 = () => "Resgatado",
  b6 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? y6() : x6(),
  w6 = m => `You received ${m.droplets} droplets!`,
  T6 = m => `Voc√™ recebeu ${m.droplets} droplets!`,
  S6 = (m, a = {}) => (a.locale ?? Ne()) === "en" ? w6(m) : T6(m),
  P6 = () => "Event",
  C6 = () => "Evento",
  I6 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? P6() : C6(),
  M6 = () => "Service Workers are not supported/enabled in your browser. Some features might not work properly.",
  A6 = () => "Service Workers n√£o s√£o suportados ou est√£o desativados em seu navegador. Alguns recursos podem n√£o funcionar corretamente.",
  k6 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? M6() : A6(),
  E6 = () => "Change language",
  L6 = () => "Mudar idioma",
  z6 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? E6() : L6(),
  D6 = () => "Your browser does not support loading the map. Try to use another browser.",
  R6 = () => "Seu navegador n√£o suporta carregar o map. Tente usar outro navegador.",
  F6 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? D6() : R6(),
  B6 = () => "Undo",
  O6 = () => "Desfazer",
  N6 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? B6() : O6(),
  j6 = () => "Redo",
  q6 = () => "Refazer",
  V6 = (m = {}, a = {}) => (a.locale ?? Ne()) === "en" ? j6() : q6(),
  ds = 2 * Math.PI * 6378137 / 2;
class Oa {
  constructor(a = 256) {
    Nr(this, "initialResolution");
    this.tileSize = a, this.initialResolution = 2 * ds / this.tileSize
  }
  latLonToMeters(a, d) {
    const x = d / 180 * ds,
      A = Math.log(Math.tan((90 + a) * Math.PI / 360)) / (Math.PI / 180) * ds / 180;
    return [x, A]
  }
  metersToLatLon(a, d) {
    const x = a / ds * 180;
    let A = d / ds * 180;
    return A = 180 / Math.PI * (2 * Math.atan(Math.exp(A * Math.PI / 180)) - Math.PI / 2), [A, x]
  }
  pixelsToMeters(a, d, x) {
    const A = this.resolution(x),
      z = a * A - ds,
      b = ds - d * A;
    return [z, b]
  }
  pixelsToLatLon(a, d, x) {
    const [A, z] = this.pixelsToMeters(a, d, x);
    return this.metersToLatLon(A, z)
  }
  latLonToPixels(a, d, x) {
    const [A, z] = this.latLonToMeters(a, d);
    return this.metersToPixels(A, z, x)
  }
  latLonToPixelsFloor(a, d, x) {
    const [A, z] = this.latLonToPixels(a, d, x);
    return [Math.floor(A), Math.floor(z)]
  }
  metersToPixels(a, d, x) {
    const A = this.resolution(x),
      z = (a + ds) / A,
      b = (ds - d) / A;
    return [z, b]
  }
  latLonToTile(a, d, x) {
    const [A, z] = this.latLonToMeters(a, d);
    return this.metersToTile(A, z, x)
  }
  metersToTile(a, d, x) {
    const [A, z] = this.metersToPixels(a, d, x);
    return this.pixelsToTile(A, z)
  }
  pixelsToTile(a, d) {
    const x = Math.ceil(a / this.tileSize) - 1,
      A = Math.ceil(d / this.tileSize) - 1;
    return [x, A]
  }
  pixelsToTileLocal(a, d) {
    return {
      tile: this.pixelsToTile(a, d),
      pixel: [Math.floor(a) % this.tileSize, Math.floor(d) % this.tileSize]
    }
  }
  tileBounds(a, d, x) {
    const [A, z] = this.pixelsToMeters(a * this.tileSize, d * this.tileSize, x), [b, s] = this.pixelsToMeters((a + 1) * this.tileSize, (d + 1) * this.tileSize, x);
    return {
      min: [A, z],
      max: [b, s]
    }
  }
  tileBoundsLatLon(a, d, x) {
    const A = this.tileBounds(a, d, x);
    return {
      min: this.metersToLatLon(A.min[0], A.min[1]),
      max: this.metersToLatLon(A.max[0], A.max[1])
    }
  }
  resolution(a) {
    return this.initialResolution / 2 ** a
  }
  latLonToTileAndPixel(a, d, x) {
    const [A, z] = this.latLonToMeters(a, d), [b, s] = this.metersToTile(A, z, x), [F, q] = this.metersToPixels(A, z, x);
    return {
      tile: [b, s],
      pixel: [Math.floor(F) % this.tileSize, Math.floor(q) % this.tileSize]
    }
  }
  pixelBounds(a, d, x) {
    return {
      min: this.pixelsToMeters(a, d, x),
      max: this.pixelsToMeters(a + 1, d + 1, x)
    }
  }
  pixelToBoundsLatLon(a, d, x) {
    const A = this.pixelBounds(a, d, x),
      z = .001885,
      b = (A.max[0] - A.min[0]) * z,
      s = (A.max[1] - A.min[1]) * z;
    return A.min[0] -= b, A.max[0] -= b, A.min[1] -= s, A.max[1] -= s, {
      min: this.metersToLatLon(A.min[0], A.min[1]),
      max: this.metersToLatLon(A.max[0], A.max[1])
    }
  }
  latLonToTileBoundsLatLon(a, d, x) {
    const [A, z] = this.latLonToMeters(a, d), [b, s] = this.metersToTile(A, z, x);
    return this.tileBoundsLatLon(b, s, x)
  }
  latLonToPixelBoundsLatLon(a, d, x) {
    const [A, z] = this.latLonToMeters(a, d), [b, s] = this.metersToPixels(A, z, x);
    return this.pixelToBoundsLatLon(Math.floor(b), Math.floor(s), x)
  }
  latLonToRegionAndPixel(a, d, x, A = La.regionSize) {
    const [z, b] = this.latLonToPixelsFloor(a, d, x), s = this.tileSize * A;
    return {
      region: [Math.floor(z / s), Math.floor(b / s)],
      pixel: [z % s, b % s]
    }
  }
}

function Ag(m, a = !0) {
  const {
    min: d,
    max: x
  } = m;
  return a ? [
    [d[1], x[0]],
    [x[1], x[0]],
    [x[1], d[0]],
    [d[1], d[0]]
  ] : [
    [d[0], x[1]],
    [x[0], x[1]],
    [x[0], d[1]],
    [d[0], d[1]]
  ]
}

function kg(m) {
  return [(m.min[0] + m.max[0]) / 2, (m.min[1] + m.max[1]) / 2]
}
const U6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==",
  $v = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";

function Z6(m) {
  return Math.floor(Math.random() * m)
}
const Lm = 14.5;
async function G6() {
  const m = $6();
  if (m) return m;
  try {
    if ((await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted") {
      const d = await new Promise((x, A) => navigator.geolocation.getCurrentPosition(z => x(z), z => A(z)));
      return {
        lat: d.coords.latitude,
        lng: d.coords.longitude,
        zoom: Lm
      }
    }
  } catch (a) {
    console.error(a)
  }
  return {
    ...H6().pos,
    zoom: Lm
  }
}

function H6() {
  const m = Object.entries(W6),
    a = Z6(m.length),
    [d, x] = m[a];
  return {
    city: d,
    pos: x
  }
}
const W6 = {
    tokyo: {
      lat: 35.677545560719665,
      lng: 139.76394445809638
    },
    paris: {
      lat: 48.8537151734952,
      lng: 2.3484026030630787
    },
    newYork: {
      lat: 40.71283173786517,
      lng: -74.00599771376795
    },
    saoPaulo: {
      lat: -23.550584064565356,
      lng: -46.63339720713918
    },
    sydney: {
      lat: -33.86943325619071,
      lng: 151.2083447239608
    }
  },
  iy = "location";

function ps(m, a) {
  localStorage.setItem(iy, JSON.stringify({
    ...m,
    zoom: a
  }))
}

function $6() {
  const m = localStorage.getItem(iy);
  if (!m) return;
  const a = JSON.parse(m);
  return a.zoom ?? (a.zoom = Lm), a
}
var hh, dh;
class X6 {
  constructor() {
    Zr(this, hh, et(-1));
    Zr(this, dh, et([]))
  }
  get idx() {
    return _(Qe(this, hh))
  }
  set idx(a) {
    Y(Qe(this, hh), a, !0)
  }
  get entries() {
    return _(Qe(this, dh))
  }
  set entries(a) {
    Y(Qe(this, dh), a)
  }
  hasNext() {
    return this.idx < this.entries.length - 1
  }
  goToNext(a) {
    const d = this.idx + 1,
      x = this.entries[d];
    x && (this.idx = d, a.flyTo({
      center: x.pos,
      zoom: x.zoom
    }))
  }
  hasPrev() {
    return this.idx > 0
  }
  goToPrev(a) {
    const d = this.idx - 1,
      x = this.entries[d];
    x && (this.idx = d, a.flyTo({
      center: x.pos,
      zoom: x.zoom
    }))
  }
  isEmpty() {
    return this.entries.length === 0
  }
  push(a) {
    this.idx = this.idx + 1, this.entries = [...this.entries.slice(0, this.idx), a]
  }
}
hh = new WeakMap, dh = new WeakMap;
const Y6 = new X6;

function ay(m) {
  return m && m.__esModule && Object.prototype.hasOwnProperty.call(m, "default") ? m.default : m
}
var Ip = {
  exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.11.0/LICENSE.txt
 */
var K6 = Ip.exports,
  Xv;

function J6() {
  return Xv || (Xv = 1, (function(m, a) {
    (function(d, x) {
      m.exports = x()
    })(K6, (function() {
      var d = {},
        x = {};

      function A(b, s, F) {
        if (x[b] = F, b === "index") {
          var q = "var sharedModule = {}; (" + x.shared + ")(sharedModule); (" + x.worker + ")(sharedModule);",
            J = {};
          return x.shared(J), x.index(d, J), typeof window < "u" && d.setWorkerUrl(window.URL.createObjectURL(new Blob([q], {
            type: "text/javascript"
          }))), d
        }
      }
      A("shared", ["exports"], (function(b) {
        function s(n, t, r, o) {
          return new(r || (r = Promise))((function(c, f) {
            function g(P) {
              try {
                w(o.next(P))
              } catch (M) {
                f(M)
              }
            }

            function y(P) {
              try {
                w(o.throw(P))
              } catch (M) {
                f(M)
              }
            }

            function w(P) {
              var M;
              P.done ? c(P.value) : (M = P.value, M instanceof r ? M : new r((function(R) {
                R(M)
              }))).then(g, y)
            }
            w((o = o.apply(n, t || [])).next())
          }))
        }

        function F(n, t) {
          this.x = n, this.y = t
        }

        function q(n) {
          return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
        }
        var J, te;
        typeof SuppressedError == "function" && SuppressedError, F.prototype = {
          clone() {
            return new F(this.x, this.y)
          },
          add(n) {
            return this.clone()._add(n)
          },
          sub(n) {
            return this.clone()._sub(n)
          },
          multByPoint(n) {
            return this.clone()._multByPoint(n)
          },
          divByPoint(n) {
            return this.clone()._divByPoint(n)
          },
          mult(n) {
            return this.clone()._mult(n)
          },
          div(n) {
            return this.clone()._div(n)
          },
          rotate(n) {
            return this.clone()._rotate(n)
          },
          rotateAround(n, t) {
            return this.clone()._rotateAround(n, t)
          },
          matMult(n) {
            return this.clone()._matMult(n)
          },
          unit() {
            return this.clone()._unit()
          },
          perp() {
            return this.clone()._perp()
          },
          round() {
            return this.clone()._round()
          },
          mag() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
          },
          equals(n) {
            return this.x === n.x && this.y === n.y
          },
          dist(n) {
            return Math.sqrt(this.distSqr(n))
          },
          distSqr(n) {
            const t = n.x - this.x,
              r = n.y - this.y;
            return t * t + r * r
          },
          angle() {
            return Math.atan2(this.y, this.x)
          },
          angleTo(n) {
            return Math.atan2(this.y - n.y, this.x - n.x)
          },
          angleWith(n) {
            return this.angleWithSep(n.x, n.y)
          },
          angleWithSep(n, t) {
            return Math.atan2(this.x * t - this.y * n, this.x * n + this.y * t)
          },
          _matMult(n) {
            const t = n[2] * this.x + n[3] * this.y;
            return this.x = n[0] * this.x + n[1] * this.y, this.y = t, this
          },
          _add(n) {
            return this.x += n.x, this.y += n.y, this
          },
          _sub(n) {
            return this.x -= n.x, this.y -= n.y, this
          },
          _mult(n) {
            return this.x *= n, this.y *= n, this
          },
          _div(n) {
            return this.x /= n, this.y /= n, this
          },
          _multByPoint(n) {
            return this.x *= n.x, this.y *= n.y, this
          },
          _divByPoint(n) {
            return this.x /= n.x, this.y /= n.y, this
          },
          _unit() {
            return this._div(this.mag()), this
          },
          _perp() {
            const n = this.y;
            return this.y = this.x, this.x = -n, this
          },
          _rotate(n) {
            const t = Math.cos(n),
              r = Math.sin(n),
              o = r * this.x + t * this.y;
            return this.x = t * this.x - r * this.y, this.y = o, this
          },
          _rotateAround(n, t) {
            const r = Math.cos(n),
              o = Math.sin(n),
              c = t.y + o * (this.x - t.x) + r * (this.y - t.y);
            return this.x = t.x + r * (this.x - t.x) - o * (this.y - t.y), this.y = c, this
          },
          _round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
          },
          constructor: F
        }, F.convert = function(n) {
          if (n instanceof F) return n;
          if (Array.isArray(n)) return new F(+n[0], +n[1]);
          if (n.x !== void 0 && n.y !== void 0) return new F(+n.x, +n.y);
          throw new Error("Expected [x, y] or {x, y} point format")
        };
        var ae = (function() {
            if (te) return J;

            function n(t, r, o, c) {
              this.cx = 3 * t, this.bx = 3 * (o - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (c - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = o, this.p2y = c
            }
            return te = 1, J = n, n.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var o = t, c = 0; c < 8; c++) {
                  var f = this.sampleCurveX(o) - t;
                  if (Math.abs(f) < r) return o;
                  var g = this.sampleCurveDerivativeX(o);
                  if (Math.abs(g) < 1e-6) break;
                  o -= f / g
                }
                var y = 0,
                  w = 1;
                for (o = t, c = 0; c < 20 && (f = this.sampleCurveX(o), !(Math.abs(f - t) < r)); c++) t > f ? y = o : w = o, o = .5 * (w - y) + y;
                return o
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, J
          })(),
          fe = q(ae);
        let ie, $;

        function Se() {
          return ie == null && (ie = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), ie
        }

        function Me() {
          if ($ == null && ($ = !1, Se())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", {
              willReadFrequently: !0
            });
            if (t) {
              for (let o = 0; o < 25; o++) {
                const c = 4 * o;
                t.fillStyle = `rgb(${c},${c+1},${c+2})`, t.fillRect(o % 5, Math.floor(o / 5), 1, 1)
              }
              const r = t.getImageData(0, 0, 5, 5).data;
              for (let o = 0; o < 100; o++)
                if (o % 4 != 3 && r[o] !== o) {
                  $ = !0;
                  break
                }
            }
          }
          return $ || !1
        }
        var Pe = 1e-6,
          Ie = typeof Float32Array < "u" ? Float32Array : Array;

        function Ce() {
          var n = new Ie(9);
          return Ie != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[0] = 1, n[4] = 1, n[8] = 1, n
        }

        function je(n) {
          return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n
        }

        function Ye() {
          var n = new Ie(3);
          return Ie != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n
        }

        function qe(n) {
          var t = n[0],
            r = n[1],
            o = n[2];
          return Math.sqrt(t * t + r * r + o * o)
        }

        function Be(n, t, r) {
          var o = new Ie(3);
          return o[0] = n, o[1] = t, o[2] = r, o
        }

        function He(n, t, r) {
          return n[0] = t[0] + r[0], n[1] = t[1] + r[1], n[2] = t[2] + r[2], n
        }

        function we(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n
        }

        function it(n, t, r) {
          var o = t[0],
            c = t[1],
            f = t[2],
            g = r[0],
            y = r[1],
            w = r[2];
          return n[0] = c * w - f * y, n[1] = f * g - o * w, n[2] = o * y - c * g, n
        }
        var mt, Ge = qe;

        function Xe(n, t, r) {
          var o = t[0],
            c = t[1],
            f = t[2],
            g = t[3];
          return n[0] = r[0] * o + r[4] * c + r[8] * f + r[12] * g, n[1] = r[1] * o + r[5] * c + r[9] * f + r[13] * g, n[2] = r[2] * o + r[6] * c + r[10] * f + r[14] * g, n[3] = r[3] * o + r[7] * c + r[11] * f + r[15] * g, n
        }

        function vt() {
          var n = new Ie(4);
          return Ie != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n[3] = 1, n
        }

        function Ut(n, t, r, o) {
          var c = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx",
            f = Math.PI / 360;
          t *= f, o *= f, r *= f;
          var g = Math.sin(t),
            y = Math.cos(t),
            w = Math.sin(r),
            P = Math.cos(r),
            M = Math.sin(o),
            R = Math.cos(o);
          switch (c) {
            case "xyz":
              n[0] = g * P * R + y * w * M, n[1] = y * w * R - g * P * M, n[2] = y * P * M + g * w * R, n[3] = y * P * R - g * w * M;
              break;
            case "xzy":
              n[0] = g * P * R - y * w * M, n[1] = y * w * R - g * P * M, n[2] = y * P * M + g * w * R, n[3] = y * P * R + g * w * M;
              break;
            case "yxz":
              n[0] = g * P * R + y * w * M, n[1] = y * w * R - g * P * M, n[2] = y * P * M - g * w * R, n[3] = y * P * R + g * w * M;
              break;
            case "yzx":
              n[0] = g * P * R + y * w * M, n[1] = y * w * R + g * P * M, n[2] = y * P * M - g * w * R, n[3] = y * P * R - g * w * M;
              break;
            case "zxy":
              n[0] = g * P * R - y * w * M, n[1] = y * w * R + g * P * M, n[2] = y * P * M + g * w * R, n[3] = y * P * R - g * w * M;
              break;
            case "zyx":
              n[0] = g * P * R - y * w * M, n[1] = y * w * R + g * P * M, n[2] = y * P * M - g * w * R, n[3] = y * P * R + g * w * M;
              break;
            default:
              throw new Error("Unknown angle order " + c)
          }
          return n
        }

        function _t() {
          var n = new Ie(2);
          return Ie != Float32Array && (n[0] = 0, n[1] = 0), n
        }

        function wt(n, t) {
          var r = new Ie(2);
          return r[0] = n, r[1] = t, r
        }
        Ye(), mt = new Ie(4), Ie != Float32Array && (mt[0] = 0, mt[1] = 0, mt[2] = 0, mt[3] = 0), Ye(), Be(1, 0, 0), Be(0, 1, 0), vt(), vt(), Ce(), _t();
        const Je = 8192;

        function zt(n, t, r) {
          return t * (Je / (n.tileSize * Math.pow(2, r - n.tileID.overscaledZ)))
        }

        function bt(n, t) {
          return (n % t + t) % t
        }

        function Rt(n, t, r) {
          return n * (1 - r) + t * r
        }

        function Pt(n) {
          if (n <= 0) return 0;
          if (n >= 1) return 1;
          const t = n * n,
            r = t * n;
          return 4 * (n < .5 ? r : 3 * (n - t) + r - .75)
        }

        function yt(n, t, r, o) {
          const c = new fe(n, t, r, o);
          return f => c.solve(f)
        }
        const sr = yt(.25, .1, .25, 1);

        function tr(n, t, r) {
          return Math.min(r, Math.max(t, n))
        }

        function tt(n, t, r) {
          const o = r - t,
            c = ((n - t) % o + o) % o + t;
          return c === t ? r : c
        }

        function ht(n, ...t) {
          for (const r of t)
            for (const o in r) n[o] = r[o];
          return n
        }
        let It = 1;

        function Bt(n, t, r) {
          const o = {};
          for (const c in n) o[c] = t.call(this, n[c], c, n);
          return o
        }

        function Nt(n, t, r) {
          const o = {};
          for (const c in n) t.call(this, n[c], c, n) && (o[c] = n[c]);
          return o
        }

        function Ht(n) {
          return Array.isArray(n) ? n.map(Ht) : typeof n == "object" && n ? Bt(n, Ht) : n
        }
        const yr = {};

        function Wt(n) {
          yr[n] || (typeof console < "u" && console.warn(n), yr[n] = !0)
        }

        function Zt(n, t, r) {
          return (r.y - n.y) * (t.x - n.x) > (t.y - n.y) * (r.x - n.x)
        }

        function jt(n) {
          return typeof WorkerGlobalScope < "u" && n !== void 0 && n instanceof WorkerGlobalScope
        }
        let Jt = null;

        function Lt(n) {
          if (Jt == null) {
            const t = n.navigator ? n.navigator.userAgent : null;
            Jt = !!n.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
          }
          return Jt
        }

        function Gt(n) {
          return typeof ImageBitmap < "u" && n instanceof ImageBitmap
        }
        const Yt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";

        function Lr(n, t, r, o, c) {
          return s(this, void 0, void 0, (function*() {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const f = new VideoFrame(n, {
              timestamp: 0
            });
            try {
              const g = f == null ? void 0 : f.format;
              if (!g || !g.startsWith("BGR") && !g.startsWith("RGB")) throw new Error(`Unrecognized format ${g}`);
              const y = g.startsWith("BGR"),
                w = new Uint8ClampedArray(o * c * 4);
              if (yield f.copyTo(w, (function(P, M, R, U, G) {
                  const W = 4 * Math.max(-M, 0),
                    ne = (Math.max(0, R) - R) * U * 4 + W,
                    se = 4 * U,
                    ge = Math.max(0, M),
                    We = Math.max(0, R);
                  return {
                    rect: {
                      x: ge,
                      y: We,
                      width: Math.min(P.width, M + U) - ge,
                      height: Math.min(P.height, R + G) - We
                    },
                    layout: [{
                      offset: ne,
                      stride: se
                    }]
                  }
                })(n, t, r, o, c)), y)
                for (let P = 0; P < w.length; P += 4) {
                  const M = w[P];
                  w[P] = w[P + 2], w[P + 2] = M
                }
              return w
            } finally {
              f.close()
            }
          }))
        }
        let Ir, Jr;

        function Tr(n, t, r, o) {
          return n.addEventListener(t, r, o), {
            unsubscribe: () => {
              n.removeEventListener(t, r, o)
            }
          }
        }

        function Ar(n) {
          return n * Math.PI / 180
        }

        function xr(n) {
          return n / Math.PI * 180
        }
        const qt = {
            touchstart: !0,
            touchmove: !0,
            touchmoveWindow: !0,
            touchend: !0,
            touchcancel: !0
          },
          Yr = {
            dblclick: !0,
            click: !0,
            mouseover: !0,
            mouseout: !0,
            mousedown: !0,
            mousemove: !0,
            mousemoveWindow: !0,
            mouseup: !0,
            mouseupWindow: !0,
            contextmenu: !0,
            wheel: !0
          },
          Le = "AbortError";

        function j() {
          return new Error(Le)
        }
        const E = {
          MAX_PARALLEL_IMAGE_REQUESTS: 16,
          MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
          MAX_TILE_CACHE_ZOOM_LEVELS: 5,
          REGISTERED_PROTOCOLS: {},
          WORKER_URL: ""
        };

        function D(n) {
          return E.REGISTERED_PROTOCOLS[n.substring(0, n.indexOf("://"))]
        }
        const N = "global-dispatcher";
        class X extends Error {
          constructor(t, r, o, c) {
            super(`AJAXError: ${r} (${t}): ${o}`), this.status = t, this.statusText = r, this.url = o, this.body = c
          }
        }
        const ee = () => jt(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href,
          pe = function(n, t) {
            if (/:\/\//.test(n.url) && !/^https?:|^file:/.test(n.url)) {
              const o = D(n.url);
              if (o) return o(n, t);
              if (jt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: n,
                targetMapId: N
              }, t)
            }
            if (!(/^file:/.test(r = n.url) || /^file:/.test(ee()) && !/^\w+:/.test(r))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(o, c) {
                return s(this, void 0, void 0, (function*() {
                  const f = new Request(o.url, {
                    method: o.method || "GET",
                    body: o.body,
                    credentials: o.credentials,
                    headers: o.headers,
                    cache: o.cache,
                    referrer: ee(),
                    signal: c.signal
                  });
                  let g, y;
                  o.type !== "json" || f.headers.has("Accept") || f.headers.set("Accept", "application/json");
                  try {
                    g = yield fetch(f)
                  } catch (P) {
                    throw new X(0, P.message, o.url, new Blob)
                  }
                  if (!g.ok) {
                    const P = yield g.blob();
                    throw new X(g.status, g.statusText, o.url, P)
                  }
                  y = o.type === "arrayBuffer" || o.type === "image" ? g.arrayBuffer() : o.type === "json" ? g.json() : g.text();
                  const w = yield y;
                  if (c.signal.aborted) throw j();
                  return {
                    data: w,
                    cacheControl: g.headers.get("Cache-Control"),
                    expires: g.headers.get("Expires")
                  }
                }))
              })(n, t);
              if (jt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: n,
                mustQueue: !0,
                targetMapId: N
              }, t)
            }
            var r;
            return (function(o, c) {
              return new Promise(((f, g) => {
                var y;
                const w = new XMLHttpRequest;
                w.open(o.method || "GET", o.url, !0), o.type !== "arrayBuffer" && o.type !== "image" || (w.responseType = "arraybuffer");
                for (const P in o.headers) w.setRequestHeader(P, o.headers[P]);
                o.type === "json" && (w.responseType = "text", !((y = o.headers) === null || y === void 0) && y.Accept || w.setRequestHeader("Accept", "application/json")), w.withCredentials = o.credentials === "include", w.onerror = () => {
                  g(new Error(w.statusText))
                }, w.onload = () => {
                  if (!c.signal.aborted)
                    if ((w.status >= 200 && w.status < 300 || w.status === 0) && w.response !== null) {
                      let P = w.response;
                      if (o.type === "json") try {
                        P = JSON.parse(w.response)
                      } catch (M) {
                        return void g(M)
                      }
                      f({
                        data: P,
                        cacheControl: w.getResponseHeader("Cache-Control"),
                        expires: w.getResponseHeader("Expires")
                      })
                    } else {
                      const P = new Blob([w.response], {
                        type: w.getResponseHeader("Content-Type")
                      });
                      g(new X(w.status, w.statusText, o.url, P))
                    }
                }, c.signal.addEventListener("abort", (() => {
                  w.abort(), g(j())
                })), w.send(o.body)
              }))
            })(n, t)
          };

        function be(n) {
          if (!n || n.indexOf("://") <= 0 || n.indexOf("data:image/") === 0 || n.indexOf("blob:") === 0) return !0;
          const t = new URL(n),
            r = window.location;
          return t.protocol === r.protocol && t.host === r.host
        }

        function ye(n, t, r) {
          r[n] && r[n].indexOf(t) !== -1 || (r[n] = r[n] || [], r[n].push(t))
        }

        function Oe(n, t, r) {
          if (r && r[n]) {
            const o = r[n].indexOf(t);
            o !== -1 && r[n].splice(o, 1)
          }
        }
        class oe {
          constructor(t, r = {}) {
            ht(this, r), this.type = t
          }
        }
        class K extends oe {
          constructor(t, r = {}) {
            super("error", ht({
              error: t
            }, r))
          }
        }
        class he {
          on(t, r) {
            return this._listeners = this._listeners || {}, ye(t, r, this._listeners), {
              unsubscribe: () => {
                this.off(t, r)
              }
            }
          }
          off(t, r) {
            return Oe(t, r, this._listeners), Oe(t, r, this._oneTimeListeners), this
          }
          once(t, r) {
            return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, ye(t, r, this._oneTimeListeners), this) : new Promise((o => this.once(t, o)))
          }
          fire(t, r) {
            typeof t == "string" && (t = new oe(t, r || {}));
            const o = t.type;
            if (this.listens(o)) {
              t.target = this;
              const c = this._listeners && this._listeners[o] ? this._listeners[o].slice() : [];
              for (const y of c) y.call(this, t);
              const f = this._oneTimeListeners && this._oneTimeListeners[o] ? this._oneTimeListeners[o].slice() : [];
              for (const y of f) Oe(o, y, this._oneTimeListeners), y.call(this, t);
              const g = this._eventedParent;
              g && (ht(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), g.fire(t))
            } else t instanceof K && console.error(t.error);
            return this
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
          }
          setEventedParent(t, r) {
            return this._eventedParent = t, this._eventedParentData = r, this
          }
        }
        var Q = {
          $version: 8,
          $root: {
            version: {
              required: !0,
              type: "enum",
              values: [8]
            },
            name: {
              type: "string"
            },
            metadata: {
              type: "*"
            },
            center: {
              type: "array",
              value: "number"
            },
            centerAltitude: {
              type: "number"
            },
            zoom: {
              type: "number"
            },
            bearing: {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees"
            },
            pitch: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            roll: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            state: {
              type: "state",
              default: {}
            },
            light: {
              type: "light"
            },
            sky: {
              type: "sky"
            },
            projection: {
              type: "projection"
            },
            terrain: {
              type: "terrain"
            },
            sources: {
              required: !0,
              type: "sources"
            },
            sprite: {
              type: "sprite"
            },
            glyphs: {
              type: "string"
            },
            "font-faces": {
              type: "array",
              value: "fontFaces"
            },
            transition: {
              type: "transition"
            },
            layers: {
              required: !0,
              type: "array",
              value: "layer"
            }
          },
          sources: {
            "*": {
              type: "source"
            }
          },
          source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
          source_vector: {
            type: {
              required: !0,
              type: "enum",
              values: {
                vector: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            attribution: {
              type: "string"
            },
            promoteId: {
              type: "promoteId"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            encoding: {
              type: "enum",
              values: {
                mvt: {},
                mlt: {}
              },
              default: "mvt"
            },
            "*": {
              type: "*"
            }
          },
          source_raster: {
            type: {
              required: !0,
              type: "enum",
              values: {
                raster: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            attribution: {
              type: "string"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster_dem: {
            type: {
              required: !0,
              type: "enum",
              values: {
                "raster-dem": {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            attribution: {
              type: "string"
            },
            encoding: {
              type: "enum",
              values: {
                terrarium: {},
                mapbox: {},
                custom: {}
              },
              default: "mapbox"
            },
            redFactor: {
              type: "number",
              default: 1
            },
            blueFactor: {
              type: "number",
              default: 1
            },
            greenFactor: {
              type: "number",
              default: 1
            },
            baseShift: {
              type: "number",
              default: 0
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_geojson: {
            type: {
              required: !0,
              type: "enum",
              values: {
                geojson: {}
              }
            },
            data: {
              required: !0,
              type: "*"
            },
            maxzoom: {
              type: "number",
              default: 18
            },
            attribution: {
              type: "string"
            },
            buffer: {
              type: "number",
              default: 128,
              maximum: 512,
              minimum: 0
            },
            filter: {
              type: "*"
            },
            tolerance: {
              type: "number",
              default: .375
            },
            cluster: {
              type: "boolean",
              default: !1
            },
            clusterRadius: {
              type: "number",
              default: 50,
              minimum: 0
            },
            clusterMaxZoom: {
              type: "number"
            },
            clusterMinPoints: {
              type: "number"
            },
            clusterProperties: {
              type: "*"
            },
            lineMetrics: {
              type: "boolean",
              default: !1
            },
            generateId: {
              type: "boolean",
              default: !1
            },
            promoteId: {
              type: "promoteId"
            }
          },
          source_video: {
            type: {
              required: !0,
              type: "enum",
              values: {
                video: {}
              }
            },
            urls: {
              required: !0,
              type: "array",
              value: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          source_image: {
            type: {
              required: !0,
              type: "enum",
              values: {
                image: {}
              }
            },
            url: {
              required: !0,
              type: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          layer: {
            id: {
              type: "string",
              required: !0
            },
            type: {
              type: "enum",
              values: {
                fill: {},
                line: {},
                symbol: {},
                circle: {},
                heatmap: {},
                "fill-extrusion": {},
                raster: {},
                hillshade: {},
                "color-relief": {},
                background: {}
              },
              required: !0
            },
            metadata: {
              type: "*"
            },
            source: {
              type: "string"
            },
            "source-layer": {
              type: "string"
            },
            minzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            maxzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            filter: {
              type: "filter"
            },
            layout: {
              type: "layout"
            },
            paint: {
              type: "paint"
            }
          },
          layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
          layout_background: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_fill: {
            "fill-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_circle: {
            "circle-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_heatmap: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_fill-extrusion": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_line: {
            "line-cap": {
              type: "enum",
              values: {
                butt: {},
                round: {},
                square: {}
              },
              default: "butt",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-join": {
              type: "enum",
              values: {
                bevel: {},
                round: {},
                miter: {}
              },
              default: "miter",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "line-miter-limit": {
              type: "number",
              default: 2,
              requires: [{
                "line-join": "miter"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-round-limit": {
              type: "number",
              default: 1.05,
              requires: [{
                "line-join": "round"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_symbol: {
            "symbol-placement": {
              type: "enum",
              values: {
                point: {},
                line: {},
                "line-center": {}
              },
              default: "point",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-spacing": {
              type: "number",
              default: 250,
              minimum: 1,
              units: "pixels",
              requires: [{
                "symbol-placement": "line"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-avoid-edges": {
              type: "boolean",
              default: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "symbol-z-order": {
              type: "enum",
              values: {
                auto: {},
                "viewport-y": {},
                source: {}
              },
              default: "auto",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "!": "icon-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-optional": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-size": {
              type: "number",
              default: 1,
              minimum: 0,
              units: "factor of the original icon size",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-text-fit": {
              type: "enum",
              values: {
                none: {},
                width: {},
                height: {},
                both: {}
              },
              default: "none",
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-text-fit-padding": {
              type: "array",
              value: "number",
              length: 4,
              default: [0, 0, 0, 0],
              units: "pixels",
              requires: ["icon-image", "text-field", {
                "icon-text-fit": ["both", "width", "height"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-image": {
              type: "resolvedImage",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-padding": {
              type: "padding",
              default: [2],
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-keep-upright": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "icon-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-offset": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                "viewport-glyph": {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-field": {
              type: "formatted",
              default: "",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-font": {
              type: "array",
              value: "string",
              default: ["Open Sans Regular", "Arial Unicode MS Regular"],
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-size": {
              type: "number",
              default: 16,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-width": {
              type: "number",
              default: 10,
              minimum: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-line-height": {
              type: "number",
              default: 1.2,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-letter-spacing": {
              type: "number",
              default: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-justify": {
              type: "enum",
              values: {
                auto: {},
                left: {},
                center: {},
                right: {}
              },
              default: "center",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-radial-offset": {
              type: "number",
              units: "ems",
              default: 0,
              requires: ["text-field"],
              "property-type": "data-driven",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              }
            },
            "text-variable-anchor": {
              type: "array",
              value: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-variable-anchor-offset": {
              type: "variableAnchorOffsetCollection",
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["text-field", {
                "!": "text-variable-anchor"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-angle": {
              type: "number",
              default: 45,
              units: "degrees",
              requires: ["text-field", {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-writing-mode": {
              type: "array",
              value: "enum",
              values: {
                horizontal: {},
                vertical: {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-padding": {
              type: "number",
              default: 2,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-keep-upright": {
              type: "boolean",
              default: !0,
              requires: ["text-field", {
                "text-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-transform": {
              type: "enum",
              values: {
                none: {},
                uppercase: {},
                lowercase: {}
              },
              default: "none",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-offset": {
              type: "array",
              value: "number",
              units: "ems",
              length: 2,
              default: [0, 0],
              requires: ["text-field", {
                "!": "text-radial-offset"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["text-field", {
                "!": "text-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-optional": {
              type: "boolean",
              default: !1,
              requires: ["text-field", "icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_raster: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_hillshade: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_color-relief": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          filter: {
            type: "array",
            value: "*"
          },
          filter_operator: {
            type: "enum",
            values: {
              "==": {},
              "!=": {},
              ">": {},
              ">=": {},
              "<": {},
              "<=": {},
              in: {},
              "!in": {},
              all: {},
              any: {},
              none: {},
              has: {},
              "!has": {}
            }
          },
          geometry_type: {
            type: "enum",
            values: {
              Point: {},
              LineString: {},
              Polygon: {}
            }
          },
          function: {
            expression: {
              type: "expression"
            },
            stops: {
              type: "array",
              value: "function_stop"
            },
            base: {
              type: "number",
              default: 1,
              minimum: 0
            },
            property: {
              type: "string",
              default: "$zoom"
            },
            type: {
              type: "enum",
              values: {
                identity: {},
                exponential: {},
                interval: {},
                categorical: {}
              },
              default: "exponential"
            },
            colorSpace: {
              type: "enum",
              values: {
                rgb: {},
                lab: {},
                hcl: {}
              },
              default: "rgb"
            },
            default: {
              type: "*",
              required: !1
            }
          },
          function_stop: {
            type: "array",
            minimum: 0,
            maximum: 24,
            value: ["number", "color"],
            length: 2
          },
          expression: {
            type: "array",
            value: "*",
            minimum: 1
          },
          light: {
            anchor: {
              type: "enum",
              default: "viewport",
              values: {
                map: {},
                viewport: {}
              },
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              }
            },
            position: {
              type: "array",
              default: [1.15, 210, 30],
              length: 3,
              value: "number",
              "property-type": "data-constant",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            },
            color: {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            intensity: {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          sky: {
            "sky-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#88C6FC",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-ground-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-fog-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "sky-horizon-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "atmosphere-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          terrain: {
            source: {
              type: "string",
              required: !0
            },
            exaggeration: {
              type: "number",
              minimum: 0,
              default: 1
            }
          },
          projection: {
            type: {
              type: "projectionDefinition",
              default: "mercator",
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            }
          },
          paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
          paint_fill: {
            "fill-antialias": {
              type: "boolean",
              default: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-outline-color": {
              type: "color",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }, {
                "fill-antialias": !0
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            }
          },
          "paint_fill-extrusion": {
            "fill-extrusion-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-extrusion-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-extrusion-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "fill-extrusion-height": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-base": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              requires: ["fill-extrusion-height"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-vertical-gradient": {
              type: "boolean",
              default: !0,
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_line: {
            "line-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["line-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-width": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-gap-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-offset": {
              type: "number",
              default: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-dasharray": {
              type: "array",
              value: "number",
              minimum: 0,
              transition: !0,
              units: "line widths",
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-gradient": {
              type: "color",
              transition: !1,
              requires: [{
                "!": "line-dasharray"
              }, {
                "!": "line-pattern"
              }, {
                source: "geojson",
                has: {
                  lineMetrics: !0
                }
              }],
              expression: {
                interpolated: !0,
                parameters: ["line-progress"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_circle: {
            "circle-radius": {
              type: "number",
              default: 5,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-blur": {
              type: "number",
              default: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["circle-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-scale": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-stroke-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            }
          },
          paint_heatmap: {
            "heatmap-radius": {
              type: "number",
              default: 30,
              minimum: 1,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-weight": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-intensity": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "heatmap-color": {
              type: "color",
              default: ["interpolate", ["linear"],
                ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"
              ],
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["heatmap-density"]
              },
              "property-type": "color-ramp"
            },
            "heatmap-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_symbol: {
            "icon-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["icon-image", "icon-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              overridable: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["text-field", "text-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_raster: {
            "raster-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-hue-rotate": {
              type: "number",
              default: 0,
              period: 360,
              transition: !0,
              units: "degrees",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-min": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-max": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-saturation": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-contrast": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-resampling": {
              type: "enum",
              values: {
                linear: {},
                nearest: {}
              },
              default: "linear",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-fade-duration": {
              type: "number",
              default: 300,
              minimum: 0,
              transition: !1,
              units: "milliseconds",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_hillshade: {
            "hillshade-illumination-direction": {
              type: "numberArray",
              default: 335,
              minimum: 0,
              maximum: 359,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-altitude": {
              type: "numberArray",
              default: 45,
              minimum: 0,
              maximum: 90,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-exaggeration": {
              type: "number",
              default: .5,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-shadow-color": {
              type: "colorArray",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-highlight-color": {
              type: "colorArray",
              default: "#FFFFFF",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-accent-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-method": {
              type: "enum",
              values: {
                standard: {},
                basic: {},
                combined: {},
                igor: {},
                multidirectional: {}
              },
              default: "standard",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          "paint_color-relief": {
            "color-relief-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "color-relief-color": {
              type: "color",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["elevation"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_background: {
            "background-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "background-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "background-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "background-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          transition: {
            duration: {
              type: "number",
              default: 300,
              minimum: 0,
              units: "milliseconds"
            },
            delay: {
              type: "number",
              default: 0,
              minimum: 0,
              units: "milliseconds"
            }
          },
          "property-type": {
            "data-driven": {
              type: "property-type"
            },
            "cross-faded": {
              type: "property-type"
            },
            "cross-faded-data-driven": {
              type: "property-type"
            },
            "color-ramp": {
              type: "property-type"
            },
            "data-constant": {
              type: "property-type"
            },
            constant: {
              type: "property-type"
            }
          },
          promoteId: {
            "*": {
              type: "string"
            }
          }
        };
        const ze = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];

        function $e(n, t) {
          const r = {};
          for (const o in n) o !== "ref" && (r[o] = n[o]);
          return ze.forEach((o => {
            o in t && (r[o] = t[o])
          })), r
        }

        function Re(n, t) {
          if (Array.isArray(n)) {
            if (!Array.isArray(t) || n.length !== t.length) return !1;
            for (let r = 0; r < n.length; r++)
              if (!Re(n[r], t[r])) return !1;
            return !0
          }
          if (typeof n == "object" && n !== null && t !== null) {
            if (typeof t != "object" || Object.keys(n).length !== Object.keys(t).length) return !1;
            for (const r in n)
              if (!Re(n[r], t[r])) return !1;
            return !0
          }
          return n === t
        }

        function ft(n, t) {
          n.push(t)
        }

        function Mt(n, t, r) {
          ft(r, {
            command: "addSource",
            args: [n, t[n]]
          })
        }

        function Et(n, t, r) {
          ft(t, {
            command: "removeSource",
            args: [n]
          }), r[n] = !0
        }

        function dt(n, t, r, o) {
          Et(n, r, o), Mt(n, t, r)
        }

        function Kt(n, t, r) {
          let o;
          for (o in n[r])
            if (Object.prototype.hasOwnProperty.call(n[r], o) && o !== "data" && !Re(n[r][o], t[r][o])) return !1;
          for (o in t[r])
            if (Object.prototype.hasOwnProperty.call(t[r], o) && o !== "data" && !Re(n[r][o], t[r][o])) return !1;
          return !0
        }

        function Qt(n, t, r, o, c, f) {
          n = n || {}, t = t || {};
          for (const g in n) Object.prototype.hasOwnProperty.call(n, g) && (Re(n[g], t[g]) || r.push({
            command: f,
            args: [o, g, t[g], c]
          }));
          for (const g in t) Object.prototype.hasOwnProperty.call(t, g) && !Object.prototype.hasOwnProperty.call(n, g) && (Re(n[g], t[g]) || r.push({
            command: f,
            args: [o, g, t[g], c]
          }))
        }

        function Sr(n) {
          return n.id
        }

        function Ft(n, t) {
          return n[t.id] = t, n
        }
        class Ze {
          constructor(t, r, o, c) {
            this.message = (t ? `${t}: ` : "") + o, c && (this.identifier = c), r != null && r.__line__ && (this.line = r.__line__)
          }
        }

        function Pr(n, ...t) {
          for (const r of t)
            for (const o in r) n[o] = r[o];
          return n
        }
        class br extends Error {
          constructor(t, r) {
            super(r), this.message = r, this.key = t
          }
        }
        class Rr {
          constructor(t, r = []) {
            this.parent = t, this.bindings = {};
            for (const [o, c] of r) this.bindings[o] = c
          }
          concat(t) {
            return new Rr(this, t)
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`)
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t)
          }
        }
        const Dr = {
            kind: "null"
          },
          ot = {
            kind: "number"
          },
          dr = {
            kind: "string"
          },
          st = {
            kind: "boolean"
          },
          Tt = {
            kind: "color"
          },
          nr = {
            kind: "projectionDefinition"
          },
          Ur = {
            kind: "object"
          },
          Ot = {
            kind: "value"
          },
          Fr = {
            kind: "collator"
          },
          Xr = {
            kind: "formatted"
          },
          mn = {
            kind: "padding"
          },
          sn = {
            kind: "colorArray"
          },
          hn = {
            kind: "numberArray"
          },
          dn = {
            kind: "resolvedImage"
          },
          nn = {
            kind: "variableAnchorOffsetCollection"
          };

        function Ke(n, t) {
          return {
            kind: "array",
            itemType: n,
            N: t
          }
        }

        function St(n) {
          if (n.kind === "array") {
            const t = St(n.itemType);
            return typeof n.N == "number" ? `array<${t}, ${n.N}>` : n.itemType.kind === "value" ? "array" : `array<${t}>`
          }
          return n.kind
        }
        const kr = [Dr, ot, dr, st, Tt, nr, Xr, Ur, Ke(Ot), mn, hn, sn, dn, nn];

        function wr(n, t) {
          if (t.kind === "error") return null;
          if (n.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !wr(n.itemType, t.itemType)) && (typeof n.N != "number" || n.N === t.N)) return null
          } else {
            if (n.kind === t.kind) return null;
            if (n.kind === "value") {
              for (const r of kr)
                if (!wr(r, t)) return null
            }
          }
          return `Expected ${St(n)} but found ${St(t)} instead.`
        }

        function mr(n, t) {
          return t.some((r => r.kind === n.kind))
        }

        function Mr(n, t) {
          return t.some((r => r === "null" ? n === null : r === "array" ? Array.isArray(n) : r === "object" ? n && !Array.isArray(n) && typeof n == "object" : r === typeof n))
        }

        function gn(n, t) {
          return n.kind === "array" && t.kind === "array" ? n.itemType.kind === t.itemType.kind && typeof n.N == "number" : n.kind === t.kind
        }
        const Rn = .96422,
          ln = .82521,
          Gn = 4 / 29,
          On = 6 / 29,
          Wn = 3 * On * On,
          ti = On * On * On,
          Zn = Math.PI / 180,
          cn = 180 / Math.PI;

        function kn(n) {
          return (n %= 360) < 0 && (n += 360), n
        }

        function Xn([n, t, r, o]) {
          let c, f;
          const g = Ii((.2225045 * (n = Ri(n)) + .7168786 * (t = Ri(t)) + .0606169 * (r = Ri(r))) / 1);
          n === t && t === r ? c = f = g : (c = Ii((.4360747 * n + .3850649 * t + .1430804 * r) / Rn), f = Ii((.0139322 * n + .0971045 * t + .7141733 * r) / ln));
          const y = 116 * g - 16;
          return [y < 0 ? 0 : y, 500 * (c - g), 200 * (g - f), o]
        }

        function Ri(n) {
          return n <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4)
        }

        function Ii(n) {
          return n > ti ? Math.pow(n, 1 / 3) : n / Wn + Gn
        }

        function Vi([n, t, r, o]) {
          let c = (n + 16) / 116,
            f = isNaN(t) ? c : c + t / 500,
            g = isNaN(r) ? c : c - r / 200;
          return c = 1 * $t(c), f = Rn * $t(f), g = ln * $t(g), [pt(3.1338561 * f - 1.6168667 * c - .4906146 * g), pt(-.9787684 * f + 1.9161415 * c + .033454 * g), pt(.0719453 * f - .2289914 * c + 1.4052427 * g), o]
        }

        function pt(n) {
          return (n = n <= .00304 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055) < 0 ? 0 : n > 1 ? 1 : n
        }

        function $t(n) {
          return n > On ? n * n * n : Wn * (n - Gn)
        }
        const Or = Object.hasOwn || function(n, t) {
          return Object.prototype.hasOwnProperty.call(n, t)
        };

        function on(n, t) {
          return Or(n, t) ? n[t] : void 0
        }

        function Er(n) {
          return parseInt(n.padEnd(2, n), 16) / 255
        }

        function Hn(n, t) {
          return jn(t ? n / 100 : n, 0, 1)
        }

        function jn(n, t, r) {
          return Math.min(Math.max(t, n), r)
        }

        function Cn(n) {
          return !n.some(Number.isNaN)
        }
        const Yn = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        };

        function vr(n, t, r) {
          return n + r * (t - n)
        }

        function ar(n, t, r) {
          return n.map(((o, c) => vr(o, t[c], r)))
        }
        class gr {
          constructor(t, r, o, c = 1, f = !0) {
            this.r = t, this.g = r, this.b = o, this.a = c, f || (this.r *= c, this.g *= c, this.b *= c, c || this.overwriteGetter("rgb", [t, r, o, c]))
          }
          static parse(t) {
            if (t instanceof gr) return t;
            if (typeof t != "string") return;
            const r = (function(o) {
              if ((o = o.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const c = on(Yn, o);
              if (c) {
                const [g, y, w] = c;
                return [g / 255, y / 255, w / 255, 1]
              }
              if (o.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(o)) {
                const g = o.length < 6 ? 1 : 2;
                let y = 1;
                return [Er(o.slice(y, y += g)), Er(o.slice(y, y += g)), Er(o.slice(y, y += g)), Er(o.slice(y, y + g) || "ff")]
              }
              if (o.startsWith("rgb")) {
                const g = o.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (g) {
                  const [y, w, P, M, R, U, G, W, ne, se, ge, We] = g, Te = [M || " ", G || " ", se].join("");
                  if (Te === "  " || Te === "  /" || Te === ",," || Te === ",,,") {
                    const De = [P, U, ne].join(""),
                      nt = De === "%%%" ? 100 : De === "" ? 255 : 0;
                    if (nt) {
                      const gt = [jn(+w / nt, 0, 1), jn(+R / nt, 0, 1), jn(+W / nt, 0, 1), ge ? Hn(+ge, We) : 1];
                      if (Cn(gt)) return gt
                    }
                  }
                  return
                }
              }
              const f = o.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (f) {
                const [g, y, w, P, M, R, U, G, W] = f, ne = [w || " ", M || " ", U].join("");
                if (ne === "  " || ne === "  /" || ne === ",," || ne === ",,,") {
                  const se = [+y, jn(+P, 0, 100), jn(+R, 0, 100), G ? Hn(+G, W) : 1];
                  if (Cn(se)) return (function([ge, We, Te, De]) {
                    function nt(gt) {
                      const Vt = (gt + ge / 30) % 12,
                        pr = We * Math.min(Te, 1 - Te);
                      return Te - pr * Math.max(-1, Math.min(Vt - 3, 9 - Vt, 1))
                    }
                    return ge = kn(ge), We /= 100, Te /= 100, [nt(0), nt(8), nt(4), De]
                  })(se)
                }
              }
            })(t);
            return r ? new gr(...r, !1) : void 0
          }
          get rgb() {
            const {
              r: t,
              g: r,
              b: o,
              a: c
            } = this, f = c || 1 / 0;
            return this.overwriteGetter("rgb", [t / f, r / f, o / f, c])
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [r, o, c, f] = Xn(t), g = Math.sqrt(o * o + c * c);
              return [Math.round(1e4 * g) ? kn(Math.atan2(c, o) * cn) : NaN, g, r, f]
            })(this.rgb))
          }
          get lab() {
            return this.overwriteGetter("lab", Xn(this.rgb))
          }
          overwriteGetter(t, r) {
            return Object.defineProperty(this, t, {
              value: r
            }), r
          }
          toString() {
            const [t, r, o, c] = this.rgb;
            return `rgba(${[t,r,o].map((f=>Math.round(255*f))).join(",")},${c})`
          }
          static interpolate(t, r, o, c = "rgb") {
            switch (c) {
              case "rgb": {
                const [f, g, y, w] = ar(t.rgb, r.rgb, o);
                return new gr(f, g, y, w, !1)
              }
              case "hcl": {
                const [f, g, y, w] = t.hcl, [P, M, R, U] = r.hcl;
                let G, W;
                if (isNaN(f) || isNaN(P)) isNaN(f) ? isNaN(P) ? G = NaN : (G = P, y !== 1 && y !== 0 || (W = M)) : (G = f, R !== 1 && R !== 0 || (W = g));
                else {
                  let Te = P - f;
                  P > f && Te > 180 ? Te -= 360 : P < f && f - P > 180 && (Te += 360), G = f + o * Te
                }
                const [ne, se, ge, We] = (function([Te, De, nt, gt]) {
                  return Te = isNaN(Te) ? 0 : Te * Zn, Vi([nt, Math.cos(Te) * De, Math.sin(Te) * De, gt])
                })([G, W ?? vr(g, M, o), vr(y, R, o), vr(w, U, o)]);
                return new gr(ne, se, ge, We, !1)
              }
              case "lab": {
                const [f, g, y, w] = Vi(ar(t.lab, r.lab, o));
                return new gr(f, g, y, w, !1)
              }
            }
          }
        }
        gr.black = new gr(0, 0, 0, 1), gr.white = new gr(1, 1, 1, 1), gr.transparent = new gr(0, 0, 0, 0), gr.red = new gr(1, 0, 0, 1);
        class zr {
          constructor(t, r, o) {
            this.sensitivity = t ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = o, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
              sensitivity: this.sensitivity,
              usage: "search"
            })
          }
          compare(t, r) {
            return this.collator.compare(t, r)
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
          }
        }
        const Fn = ["bottom", "center", "top"];
        class xn {
          constructor(t, r, o, c, f, g) {
            this.text = t, this.image = r, this.scale = o, this.fontStack = c, this.textColor = f, this.verticalAlign = g
          }
        }
        class In {
          constructor(t) {
            this.sections = t
          }
          static fromString(t) {
            return new In([new xn(t, null, null, null, null, null)])
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t => t.text.length !== 0 || t.image && t.image.name.length !== 0))
          }
          static factory(t) {
            return t instanceof In ? t : In.fromString(t)
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t => t.text)).join("")
          }
        }
        class qn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof qn) return t;
            if (typeof t == "number") return new qn([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const r of t)
                if (typeof r != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]]
              }
              return new qn(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, o) {
            return new qn(ar(t.values, r.values, o))
          }
        }
        class $n {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof $n) return t;
            if (typeof t == "number") return new $n([t]);
            if (Array.isArray(t)) {
              for (const r of t)
                if (typeof r != "number") return;
              return new $n(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, o) {
            return new $n(ar(t.values, r.values, o))
          }
        }
        class Mn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Mn) return t;
            if (typeof t == "string") {
              const o = gr.parse(t);
              return o ? new Mn([o]) : void 0
            }
            if (!Array.isArray(t)) return;
            const r = [];
            for (const o of t) {
              if (typeof o != "string") return;
              const c = gr.parse(o);
              if (!c) return;
              r.push(c)
            }
            return new Mn(r)
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, o, c = "rgb") {
            const f = [];
            if (t.values.length != r.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${r.values.length}), cannot interpolate.`);
            for (let g = 0; g < t.values.length; g++) f.push(gr.interpolate(t.values[g], r.values[g], o, c));
            return new Mn(f)
          }
        }
        class Qr extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError"
          }
          toJSON() {
            return this.message
          }
        }
        const Tn = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Bn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Bn) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let r = 0; r < t.length; r += 2) {
                const o = t[r],
                  c = t[r + 1];
                if (typeof o != "string" || !Tn.has(o) || !Array.isArray(c) || c.length !== 2 || typeof c[0] != "number" || typeof c[1] != "number") return
              }
              return new Bn(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, o) {
            const c = t.values,
              f = r.values;
            if (c.length !== f.length) throw new Qr(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${r.toString()}`);
            const g = [];
            for (let y = 0; y < c.length; y += 2) {
              if (c[y] !== f[y]) throw new Qr(`Cannot interpolate values containing mismatched anchors. from[${y}]: ${c[y]}, to[${y}]: ${f[y]}`);
              g.push(c[y]);
              const [w, P] = c[y + 1], [M, R] = f[y + 1];
              g.push([vr(w, M, o), vr(P, R, o)])
            }
            return new Bn(g)
          }
        }
        class bn {
          constructor(t) {
            this.name = t.name, this.available = t.available
          }
          toString() {
            return this.name
          }
          static fromString(t) {
            return t ? new bn({
              name: t,
              available: !1
            }) : null
          }
        }
        class vn {
          constructor(t, r, o) {
            this.from = t, this.to = r, this.transition = o
          }
          static interpolate(t, r, o) {
            return new vn(t, r, o)
          }
          static parse(t) {
            return t instanceof vn ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new vn(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new vn(t.from, t.to, t.transition) : typeof t == "string" ? new vn(t, t, 1) : void 0
          }
        }

        function ii(n, t, r, o) {
          return typeof n == "number" && n >= 0 && n <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? o === void 0 || typeof o == "number" && o >= 0 && o <= 1 ? null : `Invalid rgba value [${[n,t,r,o].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof o=="number"?[n,t,r,o]:[n,t,r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }

        function Kn(n) {
          if (n === null || typeof n == "string" || typeof n == "boolean" || typeof n == "number" || n instanceof vn || n instanceof gr || n instanceof zr || n instanceof In || n instanceof qn || n instanceof $n || n instanceof Mn || n instanceof Bn || n instanceof bn) return !0;
          if (Array.isArray(n)) {
            for (const t of n)
              if (!Kn(t)) return !1;
            return !0
          }
          if (typeof n == "object") {
            for (const t in n)
              if (!Kn(n[t])) return !1;
            return !0
          }
          return !1
        }

        function Vn(n) {
          if (n === null) return Dr;
          if (typeof n == "string") return dr;
          if (typeof n == "boolean") return st;
          if (typeof n == "number") return ot;
          if (n instanceof gr) return Tt;
          if (n instanceof vn) return nr;
          if (n instanceof zr) return Fr;
          if (n instanceof In) return Xr;
          if (n instanceof qn) return mn;
          if (n instanceof $n) return hn;
          if (n instanceof Mn) return sn;
          if (n instanceof Bn) return nn;
          if (n instanceof bn) return dn;
          if (Array.isArray(n)) {
            const t = n.length;
            let r;
            for (const o of n) {
              const c = Vn(o);
              if (r) {
                if (r === c) continue;
                r = Ot;
                break
              }
              r = c
            }
            return Ke(r || Ot, t)
          }
          return Ur
        }

        function ga(n) {
          const t = typeof n;
          return n === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(n) : n instanceof gr || n instanceof vn || n instanceof In || n instanceof qn || n instanceof $n || n instanceof Mn || n instanceof Bn || n instanceof bn ? n.toString() : JSON.stringify(n)
        }
        class ta {
          constructor(t, r) {
            this.type = t, this.value = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (!Kn(t[1])) return r.error("invalid value");
            const o = t[1];
            let c = Vn(o);
            const f = r.expectedType;
            return c.kind !== "array" || c.N !== 0 || !f || f.kind !== "array" || typeof f.N == "number" && f.N !== 0 || (c = f), new ta(c, o)
          }
          evaluate() {
            return this.value
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        const Fi = {
          string: dr,
          number: ot,
          boolean: st,
          object: Ur
        };
        class zn {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let o, c = 1;
            const f = t[0];
            if (f === "array") {
              let y, w;
              if (t.length > 2) {
                const P = t[1];
                if (typeof P != "string" || !(P in Fi) || P === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
                y = Fi[P], c++
              } else y = Ot;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2);
                w = t[2], c++
              }
              o = Ke(y, w)
            } else {
              if (!Fi[f]) throw new Error(`Types doesn't contain name = ${f}`);
              o = Fi[f]
            }
            const g = [];
            for (; c < t.length; c++) {
              const y = r.parse(t[c], c, Ot);
              if (!y) return null;
              g.push(y)
            }
            return new zn(o, g)
          }
          evaluate(t) {
            for (let r = 0; r < this.args.length; r++) {
              const o = this.args[r].evaluate(t);
              if (!wr(this.type, Vn(o))) return o;
              if (r === this.args.length - 1) throw new Qr(`Expected value to be of type ${St(this.type)}, but found ${St(Vn(o))} instead.`)
            }
            throw new Error
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const ja = {
          "to-boolean": st,
          "to-color": Tt,
          "to-number": ot,
          "to-string": dr
        };
        class Sn {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const o = t[0];
            if (!ja[o]) throw new Error(`Can't parse ${o} as it is not part of the known types`);
            if ((o === "to-boolean" || o === "to-string") && t.length !== 2) return r.error("Expected one argument.");
            const c = ja[o],
              f = [];
            for (let g = 1; g < t.length; g++) {
              const y = r.parse(t[g], g, Ot);
              if (!y) return null;
              f.push(y)
            }
            return new Sn(c, f)
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let r, o;
                for (const c of this.args) {
                  if (r = c.evaluate(t), o = null, r instanceof gr) return r;
                  if (typeof r == "string") {
                    const f = t.parseColor(r);
                    if (f) return f
                  } else if (Array.isArray(r) && (o = r.length < 3 || r.length > 4 ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : ii(r[0], r[1], r[2], r[3]), !o)) return new gr(r[0] / 255, r[1] / 255, r[2] / 255, r[3])
                }
                throw new Qr(o || `Could not parse color from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "padding": {
                let r;
                for (const o of this.args) {
                  r = o.evaluate(t);
                  const c = qn.parse(r);
                  if (c) return c
                }
                throw new Qr(`Could not parse padding from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "numberArray": {
                let r;
                for (const o of this.args) {
                  r = o.evaluate(t);
                  const c = $n.parse(r);
                  if (c) return c
                }
                throw new Qr(`Could not parse numberArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "colorArray": {
                let r;
                for (const o of this.args) {
                  r = o.evaluate(t);
                  const c = Mn.parse(r);
                  if (c) return c
                }
                throw new Qr(`Could not parse colorArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "variableAnchorOffsetCollection": {
                let r;
                for (const o of this.args) {
                  r = o.evaluate(t);
                  const c = Bn.parse(r);
                  if (c) return c
                }
                throw new Qr(`Could not parse variableAnchorOffsetCollection from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "number": {
                let r = null;
                for (const o of this.args) {
                  if (r = o.evaluate(t), r === null) return 0;
                  const c = Number(r);
                  if (!isNaN(c)) return c
                }
                throw new Qr(`Could not convert ${JSON.stringify(r)} to number.`)
              }
              case "formatted":
                return In.fromString(ga(this.args[0].evaluate(t)));
              case "resolvedImage":
                return bn.fromString(ga(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return ga(this.args[0].evaluate(t))
            }
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const _n = ["Unknown", "Point", "LineString", "Polygon"];
        class Ta {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = new Map, this.availableImages = null, this.canonical = null
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? _n[this.feature.type] : this.feature.type : null
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null
          }
          canonicalID() {
            return this.canonical
          }
          properties() {
            return this.feature && this.feature.properties || {}
          }
          parseColor(t) {
            let r = this._parseColorCache.get(t);
            return r || (r = gr.parse(t), this._parseColorCache.set(t, r)), r
          }
        }
        class En {
          constructor(t, r, o = [], c, f = new Rr, g = []) {
            this.registry = t, this.path = o, this.key = o.map((y => `[${y}]`)).join(""), this.scope = f, this.errors = g, this.expectedType = c, this._isConstant = r
          }
          parse(t, r, o, c, f = {}) {
            return r ? this.concat(r, o, c)._parse(t, f) : this._parse(t, f)
          }
          _parse(t, r) {
            function o(c, f, g) {
              return g === "assert" ? new zn(f, [c]) : g === "coerce" ? new Sn(f, [c]) : c
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const c = t[0];
              if (typeof c != "string") return this.error(`Expression name must be a string, but found ${typeof c} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const f = this.registry[c];
              if (f) {
                let g = f.parse(t, this);
                if (!g) return null;
                if (this.expectedType) {
                  const y = this.expectedType,
                    w = g.type;
                  if (y.kind !== "string" && y.kind !== "number" && y.kind !== "boolean" && y.kind !== "object" && y.kind !== "array" || w.kind !== "value") {
                    if (y.kind === "projectionDefinition" && ["string", "array"].includes(w.kind) || ["color", "formatted", "resolvedImage"].includes(y.kind) && ["value", "string"].includes(w.kind) || ["padding", "numberArray"].includes(y.kind) && ["value", "number", "array"].includes(w.kind) || y.kind === "colorArray" && ["value", "string", "array"].includes(w.kind) || y.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(w.kind)) g = o(g, y, r.typeAnnotation || "coerce");
                    else if (this.checkSubtype(y, w)) return null
                  } else g = o(g, y, r.typeAnnotation || "assert")
                }
                if (!(g instanceof ta) && g.type.kind !== "resolvedImage" && this._isConstant(g)) {
                  const y = new Ta;
                  try {
                    g = new ta(g.type, g.evaluate(y))
                  } catch (w) {
                    return this.error(w.message), null
                  }
                }
                return g
              }
              return this.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0)
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
          }
          concat(t, r, o) {
            const c = typeof t == "number" ? this.path.concat(t) : this.path,
              f = o ? this.scope.concat(o) : this.scope;
            return new En(this.registry, this._isConstant, c, r || null, f, this.errors)
          }
          error(t, ...r) {
            const o = `${this.key}${r.map((c=>`[${c}]`)).join("")}`;
            this.errors.push(new br(o, t))
          }
          checkSubtype(t, r) {
            const o = wr(t, r);
            return o && this.error(o), o
          }
        }
        class qa {
          constructor(t, r) {
            this.type = r.type, this.bindings = [].concat(t), this.result = r
          }
          evaluate(t) {
            return this.result.evaluate(t)
          }
          eachChild(t) {
            for (const r of this.bindings) t(r[1]);
            t(this.result)
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);
            const o = [];
            for (let f = 1; f < t.length - 1; f += 2) {
              const g = t[f];
              if (typeof g != "string") return r.error(`Expected string, but found ${typeof g} instead.`, f);
              if (/[^a-zA-Z0-9_]/.test(g)) return r.error("Variable names must contain only alphanumeric characters or '_'.", f);
              const y = r.parse(t[f + 1], f + 1);
              if (!y) return null;
              o.push([g, y])
            }
            const c = r.parse(t[t.length - 1], t.length - 1, r.expectedType, o);
            return c ? new qa(o, c) : null
          }
          outputDefined() {
            return this.result.outputDefined()
          }
        }
        class Ui {
          constructor(t, r) {
            this.type = r.type, this.name = t, this.boundExpression = r
          }
          static parse(t, r) {
            if (t.length !== 2 || typeof t[1] != "string") return r.error("'var' expression requires exactly one string literal argument.");
            const o = t[1];
            return r.scope.has(o) ? new Ui(o, r.scope.get(o)) : r.error(`Unknown variable "${o}". Make sure "${o}" has been bound in an enclosing "let" expression before using it.`, 1)
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t)
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        class Va {
          constructor(t, r, o) {
            this.type = t, this.index = r, this.input = o
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const o = r.parse(t[1], 1, ot),
              c = r.parse(t[2], 2, Ke(r.expectedType || Ot));
            return o && c ? new Va(c.type.itemType, o, c) : null
          }
          evaluate(t) {
            const r = this.index.evaluate(t),
              o = this.input.evaluate(t);
            if (r < 0) throw new Qr(`Array index out of bounds: ${r} < 0.`);
            if (r >= o.length) throw new Qr(`Array index out of bounds: ${r} > ${o.length-1}.`);
            if (r !== Math.floor(r)) throw new Qr(`Array index must be an integer, but found ${r} instead.`);
            return o[r]
          }
          eachChild(t) {
            t(this.index), t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class ci {
          constructor(t, r) {
            this.type = st, this.needle = t, this.haystack = r
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const o = r.parse(t[1], 1, Ot),
              c = r.parse(t[2], 2, Ot);
            return o && c ? mr(o.type, [st, dr, ot, Dr, Ot]) ? new ci(o, c) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${St(o.type)} instead`) : null
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              o = this.haystack.evaluate(t);
            if (!o) return !1;
            if (!Mr(r, ["boolean", "string", "number", "null"])) throw new Qr(`Expected first argument to be of type boolean, string, number or null, but found ${St(Vn(r))} instead.`);
            if (!Mr(o, ["string", "array"])) throw new Qr(`Expected second argument to be of type array or string, but found ${St(Vn(o))} instead.`);
            return o.indexOf(r) >= 0
          }
          eachChild(t) {
            t(this.needle), t(this.haystack)
          }
          outputDefined() {
            return !0
          }
        }
        class wi {
          constructor(t, r, o) {
            this.type = ot, this.needle = t, this.haystack = r, this.fromIndex = o
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${t.length-1} instead.`);
            const o = r.parse(t[1], 1, Ot),
              c = r.parse(t[2], 2, Ot);
            if (!o || !c) return null;
            if (!mr(o.type, [st, dr, ot, Dr, Ot])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${St(o.type)} instead`);
            if (t.length === 4) {
              const f = r.parse(t[3], 3, ot);
              return f ? new wi(o, c, f) : null
            }
            return new wi(o, c)
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              o = this.haystack.evaluate(t);
            if (!Mr(r, ["boolean", "string", "number", "null"])) throw new Qr(`Expected first argument to be of type boolean, string, number or null, but found ${St(Vn(r))} instead.`);
            let c;
            if (this.fromIndex && (c = this.fromIndex.evaluate(t)), Mr(o, ["string"])) {
              const f = o.indexOf(r, c);
              return f === -1 ? -1 : [...o.slice(0, f)].length
            }
            if (Mr(o, ["array"])) return o.indexOf(r, c);
            throw new Qr(`Expected second argument to be of type array or string, but found ${St(Vn(o))} instead.`)
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex)
          }
          outputDefined() {
            return !1
          }
        }
        class sa {
          constructor(t, r, o, c, f, g) {
            this.inputType = t, this.type = r, this.input = o, this.cases = c, this.outputs = f, this.otherwise = g
          }
          static parse(t, r) {
            if (t.length < 5) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 1) return r.error("Expected an even number of arguments.");
            let o, c;
            r.expectedType && r.expectedType.kind !== "value" && (c = r.expectedType);
            const f = {},
              g = [];
            for (let P = 2; P < t.length - 1; P += 2) {
              let M = t[P];
              const R = t[P + 1];
              Array.isArray(M) || (M = [M]);
              const U = r.concat(P);
              if (M.length === 0) return U.error("Expected at least one branch label.");
              for (const W of M) {
                if (typeof W != "number" && typeof W != "string") return U.error("Branch labels must be numbers or strings.");
                if (typeof W == "number" && Math.abs(W) > Number.MAX_SAFE_INTEGER) return U.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof W == "number" && Math.floor(W) !== W) return U.error("Numeric branch labels must be integer values.");
                if (o) {
                  if (U.checkSubtype(o, Vn(W))) return null
                } else o = Vn(W);
                if (f[String(W)] !== void 0) return U.error("Branch labels must be unique.");
                f[String(W)] = g.length
              }
              const G = r.parse(R, P, c);
              if (!G) return null;
              c = c || G.type, g.push(G)
            }
            const y = r.parse(t[1], 1, Ot);
            if (!y) return null;
            const w = r.parse(t[t.length - 1], t.length - 1, c);
            return w ? y.type.kind !== "value" && r.concat(1).checkSubtype(o, y.type) ? null : new sa(o, c, y, f, g, w) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            return (Vn(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(t)
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class Ra {
          constructor(t, r, o) {
            this.type = t, this.branches = r, this.otherwise = o
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 0) return r.error("Expected an odd number of arguments.");
            let o;
            r.expectedType && r.expectedType.kind !== "value" && (o = r.expectedType);
            const c = [];
            for (let g = 1; g < t.length - 1; g += 2) {
              const y = r.parse(t[g], g, st);
              if (!y) return null;
              const w = r.parse(t[g + 1], g + 1, o);
              if (!w) return null;
              c.push([y, w]), o = o || w.type
            }
            const f = r.parse(t[t.length - 1], t.length - 1, o);
            if (!f) return null;
            if (!o) throw new Error("Can't infer output type");
            return new Ra(o, c, f)
          }
          evaluate(t) {
            for (const [r, o] of this.branches)
              if (r.evaluate(t)) return o.evaluate(t);
            return this.otherwise.evaluate(t)
          }
          eachChild(t) {
            for (const [r, o] of this.branches) t(r), t(o);
            t(this.otherwise)
          }
          outputDefined() {
            return this.branches.every((([t, r]) => r.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class Sa {
          constructor(t, r, o, c) {
            this.type = t, this.input = r, this.beginIndex = o, this.endIndex = c
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${t.length-1} instead.`);
            const o = r.parse(t[1], 1, Ot),
              c = r.parse(t[2], 2, ot);
            if (!o || !c) return null;
            if (!mr(o.type, [Ke(Ot), dr, Ot])) return r.error(`Expected first argument to be of type array or string, but found ${St(o.type)} instead`);
            if (t.length === 4) {
              const f = r.parse(t[3], 3, ot);
              return f ? new Sa(o.type, o, c, f) : null
            }
            return new Sa(o.type, o, c)
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              o = this.beginIndex.evaluate(t);
            let c;
            if (this.endIndex && (c = this.endIndex.evaluate(t)), Mr(r, ["string"])) return [...r].slice(o, c).join("");
            if (Mr(r, ["array"])) return r.slice(o, c);
            throw new Qr(`Expected first argument to be of type array or string, but found ${St(Vn(r))} instead.`)
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex)
          }
          outputDefined() {
            return !1
          }
        }

        function la(n, t) {
          const r = n.length - 1;
          let o, c, f = 0,
            g = r,
            y = 0;
          for (; f <= g;)
            if (y = Math.floor((f + g) / 2), o = n[y], c = n[y + 1], o <= t) {
              if (y === r || t < c) return y;
              f = y + 1
            } else {
              if (!(o > t)) throw new Qr("Input is not a number.");
              g = y - 1
            } return 0
        }
        class eo {
          constructor(t, r, o) {
            this.type = t, this.input = r, this.labels = [], this.outputs = [];
            for (const [c, f] of o) this.labels.push(c), this.outputs.push(f)
          }
          static parse(t, r) {
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            const o = r.parse(t[1], 1, ot);
            if (!o) return null;
            const c = [];
            let f = null;
            r.expectedType && r.expectedType.kind !== "value" && (f = r.expectedType);
            for (let g = 1; g < t.length; g += 2) {
              const y = g === 1 ? -1 / 0 : t[g],
                w = t[g + 1],
                P = g,
                M = g + 1;
              if (typeof y != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', P);
              if (c.length && c[c.length - 1][0] >= y) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', P);
              const R = r.parse(w, M, f);
              if (!R) return null;
              f = f || R.type, c.push([y, R])
            }
            return new eo(f, o, c)
          }
          evaluate(t) {
            const r = this.labels,
              o = this.outputs;
            if (r.length === 1) return o[0].evaluate(t);
            const c = this.input.evaluate(t);
            if (c <= r[0]) return o[0].evaluate(t);
            const f = r.length;
            return c >= r[f - 1] ? o[f - 1].evaluate(t) : o[la(r, c)].evaluate(t)
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function ca(n) {
          return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
        }
        var Ti, Zo, rd = (function() {
            if (Zo) return Ti;

            function n(t, r, o, c) {
              this.cx = 3 * t, this.bx = 3 * (o - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (c - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = o, this.p2y = c
            }
            return Zo = 1, Ti = n, n.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var o = t, c = 0; c < 8; c++) {
                  var f = this.sampleCurveX(o) - t;
                  if (Math.abs(f) < r) return o;
                  var g = this.sampleCurveDerivativeX(o);
                  if (Math.abs(g) < 1e-6) break;
                  o -= f / g
                }
                var y = 0,
                  w = 1;
                for (o = t, c = 0; c < 20 && (f = this.sampleCurveX(o), !(Math.abs(f - t) < r)); c++) t > f ? y = o : w = o, o = .5 * (w - y) + y;
                return o
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, Ti
          })(),
          Al = ca(rd);
        class Qn {
          constructor(t, r, o, c, f) {
            this.type = t, this.operator = r, this.interpolation = o, this.input = c, this.labels = [], this.outputs = [];
            for (const [g, y] of f) this.labels.push(g), this.outputs.push(y)
          }
          static interpolationFactor(t, r, o, c) {
            let f = 0;
            if (t.name === "exponential") f = kl(r, t.base, o, c);
            else if (t.name === "linear") f = kl(r, 1, o, c);
            else if (t.name === "cubic-bezier") {
              const g = t.controlPoints;
              f = new Al(g[0], g[1], g[2], g[3]).solve(kl(r, 1, o, c))
            }
            return f
          }
          static parse(t, r) {
            let [o, c, f, ...g] = t;
            if (!Array.isArray(c) || c.length === 0) return r.error("Expected an interpolation type expression.", 1);
            if (c[0] === "linear") c = {
              name: "linear"
            };
            else if (c[0] === "exponential") {
              const P = c[1];
              if (typeof P != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1);
              c = {
                name: "exponential",
                base: P
              }
            } else {
              if (c[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(c[0])}`, 1, 0);
              {
                const P = c.slice(1);
                if (P.length !== 4 || P.some((M => typeof M != "number" || M < 0 || M > 1))) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                c = {
                  name: "cubic-bezier",
                  controlPoints: P
                }
              }
            }
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            if (f = r.parse(f, 2, ot), !f) return null;
            const y = [];
            let w = null;
            o !== "interpolate-hcl" && o !== "interpolate-lab" || r.expectedType == sn ? r.expectedType && r.expectedType.kind !== "value" && (w = r.expectedType) : w = Tt;
            for (let P = 0; P < g.length; P += 2) {
              const M = g[P],
                R = g[P + 1],
                U = P + 3,
                G = P + 4;
              if (typeof M != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', U);
              if (y.length && y[y.length - 1][0] >= M) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', U);
              const W = r.parse(R, G, w);
              if (!W) return null;
              w = w || W.type, y.push([M, W])
            }
            return gn(w, ot) || gn(w, nr) || gn(w, Tt) || gn(w, mn) || gn(w, hn) || gn(w, sn) || gn(w, nn) || gn(w, Ke(ot)) ? new Qn(w, o, c, f, y) : r.error(`Type ${St(w)} is not interpolatable.`)
          }
          evaluate(t) {
            const r = this.labels,
              o = this.outputs;
            if (r.length === 1) return o[0].evaluate(t);
            const c = this.input.evaluate(t);
            if (c <= r[0]) return o[0].evaluate(t);
            const f = r.length;
            if (c >= r[f - 1]) return o[f - 1].evaluate(t);
            const g = la(r, c),
              y = Qn.interpolationFactor(this.interpolation, c, r[g], r[g + 1]),
              w = o[g].evaluate(t),
              P = o[g + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return vr(w, P, y);
                  case "color":
                    return gr.interpolate(w, P, y);
                  case "padding":
                    return qn.interpolate(w, P, y);
                  case "colorArray":
                    return Mn.interpolate(w, P, y);
                  case "numberArray":
                    return $n.interpolate(w, P, y);
                  case "variableAnchorOffsetCollection":
                    return Bn.interpolate(w, P, y);
                  case "array":
                    return ar(w, P, y);
                  case "projectionDefinition":
                    return vn.interpolate(w, P, y)
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return gr.interpolate(w, P, y, "hcl");
                  case "colorArray":
                    return Mn.interpolate(w, P, y, "hcl")
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return gr.interpolate(w, P, y, "lab");
                  case "colorArray":
                    return Mn.interpolate(w, P, y, "lab")
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function kl(n, t, r, o) {
          const c = o - r,
            f = n - r;
          return c === 0 ? 0 : t === 1 ? f / c : (Math.pow(t, f) - 1) / (Math.pow(t, c) - 1)
        }
        const Fa = {
          color: gr.interpolate,
          number: vr,
          padding: qn.interpolate,
          numberArray: $n.interpolate,
          colorArray: Mn.interpolate,
          variableAnchorOffsetCollection: Bn.interpolate,
          array: ar
        };
        class Ws {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let o = null;
            const c = r.expectedType;
            c && c.kind !== "value" && (o = c);
            const f = [];
            for (const y of t.slice(1)) {
              const w = r.parse(y, 1 + f.length, o, void 0, {
                typeAnnotation: "omit"
              });
              if (!w) return null;
              o = o || w.type, f.push(w)
            }
            if (!o) throw new Error("No output type");
            const g = c && f.some((y => wr(c, y.type)));
            return new Ws(g ? Ot : o, f)
          }
          evaluate(t) {
            let r, o = null,
              c = 0;
            for (const f of this.args)
              if (c++, o = f.evaluate(t), o && o instanceof bn && !o.available && (r || (r = o.name), o = null, c === this.args.length && (o = r)), o !== null) break;
            return o
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }

        function nd(n, t) {
          return n === "==" || n === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
        }

        function Go(n, t, r, o) {
          return o.compare(t, r) === 0
        }

        function ho(n, t, r) {
          const o = n !== "==" && n !== "!=";
          return class oy {
            constructor(f, g, y) {
              this.type = st, this.lhs = f, this.rhs = g, this.collator = y, this.hasUntypedArgument = f.type.kind === "value" || g.type.kind === "value"
            }
            static parse(f, g) {
              if (f.length !== 3 && f.length !== 4) return g.error("Expected two or three arguments.");
              const y = f[0];
              let w = g.parse(f[1], 1, Ot);
              if (!w) return null;
              if (!nd(y, w.type)) return g.concat(1).error(`"${y}" comparisons are not supported for type '${St(w.type)}'.`);
              let P = g.parse(f[2], 2, Ot);
              if (!P) return null;
              if (!nd(y, P.type)) return g.concat(2).error(`"${y}" comparisons are not supported for type '${St(P.type)}'.`);
              if (w.type.kind !== P.type.kind && w.type.kind !== "value" && P.type.kind !== "value") return g.error(`Cannot compare types '${St(w.type)}' and '${St(P.type)}'.`);
              o && (w.type.kind === "value" && P.type.kind !== "value" ? w = new zn(P.type, [w]) : w.type.kind !== "value" && P.type.kind === "value" && (P = new zn(w.type, [P])));
              let M = null;
              if (f.length === 4) {
                if (w.type.kind !== "string" && P.type.kind !== "string" && w.type.kind !== "value" && P.type.kind !== "value") return g.error("Cannot use collator to compare non-string types.");
                if (M = g.parse(f[3], 3, Fr), !M) return null
              }
              return new oy(w, P, M)
            }
            evaluate(f) {
              const g = this.lhs.evaluate(f),
                y = this.rhs.evaluate(f);
              if (o && this.hasUntypedArgument) {
                const w = Vn(g),
                  P = Vn(y);
                if (w.kind !== P.kind || w.kind !== "string" && w.kind !== "number") throw new Qr(`Expected arguments for "${n}" to be (string, string) or (number, number), but found (${w.kind}, ${P.kind}) instead.`)
              }
              if (this.collator && !o && this.hasUntypedArgument) {
                const w = Vn(g),
                  P = Vn(y);
                if (w.kind !== "string" || P.kind !== "string") return t(f, g, y)
              }
              return this.collator ? r(f, g, y, this.collator.evaluate(f)) : t(f, g, y)
            }
            eachChild(f) {
              f(this.lhs), f(this.rhs), this.collator && f(this.collator)
            }
            outputDefined() {
              return !0
            }
          }
        }
        const Uc = ho("==", (function(n, t, r) {
            return t === r
          }), Go),
          sf = ho("!=", (function(n, t, r) {
            return t !== r
          }), (function(n, t, r, o) {
            return !Go(0, t, r, o)
          })),
          id = ho("<", (function(n, t, r) {
            return t < r
          }), (function(n, t, r, o) {
            return o.compare(t, r) < 0
          })),
          El = ho(">", (function(n, t, r) {
            return t > r
          }), (function(n, t, r, o) {
            return o.compare(t, r) > 0
          })),
          Ll = ho("<=", (function(n, t, r) {
            return t <= r
          }), (function(n, t, r, o) {
            return o.compare(t, r) <= 0
          })),
          Ua = ho(">=", (function(n, t, r) {
            return t >= r
          }), (function(n, t, r, o) {
            return o.compare(t, r) >= 0
          }));
        class $s {
          constructor(t, r, o) {
            this.type = Fr, this.locale = o, this.caseSensitive = t, this.diacriticSensitive = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected one argument.");
            const o = t[1];
            if (typeof o != "object" || Array.isArray(o)) return r.error("Collator options argument must be an object.");
            const c = r.parse(o["case-sensitive"] !== void 0 && o["case-sensitive"], 1, st);
            if (!c) return null;
            const f = r.parse(o["diacritic-sensitive"] !== void 0 && o["diacritic-sensitive"], 1, st);
            if (!f) return null;
            let g = null;
            return o.locale && (g = r.parse(o.locale, 1, dr), !g) ? null : new $s(c, f, g)
          }
          evaluate(t) {
            return new zr(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null)
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale)
          }
          outputDefined() {
            return !1
          }
        }
        class Ts {
          constructor(t, r, o, c, f) {
            this.type = dr, this.number = t, this.locale = r, this.currency = o, this.minFractionDigits = c, this.maxFractionDigits = f
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error("Expected two arguments.");
            const o = r.parse(t[1], 1, ot);
            if (!o) return null;
            const c = t[2];
            if (typeof c != "object" || Array.isArray(c)) return r.error("NumberFormat options argument must be an object.");
            let f = null;
            if (c.locale && (f = r.parse(c.locale, 1, dr), !f)) return null;
            let g = null;
            if (c.currency && (g = r.parse(c.currency, 1, dr), !g)) return null;
            let y = null;
            if (c["min-fraction-digits"] && (y = r.parse(c["min-fraction-digits"], 1, ot), !y)) return null;
            let w = null;
            return c["max-fraction-digits"] && (w = r.parse(c["max-fraction-digits"], 1, ot), !w) ? null : new Ts(o, f, g, y, w)
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
              style: this.currency ? "currency" : "decimal",
              currency: this.currency ? this.currency.evaluate(t) : void 0,
              minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
              maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
            }).format(this.number.evaluate(t))
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits)
          }
          outputDefined() {
            return !1
          }
        }
        class zl {
          constructor(t) {
            this.type = Xr, this.sections = t
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const o = t[1];
            if (!Array.isArray(o) && typeof o == "object") return r.error("First argument must be an image or text section.");
            const c = [];
            let f = !1;
            for (let g = 1; g <= t.length - 1; ++g) {
              const y = t[g];
              if (f && typeof y == "object" && !Array.isArray(y)) {
                f = !1;
                let w = null;
                if (y["font-scale"] && (w = r.parse(y["font-scale"], 1, ot), !w)) return null;
                let P = null;
                if (y["text-font"] && (P = r.parse(y["text-font"], 1, Ke(dr)), !P)) return null;
                let M = null;
                if (y["text-color"] && (M = r.parse(y["text-color"], 1, Tt), !M)) return null;
                let R = null;
                if (y["vertical-align"]) {
                  if (typeof y["vertical-align"] == "string" && !Fn.includes(y["vertical-align"])) return r.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${y["vertical-align"]}' instead.`);
                  if (R = r.parse(y["vertical-align"], 1, dr), !R) return null
                }
                const U = c[c.length - 1];
                U.scale = w, U.font = P, U.textColor = M, U.verticalAlign = R
              } else {
                const w = r.parse(t[g], 1, Ot);
                if (!w) return null;
                const P = w.type.kind;
                if (P !== "string" && P !== "value" && P !== "null" && P !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                f = !0, c.push({
                  content: w,
                  scale: null,
                  font: null,
                  textColor: null,
                  verticalAlign: null
                })
              }
            }
            return new zl(c)
          }
          evaluate(t) {
            return new In(this.sections.map((r => {
              const o = r.content.evaluate(t);
              return Vn(o) === dn ? new xn("", o, null, null, null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null) : new xn(ga(o), null, r.scale ? r.scale.evaluate(t) : null, r.font ? r.font.evaluate(t).join(",") : null, r.textColor ? r.textColor.evaluate(t) : null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null)
            })))
          }
          eachChild(t) {
            for (const r of this.sections) t(r.content), r.scale && t(r.scale), r.font && t(r.font), r.textColor && t(r.textColor), r.verticalAlign && t(r.verticalAlign)
          }
          outputDefined() {
            return !1
          }
        }
        class Xs {
          constructor(t) {
            this.type = dn, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected two arguments.");
            const o = r.parse(t[1], 1, dr);
            return o ? new Xs(o) : r.error("No image name provided.")
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              o = bn.fromString(r);
            return o && t.availableImages && (o.available = t.availableImages.indexOf(r) > -1), o
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class Zc {
          constructor(t) {
            this.type = ot, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const o = r.parse(t[1], 1);
            return o ? o.type.kind !== "array" && o.type.kind !== "string" && o.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${St(o.type)} instead.`) : new Zc(o) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            if (typeof r == "string") return [...r].length;
            if (Array.isArray(r)) return r.length;
            throw new Qr(`Expected value to be of type string or array, but found ${St(Vn(r))} instead.`)
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        const to = 8192;

        function lf(n, t) {
          const r = (180 + n[0]) / 360,
            o = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n[1] * Math.PI / 360))) / 360,
            c = Math.pow(2, t.z);
          return [Math.round(r * c * to), Math.round(o * c * to)]
        }

        function Gc(n, t) {
          const r = Math.pow(2, t.z);
          return [(c = (n[0] / to + t.x) / r, 360 * c - 180), (o = (n[1] / to + t.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * o) * Math.PI / 180)) - 90)];
          var o, c
        }

        function Eo(n, t) {
          n[0] = Math.min(n[0], t[0]), n[1] = Math.min(n[1], t[1]), n[2] = Math.max(n[2], t[0]), n[3] = Math.max(n[3], t[1])
        }

        function Ys(n, t) {
          return !(n[0] <= t[0] || n[2] >= t[2] || n[1] <= t[1] || n[3] >= t[3])
        }

        function ad(n, t, r) {
          const o = n[0] - t[0],
            c = n[1] - t[1],
            f = n[0] - r[0],
            g = n[1] - r[1];
          return o * g - f * c == 0 && o * f <= 0 && c * g <= 0
        }

        function Ks(n, t, r, o) {
          return (c = [o[0] - r[0], o[1] - r[1]])[0] * (f = [t[0] - n[0], t[1] - n[1]])[1] - c[1] * f[0] != 0 && !(!sd(n, t, r, o) || !sd(r, o, n, t));
          var c, f
        }

        function cf(n, t, r) {
          for (const o of r)
            for (let c = 0; c < o.length - 1; ++c)
              if (Ks(n, t, o[c], o[c + 1])) return !0;
          return !1
        }

        function Ho(n, t, r = !1) {
          let o = !1;
          for (const y of t)
            for (let w = 0; w < y.length - 1; w++) {
              if (ad(n, y[w], y[w + 1])) return r;
              (f = y[w])[1] > (c = n)[1] != (g = y[w + 1])[1] > c[1] && c[0] < (g[0] - f[0]) * (c[1] - f[1]) / (g[1] - f[1]) + f[0] && (o = !o)
            }
          var c, f, g;
          return o
        }

        function uf(n, t) {
          for (const r of t)
            if (Ho(n, r)) return !0;
          return !1
        }

        function od(n, t) {
          for (const r of n)
            if (!Ho(r, t)) return !1;
          for (let r = 0; r < n.length - 1; ++r)
            if (cf(n[r], n[r + 1], t)) return !1;
          return !0
        }

        function hf(n, t) {
          for (const r of t)
            if (od(n, r)) return !0;
          return !1
        }

        function sd(n, t, r, o) {
          const c = o[0] - r[0],
            f = o[1] - r[1],
            g = (n[0] - r[0]) * f - c * (n[1] - r[1]),
            y = (t[0] - r[0]) * f - c * (t[1] - r[1]);
          return g > 0 && y < 0 || g < 0 && y > 0
        }

        function Hc(n, t, r) {
          const o = [];
          for (let c = 0; c < n.length; c++) {
            const f = [];
            for (let g = 0; g < n[c].length; g++) {
              const y = lf(n[c][g], r);
              Eo(t, y), f.push(y)
            }
            o.push(f)
          }
          return o
        }

        function Wc(n, t, r) {
          const o = [];
          for (let c = 0; c < n.length; c++) {
            const f = Hc(n[c], t, r);
            o.push(f)
          }
          return o
        }

        function $c(n, t, r, o) {
          if (n[0] < r[0] || n[0] > r[2]) {
            const c = .5 * o;
            let f = n[0] - r[0] > c ? -o : r[0] - n[0] > c ? o : 0;
            f === 0 && (f = n[0] - r[2] > c ? -o : r[2] - n[0] > c ? o : 0), n[0] += f
          }
          Eo(t, n)
        }

        function Xc(n, t, r, o) {
          const c = Math.pow(2, o.z) * to,
            f = [o.x * to, o.y * to],
            g = [];
          for (const y of n)
            for (const w of y) {
              const P = [w.x + f[0], w.y + f[1]];
              $c(P, t, r, c), g.push(P)
            }
          return g
        }

        function ld(n, t, r, o) {
          const c = Math.pow(2, o.z) * to,
            f = [o.x * to, o.y * to],
            g = [];
          for (const w of n) {
            const P = [];
            for (const M of w) {
              const R = [M.x + f[0], M.y + f[1]];
              Eo(t, R), P.push(R)
            }
            g.push(P)
          }
          if (t[2] - t[0] <= c / 2) {
            (y = t)[0] = y[1] = 1 / 0, y[2] = y[3] = -1 / 0;
            for (const w of g)
              for (const P of w) $c(P, t, r, c)
          }
          var y;
          return g
        }
        class Wo {
          constructor(t, r) {
            this.type = st, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Kn(t[1])) {
              const o = t[1];
              if (o.type === "FeatureCollection") {
                const c = [];
                for (const f of o.features) {
                  const {
                    type: g,
                    coordinates: y
                  } = f.geometry;
                  g === "Polygon" && c.push(y), g === "MultiPolygon" && c.push(...y)
                }
                if (c.length) return new Wo(o, {
                  type: "MultiPolygon",
                  coordinates: c
                })
              } else if (o.type === "Feature") {
                const c = o.geometry.type;
                if (c === "Polygon" || c === "MultiPolygon") return new Wo(o, o.geometry)
              } else if (o.type === "Polygon" || o.type === "MultiPolygon") return new Wo(o, o)
            }
            return r.error("'within' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, o) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  g = r.canonicalID();
                if (o.type === "Polygon") {
                  const y = Hc(o.coordinates, f, g),
                    w = Xc(r.geometry(), c, f, g);
                  if (!Ys(c, f)) return !1;
                  for (const P of w)
                    if (!Ho(P, y)) return !1
                }
                if (o.type === "MultiPolygon") {
                  const y = Wc(o.coordinates, f, g),
                    w = Xc(r.geometry(), c, f, g);
                  if (!Ys(c, f)) return !1;
                  for (const P of w)
                    if (!uf(P, y)) return !1
                }
                return !0
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, o) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  g = r.canonicalID();
                if (o.type === "Polygon") {
                  const y = Hc(o.coordinates, f, g),
                    w = ld(r.geometry(), c, f, g);
                  if (!Ys(c, f)) return !1;
                  for (const P of w)
                    if (!od(P, y)) return !1
                }
                if (o.type === "MultiPolygon") {
                  const y = Wc(o.coordinates, f, g),
                    w = ld(r.geometry(), c, f, g);
                  if (!Ys(c, f)) return !1;
                  for (const P of w)
                    if (!hf(P, y)) return !1
                }
                return !0
              })(t, this.geometries)
            }
            return !1
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        let cd = class {
          constructor(n = [], t = (r, o) => r < o ? -1 : r > o ? 1 : 0) {
            if (this.data = n, this.length = this.data.length, this.compare = t, this.length > 0)
              for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r)
          }
          push(n) {
            this.data.push(n), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const n = this.data[0],
              t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), n
          }
          peek() {
            return this.data[0]
          }
          _up(n) {
            const {
              data: t,
              compare: r
            } = this, o = t[n];
            for (; n > 0;) {
              const c = n - 1 >> 1,
                f = t[c];
              if (r(o, f) >= 0) break;
              t[n] = f, n = c
            }
            t[n] = o
          }
          _down(n) {
            const {
              data: t,
              compare: r
            } = this, o = this.length >> 1, c = t[n];
            for (; n < o;) {
              let f = 1 + (n << 1);
              const g = f + 1;
              if (g < this.length && r(t[g], t[f]) < 0 && (f = g), r(t[f], c) >= 0) break;
              t[n] = t[f], n = f
            }
            t[n] = c
          }
        };

        function ud(n, t, r = 0, o = n.length - 1, c = df) {
          for (; o > r;) {
            if (o - r > 600) {
              const w = o - r + 1,
                P = t - r + 1,
                M = Math.log(w),
                R = .5 * Math.exp(2 * M / 3),
                U = .5 * Math.sqrt(M * R * (w - R) / w) * (P - w / 2 < 0 ? -1 : 1);
              ud(n, t, Math.max(r, Math.floor(t - P * R / w + U)), Math.min(o, Math.floor(t + (w - P) * R / w + U)), c)
            }
            const f = n[t];
            let g = r,
              y = o;
            for (Lo(n, r, t), c(n[o], f) > 0 && Lo(n, r, o); g < y;) {
              for (Lo(n, g, y), g++, y--; c(n[g], f) < 0;) g++;
              for (; c(n[y], f) > 0;) y--
            }
            c(n[r], f) === 0 ? Lo(n, r, y) : (y++, Lo(n, y, o)), y <= t && (r = y + 1), t <= y && (o = y - 1)
          }
        }

        function Lo(n, t, r) {
          const o = n[t];
          n[t] = n[r], n[r] = o
        }

        function df(n, t) {
          return n < t ? -1 : n > t ? 1 : 0
        }

        function Dl(n, t) {
          if (n.length <= 1) return [n];
          const r = [];
          let o, c;
          for (const f of n) {
            const g = ff(f);
            g !== 0 && (f.area = Math.abs(g), c === void 0 && (c = g < 0), c === g < 0 ? (o && r.push(o), o = [f]) : o.push(f))
          }
          if (o && r.push(o), t > 1)
            for (let f = 0; f < r.length; f++) r[f].length <= t || (ud(r[f], t, 1, r[f].length - 1, pf), r[f] = r[f].slice(0, t));
          return r
        }

        function pf(n, t) {
          return t.area - n.area
        }

        function ff(n) {
          let t = 0;
          for (let r, o, c = 0, f = n.length, g = f - 1; c < f; g = c++) r = n[c], o = n[g], t += (o.x - r.x) * (r.y + o.y);
          return t
        }
        const Rl = 1 / 298.257223563,
          Yc = Rl * (2 - Rl),
          hd = Math.PI / 180;
        class Kc {
          constructor(t) {
            const r = 6378.137 * hd * 1e3,
              o = Math.cos(t * hd),
              c = 1 / (1 - Yc * (1 - o * o)),
              f = Math.sqrt(c);
            this.kx = r * f * o, this.ky = r * f * c * (1 - Yc)
          }
          distance(t, r) {
            const o = this.wrap(t[0] - r[0]) * this.kx,
              c = (t[1] - r[1]) * this.ky;
            return Math.sqrt(o * o + c * c)
          }
          pointOnLine(t, r) {
            let o, c, f, g, y = 1 / 0;
            for (let w = 0; w < t.length - 1; w++) {
              let P = t[w][0],
                M = t[w][1],
                R = this.wrap(t[w + 1][0] - P) * this.kx,
                U = (t[w + 1][1] - M) * this.ky,
                G = 0;
              R === 0 && U === 0 || (G = (this.wrap(r[0] - P) * this.kx * R + (r[1] - M) * this.ky * U) / (R * R + U * U), G > 1 ? (P = t[w + 1][0], M = t[w + 1][1]) : G > 0 && (P += R / this.kx * G, M += U / this.ky * G)), R = this.wrap(r[0] - P) * this.kx, U = (r[1] - M) * this.ky;
              const W = R * R + U * U;
              W < y && (y = W, o = P, c = M, f = w, g = G)
            }
            return {
              point: [o, c],
              index: f,
              t: Math.max(0, Math.min(1, g))
            }
          }
          wrap(t) {
            for (; t < -180;) t += 360;
            for (; t > 180;) t -= 360;
            return t
          }
        }

        function Jc(n, t) {
          return t[0] - n[0]
        }

        function Js(n) {
          return n[1] - n[0] + 1
        }

        function po(n, t) {
          return n[1] >= n[0] && n[1] < t
        }

        function Qc(n, t) {
          if (n[0] > n[1]) return [null, null];
          const r = Js(n);
          if (t) {
            if (r === 2) return [n, null];
            const c = Math.floor(r / 2);
            return [
              [n[0], n[0] + c],
              [n[0] + c, n[1]]
            ]
          }
          if (r === 1) return [n, null];
          const o = Math.floor(r / 2) - 1;
          return [
            [n[0], n[0] + o],
            [n[0] + o + 1, n[1]]
          ]
        }

        function eu(n, t) {
          if (!po(t, n.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let o = t[0]; o <= t[1]; ++o) Eo(r, n[o]);
          return r
        }

        function Fl(n) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const r of n)
            for (const o of r) Eo(t, o);
          return t
        }

        function dd(n) {
          return n[0] !== -1 / 0 && n[1] !== -1 / 0 && n[2] !== 1 / 0 && n[3] !== 1 / 0
        }

        function tu(n, t, r) {
          if (!dd(n) || !dd(t)) return NaN;
          let o = 0,
            c = 0;
          return n[2] < t[0] && (o = t[0] - n[2]), n[0] > t[2] && (o = n[0] - t[2]), n[1] > t[3] && (c = n[1] - t[3]), n[3] < t[1] && (c = t[1] - n[3]), r.distance([0, 0], [o, c])
        }

        function $o(n, t, r) {
          const o = r.pointOnLine(t, n);
          return r.distance(n, o.point)
        }

        function ru(n, t, r, o, c) {
          const f = Math.min($o(n, [r, o], c), $o(t, [r, o], c)),
            g = Math.min($o(r, [n, t], c), $o(o, [n, t], c));
          return Math.min(f, g)
        }

        function Jn(n, t, r, o, c) {
          if (!po(t, n.length) || !po(o, r.length)) return 1 / 0;
          let f = 1 / 0;
          for (let g = t[0]; g < t[1]; ++g) {
            const y = n[g],
              w = n[g + 1];
            for (let P = o[0]; P < o[1]; ++P) {
              const M = r[P],
                R = r[P + 1];
              if (Ks(y, w, M, R)) return 0;
              f = Math.min(f, ru(y, w, M, R, c))
            }
          }
          return f
        }

        function mf(n, t, r, o, c) {
          if (!po(t, n.length) || !po(o, r.length)) return NaN;
          let f = 1 / 0;
          for (let g = t[0]; g <= t[1]; ++g)
            for (let y = o[0]; y <= o[1]; ++y)
              if (f = Math.min(f, c.distance(n[g], r[y])), f === 0) return f;
          return f
        }

        function gf(n, t, r) {
          if (Ho(n, t, !0)) return 0;
          let o = 1 / 0;
          for (const c of t) {
            const f = c[0],
              g = c[c.length - 1];
            if (f !== g && (o = Math.min(o, $o(n, [g, f], r)), o === 0)) return o;
            const y = r.pointOnLine(c, n);
            if (o = Math.min(o, r.distance(n, y.point)), o === 0) return o
          }
          return o
        }

        function _f(n, t, r, o) {
          if (!po(t, n.length)) return NaN;
          for (let f = t[0]; f <= t[1]; ++f)
            if (Ho(n[f], r, !0)) return 0;
          let c = 1 / 0;
          for (let f = t[0]; f < t[1]; ++f) {
            const g = n[f],
              y = n[f + 1];
            for (const w of r)
              for (let P = 0, M = w.length, R = M - 1; P < M; R = P++) {
                const U = w[R],
                  G = w[P];
                if (Ks(g, y, U, G)) return 0;
                c = Math.min(c, ru(g, y, U, G, o))
              }
          }
          return c
        }

        function pd(n, t) {
          for (const r of n)
            for (const o of r)
              if (Ho(o, t, !0)) return !0;
          return !1
        }

        function vf(n, t, r, o = 1 / 0) {
          const c = Fl(n),
            f = Fl(t);
          if (o !== 1 / 0 && tu(c, f, r) >= o) return o;
          if (Ys(c, f)) {
            if (pd(n, t)) return 0
          } else if (pd(t, n)) return 0;
          let g = 1 / 0;
          for (const y of n)
            for (let w = 0, P = y.length, M = P - 1; w < P; M = w++) {
              const R = y[M],
                U = y[w];
              for (const G of t)
                for (let W = 0, ne = G.length, se = ne - 1; W < ne; se = W++) {
                  const ge = G[se],
                    We = G[W];
                  if (Ks(R, U, ge, We)) return 0;
                  g = Math.min(g, ru(R, U, ge, We, r))
                }
            }
          return g
        }

        function fd(n, t, r, o, c, f) {
          if (!f) return;
          const g = tu(eu(o, f), c, r);
          g < t && n.push([g, f, [0, 0]])
        }

        function Bl(n, t, r, o, c, f, g) {
          if (!f || !g) return;
          const y = tu(eu(o, f), eu(c, g), r);
          y < t && n.push([y, f, g])
        }

        function Ol(n, t, r, o, c = 1 / 0) {
          let f = Math.min(o.distance(n[0], r[0][0]), c);
          if (f === 0) return f;
          const g = new cd([
              [0, [0, n.length - 1],
                [0, 0]
              ]
            ], Jc),
            y = Fl(r);
          for (; g.length > 0;) {
            const w = g.pop();
            if (w[0] >= f) continue;
            const P = w[1],
              M = t ? 50 : 100;
            if (Js(P) <= M) {
              if (!po(P, n.length)) return NaN;
              if (t) {
                const R = _f(n, P, r, o);
                if (isNaN(R) || R === 0) return R;
                f = Math.min(f, R)
              } else
                for (let R = P[0]; R <= P[1]; ++R) {
                  const U = gf(n[R], r, o);
                  if (f = Math.min(f, U), f === 0) return 0
                }
            } else {
              const R = Qc(P, t);
              fd(g, f, o, n, y, R[0]), fd(g, f, o, n, y, R[1])
            }
          }
          return f
        }

        function Nl(n, t, r, o, c, f = 1 / 0) {
          let g = Math.min(f, c.distance(n[0], r[0]));
          if (g === 0) return g;
          const y = new cd([
            [0, [0, n.length - 1],
              [0, r.length - 1]
            ]
          ], Jc);
          for (; y.length > 0;) {
            const w = y.pop();
            if (w[0] >= g) continue;
            const P = w[1],
              M = w[2],
              R = t ? 50 : 100,
              U = o ? 50 : 100;
            if (Js(P) <= R && Js(M) <= U) {
              if (!po(P, n.length) && po(M, r.length)) return NaN;
              let G;
              if (t && o) G = Jn(n, P, r, M, c), g = Math.min(g, G);
              else if (t && !o) {
                const W = n.slice(P[0], P[1] + 1);
                for (let ne = M[0]; ne <= M[1]; ++ne)
                  if (G = $o(r[ne], W, c), g = Math.min(g, G), g === 0) return g
              } else if (!t && o) {
                const W = r.slice(M[0], M[1] + 1);
                for (let ne = P[0]; ne <= P[1]; ++ne)
                  if (G = $o(n[ne], W, c), g = Math.min(g, G), g === 0) return g
              } else G = mf(n, P, r, M, c), g = Math.min(g, G)
            } else {
              const G = Qc(P, t),
                W = Qc(M, o);
              Bl(y, g, c, n, r, G[0], W[0]), Bl(y, g, c, n, r, G[0], W[1]), Bl(y, g, c, n, r, G[1], W[0]), Bl(y, g, c, n, r, G[1], W[1])
            }
          }
          return g
        }

        function nu(n) {
          return n.type === "MultiPolygon" ? n.coordinates.map((t => ({
            type: "Polygon",
            coordinates: t
          }))) : n.type === "MultiLineString" ? n.coordinates.map((t => ({
            type: "LineString",
            coordinates: t
          }))) : n.type === "MultiPoint" ? n.coordinates.map((t => ({
            type: "Point",
            coordinates: t
          }))) : [n]
        }
        class Xo {
          constructor(t, r) {
            this.type = ot, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'distance' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Kn(t[1])) {
              const o = t[1];
              if (o.type === "FeatureCollection") return new Xo(o, o.features.map((c => nu(c.geometry))).flat());
              if (o.type === "Feature") return new Xo(o, nu(o.geometry));
              if ("type" in o && "coordinates" in o) return new Xo(o, nu(o))
            }
            return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, o) {
                const c = r.geometry(),
                  f = c.flat().map((w => Gc([w.x, w.y], r.canonical)));
                if (c.length === 0) return NaN;
                const g = new Kc(f[0][1]);
                let y = 1 / 0;
                for (const w of o) {
                  switch (w.type) {
                    case "Point":
                      y = Math.min(y, Nl(f, !1, [w.coordinates], !1, g, y));
                      break;
                    case "LineString":
                      y = Math.min(y, Nl(f, !1, w.coordinates, !0, g, y));
                      break;
                    case "Polygon":
                      y = Math.min(y, Ol(f, !1, w.coordinates, g, y))
                  }
                  if (y === 0) return y
                }
                return y
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, o) {
                const c = r.geometry(),
                  f = c.flat().map((w => Gc([w.x, w.y], r.canonical)));
                if (c.length === 0) return NaN;
                const g = new Kc(f[0][1]);
                let y = 1 / 0;
                for (const w of o) {
                  switch (w.type) {
                    case "Point":
                      y = Math.min(y, Nl(f, !0, [w.coordinates], !1, g, y));
                      break;
                    case "LineString":
                      y = Math.min(y, Nl(f, !0, w.coordinates, !0, g, y));
                      break;
                    case "Polygon":
                      y = Math.min(y, Ol(f, !0, w.coordinates, g, y))
                  }
                  if (y === 0) return y
                }
                return y
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(r, o) {
                const c = r.geometry();
                if (c.length === 0 || c[0].length === 0) return NaN;
                const f = Dl(c, 0).map((w => w.map((P => P.map((M => Gc([M.x, M.y], r.canonical))))))),
                  g = new Kc(f[0][0][0][1]);
                let y = 1 / 0;
                for (const w of o)
                  for (const P of f) {
                    switch (w.type) {
                      case "Point":
                        y = Math.min(y, Ol([w.coordinates], !1, P, g, y));
                        break;
                      case "LineString":
                        y = Math.min(y, Ol(w.coordinates, !0, P, g, y));
                        break;
                      case "Polygon":
                        y = Math.min(y, vf(P, w.coordinates, g, y))
                    }
                    if (y === 0) return y
                  }
                return y
              })(t, this.geometries)
            }
            return NaN
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        class Qs {
          constructor(t) {
            this.type = Ot, this.key = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const o = t[1];
            return o == null ? r.error("Global state property must be defined.") : typeof o != "string" ? r.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Qs(o)
          }
          evaluate(t) {
            var r;
            const o = (r = t.globals) === null || r === void 0 ? void 0 : r.globalState;
            return o && Object.keys(o).length !== 0 ? on(o, this.key) : null
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        const Ss = {
          "==": Uc,
          "!=": sf,
          ">": El,
          "<": id,
          ">=": Ua,
          "<=": Ll,
          array: zn,
          at: Va,
          boolean: zn,
          case: Ra,
          coalesce: Ws,
          collator: $s,
          format: zl,
          image: Xs,
          in: ci,
          "index-of": wi,
          interpolate: Qn,
          "interpolate-hcl": Qn,
          "interpolate-lab": Qn,
          length: Zc,
          let: qa,
          literal: ta,
          match: sa,
          number: zn,
          "number-format": Ts,
          object: zn,
          slice: Sa,
          step: eo,
          string: zn,
          "to-boolean": Sn,
          "to-color": Sn,
          "to-number": Sn,
          "to-string": Sn,
          var: Ui,
          within: Wo,
          distance: Xo,
          "global-state": Qs
        };
        class Ba {
          constructor(t, r, o, c) {
            this.name = t, this.type = r, this._evaluate = o, this.args = c
          }
          evaluate(t) {
            return this._evaluate(t, this.args)
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return !1
          }
          static parse(t, r) {
            const o = t[0],
              c = Ba.definitions[o];
            if (!c) return r.error(`Unknown expression "${o}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const f = Array.isArray(c) ? c[0] : c.type,
              g = Array.isArray(c) ? [
                [c[1], c[2]]
              ] : c.overloads,
              y = g.filter((([P]) => !Array.isArray(P) || P.length === t.length - 1));
            let w = null;
            for (const [P, M] of y) {
              w = new En(r.registry, jl, r.path, null, r.scope);
              const R = [];
              let U = !1;
              for (let G = 1; G < t.length; G++) {
                const W = t[G],
                  ne = Array.isArray(P) ? P[G - 1] : P.type,
                  se = w.parse(W, 1 + R.length, ne);
                if (!se) {
                  U = !0;
                  break
                }
                R.push(se)
              }
              if (!U)
                if (Array.isArray(P) && P.length !== R.length) w.error(`Expected ${P.length} arguments, but found ${R.length} instead.`);
                else {
                  for (let G = 0; G < R.length; G++) {
                    const W = Array.isArray(P) ? P[G] : P.type,
                      ne = R[G];
                    w.concat(G + 1).checkSubtype(W, ne.type)
                  }
                  if (w.errors.length === 0) return new Ba(o, f, M, R)
                }
            }
            if (y.length === 1) r.errors.push(...w.errors);
            else {
              const P = (y.length ? y : g).map((([R]) => {
                  return U = R, Array.isArray(U) ? `(${U.map(St).join(", ")})` : `(${St(U.type)}...)`;
                  var U
                })).join(" | "),
                M = [];
              for (let R = 1; R < t.length; R++) {
                const U = r.parse(t[R], 1 + M.length);
                if (!U) return null;
                M.push(St(U.type))
              }
              r.error(`Expected arguments of type ${P}, but found (${M.join(", ")}) instead.`)
            }
            return null
          }
          static register(t, r) {
            Ba.definitions = r;
            for (const o in r) t[o] = Ba
          }
        }

        function md(n, [t, r, o, c]) {
          t = t.evaluate(n), r = r.evaluate(n), o = o.evaluate(n);
          const f = c ? c.evaluate(n) : 1,
            g = ii(t, r, o, f);
          if (g) throw new Qr(g);
          return new gr(t / 255, r / 255, o / 255, f, !1)
        }

        function gd(n, t) {
          return n in t
        }

        function iu(n, t) {
          const r = t[n];
          return r === void 0 ? null : r
        }

        function Yo(n) {
          return {
            type: n
          }
        }

        function jl(n) {
          if (n instanceof Ui) return jl(n.boundExpression);
          if (n instanceof Ba && n.name === "error" || n instanceof $s || n instanceof Wo || n instanceof Xo || n instanceof Qs) return !1;
          const t = n instanceof Sn || n instanceof zn;
          let r = !0;
          return n.eachChild((o => {
            r = t ? r && jl(o) : r && o instanceof ta
          })), !!r && ql(n) && Vl(n, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
        }

        function ql(n) {
          if (n instanceof Ba && (n.name === "get" && n.args.length === 1 || n.name === "feature-state" || n.name === "has" && n.args.length === 1 || n.name === "properties" || n.name === "geometry-type" || n.name === "id" || /^filter-/.test(n.name)) || n instanceof Wo || n instanceof Xo) return !1;
          let t = !0;
          return n.eachChild((r => {
            t && !ql(r) && (t = !1)
          })), t
        }

        function el(n) {
          if (n instanceof Ba && n.name === "feature-state") return !1;
          let t = !0;
          return n.eachChild((r => {
            t && !el(r) && (t = !1)
          })), t
        }

        function Vl(n, t) {
          if (n instanceof Ba && t.indexOf(n.name) >= 0) return !1;
          let r = !0;
          return n.eachChild((o => {
            r && !Vl(o, t) && (r = !1)
          })), r
        }

        function _d(n) {
          return {
            result: "success",
            value: n
          }
        }

        function Ps(n) {
          return {
            result: "error",
            value: n
          }
        }

        function Cs(n) {
          return n["property-type"] === "data-driven" || n["property-type"] === "cross-faded-data-driven"
        }

        function vd(n) {
          return !!n.expression && n.expression.parameters.indexOf("zoom") > -1
        }

        function au(n) {
          return !!n.expression && n.expression.interpolated
        }

        function Nn(n) {
          return n instanceof Number ? "number" : n instanceof String ? "string" : n instanceof Boolean ? "boolean" : Array.isArray(n) ? "array" : n === null ? "null" : typeof n
        }

        function Ul(n) {
          return typeof n == "object" && n !== null && !Array.isArray(n) && Vn(n) === Ur
        }

        function yf(n) {
          return n
        }

        function yd(n, t) {
          const r = n.stops && typeof n.stops[0][0] == "object",
            o = r || !(r || n.property !== void 0),
            c = n.type || (au(t) ? "exponential" : "interval"),
            f = (function(M) {
              switch (M.type) {
                case "color":
                  return gr.parse;
                case "padding":
                  return qn.parse;
                case "numberArray":
                  return $n.parse;
                case "colorArray":
                  return Mn.parse;
                default:
                  return null
              }
            })(t);
          if (f && ((n = Pr({}, n)).stops && (n.stops = n.stops.map((M => [M[0], f(M[1])]))), n.default = f(n.default ? n.default : t.default)), n.colorSpace && (g = n.colorSpace) !== "rgb" && g !== "hcl" && g !== "lab") throw new Error(`Unknown color space: "${n.colorSpace}"`);
          var g;
          const y = (function(M) {
            switch (M) {
              case "exponential":
                return xd;
              case "interval":
                return bf;
              case "categorical":
                return xf;
              case "identity":
                return bd;
              default:
                throw new Error(`Unknown function type "${M}"`)
            }
          })(c);
          let w, P;
          if (c === "categorical") {
            w = Object.create(null);
            for (const M of n.stops) w[M[0]] = M[1];
            P = typeof n.stops[0][0]
          }
          if (r) {
            const M = {},
              R = [];
            for (let W = 0; W < n.stops.length; W++) {
              const ne = n.stops[W],
                se = ne[0].zoom;
              M[se] === void 0 && (M[se] = {
                zoom: se,
                type: n.type,
                property: n.property,
                default: n.default,
                stops: []
              }, R.push(se)), M[se].stops.push([ne[0].value, ne[1]])
            }
            const U = [];
            for (const W of R) U.push([M[W].zoom, yd(M[W], t)]);
            const G = {
              name: "linear"
            };
            return {
              kind: "composite",
              interpolationType: G,
              interpolationFactor: Qn.interpolationFactor.bind(void 0, G),
              zoomStops: U.map((W => W[0])),
              evaluate: ({
                zoom: W
              }, ne) => xd({
                stops: U,
                base: n.base
              }, t, W).evaluate(W, ne)
            }
          }
          if (o) {
            const M = c === "exponential" ? {
              name: "exponential",
              base: n.base !== void 0 ? n.base : 1
            } : null;
            return {
              kind: "camera",
              interpolationType: M,
              interpolationFactor: Qn.interpolationFactor.bind(void 0, M),
              zoomStops: n.stops.map((R => R[0])),
              evaluate: ({
                zoom: R
              }) => y(n, t, R, w, P)
            }
          }
          return {
            kind: "source",
            evaluate(M, R) {
              const U = R && R.properties ? R.properties[n.property] : void 0;
              return U === void 0 ? Ko(n.default, t.default) : y(n, t, U, w, P)
            }
          }
        }

        function Ko(n, t, r) {
          return n !== void 0 ? n : t !== void 0 ? t : r !== void 0 ? r : void 0
        }

        function xf(n, t, r, o, c) {
          return Ko(typeof r === c ? o[r] : void 0, n.default, t.default)
        }

        function bf(n, t, r) {
          if (Nn(r) !== "number") return Ko(n.default, t.default);
          const o = n.stops.length;
          if (o === 1 || r <= n.stops[0][0]) return n.stops[0][1];
          if (r >= n.stops[o - 1][0]) return n.stops[o - 1][1];
          const c = la(n.stops.map((f => f[0])), r);
          return n.stops[c][1]
        }

        function xd(n, t, r) {
          const o = n.base !== void 0 ? n.base : 1;
          if (Nn(r) !== "number") return Ko(n.default, t.default);
          const c = n.stops.length;
          if (c === 1 || r <= n.stops[0][0]) return n.stops[0][1];
          if (r >= n.stops[c - 1][0]) return n.stops[c - 1][1];
          const f = la(n.stops.map((M => M[0])), r),
            g = (function(M, R, U, G) {
              const W = G - U,
                ne = M - U;
              return W === 0 ? 0 : R === 1 ? ne / W : (Math.pow(R, ne) - 1) / (Math.pow(R, W) - 1)
            })(r, o, n.stops[f][0], n.stops[f + 1][0]),
            y = n.stops[f][1],
            w = n.stops[f + 1][1],
            P = Fa[t.type] || yf;
          return typeof y.evaluate == "function" ? {
            evaluate(...M) {
              const R = y.evaluate.apply(void 0, M),
                U = w.evaluate.apply(void 0, M);
              if (R !== void 0 && U !== void 0) return P(R, U, g, n.colorSpace)
            }
          } : P(y, w, g, n.colorSpace)
        }

        function bd(n, t, r) {
          switch (t.type) {
            case "color":
              r = gr.parse(r);
              break;
            case "formatted":
              r = In.fromString(r.toString());
              break;
            case "resolvedImage":
              r = bn.fromString(r.toString());
              break;
            case "padding":
              r = qn.parse(r);
              break;
            case "colorArray":
              r = Mn.parse(r);
              break;
            case "numberArray":
              r = $n.parse(r);
              break;
            default:
              Nn(r) === t.type || t.type === "enum" && t.values[r] || (r = void 0)
          }
          return Ko(r, n.default, t.default)
        }
        Ba.register(Ss, {
          error: [{
              kind: "error"
            },
            [dr], (n, [t]) => {
              throw new Qr(t.evaluate(n))
            }
          ],
          typeof: [dr, [Ot], (n, [t]) => St(Vn(t.evaluate(n)))],
          "to-rgba": [Ke(ot, 4), [Tt], (n, [t]) => {
            const [r, o, c, f] = t.evaluate(n).rgb;
            return [255 * r, 255 * o, 255 * c, f]
          }],
          rgb: [Tt, [ot, ot, ot], md],
          rgba: [Tt, [ot, ot, ot, ot], md],
          has: {
            type: st,
            overloads: [
              [
                [dr], (n, [t]) => gd(t.evaluate(n), n.properties())
              ],
              [
                [dr, Ur], (n, [t, r]) => gd(t.evaluate(n), r.evaluate(n))
              ]
            ]
          },
          get: {
            type: Ot,
            overloads: [
              [
                [dr], (n, [t]) => iu(t.evaluate(n), n.properties())
              ],
              [
                [dr, Ur], (n, [t, r]) => iu(t.evaluate(n), r.evaluate(n))
              ]
            ]
          },
          "feature-state": [Ot, [dr], (n, [t]) => iu(t.evaluate(n), n.featureState || {})],
          properties: [Ur, [], n => n.properties()],
          "geometry-type": [dr, [], n => n.geometryType()],
          id: [Ot, [], n => n.id()],
          zoom: [ot, [], n => n.globals.zoom],
          "heatmap-density": [ot, [], n => n.globals.heatmapDensity || 0],
          elevation: [ot, [], n => n.globals.elevation || 0],
          "line-progress": [ot, [], n => n.globals.lineProgress || 0],
          accumulated: [Ot, [], n => n.globals.accumulated === void 0 ? null : n.globals.accumulated],
          "+": [ot, Yo(ot), (n, t) => {
            let r = 0;
            for (const o of t) r += o.evaluate(n);
            return r
          }],
          "*": [ot, Yo(ot), (n, t) => {
            let r = 1;
            for (const o of t) r *= o.evaluate(n);
            return r
          }],
          "-": {
            type: ot,
            overloads: [
              [
                [ot, ot], (n, [t, r]) => t.evaluate(n) - r.evaluate(n)
              ],
              [
                [ot], (n, [t]) => -t.evaluate(n)
              ]
            ]
          },
          "/": [ot, [ot, ot], (n, [t, r]) => t.evaluate(n) / r.evaluate(n)],
          "%": [ot, [ot, ot], (n, [t, r]) => t.evaluate(n) % r.evaluate(n)],
          ln2: [ot, [], () => Math.LN2],
          pi: [ot, [], () => Math.PI],
          e: [ot, [], () => Math.E],
          "^": [ot, [ot, ot], (n, [t, r]) => Math.pow(t.evaluate(n), r.evaluate(n))],
          sqrt: [ot, [ot], (n, [t]) => Math.sqrt(t.evaluate(n))],
          log10: [ot, [ot], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN10],
          ln: [ot, [ot], (n, [t]) => Math.log(t.evaluate(n))],
          log2: [ot, [ot], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN2],
          sin: [ot, [ot], (n, [t]) => Math.sin(t.evaluate(n))],
          cos: [ot, [ot], (n, [t]) => Math.cos(t.evaluate(n))],
          tan: [ot, [ot], (n, [t]) => Math.tan(t.evaluate(n))],
          asin: [ot, [ot], (n, [t]) => Math.asin(t.evaluate(n))],
          acos: [ot, [ot], (n, [t]) => Math.acos(t.evaluate(n))],
          atan: [ot, [ot], (n, [t]) => Math.atan(t.evaluate(n))],
          min: [ot, Yo(ot), (n, t) => Math.min(...t.map((r => r.evaluate(n))))],
          max: [ot, Yo(ot), (n, t) => Math.max(...t.map((r => r.evaluate(n))))],
          abs: [ot, [ot], (n, [t]) => Math.abs(t.evaluate(n))],
          round: [ot, [ot], (n, [t]) => {
            const r = t.evaluate(n);
            return r < 0 ? -Math.round(-r) : Math.round(r)
          }],
          floor: [ot, [ot], (n, [t]) => Math.floor(t.evaluate(n))],
          ceil: [ot, [ot], (n, [t]) => Math.ceil(t.evaluate(n))],
          "filter-==": [st, [dr, Ot], (n, [t, r]) => n.properties()[t.value] === r.value],
          "filter-id-==": [st, [Ot], (n, [t]) => n.id() === t.value],
          "filter-type-==": [st, [dr], (n, [t]) => n.geometryType() === t.value],
          "filter-<": [st, [dr, Ot], (n, [t, r]) => {
            const o = n.properties()[t.value],
              c = r.value;
            return typeof o == typeof c && o < c
          }],
          "filter-id-<": [st, [Ot], (n, [t]) => {
            const r = n.id(),
              o = t.value;
            return typeof r == typeof o && r < o
          }],
          "filter->": [st, [dr, Ot], (n, [t, r]) => {
            const o = n.properties()[t.value],
              c = r.value;
            return typeof o == typeof c && o > c
          }],
          "filter-id->": [st, [Ot], (n, [t]) => {
            const r = n.id(),
              o = t.value;
            return typeof r == typeof o && r > o
          }],
          "filter-<=": [st, [dr, Ot], (n, [t, r]) => {
            const o = n.properties()[t.value],
              c = r.value;
            return typeof o == typeof c && o <= c
          }],
          "filter-id-<=": [st, [Ot], (n, [t]) => {
            const r = n.id(),
              o = t.value;
            return typeof r == typeof o && r <= o
          }],
          "filter->=": [st, [dr, Ot], (n, [t, r]) => {
            const o = n.properties()[t.value],
              c = r.value;
            return typeof o == typeof c && o >= c
          }],
          "filter-id->=": [st, [Ot], (n, [t]) => {
            const r = n.id(),
              o = t.value;
            return typeof r == typeof o && r >= o
          }],
          "filter-has": [st, [Ot], (n, [t]) => t.value in n.properties()],
          "filter-has-id": [st, [], n => n.id() !== null && n.id() !== void 0],
          "filter-type-in": [st, [Ke(dr)], (n, [t]) => t.value.indexOf(n.geometryType()) >= 0],
          "filter-id-in": [st, [Ke(Ot)], (n, [t]) => t.value.indexOf(n.id()) >= 0],
          "filter-in-small": [st, [dr, Ke(Ot)], (n, [t, r]) => r.value.indexOf(n.properties()[t.value]) >= 0],
          "filter-in-large": [st, [dr, Ke(Ot)], (n, [t, r]) => (function(o, c, f, g) {
            for (; f <= g;) {
              const y = f + g >> 1;
              if (c[y] === o) return !0;
              c[y] > o ? g = y - 1 : f = y + 1
            }
            return !1
          })(n.properties()[t.value], r.value, 0, r.value.length - 1)],
          all: {
            type: st,
            overloads: [
              [
                [st, st], (n, [t, r]) => t.evaluate(n) && r.evaluate(n)
              ],
              [Yo(st), (n, t) => {
                for (const r of t)
                  if (!r.evaluate(n)) return !1;
                return !0
              }]
            ]
          },
          any: {
            type: st,
            overloads: [
              [
                [st, st], (n, [t, r]) => t.evaluate(n) || r.evaluate(n)
              ],
              [Yo(st), (n, t) => {
                for (const r of t)
                  if (r.evaluate(n)) return !0;
                return !1
              }]
            ]
          },
          "!": [st, [st], (n, [t]) => !t.evaluate(n)],
          "is-supported-script": [st, [dr], (n, [t]) => {
            const r = n.globals && n.globals.isSupportedScript;
            return !r || r(t.evaluate(n))
          }],
          upcase: [dr, [dr], (n, [t]) => t.evaluate(n).toUpperCase()],
          downcase: [dr, [dr], (n, [t]) => t.evaluate(n).toLowerCase()],
          concat: [dr, Yo(Ot), (n, t) => t.map((r => ga(r.evaluate(n)))).join("")],
          "resolved-locale": [dr, [Fr], (n, [t]) => t.evaluate(n).resolvedLocale()]
        });
        class ou {
          constructor(t, r, o) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new Ta, this._defaultValue = r ? (function(c) {
              if (c.type === "color" && Ul(c.default)) return new gr(0, 0, 0, 0);
              switch (c.type) {
                case "color":
                  return gr.parse(c.default) || null;
                case "padding":
                  return qn.parse(c.default) || null;
                case "numberArray":
                  return $n.parse(c.default) || null;
                case "colorArray":
                  return Mn.parse(c.default) || null;
                case "variableAnchorOffsetCollection":
                  return Bn.parse(c.default) || null;
                case "projectionDefinition":
                  return vn.parse(c.default) || null;
                default:
                  return c.default === void 0 ? null : c.default
              }
            })(r) : null, this._enumValues = r && r.type === "enum" ? r.values : null, this._globalState = o
          }
          evaluateWithoutErrorHandling(t, r, o, c, f, g) {
            return this._globalState && (t = Qo(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = r, this._evaluator.featureState = o, this._evaluator.canonical = c, this._evaluator.availableImages = f || null, this._evaluator.formattedSection = g, this.expression.evaluate(this._evaluator)
          }
          evaluate(t, r, o, c, f, g) {
            this._globalState && (t = Qo(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = r || null, this._evaluator.featureState = o || null, this._evaluator.canonical = c, this._evaluator.availableImages = f || null, this._evaluator.formattedSection = g || null;
            try {
              const y = this.expression.evaluate(this._evaluator);
              if (y == null || typeof y == "number" && y != y) return this._defaultValue;
              if (this._enumValues && !(y in this._enumValues)) throw new Qr(`Expected value to be one of ${Object.keys(this._enumValues).map((w=>JSON.stringify(w))).join(", ")}, but found ${JSON.stringify(y)} instead.`);
              return y
            } catch (y) {
              return this._warningHistory[y.message] || (this._warningHistory[y.message] = !0, typeof console < "u" && console.warn(y.message)), this._defaultValue
            }
          }
        }

        function Zl(n) {
          return Array.isArray(n) && n.length > 0 && typeof n[0] == "string" && n[0] in Ss
        }

        function Jo(n, t, r) {
          const o = new En(Ss, jl, [], t ? (function(f) {
              const g = {
                color: Tt,
                string: dr,
                number: ot,
                enum: dr,
                boolean: st,
                formatted: Xr,
                padding: mn,
                numberArray: hn,
                colorArray: sn,
                projectionDefinition: nr,
                resolvedImage: dn,
                variableAnchorOffsetCollection: nn
              };
              return f.type === "array" ? Ke(g[f.value] || Ot, f.length) : g[f.type]
            })(t) : void 0),
            c = o.parse(n, void 0, void 0, void 0, t && t.type === "string" ? {
              typeAnnotation: "coerce"
            } : void 0);
          return c ? _d(new ou(c, t, r)) : Ps(o.errors)
        }
        class tl {
          constructor(t, r, o) {
            this.kind = t, this._styleExpression = r, this.isStateDependent = t !== "constant" && !el(r.expression), this.globalStateRefs = Wl(r.expression), this._globalState = o
          }
          evaluateWithoutErrorHandling(t, r, o, c, f, g) {
            return this._globalState && (t = Qo(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, r, o, c, f, g)
          }
          evaluate(t, r, o, c, f, g) {
            return this._globalState && (t = Qo(t, this._globalState)), this._styleExpression.evaluate(t, r, o, c, f, g)
          }
        }
        class su {
          constructor(t, r, o, c, f) {
            this.kind = t, this.zoomStops = o, this._styleExpression = r, this.isStateDependent = t !== "camera" && !el(r.expression), this.globalStateRefs = Wl(r.expression), this.interpolationType = c, this._globalState = f
          }
          evaluateWithoutErrorHandling(t, r, o, c, f, g) {
            return this._globalState && (t = Qo(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, r, o, c, f, g)
          }
          evaluate(t, r, o, c, f, g) {
            return this._globalState && (t = Qo(t, this._globalState)), this._styleExpression.evaluate(t, r, o, c, f, g)
          }
          interpolationFactor(t, r, o) {
            return this.interpolationType ? Qn.interpolationFactor(this.interpolationType, t, r, o) : 0
          }
        }

        function wd(n, t, r) {
          const o = Jo(n, t, r);
          if (o.result === "error") return o;
          const c = o.value.expression,
            f = ql(c);
          if (!f && !Cs(t)) return Ps([new br("", "data expressions not supported")]);
          const g = Vl(c, ["zoom"]);
          if (!g && !vd(t)) return Ps([new br("", "zoom expressions not supported")]);
          const y = Hl(c);
          return y || g ? y instanceof br ? Ps([y]) : y instanceof Qn && !au(t) ? Ps([new br("", '"interpolate" expressions cannot be used with this property')]) : _d(y ? new su(f ? "camera" : "composite", o.value, y.labels, y instanceof Qn ? y.interpolation : void 0, r) : new tl(f ? "constant" : "source", o.value, r)) : Ps([new br("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
        }
        class Gl {
          constructor(t, r) {
            this._parameters = t, this._specification = r, Pr(this, yd(this._parameters, this._specification))
          }
          static deserialize(t) {
            return new Gl(t._parameters, t._specification)
          }
          static serialize(t) {
            return {
              _parameters: t._parameters,
              _specification: t._specification
            }
          }
        }

        function Hl(n) {
          let t = null;
          if (n instanceof qa) t = Hl(n.result);
          else if (n instanceof Ws) {
            for (const r of n.args)
              if (t = Hl(r), t) break
          } else(n instanceof eo || n instanceof Qn) && n.input instanceof Ba && n.input.name === "zoom" && (t = n);
          return t instanceof br || n.eachChild((r => {
            const o = Hl(r);
            o instanceof br ? t = o : !t && o ? t = new br("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && o && t !== o && (t = new br("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
          })), t
        }

        function Wl(n, t = new Set) {
          return n instanceof Qs && t.add(n.key), n.eachChild((r => {
            Wl(r, t)
          })), t
        }

        function Qo(n, t) {
          const {
            zoom: r,
            heatmapDensity: o,
            elevation: c,
            lineProgress: f,
            isSupportedScript: g,
            accumulated: y
          } = n ?? {};
          return {
            zoom: r,
            heatmapDensity: o,
            elevation: c,
            lineProgress: f,
            isSupportedScript: g,
            accumulated: y,
            globalState: t
          }
        }

        function $l(n) {
          if (n === !0 || n === !1) return !0;
          if (!Array.isArray(n) || n.length === 0) return !1;
          switch (n[0]) {
            case "has":
              return n.length >= 2 && n[1] !== "$id" && n[1] !== "$type";
            case "in":
              return n.length >= 3 && (typeof n[1] != "string" || Array.isArray(n[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return n.length !== 3 || Array.isArray(n[1]) || Array.isArray(n[2]);
            case "any":
            case "all":
              for (const t of n.slice(1))
                if (!$l(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0
          }
        }
        const wf = {
          type: "boolean",
          default: !1,
          transition: !1,
          "property-type": "data-driven",
          expression: {
            interpolated: !1,
            parameters: ["zoom", "feature"]
          }
        };

        function rl(n, t) {
          if (n == null) return {
            filter: () => !0,
            needGeometry: !1,
            getGlobalStateRefs: () => new Set
          };
          $l(n) || (n = nl(n));
          const r = Jo(n, wf, t);
          if (r.result === "error") throw new Error(r.value.map((o => `${o.key}: ${o.message}`)).join(", "));
          return {
            filter: (o, c, f) => r.value.evaluate(o, c, {}, f),
            needGeometry: lu(n),
            getGlobalStateRefs: () => Wl(r.value.expression)
          }
        }

        function Td(n, t) {
          return n < t ? -1 : n > t ? 1 : 0
        }

        function lu(n) {
          if (!Array.isArray(n)) return !1;
          if (n[0] === "within" || n[0] === "distance") return !0;
          for (let t = 1; t < n.length; t++)
            if (lu(n[t])) return !0;
          return !1
        }

        function nl(n) {
          if (!n) return !0;
          const t = n[0];
          return n.length <= 1 ? t !== "any" : t === "==" ? cu(n[1], n[2], "==") : t === "!=" ? Xl(cu(n[1], n[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? cu(n[1], n[2], t) : t === "any" ? (r = n.slice(1), ["any"].concat(r.map(nl))) : t === "all" ? ["all"].concat(n.slice(1).map(nl)) : t === "none" ? ["all"].concat(n.slice(1).map(nl).map(Xl)) : t === "in" ? Sd(n[1], n.slice(2)) : t === "!in" ? Xl(Sd(n[1], n.slice(2))) : t === "has" ? Pd(n[1]) : t !== "!has" || Xl(Pd(n[1]));
          var r
        }

        function cu(n, t, r) {
          switch (n) {
            case "$type":
              return [`filter-type-${r}`, t];
            case "$id":
              return [`filter-id-${r}`, t];
            default:
              return [`filter-${r}`, n, t]
          }
        }

        function Sd(n, t) {
          if (t.length === 0) return !1;
          switch (n) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some((r => typeof r != typeof t[0])) ? ["filter-in-large", n, ["literal", t.sort(Td)]] : ["filter-in-small", n, ["literal", t]]
          }
        }

        function Pd(n) {
          switch (n) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", n]
          }
        }

        function Xl(n) {
          return ["!", n]
        }

        function Yl(n) {
          const t = typeof n;
          if (t === "number" || t === "boolean" || t === "string" || n == null) return JSON.stringify(n);
          if (Array.isArray(n)) {
            let c = "[";
            for (const f of n) c += `${Yl(f)},`;
            return `${c}]`
          }
          const r = Object.keys(n).sort();
          let o = "{";
          for (let c = 0; c < r.length; c++) o += `${JSON.stringify(r[c])}:${Yl(n[r[c]])},`;
          return `${o}}`
        }

        function Cd(n) {
          let t = "";
          for (const r of ze) t += `/${Yl(n[r])}`;
          return t
        }

        function Kl(n) {
          const t = n.value;
          return t ? [new Ze(n.key, t, "constants have been deprecated as of v8")] : []
        }

        function mi(n) {
          return n instanceof Number || n instanceof String || n instanceof Boolean ? n.valueOf() : n
        }

        function fo(n) {
          if (Array.isArray(n)) return n.map(fo);
          if (n instanceof Object && !(n instanceof Number || n instanceof String || n instanceof Boolean)) {
            const t = {};
            for (const r in n) t[r] = fo(n[r]);
            return t
          }
          return mi(n)
        }

        function _a(n) {
          const t = n.key,
            r = n.value,
            o = n.valueSpec || {},
            c = n.objectElementValidators || {},
            f = n.style,
            g = n.styleSpec,
            y = n.validateSpec;
          let w = [];
          const P = Nn(r);
          if (P !== "object") return [new Ze(t, r, `object expected, ${P} found`)];
          for (const M in r) {
            const R = M.split(".")[0],
              U = on(o, R) || o["*"];
            let G;
            if (on(c, R)) G = c[R];
            else if (on(o, R)) G = y;
            else if (c["*"]) G = c["*"];
            else {
              if (!o["*"]) {
                w.push(new Ze(t, r[M], `unknown property "${M}"`));
                continue
              }
              G = y
            }
            w = w.concat(G({
              key: (t && `${t}.`) + M,
              value: r[M],
              valueSpec: U,
              style: f,
              styleSpec: g,
              object: r,
              objectKey: M,
              validateSpec: y
            }, r))
          }
          for (const M in o) c[M] || o[M].required && o[M].default === void 0 && r[M] === void 0 && w.push(new Ze(t, r, `missing required property "${M}"`));
          return w
        }

        function Is(n) {
          const t = n.value,
            r = n.valueSpec,
            o = n.style,
            c = n.styleSpec,
            f = n.key,
            g = n.arrayElementValidator || n.validateSpec;
          if (Nn(t) !== "array") return [new Ze(f, t, `array expected, ${Nn(t)} found`)];
          if (r.length && t.length !== r.length) return [new Ze(f, t, `array length ${r.length} expected, length ${t.length} found`)];
          if (r["min-length"] && t.length < r["min-length"]) return [new Ze(f, t, `array length at least ${r["min-length"]} expected, length ${t.length} found`)];
          let y = {
            type: r.value,
            values: r.values
          };
          c.$version < 7 && (y.function = r.function), Nn(r.value) === "object" && (y = r.value);
          let w = [];
          for (let P = 0; P < t.length; P++) w = w.concat(g({
            array: t,
            arrayIndex: P,
            value: t[P],
            valueSpec: y,
            validateSpec: n.validateSpec,
            style: o,
            styleSpec: c,
            key: `${f}[${P}]`
          }));
          return w
        }

        function Jl(n) {
          const t = n.key,
            r = n.value,
            o = n.valueSpec;
          let c = Nn(r);
          return c === "number" && r != r && (c = "NaN"), c !== "number" ? [new Ze(t, r, `number expected, ${c} found`)] : "minimum" in o && r < o.minimum ? [new Ze(t, r, `${r} is less than the minimum value ${o.minimum}`)] : "maximum" in o && r > o.maximum ? [new Ze(t, r, `${r} is greater than the maximum value ${o.maximum}`)] : []
        }

        function Id(n) {
          const t = n.valueSpec,
            r = mi(n.value.type);
          let o, c, f, g = {};
          const y = r !== "categorical" && n.value.property === void 0,
            w = !y,
            P = Nn(n.value.stops) === "array" && Nn(n.value.stops[0]) === "array" && Nn(n.value.stops[0][0]) === "object",
            M = _a({
              key: n.key,
              value: n.value,
              valueSpec: n.styleSpec.function,
              validateSpec: n.validateSpec,
              style: n.style,
              styleSpec: n.styleSpec,
              objectElementValidators: {
                stops: function(G) {
                  if (r === "identity") return [new Ze(G.key, G.value, 'identity function may not have a "stops" property')];
                  let W = [];
                  const ne = G.value;
                  return W = W.concat(Is({
                    key: G.key,
                    value: ne,
                    valueSpec: G.valueSpec,
                    validateSpec: G.validateSpec,
                    style: G.style,
                    styleSpec: G.styleSpec,
                    arrayElementValidator: R
                  })), Nn(ne) === "array" && ne.length === 0 && W.push(new Ze(G.key, ne, "array must have at least one stop")), W
                },
                default: function(G) {
                  return G.validateSpec({
                    key: G.key,
                    value: G.value,
                    valueSpec: t,
                    validateSpec: G.validateSpec,
                    style: G.style,
                    styleSpec: G.styleSpec
                  })
                }
              }
            });
          return r === "identity" && y && M.push(new Ze(n.key, n.value, 'missing required property "property"')), r === "identity" || n.value.stops || M.push(new Ze(n.key, n.value, 'missing required property "stops"')), r === "exponential" && n.valueSpec.expression && !au(n.valueSpec) && M.push(new Ze(n.key, n.value, "exponential functions not supported")), n.styleSpec.$version >= 8 && (w && !Cs(n.valueSpec) ? M.push(new Ze(n.key, n.value, "property functions not supported")) : y && !vd(n.valueSpec) && M.push(new Ze(n.key, n.value, "zoom functions not supported"))), r !== "categorical" && !P || n.value.property !== void 0 || M.push(new Ze(n.key, n.value, '"property" property is required')), M;

          function R(G) {
            let W = [];
            const ne = G.value,
              se = G.key;
            if (Nn(ne) !== "array") return [new Ze(se, ne, `array expected, ${Nn(ne)} found`)];
            if (ne.length !== 2) return [new Ze(se, ne, `array length 2 expected, length ${ne.length} found`)];
            if (P) {
              if (Nn(ne[0]) !== "object") return [new Ze(se, ne, `object expected, ${Nn(ne[0])} found`)];
              if (ne[0].zoom === void 0) return [new Ze(se, ne, "object stop key must have zoom")];
              if (ne[0].value === void 0) return [new Ze(se, ne, "object stop key must have value")];
              if (f && f > mi(ne[0].zoom)) return [new Ze(se, ne[0].zoom, "stop zoom values must appear in ascending order")];
              mi(ne[0].zoom) !== f && (f = mi(ne[0].zoom), c = void 0, g = {}), W = W.concat(_a({
                key: `${se}[0]`,
                value: ne[0],
                valueSpec: {
                  zoom: {}
                },
                validateSpec: G.validateSpec,
                style: G.style,
                styleSpec: G.styleSpec,
                objectElementValidators: {
                  zoom: Jl,
                  value: U
                }
              }))
            } else W = W.concat(U({
              key: `${se}[0]`,
              value: ne[0],
              validateSpec: G.validateSpec,
              style: G.style,
              styleSpec: G.styleSpec
            }, ne));
            return Zl(fo(ne[1])) ? W.concat([new Ze(`${se}[1]`, ne[1], "expressions are not allowed in function stops.")]) : W.concat(G.validateSpec({
              key: `${se}[1]`,
              value: ne[1],
              valueSpec: t,
              validateSpec: G.validateSpec,
              style: G.style,
              styleSpec: G.styleSpec
            }))
          }

          function U(G, W) {
            const ne = Nn(G.value),
              se = mi(G.value),
              ge = G.value !== null ? G.value : W;
            if (o) {
              if (ne !== o) return [new Ze(G.key, ge, `${ne} stop domain type must match previous stop domain type ${o}`)]
            } else o = ne;
            if (ne !== "number" && ne !== "string" && ne !== "boolean") return [new Ze(G.key, ge, "stop domain value must be a number, string, or boolean")];
            if (ne !== "number" && r !== "categorical") {
              let We = `number expected, ${ne} found`;
              return Cs(t) && r === void 0 && (We += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Ze(G.key, ge, We)]
            }
            return r !== "categorical" || ne !== "number" || isFinite(se) && Math.floor(se) === se ? r !== "categorical" && ne === "number" && c !== void 0 && se < c ? [new Ze(G.key, ge, "stop domain values must appear in ascending order")] : (c = se, r === "categorical" && se in g ? [new Ze(G.key, ge, "stop domain values must be unique")] : (g[se] = !0, [])) : [new Ze(G.key, ge, `integer expected, found ${se}`)]
          }
        }

        function Ms(n) {
          const t = (n.expressionContext === "property" ? wd : Jo)(fo(n.value), n.valueSpec);
          if (t.result === "error") return t.value.map((o => new Ze(`${n.key}${o.key}`, n.value, o.message)));
          const r = t.value.expression || t.value._styleExpression.expression;
          if (n.expressionContext === "property" && n.propertyKey === "text-font" && !r.outputDefined()) return [new Ze(n.key, n.value, `Invalid data expression for "${n.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (n.expressionContext === "property" && n.propertyType === "layout" && !el(r)) return [new Ze(n.key, n.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (n.expressionContext === "filter" && !el(r)) return [new Ze(n.key, n.value, '"feature-state" data expressions are not supported with filters.')];
          if (n.expressionContext && n.expressionContext.indexOf("cluster") === 0) {
            if (!Vl(r, ["zoom", "feature-state"])) return [new Ze(n.key, n.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (n.expressionContext === "cluster-initial" && !ql(r)) return [new Ze(n.key, n.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
          }
          return []
        }

        function uu(n) {
          const t = n.key,
            r = n.value,
            o = Nn(r);
          return o !== "string" ? [new Ze(t, r, `color expected, ${o} found`)] : gr.parse(String(r)) ? [] : [new Ze(t, r, `color expected, "${r}" found`)]
        }

        function il(n) {
          const t = n.key,
            r = n.value,
            o = n.valueSpec,
            c = [];
          return Array.isArray(o.values) ? o.values.indexOf(mi(r)) === -1 && c.push(new Ze(t, r, `expected one of [${o.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(o.values).indexOf(mi(r)) === -1 && c.push(new Ze(t, r, `expected one of [${Object.keys(o.values).join(", ")}], ${JSON.stringify(r)} found`)), c
        }

        function hu(n) {
          return $l(fo(n.value)) ? Ms(Pr({}, n, {
            expressionContext: "filter",
            valueSpec: {
              value: "boolean"
            }
          })) : du(n)
        }

        function du(n) {
          const t = n.value,
            r = n.key;
          if (Nn(t) !== "array") return [new Ze(r, t, `array expected, ${Nn(t)} found`)];
          const o = n.styleSpec;
          let c, f = [];
          if (t.length < 1) return [new Ze(r, t, "filter array must have at least 1 element")];
          switch (f = f.concat(il({
              key: `${r}[0]`,
              value: t[0],
              valueSpec: o.filter_operator,
              style: n.style,
              styleSpec: n.styleSpec
            })), mi(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && mi(t[1]) === "$type" && f.push(new Ze(r, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && f.push(new Ze(r, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (c = Nn(t[1]), c !== "string" && f.push(new Ze(`${r}[1]`, t[1], `string expected, ${c} found`)));
              for (let g = 2; g < t.length; g++) c = Nn(t[g]), mi(t[1]) === "$type" ? f = f.concat(il({
                key: `${r}[${g}]`,
                value: t[g],
                valueSpec: o.geometry_type,
                style: n.style,
                styleSpec: n.styleSpec
              })) : c !== "string" && c !== "number" && c !== "boolean" && f.push(new Ze(`${r}[${g}]`, t[g], `string, number, or boolean expected, ${c} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let g = 1; g < t.length; g++) f = f.concat(du({
                key: `${r}[${g}]`,
                value: t[g],
                style: n.style,
                styleSpec: n.styleSpec
              }));
              break;
            case "has":
            case "!has":
              c = Nn(t[1]), t.length !== 2 ? f.push(new Ze(r, t, `filter array for "${t[0]}" operator must have 2 elements`)) : c !== "string" && f.push(new Ze(`${r}[1]`, t[1], `string expected, ${c} found`))
          }
          return f
        }

        function pu(n, t) {
          const r = n.key,
            o = n.validateSpec,
            c = n.style,
            f = n.styleSpec,
            g = n.value,
            y = n.objectKey,
            w = f[`${t}_${n.layerType}`];
          if (!w) return [];
          const P = y.match(/^(.*)-transition$/);
          if (t === "paint" && P && w[P[1]] && w[P[1]].transition) return o({
            key: r,
            value: g,
            valueSpec: f.transition,
            style: c,
            styleSpec: f
          });
          const M = n.valueSpec || w[y];
          if (!M) return [new Ze(r, g, `unknown property "${y}"`)];
          let R;
          if (Nn(g) === "string" && Cs(M) && !M.tokens && (R = /^{([^}]+)}$/.exec(g))) return [new Ze(r, g, `"${y}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(R[1])} }\`.`)];
          const U = [];
          return n.layerType === "symbol" && y === "text-font" && Ul(fo(g)) && mi(g.type) === "identity" && U.push(new Ze(r, g, '"text-font" does not support identity functions')), U.concat(o({
            key: n.key,
            value: g,
            valueSpec: M,
            style: c,
            styleSpec: f,
            expressionContext: "property",
            propertyType: t,
            propertyKey: y
          }))
        }

        function al(n) {
          return pu(n, "paint")
        }

        function Md(n) {
          return pu(n, "layout")
        }

        function fu(n) {
          let t = [];
          const r = n.value,
            o = n.key,
            c = n.style,
            f = n.styleSpec;
          if (Nn(r) !== "object") return [new Ze(o, r, `object expected, ${Nn(r)} found`)];
          r.type || r.ref || t.push(new Ze(o, r, 'either "type" or "ref" is required'));
          let g = mi(r.type);
          const y = mi(r.ref);
          if (r.id) {
            const w = mi(r.id);
            for (let P = 0; P < n.arrayIndex; P++) {
              const M = c.layers[P];
              mi(M.id) === w && t.push(new Ze(o, r.id, `duplicate layer id "${r.id}", previously used at line ${M.id.__line__}`))
            }
          }
          if ("ref" in r) {
            let w;
            ["type", "source", "source-layer", "filter", "layout"].forEach((P => {
              P in r && t.push(new Ze(o, r[P], `"${P}" is prohibited for ref layers`))
            })), c.layers.forEach((P => {
              mi(P.id) === y && (w = P)
            })), w ? w.ref ? t.push(new Ze(o, r.ref, "ref cannot reference another ref layer")) : g = mi(w.type) : t.push(new Ze(o, r.ref, `ref layer "${y}" not found`))
          } else if (g !== "background")
            if (r.source) {
              const w = c.sources && c.sources[r.source],
                P = w && mi(w.type);
              w ? P === "vector" && g === "raster" ? t.push(new Ze(o, r.source, `layer "${r.id}" requires a raster source`)) : P !== "raster-dem" && g === "hillshade" || P !== "raster-dem" && g === "color-relief" ? t.push(new Ze(o, r.source, `layer "${r.id}" requires a raster-dem source`)) : P === "raster" && g !== "raster" ? t.push(new Ze(o, r.source, `layer "${r.id}" requires a vector source`)) : P !== "vector" || r["source-layer"] ? P === "raster-dem" && g !== "hillshade" && g !== "color-relief" ? t.push(new Ze(o, r.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : g !== "line" || !r.paint || !r.paint["line-gradient"] || P === "geojson" && w.lineMetrics || t.push(new Ze(o, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new Ze(o, r, `layer "${r.id}" must specify a "source-layer"`)) : t.push(new Ze(o, r.source, `source "${r.source}" not found`))
            } else t.push(new Ze(o, r, 'missing required property "source"'));
          return t = t.concat(_a({
            key: o,
            value: r,
            valueSpec: f.layer,
            style: n.style,
            styleSpec: n.styleSpec,
            validateSpec: n.validateSpec,
            objectElementValidators: {
              "*": () => [],
              type: () => n.validateSpec({
                key: `${o}.type`,
                value: r.type,
                valueSpec: f.layer.type,
                style: n.style,
                styleSpec: n.styleSpec,
                validateSpec: n.validateSpec,
                object: r,
                objectKey: "type"
              }),
              filter: hu,
              layout: w => _a({
                layer: r,
                key: w.key,
                value: w.value,
                style: w.style,
                styleSpec: w.styleSpec,
                validateSpec: w.validateSpec,
                objectElementValidators: {
                  "*": P => Md(Pr({
                    layerType: g
                  }, P))
                }
              }),
              paint: w => _a({
                layer: r,
                key: w.key,
                value: w.value,
                style: w.style,
                styleSpec: w.styleSpec,
                validateSpec: w.validateSpec,
                objectElementValidators: {
                  "*": P => al(Pr({
                    layerType: g
                  }, P))
                }
              })
            }
          })), t
        }

        function zo(n) {
          const t = n.value,
            r = n.key,
            o = Nn(t);
          return o !== "string" ? [new Ze(r, t, `string expected, ${o} found`)] : []
        }
        const Ad = {
          promoteId: function({
            key: n,
            value: t
          }) {
            if (Nn(t) === "string") return zo({
              key: n,
              value: t
            });
            {
              const r = [];
              for (const o in t) r.push(...zo({
                key: `${n}.${o}`,
                value: t[o]
              }));
              return r
            }
          }
        };

        function mu(n) {
          const t = n.value,
            r = n.key,
            o = n.styleSpec,
            c = n.style,
            f = n.validateSpec;
          if (!t.type) return [new Ze(r, t, '"type" is required')];
          const g = mi(t.type);
          let y;
          switch (g) {
            case "vector":
            case "raster":
              return y = _a({
                key: r,
                value: t,
                valueSpec: o[`source_${g.replace("-","_")}`],
                style: n.style,
                styleSpec: o,
                objectElementValidators: Ad,
                validateSpec: f
              }), y;
            case "raster-dem":
              return y = (function(w) {
                var P;
                const M = (P = w.sourceName) !== null && P !== void 0 ? P : "",
                  R = w.value,
                  U = w.styleSpec,
                  G = U.source_raster_dem,
                  W = w.style;
                let ne = [];
                const se = Nn(R);
                if (R === void 0) return ne;
                if (se !== "object") return ne.push(new Ze("source_raster_dem", R, `object expected, ${se} found`)), ne;
                const ge = mi(R.encoding) === "custom",
                  We = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                  Te = w.value.encoding ? `"${w.value.encoding}"` : "Default";
                for (const De in R) !ge && We.includes(De) ? ne.push(new Ze(De, R[De], `In "${M}": "${De}" is only valid when "encoding" is set to "custom". ${Te} encoding found`)) : G[De] ? ne = ne.concat(w.validateSpec({
                  key: De,
                  value: R[De],
                  valueSpec: G[De],
                  validateSpec: w.validateSpec,
                  style: W,
                  styleSpec: U
                })) : ne.push(new Ze(De, R[De], `unknown property "${De}"`));
                return ne
              })({
                sourceName: r,
                value: t,
                style: n.style,
                styleSpec: o,
                validateSpec: f
              }), y;
            case "geojson":
              if (y = _a({
                  key: r,
                  value: t,
                  valueSpec: o.source_geojson,
                  style: c,
                  styleSpec: o,
                  validateSpec: f,
                  objectElementValidators: Ad
                }), t.cluster)
                for (const w in t.clusterProperties) {
                  const [P, M] = t.clusterProperties[w], R = typeof P == "string" ? [P, ["accumulated"],
                    ["get", w]
                  ] : P;
                  y.push(...Ms({
                    key: `${r}.${w}.map`,
                    value: M,
                    expressionContext: "cluster-map"
                  })), y.push(...Ms({
                    key: `${r}.${w}.reduce`,
                    value: R,
                    expressionContext: "cluster-reduce"
                  }))
                }
              return y;
            case "video":
              return _a({
                key: r,
                value: t,
                valueSpec: o.source_video,
                style: c,
                validateSpec: f,
                styleSpec: o
              });
            case "image":
              return _a({
                key: r,
                value: t,
                valueSpec: o.source_image,
                style: c,
                validateSpec: f,
                styleSpec: o
              });
            case "canvas":
              return [new Ze(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return il({
                key: `${r}.type`,
                value: t.type,
                valueSpec: {
                  values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                }
              })
          }
        }

        function gu(n) {
          const t = n.value,
            r = n.styleSpec,
            o = r.light,
            c = n.style;
          let f = [];
          const g = Nn(t);
          if (t === void 0) return f;
          if (g !== "object") return f = f.concat([new Ze("light", t, `object expected, ${g} found`)]), f;
          for (const y in t) {
            const w = y.match(/^(.*)-transition$/);
            f = f.concat(w && o[w[1]] && o[w[1]].transition ? n.validateSpec({
              key: y,
              value: t[y],
              valueSpec: r.transition,
              validateSpec: n.validateSpec,
              style: c,
              styleSpec: r
            }) : o[y] ? n.validateSpec({
              key: y,
              value: t[y],
              valueSpec: o[y],
              validateSpec: n.validateSpec,
              style: c,
              styleSpec: r
            }) : [new Ze(y, t[y], `unknown property "${y}"`)])
          }
          return f
        }

        function As(n) {
          const t = n.value,
            r = n.styleSpec,
            o = r.sky,
            c = n.style,
            f = Nn(t);
          if (t === void 0) return [];
          if (f !== "object") return [new Ze("sky", t, `object expected, ${f} found`)];
          let g = [];
          for (const y in t) g = g.concat(o[y] ? n.validateSpec({
            key: y,
            value: t[y],
            valueSpec: o[y],
            style: c,
            styleSpec: r
          }) : [new Ze(y, t[y], `unknown property "${y}"`)]);
          return g
        }

        function kd(n) {
          const t = n.value,
            r = n.styleSpec,
            o = r.terrain,
            c = n.style;
          let f = [];
          const g = Nn(t);
          if (t === void 0) return f;
          if (g !== "object") return f = f.concat([new Ze("terrain", t, `object expected, ${g} found`)]), f;
          for (const y in t) f = f.concat(o[y] ? n.validateSpec({
            key: y,
            value: t[y],
            valueSpec: o[y],
            validateSpec: n.validateSpec,
            style: c,
            styleSpec: r
          }) : [new Ze(y, t[y], `unknown property "${y}"`)]);
          return f
        }

        function Ed(n) {
          let t = [];
          const r = n.value,
            o = n.key;
          if (Array.isArray(r)) {
            const c = [],
              f = [];
            for (const g in r) r[g].id && c.includes(r[g].id) && t.push(new Ze(o, r, `all the sprites' ids must be unique, but ${r[g].id} is duplicated`)), c.push(r[g].id), r[g].url && f.includes(r[g].url) && t.push(new Ze(o, r, `all the sprites' URLs must be unique, but ${r[g].url} is duplicated`)), f.push(r[g].url), t = t.concat(_a({
              key: `${o}[${g}]`,
              value: r[g],
              valueSpec: {
                id: {
                  type: "string",
                  required: !0
                },
                url: {
                  type: "string",
                  required: !0
                }
              },
              validateSpec: n.validateSpec
            }));
            return t
          }
          return zo({
            key: o,
            value: r
          })
        }

        function Ld(n) {
          return t = n.value, t && t.constructor === Object ? [] : [new Ze(n.key, n.value, `object expected, ${Nn(n.value)} found`)];
          var t
        }
        const zd = {
          "*": () => [],
          array: Is,
          boolean: function(n) {
            const t = n.value,
              r = n.key,
              o = Nn(t);
            return o !== "boolean" ? [new Ze(r, t, `boolean expected, ${o} found`)] : []
          },
          number: Jl,
          color: uu,
          constants: Kl,
          enum: il,
          filter: hu,
          function: Id,
          layer: fu,
          object: _a,
          source: mu,
          light: gu,
          sky: As,
          terrain: kd,
          projection: function(n) {
            const t = n.value,
              r = n.styleSpec,
              o = r.projection,
              c = n.style,
              f = Nn(t);
            if (t === void 0) return [];
            if (f !== "object") return [new Ze("projection", t, `object expected, ${f} found`)];
            let g = [];
            for (const y in t) g = g.concat(o[y] ? n.validateSpec({
              key: y,
              value: t[y],
              valueSpec: o[y],
              style: c,
              styleSpec: r
            }) : [new Ze(y, t[y], `unknown property "${y}"`)]);
            return g
          },
          projectionDefinition: function(n) {
            const t = n.key;
            let r = n.value;
            r = r instanceof String ? r.valueOf() : r;
            const o = Nn(r);
            return o !== "array" || (function(c) {
              return Array.isArray(c) && c.length === 3 && typeof c[0] == "string" && typeof c[1] == "string" && typeof c[2] == "number"
            })(r) || (function(c) {
              return !!["interpolate", "step", "literal"].includes(c[0])
            })(r) ? ["array", "string"].includes(o) ? [] : [new Ze(t, r, `projection expected, invalid type "${o}" found`)] : [new Ze(t, r, `projection expected, invalid array ${JSON.stringify(r)} found`)]
          },
          string: zo,
          formatted: function(n) {
            return zo(n).length === 0 ? [] : Ms(n)
          },
          resolvedImage: function(n) {
            return zo(n).length === 0 ? [] : Ms(n)
          },
          padding: function(n) {
            const t = n.key,
              r = n.value;
            if (Nn(r) === "array") {
              if (r.length < 1 || r.length > 4) return [new Ze(t, r, `padding requires 1 to 4 values; ${r.length} values found`)];
              const o = {
                type: "number"
              };
              let c = [];
              for (let f = 0; f < r.length; f++) c = c.concat(n.validateSpec({
                key: `${t}[${f}]`,
                value: r[f],
                validateSpec: n.validateSpec,
                valueSpec: o
              }));
              return c
            }
            return Jl({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          numberArray: function(n) {
            const t = n.key,
              r = n.value;
            if (Nn(r) === "array") {
              const o = {
                type: "number"
              };
              if (r.length < 1) return [new Ze(t, r, "array length at least 1 expected, length 0 found")];
              let c = [];
              for (let f = 0; f < r.length; f++) c = c.concat(n.validateSpec({
                key: `${t}[${f}]`,
                value: r[f],
                validateSpec: n.validateSpec,
                valueSpec: o
              }));
              return c
            }
            return Jl({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          colorArray: function(n) {
            const t = n.key,
              r = n.value;
            if (Nn(r) === "array") {
              if (r.length < 1) return [new Ze(t, r, "array length at least 1 expected, length 0 found")];
              let o = [];
              for (let c = 0; c < r.length; c++) o = o.concat(uu({
                key: `${t}[${c}]`,
                value: r[c]
              }));
              return o
            }
            return uu({
              key: t,
              value: r
            })
          },
          variableAnchorOffsetCollection: function(n) {
            const t = n.key,
              r = n.value,
              o = Nn(r),
              c = n.styleSpec;
            if (o !== "array" || r.length < 1 || r.length % 2 != 0) return [new Ze(t, r, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let f = [];
            for (let g = 0; g < r.length; g += 2) f = f.concat(il({
              key: `${t}[${g}]`,
              value: r[g],
              valueSpec: c.layout_symbol["text-anchor"]
            })), f = f.concat(Is({
              key: `${t}[${g+1}]`,
              value: r[g + 1],
              valueSpec: {
                length: 2,
                value: "number"
              },
              validateSpec: n.validateSpec,
              style: n.style,
              styleSpec: c
            }));
            return f
          },
          sprite: Ed,
          state: Ld
        };

        function Ql(n) {
          const t = n.value,
            r = n.valueSpec,
            o = n.styleSpec;
          return n.validateSpec = Ql, r.expression && Ul(mi(t)) ? Id(n) : r.expression && Zl(fo(t)) ? Ms(n) : r.type && zd[r.type] ? zd[r.type](n) : _a(Pr({}, n, {
            valueSpec: r.type ? o[r.type] : r
          }))
        }

        function Dd(n) {
          const t = n.value,
            r = n.key,
            o = zo(n);
          return o.length || (t.indexOf("{fontstack}") === -1 && o.push(new Ze(r, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && o.push(new Ze(r, t, '"glyphs" url must include a "{range}" token'))), o
        }

        function ra(n, t = Q) {
          let r = [];
          return r = r.concat(Ql({
            key: "",
            value: n,
            valueSpec: t.$root,
            styleSpec: t,
            style: n,
            validateSpec: Ql,
            objectElementValidators: {
              glyphs: Dd,
              "*": () => []
            }
          })), n.constants && (r = r.concat(Kl({
            key: "constants",
            value: n.constants
          }))), va(r)
        }

        function ua(n) {
          return function(t) {
            return n(Object.assign({}, t, {
              validateSpec: Ql
            }))
          }
        }

        function va(n) {
          return [].concat(n).sort(((t, r) => t.line - r.line))
        }

        function ha(n) {
          return function(...t) {
            return va(n.apply(this, t))
          }
        }
        ra.source = ha(ua(mu)), ra.sprite = ha(ua(Ed)), ra.glyphs = ha(ua(Dd)), ra.light = ha(ua(gu)), ra.sky = ha(ua(As)), ra.terrain = ha(ua(kd)), ra.state = ha(ua(Ld)), ra.layer = ha(ua(fu)), ra.filter = ha(ua(hu)), ra.paintProperty = ha(ua(al)), ra.layoutProperty = ha(ua(Md));
        const Rd = Q,
          ks = ra,
          Tf = ks.light,
          ol = ks.sky,
          Fd = ks.paintProperty,
          _u = ks.layoutProperty;

        function Bd(n, t) {
          let r = !1;
          if (t && t.length)
            for (const o of t) n.fire(new K(new Error(o.message))), r = !0;
          return r
        }
        class es {
          constructor(t, r, o) {
            const c = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const g = new Int32Array(this.arrayBuffer);
              t = g[0], this.d = (r = g[1]) + 2 * (o = g[2]);
              for (let w = 0; w < this.d * this.d; w++) {
                const P = g[3 + w],
                  M = g[3 + w + 1];
                c.push(P === M ? null : g.subarray(P, M))
              }
              const y = g[3 + c.length + 1];
              this.keys = g.subarray(g[3 + c.length], y), this.bboxes = g.subarray(y), this.insert = this._insertReadonly
            } else {
              this.d = r + 2 * o;
              for (let g = 0; g < this.d * this.d; g++) c.push([]);
              this.keys = [], this.bboxes = []
            }
            this.n = r, this.extent = t, this.padding = o, this.scale = r / t, this.uid = 0;
            const f = o / r * t;
            this.min = -f, this.max = t + f
          }
          insert(t, r, o, c, f) {
            this._forEachCell(r, o, c, f, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(r), this.bboxes.push(o), this.bboxes.push(c), this.bboxes.push(f)
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
          }
          _insertCell(t, r, o, c, f, g) {
            this.cells[f].push(g)
          }
          query(t, r, o, c, f) {
            const g = this.min,
              y = this.max;
            if (t <= g && r <= g && y <= o && y <= c && !f) return Array.prototype.slice.call(this.keys);
            {
              const w = [];
              return this._forEachCell(t, r, o, c, this._queryCell, w, {}, f), w
            }
          }
          _queryCell(t, r, o, c, f, g, y, w) {
            const P = this.cells[f];
            if (P !== null) {
              const M = this.keys,
                R = this.bboxes;
              for (let U = 0; U < P.length; U++) {
                const G = P[U];
                if (y[G] === void 0) {
                  const W = 4 * G;
                  (w ? w(R[W + 0], R[W + 1], R[W + 2], R[W + 3]) : t <= R[W + 2] && r <= R[W + 3] && o >= R[W + 0] && c >= R[W + 1]) ? (y[G] = !0, g.push(M[G])) : y[G] = !1
                }
              }
            }
          }
          _forEachCell(t, r, o, c, f, g, y, w) {
            const P = this._convertToCellCoord(t),
              M = this._convertToCellCoord(r),
              R = this._convertToCellCoord(o),
              U = this._convertToCellCoord(c);
            for (let G = P; G <= R; G++)
              for (let W = M; W <= U; W++) {
                const ne = this.d * W + G;
                if ((!w || w(this._convertFromCellCoord(G), this._convertFromCellCoord(W), this._convertFromCellCoord(G + 1), this._convertFromCellCoord(W + 1))) && f.call(this, t, r, o, c, ne, g, y, w)) return
              }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells,
              r = 3 + this.cells.length + 1 + 1;
            let o = 0;
            for (let g = 0; g < this.cells.length; g++) o += this.cells[g].length;
            const c = new Int32Array(r + o + this.keys.length + this.bboxes.length);
            c[0] = this.extent, c[1] = this.n, c[2] = this.padding;
            let f = r;
            for (let g = 0; g < t.length; g++) {
              const y = t[g];
              c[3 + g] = f, c.set(y, f), f += y.length
            }
            return c[3 + t.length] = f, c.set(this.keys, f), f += this.keys.length, c[3 + t.length + 1] = f, c.set(this.bboxes, f), f += this.bboxes.length, c.buffer
          }
          static serialize(t, r) {
            const o = t.toArrayBuffer();
            return r && r.push(o), {
              buffer: o
            }
          }
          static deserialize(t) {
            return new es(t.buffer)
          }
        }
        const mo = {};

        function Cr(n, t, r = {}) {
          if (mo[n]) throw new Error(`${n} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", {
            value: n,
            writeable: !1
          }), mo[n] = {
            klass: t,
            omit: r.omit || [],
            shallow: r.shallow || []
          }
        }
        Cr("Object", Object), Cr("Set", Set), Cr("TransferableGridIndex", es), Cr("Color", gr), Cr("Error", Error), Cr("AJAXError", X), Cr("ResolvedImage", bn), Cr("StylePropertyFunction", Gl), Cr("StyleExpression", ou, {
          omit: ["_evaluator"]
        }), Cr("ZoomDependentExpression", su), Cr("ZoomConstantExpression", tl), Cr("CompoundExpression", Ba, {
          omit: ["_evaluate"]
        });
        for (const n in Ss) Ss[n]._classRegistryKey || Cr(`Expression_${n}`, Ss[n]);

        function Od(n) {
          return n && typeof ArrayBuffer < "u" && (n instanceof ArrayBuffer || n.constructor && n.constructor.name === "ArrayBuffer")
        }

        function vu(n) {
          return n.$name || n.constructor._classRegistryKey
        }

        function Nd(n) {
          return !(function(t) {
            if (t === null || typeof t != "object") return !1;
            const r = vu(t);
            return !(!r || r === "Object")
          })(n) && (n == null || typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n instanceof Boolean || n instanceof Number || n instanceof String || n instanceof Date || n instanceof RegExp || n instanceof Blob || n instanceof Error || Od(n) || Gt(n) || ArrayBuffer.isView(n) || n instanceof ImageData)
        }

        function go(n, t) {
          if (Nd(n)) return (Od(n) || Gt(n)) && t && t.push(n), ArrayBuffer.isView(n) && t && t.push(n.buffer), n instanceof ImageData && t && t.push(n.data.buffer), n;
          if (Array.isArray(n)) {
            const f = [];
            for (const g of n) f.push(go(g, t));
            return f
          }
          if (typeof n != "object") throw new Error("can't serialize object of type " + typeof n);
          const r = vu(n);
          if (!r) throw new Error(`can't serialize object of unregistered class ${n.constructor.name}`);
          if (!mo[r]) throw new Error(`${r} is not registered.`);
          const {
            klass: o
          } = mo[r], c = o.serialize ? o.serialize(n, t) : {};
          if (o.serialize) {
            if (t && c === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property")
          } else {
            for (const f in n) {
              if (!n.hasOwnProperty(f) || mo[r].omit.indexOf(f) >= 0) continue;
              const g = n[f];
              c[f] = mo[r].shallow.indexOf(f) >= 0 ? g : go(g, t)
            }
            n instanceof Error && (c.message = n.message)
          }
          if (c.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return r !== "Object" && (c.$name = r), c
        }

        function sl(n) {
          if (Nd(n)) return n;
          if (Array.isArray(n)) return n.map(sl);
          if (typeof n != "object") throw new Error("can't deserialize object of type " + typeof n);
          const t = vu(n) || "Object";
          if (!mo[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const {
            klass: r
          } = mo[t];
          if (!r) throw new Error(`can't deserialize unregistered class ${t}`);
          if (r.deserialize) return r.deserialize(n);
          const o = Object.create(r.prototype);
          for (const c of Object.keys(n)) {
            if (c === "$name") continue;
            const f = n[c];
            o[c] = mo[t].shallow.indexOf(c) >= 0 ? f : sl(f)
          }
          return o
        }
        class yu {
          constructor() {
            this.first = !0
          }
          update(t, r) {
            const o = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = o, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = o, !0) : (this.lastFloorZoom > o ? (this.lastIntegerZoom = o + 1, this.lastIntegerZoomTime = r) : this.lastFloorZoom < o && (this.lastIntegerZoom = o, this.lastIntegerZoomTime = r), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = o, !0))
          }
        }
        const Dn = {
          "Latin-1 Supplement": n => n >= 128 && n <= 255,
          "Hangul Jamo": n => n >= 4352 && n <= 4607,
          Khmer: n => n >= 6016 && n <= 6143,
          "General Punctuation": n => n >= 8192 && n <= 8303,
          "Letterlike Symbols": n => n >= 8448 && n <= 8527,
          "Number Forms": n => n >= 8528 && n <= 8591,
          "Miscellaneous Technical": n => n >= 8960 && n <= 9215,
          "Control Pictures": n => n >= 9216 && n <= 9279,
          "Optical Character Recognition": n => n >= 9280 && n <= 9311,
          "Enclosed Alphanumerics": n => n >= 9312 && n <= 9471,
          "Geometric Shapes": n => n >= 9632 && n <= 9727,
          "Miscellaneous Symbols": n => n >= 9728 && n <= 9983,
          "Miscellaneous Symbols and Arrows": n => n >= 11008 && n <= 11263,
          "Ideographic Description Characters": n => n >= 12272 && n <= 12287,
          "CJK Symbols and Punctuation": n => n >= 12288 && n <= 12351,
          Hiragana: n => n >= 12352 && n <= 12447,
          Katakana: n => n >= 12448 && n <= 12543,
          Kanbun: n => n >= 12688 && n <= 12703,
          "CJK Strokes": n => n >= 12736 && n <= 12783,
          "Enclosed CJK Letters and Months": n => n >= 12800 && n <= 13055,
          "CJK Compatibility": n => n >= 13056 && n <= 13311,
          "Yijing Hexagram Symbols": n => n >= 19904 && n <= 19967,
          "CJK Unified Ideographs": n => n >= 19968 && n <= 40959,
          "Hangul Syllables": n => n >= 44032 && n <= 55215,
          "Private Use Area": n => n >= 57344 && n <= 63743,
          "Vertical Forms": n => n >= 65040 && n <= 65055,
          "CJK Compatibility Forms": n => n >= 65072 && n <= 65103,
          "Small Form Variants": n => n >= 65104 && n <= 65135,
          "Halfwidth and Fullwidth Forms": n => n >= 65280 && n <= 65519
        };

        function xu(n) {
          for (const t of n)
            if (ec(t.charCodeAt(0))) return !0;
          return !1
        }

        function bu(n) {
          for (const t of n)
            if (!qd(t.charCodeAt(0))) return !1;
          return !0
        }

        function Es(n) {
          const t = n.map((r => {
            try {
              return new RegExp(`\\p{sc=${r}}`, "u").source
            } catch {
              return null
            }
          })).filter((r => r));
          return new RegExp(t.join("|"), "u")
        }
        const jd = Es(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);

        function qd(n) {
          return !jd.test(String.fromCodePoint(n))
        }
        const wu = Es(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);

        function ec(n) {
          return !(n !== 746 && n !== 747 && (n < 4352 || !(Dn["CJK Compatibility Forms"](n) && !(n >= 65097 && n <= 65103) || Dn["CJK Compatibility"](n) || Dn["CJK Strokes"](n) || !(!Dn["CJK Symbols and Punctuation"](n) || n >= 12296 && n <= 12305 || n >= 12308 && n <= 12319 || n === 12336) || Dn["Enclosed CJK Letters and Months"](n) || Dn["Ideographic Description Characters"](n) || Dn.Kanbun(n) || Dn.Katakana(n) && n !== 12540 || !(!Dn["Halfwidth and Fullwidth Forms"](n) || n === 65288 || n === 65289 || n === 65293 || n >= 65306 && n <= 65310 || n === 65339 || n === 65341 || n === 65343 || n >= 65371 && n <= 65503 || n === 65507 || n >= 65512 && n <= 65519) || !(!Dn["Small Form Variants"](n) || n >= 65112 && n <= 65118 || n >= 65123 && n <= 65126) || Dn["Vertical Forms"](n) || Dn["Yijing Hexagram Symbols"](n) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(n)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(n)) || wu.test(String.fromCodePoint(n)))))
        }

        function tc(n) {
          return !(ec(n) || (function(t) {
            return !!(Dn["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || Dn["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || Dn["Letterlike Symbols"](t) || Dn["Number Forms"](t) || Dn["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Dn["Control Pictures"](t) && t !== 9251 || Dn["Optical Character Recognition"](t) || Dn["Enclosed Alphanumerics"](t) || Dn["Geometric Shapes"](t) || Dn["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Dn["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Dn["CJK Symbols and Punctuation"](t) || Dn.Katakana(t) || Dn["Private Use Area"](t) || Dn["CJK Compatibility Forms"](t) || Dn["Small Form Variants"](t) || Dn["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
          })(n))
        }
        const Vd = Es(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);

        function Ud(n) {
          return Vd.test(String.fromCodePoint(n))
        }

        function Zd(n, t) {
          return !(!t && Ud(n) || n >= 2304 && n <= 3583 || n >= 3840 && n <= 4255 || Dn.Khmer(n))
        }

        function Sf(n) {
          for (const t of n)
            if (Ud(t.charCodeAt(0))) return !0;
          return !1
        }
        const _o = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {}
          }
          setState(n) {
            this.pluginStatus = n.pluginStatus, this.pluginURL = n.pluginURL
          }
          getState() {
            return {
              pluginStatus: this.pluginStatus,
              pluginURL: this.pluginURL
            }
          }
          setMethods(n) {
            if (_o.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = n.applyArabicShaping, this.processBidirectionalText = n.processBidirectionalText, this.processStyledBidirectionalText = n.processStyledBidirectionalText, this.loadScriptResolve()
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus
          }
          syncState(n, t) {
            return s(this, void 0, void 0, (function*() {
              if (this.isParsed()) return this.getState();
              if (n.pluginStatus !== "loading") return this.setState(n), n;
              const r = n.pluginURL,
                o = new Promise((f => {
                  this.loadScriptResolve = f
                }));
              t(r);
              const c = new Promise((f => setTimeout((() => f()), this.TIMEOUT)));
              if (yield Promise.race([o, c]), this.isParsed()) {
                const f = {
                  pluginStatus: "loaded",
                  pluginURL: r
                };
                return this.setState(f), f
              }
              throw this.setState({
                pluginStatus: "error",
                pluginURL: ""
              }), new Error(`RTL Text Plugin failed to import scripts from ${r}`)
            }))
          }
        };
        class ai {
          constructor(t, r) {
            this.isSupportedScript = Gd, this.zoom = t, r ? (this.now = r.now || 0, this.fadeDuration = r.fadeDuration || 0, this.zoomHistory = r.zoomHistory || new yu, this.transition = r.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new yu, this.transition = {})
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
          }
          getCrossfadeParameters() {
            const t = this.zoom,
              r = t - Math.floor(t),
              o = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? {
              fromScale: 2,
              toScale: 1,
              t: r + (1 - r) * o
            } : {
              fromScale: .5,
              toScale: 1,
              t: 1 - (1 - o) * r
            }
          }
        }

        function Gd(n) {
          return (function(t, r) {
            for (const o of t)
              if (!Zd(o.charCodeAt(0), r)) return !1;
            return !0
          })(n, _o.getRTLTextPluginStatus() === "loaded")
        }
        class ll {
          constructor(t, r, o) {
            this.property = t, this.value = r, this.expression = (function(c, f, g) {
              if (Ul(c)) return new Gl(c, f);
              if (Zl(c)) {
                const y = wd(c, f, g);
                if (y.result === "error") throw new Error(y.value.map((w => `${w.key}: ${w.message}`)).join(", "));
                return y.value
              } {
                let y = c;
                return f.type === "color" && typeof c == "string" ? y = gr.parse(c) : f.type !== "padding" || typeof c != "number" && !Array.isArray(c) ? f.type !== "numberArray" || typeof c != "number" && !Array.isArray(c) ? f.type !== "colorArray" || typeof c != "string" && !Array.isArray(c) ? f.type === "variableAnchorOffsetCollection" && Array.isArray(c) ? y = Bn.parse(c) : f.type === "projectionDefinition" && typeof c == "string" && (y = vn.parse(c)) : y = Mn.parse(c) : y = $n.parse(c) : y = qn.parse(c), {
                  globalStateRefs: new Set,
                  _globalState: null,
                  kind: "constant",
                  evaluate: () => y
                }
              }
            })(r === void 0 ? t.specification.default : r, t.specification, o)
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite"
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || new Set
          }
          possiblyEvaluate(t, r, o) {
            return this.property.possiblyEvaluate(this, t, r, o)
          }
        }
        class Tu {
          constructor(t, r) {
            this.property = t, this.value = new ll(t, void 0, r)
          }
          transitioned(t, r) {
            return new Su(this.property, this.value, r, ht({}, t.transition, this.transition), t.now)
          }
          untransitioned() {
            return new Su(this.property, this.value, null, {}, 0)
          }
        }
        class Hd {
          constructor(t, r) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues), this._globalState = r
          }
          getValue(t) {
            return Ht(this._values[t].value.value)
          }
          setValue(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Tu(this._values[t].property, this._globalState)), this._values[t].value = new ll(this._values[t].property, r === null ? void 0 : Ht(r), this._globalState)
          }
          getTransition(t) {
            return Ht(this._values[t].transition)
          }
          setTransition(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Tu(this._values[t].property, this._globalState)), this._values[t].transition = Ht(r) || void 0
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const o = this.getValue(r);
              o !== void 0 && (t[r] = o);
              const c = this.getTransition(r);
              c !== void 0 && (t[`${r}-transition`] = c)
            }
            return t
          }
          transitioned(t, r) {
            const o = new Pu(this._properties);
            for (const c of Object.keys(this._values)) o._values[c] = this._values[c].transitioned(t, r._values[c]);
            return o
          }
          untransitioned() {
            const t = new Pu(this._properties);
            for (const r of Object.keys(this._values)) t._values[r] = this._values[r].untransitioned();
            return t
          }
        }
        class Su {
          constructor(t, r, o, c, f) {
            this.property = t, this.value = r, this.begin = f + c.delay || 0, this.end = this.begin + c.duration || 0, t.specification.transition && (c.delay || c.duration) && (this.prior = o)
          }
          possiblyEvaluate(t, r, o) {
            const c = t.now || 0,
              f = this.value.possiblyEvaluate(t, r, o),
              g = this.prior;
            if (g) {
              if (c > this.end) return this.prior = null, f;
              if (this.value.isDataDriven()) return this.prior = null, f;
              if (c < this.begin) return g.possiblyEvaluate(t, r, o);
              {
                const y = (c - this.begin) / (this.end - this.begin);
                return this.property.interpolate(g.possiblyEvaluate(t, r, o), f, Pt(y))
              }
            }
            return f
          }
        }
        class Pu {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues)
          }
          possiblyEvaluate(t, r, o) {
            const c = new ts(this._properties);
            for (const f of Object.keys(this._values)) c._values[f] = this._values[f].possiblyEvaluate(t, r, o);
            return c
          }
          hasTransition() {
            for (const t of Object.keys(this._values))
              if (this._values[t].prior) return !0;
            return !1
          }
        }
        class Wd {
          constructor(t, r) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._globalState = r
          }
          hasValue(t) {
            return this._values[t].value !== void 0
          }
          getValue(t) {
            return Ht(this._values[t].value)
          }
          setValue(t, r) {
            this._values[t] = new ll(this._values[t].property, r === null ? void 0 : Ht(r), this._globalState)
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const o = this.getValue(r);
              o !== void 0 && (t[r] = o)
            }
            return t
          }
          possiblyEvaluate(t, r, o) {
            const c = new ts(this._properties);
            for (const f of Object.keys(this._values)) c._values[f] = this._values[f].possiblyEvaluate(t, r, o);
            return c
          }
        }
        class Za {
          constructor(t, r, o) {
            this.property = t, this.value = r, this.parameters = o
          }
          isConstant() {
            return this.value.kind === "constant"
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t
          }
          evaluate(t, r, o, c) {
            return this.property.evaluate(this.value, this.parameters, t, r, o, c)
          }
        }
        class ts {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues)
          }
          get(t) {
            return this._values[t]
          }
        }
        class Hr {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(r)
          }
          interpolate(t, r, o) {
            const c = Fa[this.specification.type];
            return c ? c(t, r, o) : t
          }
        }
        class an {
          constructor(t, r) {
            this.specification = t, this.overrides = r
          }
          possiblyEvaluate(t, r, o, c) {
            return new Za(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? {
              kind: "constant",
              value: t.expression.evaluate(r, null, {}, o, c)
            } : t.expression, r)
          }
          interpolate(t, r, o) {
            if (t.value.kind !== "constant" || r.value.kind !== "constant") return t;
            if (t.value.value === void 0 || r.value.value === void 0) return new Za(this, {
              kind: "constant",
              value: void 0
            }, t.parameters);
            const c = Fa[this.specification.type];
            if (c) {
              const f = c(t.value.value, r.value.value, o);
              return new Za(this, {
                kind: "constant",
                value: f
              }, t.parameters)
            }
            return t
          }
          evaluate(t, r, o, c, f, g) {
            return t.kind === "constant" ? t.value : t.evaluate(r, o, c, f, g)
          }
        }
        class cl extends an {
          possiblyEvaluate(t, r, o, c) {
            if (t.value === void 0) return new Za(this, {
              kind: "constant",
              value: void 0
            }, r);
            if (t.expression.kind === "constant") {
              const f = t.expression.evaluate(r, null, {}, o, c),
                g = t.property.specification.type === "resolvedImage" && typeof f != "string" ? f.name : f,
                y = this._calculate(g, g, g, r);
              return new Za(this, {
                kind: "constant",
                value: y
              }, r)
            }
            if (t.expression.kind === "camera") {
              const f = this._calculate(t.expression.evaluate({
                zoom: r.zoom - 1
              }), t.expression.evaluate({
                zoom: r.zoom
              }), t.expression.evaluate({
                zoom: r.zoom + 1
              }), r);
              return new Za(this, {
                kind: "constant",
                value: f
              }, r)
            }
            return new Za(this, t.expression, r)
          }
          evaluate(t, r, o, c, f, g) {
            if (t.kind === "source") {
              const y = t.evaluate(r, o, c, f, g);
              return this._calculate(y, y, y, r)
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({
              zoom: Math.floor(r.zoom) - 1
            }, o, c), t.evaluate({
              zoom: Math.floor(r.zoom)
            }, o, c), t.evaluate({
              zoom: Math.floor(r.zoom) + 1
            }, o, c), r) : t.value
          }
          _calculate(t, r, o, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: o,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class $d {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, o, c) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const f = t.expression.evaluate(r, null, {}, o, c);
                return this._calculate(f, f, f, r)
              }
              return this._calculate(t.expression.evaluate(new ai(Math.floor(r.zoom - 1), r)), t.expression.evaluate(new ai(Math.floor(r.zoom), r)), t.expression.evaluate(new ai(Math.floor(r.zoom + 1), r)), r)
            }
          }
          _calculate(t, r, o, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: o,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class ul {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, o, c) {
            return !!t.expression.evaluate(r, null, {}, o, c)
          }
          interpolate() {
            return !1
          }
        }
        class na {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const r in t) {
              const o = t[r];
              o.specification.overridable && this.overridableProperties.push(r);
              const c = this.defaultPropertyValues[r] = new ll(o, void 0, void 0),
                f = this.defaultTransitionablePropertyValues[r] = new Tu(o, void 0);
              this.defaultTransitioningPropertyValues[r] = f.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = c.possiblyEvaluate({})
            }
          }
        }
        Cr("DataDrivenProperty", an), Cr("DataConstantProperty", Hr), Cr("CrossFadedDataDrivenProperty", cl), Cr("CrossFadedProperty", $d), Cr("ColorRampProperty", ul);
        const Cu = "-transition";
        class Ga extends he {
          constructor(t, r, o) {
            if (super(), this.id = t.id, this.type = t.type, this._globalState = o, this._featureFilter = {
                filter: () => !0,
                needGeometry: !1,
                getGlobalStateRefs: () => new Set
              }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = rl(t.filter, o)), r.layout && (this._unevaluatedLayout = new Wd(r.layout, o)), r.paint)) {
              this._transitionablePaint = new Hd(r.paint, o);
              for (const c in t.paint) this.setPaintProperty(c, t.paint[c], {
                validate: !1
              });
              for (const c in t.layout) this.setLayoutProperty(c, t.layout[c], {
                validate: !1
              });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new ts(r.paint)
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = rl(t, this._globalState)
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = new Set;
            if (this._unevaluatedLayout)
              for (const r in this._unevaluatedLayout._values) {
                const o = this._unevaluatedLayout._values[r];
                for (const c of o.getGlobalStateRefs()) t.add(c)
              }
            for (const r of this._featureFilter.getGlobalStateRefs()) t.add(r);
            return t
          }
          getPaintAffectingGlobalStateRefs() {
            var t;
            const r = new globalThis.Map;
            if (this._transitionablePaint)
              for (const o in this._transitionablePaint._values) {
                const c = this._transitionablePaint._values[o].value;
                for (const f of c.getGlobalStateRefs()) {
                  const g = (t = r.get(f)) !== null && t !== void 0 ? t : [];
                  g.push({
                    name: o,
                    value: c.value
                  }), r.set(f, g)
                }
              }
            return r
          }
          setLayoutProperty(t, r, o = {}) {
            r != null && this._validate(_u, `layers.${this.id}.layout.${t}`, t, r, o) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, r) : this.visibility = r)
          }
          getPaintProperty(t) {
            return t.endsWith(Cu) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
          }
          setPaintProperty(t, r, o = {}) {
            if (r != null && this._validate(Fd, `layers.${this.id}.paint.${t}`, t, r, o)) return !1;
            if (t.endsWith(Cu)) return this._transitionablePaint.setTransition(t.slice(0, -11), r || void 0), !1;
            {
              const c = this._transitionablePaint._values[t],
                f = c.property.specification["property-type"] === "cross-faded-data-driven",
                g = c.value.isDataDriven(),
                y = c.value;
              this._transitionablePaint.setValue(t, r), this._handleSpecialPaintPropertyUpdate(t);
              const w = this._transitionablePaint._values[t].value;
              return w.isDataDriven() || g || f || this._handleOverridablePaintPropertyUpdate(t, y, w)
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {}
          _handleOverridablePaintPropertyUpdate(t, r, o) {
            return !1
          }
          isHidden(t, r = !1) {
            return !!(this.minzoom && t < (r ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition()
          }
          recalculate(t, r) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, r)
          }
          serialize() {
            const t = {
              id: this.id,
              type: this.type,
              source: this.source,
              "source-layer": this.sourceLayer,
              metadata: this.metadata,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              filter: this.filter,
              layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
              paint: this._transitionablePaint && this._transitionablePaint.serialize()
            };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Nt(t, ((r, o) => !(r === void 0 || o === "layout" && !Object.keys(r).length || o === "paint" && !Object.keys(r).length)))
          }
          _validate(t, r, o, c, f = {}) {
            return (!f || f.validate !== !1) && Bd(this, t.call(ks, {
              key: r,
              layerType: this.type,
              objectKey: o,
              value: c,
              styleSpec: Q,
              style: {
                glyphs: !0,
                sprite: !0
              }
            }))
          }
          is3D() {
            return !1
          }
          isTileClipped() {
            return !1
          }
          hasOffscreenPass() {
            return !1
          }
          resize() {}
          isStateDependent() {
            for (const t in this.paint._values) {
              const r = this.paint.get(t);
              if (r instanceof Za && Cs(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return !0
            }
            return !1
          }
        }
        let Xd;
        var Pf = {
          get paint() {
            return Xd = Xd || new na({
              "raster-opacity": new Hr(Q.paint_raster["raster-opacity"]),
              "raster-hue-rotate": new Hr(Q.paint_raster["raster-hue-rotate"]),
              "raster-brightness-min": new Hr(Q.paint_raster["raster-brightness-min"]),
              "raster-brightness-max": new Hr(Q.paint_raster["raster-brightness-max"]),
              "raster-saturation": new Hr(Q.paint_raster["raster-saturation"]),
              "raster-contrast": new Hr(Q.paint_raster["raster-contrast"]),
              "raster-resampling": new Hr(Q.paint_raster["raster-resampling"]),
              "raster-fade-duration": new Hr(Q.paint_raster["raster-fade-duration"])
            })
          }
        };
        class Cf extends Ga {
          constructor(t, r) {
            super(t, Pf, r)
          }
        }
        const If = {
          Int8: Int8Array,
          Uint8: Uint8Array,
          Int16: Int16Array,
          Uint16: Uint16Array,
          Int32: Int32Array,
          Uint32: Uint32Array,
          Float32: Float32Array
        };
        class ro {
          constructor(t, r) {
            this._structArray = t, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
          }
        }
        class gi {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0)
          }
          static serialize(t, r) {
            return t._trim(), r && (t.isTransferred = !0, r.push(t.arrayBuffer)), {
              length: t.length,
              arrayBuffer: t.arrayBuffer
            }
          }
          static deserialize(t) {
            const r = Object.create(this.prototype);
            return r.arrayBuffer = t.arrayBuffer, r.length = t.length, r.capacity = t.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
          }
          clear() {
            this.length = 0
          }
          resize(t) {
            this.reserve(t), this.length = t
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const r = this.uint8;
              this._refreshViews(), r && this.uint8.set(r)
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
          }
        }

        function Si(n, t = 1) {
          let r = 0,
            o = 0;
          return {
            members: n.map((c => {
              const f = If[c.type].BYTES_PER_ELEMENT,
                g = r = Yd(r, Math.max(t, f)),
                y = c.components || 1;
              return o = Math.max(o, f), r += f * y, {
                name: c.name,
                type: c.type,
                components: y,
                offset: g
              }
            })),
            size: Yd(r, Math.max(o, t)),
            alignment: t
          }
        }

        function Yd(n, t) {
          return Math.ceil(n / t) * t
        }
        class Ls extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, t, r)
          }
          emplace(t, r, o) {
            const c = 2 * t;
            return this.int16[c + 0] = r, this.int16[c + 1] = o, t
          }
        }
        Ls.prototype.bytesPerElement = 4, Cr("StructArrayLayout2i4", Ls);
        class rc extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, o)
          }
          emplace(t, r, o, c) {
            const f = 3 * t;
            return this.int16[f + 0] = r, this.int16[f + 1] = o, this.int16[f + 2] = c, t
          }
        }
        rc.prototype.bytesPerElement = 6, Cr("StructArrayLayout3i6", rc);
        class Iu extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, r, o, c)
          }
          emplace(t, r, o, c, f) {
            const g = 4 * t;
            return this.int16[g + 0] = r, this.int16[g + 1] = o, this.int16[g + 2] = c, this.int16[g + 3] = f, t
          }
        }
        Iu.prototype.bytesPerElement = 8, Cr("StructArrayLayout4i8", Iu);
        class vo extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, f, g) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, r, o, c, f, g)
          }
          emplace(t, r, o, c, f, g, y) {
            const w = 6 * t;
            return this.int16[w + 0] = r, this.int16[w + 1] = o, this.int16[w + 2] = c, this.int16[w + 3] = f, this.int16[w + 4] = g, this.int16[w + 5] = y, t
          }
        }
        vo.prototype.bytesPerElement = 12, Cr("StructArrayLayout2i4i12", vo);
        class nc extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, f, g) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, r, o, c, f, g)
          }
          emplace(t, r, o, c, f, g, y) {
            const w = 4 * t,
              P = 8 * t;
            return this.int16[w + 0] = r, this.int16[w + 1] = o, this.uint8[P + 4] = c, this.uint8[P + 5] = f, this.uint8[P + 6] = g, this.uint8[P + 7] = y, t
          }
        }
        nc.prototype.bytesPerElement = 8, Cr("StructArrayLayout2i4ub8", nc);
        class rs extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, t, r)
          }
          emplace(t, r, o) {
            const c = 2 * t;
            return this.float32[c + 0] = r, this.float32[c + 1] = o, t
          }
        }
        rs.prototype.bytesPerElement = 8, Cr("StructArrayLayout2f8", rs);
        class ic extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, f, g, y, w, P, M) {
            const R = this.length;
            return this.resize(R + 1), this.emplace(R, t, r, o, c, f, g, y, w, P, M)
          }
          emplace(t, r, o, c, f, g, y, w, P, M, R) {
            const U = 10 * t;
            return this.uint16[U + 0] = r, this.uint16[U + 1] = o, this.uint16[U + 2] = c, this.uint16[U + 3] = f, this.uint16[U + 4] = g, this.uint16[U + 5] = y, this.uint16[U + 6] = w, this.uint16[U + 7] = P, this.uint16[U + 8] = M, this.uint16[U + 9] = R, t
          }
        }
        ic.prototype.bytesPerElement = 20, Cr("StructArrayLayout10ui20", ic);
        class hl extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, f, g, y, w) {
            const P = this.length;
            return this.resize(P + 1), this.emplace(P, t, r, o, c, f, g, y, w)
          }
          emplace(t, r, o, c, f, g, y, w, P) {
            const M = 8 * t;
            return this.uint16[M + 0] = r, this.uint16[M + 1] = o, this.uint16[M + 2] = c, this.uint16[M + 3] = f, this.uint16[M + 4] = g, this.uint16[M + 5] = y, this.uint16[M + 6] = w, this.uint16[M + 7] = P, t
          }
        }
        hl.prototype.bytesPerElement = 16, Cr("StructArrayLayout8ui16", hl);
        class Mu extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, f, g, y, w, P, M, R, U) {
            const G = this.length;
            return this.resize(G + 1), this.emplace(G, t, r, o, c, f, g, y, w, P, M, R, U)
          }
          emplace(t, r, o, c, f, g, y, w, P, M, R, U, G) {
            const W = 12 * t;
            return this.int16[W + 0] = r, this.int16[W + 1] = o, this.int16[W + 2] = c, this.int16[W + 3] = f, this.uint16[W + 4] = g, this.uint16[W + 5] = y, this.uint16[W + 6] = w, this.uint16[W + 7] = P, this.int16[W + 8] = M, this.int16[W + 9] = R, this.int16[W + 10] = U, this.int16[W + 11] = G, t
          }
        }
        Mu.prototype.bytesPerElement = 24, Cr("StructArrayLayout4i4ui4i24", Mu);
        class zs extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, o)
          }
          emplace(t, r, o, c) {
            const f = 3 * t;
            return this.float32[f + 0] = r, this.float32[f + 1] = o, this.float32[f + 2] = c, t
          }
        }
        zs.prototype.bytesPerElement = 12, Cr("StructArrayLayout3f12", zs);
        class ns extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint32[1 * t + 0] = r, t
          }
        }
        ns.prototype.bytesPerElement = 4, Cr("StructArrayLayout1ul4", ns);
        class Au extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, f, g, y, w, P) {
            const M = this.length;
            return this.resize(M + 1), this.emplace(M, t, r, o, c, f, g, y, w, P)
          }
          emplace(t, r, o, c, f, g, y, w, P, M) {
            const R = 10 * t,
              U = 5 * t;
            return this.int16[R + 0] = r, this.int16[R + 1] = o, this.int16[R + 2] = c, this.int16[R + 3] = f, this.int16[R + 4] = g, this.int16[R + 5] = y, this.uint32[U + 3] = w, this.uint16[R + 8] = P, this.uint16[R + 9] = M, t
          }
        }
        Au.prototype.bytesPerElement = 20, Cr("StructArrayLayout6i1ul2ui20", Au);
        class ac extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, f, g) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, r, o, c, f, g)
          }
          emplace(t, r, o, c, f, g, y) {
            const w = 6 * t;
            return this.int16[w + 0] = r, this.int16[w + 1] = o, this.int16[w + 2] = c, this.int16[w + 3] = f, this.int16[w + 4] = g, this.int16[w + 5] = y, t
          }
        }
        ac.prototype.bytesPerElement = 12, Cr("StructArrayLayout2i2i2i12", ac);
        class is extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, f) {
            const g = this.length;
            return this.resize(g + 1), this.emplace(g, t, r, o, c, f)
          }
          emplace(t, r, o, c, f, g) {
            const y = 4 * t,
              w = 8 * t;
            return this.float32[y + 0] = r, this.float32[y + 1] = o, this.float32[y + 2] = c, this.int16[w + 6] = f, this.int16[w + 7] = g, t
          }
        }
        is.prototype.bytesPerElement = 16, Cr("StructArrayLayout2f1f2i16", is);
        class ku extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, f, g) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, r, o, c, f, g)
          }
          emplace(t, r, o, c, f, g, y) {
            const w = 16 * t,
              P = 4 * t,
              M = 8 * t;
            return this.uint8[w + 0] = r, this.uint8[w + 1] = o, this.float32[P + 1] = c, this.float32[P + 2] = f, this.int16[M + 6] = g, this.int16[M + 7] = y, t
          }
        }
        ku.prototype.bytesPerElement = 16, Cr("StructArrayLayout2ub2f2i16", ku);
        class oc extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, o)
          }
          emplace(t, r, o, c) {
            const f = 3 * t;
            return this.uint16[f + 0] = r, this.uint16[f + 1] = o, this.uint16[f + 2] = c, t
          }
        }
        oc.prototype.bytesPerElement = 6, Cr("StructArrayLayout3ui6", oc);
        class sc extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, f, g, y, w, P, M, R, U, G, W, ne, se, ge) {
            const We = this.length;
            return this.resize(We + 1), this.emplace(We, t, r, o, c, f, g, y, w, P, M, R, U, G, W, ne, se, ge)
          }
          emplace(t, r, o, c, f, g, y, w, P, M, R, U, G, W, ne, se, ge, We) {
            const Te = 24 * t,
              De = 12 * t,
              nt = 48 * t;
            return this.int16[Te + 0] = r, this.int16[Te + 1] = o, this.uint16[Te + 2] = c, this.uint16[Te + 3] = f, this.uint32[De + 2] = g, this.uint32[De + 3] = y, this.uint32[De + 4] = w, this.uint16[Te + 10] = P, this.uint16[Te + 11] = M, this.uint16[Te + 12] = R, this.float32[De + 7] = U, this.float32[De + 8] = G, this.uint8[nt + 36] = W, this.uint8[nt + 37] = ne, this.uint8[nt + 38] = se, this.uint32[De + 10] = ge, this.int16[Te + 22] = We, t
          }
        }
        sc.prototype.bytesPerElement = 48, Cr("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", sc);
        class Eu extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c, f, g, y, w, P, M, R, U, G, W, ne, se, ge, We, Te, De, nt, gt, Vt, pr, ir, ur, Kr, lr) {
            const hr = this.length;
            return this.resize(hr + 1), this.emplace(hr, t, r, o, c, f, g, y, w, P, M, R, U, G, W, ne, se, ge, We, Te, De, nt, gt, Vt, pr, ir, ur, Kr, lr)
          }
          emplace(t, r, o, c, f, g, y, w, P, M, R, U, G, W, ne, se, ge, We, Te, De, nt, gt, Vt, pr, ir, ur, Kr, lr, hr) {
            const Ct = 32 * t,
              un = 16 * t;
            return this.int16[Ct + 0] = r, this.int16[Ct + 1] = o, this.int16[Ct + 2] = c, this.int16[Ct + 3] = f, this.int16[Ct + 4] = g, this.int16[Ct + 5] = y, this.int16[Ct + 6] = w, this.int16[Ct + 7] = P, this.uint16[Ct + 8] = M, this.uint16[Ct + 9] = R, this.uint16[Ct + 10] = U, this.uint16[Ct + 11] = G, this.uint16[Ct + 12] = W, this.uint16[Ct + 13] = ne, this.uint16[Ct + 14] = se, this.uint16[Ct + 15] = ge, this.uint16[Ct + 16] = We, this.uint16[Ct + 17] = Te, this.uint16[Ct + 18] = De, this.uint16[Ct + 19] = nt, this.uint16[Ct + 20] = gt, this.uint16[Ct + 21] = Vt, this.uint16[Ct + 22] = pr, this.uint32[un + 12] = ir, this.float32[un + 13] = ur, this.float32[un + 14] = Kr, this.uint16[Ct + 30] = lr, this.uint16[Ct + 31] = hr, t
          }
        }
        Eu.prototype.bytesPerElement = 64, Cr("StructArrayLayout8i15ui1ul2f2ui64", Eu);
        class h extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.float32[1 * t + 0] = r, t
          }
        }
        h.prototype.bytesPerElement = 4, Cr("StructArrayLayout1f4", h);
        class e extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, o)
          }
          emplace(t, r, o, c) {
            const f = 3 * t;
            return this.uint16[6 * t + 0] = r, this.float32[f + 1] = o, this.float32[f + 2] = c, t
          }
        }
        e.prototype.bytesPerElement = 12, Cr("StructArrayLayout1ui2f12", e);
        class i extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, o)
          }
          emplace(t, r, o, c) {
            const f = 4 * t;
            return this.uint32[2 * t + 0] = r, this.uint16[f + 2] = o, this.uint16[f + 3] = c, t
          }
        }
        i.prototype.bytesPerElement = 8, Cr("StructArrayLayout1ul2ui8", i);
        class l extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, t, r)
          }
          emplace(t, r, o) {
            const c = 2 * t;
            return this.uint16[c + 0] = r, this.uint16[c + 1] = o, t
          }
        }
        l.prototype.bytesPerElement = 4, Cr("StructArrayLayout2ui4", l);
        class u extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint16[1 * t + 0] = r, t
          }
        }
        u.prototype.bytesPerElement = 2, Cr("StructArrayLayout1ui2", u);
        class p extends gi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, o, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, r, o, c)
          }
          emplace(t, r, o, c, f) {
            const g = 4 * t;
            return this.float32[g + 0] = r, this.float32[g + 1] = o, this.float32[g + 2] = c, this.float32[g + 3] = f, t
          }
        }
        p.prototype.bytesPerElement = 16, Cr("StructArrayLayout4f16", p);
        class v extends ro {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get anchorPoint() {
            return new F(this.anchorPointX, this.anchorPointY)
          }
        }
        v.prototype.size = 20;
        class T extends Au {
          get(t) {
            return new v(this, t)
          }
        }
        Cr("CollisionBoxArray", T);
        class S extends ro {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3]
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2]
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4]
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7]
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8]
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36]
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37]
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38]
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22]
          }
        }
        S.prototype.size = 48;
        class k extends sc {
          get(t) {
            return new S(this, t)
          }
        }
        Cr("PlacedSymbolArray", k);
        class L extends ro {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6]
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7]
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13]
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14]
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15]
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16]
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17]
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18]
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19]
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20]
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21]
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22]
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13]
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14]
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30]
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31]
          }
        }
        L.prototype.size = 64;
        class V extends Eu {
          get(t) {
            return new L(this, t)
          }
        }
        Cr("SymbolInstanceArray", V);
        class B extends h {
          getoffsetX(t) {
            return this.float32[1 * t + 0]
          }
        }
        Cr("GlyphOffsetArray", B);
        class H extends rc {
          getx(t) {
            return this.int16[3 * t + 0]
          }
          gety(t) {
            return this.int16[3 * t + 1]
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2]
          }
        }
        Cr("SymbolLineVertexArray", H);
        class re extends ro {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0]
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1]
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2]
          }
        }
        re.prototype.size = 12;
        class le extends e {
          get(t) {
            return new re(this, t)
          }
        }
        Cr("TextAnchorOffsetArray", le);
        class ue extends ro {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3]
          }
        }
        ue.prototype.size = 8;
        class de extends i {
          get(t) {
            return new ue(this, t)
          }
        }
        Cr("FeatureIndexArray", de);
        class ve extends Ls {}
        class Ae extends Ls {}
        class _e extends Ls {}
        class ke extends vo {}
        class Fe extends nc {}
        class xe extends rs {}
        class Ve extends ic {}
        class lt extends hl {}
        class rt extends Mu {}
        class at extends zs {}
        class ct extends ns {}
        class er extends ac {}
        class rr extends ku {}
        class kt extends oc {}
        class Br extends l {}
        const Pn = Si([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: ei
          } = Pn;
        class An {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t
          }
          prepareSegment(t, r, o, c) {
            const f = this.segments[this.segments.length - 1];
            return t > An.MAX_VERTEX_ARRAY_LENGTH && Wt(`Max vertices per segment is ${An.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${An.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !f || f.vertexLength + t > An.MAX_VERTEX_ARRAY_LENGTH || f.sortKey !== c ? this.createNewSegment(r, o, c) : f
          }
          createNewSegment(t, r, o) {
            const c = {
              vertexOffset: t.length,
              primitiveOffset: r.length,
              vertexLength: 0,
              primitiveLength: 0,
              vaos: {}
            };
            return o !== void 0 && (c.sortKey = o), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(c), c
          }
          getOrCreateLatestSegment(t, r, o) {
            return this.prepareSegment(0, t, r, o)
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0
          }
          get() {
            return this.segments
          }
          destroy() {
            for (const t of this.segments)
              for (const r in t.vaos) t.vaos[r].destroy()
          }
          static simpleSegment(t, r, o, c) {
            return new An([{
              vertexOffset: t,
              primitiveOffset: r,
              vertexLength: o,
              primitiveLength: c,
              vaos: {},
              sortKey: 0
            }])
          }
        }

        function oi(n, t) {
          return 256 * (n = tr(Math.floor(n), 0, 255)) + tr(Math.floor(t), 0, 255)
        }
        An.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Cr("SegmentVector", An);
        const _i = Si([{
            name: "a_pattern_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pattern_to",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_from",
            components: 1,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_to",
            components: 1,
            type: "Uint16"
          }]),
          li = Si([{
            name: "a_dasharray_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_dasharray_to",
            components: 4,
            type: "Uint16"
          }]);
        var Ei, di, Zi, pi = {
            exports: {}
          },
          Mi = {
            exports: {}
          },
          da = {
            exports: {}
          },
          as = (function() {
            if (Zi) return pi.exports;
            Zi = 1;
            var n = (Ei || (Ei = 1, Mi.exports = function(r, o) {
                var c, f, g, y, w, P, M, R;
                for (f = r.length - (c = 3 & r.length), g = o, w = 3432918353, P = 461845907, R = 0; R < f;) M = 255 & r.charCodeAt(R) | (255 & r.charCodeAt(++R)) << 8 | (255 & r.charCodeAt(++R)) << 16 | (255 & r.charCodeAt(++R)) << 24, ++R, g = 27492 + (65535 & (y = 5 * (65535 & (g = (g ^= M = (65535 & (M = (M = (65535 & M) * w + (((M >>> 16) * w & 65535) << 16) & 4294967295) << 15 | M >>> 17)) * P + (((M >>> 16) * P & 65535) << 16) & 4294967295) << 13 | g >>> 19)) + ((5 * (g >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (y >>> 16) & 65535) << 16);
                switch (M = 0, c) {
                  case 3:
                    M ^= (255 & r.charCodeAt(R + 2)) << 16;
                  case 2:
                    M ^= (255 & r.charCodeAt(R + 1)) << 8;
                  case 1:
                    g ^= M = (65535 & (M = (M = (65535 & (M ^= 255 & r.charCodeAt(R))) * w + (((M >>> 16) * w & 65535) << 16) & 4294967295) << 15 | M >>> 17)) * P + (((M >>> 16) * P & 65535) << 16) & 4294967295
                }
                return g ^= r.length, g = 2246822507 * (65535 & (g ^= g >>> 16)) + ((2246822507 * (g >>> 16) & 65535) << 16) & 4294967295, g = 3266489909 * (65535 & (g ^= g >>> 13)) + ((3266489909 * (g >>> 16) & 65535) << 16) & 4294967295, (g ^= g >>> 16) >>> 0
              }), Mi.exports),
              t = (di || (di = 1, da.exports = function(r, o) {
                for (var c, f = r.length, g = o ^ f, y = 0; f >= 4;) c = 1540483477 * (65535 & (c = 255 & r.charCodeAt(y) | (255 & r.charCodeAt(++y)) << 8 | (255 & r.charCodeAt(++y)) << 16 | (255 & r.charCodeAt(++y)) << 24)) + ((1540483477 * (c >>> 16) & 65535) << 16), g = 1540483477 * (65535 & g) + ((1540483477 * (g >>> 16) & 65535) << 16) ^ (c = 1540483477 * (65535 & (c ^= c >>> 24)) + ((1540483477 * (c >>> 16) & 65535) << 16)), f -= 4, ++y;
                switch (f) {
                  case 3:
                    g ^= (255 & r.charCodeAt(y + 2)) << 16;
                  case 2:
                    g ^= (255 & r.charCodeAt(y + 1)) << 8;
                  case 1:
                    g = 1540483477 * (65535 & (g ^= 255 & r.charCodeAt(y))) + ((1540483477 * (g >>> 16) & 65535) << 16)
                }
                return g = 1540483477 * (65535 & (g ^= g >>> 13)) + ((1540483477 * (g >>> 16) & 65535) << 16), (g ^= g >>> 15) >>> 0
              }), da.exports);
            return pi.exports = n, pi.exports.murmur3 = n, pi.exports.murmur2 = t, pi.exports
          })(),
          yo = q(as);
        class no {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1
          }
          add(t, r, o, c) {
            this.ids.push(os(t)), this.positions.push(r, o, c)
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const r = os(t);
            let o = 0,
              c = this.ids.length - 1;
            for (; o < c;) {
              const g = o + c >> 1;
              this.ids[g] >= r ? c = g : o = g + 1
            }
            const f = [];
            for (; this.ids[o] === r;) f.push({
              index: this.positions[3 * o],
              start: this.positions[3 * o + 1],
              end: this.positions[3 * o + 2]
            }), o++;
            return f
          }
          static serialize(t, r) {
            const o = new Float64Array(t.ids),
              c = new Uint32Array(t.positions);
            return Ds(o, c, 0, o.length - 1), r && r.push(o.buffer, c.buffer), {
              ids: o,
              positions: c
            }
          }
          static deserialize(t) {
            const r = new no;
            return r.ids = t.ids, r.positions = t.positions, r.indexed = !0, r
          }
        }

        function os(n) {
          const t = +n;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : yo(String(n))
        }

        function Ds(n, t, r, o) {
          for (; r < o;) {
            const c = n[r + o >> 1];
            let f = r - 1,
              g = o + 1;
            for (;;) {
              do f++; while (n[f] < c);
              do g--; while (n[g] > c);
              if (f >= g) break;
              ss(n, f, g), ss(t, 3 * f, 3 * g), ss(t, 3 * f + 1, 3 * g + 1), ss(t, 3 * f + 2, 3 * g + 2)
            }
            g - r < o - g ? (Ds(n, t, r, g), r = g + 1) : (Ds(n, t, g + 1, o), o = g)
          }
        }

        function ss(n, t, r) {
          const o = n[t];
          n[t] = n[r], n[r] = o
        }
        Cr("FeaturePositionMap", no);
        class ya {
          constructor(t, r) {
            this.gl = t.gl, this.location = r
          }
        }
        class pa extends ya {
          constructor(t, r) {
            super(t, r), this.current = 0
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t))
          }
        }
        class xo extends ya {
          constructor(t, r) {
            super(t, r), this.current = [0, 0, 0, 0]
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
          }
        }
        class Do extends ya {
          constructor(t, r) {
            super(t, r), this.current = gr.transparent
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
          }
        }
        const dl = new Float32Array(16);

        function Ai(n) {
          return [oi(255 * n.r, 255 * n.g), oi(255 * n.b, 255 * n.a)]
        }
        class Pi {
          constructor(t, r, o) {
            this.value = t, this.uniformNames = r.map((c => `u_${c}`)), this.type = o
          }
          setUniform(t, r, o) {
            t.set(o.constantOr(this.value))
          }
          getBinding(t, r, o) {
            return this.type === "color" ? new Do(t, r) : new pa(t, r)
          }
        }
        class Gi {
          constructor(t, r) {
            this.uniformNames = r.map((o => `u_${o}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1
          }
          setConstantPatternPositions(t, r) {
            this.pixelRatioFrom = r.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = r.tlbr, this.patternTo = t.tlbr
          }
          setConstantDashPositions(t, r) {
            this.dashTo = [0, t.y, t.height, t.width], this.dashFrom = [0, r.y, r.height, r.width]
          }
          setUniform(t, r, o, c) {
            let f = null;
            c === "u_pattern_to" ? f = this.patternTo : c === "u_pattern_from" ? f = this.patternFrom : c === "u_dasharray_to" ? f = this.dashTo : c === "u_dasharray_from" ? f = this.dashFrom : c === "u_pixel_ratio_to" ? f = this.pixelRatioTo : c === "u_pixel_ratio_from" && (f = this.pixelRatioFrom), f !== null && t.set(f)
          }
          getBinding(t, r, o) {
            return o.substr(0, 9) === "u_pattern" || o.substr(0, 12) === "u_dasharray_" ? new xo(t, r) : new pa(t, r)
          }
        }
        class ui {
          constructor(t, r, o, c) {
            this.expression = t, this.type = o, this.maxValue = 0, this.paintVertexAttributes = r.map((f => ({
              name: `a_${f}`,
              type: "Float32",
              components: o === "color" ? 2 : 1,
              offset: 0
            }))), this.paintVertexArray = new c
          }
          populatePaintArray(t, r, o) {
            const c = this.paintVertexArray.length,
              f = this.expression.evaluate(new ai(0, o), r, {}, o.canonical, [], o.formattedSection);
            this.paintVertexArray.resize(t), this._setPaintValue(c, t, f)
          }
          updatePaintArray(t, r, o, c, f) {
            const g = this.expression.evaluate(new ai(0, f), o, c);
            this._setPaintValue(t, r, g)
          }
          _setPaintValue(t, r, o) {
            if (this.type === "color") {
              const c = Ai(o);
              for (let f = t; f < r; f++) this.paintVertexArray.emplace(f, c[0], c[1])
            } else {
              for (let c = t; c < r; c++) this.paintVertexArray.emplace(c, o);
              this.maxValue = Math.max(this.maxValue, Math.abs(o))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
        }
        class Ha {
          constructor(t, r, o, c, f, g) {
            this.expression = t, this.uniformNames = r.map((y => `u_${y}_t`)), this.type = o, this.useIntegerZoom = c, this.zoom = f, this.maxValue = 0, this.paintVertexAttributes = r.map((y => ({
              name: `a_${y}`,
              type: "Float32",
              components: o === "color" ? 4 : 2,
              offset: 0
            }))), this.paintVertexArray = new g
          }
          populatePaintArray(t, r, o) {
            const c = this.expression.evaluate(new ai(this.zoom, o), r, {}, o.canonical, [], o.formattedSection),
              f = this.expression.evaluate(new ai(this.zoom + 1, o), r, {}, o.canonical, [], o.formattedSection),
              g = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(g, t, c, f)
          }
          updatePaintArray(t, r, o, c, f) {
            const g = this.expression.evaluate(new ai(this.zoom, f), o, c),
              y = this.expression.evaluate(new ai(this.zoom + 1, f), o, c);
            this._setPaintValue(t, r, g, y)
          }
          _setPaintValue(t, r, o, c) {
            if (this.type === "color") {
              const f = Ai(o),
                g = Ai(c);
              for (let y = t; y < r; y++) this.paintVertexArray.emplace(y, f[0], f[1], g[0], g[1])
            } else {
              for (let f = t; f < r; f++) this.paintVertexArray.emplace(f, o, c);
              this.maxValue = Math.max(this.maxValue, Math.abs(o), Math.abs(c))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
          setUniform(t, r) {
            const o = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,
              c = tr(this.expression.interpolationFactor(o, this.zoom, this.zoom + 1), 0, 1);
            t.set(c)
          }
          getBinding(t, r, o) {
            return new pa(t, r)
          }
        }
        class Ro {
          constructor(t, r, o, c, f, g) {
            this.expression = t, this.type = r, this.useIntegerZoom = o, this.zoom = c, this.layerId = g, this.zoomInPaintVertexArray = new f, this.zoomOutPaintVertexArray = new f
          }
          populatePaintArray(t, r, o) {
            const c = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(c, t, this.getPositionIds(r), o)
          }
          updatePaintArray(t, r, o, c, f) {
            this._setPaintValues(t, r, this.getPositionIds(o), f)
          }
          _setPaintValues(t, r, o, c) {
            const f = this.getPositions(c);
            if (!f || !o) return;
            const g = f[o.min],
              y = f[o.mid],
              w = f[o.max];
            if (g && y && w)
              for (let P = t; P < r; P++) this.emplace(this.zoomInPaintVertexArray, P, y, g), this.emplace(this.zoomOutPaintVertexArray, P, y, w)
          }
          upload(t) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const r = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, r, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, r, this.expression.isStateDependent)
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
          }
        }
        class Kd extends Ro {
          getPositions(t) {
            return t.imagePositions
          }
          getPositionIds(t) {
            return t.patterns && t.patterns[this.layerId]
          }
          getVertexAttributes() {
            return _i.members
          }
          emplace(t, r, o, c) {
            t.emplace(r, o.tlbr[0], o.tlbr[1], o.tlbr[2], o.tlbr[3], c.tlbr[0], c.tlbr[1], c.tlbr[2], c.tlbr[3], o.pixelRatio, c.pixelRatio)
          }
        }
        class Jd extends Ro {
          getPositions(t) {
            return t.dashPositions
          }
          getPositionIds(t) {
            return t.dashes && t.dashes[this.layerId]
          }
          getVertexAttributes() {
            return li.members
          }
          emplace(t, r, o, c) {
            t.emplace(r, 0, o.y, o.height, o.width, 0, c.y, c.height, c.width)
          }
        }
        class Qd {
          constructor(t, r, o) {
            this.binders = {}, this._buffers = [];
            const c = [];
            for (const f in t.paint._values) {
              if (!o(f)) continue;
              const g = t.paint.get(f);
              if (!(g instanceof Za && Cs(g.property.specification))) continue;
              const y = cs(f, t.type),
                w = g.value,
                P = g.property.specification.type,
                M = g.property.useIntegerZoom,
                R = g.property.specification["property-type"],
                U = R === "cross-faded" || R === "cross-faded-data-driven";
              if (w.kind === "constant") this.binders[f] = U ? new Gi(w.value, y) : new Pi(w.value, y, P), c.push(`/u_${f}`);
              else if (w.kind === "source" || U) {
                const G = Lu(f, P, "source");
                this.binders[f] = U ? f === "line-dasharray" ? new Jd(w, P, M, r, G, t.id) : new Kd(w, P, M, r, G, t.id) : new ui(w, y, P, G), c.push(`/a_${f}`)
              } else {
                const G = Lu(f, P, "composite");
                this.binders[f] = new Ha(w, y, P, M, r, G), c.push(`/z_${f}`)
              }
            }
            this.cacheKey = c.sort().join("")
          }
          getMaxValue(t) {
            const r = this.binders[t];
            return r instanceof ui || r instanceof Ha ? r.maxValue : 0
          }
          populatePaintArrays(t, r, o) {
            for (const c in this.binders) {
              const f = this.binders[c];
              (f instanceof ui || f instanceof Ha || f instanceof Ro) && f.populatePaintArray(t, r, o)
            }
          }
          setConstantPatternPositions(t, r) {
            for (const o in this.binders) {
              const c = this.binders[o];
              c instanceof Gi && c.setConstantPatternPositions(t, r)
            }
          }
          setConstantDashPositions(t, r) {
            for (const o in this.binders) {
              const c = this.binders[o];
              c instanceof Gi && c.setConstantDashPositions(t, r)
            }
          }
          updatePaintArrays(t, r, o, c, f) {
            let g = !1;
            for (const y in t) {
              const w = r.getPositions(y);
              for (const P of w) {
                const M = o.feature(P.index);
                for (const R in this.binders) {
                  const U = this.binders[R];
                  if ((U instanceof ui || U instanceof Ha || U instanceof Ro) && U.expression.isStateDependent === !0) {
                    const G = c.paint.get(R);
                    U.expression = G.value, U.updatePaintArray(P.start, P.end, M, t[y], f), g = !0
                  }
                }
              }
            }
            return g
          }
          defines() {
            const t = [];
            for (const r in this.binders) {
              const o = this.binders[r];
              (o instanceof Pi || o instanceof Gi) && t.push(...o.uniformNames.map((c => `#define HAS_UNIFORM_${c}`)))
            }
            return t
          }
          getBinderAttributes() {
            const t = [];
            for (const r in this.binders) {
              const o = this.binders[r];
              if (o instanceof ui || o instanceof Ha)
                for (let c = 0; c < o.paintVertexAttributes.length; c++) t.push(o.paintVertexAttributes[c].name);
              else if (o instanceof Ro) {
                const c = o.getVertexAttributes();
                for (const f of c) t.push(f.name)
              }
            }
            return t
          }
          getBinderUniforms() {
            const t = [];
            for (const r in this.binders) {
              const o = this.binders[r];
              if (o instanceof Pi || o instanceof Gi || o instanceof Ha)
                for (const c of o.uniformNames) t.push(c)
            }
            return t
          }
          getPaintVertexBuffers() {
            return this._buffers
          }
          getUniforms(t, r) {
            const o = [];
            for (const c in this.binders) {
              const f = this.binders[c];
              if (f instanceof Pi || f instanceof Gi || f instanceof Ha) {
                for (const g of f.uniformNames)
                  if (r[g]) {
                    const y = f.getBinding(t, r[g], g);
                    o.push({
                      name: g,
                      property: c,
                      binding: y
                    })
                  }
              }
            }
            return o
          }
          setUniforms(t, r, o, c) {
            for (const {
                name: f,
                property: g,
                binding: y
              }
              of r) this.binders[g].setUniform(y, c, o.get(g), f)
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const r in this.binders) {
              const o = this.binders[r];
              if (t && o instanceof Ro) {
                const c = t.fromScale === 2 ? o.zoomInPaintVertexBuffer : o.zoomOutPaintVertexBuffer;
                c && this._buffers.push(c)
              } else(o instanceof ui || o instanceof Ha) && o.paintVertexBuffer && this._buffers.push(o.paintVertexBuffer)
            }
          }
          upload(t) {
            for (const r in this.binders) {
              const o = this.binders[r];
              (o instanceof ui || o instanceof Ha || o instanceof Ro) && o.upload(t)
            }
            this.updatePaintBuffers()
          }
          destroy() {
            for (const t in this.binders) {
              const r = this.binders[t];
              (r instanceof ui || r instanceof Ha || r instanceof Ro) && r.destroy()
            }
          }
        }
        class ls {
          constructor(t, r, o = () => !0) {
            this.programConfigurations = {};
            for (const c of t) this.programConfigurations[c.id] = new Qd(c, r, o);
            this.needsUpload = !1, this._featureMap = new no, this._bufferOffset = 0
          }
          populatePaintArrays(t, r, o, c) {
            for (const f in this.programConfigurations) this.programConfigurations[f].populatePaintArrays(t, r, c);
            r.id !== void 0 && this._featureMap.add(r.id, o, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0
          }
          updatePaintArrays(t, r, o, c) {
            for (const f of o) this.needsUpload = this.programConfigurations[f.id].updatePaintArrays(t, this._featureMap, r, f, c) || this.needsUpload
          }
          get(t) {
            return this.programConfigurations[t]
          }
          upload(t) {
            if (this.needsUpload) {
              for (const r in this.programConfigurations) this.programConfigurations[r].upload(t);
              this.needsUpload = !1
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy()
          }
        }

        function cs(n, t) {
          return {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-dasharray": ["dasharray_to", "dasharray_from"],
            "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
          } [n] || [n.replace(`${t}-`, "").replace(/-/g, "_")]
        }

        function Lu(n, t, r) {
          const o = {
              color: {
                source: rs,
                composite: p
              },
              number: {
                source: h,
                composite: rs
              }
            },
            c = (function(f) {
              return {
                "line-pattern": {
                  source: Ve,
                  composite: Ve
                },
                "fill-pattern": {
                  source: Ve,
                  composite: Ve
                },
                "fill-extrusion-pattern": {
                  source: Ve,
                  composite: Ve
                },
                "line-dasharray": {
                  source: lt,
                  composite: lt
                }
              } [f]
            })(n);
          return c && c[r] || o[t][r]
        }
        Cr("ConstantBinder", Pi), Cr("CrossFadedConstantBinder", Gi), Cr("SourceExpressionBinder", ui), Cr("CrossFadedPatternBinder", Kd), Cr("CrossFadedDasharrayBinder", Jd), Cr("CompositeExpressionBinder", Ha), Cr("ProgramConfiguration", Qd, {
          omit: ["_buffers"]
        }), Cr("ProgramConfigurationSet", ls);
        const lc = Math.pow(2, 14) - 1,
          zu = -lc - 1;

        function bo(n) {
          const t = Je / n.extent,
            r = n.loadGeometry();
          for (let o = 0; o < r.length; o++) {
            const c = r[o];
            for (let f = 0; f < c.length; f++) {
              const g = c[f],
                y = Math.round(g.x * t),
                w = Math.round(g.y * t);
              g.x = tr(y, zu, lc), g.y = tr(w, zu, lc), (y < g.x || y > g.x + 1 || w < g.y || w > g.y + 1) && Wt("Geometry exceeds allowed extent, reduce your vector tile buffer size")
            }
          }
          return r
        }

        function Fo(n, t) {
          return {
            type: n.type,
            id: n.id,
            properties: n.properties,
            geometry: t ? bo(n) : []
          }
        }
        const cc = -32768;

        function n1(n, t, r, o, c) {
          n.emplaceBack(cc + 8 * t + o, cc + 8 * r + c)
        }
        class Mf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new Ae, this.indexArray = new kt, this.segments = new An, this.programConfigurations = new ls(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, o) {
            const c = this.layers[0],
              f = [];
            let g = null,
              y = !1,
              w = c.type === "heatmap";
            if (c.type === "circle") {
              const M = c;
              g = M.layout.get("circle-sort-key"), y = !g.isConstant(), w = w || M.paint.get("circle-pitch-alignment") === "map"
            }
            const P = w ? r.subdivisionGranularity.circle : 1;
            for (const {
                feature: M,
                id: R,
                index: U,
                sourceLayerIndex: G
              }
              of t) {
              const W = this.layers[0]._featureFilter.needGeometry,
                ne = Fo(M, W);
              if (!this.layers[0]._featureFilter.filter(new ai(this.zoom), ne, o)) continue;
              const se = y ? g.evaluate(ne, {}, o) : void 0,
                ge = {
                  id: R,
                  properties: M.properties,
                  type: M.type,
                  sourceLayerIndex: G,
                  index: U,
                  geometry: W ? ne.geometry : bo(M),
                  patterns: {},
                  sortKey: se
                };
              f.push(ge)
            }
            y && f.sort(((M, R) => M.sortKey - R.sortKey));
            for (const M of f) {
              const {
                geometry: R,
                index: U,
                sourceLayerIndex: G
              } = M, W = t[U].feature;
              this.addFeature(M, R, U, o, P), r.featureIndex.insert(W, R, U, G, this.index)
            }
          }
          update(t, r, o) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: o
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ei), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          addFeature(t, r, o, c, f = 1) {
            let g;
            switch (f) {
              case 1:
                g = [0, 7];
                break;
              case 3:
                g = [0, 2, 5, 7];
                break;
              case 5:
                g = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                g = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${f}; valid values are 1, 3, 5, 7.`)
            }
            const y = g.length;
            for (const w of r)
              for (const P of w) {
                const M = P.x,
                  R = P.y;
                if (M < 0 || M >= Je || R < 0 || R >= Je) continue;
                const U = this.segments.prepareSegment(y * y, this.layoutVertexArray, this.indexArray, t.sortKey),
                  G = U.vertexLength;
                for (let W = 0; W < y; W++)
                  for (let ne = 0; ne < y; ne++) n1(this.layoutVertexArray, M, R, g[ne], g[W]);
                for (let W = 0; W < y - 1; W++)
                  for (let ne = 0; ne < y - 1; ne++) {
                    const se = G + W * y + ne,
                      ge = G + (W + 1) * y + ne;
                    this.indexArray.emplaceBack(se, ge + 1, se + 1), this.indexArray.emplaceBack(se, ge, ge + 1)
                  }
                U.vertexLength += y * y, U.primitiveLength += (y - 1) * (y - 1) * 2
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {
              imagePositions: {},
              canonical: c
            })
          }
        }

        function t_(n, t) {
          for (let r = 0; r < n.length; r++)
            if (uc(t, n[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (uc(n, t[r])) return !0;
          return !!Af(n, t)
        }

        function ep(n, t, r) {
          return !!uc(n, t) || !!kf(t, n, r)
        }

        function r_(n, t) {
          if (n.length === 1) return i_(t, n[0]);
          for (let r = 0; r < t.length; r++) {
            const o = t[r];
            for (let c = 0; c < o.length; c++)
              if (uc(n, o[c])) return !0
          }
          for (let r = 0; r < n.length; r++)
            if (i_(t, n[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (Af(n, t[r])) return !0;
          return !1
        }

        function i1(n, t, r) {
          if (n.length > 1) {
            if (Af(n, t)) return !0;
            for (let o = 0; o < t.length; o++)
              if (kf(t[o], n, r)) return !0
          }
          for (let o = 0; o < n.length; o++)
            if (kf(n[o], t, r)) return !0;
          return !1
        }

        function Af(n, t) {
          if (n.length === 0 || t.length === 0) return !1;
          for (let r = 0; r < n.length - 1; r++) {
            const o = n[r],
              c = n[r + 1];
            for (let f = 0; f < t.length - 1; f++)
              if (a1(o, c, t[f], t[f + 1])) return !0
          }
          return !1
        }

        function a1(n, t, r, o) {
          return Zt(n, r, o) !== Zt(t, r, o) && Zt(n, t, r) !== Zt(n, t, o)
        }

        function kf(n, t, r) {
          const o = r * r;
          if (t.length === 1) return n.distSqr(t[0]) < o;
          for (let c = 1; c < t.length; c++)
            if (n_(n, t[c - 1], t[c]) < o) return !0;
          return !1
        }

        function n_(n, t, r) {
          const o = t.distSqr(r);
          if (o === 0) return n.distSqr(t);
          const c = ((n.x - t.x) * (r.x - t.x) + (n.y - t.y) * (r.y - t.y)) / o;
          return n.distSqr(c < 0 ? t : c > 1 ? r : r.sub(t)._mult(c)._add(t))
        }

        function i_(n, t) {
          let r, o, c, f = !1;
          for (let g = 0; g < n.length; g++) {
            r = n[g];
            for (let y = 0, w = r.length - 1; y < r.length; w = y++) o = r[y], c = r[w], o.y > t.y != c.y > t.y && t.x < (c.x - o.x) * (t.y - o.y) / (c.y - o.y) + o.x && (f = !f)
          }
          return f
        }

        function uc(n, t) {
          let r = !1;
          for (let o = 0, c = n.length - 1; o < n.length; c = o++) {
            const f = n[o],
              g = n[c];
            f.y > t.y != g.y > t.y && t.x < (g.x - f.x) * (t.y - f.y) / (g.y - f.y) + f.x && (r = !r)
          }
          return r
        }

        function o1(n, t, r) {
          const o = r[0],
            c = r[2];
          if (n.x < o.x && t.x < o.x || n.x > c.x && t.x > c.x || n.y < o.y && t.y < o.y || n.y > c.y && t.y > c.y) return !1;
          const f = Zt(n, t, r[0]);
          return f !== Zt(n, t, r[1]) || f !== Zt(n, t, r[2]) || f !== Zt(n, t, r[3])
        }

        function hc(n, t, r) {
          const o = t.paint.get(n).value;
          return o.kind === "constant" ? o.value : r.programConfigurations.get(t.id).getMaxValue(n)
        }

        function tp(n) {
          return Math.sqrt(n[0] * n[0] + n[1] * n[1])
        }

        function rp(n, t, r, o, c) {
          if (!t[0] && !t[1]) return n;
          const f = F.convert(t)._mult(c);
          r === "viewport" && f._rotate(-o);
          const g = [];
          for (let y = 0; y < n.length; y++) g.push(n[y].sub(f));
          return g
        }

        function s1({
          queryGeometry: n,
          size: t
        }, r) {
          return ep(n, r, t)
        }

        function l1({
          queryGeometry: n,
          size: t,
          transform: r,
          unwrappedTileID: o,
          getElevation: c
        }, f) {
          return ep(n, f, t * (r.projectTileCoordinates(f.x, f.y, o, c).signedDistanceFromCamera / r.cameraToCenterDistance))
        }

        function c1({
          queryGeometry: n,
          size: t,
          transform: r,
          unwrappedTileID: o,
          getElevation: c
        }, f) {
          const g = r.projectTileCoordinates(f.x, f.y, o, c).signedDistanceFromCamera,
            y = t * (r.cameraToCenterDistance / g);
          return ep(n, Ef(f, r, o, c), y)
        }

        function u1({
          queryGeometry: n,
          size: t,
          transform: r,
          unwrappedTileID: o,
          getElevation: c
        }, f) {
          return ep(n, Ef(f, r, o, c), t)
        }

        function a_({
          queryGeometry: n,
          size: t,
          transform: r,
          unwrappedTileID: o,
          getElevation: c,
          pitchAlignment: f = "map",
          pitchScale: g = "map"
        }, y) {
          const w = f === "map" ? g === "map" ? s1 : l1 : g === "map" ? c1 : u1,
            P = {
              queryGeometry: n,
              size: t,
              transform: r,
              unwrappedTileID: o,
              getElevation: c
            };
          for (const M of y)
            for (const R of M)
              if (w(P, R)) return !0;
          return !1
        }

        function Ef(n, t, r, o) {
          const c = t.projectTileCoordinates(n.x, n.y, r, o).point;
          return new F((.5 * c.x + .5) * t.width, (.5 * -c.y + .5) * t.height)
        }
        let o_, s_;
        Cr("CircleBucket", Mf, {
          omit: ["layers"]
        });
        var h1 = {
          get paint() {
            return s_ = s_ || new na({
              "circle-radius": new an(Q.paint_circle["circle-radius"]),
              "circle-color": new an(Q.paint_circle["circle-color"]),
              "circle-blur": new an(Q.paint_circle["circle-blur"]),
              "circle-opacity": new an(Q.paint_circle["circle-opacity"]),
              "circle-translate": new Hr(Q.paint_circle["circle-translate"]),
              "circle-translate-anchor": new Hr(Q.paint_circle["circle-translate-anchor"]),
              "circle-pitch-scale": new Hr(Q.paint_circle["circle-pitch-scale"]),
              "circle-pitch-alignment": new Hr(Q.paint_circle["circle-pitch-alignment"]),
              "circle-stroke-width": new an(Q.paint_circle["circle-stroke-width"]),
              "circle-stroke-color": new an(Q.paint_circle["circle-stroke-color"]),
              "circle-stroke-opacity": new an(Q.paint_circle["circle-stroke-opacity"])
            })
          },
          get layout() {
            return o_ = o_ || new na({
              "circle-sort-key": new an(Q.layout_circle["circle-sort-key"])
            })
          }
        };
        class d1 extends Ga {
          constructor(t, r) {
            super(t, h1, r)
          }
          createBucket(t) {
            return new Mf(t)
          }
          queryRadius(t) {
            const r = t;
            return hc("circle-radius", this, r) + hc("circle-stroke-width", this, r) + tp(this.paint.get("circle-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: o,
            geometry: c,
            transform: f,
            pixelsToTileUnits: g,
            unwrappedTileID: y,
            getElevation: w
          }) {
            const P = rp(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -f.bearingInRadians, g),
              M = this.paint.get("circle-radius").evaluate(r, o) + this.paint.get("circle-stroke-width").evaluate(r, o),
              R = this.paint.get("circle-pitch-scale"),
              U = this.paint.get("circle-pitch-alignment");
            let G, W;
            return U === "map" ? (G = P, W = M * g) : (G = (function(ne, se, ge, We) {
              return ne.map((Te => Ef(Te, se, ge, We)))
            })(P, f, y, w), W = M), a_({
              queryGeometry: G,
              size: W,
              transform: f,
              unwrappedTileID: y,
              getElevation: w,
              pitchAlignment: U,
              pitchScale: R
            }, c)
          }
        }
        class l_ extends Mf {}
        let c_;
        Cr("HeatmapBucket", l_, {
          omit: ["layers"]
        });
        var p1 = {
          get paint() {
            return c_ = c_ || new na({
              "heatmap-radius": new an(Q.paint_heatmap["heatmap-radius"]),
              "heatmap-weight": new an(Q.paint_heatmap["heatmap-weight"]),
              "heatmap-intensity": new Hr(Q.paint_heatmap["heatmap-intensity"]),
              "heatmap-color": new ul(Q.paint_heatmap["heatmap-color"]),
              "heatmap-opacity": new Hr(Q.paint_heatmap["heatmap-opacity"])
            })
          }
        };

        function Lf(n, {
          width: t,
          height: r
        }, o, c) {
          if (c) {
            if (c instanceof Uint8ClampedArray) c = new Uint8Array(c.buffer);
            else if (c.length !== t * r * o) throw new RangeError(`mismatched image size. expected: ${c.length} but got: ${t*r*o}`)
          } else c = new Uint8Array(t * r * o);
          return n.width = t, n.height = r, n.data = c, n
        }

        function u_(n, {
          width: t,
          height: r
        }, o) {
          if (t === n.width && r === n.height) return;
          const c = Lf({}, {
            width: t,
            height: r
          }, o);
          zf(n, c, {
            x: 0,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            width: Math.min(n.width, t),
            height: Math.min(n.height, r)
          }, o), n.width = t, n.height = r, n.data = c.data
        }

        function zf(n, t, r, o, c, f) {
          if (c.width === 0 || c.height === 0) return t;
          if (c.width > n.width || c.height > n.height || r.x > n.width - c.width || r.y > n.height - c.height) throw new RangeError("out of range source coordinates for image copy");
          if (c.width > t.width || c.height > t.height || o.x > t.width - c.width || o.y > t.height - c.height) throw new RangeError("out of range destination coordinates for image copy");
          const g = n.data,
            y = t.data;
          if (g === y) throw new Error("srcData equals dstData, so image is already copied");
          for (let w = 0; w < c.height; w++) {
            const P = ((r.y + w) * n.width + r.x) * f,
              M = ((o.y + w) * t.width + o.x) * f;
            for (let R = 0; R < c.width * f; R++) y[M + R] = g[P + R]
          }
          return t
        }
        class Du {
          constructor(t, r) {
            Lf(this, t, 1, r)
          }
          resize(t) {
            u_(this, t, 1)
          }
          clone() {
            return new Du({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, o, c, f) {
            zf(t, r, o, c, f, 1)
          }
        }
        class Pa {
          constructor(t, r) {
            Lf(this, t, 4, r)
          }
          resize(t) {
            u_(this, t, 4)
          }
          replace(t, r) {
            r ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
          }
          clone() {
            return new Pa({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, o, c, f) {
            zf(t, r, o, c, f, 4)
          }
          setPixel(t, r, o) {
            const c = 4 * (t * this.width + r);
            this.data[c + 0] = Math.round(255 * o.r / o.a), this.data[c + 1] = Math.round(255 * o.g / o.a), this.data[c + 2] = Math.round(255 * o.b / o.a), this.data[c + 3] = Math.round(255 * o.a)
          }
        }

        function h_(n) {
          const t = {},
            r = n.resolution || 256,
            o = n.clips ? n.clips.length : 1,
            c = n.image || new Pa({
              width: r,
              height: o
            });
          if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`);
          const f = (g, y, w) => {
            t[n.evaluationKey] = w;
            const P = n.expression.evaluate(t);
            c.setPixel(g / 4 / r, y / 4, P)
          };
          if (n.clips)
            for (let g = 0, y = 0; g < o; ++g, y += 4 * r)
              for (let w = 0, P = 0; w < r; w++, P += 4) {
                const M = w / (r - 1),
                  {
                    start: R,
                    end: U
                  } = n.clips[g];
                f(y, P, R * (1 - M) + U * M)
              } else
                for (let g = 0, y = 0; g < r; g++, y += 4) f(0, y, g / (r - 1));
          return c
        }
        Cr("AlphaImage", Du), Cr("RGBAImage", Pa);
        const Df = "big-fb";
        class f1 extends Ga {
          createBucket(t) {
            return new l_(t)
          }
          constructor(t, r) {
            super(t, p1, r), this.heatmapFbos = new Map, this._updateColorRamp()
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp()
          }
          _updateColorRamp() {
            this.colorRamp = h_({
              expression: this._transitionablePaint._values["heatmap-color"].value.expression,
              evaluationKey: "heatmapDensity",
              image: this.colorRamp
            }), this.colorRampTexture = null
          }
          resize() {
            this.heatmapFbos.has(Df) && this.heatmapFbos.delete(Df)
          }
          queryRadius(t) {
            return hc("heatmap-radius", this, t)
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: o,
            geometry: c,
            transform: f,
            pixelsToTileUnits: g,
            unwrappedTileID: y,
            getElevation: w
          }) {
            return a_({
              queryGeometry: t,
              size: this.paint.get("heatmap-radius").evaluate(r, o) * g,
              transform: f,
              unwrappedTileID: y,
              getElevation: w
            }, c)
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
          }
        }
        let d_;
        var m1 = {
          get paint() {
            return d_ = d_ || new na({
              "hillshade-illumination-direction": new Hr(Q.paint_hillshade["hillshade-illumination-direction"]),
              "hillshade-illumination-altitude": new Hr(Q.paint_hillshade["hillshade-illumination-altitude"]),
              "hillshade-illumination-anchor": new Hr(Q.paint_hillshade["hillshade-illumination-anchor"]),
              "hillshade-exaggeration": new Hr(Q.paint_hillshade["hillshade-exaggeration"]),
              "hillshade-shadow-color": new Hr(Q.paint_hillshade["hillshade-shadow-color"]),
              "hillshade-highlight-color": new Hr(Q.paint_hillshade["hillshade-highlight-color"]),
              "hillshade-accent-color": new Hr(Q.paint_hillshade["hillshade-accent-color"]),
              "hillshade-method": new Hr(Q.paint_hillshade["hillshade-method"])
            })
          }
        };
        class g1 extends Ga {
          constructor(t, r) {
            super(t, m1, r), this.recalculate({
              zoom: 0,
              zoomHistory: {}
            }, void 0)
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values,
              r = this.paint.get("hillshade-illumination-altitude").values,
              o = this.paint.get("hillshade-highlight-color").values,
              c = this.paint.get("hillshade-shadow-color").values;
            const f = Math.max(t.length, r.length, o.length, c.length);
            t = t.concat(Array(f - t.length).fill(t.at(-1))), r = r.concat(Array(f - r.length).fill(r.at(-1))), o = o.concat(Array(f - o.length).fill(o.at(-1))), c = c.concat(Array(f - c.length).fill(c.at(-1)));
            const g = r.map(Ar);
            return {
              directionRadians: t.map(Ar),
              altitudeRadians: g,
              shadowColor: c,
              highlightColor: o
            }
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
          }
        }
        let p_;
        var _1 = {
          get paint() {
            return p_ = p_ || new na({
              "color-relief-opacity": new Hr(Q["paint_color-relief"]["color-relief-opacity"]),
              "color-relief-color": new ul(Q["paint_color-relief"]["color-relief-color"])
            })
          }
        };
        class Rf {
          constructor(t, r, o, c) {
            this.context = t, this.format = o, this.texture = t.gl.createTexture(), this.update(r, c)
          }
          update(t, r, o) {
            const {
              width: c,
              height: f
            } = t, g = !(this.size && this.size[0] === c && this.size[1] === f || o), {
              context: y
            } = this, {
              gl: w
            } = y;
            if (this.useMipmap = !!(r && r.useMipmap), w.bindTexture(w.TEXTURE_2D, this.texture), y.pixelStoreUnpackFlipY.set(!1), y.pixelStoreUnpack.set(1), y.pixelStoreUnpackPremultiplyAlpha.set(this.format === w.RGBA && (!r || r.premultiply !== !1)), g) this.size = [c, f], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Gt(t) ? w.texImage2D(w.TEXTURE_2D, 0, this.format, this.format, w.UNSIGNED_BYTE, t) : w.texImage2D(w.TEXTURE_2D, 0, this.format, c, f, 0, this.format, w.UNSIGNED_BYTE, t.data);
            else {
              const {
                x: P,
                y: M
              } = o || {
                x: 0,
                y: 0
              };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Gt(t) ? w.texSubImage2D(w.TEXTURE_2D, 0, P, M, w.RGBA, w.UNSIGNED_BYTE, t) : w.texSubImage2D(w.TEXTURE_2D, 0, P, M, c, f, w.RGBA, w.UNSIGNED_BYTE, t.data)
            }
            this.useMipmap && this.isSizePowerOfTwo() && w.generateMipmap(w.TEXTURE_2D), y.pixelStoreUnpackFlipY.setDefault(), y.pixelStoreUnpack.setDefault(), y.pixelStoreUnpackPremultiplyAlpha.setDefault()
          }
          bind(t, r, o) {
            const {
              context: c
            } = this, {
              gl: f
            } = c;
            f.bindTexture(f.TEXTURE_2D, this.texture), o !== f.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (o = f.LINEAR), t !== this.filter && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, t), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, o || t), this.filter = t), r !== this.wrap && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, r), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, r), this.wrap = r)
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
          }
          destroy() {
            const {
              gl: t
            } = this.context;
            t.deleteTexture(this.texture), this.texture = null
          }
        }
        class f_ {
          constructor(t, r, o, c = 1, f = 1, g = 1, y = 0) {
            if (this.uid = t, r.height !== r.width) throw new RangeError("DEM tiles must be square");
            if (o && !["mapbox", "terrarium", "custom"].includes(o)) return void Wt(`"${o}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = r.height;
            const w = this.dim = r.height - 2;
            switch (this.data = new Uint32Array(r.data.buffer), o) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = c, this.greenFactor = f, this.blueFactor = g, this.baseShift = y;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4
            }
            for (let P = 0; P < w; P++) this.data[this._idx(-1, P)] = this.data[this._idx(0, P)], this.data[this._idx(w, P)] = this.data[this._idx(w - 1, P)], this.data[this._idx(P, -1)] = this.data[this._idx(P, 0)], this.data[this._idx(P, w)] = this.data[this._idx(P, w - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(w, -1)] = this.data[this._idx(w - 1, 0)], this.data[this._idx(-1, w)] = this.data[this._idx(0, w - 1)], this.data[this._idx(w, w)] = this.data[this._idx(w - 1, w - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let P = 0; P < w; P++)
              for (let M = 0; M < w; M++) {
                const R = this.get(P, M);
                R > this.max && (this.max = R), R < this.min && (this.min = R)
              }
          }
          get(t, r) {
            const o = new Uint8Array(this.data.buffer),
              c = 4 * this._idx(t, r);
            return this.unpack(o[c], o[c + 1], o[c + 2])
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
          }
          _idx(t, r) {
            if (t < -1 || t >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (r + 1) * this.stride + (t + 1)
          }
          unpack(t, r, o) {
            return t * this.redFactor + r * this.greenFactor + o * this.blueFactor - this.baseShift
          }
          pack(t) {
            return m_(t, this.getUnpackVector())
          }
          getPixels() {
            return new Pa({
              width: this.stride,
              height: this.stride
            }, new Uint8Array(this.data.buffer))
          }
          backfillBorder(t, r, o) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let c = r * this.dim,
              f = r * this.dim + this.dim,
              g = o * this.dim,
              y = o * this.dim + this.dim;
            switch (r) {
              case -1:
                c = f - 1;
                break;
              case 1:
                f = c + 1
            }
            switch (o) {
              case -1:
                g = y - 1;
                break;
              case 1:
                y = g + 1
            }
            const w = -r * this.dim,
              P = -o * this.dim;
            for (let M = g; M < y; M++)
              for (let R = c; R < f; R++) this.data[this._idx(R, M)] = t.data[this._idx(R + w, M + P)]
          }
        }

        function m_(n, t) {
          const r = t[0],
            o = t[1],
            c = t[2],
            f = t[3],
            g = Math.min(r, o, c),
            y = Math.round((n + f) / g);
          return {
            r: Math.floor(y * g / r) % 256,
            g: Math.floor(y * g / o) % 256,
            b: Math.floor(y * g / c) % 256
          }
        }
        Cr("DEMData", f_);
        class v1 extends Ga {
          constructor(t, r) {
            super(t, _1, r)
          }
          _createColorRamp(t) {
            const r = {
                elevationStops: [],
                colorStops: []
              },
              o = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (o instanceof tl && o._styleExpression.expression instanceof Qn) {
              this.colorRampExpression = o;
              const g = o._styleExpression.expression;
              r.elevationStops = g.labels, r.colorStops = [];
              for (const y of r.elevationStops) r.colorStops.push(g.evaluate({
                globals: {
                  elevation: y
                }
              }))
            }
            if (r.elevationStops.length < 1 && (r.elevationStops = [0], r.colorStops = [gr.transparent]), r.elevationStops.length < 2 && (r.elevationStops.push(r.elevationStops[0] + 1), r.colorStops.push(r.colorStops[0])), r.elevationStops.length <= t) return r;
            const c = {
                elevationStops: [],
                colorStops: []
              },
              f = (r.elevationStops.length - 1) / (t - 1);
            for (let g = 0; g < r.elevationStops.length - .5; g += f) c.elevationStops.push(r.elevationStops[Math.round(g)]), c.colorStops.push(r.colorStops[Math.round(g)]);
            return Wt(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t}, provided: ${r.elevationStops.length}`), c
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
          }
          getColorRampTextures(t, r, o) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const c = this._createColorRamp(r),
              f = new Pa({
                width: c.colorStops.length,
                height: 1
              }),
              g = new Pa({
                width: c.colorStops.length,
                height: 1
              });
            for (let y = 0; y < c.elevationStops.length; y++) {
              const w = m_(c.elevationStops[y], o);
              g.setPixel(0, y, new gr(w.r / 255, w.g / 255, w.b / 255, 1)), f.setPixel(0, y, c.colorStops[y])
            }
            return this.colorRampTextures = {
              elevationTexture: new Rf(t, g, t.gl.RGBA),
              colorTexture: new Rf(t, f, t.gl.RGBA)
            }, this.colorRampTextures
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures
          }
        }
        const y1 = Si([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: x1
          } = y1;

        function np(n, t, r) {
          const o = r.patternDependencies;
          let c = !1;
          for (const f of t) {
            const g = f.paint.get(`${n}-pattern`);
            g.isConstant() || (c = !0);
            const y = g.constantOr(null);
            y && (c = !0, o[y.to] = !0, o[y.from] = !0)
          }
          return c
        }

        function Ff(n, t, r, o, c) {
          const {
            zoom: f
          } = o, g = c.patternDependencies;
          for (const y of t) {
            const w = y.paint.get(`${n}-pattern`).value;
            if (w.kind !== "constant") {
              let P = w.evaluate({
                  zoom: f - 1
                }, r, {}, c.availableImages),
                M = w.evaluate({
                  zoom: f
                }, r, {}, c.availableImages),
                R = w.evaluate({
                  zoom: f + 1
                }, r, {}, c.availableImages);
              P = P && P.name ? P.name : P, M = M && M.name ? M.name : M, R = R && R.name ? R.name : R, g[P] = !0, g[M] = !0, g[R] = !0, r.patterns[y.id] = {
                min: P,
                mid: M,
                max: R
              }
            }
          }
          return r
        }

        function g_(n, t, r, o, c) {
          let f;
          if (c === (function(g, y, w, P) {
              let M = 0;
              for (let R = y, U = w - P; R < w; R += P) M += (g[U] - g[R]) * (g[R + 1] + g[U + 1]), U = R;
              return M
            })(n, t, r, o) > 0)
            for (let g = t; g < r; g += o) f = x_(g / o | 0, n[g], n[g + 1], f);
          else
            for (let g = r - o; g >= t; g -= o) f = x_(g / o | 0, n[g], n[g + 1], f);
          return f && dc(f, f.next) && (Ou(f), f = f.next), f
        }

        function pl(n, t) {
          if (!n) return n;
          t || (t = n);
          let r, o = n;
          do
            if (r = !1, o.steiner || !dc(o, o.next) && ki(o.prev, o, o.next) !== 0) o = o.next;
            else {
              if (Ou(o), o = t = o.prev, o === o.next) break;
              r = !0
            } while (r || o !== t);
          return t
        }

        function Ru(n, t, r, o, c, f, g) {
          if (!n) return;
          !g && f && (function(w, P, M, R) {
            let U = w;
            do U.z === 0 && (U.z = Bf(U.x, U.y, P, M, R)), U.prevZ = U.prev, U.nextZ = U.next, U = U.next; while (U !== w);
            U.prevZ.nextZ = null, U.prevZ = null, (function(G) {
              let W, ne = 1;
              do {
                let se, ge = G;
                G = null;
                let We = null;
                for (W = 0; ge;) {
                  W++;
                  let Te = ge,
                    De = 0;
                  for (let gt = 0; gt < ne && (De++, Te = Te.nextZ, Te); gt++);
                  let nt = ne;
                  for (; De > 0 || nt > 0 && Te;) De !== 0 && (nt === 0 || !Te || ge.z <= Te.z) ? (se = ge, ge = ge.nextZ, De--) : (se = Te, Te = Te.nextZ, nt--), We ? We.nextZ = se : G = se, se.prevZ = We, We = se;
                  ge = Te
                }
                We.nextZ = null, ne *= 2
              } while (W > 1)
            })(U)
          })(n, o, c, f);
          let y = n;
          for (; n.prev !== n.next;) {
            const w = n.prev,
              P = n.next;
            if (f ? w1(n, o, c, f) : b1(n)) t.push(w.i, n.i, P.i), Ou(n), n = P.next, y = P.next;
            else if ((n = P) === y) {
              g ? g === 1 ? Ru(n = T1(pl(n), t), t, r, o, c, f, 2) : g === 2 && S1(n, t, r, o, c, f) : Ru(pl(n), t, r, o, c, f, 1);
              break
            }
          }
        }

        function b1(n) {
          const t = n.prev,
            r = n,
            o = n.next;
          if (ki(t, r, o) >= 0) return !1;
          const c = t.x,
            f = r.x,
            g = o.x,
            y = t.y,
            w = r.y,
            P = o.y,
            M = Math.min(c, f, g),
            R = Math.min(y, w, P),
            U = Math.max(c, f, g),
            G = Math.max(y, w, P);
          let W = o.next;
          for (; W !== t;) {
            if (W.x >= M && W.x <= U && W.y >= R && W.y <= G && Fu(c, y, f, w, g, P, W.x, W.y) && ki(W.prev, W, W.next) >= 0) return !1;
            W = W.next
          }
          return !0
        }

        function w1(n, t, r, o) {
          const c = n.prev,
            f = n,
            g = n.next;
          if (ki(c, f, g) >= 0) return !1;
          const y = c.x,
            w = f.x,
            P = g.x,
            M = c.y,
            R = f.y,
            U = g.y,
            G = Math.min(y, w, P),
            W = Math.min(M, R, U),
            ne = Math.max(y, w, P),
            se = Math.max(M, R, U),
            ge = Bf(G, W, t, r, o),
            We = Bf(ne, se, t, r, o);
          let Te = n.prevZ,
            De = n.nextZ;
          for (; Te && Te.z >= ge && De && De.z <= We;) {
            if (Te.x >= G && Te.x <= ne && Te.y >= W && Te.y <= se && Te !== c && Te !== g && Fu(y, M, w, R, P, U, Te.x, Te.y) && ki(Te.prev, Te, Te.next) >= 0 || (Te = Te.prevZ, De.x >= G && De.x <= ne && De.y >= W && De.y <= se && De !== c && De !== g && Fu(y, M, w, R, P, U, De.x, De.y) && ki(De.prev, De, De.next) >= 0)) return !1;
            De = De.nextZ
          }
          for (; Te && Te.z >= ge;) {
            if (Te.x >= G && Te.x <= ne && Te.y >= W && Te.y <= se && Te !== c && Te !== g && Fu(y, M, w, R, P, U, Te.x, Te.y) && ki(Te.prev, Te, Te.next) >= 0) return !1;
            Te = Te.prevZ
          }
          for (; De && De.z <= We;) {
            if (De.x >= G && De.x <= ne && De.y >= W && De.y <= se && De !== c && De !== g && Fu(y, M, w, R, P, U, De.x, De.y) && ki(De.prev, De, De.next) >= 0) return !1;
            De = De.nextZ
          }
          return !0
        }

        function T1(n, t) {
          let r = n;
          do {
            const o = r.prev,
              c = r.next.next;
            !dc(o, c) && v_(o, r, r.next, c) && Bu(o, c) && Bu(c, o) && (t.push(o.i, r.i, c.i), Ou(r), Ou(r.next), r = n = c), r = r.next
          } while (r !== n);
          return pl(r)
        }

        function S1(n, t, r, o, c, f) {
          let g = n;
          do {
            let y = g.next.next;
            for (; y !== g.prev;) {
              if (g.i !== y.i && A1(g, y)) {
                let w = y_(g, y);
                return g = pl(g, g.next), w = pl(w, w.next), Ru(g, t, r, o, c, f, 0), void Ru(w, t, r, o, c, f, 0)
              }
              y = y.next
            }
            g = g.next
          } while (g !== n)
        }

        function P1(n, t) {
          let r = n.x - t.x;
          return r === 0 && (r = n.y - t.y, r === 0) && (r = (n.next.y - n.y) / (n.next.x - n.x) - (t.next.y - t.y) / (t.next.x - t.x)), r
        }

        function C1(n, t) {
          const r = (function(c, f) {
            let g = f;
            const y = c.x,
              w = c.y;
            let P, M = -1 / 0;
            if (dc(c, g)) return g;
            do {
              if (dc(c, g.next)) return g.next;
              if (w <= g.y && w >= g.next.y && g.next.y !== g.y) {
                const ne = g.x + (w - g.y) * (g.next.x - g.x) / (g.next.y - g.y);
                if (ne <= y && ne > M && (M = ne, P = g.x < g.next.x ? g : g.next, ne === y)) return P
              }
              g = g.next
            } while (g !== f);
            if (!P) return null;
            const R = P,
              U = P.x,
              G = P.y;
            let W = 1 / 0;
            g = P;
            do {
              if (y >= g.x && g.x >= U && y !== g.x && __(w < G ? y : M, w, U, G, w < G ? M : y, w, g.x, g.y)) {
                const ne = Math.abs(w - g.y) / (y - g.x);
                Bu(g, c) && (ne < W || ne === W && (g.x > P.x || g.x === P.x && I1(P, g))) && (P = g, W = ne)
              }
              g = g.next
            } while (g !== R);
            return P
          })(n, t);
          if (!r) return t;
          const o = y_(r, n);
          return pl(o, o.next), pl(r, r.next)
        }

        function I1(n, t) {
          return ki(n.prev, n, t.prev) < 0 && ki(t.next, n, n.next) < 0
        }

        function Bf(n, t, r, o, c) {
          return (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - r) * c | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - o) * c | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }

        function M1(n) {
          let t = n,
            r = n;
          do(t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next; while (t !== n);
          return r
        }

        function __(n, t, r, o, c, f, g, y) {
          return (c - g) * (t - y) >= (n - g) * (f - y) && (n - g) * (o - y) >= (r - g) * (t - y) && (r - g) * (f - y) >= (c - g) * (o - y)
        }

        function Fu(n, t, r, o, c, f, g, y) {
          return !(n === g && t === y) && __(n, t, r, o, c, f, g, y)
        }

        function A1(n, t) {
          return n.next.i !== t.i && n.prev.i !== t.i && !(function(r, o) {
            let c = r;
            do {
              if (c.i !== r.i && c.next.i !== r.i && c.i !== o.i && c.next.i !== o.i && v_(c, c.next, r, o)) return !0;
              c = c.next
            } while (c !== r);
            return !1
          })(n, t) && (Bu(n, t) && Bu(t, n) && (function(r, o) {
            let c = r,
              f = !1;
            const g = (r.x + o.x) / 2,
              y = (r.y + o.y) / 2;
            do c.y > y != c.next.y > y && c.next.y !== c.y && g < (c.next.x - c.x) * (y - c.y) / (c.next.y - c.y) + c.x && (f = !f), c = c.next; while (c !== r);
            return f
          })(n, t) && (ki(n.prev, n, t.prev) || ki(n, t.prev, t)) || dc(n, t) && ki(n.prev, n, n.next) > 0 && ki(t.prev, t, t.next) > 0)
        }

        function ki(n, t, r) {
          return (t.y - n.y) * (r.x - t.x) - (t.x - n.x) * (r.y - t.y)
        }

        function dc(n, t) {
          return n.x === t.x && n.y === t.y
        }

        function v_(n, t, r, o) {
          const c = ap(ki(n, t, r)),
            f = ap(ki(n, t, o)),
            g = ap(ki(r, o, n)),
            y = ap(ki(r, o, t));
          return c !== f && g !== y || !(c !== 0 || !ip(n, r, t)) || !(f !== 0 || !ip(n, o, t)) || !(g !== 0 || !ip(r, n, o)) || !(y !== 0 || !ip(r, t, o))
        }

        function ip(n, t, r) {
          return t.x <= Math.max(n.x, r.x) && t.x >= Math.min(n.x, r.x) && t.y <= Math.max(n.y, r.y) && t.y >= Math.min(n.y, r.y)
        }

        function ap(n) {
          return n > 0 ? 1 : n < 0 ? -1 : 0
        }

        function Bu(n, t) {
          return ki(n.prev, n, n.next) < 0 ? ki(n, t, n.next) >= 0 && ki(n, n.prev, t) >= 0 : ki(n, t, n.prev) < 0 || ki(n, n.next, t) < 0
        }

        function y_(n, t) {
          const r = Of(n.i, n.x, n.y),
            o = Of(t.i, t.x, t.y),
            c = n.next,
            f = t.prev;
          return n.next = t, t.prev = n, r.next = c, c.prev = r, o.next = r, r.prev = o, f.next = o, o.prev = f, o
        }

        function x_(n, t, r, o) {
          const c = Of(n, t, r);
          return o ? (c.next = o.next, c.prev = o, o.next.prev = c, o.next = c) : (c.prev = c, c.next = c), c
        }

        function Ou(n) {
          n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ)
        }

        function Of(n, t, r) {
          return {
            i: n,
            x: t,
            y: r,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
          }
        }
        class pc {
          constructor(t, r) {
            if (r > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = r
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1)
          }
        }
        class op {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle
          }
        }
        op.noSubdivision = new op({
          fill: new pc(0, 0),
          line: new pc(0, 0),
          tile: new pc(0, 0),
          stencil: new pc(0, 0),
          circle: 1
        }), Cr("SubdivisionGranularityExpression", pc), Cr("SubdivisionGranularitySetting", op);
        const fc = -32768,
          Nu = 32767;
        class k1 {
          constructor(t, r) {
            this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = t, this._granularityCellSize = Je / t, this._canonical = r
          }
          _getKey(t, r) {
            return (t += 32768) << 16 | r + 32768
          }
          _vertexToIndex(t, r) {
            if (t < -32768 || r < -32768 || t > 32767 || r > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const o = 0 | Math.round(t),
              c = 0 | Math.round(r),
              f = this._getKey(o, c);
            if (this._vertexDictionary.has(f)) return this._vertexDictionary.get(f);
            const g = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(f, g), this._vertexBuffer.push(o, c), g
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(c, f) {
              const g = [];
              for (let y = 0; y < f.length; y += 3) {
                const w = f[y],
                  P = f[y + 1],
                  M = f[y + 2],
                  R = c[2 * w],
                  U = c[2 * w + 1];
                (c[2 * P] - R) * (c[2 * M + 1] - U) - (c[2 * P + 1] - U) * (c[2 * M] - R) > 0 ? (g.push(w), g.push(M), g.push(P)) : (g.push(w), g.push(P), g.push(M))
              }
              return g
            })(this._vertexBuffer, t);
            const r = [],
              o = t.length;
            for (let c = 0; c < o; c += 3) {
              const f = [t[c + 0], t[c + 1], t[c + 2]],
                g = [this._vertexBuffer[2 * t[c + 0] + 0], this._vertexBuffer[2 * t[c + 0] + 1], this._vertexBuffer[2 * t[c + 1] + 0], this._vertexBuffer[2 * t[c + 1] + 1], this._vertexBuffer[2 * t[c + 2] + 0], this._vertexBuffer[2 * t[c + 2] + 1]];
              let y = 1 / 0,
                w = 1 / 0,
                P = -1 / 0,
                M = -1 / 0;
              for (let ne = 0; ne < 3; ne++) {
                const se = g[2 * ne],
                  ge = g[2 * ne + 1];
                y = Math.min(y, se), P = Math.max(P, se), w = Math.min(w, ge), M = Math.max(M, ge)
              }
              if (y === P || w === M) continue;
              const R = Math.floor(y / this._granularityCellSize),
                U = Math.ceil(P / this._granularityCellSize),
                G = Math.floor(w / this._granularityCellSize),
                W = Math.ceil(M / this._granularityCellSize);
              if (R !== U || G !== W)
                for (let ne = G; ne < W; ne++) {
                  const se = this._scanlineGenerateVertexRingForCellRow(ne, g, f);
                  E1(this._vertexBuffer, se, r)
                } else r.push(...f)
            }
            return r
          }
          _scanlineGenerateVertexRingForCellRow(t, r, o) {
            const c = t * this._granularityCellSize,
              f = c + this._granularityCellSize,
              g = [];
            for (let y = 0; y < 3; y++) {
              const w = r[2 * y],
                P = r[2 * y + 1],
                M = r[2 * (y + 1) % 6],
                R = r[(2 * (y + 1) + 1) % 6],
                U = r[2 * (y + 2) % 6],
                G = r[(2 * (y + 2) + 1) % 6],
                W = M - w,
                ne = R - P,
                se = W === 0,
                ge = ne === 0,
                We = (c - P) / ne,
                Te = (f - P) / ne,
                De = Math.min(We, Te),
                nt = Math.max(We, Te);
              if (!ge && (De >= 1 || nt <= 0) || ge && (P < c || P > f)) {
                R >= c && R <= f && g.push(o[(y + 1) % 3]);
                continue
              }!ge && De > 0 && g.push(this._vertexToIndex(w + W * De, P + ne * De));
              const gt = w + W * Math.max(De, 0),
                Vt = w + W * Math.min(nt, 1);
              se || this._generateIntraEdgeVertices(g, w, P, M, R, gt, Vt), !ge && nt < 1 && g.push(this._vertexToIndex(w + W * nt, P + ne * nt)), (ge || R >= c && R <= f) && g.push(o[(y + 1) % 3]), !ge && (R <= c || R >= f) && this._generateInterEdgeVertices(g, w, P, M, R, U, G, Vt, c, f)
            }
            return g
          }
          _generateIntraEdgeVertices(t, r, o, c, f, g, y) {
            const w = c - r,
              P = f - o,
              M = P === 0,
              R = M ? Math.min(r, c) : Math.min(g, y),
              U = M ? Math.max(r, c) : Math.max(g, y),
              G = Math.floor(R / this._granularityCellSize) + 1,
              W = Math.ceil(U / this._granularityCellSize) - 1;
            if (M ? r < c : g < y)
              for (let ne = G; ne <= W; ne++) {
                const se = ne * this._granularityCellSize;
                t.push(this._vertexToIndex(se, o + P * (se - r) / w))
              } else
                for (let ne = W; ne >= G; ne--) {
                  const se = ne * this._granularityCellSize;
                  t.push(this._vertexToIndex(se, o + P * (se - r) / w))
                }
          }
          _generateInterEdgeVertices(t, r, o, c, f, g, y, w, P, M) {
            const R = f - o,
              U = g - c,
              G = y - f,
              W = (P - f) / G,
              ne = (M - f) / G,
              se = Math.min(W, ne),
              ge = Math.max(W, ne),
              We = c + U * se;
            let Te = Math.floor(Math.min(We, w) / this._granularityCellSize) + 1,
              De = Math.ceil(Math.max(We, w) / this._granularityCellSize) - 1,
              nt = w < We;
            const gt = G === 0;
            if (gt && (y === P || y === M)) return;
            if (gt || se >= 1 || ge <= 0) {
              const pr = o - y,
                ir = g + (r - g) * Math.min((P - y) / pr, (M - y) / pr);
              Te = Math.floor(Math.min(ir, w) / this._granularityCellSize) + 1, De = Math.ceil(Math.max(ir, w) / this._granularityCellSize) - 1, nt = w < ir
            }
            const Vt = R > 0 ? M : P;
            if (nt)
              for (let pr = Te; pr <= De; pr++) t.push(this._vertexToIndex(pr * this._granularityCellSize, Vt));
            else
              for (let pr = De; pr >= Te; pr--) t.push(this._vertexToIndex(pr * this._granularityCellSize, Vt))
          }
          _generateOutline(t) {
            const r = [];
            for (const o of t) {
              const c = fl(o, this._granularity, !0),
                f = this._pointArrayToIndices(c),
                g = [];
              for (let y = 1; y < f.length; y++) g.push(f[y - 1]), g.push(f[y]);
              r.push(g)
            }
            return r
          }
          _handlePoles(t) {
            let r = !1,
              o = !1;
            this._canonical && (this._canonical.y === 0 && (r = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (o = !0)), (r || o) && this._fillPoles(t, r, o)
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let r = 0; r < t.length; r += 2) {
              const o = t[r + 1];
              o === fc && (t[r + 1] = -32767), o === Nu && (t[r + 1] = 32766)
            }
          }
          _generatePoleQuad(t, r, o, c, f, g) {
            c > f != (g === fc) ? (t.push(r), t.push(o), t.push(this._vertexToIndex(c, g)), t.push(o), t.push(this._vertexToIndex(f, g)), t.push(this._vertexToIndex(c, g))) : (t.push(o), t.push(r), t.push(this._vertexToIndex(c, g)), t.push(this._vertexToIndex(f, g)), t.push(o), t.push(this._vertexToIndex(c, g)))
          }
          _fillPoles(t, r, o) {
            const c = this._vertexBuffer,
              f = Je,
              g = t.length;
            for (let y = 2; y < g; y += 3) {
              const w = t[y - 2],
                P = t[y - 1],
                M = t[y],
                R = c[2 * w],
                U = c[2 * w + 1],
                G = c[2 * P],
                W = c[2 * P + 1],
                ne = c[2 * M],
                se = c[2 * M + 1];
              r && (U === 0 && W === 0 && this._generatePoleQuad(t, w, P, R, G, fc), W === 0 && se === 0 && this._generatePoleQuad(t, P, M, G, ne, fc), se === 0 && U === 0 && this._generatePoleQuad(t, M, w, ne, R, fc)), o && (U === f && W === f && this._generatePoleQuad(t, w, P, R, G, Nu), W === f && se === f && this._generatePoleQuad(t, P, M, G, ne, Nu), se === f && U === f && this._generatePoleQuad(t, M, w, ne, R, Nu))
            }
          }
          _initializeVertices(t) {
            for (let r = 0; r < t.length; r += 2) this._vertexToIndex(t[r], t[r + 1])
          }
          subdividePolygonInternal(t, r) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const {
              flattened: o,
              holeIndices: c
            } = (function(y) {
              const w = [],
                P = [];
              for (const M of y)
                if (M.length !== 0) {
                  M !== y[0] && w.push(P.length / 2);
                  for (let R = 0; R < M.length; R++) P.push(M[R].x), P.push(M[R].y)
                } return {
                flattened: P,
                holeIndices: w
              }
            })(t);
            let f;
            this._initializeVertices(o);
            try {
              const y = (function(P, M, R = 2) {
                  const U = M && M.length,
                    G = U ? M[0] * R : P.length;
                  let W = g_(P, 0, G, R, !0);
                  const ne = [];
                  if (!W || W.next === W.prev) return ne;
                  let se, ge, We;
                  if (U && (W = (function(Te, De, nt, gt) {
                      const Vt = [];
                      for (let pr = 0, ir = De.length; pr < ir; pr++) {
                        const ur = g_(Te, De[pr] * gt, pr < ir - 1 ? De[pr + 1] * gt : Te.length, gt, !1);
                        ur === ur.next && (ur.steiner = !0), Vt.push(M1(ur))
                      }
                      Vt.sort(P1);
                      for (let pr = 0; pr < Vt.length; pr++) nt = C1(Vt[pr], nt);
                      return nt
                    })(P, M, W, R)), P.length > 80 * R) {
                    se = P[0], ge = P[1];
                    let Te = se,
                      De = ge;
                    for (let nt = R; nt < G; nt += R) {
                      const gt = P[nt],
                        Vt = P[nt + 1];
                      gt < se && (se = gt), Vt < ge && (ge = Vt), gt > Te && (Te = gt), Vt > De && (De = Vt)
                    }
                    We = Math.max(Te - se, De - ge), We = We !== 0 ? 32767 / We : 0
                  }
                  return Ru(W, ne, R, se, ge, We, 0), ne
                })(o, c),
                w = this._convertIndices(o, y);
              f = this._subdivideTrianglesScanline(w)
            } catch (y) {
              console.error(y)
            }
            let g = [];
            return r && (g = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(f), {
              verticesFlattened: this._vertexBuffer,
              indicesTriangles: f,
              indicesLineList: g
            }
          }
          _convertIndices(t, r) {
            const o = [];
            for (let c = 0; c < r.length; c++) o.push(this._vertexToIndex(t[2 * r[c]], t[2 * r[c] + 1]));
            return o
          }
          _pointArrayToIndices(t) {
            const r = [];
            for (let o = 0; o < t.length; o++) {
              const c = t[o];
              r.push(this._vertexToIndex(c.x, c.y))
            }
            return r
          }
        }

        function b_(n, t, r, o = !0) {
          return new k1(r, t).subdividePolygonInternal(n, o)
        }

        function fl(n, t, r = !1) {
          if (!n || n.length < 1) return [];
          if (n.length < 2) return [];
          const o = n[0],
            c = n[n.length - 1],
            f = r && (o.x !== c.x || o.y !== c.y);
          if (t < 2) return f ? [...n, n[0]] : [...n];
          const g = Math.floor(Je / t),
            y = [];
          y.push(new F(n[0].x, n[0].y));
          const w = n.length,
            P = f ? w : w - 1;
          for (let M = 0; M < P; M++) {
            const R = n[M],
              U = M < w - 1 ? n[M + 1] : n[0],
              G = R.x,
              W = R.y,
              ne = U.x,
              se = U.y,
              ge = G !== ne,
              We = W !== se;
            if (!ge && !We) continue;
            const Te = ne - G,
              De = se - W,
              nt = Math.abs(Te),
              gt = Math.abs(De);
            let Vt = G,
              pr = W;
            for (;;) {
              const ur = Te > 0 ? (Math.floor(Vt / g) + 1) * g : (Math.ceil(Vt / g) - 1) * g,
                Kr = De > 0 ? (Math.floor(pr / g) + 1) * g : (Math.ceil(pr / g) - 1) * g,
                lr = Math.abs(Vt - ur),
                hr = Math.abs(pr - Kr),
                Ct = Math.abs(Vt - ne),
                un = Math.abs(pr - se),
                yn = ge ? lr / nt : Number.POSITIVE_INFINITY,
                rn = We ? hr / gt : Number.POSITIVE_INFINITY;
              if ((Ct <= lr || !ge) && (un <= hr || !We)) break;
              if (yn < rn && ge || !We) {
                Vt = ur, pr += De * yn;
                const Gr = new F(Vt, Math.round(pr));
                y[y.length - 1].x === Gr.x && y[y.length - 1].y === Gr.y || y.push(Gr)
              } else {
                Vt += Te * rn, pr = Kr;
                const Gr = new F(Math.round(Vt), pr);
                y[y.length - 1].x === Gr.x && y[y.length - 1].y === Gr.y || y.push(Gr)
              }
            }
            const ir = new F(ne, se);
            y[y.length - 1].x === ir.x && y[y.length - 1].y === ir.y || y.push(ir)
          }
          return y
        }

        function E1(n, t, r) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let o = 0,
            c = n[2 * t[0]];
          for (let w = 1; w < t.length; w++) {
            const P = n[2 * t[w]];
            P < c && (c = P, o = w)
          }
          const f = t.length;
          let g = o,
            y = (g + 1) % f;
          for (;;) {
            const w = g - 1 >= 0 ? g - 1 : f - 1,
              P = (y + 1) % f,
              M = n[2 * t[w]],
              R = n[2 * t[P]],
              U = n[2 * t[g]],
              G = n[2 * t[g] + 1],
              W = n[2 * t[y] + 1];
            let ne = !1;
            if (M < R) ne = !0;
            else if (M > R) ne = !1;
            else {
              const se = W - G,
                ge = -(n[2 * t[y]] - U),
                We = G < W ? 1 : -1;
              ((M - U) * se + (n[2 * t[w] + 1] - G) * ge) * We > ((R - U) * se + (n[2 * t[P] + 1] - G) * ge) * We && (ne = !0)
            }
            if (ne) {
              const se = t[w],
                ge = t[g],
                We = t[y];
              se !== ge && se !== We && ge !== We && r.push(We, ge, se), g--, g < 0 && (g = f - 1)
            } else {
              const se = t[P],
                ge = t[g],
                We = t[y];
              se !== ge && se !== We && ge !== We && r.push(We, ge, se), y++, y >= f && (y = 0)
            }
            if (w === P) break
          }
        }

        function w_(n, t, r, o, c, f, g, y, w) {
          const P = c.length / 2,
            M = g && y && w;
          if (P < An.MAX_VERTEX_ARRAY_LENGTH) {
            const R = t.prepareSegment(P, r, o),
              U = R.vertexLength;
            for (let ne = 0; ne < f.length; ne += 3) o.emplaceBack(U + f[ne], U + f[ne + 1], U + f[ne + 2]);
            let G, W;
            R.vertexLength += P, R.primitiveLength += f.length / 3, M && (W = g.prepareSegment(P, r, y), G = W.vertexLength, W.vertexLength += P);
            for (let ne = 0; ne < c.length; ne += 2) n(c[ne], c[ne + 1]);
            if (M)
              for (let ne = 0; ne < w.length; ne++) {
                const se = w[ne];
                for (let ge = 1; ge < se.length; ge += 2) y.emplaceBack(G + se[ge - 1], G + se[ge]);
                W.primitiveLength += se.length / 2
              }
          } else(function(R, U, G, W, ne, se) {
            const ge = [];
            for (let gt = 0; gt < W.length / 2; gt++) ge.push(-1);
            const We = {
              count: 0
            };
            let Te = 0,
              De = R.getOrCreateLatestSegment(U, G),
              nt = De.vertexLength;
            for (let gt = 2; gt < ne.length; gt += 3) {
              const Vt = ne[gt - 2],
                pr = ne[gt - 1],
                ir = ne[gt];
              let ur = ge[Vt] < Te,
                Kr = ge[pr] < Te,
                lr = ge[ir] < Te;
              De.vertexLength + ((ur ? 1 : 0) + (Kr ? 1 : 0) + (lr ? 1 : 0)) > An.MAX_VERTEX_ARRAY_LENGTH && (De = R.createNewSegment(U, G), Te = We.count, ur = !0, Kr = !0, lr = !0, nt = 0);
              const hr = ju(ge, W, se, We, Vt, ur, De),
                Ct = ju(ge, W, se, We, pr, Kr, De),
                un = ju(ge, W, se, We, ir, lr, De);
              G.emplaceBack(nt + hr - Te, nt + Ct - Te, nt + un - Te), De.primitiveLength++
            }
          })(t, r, o, c, f, n), M && (function(R, U, G, W, ne, se) {
            const ge = [];
            for (let gt = 0; gt < W.length / 2; gt++) ge.push(-1);
            const We = {
              count: 0
            };
            let Te = 0,
              De = R.getOrCreateLatestSegment(U, G),
              nt = De.vertexLength;
            for (let gt = 0; gt < ne.length; gt++) {
              const Vt = ne[gt];
              for (let pr = 1; pr < ne[gt].length; pr += 2) {
                const ir = Vt[pr - 1],
                  ur = Vt[pr];
                let Kr = ge[ir] < Te,
                  lr = ge[ur] < Te;
                De.vertexLength + ((Kr ? 1 : 0) + (lr ? 1 : 0)) > An.MAX_VERTEX_ARRAY_LENGTH && (De = R.createNewSegment(U, G), Te = We.count, Kr = !0, lr = !0, nt = 0);
                const hr = ju(ge, W, se, We, ir, Kr, De),
                  Ct = ju(ge, W, se, We, ur, lr, De);
                G.emplaceBack(nt + hr - Te, nt + Ct - Te), De.primitiveLength++
              }
            }
          })(g, r, y, c, w, n), t.forceNewSegmentOnNextPrepare(), g == null || g.forceNewSegmentOnNextPrepare()
        }

        function ju(n, t, r, o, c, f, g) {
          if (f) {
            const y = o.count;
            return r(t[2 * c], t[2 * c + 1]), n[c] = o.count, o.count++, g.vertexLength++, y
          }
          return n[c]
        }
        class Nf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new _e, this.indexArray = new kt, this.indexArray2 = new Br, this.programConfigurations = new ls(t.layers, t.zoom), this.segments = new An, this.segments2 = new An, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, o) {
            this.hasDependencies = np("fill", this.layers, r);
            const c = this.layers[0].layout.get("fill-sort-key"),
              f = !c.isConstant(),
              g = [];
            for (const {
                feature: y,
                id: w,
                index: P,
                sourceLayerIndex: M
              }
              of t) {
              const R = this.layers[0]._featureFilter.needGeometry,
                U = Fo(y, R);
              if (!this.layers[0]._featureFilter.filter(new ai(this.zoom), U, o)) continue;
              const G = f ? c.evaluate(U, {}, o, r.availableImages) : void 0,
                W = {
                  id: w,
                  properties: y.properties,
                  type: y.type,
                  sourceLayerIndex: M,
                  index: P,
                  geometry: R ? U.geometry : bo(y),
                  patterns: {},
                  sortKey: G
                };
              g.push(W)
            }
            f && g.sort(((y, w) => y.sortKey - w.sortKey));
            for (const y of g) {
              const {
                geometry: w,
                index: P,
                sourceLayerIndex: M
              } = y;
              if (this.hasDependencies) {
                const R = Ff("fill", this.layers, y, {
                  zoom: this.zoom
                }, r);
                this.patternFeatures.push(R)
              } else this.addFeature(y, w, P, o, {}, r.subdivisionGranularity);
              r.featureIndex.insert(t[P].feature, w, P, M, this.index)
            }
          }
          update(t, r, o) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: o
            })
          }
          addFeatures(t, r, o) {
            for (const c of this.patternFeatures) this.addFeature(c, c.geometry, c.index, r, o, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, x1), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy())
          }
          addFeature(t, r, o, c, f, g) {
            for (const y of Dl(r, 500)) {
              const w = b_(y, c, g.fill.getGranularityForZoomLevel(c.z)),
                P = this.layoutVertexArray;
              w_(((M, R) => {
                P.emplaceBack(M, R)
              }), this.segments, this.layoutVertexArray, this.indexArray, w.verticesFlattened, w.indicesTriangles, this.segments2, this.indexArray2, w.indicesLineList)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {
              imagePositions: f,
              canonical: c
            })
          }
        }
        let T_, S_;
        Cr("FillBucket", Nf, {
          omit: ["layers", "patternFeatures"]
        });
        var L1 = {
          get paint() {
            return S_ = S_ || new na({
              "fill-antialias": new Hr(Q.paint_fill["fill-antialias"]),
              "fill-opacity": new an(Q.paint_fill["fill-opacity"]),
              "fill-color": new an(Q.paint_fill["fill-color"]),
              "fill-outline-color": new an(Q.paint_fill["fill-outline-color"]),
              "fill-translate": new Hr(Q.paint_fill["fill-translate"]),
              "fill-translate-anchor": new Hr(Q.paint_fill["fill-translate-anchor"]),
              "fill-pattern": new cl(Q.paint_fill["fill-pattern"])
            })
          },
          get layout() {
            return T_ = T_ || new na({
              "fill-sort-key": new an(Q.layout_fill["fill-sort-key"])
            })
          }
        };
        class z1 extends Ga {
          constructor(t, r) {
            super(t, L1, r)
          }
          recalculate(t, r) {
            super.recalculate(t, r);
            const o = this.paint._values["fill-outline-color"];
            o.value.kind === "constant" && o.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
          }
          createBucket(t) {
            return new Nf(t)
          }
          queryRadius() {
            return tp(this.paint.get("fill-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            geometry: r,
            transform: o,
            pixelsToTileUnits: c
          }) {
            return r_(rp(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -o.bearingInRadians, c), r)
          }
          isTileClipped() {
            return !0
          }
        }
        const D1 = Si([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_normal_ed",
            components: 4,
            type: "Int16"
          }], 4),
          R1 = Si([{
            name: "a_centroid",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: F1
          } = D1;
        class mc {
          constructor(t, r, o, c, f) {
            this.properties = {}, this.extent = o, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = c, this._values = f, t.readFields(B1, this, r)
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos,
              o = [];
            let c, f = 1,
              g = 0,
              y = 0,
              w = 0;
            for (; t.pos < r;) {
              if (g <= 0) {
                const P = t.readVarint();
                f = 7 & P, g = P >> 3
              }
              if (g--, f === 1 || f === 2) y += t.readSVarint(), w += t.readSVarint(), f === 1 && (c && o.push(c), c = []), c && c.push(new F(y, w));
              else {
                if (f !== 7) throw new Error(`unknown command ${f}`);
                c && c.push(c[0].clone())
              }
            }
            return c && o.push(c), o
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos;
            let o = 1,
              c = 0,
              f = 0,
              g = 0,
              y = 1 / 0,
              w = -1 / 0,
              P = 1 / 0,
              M = -1 / 0;
            for (; t.pos < r;) {
              if (c <= 0) {
                const R = t.readVarint();
                o = 7 & R, c = R >> 3
              }
              if (c--, o === 1 || o === 2) f += t.readSVarint(), g += t.readSVarint(), f < y && (y = f), f > w && (w = f), g < P && (P = g), g > M && (M = g);
              else if (o !== 7) throw new Error(`unknown command ${o}`)
            }
            return [y, P, w, M]
          }
          toGeoJSON(t, r, o) {
            const c = this.extent * Math.pow(2, o),
              f = this.extent * t,
              g = this.extent * r,
              y = this.loadGeometry();

            function w(U) {
              return [360 * (U.x + f) / c - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (U.y + g) / c) * Math.PI)) - 90]
            }

            function P(U) {
              return U.map(w)
            }
            let M;
            if (this.type === 1) {
              const U = [];
              for (const W of y) U.push(W[0]);
              const G = P(U);
              M = U.length === 1 ? {
                type: "Point",
                coordinates: G[0]
              } : {
                type: "MultiPoint",
                coordinates: G
              }
            } else if (this.type === 2) {
              const U = y.map(P);
              M = U.length === 1 ? {
                type: "LineString",
                coordinates: U[0]
              } : {
                type: "MultiLineString",
                coordinates: U
              }
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const U = (function(W) {
                    const ne = W.length;
                    if (ne <= 1) return [W];
                    const se = [];
                    let ge, We;
                    for (let Te = 0; Te < ne; Te++) {
                      const De = O1(W[Te]);
                      De !== 0 && (We === void 0 && (We = De < 0), We === De < 0 ? (ge && se.push(ge), ge = [W[Te]]) : ge && ge.push(W[Te]))
                    }
                    return ge && se.push(ge), se
                  })(y),
                  G = [];
                for (const W of U) G.push(W.map(P));
                M = G.length === 1 ? {
                  type: "Polygon",
                  coordinates: G[0]
                } : {
                  type: "MultiPolygon",
                  coordinates: G
                }
              }
            }
            const R = {
              type: "Feature",
              geometry: M,
              properties: this.properties
            };
            return this.id != null && (R.id = this.id), R
          }
        }

        function B1(n, t, r) {
          n === 1 ? t.id = r.readVarint() : n === 2 ? (function(o, c) {
            const f = o.readVarint() + o.pos;
            for (; o.pos < f;) {
              const g = c._keys[o.readVarint()],
                y = c._values[o.readVarint()];
              c.properties[g] = y
            }
          })(r, t) : n === 3 ? t.type = r.readVarint() : n === 4 && (t._geometry = r.pos)
        }

        function O1(n) {
          let t = 0;
          for (let r, o, c = 0, f = n.length, g = f - 1; c < f; g = c++) r = n[c], o = n[g], t += (o.x - r.x) * (r.y + o.y);
          return t
        }
        mc.types = ["Unknown", "Point", "LineString", "Polygon"];
        class P_ {
          constructor(t, r) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(N1, this, r), this.length = this._features.length
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const r = this._pbf.readVarint() + this._pbf.pos;
            return new mc(this._pbf, r, this.extent, this._keys, this._values)
          }
        }

        function N1(n, t, r) {
          n === 15 ? t.version = r.readVarint() : n === 1 ? t.name = r.readString() : n === 5 ? t.extent = r.readVarint() : n === 2 ? t._features.push(r.pos) : n === 3 ? t._keys.push(r.readString()) : n === 4 && t._values.push((function(o) {
            let c = null;
            const f = o.readVarint() + o.pos;
            for (; o.pos < f;) {
              const g = o.readVarint() >> 3;
              c = g === 1 ? o.readString() : g === 2 ? o.readFloat() : g === 3 ? o.readDouble() : g === 4 ? o.readVarint64() : g === 5 ? o.readVarint() : g === 6 ? o.readSVarint() : g === 7 ? o.readBoolean() : null
            }
            if (c == null) throw new Error("unknown feature value");
            return c
          })(r))
        }
        class C_ {
          constructor(t, r) {
            this.layers = t.readFields(j1, {}, r)
          }
        }

        function j1(n, t, r) {
          if (n === 3) {
            const o = new P_(r, r.readVarint() + r.pos);
            o.length && (t[o.name] = o)
          }
        }
        const jf = Math.pow(2, 13);

        function qu(n, t, r, o, c, f, g, y) {
          n.emplaceBack(t, r, 2 * Math.floor(o * jf) + g, c * jf * 2, f * jf * 2, Math.round(y))
        }
        class qf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new ke, this.centroidVertexArray = new ve, this.indexArray = new kt, this.programConfigurations = new ls(t.layers, t.zoom), this.segments = new An, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, o) {
            this.features = [], this.hasDependencies = np("fill-extrusion", this.layers, r);
            for (const {
                feature: c,
                id: f,
                index: g,
                sourceLayerIndex: y
              }
              of t) {
              const w = this.layers[0]._featureFilter.needGeometry,
                P = Fo(c, w);
              if (!this.layers[0]._featureFilter.filter(new ai(this.zoom), P, o)) continue;
              const M = {
                id: f,
                sourceLayerIndex: y,
                index: g,
                geometry: w ? P.geometry : bo(c),
                properties: c.properties,
                type: c.type,
                patterns: {}
              };
              this.hasDependencies ? this.features.push(Ff("fill-extrusion", this.layers, M, {
                zoom: this.zoom
              }, r)) : this.addFeature(M, M.geometry, g, o, {}, r.subdivisionGranularity), r.featureIndex.insert(c, M.geometry, g, y, this.index, !0)
            }
          }
          addFeatures(t, r, o) {
            for (const c of this.features) {
              const {
                geometry: f
              } = c;
              this.addFeature(c, f, c.index, r, o, t.subdivisionGranularity)
            }
          }
          update(t, r, o) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: o
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, F1), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, R1.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy())
          }
          addFeature(t, r, o, c, f, g) {
            for (const y of Dl(r, 500)) {
              const w = {
                  x: 0,
                  y: 0,
                  sampleCount: 0
                },
                P = this.layoutVertexArray.length;
              this.processPolygon(w, c, t, y, g);
              const M = this.layoutVertexArray.length - P,
                R = Math.floor(w.x / w.sampleCount),
                U = Math.floor(w.y / w.sampleCount);
              for (let G = 0; G < M; G++) this.centroidVertexArray.emplaceBack(R, U)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {
              imagePositions: f,
              canonical: c
            })
          }
          processPolygon(t, r, o, c, f) {
            if (c.length < 1 || I_(c[0])) return;
            for (const R of c) R.length !== 0 && q1(t, R);
            const g = {
                segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
              },
              y = f.fill.getGranularityForZoomLevel(r.z),
              w = mc.types[o.type] === "Polygon";
            for (const R of c) {
              if (R.length === 0 || I_(R)) continue;
              const U = fl(R, y, w);
              this._generateSideFaces(U, g)
            }
            if (!w) return;
            const P = b_(c, r, y, !1),
              M = this.layoutVertexArray;
            w_(((R, U) => {
              qu(M, R, U, 0, 0, 1, 1, 0)
            }), this.segments, this.layoutVertexArray, this.indexArray, P.verticesFlattened, P.indicesTriangles)
          }
          _generateSideFaces(t, r) {
            let o = 0;
            for (let c = 1; c < t.length; c++) {
              const f = t[c],
                g = t[c - 1];
              if (V1(f, g)) continue;
              r.segment.vertexLength + 4 > An.MAX_VERTEX_ARRAY_LENGTH && (r.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const y = f.sub(g)._perp()._unit(),
                w = g.dist(f);
              o + w > 32768 && (o = 0), qu(this.layoutVertexArray, f.x, f.y, y.x, y.y, 0, 0, o), qu(this.layoutVertexArray, f.x, f.y, y.x, y.y, 0, 1, o), o += w, qu(this.layoutVertexArray, g.x, g.y, y.x, y.y, 0, 0, o), qu(this.layoutVertexArray, g.x, g.y, y.x, y.y, 0, 1, o);
              const P = r.segment.vertexLength;
              this.indexArray.emplaceBack(P, P + 2, P + 1), this.indexArray.emplaceBack(P + 1, P + 2, P + 3), r.segment.vertexLength += 4, r.segment.primitiveLength += 2
            }
          }
        }

        function q1(n, t) {
          for (let r = 0; r < t.length; r++) {
            const o = t[r];
            r === t.length - 1 && t[0].x === o.x && t[0].y === o.y || (n.x += o.x, n.y += o.y, n.sampleCount++)
          }
        }

        function V1(n, t) {
          return n.x === t.x && (n.x < 0 || n.x > Je) || n.y === t.y && (n.y < 0 || n.y > Je)
        }

        function I_(n) {
          return n.every((t => t.x < 0)) || n.every((t => t.x > Je)) || n.every((t => t.y < 0)) || n.every((t => t.y > Je))
        }
        let M_;
        Cr("FillExtrusionBucket", qf, {
          omit: ["layers", "features"]
        });
        var U1 = {
          get paint() {
            return M_ = M_ || new na({
              "fill-extrusion-opacity": new Hr(Q["paint_fill-extrusion"]["fill-extrusion-opacity"]),
              "fill-extrusion-color": new an(Q["paint_fill-extrusion"]["fill-extrusion-color"]),
              "fill-extrusion-translate": new Hr(Q["paint_fill-extrusion"]["fill-extrusion-translate"]),
              "fill-extrusion-translate-anchor": new Hr(Q["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
              "fill-extrusion-pattern": new cl(Q["paint_fill-extrusion"]["fill-extrusion-pattern"]),
              "fill-extrusion-height": new an(Q["paint_fill-extrusion"]["fill-extrusion-height"]),
              "fill-extrusion-base": new an(Q["paint_fill-extrusion"]["fill-extrusion-base"]),
              "fill-extrusion-vertical-gradient": new Hr(Q["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
            })
          }
        };
        class Z1 extends Ga {
          constructor(t, r) {
            super(t, U1, r)
          }
          createBucket(t) {
            return new qf(t)
          }
          queryRadius() {
            return tp(this.paint.get("fill-extrusion-translate"))
          }
          is3D() {
            return !0
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: o,
            geometry: c,
            transform: f,
            pixelsToTileUnits: g,
            pixelPosMatrix: y
          }) {
            const w = rp(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -f.bearingInRadians, g),
              P = this.paint.get("fill-extrusion-height").evaluate(r, o),
              M = this.paint.get("fill-extrusion-base").evaluate(r, o),
              R = (function(G, W) {
                const ne = [];
                for (const se of G) {
                  const ge = [se.x, se.y, 0, 1];
                  Xe(ge, ge, W), ne.push(new F(ge[0] / ge[3], ge[1] / ge[3]))
                }
                return ne
              })(w, y),
              U = (function(G, W, ne, se) {
                const ge = [],
                  We = [],
                  Te = se[8] * W,
                  De = se[9] * W,
                  nt = se[10] * W,
                  gt = se[11] * W,
                  Vt = se[8] * ne,
                  pr = se[9] * ne,
                  ir = se[10] * ne,
                  ur = se[11] * ne;
                for (const Kr of G) {
                  const lr = [],
                    hr = [];
                  for (const Ct of Kr) {
                    const un = Ct.x,
                      yn = Ct.y,
                      rn = se[0] * un + se[4] * yn + se[12],
                      Gr = se[1] * un + se[5] * yn + se[13],
                      Un = se[2] * un + se[6] * yn + se[14],
                      yi = se[3] * un + se[7] * yn + se[15],
                      Bi = Un + nt,
                      aa = yi + gt,
                      $a = rn + Vt,
                      Ca = Gr + pr,
                      Ki = Un + ir,
                      vi = yi + ur,
                      Wi = new F((rn + Te) / aa, (Gr + De) / aa);
                    Wi.z = Bi / aa, lr.push(Wi);
                    const Ji = new F($a / vi, Ca / vi);
                    Ji.z = Ki / vi, hr.push(Ji)
                  }
                  ge.push(lr), We.push(hr)
                }
                return [ge, We]
              })(c, M, P, y);
            return (function(G, W, ne) {
              let se = 1 / 0;
              r_(ne, W) && (se = A_(ne, W[0]));
              for (let ge = 0; ge < W.length; ge++) {
                const We = W[ge],
                  Te = G[ge];
                for (let De = 0; De < We.length - 1; De++) {
                  const nt = We[De],
                    gt = [nt, We[De + 1], Te[De + 1], Te[De], nt];
                  t_(ne, gt) && (se = Math.min(se, A_(ne, gt)))
                }
              }
              return se !== 1 / 0 && se
            })(U[0], U[1], R)
          }
        }

        function Vu(n, t) {
          return n.x * t.x + n.y * t.y
        }

        function A_(n, t) {
          if (n.length === 1) {
            let r = 0;
            const o = t[r++];
            let c;
            for (; !c || o.equals(c);)
              if (c = t[r++], !c) return 1 / 0;
            for (; r < t.length; r++) {
              const f = t[r],
                g = n[0],
                y = c.sub(o),
                w = f.sub(o),
                P = g.sub(o),
                M = Vu(y, y),
                R = Vu(y, w),
                U = Vu(w, w),
                G = Vu(P, y),
                W = Vu(P, w),
                ne = M * U - R * R,
                se = (U * G - R * W) / ne,
                ge = (M * W - R * G) / ne,
                We = o.z * (1 - se - ge) + c.z * se + f.z * ge;
              if (isFinite(We)) return We
            }
            return 1 / 0
          } {
            let r = 1 / 0;
            for (const o of t) r = Math.min(r, o.z);
            return r
          }
        }
        const G1 = Si([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
          }], 4),
          {
            members: H1
          } = G1,
          W1 = Si([{
            name: "a_uv_x",
            components: 1,
            type: "Float32"
          }, {
            name: "a_split_index",
            components: 1,
            type: "Float32"
          }]),
          {
            members: $1
          } = W1,
          X1 = Math.cos(Math.PI / 180 * 37.5),
          k_ = Math.pow(2, 14) / .5;
        class Vf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((r => {
              this.gradients[r.id] = {}
            })), this.layoutVertexArray = new Fe, this.layoutVertexArray2 = new xe, this.indexArray = new kt, this.programConfigurations = new ls(t.layers, t.zoom), this.segments = new An, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, o) {
            this.hasDependencies = np("line", this.layers, r) || this.hasLineDasharray(this.layers);
            const c = this.layers[0].layout.get("line-sort-key"),
              f = !c.isConstant(),
              g = [];
            for (const {
                feature: y,
                id: w,
                index: P,
                sourceLayerIndex: M
              }
              of t) {
              const R = this.layers[0]._featureFilter.needGeometry,
                U = Fo(y, R);
              if (!this.layers[0]._featureFilter.filter(new ai(this.zoom), U, o)) continue;
              const G = f ? c.evaluate(U, {}, o) : void 0,
                W = {
                  id: w,
                  properties: y.properties,
                  type: y.type,
                  sourceLayerIndex: M,
                  index: P,
                  geometry: R ? U.geometry : bo(y),
                  patterns: {},
                  dashes: {},
                  sortKey: G
                };
              g.push(W)
            }
            f && g.sort(((y, w) => y.sortKey - w.sortKey));
            for (const y of g) {
              const {
                geometry: w,
                index: P,
                sourceLayerIndex: M
              } = y;
              this.hasDependencies ? (np("line", this.layers, r) ? Ff("line", this.layers, y, {
                zoom: this.zoom
              }, r) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, y, this.zoom, r), this.patternFeatures.push(y)) : this.addFeature(y, w, P, o, {}, {}, r.subdivisionGranularity), r.featureIndex.insert(t[P].feature, w, P, M, this.index)
            }
          }
          update(t, r, o, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: o,
              dashPositions: c
            })
          }
          addFeatures(t, r, o, c) {
            for (const f of this.patternFeatures) this.addFeature(f, f.geometry, f.index, r, o, c, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, $1)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, H1), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return {
              start: +t.properties.mapbox_clip_start,
              end: +t.properties.mapbox_clip_end
            }
          }
          addFeature(t, r, o, c, f, g, y) {
            const w = this.layers[0].layout,
              P = w.get("line-join").evaluate(t, {}),
              M = w.get("line-cap"),
              R = w.get("line-miter-limit"),
              U = w.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const G of r) this.addLine(G, t, P, M, R, U, c, y);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {
              imagePositions: f,
              dashPositions: g,
              canonical: c
            })
          }
          addLine(t, r, o, c, f, g, y, w) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = fl(t, y ? w.line.getGranularityForZoomLevel(y.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let Te = 0; Te < t.length - 1; Te++) this.totalDistance += t[Te].dist(t[Te + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
            }
            const P = mc.types[r.type] === "Polygon";
            let M = t.length;
            for (; M >= 2 && t[M - 1].equals(t[M - 2]);) M--;
            let R = 0;
            for (; R < M - 1 && t[R].equals(t[R + 1]);) R++;
            if (M < (P ? 3 : 2)) return;
            o === "bevel" && (f = 1.05);
            const U = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
              G = this.segments.prepareSegment(10 * M, this.layoutVertexArray, this.indexArray);
            let W, ne, se, ge, We;
            this.e1 = this.e2 = -1, P && (W = t[M - 2], We = t[R].sub(W)._unit()._perp());
            for (let Te = R; Te < M; Te++) {
              if (se = Te === M - 1 ? P ? t[R + 1] : void 0 : t[Te + 1], se && t[Te].equals(se)) continue;
              We && (ge = We), W && (ne = W), W = t[Te], We = se ? se.sub(W)._unit()._perp() : ge, ge = ge || We;
              let De = ge.add(We);
              De.x === 0 && De.y === 0 || De._unit();
              const nt = ge.x * We.x + ge.y * We.y,
                gt = De.x * We.x + De.y * We.y,
                Vt = gt !== 0 ? 1 / gt : 1 / 0,
                pr = 2 * Math.sqrt(2 - 2 * gt),
                ir = gt < X1 && ne && se,
                ur = ge.x * We.y - ge.y * We.x > 0;
              if (ir && Te > R) {
                const hr = W.dist(ne);
                if (hr > 2 * U) {
                  const Ct = W.sub(W.sub(ne)._mult(U / hr)._round());
                  this.updateDistance(ne, Ct), this.addCurrentVertex(Ct, ge, 0, 0, G), ne = Ct
                }
              }
              const Kr = ne && se;
              let lr = Kr ? o : P ? "butt" : c;
              if (Kr && lr === "round" && (Vt < g ? lr = "miter" : Vt <= 2 && (lr = "fakeround")), lr === "miter" && Vt > f && (lr = "bevel"), lr === "bevel" && (Vt > 2 && (lr = "flipbevel"), Vt < f && (lr = "miter")), ne && this.updateDistance(ne, W), lr === "miter") De._mult(Vt), this.addCurrentVertex(W, De, 0, 0, G);
              else if (lr === "flipbevel") {
                if (Vt > 100) De = We.mult(-1);
                else {
                  const hr = Vt * ge.add(We).mag() / ge.sub(We).mag();
                  De._perp()._mult(hr * (ur ? -1 : 1))
                }
                this.addCurrentVertex(W, De, 0, 0, G), this.addCurrentVertex(W, De.mult(-1), 0, 0, G)
              } else if (lr === "bevel" || lr === "fakeround") {
                const hr = -Math.sqrt(Vt * Vt - 1),
                  Ct = ur ? hr : 0,
                  un = ur ? 0 : hr;
                if (ne && this.addCurrentVertex(W, ge, Ct, un, G), lr === "fakeround") {
                  const yn = Math.round(180 * pr / Math.PI / 20);
                  for (let rn = 1; rn < yn; rn++) {
                    let Gr = rn / yn;
                    if (Gr !== .5) {
                      const yi = Gr - .5;
                      Gr += Gr * yi * (Gr - 1) * ((1.0904 + nt * (nt * (3.55645 - 1.43519 * nt) - 3.2452)) * yi * yi + (.848013 + nt * (.215638 * nt - 1.06021)))
                    }
                    const Un = We.sub(ge)._mult(Gr)._add(ge)._unit()._mult(ur ? -1 : 1);
                    this.addHalfVertex(W, Un.x, Un.y, !1, ur, 0, G)
                  }
                }
                se && this.addCurrentVertex(W, We, -Ct, -un, G)
              } else if (lr === "butt") this.addCurrentVertex(W, De, 0, 0, G);
              else if (lr === "square") {
                const hr = ne ? 1 : -1;
                this.addCurrentVertex(W, De, hr, hr, G)
              } else lr === "round" && (ne && (this.addCurrentVertex(W, ge, 0, 0, G), this.addCurrentVertex(W, ge, 1, 1, G, !0)), se && (this.addCurrentVertex(W, We, -1, -1, G, !0), this.addCurrentVertex(W, We, 0, 0, G)));
              if (ir && Te < M - 1) {
                const hr = W.dist(se);
                if (hr > 2 * U) {
                  const Ct = W.add(se.sub(W)._mult(U / hr)._round());
                  this.updateDistance(W, Ct), this.addCurrentVertex(Ct, We, 0, 0, G), W = Ct
                }
              }
            }
          }
          addCurrentVertex(t, r, o, c, f, g = !1) {
            const y = r.y * c - r.x,
              w = -r.y - r.x * c;
            this.addHalfVertex(t, r.x + r.y * o, r.y - r.x * o, g, !1, o, f), this.addHalfVertex(t, y, w, g, !0, -c, f), this.distance > k_ / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, r, o, c, f, g))
          }
          addHalfVertex({
            x: t,
            y: r
          }, o, c, f, g, y, w) {
            const P = .5 * (this.lineClips ? this.scaledDistance * (k_ - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (f ? 1 : 0), (r << 1) + (g ? 1 : 0), Math.round(63 * o) + 128, Math.round(63 * c) + 128, 1 + (y === 0 ? 0 : y < 0 ? -1 : 1) | (63 & P) << 2, P >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const M = w.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, M, this.e2), w.primitiveLength++), g ? this.e2 = M : this.e1 = M
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
          }
          updateDistance(t, r) {
            this.distance += t.dist(r), this.updateScaledDistance()
          }
          hasLineDasharray(t) {
            for (const r of t) {
              const o = r.paint.get("line-dasharray");
              if (o && !o.isConstant()) return !0
            }
            return !1
          }
          addLineDashDependencies(t, r, o, c) {
            for (const f of t) {
              const g = f.paint.get("line-dasharray");
              if (!g || g.value.kind === "constant") continue;
              const y = f.layout.get("line-cap") === "round",
                w = {
                  dasharray: g.value.evaluate({
                    zoom: o - 1
                  }, r, {}),
                  round: y
                },
                P = {
                  dasharray: g.value.evaluate({
                    zoom: o
                  }, r, {}),
                  round: y
                },
                M = {
                  dasharray: g.value.evaluate({
                    zoom: o + 1
                  }, r, {}),
                  round: y
                },
                R = `${w.dasharray.join(",")},${w.round}`,
                U = `${P.dasharray.join(",")},${P.round}`,
                G = `${M.dasharray.join(",")},${M.round}`;
              c.dashDependencies[R] = w, c.dashDependencies[U] = P, c.dashDependencies[G] = M, r.dashes[f.id] = {
                min: R,
                mid: U,
                max: G
              }
            }
          }
        }
        let E_, L_;
        Cr("LineBucket", Vf, {
          omit: ["layers", "patternFeatures"]
        });
        var z_ = {
          get paint() {
            return L_ = L_ || new na({
              "line-opacity": new an(Q.paint_line["line-opacity"]),
              "line-color": new an(Q.paint_line["line-color"]),
              "line-translate": new Hr(Q.paint_line["line-translate"]),
              "line-translate-anchor": new Hr(Q.paint_line["line-translate-anchor"]),
              "line-width": new an(Q.paint_line["line-width"]),
              "line-gap-width": new an(Q.paint_line["line-gap-width"]),
              "line-offset": new an(Q.paint_line["line-offset"]),
              "line-blur": new an(Q.paint_line["line-blur"]),
              "line-dasharray": new cl(Q.paint_line["line-dasharray"]),
              "line-pattern": new cl(Q.paint_line["line-pattern"]),
              "line-gradient": new ul(Q.paint_line["line-gradient"])
            })
          },
          get layout() {
            return E_ = E_ || new na({
              "line-cap": new Hr(Q.layout_line["line-cap"]),
              "line-join": new an(Q.layout_line["line-join"]),
              "line-miter-limit": new Hr(Q.layout_line["line-miter-limit"]),
              "line-round-limit": new Hr(Q.layout_line["line-round-limit"]),
              "line-sort-key": new an(Q.layout_line["line-sort-key"])
            })
          }
        };
        class Y1 extends an {
          possiblyEvaluate(t, r) {
            return r = new ai(Math.floor(r.zoom), {
              now: r.now,
              fadeDuration: r.fadeDuration,
              zoomHistory: r.zoomHistory,
              transition: r.transition
            }), super.possiblyEvaluate(t, r)
          }
          evaluate(t, r, o, c) {
            return r = ht({}, r, {
              zoom: Math.floor(r.zoom)
            }), super.evaluate(t, r, o, c)
          }
        }
        let sp;
        class K1 extends Ga {
          constructor(t, r) {
            super(t, z_, r), this.gradientVersion = 0, sp || (sp = new Y1(z_.paint.properties["line-width"].specification), sp.useIntegerZoom = !0)
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const r = this.gradientExpression();
              this.stepInterpolant = !!(function(o) {
                return o._styleExpression !== void 0
              })(r) && r._styleExpression.expression instanceof eo, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression
          }
          recalculate(t, r) {
            super.recalculate(t, r), this.paint._values["line-floorwidth"] = sp.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
          }
          createBucket(t) {
            return new Vf(t)
          }
          queryRadius(t) {
            const r = t,
              o = D_(hc("line-width", this, r), hc("line-gap-width", this, r)),
              c = hc("line-offset", this, r);
            return o / 2 + Math.abs(c) + tp(this.paint.get("line-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: o,
            geometry: c,
            transform: f,
            pixelsToTileUnits: g
          }) {
            const y = rp(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -f.bearingInRadians, g),
              w = g / 2 * D_(this.paint.get("line-width").evaluate(r, o), this.paint.get("line-gap-width").evaluate(r, o)),
              P = this.paint.get("line-offset").evaluate(r, o);
            return P && (c = (function(M, R) {
              const U = [];
              for (let G = 0; G < M.length; G++) {
                const W = M[G],
                  ne = [];
                for (let se = 0; se < W.length; se++) {
                  const ge = W[se - 1],
                    We = W[se],
                    Te = W[se + 1],
                    De = se === 0 ? new F(0, 0) : We.sub(ge)._unit()._perp(),
                    nt = se === W.length - 1 ? new F(0, 0) : Te.sub(We)._unit()._perp(),
                    gt = De._add(nt)._unit(),
                    Vt = gt.x * nt.x + gt.y * nt.y;
                  Vt !== 0 && gt._mult(1 / Vt), ne.push(gt._mult(R)._add(We))
                }
                U.push(ne)
              }
              return U
            })(c, P * g)), (function(M, R, U) {
              for (let G = 0; G < R.length; G++) {
                const W = R[G];
                if (M.length >= 3) {
                  for (let ne = 0; ne < W.length; ne++)
                    if (uc(M, W[ne])) return !0
                }
                if (i1(M, W, U)) return !0
              }
              return !1
            })(y, c, w)
          }
          isTileClipped() {
            return !0
          }
        }

        function D_(n, t) {
          return t > 0 ? t + 2 * n : n
        }
        const J1 = Si([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
          }], 4),
          Q1 = Si([{
            name: "a_projected_pos",
            components: 3,
            type: "Float32"
          }], 4);
        Si([{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint32"
        }], 4);
        const ex = Si([{
          name: "a_placed",
          components: 2,
          type: "Uint8"
        }, {
          name: "a_shift",
          components: 2,
          type: "Float32"
        }, {
          name: "a_box_real",
          components: 2,
          type: "Int16"
        }]);
        Si([{
          type: "Int16",
          name: "anchorPointX"
        }, {
          type: "Int16",
          name: "anchorPointY"
        }, {
          type: "Int16",
          name: "x1"
        }, {
          type: "Int16",
          name: "y1"
        }, {
          type: "Int16",
          name: "x2"
        }, {
          type: "Int16",
          name: "y2"
        }, {
          type: "Uint32",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "sourceLayerIndex"
        }, {
          type: "Uint16",
          name: "bucketIndex"
        }]);
        const R_ = Si([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
          }], 4),
          tx = Si([{
            name: "a_pos",
            components: 2,
            type: "Float32"
          }, {
            name: "a_radius",
            components: 1,
            type: "Float32"
          }, {
            name: "a_flags",
            components: 2,
            type: "Int16"
          }], 4);

        function rx(n, t, r) {
          return n.sections.forEach((o => {
            o.text = (function(c, f, g) {
              const y = f.layout.get("text-transform").evaluate(g, {});
              return y === "uppercase" ? c = c.toLocaleUpperCase() : y === "lowercase" && (c = c.toLocaleLowerCase()), _o.applyArabicShaping && (c = _o.applyArabicShaping(c)), c
            })(o.text, t, r)
          })), n
        }
        Si([{
          name: "triangle",
          components: 3,
          type: "Uint16"
        }]), Si([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Uint16",
          name: "glyphStartIndex"
        }, {
          type: "Uint16",
          name: "numGlyphs"
        }, {
          type: "Uint32",
          name: "vertexStartIndex"
        }, {
          type: "Uint32",
          name: "lineStartIndex"
        }, {
          type: "Uint32",
          name: "lineLength"
        }, {
          type: "Uint16",
          name: "segment"
        }, {
          type: "Uint16",
          name: "lowerSize"
        }, {
          type: "Uint16",
          name: "upperSize"
        }, {
          type: "Float32",
          name: "lineOffsetX"
        }, {
          type: "Float32",
          name: "lineOffsetY"
        }, {
          type: "Uint8",
          name: "writingMode"
        }, {
          type: "Uint8",
          name: "placedOrientation"
        }, {
          type: "Uint8",
          name: "hidden"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Int16",
          name: "associatedIconIndex"
        }]), Si([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Int16",
          name: "rightJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "centerJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "leftJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "placedIconSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedIconSymbolIndex"
        }, {
          type: "Uint16",
          name: "key"
        }, {
          type: "Uint16",
          name: "textBoxStartIndex"
        }, {
          type: "Uint16",
          name: "textBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxEndIndex"
        }, {
          type: "Uint16",
          name: "iconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "iconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "numHorizontalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numVerticalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numIconVertices"
        }, {
          type: "Uint16",
          name: "numVerticalIconVertices"
        }, {
          type: "Uint16",
          name: "useRuntimeCollisionCircles"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Float32",
          name: "textBoxScale"
        }, {
          type: "Float32",
          name: "collisionCircleDiameter"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetStartIndex"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetEndIndex"
        }]), Si([{
          type: "Float32",
          name: "offsetX"
        }]), Si([{
          type: "Int16",
          name: "x"
        }, {
          type: "Int16",
          name: "y"
        }, {
          type: "Int16",
          name: "tileUnitDistanceFromAnchor"
        }]), Si([{
          type: "Uint16",
          name: "textAnchor"
        }, {
          type: "Float32",
          components: 2,
          name: "textOffset"
        }]);
        const Uu = {
          "!": "Ô∏ï",
          "#": "ÔºÉ",
          $: "ÔºÑ",
          "%": "ÔºÖ",
          "&": "ÔºÜ",
          "(": "Ô∏µ",
          ")": "Ô∏∂",
          "*": "Ôºä",
          "+": "Ôºã",
          ",": "Ô∏ê",
          "-": "Ô∏≤",
          ".": "„Éª",
          "/": "Ôºè",
          ":": "Ô∏ì",
          ";": "Ô∏î",
          "<": "Ô∏ø",
          "=": "Ôºù",
          ">": "ÔπÄ",
          "?": "Ô∏ñ",
          "@": "Ôº†",
          "[": "Ôπá",
          "\\": "Ôºº",
          "]": "Ôπà",
          "^": "Ôºæ",
          _: "Ô∏≥",
          "`": "ÔΩÄ",
          "{": "Ô∏∑",
          "|": "‚Äï",
          "}": "Ô∏∏",
          "~": "ÔΩû",
          "¬¢": "Ôø†",
          "¬£": "Ôø°",
          "¬•": "Ôø•",
          "¬¶": "Ôø§",
          "¬¨": "Ôø¢",
          "¬Ø": "Ôø£",
          "‚Äì": "Ô∏≤",
          "‚Äî": "Ô∏±",
          "‚Äò": "ÔπÉ",
          "‚Äô": "ÔπÑ",
          "‚Äú": "ÔπÅ",
          "‚Äù": "ÔπÇ",
          "‚Ä¶": "Ô∏ô",
          "‚Äß": "„Éª",
          "‚Ç©": "Ôø¶",
          "„ÄÅ": "Ô∏ë",
          "„ÄÇ": "Ô∏í",
          "„Äà": "Ô∏ø",
          "„Äâ": "ÔπÄ",
          "„Ää": "Ô∏Ω",
          "„Äã": "Ô∏æ",
          "„Äå": "ÔπÅ",
          "„Äç": "ÔπÇ",
          "„Äé": "ÔπÉ",
          "„Äè": "ÔπÑ",
          "„Äê": "Ô∏ª",
          "„Äë": "Ô∏º",
          "„Äî": "Ô∏π",
          "„Äï": "Ô∏∫",
          "„Äñ": "Ô∏ó",
          "„Äó": "Ô∏ò",
          "ÔºÅ": "Ô∏ï",
          "Ôºà": "Ô∏µ",
          "Ôºâ": "Ô∏∂",
          "Ôºå": "Ô∏ê",
          "Ôºç": "Ô∏≤",
          "Ôºé": "„Éª",
          "Ôºö": "Ô∏ì",
          "Ôºõ": "Ô∏î",
          "Ôºú": "Ô∏ø",
          "Ôºû": "ÔπÄ",
          "Ôºü": "Ô∏ñ",
          "Ôºª": "Ôπá",
          "ÔºΩ": "Ôπà",
          "Ôºø": "Ô∏≥",
          "ÔΩõ": "Ô∏∑",
          "ÔΩú": "‚Äï",
          "ÔΩù": "Ô∏∏",
          "ÔΩü": "Ô∏µ",
          "ÔΩ†": "Ô∏∂",
          "ÔΩ°": "Ô∏í",
          "ÔΩ¢": "ÔπÅ",
          "ÔΩ£": "ÔπÇ"
        };
        var Hi = 24;
        const Uf = 4294967296,
          F_ = 1 / Uf,
          B_ = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class Zf {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length
          }
          readFields(t, r, o = this.length) {
            for (; this.pos < o;) {
              const c = this.readVarint(),
                f = c >> 3,
                g = this.pos;
              this.type = 7 & c, t(f, r, this), this.pos === g && this.skip(c)
            }
            return r
          }
          readMessage(t, r) {
            return this.readFields(t, r, this.readVarint() + this.pos)
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, t
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, t
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * Uf;
            return this.pos += 8, t
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * Uf;
            return this.pos += 8, t
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, t
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, t
          }
          readVarint(t) {
            const r = this.buf;
            let o, c;
            return c = r[this.pos++], o = 127 & c, c < 128 ? o : (c = r[this.pos++], o |= (127 & c) << 7, c < 128 ? o : (c = r[this.pos++], o |= (127 & c) << 14, c < 128 ? o : (c = r[this.pos++], o |= (127 & c) << 21, c < 128 ? o : (c = r[this.pos], o |= (15 & c) << 28, (function(f, g, y) {
              const w = y.buf;
              let P, M;
              if (M = w[y.pos++], P = (112 & M) >> 4, M < 128 || (M = w[y.pos++], P |= (127 & M) << 3, M < 128) || (M = w[y.pos++], P |= (127 & M) << 10, M < 128) || (M = w[y.pos++], P |= (127 & M) << 17, M < 128) || (M = w[y.pos++], P |= (127 & M) << 24, M < 128) || (M = w[y.pos++], P |= (1 & M) << 31, M < 128)) return gc(f, P, g);
              throw new Error("Expected varint not more than 10 bytes")
            })(o, t, this)))))
          }
          readVarint64() {
            return this.readVarint(!0)
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2
          }
          readBoolean() {
            return !!this.readVarint()
          }
          readString() {
            const t = this.readVarint() + this.pos,
              r = this.pos;
            return this.pos = t, t - r >= 12 && B_ ? B_.decode(this.buf.subarray(r, t)) : (function(o, c, f) {
              let g = "",
                y = c;
              for (; y < f;) {
                const w = o[y];
                let P, M, R, U = null,
                  G = w > 239 ? 4 : w > 223 ? 3 : w > 191 ? 2 : 1;
                if (y + G > f) break;
                G === 1 ? w < 128 && (U = w) : G === 2 ? (P = o[y + 1], (192 & P) == 128 && (U = (31 & w) << 6 | 63 & P, U <= 127 && (U = null))) : G === 3 ? (P = o[y + 1], M = o[y + 2], (192 & P) == 128 && (192 & M) == 128 && (U = (15 & w) << 12 | (63 & P) << 6 | 63 & M, (U <= 2047 || U >= 55296 && U <= 57343) && (U = null))) : G === 4 && (P = o[y + 1], M = o[y + 2], R = o[y + 3], (192 & P) == 128 && (192 & M) == 128 && (192 & R) == 128 && (U = (15 & w) << 18 | (63 & P) << 12 | (63 & M) << 6 | 63 & R, (U <= 65535 || U >= 1114112) && (U = null))), U === null ? (U = 65533, G = 1) : U > 65535 && (U -= 65536, g += String.fromCharCode(U >>> 10 & 1023 | 55296), U = 56320 | 1023 & U), g += String.fromCharCode(U), y += G
              }
              return g
            })(this.buf, r, t)
          }
          readBytes() {
            const t = this.readVarint() + this.pos,
              r = this.buf.subarray(this.pos, t);
            return this.pos = t, r
          }
          readPackedVarint(t = [], r) {
            const o = this.readPackedEnd();
            for (; this.pos < o;) t.push(this.readVarint(r));
            return t
          }
          readPackedSVarint(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSVarint());
            return t
          }
          readPackedBoolean(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readBoolean());
            return t
          }
          readPackedFloat(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFloat());
            return t
          }
          readPackedDouble(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readDouble());
            return t
          }
          readPackedFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed32());
            return t
          }
          readPackedSFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed32());
            return t
          }
          readPackedFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed64());
            return t
          }
          readPackedSFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed64());
            return t
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1
          }
          skip(t) {
            const r = 7 & t;
            if (r === 0)
              for (; this.buf[this.pos++] > 127;);
            else if (r === 2) this.pos = this.readVarint() + this.pos;
            else if (r === 5) this.pos += 4;
            else {
              if (r !== 1) throw new Error(`Unimplemented type: ${r}`);
              this.pos += 8
            }
          }
          writeTag(t, r) {
            this.writeVarint(t << 3 | r)
          }
          realloc(t) {
            let r = this.length || 16;
            for (; r < this.pos + t;) r *= 2;
            if (r !== this.length) {
              const o = new Uint8Array(r);
              o.set(this.buf), this.buf = o, this.dataView = new DataView(o.buffer), this.length = r
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * F_), !0), this.pos += 8
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * F_), !0), this.pos += 8
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(r, o) {
              let c, f;
              if (r >= 0 ? (c = r % 4294967296 | 0, f = r / 4294967296 | 0) : (c = ~(-r % 4294967296), f = ~(-r / 4294967296), 4294967295 ^ c ? c = c + 1 | 0 : (c = 0, f = f + 1 | 0)), r >= 18446744073709552e3 || r < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              o.realloc(10), (function(g, y, w) {
                w.buf[w.pos++] = 127 & g | 128, g >>>= 7, w.buf[w.pos++] = 127 & g | 128, g >>>= 7, w.buf[w.pos++] = 127 & g | 128, g >>>= 7, w.buf[w.pos++] = 127 & g | 128, w.buf[w.pos] = 127 & (g >>>= 7)
              })(c, 0, o), (function(g, y) {
                const w = (7 & g) << 4;
                y.buf[y.pos++] |= w | ((g >>>= 3) ? 128 : 0), g && (y.buf[y.pos++] = 127 & g | ((g >>>= 7) ? 128 : 0), g && (y.buf[y.pos++] = 127 & g | ((g >>>= 7) ? 128 : 0), g && (y.buf[y.pos++] = 127 & g | ((g >>>= 7) ? 128 : 0), g && (y.buf[y.pos++] = 127 & g | ((g >>>= 7) ? 128 : 0), g && (y.buf[y.pos++] = 127 & g)))))
              })(f, o)
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))))
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t)
          }
          writeBoolean(t) {
            this.writeVarint(+t)
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const r = this.pos;
            this.pos = (function(c, f, g) {
              for (let y, w, P = 0; P < f.length; P++) {
                if (y = f.charCodeAt(P), y > 55295 && y < 57344) {
                  if (!w) {
                    y > 56319 || P + 1 === f.length ? (c[g++] = 239, c[g++] = 191, c[g++] = 189) : w = y;
                    continue
                  }
                  if (y < 56320) {
                    c[g++] = 239, c[g++] = 191, c[g++] = 189, w = y;
                    continue
                  }
                  y = w - 55296 << 10 | y - 56320 | 65536, w = null
                } else w && (c[g++] = 239, c[g++] = 191, c[g++] = 189, w = null);
                y < 128 ? c[g++] = y : (y < 2048 ? c[g++] = y >> 6 | 192 : (y < 65536 ? c[g++] = y >> 12 | 224 : (c[g++] = y >> 18 | 240, c[g++] = y >> 12 & 63 | 128), c[g++] = y >> 6 & 63 | 128), c[g++] = 63 & y | 128)
              }
              return g
            })(this.buf, t, this.pos);
            const o = this.pos - r;
            o >= 128 && O_(r, o, this), this.pos = r - 1, this.writeVarint(o), this.pos += o
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8
          }
          writeBytes(t) {
            const r = t.length;
            this.writeVarint(r), this.realloc(r);
            for (let o = 0; o < r; o++) this.buf[this.pos++] = t[o]
          }
          writeRawMessage(t, r) {
            this.pos++;
            const o = this.pos;
            t(r, this);
            const c = this.pos - o;
            c >= 128 && O_(o, c, this), this.pos = o - 1, this.writeVarint(c), this.pos += c
          }
          writeMessage(t, r, o) {
            this.writeTag(t, 2), this.writeRawMessage(r, o)
          }
          writePackedVarint(t, r) {
            r.length && this.writeMessage(t, nx, r)
          }
          writePackedSVarint(t, r) {
            r.length && this.writeMessage(t, ix, r)
          }
          writePackedBoolean(t, r) {
            r.length && this.writeMessage(t, sx, r)
          }
          writePackedFloat(t, r) {
            r.length && this.writeMessage(t, ax, r)
          }
          writePackedDouble(t, r) {
            r.length && this.writeMessage(t, ox, r)
          }
          writePackedFixed32(t, r) {
            r.length && this.writeMessage(t, lx, r)
          }
          writePackedSFixed32(t, r) {
            r.length && this.writeMessage(t, cx, r)
          }
          writePackedFixed64(t, r) {
            r.length && this.writeMessage(t, ux, r)
          }
          writePackedSFixed64(t, r) {
            r.length && this.writeMessage(t, hx, r)
          }
          writeBytesField(t, r) {
            this.writeTag(t, 2), this.writeBytes(r)
          }
          writeFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeFixed32(r)
          }
          writeSFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeSFixed32(r)
          }
          writeFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeFixed64(r)
          }
          writeSFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeSFixed64(r)
          }
          writeVarintField(t, r) {
            this.writeTag(t, 0), this.writeVarint(r)
          }
          writeSVarintField(t, r) {
            this.writeTag(t, 0), this.writeSVarint(r)
          }
          writeStringField(t, r) {
            this.writeTag(t, 2), this.writeString(r)
          }
          writeFloatField(t, r) {
            this.writeTag(t, 5), this.writeFloat(r)
          }
          writeDoubleField(t, r) {
            this.writeTag(t, 1), this.writeDouble(r)
          }
          writeBooleanField(t, r) {
            this.writeVarintField(t, +r)
          }
        }

        function gc(n, t, r) {
          return r ? 4294967296 * t + (n >>> 0) : 4294967296 * (t >>> 0) + (n >>> 0)
        }

        function O_(n, t, r) {
          const o = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          r.realloc(o);
          for (let c = r.pos - 1; c >= n; c--) r.buf[c + o] = r.buf[c]
        }

        function nx(n, t) {
          for (let r = 0; r < n.length; r++) t.writeVarint(n[r])
        }

        function ix(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSVarint(n[r])
        }

        function ax(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFloat(n[r])
        }

        function ox(n, t) {
          for (let r = 0; r < n.length; r++) t.writeDouble(n[r])
        }

        function sx(n, t) {
          for (let r = 0; r < n.length; r++) t.writeBoolean(n[r])
        }

        function lx(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFixed32(n[r])
        }

        function cx(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSFixed32(n[r])
        }

        function ux(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFixed64(n[r])
        }

        function hx(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSFixed64(n[r])
        }

        function dx(n, t, r) {
          n === 1 && r.readMessage(px, t)
        }

        function px(n, t, r) {
          if (n === 3) {
            const {
              id: o,
              bitmap: c,
              width: f,
              height: g,
              left: y,
              top: w,
              advance: P
            } = r.readMessage(fx, {});
            t.push({
              id: o,
              bitmap: new Du({
                width: f + 6,
                height: g + 6
              }, c),
              metrics: {
                width: f,
                height: g,
                left: y,
                top: w,
                advance: P
              }
            })
          }
        }

        function fx(n, t, r) {
          n === 1 ? t.id = r.readVarint() : n === 2 ? t.bitmap = r.readBytes() : n === 3 ? t.width = r.readVarint() : n === 4 ? t.height = r.readVarint() : n === 5 ? t.left = r.readSVarint() : n === 6 ? t.top = r.readSVarint() : n === 7 && (t.advance = r.readVarint())
        }

        function N_(n) {
          let t = 0,
            r = 0;
          for (const g of n) t += g.w * g.h, r = Math.max(r, g.w);
          n.sort(((g, y) => y.h - g.h));
          const o = [{
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(t / .95)), r),
            h: 1 / 0
          }];
          let c = 0,
            f = 0;
          for (const g of n)
            for (let y = o.length - 1; y >= 0; y--) {
              const w = o[y];
              if (!(g.w > w.w || g.h > w.h)) {
                if (g.x = w.x, g.y = w.y, f = Math.max(f, g.y + g.h), c = Math.max(c, g.x + g.w), g.w === w.w && g.h === w.h) {
                  const P = o.pop();
                  P && y < o.length && (o[y] = P)
                } else g.h === w.h ? (w.x += g.w, w.w -= g.w) : g.w === w.w ? (w.y += g.h, w.h -= g.h) : (o.push({
                  x: w.x + g.w,
                  y: w.y,
                  w: w.w - g.w,
                  h: g.h
                }), w.y += g.h, w.h -= g.h);
                break
              }
            }
          return {
            w: c,
            h: f,
            fill: t / (c * f) || 0
          }
        }
        class Gf {
          constructor(t, {
            pixelRatio: r,
            version: o,
            stretchX: c,
            stretchY: f,
            content: g,
            textFitWidth: y,
            textFitHeight: w
          }) {
            this.paddedRect = t, this.pixelRatio = r, this.stretchX = c, this.stretchY = f, this.content = g, this.version = o, this.textFitWidth = y, this.textFitHeight = w
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1]
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
          }
          get tlbr() {
            return this.tl.concat(this.br)
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
          }
        }
        class j_ {
          constructor(t, r) {
            const o = {},
              c = {};
            this.haveRenderCallbacks = [];
            const f = [];
            this.addImages(t, o, f), this.addImages(r, c, f);
            const {
              w: g,
              h: y
            } = N_(f), w = new Pa({
              width: g || 1,
              height: y || 1
            });
            for (const P in t) {
              const M = t[P],
                R = o[P].paddedRect;
              Pa.copy(M.data, w, {
                x: 0,
                y: 0
              }, {
                x: R.x + 1,
                y: R.y + 1
              }, M.data)
            }
            for (const P in r) {
              const M = r[P],
                R = c[P].paddedRect,
                U = R.x + 1,
                G = R.y + 1,
                W = M.data.width,
                ne = M.data.height;
              Pa.copy(M.data, w, {
                x: 0,
                y: 0
              }, {
                x: U,
                y: G
              }, M.data), Pa.copy(M.data, w, {
                x: 0,
                y: ne - 1
              }, {
                x: U,
                y: G - 1
              }, {
                width: W,
                height: 1
              }), Pa.copy(M.data, w, {
                x: 0,
                y: 0
              }, {
                x: U,
                y: G + ne
              }, {
                width: W,
                height: 1
              }), Pa.copy(M.data, w, {
                x: W - 1,
                y: 0
              }, {
                x: U - 1,
                y: G
              }, {
                width: 1,
                height: ne
              }), Pa.copy(M.data, w, {
                x: 0,
                y: 0
              }, {
                x: U + W,
                y: G
              }, {
                width: 1,
                height: ne
              })
            }
            this.image = w, this.iconPositions = o, this.patternPositions = c
          }
          addImages(t, r, o) {
            for (const c in t) {
              const f = t[c],
                g = {
                  x: 0,
                  y: 0,
                  w: f.data.width + 2,
                  h: f.data.height + 2
                };
              o.push(g), r[c] = new Gf(g, f), f.hasRenderCallback && this.haveRenderCallbacks.push(c)
            }
          }
          patchUpdatedImages(t, r) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const o in t.updatedImages) this.patchUpdatedImage(this.iconPositions[o], t.getImage(o), r), this.patchUpdatedImage(this.patternPositions[o], t.getImage(o), r)
          }
          patchUpdatedImage(t, r, o) {
            if (!t || !r || t.version === r.version) return;
            t.version = r.version;
            const [c, f] = t.tl;
            o.update(r.data, void 0, {
              x: c,
              y: f
            })
          }
        }
        var Rs;
        Cr("ImagePosition", Gf), Cr("ImageAtlas", j_), b.as = void 0, (Rs = b.as || (b.as = {}))[Rs.none = 0] = "none", Rs[Rs.horizontal = 1] = "horizontal", Rs[Rs.vertical = 2] = "vertical", Rs[Rs.horizontalOnly = 3] = "horizontalOnly";
        class Zu {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom"
          }
          static forText(t, r, o) {
            const c = new Zu;
            return c.scale = t || 1, c.fontStack = r, c.verticalAlign = o || "bottom", c
          }
          static forImage(t, r) {
            const o = new Zu;
            return o.imageName = t, o.verticalAlign = r || "bottom", o
          }
        }
        class _c {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
          }
          static fromFeature(t, r) {
            const o = new _c;
            for (let c = 0; c < t.sections.length; c++) {
              const f = t.sections[c];
              f.image ? o.addImageSection(f) : o.addTextSection(f, r)
            }
            return o
          }
          length() {
            return this.text.length
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]]
          }
          getSectionIndex(t) {
            return this.sectionIndex[t]
          }
          getCharCode(t) {
            return this.text.charCodeAt(t)
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let r = "";
              for (let o = 0; o < t.length; o++) {
                const c = t.charCodeAt(o + 1) || null,
                  f = t.charCodeAt(o - 1) || null;
                r += c && tc(c) && !Uu[t[o + 1]] || f && tc(f) && !Uu[t[o - 1]] || !Uu[t[o]] ? t[o] : Uu[t[o]]
              }
              return r
            })(this.text)
          }
          trim() {
            let t = 0;
            for (let o = 0; o < this.text.length && cp[this.text.charCodeAt(o)]; o++) t++;
            let r = this.text.length;
            for (let o = this.text.length - 1; o >= 0 && o >= t && cp[this.text.charCodeAt(o)]; o--) r--;
            this.text = this.text.substring(t, r), this.sectionIndex = this.sectionIndex.slice(t, r)
          }
          substring(t, r) {
            const o = new _c;
            return o.text = this.text.substring(t, r), o.sectionIndex = this.sectionIndex.slice(t, r), o.sections = this.sections, o
          }
          toString() {
            return this.text
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, r) => Math.max(t, this.sections[r].scale)), 0)
          }
          getMaxImageSize(t) {
            let r = 0,
              o = 0;
            for (let c = 0; c < this.length(); c++) {
              const f = this.getSection(c);
              if (f.imageName) {
                const g = t[f.imageName];
                if (!g) continue;
                const y = g.displaySize;
                r = Math.max(r, y[0]), o = Math.max(o, y[1])
              }
            }
            return {
              maxImageWidth: r,
              maxImageHeight: o
            }
          }
          addTextSection(t, r) {
            this.text += t.text, this.sections.push(Zu.forText(t.scale, t.fontStack || r, t.verticalAlign));
            const o = this.sections.length - 1;
            for (let c = 0; c < t.text.length; ++c) this.sectionIndex.push(o)
          }
          addImageSection(t) {
            const r = t.image ? t.image.name : "";
            if (r.length === 0) return void Wt("Can't add FormattedSection with an empty image.");
            const o = this.getNextImageSectionCharCode();
            o ? (this.text += String.fromCharCode(o), this.sections.push(Zu.forImage(r, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Wt("Reached maximum number of images 6401")
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
          }
        }

        function lp(n, t, r, o, c, f, g, y, w, P, M, R, U, G, W) {
          const ne = _c.fromFeature(n, c);
          let se;
          R === b.as.vertical && ne.verticalizePunctuation();
          const {
            processBidirectionalText: ge,
            processStyledBidirectionalText: We
          } = _o;
          if (ge && ne.sections.length === 1) {
            se = [];
            const nt = ge(ne.toString(), Hf(ne, P, f, t, o, G));
            for (const gt of nt) {
              const Vt = new _c;
              Vt.text = gt, Vt.sections = ne.sections;
              for (let pr = 0; pr < gt.length; pr++) Vt.sectionIndex.push(0);
              se.push(Vt)
            }
          } else if (We) {
            se = [];
            const nt = We(ne.text, ne.sectionIndex, Hf(ne, P, f, t, o, G));
            for (const gt of nt) {
              const Vt = new _c;
              Vt.text = gt[0], Vt.sectionIndex = gt[1], Vt.sections = ne.sections, se.push(Vt)
            }
          } else se = (function(nt, gt) {
            const Vt = [],
              pr = nt.text;
            let ir = 0;
            for (const ur of gt) Vt.push(nt.substring(ir, ur)), ir = ur;
            return ir < pr.length && Vt.push(nt.substring(ir, pr.length)), Vt
          })(ne, Hf(ne, P, f, t, o, G));
          const Te = [],
            De = {
              positionedLines: Te,
              text: ne.toString(),
              top: M[1],
              bottom: M[1],
              left: M[0],
              right: M[0],
              writingMode: R,
              iconsInText: !1,
              verticalizable: !1
            };
          return (function(nt, gt, Vt, pr, ir, ur, Kr, lr, hr, Ct, un, yn) {
            let rn = 0,
              Gr = 0,
              Un = 0,
              yi = 0;
            const Bi = lr === "right" ? 1 : lr === "left" ? 0 : .5,
              aa = Hi / yn;
            let $a = 0;
            for (const vi of ir) {
              vi.trim();
              const Wi = vi.getMaxScale(),
                Ji = {
                  positionedGlyphs: [],
                  lineOffset: 0
                };
              nt.positionedLines[$a] = Ji;
              const Qi = Ji.positionedGlyphs;
              let xa = 0;
              if (!vi.length()) {
                Gr += ur, ++$a;
                continue
              }
              const Xa = vx(pr, vi, aa);
              for (let Ia = 0; Ia < vi.length(); Ia++) {
                const Oi = vi.getSection(Ia),
                  Xi = vi.getSectionIndex(Ia),
                  Yi = vi.getCharCode(Ia),
                  Li = yx(hr, un, Yi);
                let hi;
                if (Oi.imageName) {
                  if (nt.iconsInText = !0, Oi.scale = Oi.scale * aa, hi = bx(Oi, Li, Wi, Xa, pr), !hi) continue;
                  xa = Math.max(xa, hi.imageOffset)
                } else if (hi = xx(Oi, Yi, Li, Xa, gt, Vt), !hi) continue;
                const {
                  rect: wo,
                  metrics: bc,
                  baselineOffset: To
                } = hi;
                Qi.push({
                  glyph: Yi,
                  imageName: Oi.imageName,
                  x: rn,
                  y: Gr + To + -17,
                  vertical: Li,
                  scale: Oi.scale,
                  fontStack: Oi.fontStack,
                  sectionIndex: Xi,
                  metrics: bc,
                  rect: wo
                }), Li ? (nt.verticalizable = !0, rn += (Oi.imageName ? bc.advance : Hi) * Oi.scale + Ct) : rn += bc.advance * Oi.scale + Ct
              }
              Qi.length !== 0 && (Un = Math.max(rn - Ct, Un), wx(Qi, 0, Qi.length - 1, Bi)), rn = 0, Ji.lineOffset = Math.max(xa, (Wi - 1) * Hi);
              const $i = ur * Wi + xa;
              Gr += $i, yi = Math.max($i, yi), ++$a
            }
            const {
              horizontalAlign: Ca,
              verticalAlign: Ki
            } = Wf(Kr);
            (function(vi, Wi, Ji, Qi, xa, Xa, $i, Ia, Oi) {
              const Xi = (Wi - Ji) * xa;
              let Yi = 0;
              Yi = Xa !== $i ? -Ia * Qi - -17 : -Qi * Oi * $i + .5 * $i;
              for (const Li of vi)
                for (const hi of Li.positionedGlyphs) hi.x += Xi, hi.y += Yi
            })(nt.positionedLines, Bi, Ca, Ki, Un, yi, ur, Gr, ir.length), nt.top += -Ki * Gr, nt.bottom = nt.top + Gr, nt.left += -Ca * Un, nt.right = nt.left + Un
          })(De, t, r, o, se, g, y, w, R, P, U, W), !(function(nt) {
            for (const gt of nt)
              if (gt.positionedGlyphs.length !== 0) return !1;
            return !0
          })(Te) && De
        }
        const cp = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
          },
          mx = {
            10: !0,
            32: !0,
            38: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
          },
          gx = {
            40: !0
          };

        function q_(n, t, r, o, c, f) {
          if (t.imageName) {
            const g = o[t.imageName];
            return g ? g.displaySize[0] * t.scale * Hi / f + c : 0
          } {
            const g = r[t.fontStack],
              y = g && g[n];
            return y ? y.metrics.advance * t.scale + c : 0
          }
        }

        function V_(n, t, r, o) {
          const c = Math.pow(n - t, 2);
          return o ? n < t ? c / 2 : 2 * c : c + Math.abs(r) * r
        }

        function _x(n, t, r) {
          let o = 0;
          return n === 10 && (o -= 1e4), r && (o += 150), n !== 40 && n !== 65288 || (o += 50), t !== 41 && t !== 65289 || (o += 50), o
        }

        function U_(n, t, r, o, c, f) {
          let g = null,
            y = V_(t, r, c, f);
          for (const w of o) {
            const P = V_(t - w.x, r, c, f) + w.badness;
            P <= y && (g = w, y = P)
          }
          return {
            index: n,
            x: t,
            priorBreak: g,
            badness: y
          }
        }

        function Z_(n) {
          return n ? Z_(n.priorBreak).concat(n.index) : []
        }

        function Hf(n, t, r, o, c, f) {
          if (!n) return [];
          const g = [],
            y = (function(R, U, G, W, ne, se) {
              let ge = 0;
              for (let We = 0; We < R.length(); We++) {
                const Te = R.getSection(We);
                ge += q_(R.getCharCode(We), Te, W, ne, U, se)
              }
              return ge / Math.max(1, Math.ceil(ge / G))
            })(n, t, r, o, c, f),
            w = n.text.indexOf("‚Äã") >= 0;
          let P = 0;
          for (let R = 0; R < n.length(); R++) {
            const U = n.getSection(R),
              G = n.getCharCode(R);
            if (cp[G] || (P += q_(G, U, o, c, t, f)), R < n.length() - 1) {
              const W = !((M = G) < 11904) && (!!Dn["CJK Compatibility Forms"](M) || !!Dn["CJK Compatibility"](M) || !!Dn["CJK Strokes"](M) || !!Dn["CJK Symbols and Punctuation"](M) || !!Dn["Enclosed CJK Letters and Months"](M) || !!Dn["Halfwidth and Fullwidth Forms"](M) || !!Dn["Ideographic Description Characters"](M) || !!Dn["Vertical Forms"](M) || wu.test(String.fromCodePoint(M)));
              (mx[G] || W || U.imageName || R !== n.length() - 2 && gx[n.getCharCode(R + 1)]) && g.push(U_(R + 1, P, y, g, _x(G, n.getCharCode(R + 1), W && w), !1))
            }
          }
          var M;
          return Z_(U_(n.length(), P, y, g, 0, !0))
        }

        function Wf(n) {
          let t = .5,
            r = .5;
          switch (n) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0
          }
          switch (n) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r = 0
          }
          return {
            horizontalAlign: t,
            verticalAlign: r
          }
        }

        function vx(n, t, r) {
          const o = t.getMaxScale() * Hi,
            {
              maxImageWidth: c,
              maxImageHeight: f
            } = t.getMaxImageSize(n),
            g = Math.max(o, f * r);
          return {
            verticalLineContentWidth: Math.max(o, c * r),
            horizontalLineContentHeight: g
          }
        }

        function G_(n) {
          switch (n) {
            case "top":
              return 0;
            case "center":
              return .5;
            default:
              return 1
          }
        }

        function yx(n, t, r) {
          return !(n === b.as.horizontal || !t && !ec(r) || t && (cp[r] || (o = r, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(o)))));
          var o
        }

        function xx(n, t, r, o, c, f) {
          const g = f[n.fontStack],
            y = (function(P, M, R, U) {
              if (P && P.rect) return P;
              const G = M[R.fontStack],
                W = G && G[U];
              return W ? {
                rect: null,
                metrics: W.metrics
              } : null
            })(g && g[t], c, n, t);
          if (y === null) return null;
          let w;
          if (r) w = o.verticalLineContentWidth - n.scale * Hi;
          else {
            const P = G_(n.verticalAlign);
            w = (o.horizontalLineContentHeight - n.scale * Hi) * P
          }
          return {
            rect: y.rect,
            metrics: y.metrics,
            baselineOffset: w
          }
        }

        function bx(n, t, r, o, c) {
          const f = c[n.imageName];
          if (!f) return null;
          const g = f.paddedRect,
            y = f.displaySize,
            w = {
              width: y[0],
              height: y[1],
              left: 1,
              top: -3,
              advance: t ? y[1] : y[0]
            };
          let P;
          if (t) P = o.verticalLineContentWidth - y[1] * n.scale;
          else {
            const M = G_(n.verticalAlign);
            P = (o.horizontalLineContentHeight - y[1] * n.scale) * M
          }
          return {
            rect: g,
            metrics: w,
            baselineOffset: P,
            imageOffset: (t ? y[0] : y[1]) * n.scale - Hi * r
          }
        }

        function wx(n, t, r, o) {
          if (o === 0) return;
          const c = n[r],
            f = (n[r].x + c.metrics.advance * c.scale) * o;
          for (let g = t; g <= r; g++) n[g].x -= f
        }

        function Tx(n, t, r) {
          const {
            horizontalAlign: o,
            verticalAlign: c
          } = Wf(r), f = t[0] - n.displaySize[0] * o, g = t[1] - n.displaySize[1] * c;
          return {
            image: n,
            top: g,
            bottom: g + n.displaySize[1],
            left: f,
            right: f + n.displaySize[0]
          }
        }

        function H_(n) {
          var t, r;
          let o = n.left,
            c = n.top,
            f = n.right - o,
            g = n.bottom - c;
          const y = (t = n.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink",
            w = (r = n.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink",
            P = (n.image.content[2] - n.image.content[0]) / (n.image.content[3] - n.image.content[1]);
          if (w === "proportional") {
            if (y === "stretchOnly" && f / g < P || y === "proportional") {
              const M = Math.ceil(g * P);
              o *= M / f, f = M
            }
          } else if (y === "proportional" && w === "stretchOnly" && P !== 0 && f / g > P) {
            const M = Math.ceil(f / P);
            c *= M / g, g = M
          }
          return {
            x1: o,
            y1: c,
            x2: o + f,
            y2: c + g
          }
        }

        function W_(n, t, r, o, c, f) {
          const g = n.image;
          let y;
          if (g.content) {
            const se = g.content,
              ge = g.pixelRatio || 1;
            y = [se[0] / ge, se[1] / ge, g.displaySize[0] - se[2] / ge, g.displaySize[1] - se[3] / ge]
          }
          const w = t.left * f,
            P = t.right * f;
          let M, R, U, G;
          r === "width" || r === "both" ? (G = c[0] + w - o[3], R = c[0] + P + o[1]) : (G = c[0] + (w + P - g.displaySize[0]) / 2, R = G + g.displaySize[0]);
          const W = t.top * f,
            ne = t.bottom * f;
          return r === "height" || r === "both" ? (M = c[1] + W - o[0], U = c[1] + ne + o[2]) : (M = c[1] + (W + ne - g.displaySize[1]) / 2, U = M + g.displaySize[1]), {
            image: g,
            top: M,
            right: R,
            bottom: U,
            left: G,
            collisionPadding: y
          }
        }
        const us = 128,
          Fs = 32640;

        function $_(n, t) {
          const {
            expression: r
          } = t;
          if (r.kind === "constant") return {
            kind: "constant",
            layoutSize: r.evaluate(new ai(n + 1))
          };
          if (r.kind === "source") return {
            kind: "source"
          };
          {
            const {
              zoomStops: o,
              interpolationType: c
            } = r;
            let f = 0;
            for (; f < o.length && o[f] <= n;) f++;
            f = Math.max(0, f - 1);
            let g = f;
            for (; g < o.length && o[g] < n + 1;) g++;
            g = Math.min(o.length - 1, g);
            const y = o[f],
              w = o[g];
            return r.kind === "composite" ? {
              kind: "composite",
              minZoom: y,
              maxZoom: w,
              interpolationType: c
            } : {
              kind: "camera",
              minZoom: y,
              maxZoom: w,
              minSize: r.evaluate(new ai(y)),
              maxSize: r.evaluate(new ai(w)),
              interpolationType: c
            }
          }
        }

        function $f(n, t, r) {
          let o = "never";
          const c = n.get(t);
          return c ? o = c : n.get(r) && (o = "always"), o
        }
        const Sx = [{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint8",
          offset: 0
        }];

        function up(n, t, r, o, c, f, g, y, w, P, M, R, U) {
          const G = y ? Math.min(Fs, Math.round(y[0])) : 0,
            W = y ? Math.min(Fs, Math.round(y[1])) : 0;
          n.emplaceBack(t, r, Math.round(32 * o), Math.round(32 * c), f, g, (G << 1) + (w ? 1 : 0), W, 16 * P, 16 * M, 256 * R, 256 * U)
        }

        function Xf(n, t, r) {
          n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r)
        }

        function Px(n) {
          for (const t of n.sections)
            if (Sf(t.text)) return !0;
          return !1
        }
        class Yf {
          constructor(t) {
            this.layoutVertexArray = new rt, this.indexArray = new kt, this.programConfigurations = t, this.segments = new An, this.dynamicLayoutVertexArray = new at, this.opacityVertexArray = new ct, this.hasVisibleVertices = !1, this.placedSymbolArray = new k
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
          }
          upload(t, r, o, c) {
            this.isEmpty() || (o && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, J1.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Q1.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Sx, !0), this.opacityVertexBuffer.itemSize = 1), (o || c) && this.programConfigurations.upload(t))
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy())
          }
        }
        Cr("SymbolBuffers", Yf);
        class Kf {
          constructor(t, r, o) {
            this.layoutVertexArray = new t, this.layoutAttributes = r, this.indexArray = new o, this.segments = new An, this.collisionVertexArray = new rr
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, ex.members, !0)
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy())
          }
        }
        Cr("CollisionBuffers", Kf);
        class vc {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = Lt(globalThis) ? Math.min(t.overscaling, 128) : t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((g => g.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const r = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = $_(this.zoom, r["text-size"]), this.iconSizeData = $_(this.zoom, r["icon-size"]);
            const o = this.layers[0].layout,
              c = o.get("symbol-sort-key"),
              f = o.get("symbol-z-order");
            this.canOverlap = $f(o, "text-overlap", "text-allow-overlap") !== "never" || $f(o, "icon-overlap", "icon-allow-overlap") !== "never" || o.get("text-ignore-placement") || o.get("icon-ignore-placement"), this.sortFeaturesByKey = f !== "viewport-y" && !c.isConstant(), this.sortFeaturesByY = (f === "viewport-y" || f === "auto" && !this.sortFeaturesByKey) && this.canOverlap, o.get("symbol-placement") === "point" && (this.writingModes = o.get("text-writing-mode").map((g => b.as[g]))), this.stateDependentLayerIds = this.layers.filter((g => g.isStateDependent())).map((g => g.id)), this.sourceID = t.sourceID
          }
          createArrays() {
            this.text = new Yf(new ls(this.layers, this.zoom, (t => /^text/.test(t)))), this.icon = new Yf(new ls(this.layers, this.zoom, (t => /^icon/.test(t)))), this.glyphOffsetArray = new B, this.lineVertexArray = new H, this.symbolInstances = new V, this.textAnchorOffsets = new le
          }
          calculateGlyphDependencies(t, r, o, c, f) {
            for (let g = 0; g < t.length; g++)
              if (r[t.charCodeAt(g)] = !0, (o || c) && f) {
                const y = Uu[t.charAt(g)];
                y && (r[y.charCodeAt(0)] = !0)
              }
          }
          populate(t, r, o) {
            const c = this.layers[0],
              f = c.layout,
              g = f.get("text-font"),
              y = f.get("text-field"),
              w = f.get("icon-image"),
              P = (y.value.kind !== "constant" || y.value.value instanceof In && !y.value.value.isEmpty() || y.value.value.toString().length > 0) && (g.value.kind !== "constant" || g.value.value.length > 0),
              M = w.value.kind !== "constant" || !!w.value.value || Object.keys(w.parameters).length > 0,
              R = f.get("symbol-sort-key");
            if (this.features = [], !P && !M) return;
            const U = r.iconDependencies,
              G = r.glyphDependencies,
              W = r.availableImages,
              ne = new ai(this.zoom);
            for (const {
                feature: se,
                id: ge,
                index: We,
                sourceLayerIndex: Te
              }
              of t) {
              const De = c._featureFilter.needGeometry,
                nt = Fo(se, De);
              if (!c._featureFilter.filter(ne, nt, o)) continue;
              let gt, Vt;
              if (De || (nt.geometry = bo(se)), P) {
                const ir = c.getValueAndResolveTokens("text-field", nt, o, W),
                  ur = In.factory(ir),
                  Kr = this.hasRTLText = this.hasRTLText || Px(ur);
                (!Kr || _o.getRTLTextPluginStatus() === "unavailable" || Kr && _o.isParsed()) && (gt = rx(ur, c, nt))
              }
              if (M) {
                const ir = c.getValueAndResolveTokens("icon-image", nt, o, W);
                Vt = ir instanceof bn ? ir : bn.fromString(ir)
              }
              if (!gt && !Vt) continue;
              const pr = this.sortFeaturesByKey ? R.evaluate(nt, {}, o) : void 0;
              if (this.features.push({
                  id: ge,
                  text: gt,
                  icon: Vt,
                  index: We,
                  sourceLayerIndex: Te,
                  geometry: nt.geometry,
                  properties: se.properties,
                  type: mc.types[se.type],
                  sortKey: pr
                }), Vt && (U[Vt.name] = !0), gt) {
                const ir = g.evaluate(nt, {}, o).join(","),
                  ur = f.get("text-rotation-alignment") !== "viewport" && f.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(b.as.vertical) >= 0;
                for (const Kr of gt.sections)
                  if (Kr.image) U[Kr.image.name] = !0;
                  else {
                    const lr = xu(gt.toString()),
                      hr = Kr.fontStack || ir,
                      Ct = G[hr] = G[hr] || {};
                    this.calculateGlyphDependencies(Kr.text, Ct, ur, this.allowVerticalPlacement, lr)
                  }
              }
            }
            f.get("symbol-placement") === "line" && (this.features = (function(se) {
              const ge = {},
                We = {},
                Te = [];
              let De = 0;

              function nt(ir) {
                Te.push(se[ir]), De++
              }

              function gt(ir, ur, Kr) {
                const lr = We[ir];
                return delete We[ir], We[ur] = lr, Te[lr].geometry[0].pop(), Te[lr].geometry[0] = Te[lr].geometry[0].concat(Kr[0]), lr
              }

              function Vt(ir, ur, Kr) {
                const lr = ge[ur];
                return delete ge[ur], ge[ir] = lr, Te[lr].geometry[0].shift(), Te[lr].geometry[0] = Kr[0].concat(Te[lr].geometry[0]), lr
              }

              function pr(ir, ur, Kr) {
                const lr = Kr ? ur[0][ur[0].length - 1] : ur[0][0];
                return `${ir}:${lr.x}:${lr.y}`
              }
              for (let ir = 0; ir < se.length; ir++) {
                const ur = se[ir],
                  Kr = ur.geometry,
                  lr = ur.text ? ur.text.toString() : null;
                if (!lr) {
                  nt(ir);
                  continue
                }
                const hr = pr(lr, Kr),
                  Ct = pr(lr, Kr, !0);
                if (hr in We && Ct in ge && We[hr] !== ge[Ct]) {
                  const un = Vt(hr, Ct, Kr),
                    yn = gt(hr, Ct, Te[un].geometry);
                  delete ge[hr], delete We[Ct], We[pr(lr, Te[yn].geometry, !0)] = yn, Te[un].geometry = null
                } else hr in We ? gt(hr, Ct, Kr) : Ct in ge ? Vt(hr, Ct, Kr) : (nt(ir), ge[hr] = De - 1, We[Ct] = De - 1)
              }
              return Te.filter((ir => ir.geometry))
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((se, ge) => se.sortKey - ge.sortKey))
          }
          update(t, r, o) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, r, this.layers, {
              imagePositions: o
            }), this.icon.programConfigurations.updatePaintArrays(t, r, this.layers, {
              imagePositions: o
            }))
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
          }
          addToLineVertexArray(t, r) {
            const o = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let c = t.dist(r[t.segment + 1]),
                f = t.dist(r[t.segment]);
              const g = {};
              for (let y = t.segment + 1; y < r.length; y++) g[y] = {
                x: r[y].x,
                y: r[y].y,
                tileUnitDistanceFromAnchor: c
              }, y < r.length - 1 && (c += r[y + 1].dist(r[y]));
              for (let y = t.segment || 0; y >= 0; y--) g[y] = {
                x: r[y].x,
                y: r[y].y,
                tileUnitDistanceFromAnchor: f
              }, y > 0 && (f += r[y - 1].dist(r[y]));
              for (let y = 0; y < r.length; y++) {
                const w = g[y];
                this.lineVertexArray.emplaceBack(w.x, w.y, w.tileUnitDistanceFromAnchor)
              }
            }
            return {
              lineStartIndex: o,
              lineLength: this.lineVertexArray.length - o
            }
          }
          addSymbols(t, r, o, c, f, g, y, w, P, M, R, U) {
            const G = t.indexArray,
              W = t.layoutVertexArray,
              ne = t.segments.prepareSegment(4 * r.length, W, G, this.canOverlap ? g.sortKey : void 0),
              se = this.glyphOffsetArray.length,
              ge = ne.vertexLength,
              We = this.allowVerticalPlacement && y === b.as.vertical ? Math.PI / 2 : 0,
              Te = g.text && g.text.sections;
            for (let De = 0; De < r.length; De++) {
              const {
                tl: nt,
                tr: gt,
                bl: Vt,
                br: pr,
                tex: ir,
                pixelOffsetTL: ur,
                pixelOffsetBR: Kr,
                minFontScaleX: lr,
                minFontScaleY: hr,
                glyphOffset: Ct,
                isSDF: un,
                sectionIndex: yn
              } = r[De], rn = ne.vertexLength, Gr = Ct[1];
              up(W, w.x, w.y, nt.x, Gr + nt.y, ir.x, ir.y, o, un, ur.x, ur.y, lr, hr), up(W, w.x, w.y, gt.x, Gr + gt.y, ir.x + ir.w, ir.y, o, un, Kr.x, ur.y, lr, hr), up(W, w.x, w.y, Vt.x, Gr + Vt.y, ir.x, ir.y + ir.h, o, un, ur.x, Kr.y, lr, hr), up(W, w.x, w.y, pr.x, Gr + pr.y, ir.x + ir.w, ir.y + ir.h, o, un, Kr.x, Kr.y, lr, hr), Xf(t.dynamicLayoutVertexArray, w, We), G.emplaceBack(rn, rn + 2, rn + 1), G.emplaceBack(rn + 1, rn + 2, rn + 3), ne.vertexLength += 4, ne.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Ct[0]), De !== r.length - 1 && yn === r[De + 1].sectionIndex || t.programConfigurations.populatePaintArrays(W.length, g, g.index, {
                imagePositions: {},
                canonical: U,
                formattedSection: Te && Te[yn]
              })
            }
            t.placedSymbolArray.emplaceBack(w.x, w.y, se, this.glyphOffsetArray.length - se, ge, P, M, w.segment, o ? o[0] : 0, o ? o[1] : 0, c[0], c[1], y, 0, !1, 0, R)
          }
          _addCollisionDebugVertex(t, r, o, c, f, g) {
            return r.emplaceBack(0, 0), t.emplaceBack(o.x, o.y, c, f, Math.round(g.x), Math.round(g.y))
          }
          addCollisionDebugVertices(t, r, o, c, f, g, y) {
            const w = f.segments.prepareSegment(4, f.layoutVertexArray, f.indexArray),
              P = w.vertexLength,
              M = f.layoutVertexArray,
              R = f.collisionVertexArray,
              U = y.anchorX,
              G = y.anchorY;
            this._addCollisionDebugVertex(M, R, g, U, G, new F(t, r)), this._addCollisionDebugVertex(M, R, g, U, G, new F(o, r)), this._addCollisionDebugVertex(M, R, g, U, G, new F(o, c)), this._addCollisionDebugVertex(M, R, g, U, G, new F(t, c)), w.vertexLength += 4;
            const W = f.indexArray;
            W.emplaceBack(P, P + 1), W.emplaceBack(P + 1, P + 2), W.emplaceBack(P + 2, P + 3), W.emplaceBack(P + 3, P), w.primitiveLength += 4
          }
          addDebugCollisionBoxes(t, r, o, c) {
            for (let f = t; f < r; f++) {
              const g = this.collisionBoxArray.get(f);
              this.addCollisionDebugVertices(g.x1, g.y1, g.x2, g.y2, c ? this.textCollisionBox : this.iconCollisionBox, g.anchorPoint, o)
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Kf(er, R_.members, Br), this.iconCollisionBox = new Kf(er, R_.members, Br);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const r = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, !1), this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, !1)
            }
          }
          _deserializeCollisionBoxesForSymbol(t, r, o, c, f, g, y, w, P) {
            const M = {};
            for (let R = r; R < o; R++) {
              const U = t.get(R);
              M.textBox = {
                x1: U.x1,
                y1: U.y1,
                x2: U.x2,
                y2: U.y2,
                anchorPointX: U.anchorPointX,
                anchorPointY: U.anchorPointY
              }, M.textFeatureIndex = U.featureIndex;
              break
            }
            for (let R = c; R < f; R++) {
              const U = t.get(R);
              M.verticalTextBox = {
                x1: U.x1,
                y1: U.y1,
                x2: U.x2,
                y2: U.y2,
                anchorPointX: U.anchorPointX,
                anchorPointY: U.anchorPointY
              }, M.verticalTextFeatureIndex = U.featureIndex;
              break
            }
            for (let R = g; R < y; R++) {
              const U = t.get(R);
              M.iconBox = {
                x1: U.x1,
                y1: U.y1,
                x2: U.x2,
                y2: U.y2,
                anchorPointX: U.anchorPointX,
                anchorPointY: U.anchorPointY
              }, M.iconFeatureIndex = U.featureIndex;
              break
            }
            for (let R = w; R < P; R++) {
              const U = t.get(R);
              M.verticalIconBox = {
                x1: U.x1,
                y1: U.y1,
                x2: U.x2,
                y2: U.y2,
                anchorPointX: U.anchorPointX,
                anchorPointY: U.anchorPointY
              }, M.verticalIconFeatureIndex = U.featureIndex;
              break
            }
            return M
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let r = 0; r < this.symbolInstances.length; r++) {
              const o = this.symbolInstances.get(r);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, o.textBoxStartIndex, o.textBoxEndIndex, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o.iconBoxStartIndex, o.iconBoxEndIndex, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex))
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0
          }
          hasIconData() {
            return this.icon.segments.get().length > 0
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
          }
          addIndicesForPlacedSymbol(t, r) {
            const o = t.placedSymbolArray.get(r),
              c = o.vertexStartIndex + 4 * o.numGlyphs;
            for (let f = o.vertexStartIndex; f < c; f += 4) t.indexArray.emplaceBack(f, f + 2, f + 1), t.indexArray.emplaceBack(f + 1, f + 2, f + 3)
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const r = Math.sin(t),
              o = Math.cos(t),
              c = [],
              f = [],
              g = [];
            for (let y = 0; y < this.symbolInstances.length; ++y) {
              g.push(y);
              const w = this.symbolInstances.get(y);
              c.push(0 | Math.round(r * w.anchorX + o * w.anchorY)), f.push(w.featureIndex)
            }
            return g.sort(((y, w) => c[y] - c[w] || f[w] - f[y])), g
          }
          addToSortKeyRanges(t, r) {
            const o = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            o && o.sortKey === r ? o.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
              sortKey: r,
              symbolInstanceStart: t,
              symbolInstanceEnd: t + 1
            })
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const r of this.symbolInstanceIndexes) {
                const o = this.symbolInstances.get(r);
                this.featureSortOrder.push(o.featureIndex), [o.rightJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.leftJustifiedTextSymbolIndex].forEach(((c, f, g) => {
                  c >= 0 && g.indexOf(c) === f && this.addIndicesForPlacedSymbol(this.text, c)
                })), o.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, o.verticalPlacedTextSymbolIndex), o.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, o.placedIconSymbolIndex), o.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, o.verticalPlacedIconSymbolIndex)
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
            }
          }
        }
        let X_, Y_;
        Cr("SymbolBucket", vc, {
          omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }), vc.MAX_GLYPHS = 65535, vc.addDynamicAttributes = Xf;
        var Jf = {
          get paint() {
            return Y_ = Y_ || new na({
              "icon-opacity": new an(Q.paint_symbol["icon-opacity"]),
              "icon-color": new an(Q.paint_symbol["icon-color"]),
              "icon-halo-color": new an(Q.paint_symbol["icon-halo-color"]),
              "icon-halo-width": new an(Q.paint_symbol["icon-halo-width"]),
              "icon-halo-blur": new an(Q.paint_symbol["icon-halo-blur"]),
              "icon-translate": new Hr(Q.paint_symbol["icon-translate"]),
              "icon-translate-anchor": new Hr(Q.paint_symbol["icon-translate-anchor"]),
              "text-opacity": new an(Q.paint_symbol["text-opacity"]),
              "text-color": new an(Q.paint_symbol["text-color"], {
                runtimeType: Tt,
                getOverride: n => n.textColor,
                hasOverride: n => !!n.textColor
              }),
              "text-halo-color": new an(Q.paint_symbol["text-halo-color"]),
              "text-halo-width": new an(Q.paint_symbol["text-halo-width"]),
              "text-halo-blur": new an(Q.paint_symbol["text-halo-blur"]),
              "text-translate": new Hr(Q.paint_symbol["text-translate"]),
              "text-translate-anchor": new Hr(Q.paint_symbol["text-translate-anchor"])
            })
          },
          get layout() {
            return X_ = X_ || new na({
              "symbol-placement": new Hr(Q.layout_symbol["symbol-placement"]),
              "symbol-spacing": new Hr(Q.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new Hr(Q.layout_symbol["symbol-avoid-edges"]),
              "symbol-sort-key": new an(Q.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new Hr(Q.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new Hr(Q.layout_symbol["icon-allow-overlap"]),
              "icon-overlap": new Hr(Q.layout_symbol["icon-overlap"]),
              "icon-ignore-placement": new Hr(Q.layout_symbol["icon-ignore-placement"]),
              "icon-optional": new Hr(Q.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new Hr(Q.layout_symbol["icon-rotation-alignment"]),
              "icon-size": new an(Q.layout_symbol["icon-size"]),
              "icon-text-fit": new Hr(Q.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new Hr(Q.layout_symbol["icon-text-fit-padding"]),
              "icon-image": new an(Q.layout_symbol["icon-image"]),
              "icon-rotate": new an(Q.layout_symbol["icon-rotate"]),
              "icon-padding": new an(Q.layout_symbol["icon-padding"]),
              "icon-keep-upright": new Hr(Q.layout_symbol["icon-keep-upright"]),
              "icon-offset": new an(Q.layout_symbol["icon-offset"]),
              "icon-anchor": new an(Q.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new Hr(Q.layout_symbol["icon-pitch-alignment"]),
              "text-pitch-alignment": new Hr(Q.layout_symbol["text-pitch-alignment"]),
              "text-rotation-alignment": new Hr(Q.layout_symbol["text-rotation-alignment"]),
              "text-field": new an(Q.layout_symbol["text-field"]),
              "text-font": new an(Q.layout_symbol["text-font"]),
              "text-size": new an(Q.layout_symbol["text-size"]),
              "text-max-width": new an(Q.layout_symbol["text-max-width"]),
              "text-line-height": new Hr(Q.layout_symbol["text-line-height"]),
              "text-letter-spacing": new an(Q.layout_symbol["text-letter-spacing"]),
              "text-justify": new an(Q.layout_symbol["text-justify"]),
              "text-radial-offset": new an(Q.layout_symbol["text-radial-offset"]),
              "text-variable-anchor": new Hr(Q.layout_symbol["text-variable-anchor"]),
              "text-variable-anchor-offset": new an(Q.layout_symbol["text-variable-anchor-offset"]),
              "text-anchor": new an(Q.layout_symbol["text-anchor"]),
              "text-max-angle": new Hr(Q.layout_symbol["text-max-angle"]),
              "text-writing-mode": new Hr(Q.layout_symbol["text-writing-mode"]),
              "text-rotate": new an(Q.layout_symbol["text-rotate"]),
              "text-padding": new Hr(Q.layout_symbol["text-padding"]),
              "text-keep-upright": new Hr(Q.layout_symbol["text-keep-upright"]),
              "text-transform": new an(Q.layout_symbol["text-transform"]),
              "text-offset": new an(Q.layout_symbol["text-offset"]),
              "text-allow-overlap": new Hr(Q.layout_symbol["text-allow-overlap"]),
              "text-overlap": new Hr(Q.layout_symbol["text-overlap"]),
              "text-ignore-placement": new Hr(Q.layout_symbol["text-ignore-placement"]),
              "text-optional": new Hr(Q.layout_symbol["text-optional"])
            })
          }
        };
        class K_ {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : Dr, this.defaultValue = t
          }
          evaluate(t) {
            if (t.formattedSection) {
              const r = this.defaultValue.property.overrides;
              if (r && r.hasOverride(t.formattedSection)) return r.getOverride(t.formattedSection)
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
          }
          outputDefined() {
            return !1
          }
          serialize() {
            return null
          }
        }
        Cr("FormatSectionOverride", K_, {
          omit: ["defaultValue"]
        });
        class hp extends Ga {
          constructor(t, r) {
            super(t, Jf, r)
          }
          recalculate(t, r) {
            if (super.recalculate(t, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const o = this.layout.get("text-writing-mode");
              if (o) {
                const c = [];
                for (const f of o) c.indexOf(f) < 0 && c.push(f);
                this.layout._values["text-writing-mode"] = c
              } else this.layout._values["text-writing-mode"] = ["horizontal"]
            }
            this._setPaintOverrides()
          }
          getValueAndResolveTokens(t, r, o, c) {
            const f = this.layout.get(t).evaluate(r, {}, o, c),
              g = this._unevaluatedLayout._values[t];
            return g.isDataDriven() || Zl(g.value) || !f ? f : (function(y, w) {
              return w.replace(/{([^{}]+)}/g, ((P, M) => y && M in y ? String(y[M]) : ""))
            })(r.properties, f)
          }
          createBucket(t) {
            return new vc(t)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex")
          }
          _setPaintOverrides() {
            for (const t of Jf.paint.overridableProperties) {
              if (!hp.hasPaintOverride(this.layout, t)) continue;
              const r = this.paint.get(t),
                o = new K_(r),
                c = new ou(o, r.property.specification);
              let f = null;
              f = r.value.kind === "constant" || r.value.kind === "source" ? new tl("source", c) : new su("composite", c, r.value.zoomStops), this.paint._values[t] = new Za(r.property, f, r.parameters)
            }
          }
          _handleOverridablePaintPropertyUpdate(t, r, o) {
            return !(!this.layout || r.isDataDriven() || o.isDataDriven()) && hp.hasPaintOverride(this.layout, t)
          }
          static hasPaintOverride(t, r) {
            const o = t.get("text-field"),
              c = Jf.paint.properties[r];
            let f = !1;
            const g = y => {
              for (const w of y)
                if (c.overrides && c.overrides.hasOverride(w)) return void(f = !0)
            };
            if (o.value.kind === "constant" && o.value.value instanceof In) g(o.value.value.sections);
            else if (o.value.kind === "source" || o.value.kind === "composite") {
              const y = P => {
                  f || (P instanceof ta && Vn(P.value) === Xr ? g(P.value.sections) : P instanceof zl ? g(P.sections) : P.eachChild(y))
                },
                w = o.value;
              w._styleExpression && y(w._styleExpression.expression)
            }
            return f
          }
        }
        let J_;
        var Cx = {
          get paint() {
            return J_ = J_ || new na({
              "background-color": new Hr(Q.paint_background["background-color"]),
              "background-pattern": new $d(Q.paint_background["background-pattern"]),
              "background-opacity": new Hr(Q.paint_background["background-opacity"])
            })
          }
        };
        class Ix extends Ga {
          constructor(t, r) {
            super(t, Cx, r)
          }
        }
        class Mx extends Ga {
          constructor(t, r) {
            super(t, {}, r), this.onAdd = o => {
              this.implementation.onAdd && this.implementation.onAdd(o, o.painter.context.gl)
            }, this.onRemove = o => {
              this.implementation.onRemove && this.implementation.onRemove(o, o.painter.context.gl)
            }, this.implementation = t
          }
          is3D() {
            return this.implementation.renderingMode === "3d"
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0
          }
          recalculate() {}
          updateTransitions() {}
          hasTransition() {
            return !1
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized")
          }
        }
        class Ax {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle()
            })
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle()
            }), 0))
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {}
          }
        }
        const kx = {
            once: !0
          },
          Qf = 63710088e-1;
        class Bs {
          constructor(t, r) {
            if (isNaN(t) || isNaN(r)) throw new Error(`Invalid LngLat object: (${t}, ${r})`);
            if (this.lng = +t, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
          }
          wrap() {
            return new Bs(tt(this.lng, -180, 180), this.lat)
          }
          toArray() {
            return [this.lng, this.lat]
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`
          }
          distanceTo(t) {
            const r = Math.PI / 180,
              o = this.lat * r,
              c = t.lat * r,
              f = Math.sin(o) * Math.sin(c) + Math.cos(o) * Math.cos(c) * Math.cos((t.lng - this.lng) * r);
            return Qf * Math.acos(Math.min(f, 1))
          }
          static convert(t) {
            if (t instanceof Bs) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new Bs(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new Bs(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
          }
        }
        const Q_ = 2 * Math.PI * Qf;

        function ev(n) {
          return Q_ * Math.cos(n * Math.PI / 180)
        }

        function tv(n) {
          return (180 + n) / 360
        }

        function rv(n) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n * Math.PI / 360))) / 360
        }

        function nv(n, t) {
          return n / ev(t)
        }

        function iv(n) {
          return 360 * n - 180
        }

        function dp(n) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90
        }

        function av(n, t) {
          return n * ev(dp(t))
        }
        class Gu {
          constructor(t, r, o = 0) {
            this.x = +t, this.y = +r, this.z = +o
          }
          static fromLngLat(t, r = 0) {
            const o = Bs.convert(t);
            return new Gu(tv(o.lng), rv(o.lat), nv(r, o.lat))
          }
          toLngLat() {
            return new Bs(iv(this.x), dp(this.y))
          }
          toAltitude() {
            return av(this.z, this.y)
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Q_ * (t = dp(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t
          }
        }

        function ov(n, t, r) {
          var o = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
          return [n * o - 2 * Math.PI * 6378137 / 2, t * o - 2 * Math.PI * 6378137 / 2]
        }
        class em {
          constructor(t, r, o) {
            if (!(function(c, f, g) {
                return !(c < 0 || c > 25 || g < 0 || g >= Math.pow(2, c) || f < 0 || f >= Math.pow(2, c))
              })(t, r, o)) throw new Error(`x=${r}, y=${o}, z=${t} outside of bounds. 0<=x<${Math.pow(2,t)}, 0<=y<${Math.pow(2,t)} 0<=z<=25 `);
            this.z = t, this.x = r, this.y = o, this.key = yc(0, t, t, r, o)
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y
          }
          url(t, r, o) {
            const c = (g = this.y, y = this.z, w = ov(256 * (f = this.x), 256 * (g = Math.pow(2, y) - g - 1), y), P = ov(256 * (f + 1), 256 * (g + 1), y), w[0] + "," + w[1] + "," + P[0] + "," + P[1]);
            var f, g, y, w, P;
            const M = (function(R, U, G) {
              let W, ne = "";
              for (let se = R; se > 0; se--) W = 1 << se - 1, ne += (U & W ? 1 : 0) + (G & W ? 2 : 0);
              return ne
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(o === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, M).replace(/{bbox-epsg-3857}/g, c)
          }
          isChildOf(t) {
            const r = this.z - t.z;
            return r > 0 && t.x === this.x >> r && t.y === this.y >> r
          }
          getTilePoint(t) {
            const r = Math.pow(2, this.z);
            return new F((t.x * r - this.x) * Je, (t.y * r - this.y) * Je)
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`
          }
        }
        class sv {
          constructor(t, r) {
            this.wrap = t, this.canonical = r, this.key = yc(t, r.z, r.z, r.x, r.y)
          }
        }
        class Wa {
          constructor(t, r, o, c, f) {
            if (this.terrainRttPosMatrix32f = null, t < o) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${o}`);
            this.overscaledZ = t, this.wrap = r, this.canonical = new em(o, +c, +f), this.key = yc(r, t, o, c, f)
          }
          clone() {
            return new Wa(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const r = this.canonical.z - t;
            return t > this.canonical.z ? new Wa(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Wa(t, this.wrap, t, this.canonical.x >> r, this.canonical.y >> r)
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z
          }
          calculateScaledKey(t, r) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const o = this.canonical.z - t;
            return t > this.canonical.z ? yc(this.wrap * +r, t, this.canonical.z, this.canonical.x, this.canonical.y) : yc(this.wrap * +r, t, t, this.canonical.x >> o, this.canonical.y >> o)
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap || this.overscaledZ - t.overscaledZ <= 0) return !1;
            if (t.overscaledZ === 0) return this.overscaledZ > 0;
            const r = this.canonical.z - t.canonical.z;
            return !(r < 0) && t.canonical.x === this.canonical.x >> r && t.canonical.y === this.canonical.y >> r
          }
          children(t) {
            if (this.overscaledZ >= t) return [new Wa(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const r = this.canonical.z + 1,
              o = 2 * this.canonical.x,
              c = 2 * this.canonical.y;
            return [new Wa(r, this.wrap, r, o, c), new Wa(r, this.wrap, r, o + 1, c), new Wa(r, this.wrap, r, o, c + 1), new Wa(r, this.wrap, r, o + 1, c + 1)]
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
          }
          wrapped() {
            return new Wa(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          unwrapTo(t) {
            return new Wa(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z)
          }
          toUnwrapped() {
            return new sv(this.wrap, this.canonical)
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new Gu(t.x - this.wrap, t.y))
          }
        }

        function yc(n, t, r, o, c) {
          (n *= 2) < 0 && (n = -1 * n - 1);
          const f = 1 << r;
          return (f * f * n + f * c + o).toString(36) + r.toString(36) + t.toString(36)
        }

        function Hu(n, t) {
          return t ? n.properties[t] : n.id
        }
        Cr("CanonicalTileID", em), Cr("OverscaledTileID", Wa, {
          omit: ["terrainRttPosMatrix32f"]
        });
        class ml {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this
          }
          shrinkBy(t) {
            return this.expandBy(-t)
          }
          map(t) {
            const r = new ml;
            return r.extend(t(new F(this.minX, this.minY))), r.extend(t(new F(this.maxX, this.minY))), r.extend(t(new F(this.minX, this.maxY))), r.extend(t(new F(this.maxX, this.maxY))), r
          }
          static fromPoints(t) {
            const r = new ml;
            for (const o of t) r.extend(o);
            return r
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY
          }
          empty() {
            return this.minX > this.maxX
          }
          width() {
            return this.maxX - this.minX
          }
          height() {
            return this.maxY - this.minY
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY
          }
        }
        class lv {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let r = 0; r < t.length; r++) {
              const o = t[r];
              this._stringToNumber[o] = r, this._numberToString[r] = o
            }
          }
          encode(t) {
            return this._stringToNumber[t]
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t]
          }
        }
        class cv {
          constructor(t, r, o, c, f) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = r, t._x = o, t._y = c, this.properties = t.properties, this.id = f
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry
          }
          set geometry(t) {
            this._geometry = t
          }
          toJSON() {
            const t = {
              geometry: this.geometry
            };
            for (const r in this) r !== "_geometry" && r !== "_vectorTileFeature" && (t[r] = this[r]);
            return t
          }
        }
        class uv {
          constructor(t, r) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new es(Je, 16, 0), this.grid3D = new es(Je, 16, 0), this.featureIndexArray = new de, this.promoteId = r
          }
          insert(t, r, o, c, f, g) {
            const y = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(o, c, f);
            const w = g ? this.grid3D : this.grid;
            for (let P = 0; P < r.length; P++) {
              const M = r[P],
                R = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let U = 0; U < M.length; U++) {
                const G = M[U];
                R[0] = Math.min(R[0], G.x), R[1] = Math.min(R[1], G.y), R[2] = Math.max(R[2], G.x), R[3] = Math.max(R[3], G.y)
              }
              R[0] < Je && R[1] < Je && R[2] >= 0 && R[3] >= 0 && w.insert(y, R[0], R[1], R[2], R[3])
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new C_(new Zf(this.rawTileData)).layers, this.sourceLayerCoder = new lv(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers
          }
          query(t, r, o, c) {
            this.loadVTLayers();
            const f = t.params,
              g = Je / t.tileSize / t.scale,
              y = rl(f.filter, f.globalState),
              w = t.queryGeometry,
              P = t.queryPadding * g,
              M = ml.fromPoints(w),
              R = this.grid.query(M.minX - P, M.minY - P, M.maxX + P, M.maxY + P),
              U = ml.fromPoints(t.cameraQueryGeometry).expandBy(P),
              G = this.grid3D.query(U.minX, U.minY, U.maxX, U.maxY, ((se, ge, We, Te) => (function(De, nt, gt, Vt, pr) {
                for (const ur of De)
                  if (nt <= ur.x && gt <= ur.y && Vt >= ur.x && pr >= ur.y) return !0;
                const ir = [new F(nt, gt), new F(nt, pr), new F(Vt, pr), new F(Vt, gt)];
                if (De.length > 2) {
                  for (const ur of ir)
                    if (uc(De, ur)) return !0
                }
                for (let ur = 0; ur < De.length - 1; ur++)
                  if (o1(De[ur], De[ur + 1], ir)) return !0;
                return !1
              })(t.cameraQueryGeometry, se - P, ge - P, We + P, Te + P)));
            for (const se of G) R.push(se);
            R.sort(Ex);
            const W = {};
            let ne;
            for (let se = 0; se < R.length; se++) {
              const ge = R[se];
              if (ge === ne) continue;
              ne = ge;
              const We = this.featureIndexArray.get(ge);
              let Te = null;
              this.loadMatchingFeature(W, We.bucketIndex, We.sourceLayerIndex, We.featureIndex, y, f.layers, f.availableImages, r, o, c, ((De, nt, gt) => (Te || (Te = bo(De)), nt.queryIntersectsFeature({
                queryGeometry: w,
                feature: De,
                featureState: gt,
                geometry: Te,
                zoom: this.z,
                transform: t.transform,
                pixelsToTileUnits: g,
                pixelPosMatrix: t.pixelPosMatrix,
                unwrappedTileID: this.tileID.toUnwrapped(),
                getElevation: t.getElevation
              }))))
            }
            return W
          }
          loadMatchingFeature(t, r, o, c, f, g, y, w, P, M, R) {
            const U = this.bucketLayerIDs[r];
            if (g && !U.some((se => g.has(se)))) return;
            const G = this.sourceLayerCoder.decode(o),
              W = this.vtLayers[G].feature(c);
            if (f.needGeometry) {
              const se = Fo(W, !0);
              if (!f.filter(new ai(this.tileID.overscaledZ), se, this.tileID.canonical)) return
            } else if (!f.filter(new ai(this.tileID.overscaledZ), W)) return;
            const ne = this.getId(W, G);
            for (let se = 0; se < U.length; se++) {
              const ge = U[se];
              if (g && !g.has(ge)) continue;
              const We = w[ge];
              if (!We) continue;
              let Te = {};
              ne && M && (Te = M.getState(We.sourceLayer || "_geojsonTileLayer", ne));
              const De = ht({}, P[ge]);
              De.paint = hv(De.paint, We.paint, W, Te, y), De.layout = hv(De.layout, We.layout, W, Te, y);
              const nt = !R || R(W, We, Te);
              if (!nt) continue;
              const gt = new cv(W, this.z, this.x, this.y, ne);
              gt.layer = De;
              let Vt = t[ge];
              Vt === void 0 && (Vt = t[ge] = []), Vt.push({
                featureIndex: c,
                feature: gt,
                intersectionZ: nt
              })
            }
          }
          lookupSymbolFeatures(t, r, o, c, f, g, y, w) {
            const P = {};
            this.loadVTLayers();
            const M = rl(f.filterSpec, f.globalState);
            for (const R of t) this.loadMatchingFeature(P, o, c, R, M, g, y, w, r);
            return P
          }
          hasLayer(t) {
            for (const r of this.bucketLayerIDs)
              for (const o of r)
                if (t === o) return !0;
            return !1
          }
          getId(t, r) {
            var o;
            let c = t.id;
            return this.promoteId && (c = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]], typeof c == "boolean" && (c = Number(c)), c === void 0 && (!((o = t.properties) === null || o === void 0) && o.cluster) && this.promoteId && (c = Number(t.properties.cluster_id))), c
          }
        }

        function hv(n, t, r, o, c) {
          return Bt(n, ((f, g) => {
            const y = t instanceof ts ? t.get(g) : null;
            return y && y.evaluate ? y.evaluate(r, o, c) : y
          }))
        }

        function Ex(n, t) {
          return t - n
        }

        function dv(n, t, r, o, c) {
          const f = [];
          for (let g = 0; g < n.length; g++) {
            const y = n[g];
            let w;
            for (let P = 0; P < y.length - 1; P++) {
              let M = y[P],
                R = y[P + 1];
              M.x < t && R.x < t || (M.x < t ? M = new F(t, M.y + (t - M.x) / (R.x - M.x) * (R.y - M.y))._round() : R.x < t && (R = new F(t, M.y + (t - M.x) / (R.x - M.x) * (R.y - M.y))._round()), M.y < r && R.y < r || (M.y < r ? M = new F(M.x + (r - M.y) / (R.y - M.y) * (R.x - M.x), r)._round() : R.y < r && (R = new F(M.x + (r - M.y) / (R.y - M.y) * (R.x - M.x), r)._round()), M.x >= o && R.x >= o || (M.x >= o ? M = new F(o, M.y + (o - M.x) / (R.x - M.x) * (R.y - M.y))._round() : R.x >= o && (R = new F(o, M.y + (o - M.x) / (R.x - M.x) * (R.y - M.y))._round()), M.y >= c && R.y >= c || (M.y >= c ? M = new F(M.x + (c - M.y) / (R.y - M.y) * (R.x - M.x), c)._round() : R.y >= c && (R = new F(M.x + (c - M.y) / (R.y - M.y) * (R.x - M.x), c)._round()), w && M.equals(w[w.length - 1]) || (w = [M], f.push(w)), w.push(R)))))
            }
          }
          return f
        }
        Cr("FeatureIndex", uv, {
          omit: ["rawTileData", "sourceLayerCoder"]
        });
        class Os extends F {
          constructor(t, r, o, c) {
            super(t, r), this.angle = o, c !== void 0 && (this.segment = c)
          }
          clone() {
            return new Os(this.x, this.y, this.angle, this.segment)
          }
        }

        function pv(n, t, r, o, c) {
          if (t.segment === void 0 || r === 0) return !0;
          let f = t,
            g = t.segment + 1,
            y = 0;
          for (; y > -r / 2;) {
            if (g--, g < 0) return !1;
            y -= n[g].dist(f), f = n[g]
          }
          y += n[g].dist(n[g + 1]), g++;
          const w = [];
          let P = 0;
          for (; y < r / 2;) {
            const M = n[g],
              R = n[g + 1];
            if (!R) return !1;
            let U = n[g - 1].angleTo(M) - M.angleTo(R);
            for (U = Math.abs((U + 3 * Math.PI) % (2 * Math.PI) - Math.PI), w.push({
                distance: y,
                angleDelta: U
              }), P += U; y - w[0].distance > o;) P -= w.shift().angleDelta;
            if (P > c) return !1;
            g++, y += M.dist(R)
          }
          return !0
        }

        function fv(n) {
          let t = 0;
          for (let r = 0; r < n.length - 1; r++) t += n[r].dist(n[r + 1]);
          return t
        }

        function mv(n, t, r) {
          return n ? .6 * t * r : 0
        }

        function gv(n, t) {
          return Math.max(n ? n.right - n.left : 0, t ? t.right - t.left : 0)
        }

        function Lx(n, t, r, o, c, f) {
          const g = mv(r, c, f),
            y = gv(r, o) * f;
          let w = 0;
          const P = fv(n) / 2;
          for (let M = 0; M < n.length - 1; M++) {
            const R = n[M],
              U = n[M + 1],
              G = R.dist(U);
            if (w + G > P) {
              const W = (P - w) / G,
                ne = Fa.number(R.x, U.x, W),
                se = Fa.number(R.y, U.y, W),
                ge = new Os(ne, se, U.angleTo(R), M);
              return ge._round(), !g || pv(n, ge, y, g, t) ? ge : void 0
            }
            w += G
          }
        }

        function zx(n, t, r, o, c, f, g, y, w) {
          const P = mv(o, f, g),
            M = gv(o, c),
            R = M * g,
            U = n[0].x === 0 || n[0].x === w || n[0].y === 0 || n[0].y === w;
          return t - R < t / 4 && (t = R + t / 4), _v(n, U ? t / 2 * y % t : (M / 2 + 2 * f) * g * y % t, t, P, r, R, U, !1, w)
        }

        function _v(n, t, r, o, c, f, g, y, w) {
          const P = f / 2,
            M = fv(n);
          let R = 0,
            U = t - r,
            G = [];
          for (let W = 0; W < n.length - 1; W++) {
            const ne = n[W],
              se = n[W + 1],
              ge = ne.dist(se),
              We = se.angleTo(ne);
            for (; U + r < R + ge;) {
              U += r;
              const Te = (U - R) / ge,
                De = Fa.number(ne.x, se.x, Te),
                nt = Fa.number(ne.y, se.y, Te);
              if (De >= 0 && De < w && nt >= 0 && nt < w && U - P >= 0 && U + P <= M) {
                const gt = new Os(De, nt, We, W);
                gt._round(), o && !pv(n, gt, f, o, c) || G.push(gt)
              }
            }
            R += ge
          }
          return y || G.length || g || (G = _v(n, R / 2, r, o, c, f, g, !0, w)), G
        }

        function vv(n, t, r, o) {
          const c = [],
            f = n.image,
            g = f.pixelRatio,
            y = f.paddedRect.w - 2,
            w = f.paddedRect.h - 2;
          let P = {
            x1: n.left,
            y1: n.top,
            x2: n.right,
            y2: n.bottom
          };
          const M = f.stretchX || [
              [0, y]
            ],
            R = f.stretchY || [
              [0, w]
            ],
            U = (Ct, un) => Ct + un[1] - un[0],
            G = M.reduce(U, 0),
            W = R.reduce(U, 0),
            ne = y - G,
            se = w - W;
          let ge = 0,
            We = G,
            Te = 0,
            De = W,
            nt = 0,
            gt = ne,
            Vt = 0,
            pr = se;
          if (f.content && o) {
            const Ct = f.content,
              un = Ct[2] - Ct[0],
              yn = Ct[3] - Ct[1];
            (f.textFitWidth || f.textFitHeight) && (P = H_(n)), ge = pp(M, 0, Ct[0]), Te = pp(R, 0, Ct[1]), We = pp(M, Ct[0], Ct[2]), De = pp(R, Ct[1], Ct[3]), nt = Ct[0] - ge, Vt = Ct[1] - Te, gt = un - We, pr = yn - De
          }
          const ir = P.x1,
            ur = P.y1,
            Kr = P.x2 - ir,
            lr = P.y2 - ur,
            hr = (Ct, un, yn, rn) => {
              const Gr = fp(Ct.stretch - ge, We, Kr, ir),
                Un = mp(Ct.fixed - nt, gt, Ct.stretch, G),
                yi = fp(un.stretch - Te, De, lr, ur),
                Bi = mp(un.fixed - Vt, pr, un.stretch, W),
                aa = fp(yn.stretch - ge, We, Kr, ir),
                $a = mp(yn.fixed - nt, gt, yn.stretch, G),
                Ca = fp(rn.stretch - Te, De, lr, ur),
                Ki = mp(rn.fixed - Vt, pr, rn.stretch, W),
                vi = new F(Gr, yi),
                Wi = new F(aa, yi),
                Ji = new F(aa, Ca),
                Qi = new F(Gr, Ca),
                xa = new F(Un / g, Bi / g),
                Xa = new F($a / g, Ki / g),
                $i = t * Math.PI / 180;
              if ($i) {
                const Xi = Math.sin($i),
                  Yi = Math.cos($i),
                  Li = [Yi, -Xi, Xi, Yi];
                vi._matMult(Li), Wi._matMult(Li), Qi._matMult(Li), Ji._matMult(Li)
              }
              const Ia = Ct.stretch + Ct.fixed,
                Oi = un.stretch + un.fixed;
              return {
                tl: vi,
                tr: Wi,
                bl: Qi,
                br: Ji,
                tex: {
                  x: f.paddedRect.x + 1 + Ia,
                  y: f.paddedRect.y + 1 + Oi,
                  w: yn.stretch + yn.fixed - Ia,
                  h: rn.stretch + rn.fixed - Oi
                },
                writingMode: void 0,
                glyphOffset: [0, 0],
                sectionIndex: 0,
                pixelOffsetTL: xa,
                pixelOffsetBR: Xa,
                minFontScaleX: gt / g / Kr,
                minFontScaleY: pr / g / lr,
                isSDF: r
              }
            };
          if (o && (f.stretchX || f.stretchY)) {
            const Ct = yv(M, ne, G),
              un = yv(R, se, W);
            for (let yn = 0; yn < Ct.length - 1; yn++) {
              const rn = Ct[yn],
                Gr = Ct[yn + 1];
              for (let Un = 0; Un < un.length - 1; Un++) c.push(hr(rn, un[Un], Gr, un[Un + 1]))
            }
          } else c.push(hr({
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: y + 1
          }, {
            fixed: 0,
            stretch: w + 1
          }));
          return c
        }

        function pp(n, t, r) {
          let o = 0;
          for (const c of n) o += Math.max(t, Math.min(r, c[1])) - Math.max(t, Math.min(r, c[0]));
          return o
        }

        function yv(n, t, r) {
          const o = [{
            fixed: -1,
            stretch: 0
          }];
          for (const [c, f] of n) {
            const g = o[o.length - 1];
            o.push({
              fixed: c - g.stretch,
              stretch: g.stretch
            }), o.push({
              fixed: c - g.stretch,
              stretch: g.stretch + (f - c)
            })
          }
          return o.push({
            fixed: t + 1,
            stretch: r
          }), o
        }

        function fp(n, t, r, o) {
          return n / t * r + o
        }

        function mp(n, t, r, o) {
          return n - t * r / o
        }
        Cr("Anchor", Os);
        class gp {
          constructor(t, r, o, c, f, g, y, w, P, M) {
            var R;
            if (this.boxStartIndex = t.length, P) {
              let U = g.top,
                G = g.bottom;
              const W = g.collisionPadding;
              W && (U -= W[1], G += W[3]);
              let ne = G - U;
              ne > 0 && (ne = Math.max(10, ne), this.circleDiameter = ne)
            } else {
              const U = !((R = g.image) === null || R === void 0) && R.content && (g.image.textFitWidth || g.image.textFitHeight) ? H_(g) : {
                x1: g.left,
                y1: g.top,
                x2: g.right,
                y2: g.bottom
              };
              U.y1 = U.y1 * y - w[0], U.y2 = U.y2 * y + w[2], U.x1 = U.x1 * y - w[3], U.x2 = U.x2 * y + w[1];
              const G = g.collisionPadding;
              if (G && (U.x1 -= G[0] * y, U.y1 -= G[1] * y, U.x2 += G[2] * y, U.y2 += G[3] * y), M) {
                const W = new F(U.x1, U.y1),
                  ne = new F(U.x2, U.y1),
                  se = new F(U.x1, U.y2),
                  ge = new F(U.x2, U.y2),
                  We = M * Math.PI / 180;
                W._rotate(We), ne._rotate(We), se._rotate(We), ge._rotate(We), U.x1 = Math.min(W.x, ne.x, se.x, ge.x), U.x2 = Math.max(W.x, ne.x, se.x, ge.x), U.y1 = Math.min(W.y, ne.y, se.y, ge.y), U.y2 = Math.max(W.y, ne.y, se.y, ge.y)
              }
              t.emplaceBack(r.x, r.y, U.x1, U.y1, U.x2, U.y2, o, c, f)
            }
            this.boxEndIndex = t.length
          }
        }
        class Dx {
          constructor(t = [], r = (o, c) => o < c ? -1 : o > c ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = r, this.length > 0)
              for (let o = (this.length >> 1) - 1; o >= 0; o--) this._down(o)
          }
          push(t) {
            this.data.push(t), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0],
              r = this.data.pop();
            return --this.length > 0 && (this.data[0] = r, this._down(0)), t
          }
          peek() {
            return this.data[0]
          }
          _up(t) {
            const {
              data: r,
              compare: o
            } = this, c = r[t];
            for (; t > 0;) {
              const f = t - 1 >> 1,
                g = r[f];
              if (o(c, g) >= 0) break;
              r[t] = g, t = f
            }
            r[t] = c
          }
          _down(t) {
            const {
              data: r,
              compare: o
            } = this, c = this.length >> 1, f = r[t];
            for (; t < c;) {
              let g = 1 + (t << 1);
              const y = g + 1;
              if (y < this.length && o(r[y], r[g]) < 0 && (g = y), o(r[g], f) >= 0) break;
              r[t] = r[g], t = g
            }
            r[t] = f
          }
        }

        function Rx(n, t = 1, r = !1) {
          const o = ml.fromPoints(n[0]),
            c = Math.min(o.width(), o.height());
          let f = c / 2;
          const g = new Dx([], Fx),
            {
              minX: y,
              minY: w,
              maxX: P,
              maxY: M
            } = o;
          if (c === 0) return new F(y, w);
          for (let G = y; G < P; G += c)
            for (let W = w; W < M; W += c) g.push(new xc(G + f, W + f, f, n));
          let R = (function(G) {
              let W = 0,
                ne = 0,
                se = 0;
              const ge = G[0];
              for (let We = 0, Te = ge.length, De = Te - 1; We < Te; De = We++) {
                const nt = ge[We],
                  gt = ge[De],
                  Vt = nt.x * gt.y - gt.x * nt.y;
                ne += (nt.x + gt.x) * Vt, se += (nt.y + gt.y) * Vt, W += 3 * Vt
              }
              return new xc(ne / W, se / W, 0, G)
            })(n),
            U = g.length;
          for (; g.length;) {
            const G = g.pop();
            (G.d > R.d || !R.d) && (R = G, r && console.log("found best %d after %d probes", Math.round(1e4 * G.d) / 1e4, U)), G.max - R.d <= t || (f = G.h / 2, g.push(new xc(G.p.x - f, G.p.y - f, f, n)), g.push(new xc(G.p.x + f, G.p.y - f, f, n)), g.push(new xc(G.p.x - f, G.p.y + f, f, n)), g.push(new xc(G.p.x + f, G.p.y + f, f, n)), U += 4)
          }
          return r && (console.log(`num probes: ${U}`), console.log(`best distance: ${R.d}`)), R.p
        }

        function Fx(n, t) {
          return t.max - n.max
        }

        function xc(n, t, r, o) {
          this.p = new F(n, t), this.h = r, this.d = (function(c, f) {
            let g = !1,
              y = 1 / 0;
            for (let w = 0; w < f.length; w++) {
              const P = f[w];
              for (let M = 0, R = P.length, U = R - 1; M < R; U = M++) {
                const G = P[M],
                  W = P[U];
                G.y > c.y != W.y > c.y && c.x < (W.x - G.x) * (c.y - G.y) / (W.y - G.y) + G.x && (g = !g), y = Math.min(y, n_(c, G, W))
              }
            }
            return (g ? 1 : -1) * Math.sqrt(y)
          })(this.p, o), this.max = this.d + this.h * Math.SQRT2
        }
        var ia;
        b.aI = void 0, (ia = b.aI || (b.aI = {}))[ia.center = 1] = "center", ia[ia.left = 2] = "left", ia[ia.right = 3] = "right", ia[ia.top = 4] = "top", ia[ia.bottom = 5] = "bottom", ia[ia["top-left"] = 6] = "top-left", ia[ia["top-right"] = 7] = "top-right", ia[ia["bottom-left"] = 8] = "bottom-left", ia[ia["bottom-right"] = 9] = "bottom-right";
        const tm = Number.POSITIVE_INFINITY;

        function xv(n, t) {
          return t[1] !== tm ? (function(r, o, c) {
            let f = 0,
              g = 0;
            switch (o = Math.abs(o), c = Math.abs(c), r) {
              case "top-right":
              case "top-left":
              case "top":
                g = c - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                g = 7 - c
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
              case "right":
                f = -o;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                f = o
            }
            return [f, g]
          })(n, t[0], t[1]) : (function(r, o) {
            let c = 0,
              f = 0;
            o < 0 && (o = 0);
            const g = o / Math.SQRT2;
            switch (r) {
              case "top-right":
              case "top-left":
                f = g - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                f = 7 - g;
                break;
              case "bottom":
                f = 7 - o;
                break;
              case "top":
                f = o - 7
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
                c = -g;
                break;
              case "top-left":
              case "bottom-left":
                c = g;
                break;
              case "left":
                c = o;
                break;
              case "right":
                c = -o
            }
            return [c, f]
          })(n, t[0])
        }

        function bv(n, t, r) {
          var o;
          const c = n.layout,
            f = (o = c.get("text-variable-anchor-offset")) === null || o === void 0 ? void 0 : o.evaluate(t, {}, r);
          if (f) {
            const y = f.values,
              w = [];
            for (let P = 0; P < y.length; P += 2) {
              const M = w[P] = y[P],
                R = y[P + 1].map((U => U * Hi));
              M.startsWith("top") ? R[1] -= 7 : M.startsWith("bottom") && (R[1] += 7), w[P + 1] = R
            }
            return new Bn(w)
          }
          const g = c.get("text-variable-anchor");
          if (g) {
            let y;
            y = n._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [c.get("text-radial-offset").evaluate(t, {}, r) * Hi, tm] : c.get("text-offset").evaluate(t, {}, r).map((P => P * Hi));
            const w = [];
            for (const P of g) w.push(P, xv(P, y));
            return new Bn(w)
          }
          return null
        }

        function rm(n) {
          switch (n) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left"
          }
          return "center"
        }

        function Bx(n, t, r, o, c, f, g, y, w, P, M, R) {
          let U = f.textMaxSize.evaluate(t, {});
          U === void 0 && (U = g);
          const G = n.layers[0].layout,
            W = G.get("icon-offset").evaluate(t, {}, M),
            ne = Tv(r.horizontal),
            se = g / 24,
            ge = n.tilePixelRatio * se,
            We = n.tilePixelRatio * U / 24,
            Te = n.tilePixelRatio * y,
            De = n.tilePixelRatio * G.get("symbol-spacing"),
            nt = G.get("text-padding") * n.tilePixelRatio,
            gt = (function(yn, rn, Gr, Un = 1) {
              const yi = yn.get("icon-padding").evaluate(rn, {}, Gr),
                Bi = yi && yi.values;
              return [Bi[0] * Un, Bi[1] * Un, Bi[2] * Un, Bi[3] * Un]
            })(G, t, M, n.tilePixelRatio),
            Vt = G.get("text-max-angle") / 180 * Math.PI,
            pr = G.get("text-rotation-alignment") !== "viewport" && G.get("symbol-placement") !== "point",
            ir = G.get("icon-rotation-alignment") === "map" && G.get("symbol-placement") !== "point",
            ur = G.get("symbol-placement"),
            Kr = De / 2,
            lr = G.get("icon-text-fit");
          let hr;
          o && lr !== "none" && (n.allowVerticalPlacement && r.vertical && (hr = W_(o, r.vertical, lr, G.get("icon-text-fit-padding"), W, se)), ne && (o = W_(o, ne, lr, G.get("icon-text-fit-padding"), W, se)));
          const Ct = M ? R.line.getGranularityForZoomLevel(M.z) : 1,
            un = (yn, rn) => {
              rn.x < 0 || rn.x >= Je || rn.y < 0 || rn.y >= Je || (function(Gr, Un, yi, Bi, aa, $a, Ca, Ki, vi, Wi, Ji, Qi, xa, Xa, $i, Ia, Oi, Xi, Yi, Li, hi, wo, bc, To, jx) {
                const wc = Gr.addToLineVertexArray(Un, yi);
                let gl, Tc, Sc, Pc, Iv = 0,
                  Mv = 0,
                  Av = 0,
                  kv = 0,
                  um = -1,
                  hm = -1;
                const hs = {};
                let Ev = yo("");
                if (Gr.allowVerticalPlacement && Bi.vertical) {
                  const fa = Ki.layout.get("text-rotate").evaluate(hi, {}, To) + 90;
                  Sc = new gp(vi, Un, Wi, Ji, Qi, Bi.vertical, xa, Xa, $i, fa), Ca && (Pc = new gp(vi, Un, Wi, Ji, Qi, Ca, Oi, Xi, $i, fa))
                }
                if (aa) {
                  const fa = Ki.layout.get("icon-rotate").evaluate(hi, {}),
                    Ya = Ki.layout.get("icon-text-fit") !== "none",
                    _l = vv(aa, fa, bc, Ya),
                    Po = Ca ? vv(Ca, fa, bc, Ya) : void 0;
                  Tc = new gp(vi, Un, Wi, Ji, Qi, aa, Oi, Xi, !1, fa), Iv = 4 * _l.length;
                  const vl = Gr.iconSizeData;
                  let Bo = null;
                  vl.kind === "source" ? (Bo = [us * Ki.layout.get("icon-size").evaluate(hi, {})], Bo[0] > Fs && Wt(`${Gr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : vl.kind === "composite" && (Bo = [us * wo.compositeIconSizes[0].evaluate(hi, {}, To), us * wo.compositeIconSizes[1].evaluate(hi, {}, To)], (Bo[0] > Fs || Bo[1] > Fs) && Wt(`${Gr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Gr.addSymbols(Gr.icon, _l, Bo, Li, Yi, hi, b.as.none, Un, wc.lineStartIndex, wc.lineLength, -1, To), um = Gr.icon.placedSymbolArray.length - 1, Po && (Mv = 4 * Po.length, Gr.addSymbols(Gr.icon, Po, Bo, Li, Yi, hi, b.as.vertical, Un, wc.lineStartIndex, wc.lineLength, -1, To), hm = Gr.icon.placedSymbolArray.length - 1)
                }
                const Lv = Object.keys(Bi.horizontal);
                for (const fa of Lv) {
                  const Ya = Bi.horizontal[fa];
                  if (!gl) {
                    Ev = yo(Ya.text);
                    const Po = Ki.layout.get("text-rotate").evaluate(hi, {}, To);
                    gl = new gp(vi, Un, Wi, Ji, Qi, Ya, xa, Xa, $i, Po)
                  }
                  const _l = Ya.positionedLines.length === 1;
                  if (Av += wv(Gr, Un, Ya, $a, Ki, $i, hi, Ia, wc, Bi.vertical ? b.as.horizontal : b.as.horizontalOnly, _l ? Lv : [fa], hs, um, wo, To), _l) break
                }
                Bi.vertical && (kv += wv(Gr, Un, Bi.vertical, $a, Ki, $i, hi, Ia, wc, b.as.vertical, ["vertical"], hs, hm, wo, To));
                const qx = gl ? gl.boxStartIndex : Gr.collisionBoxArray.length,
                  Vx = gl ? gl.boxEndIndex : Gr.collisionBoxArray.length,
                  Ux = Sc ? Sc.boxStartIndex : Gr.collisionBoxArray.length,
                  Zx = Sc ? Sc.boxEndIndex : Gr.collisionBoxArray.length,
                  Gx = Tc ? Tc.boxStartIndex : Gr.collisionBoxArray.length,
                  Hx = Tc ? Tc.boxEndIndex : Gr.collisionBoxArray.length,
                  Wx = Pc ? Pc.boxStartIndex : Gr.collisionBoxArray.length,
                  $x = Pc ? Pc.boxEndIndex : Gr.collisionBoxArray.length;
                let So = -1;
                const vp = (fa, Ya) => fa && fa.circleDiameter ? Math.max(fa.circleDiameter, Ya) : Ya;
                So = vp(gl, So), So = vp(Sc, So), So = vp(Tc, So), So = vp(Pc, So);
                const zv = So > -1 ? 1 : 0;
                zv && (So *= jx / Hi), Gr.glyphOffsetArray.length >= vc.MAX_GLYPHS && Wt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), hi.sortKey !== void 0 && Gr.addToSortKeyRanges(Gr.symbolInstances.length, hi.sortKey);
                const Xx = bv(Ki, hi, To),
                  [Yx, Kx] = (function(fa, Ya) {
                    const _l = fa.length,
                      Po = Ya == null ? void 0 : Ya.values;
                    if ((Po == null ? void 0 : Po.length) > 0)
                      for (let vl = 0; vl < Po.length; vl += 2) {
                        const Bo = Po[vl + 1];
                        fa.emplaceBack(b.aI[Po[vl]], Bo[0], Bo[1])
                      }
                    return [_l, fa.length]
                  })(Gr.textAnchorOffsets, Xx);
                Gr.symbolInstances.emplaceBack(Un.x, Un.y, hs.right >= 0 ? hs.right : -1, hs.center >= 0 ? hs.center : -1, hs.left >= 0 ? hs.left : -1, hs.vertical || -1, um, hm, Ev, qx, Vx, Ux, Zx, Gx, Hx, Wx, $x, Wi, Av, kv, Iv, Mv, zv, 0, xa, So, Yx, Kx)
              })(n, rn, yn, r, o, c, hr, n.layers[0], n.collisionBoxArray, t.index, t.sourceLayerIndex, n.index, ge, [nt, nt, nt, nt], pr, w, Te, gt, ir, W, t, f, P, M, g)
            };
          if (ur === "line")
            for (const yn of dv(t.geometry, 0, 0, Je, Je)) {
              const rn = fl(yn, Ct),
                Gr = zx(rn, De, Vt, r.vertical || ne, o, 24, We, n.overscaling, Je);
              for (const Un of Gr) ne && Ox(n, ne.text, Kr, Un) || un(rn, Un)
            } else if (ur === "line-center") {
              for (const yn of t.geometry)
                if (yn.length > 1) {
                  const rn = fl(yn, Ct),
                    Gr = Lx(rn, Vt, r.vertical || ne, o, 24, We);
                  Gr && un(rn, Gr)
                }
            } else if (t.type === "Polygon")
            for (const yn of Dl(t.geometry, 0)) {
              const rn = Rx(yn, 16);
              un(fl(yn[0], Ct, !0), new Os(rn.x, rn.y, 0))
            } else if (t.type === "LineString")
              for (const yn of t.geometry) {
                const rn = fl(yn, Ct);
                un(rn, new Os(rn[0].x, rn[0].y, 0))
              } else if (t.type === "Point")
                for (const yn of t.geometry)
                  for (const rn of yn) un([rn], new Os(rn.x, rn.y, 0))
        }

        function wv(n, t, r, o, c, f, g, y, w, P, M, R, U, G, W) {
          const ne = (function(We, Te, De, nt, gt, Vt, pr, ir) {
              const ur = nt.layout.get("text-rotate").evaluate(Vt, {}) * Math.PI / 180,
                Kr = [];
              for (const lr of Te.positionedLines)
                for (const hr of lr.positionedGlyphs) {
                  if (!hr.rect) continue;
                  const Ct = hr.rect || {};
                  let un = 4,
                    yn = !0,
                    rn = 1,
                    Gr = 0;
                  const Un = (gt || ir) && hr.vertical,
                    yi = hr.metrics.advance * hr.scale / 2;
                  if (ir && Te.verticalizable && (Gr = lr.lineOffset / 2 - (hr.imageName ? -(Hi - hr.metrics.width * hr.scale) / 2 : (hr.scale - 1) * Hi)), hr.imageName) {
                    const Xi = pr[hr.imageName];
                    yn = Xi.sdf, rn = Xi.pixelRatio, un = 1 / rn
                  }
                  const Bi = gt ? [hr.x + yi, hr.y] : [0, 0];
                  let aa = gt ? [0, 0] : [hr.x + yi + De[0], hr.y + De[1] - Gr],
                    $a = [0, 0];
                  Un && ($a = aa, aa = [0, 0]);
                  const Ca = hr.metrics.isDoubleResolution ? 2 : 1,
                    Ki = (hr.metrics.left - un) * hr.scale - yi + aa[0],
                    vi = (-hr.metrics.top - un) * hr.scale + aa[1],
                    Wi = Ki + Ct.w / Ca * hr.scale / rn,
                    Ji = vi + Ct.h / Ca * hr.scale / rn,
                    Qi = new F(Ki, vi),
                    xa = new F(Wi, vi),
                    Xa = new F(Ki, Ji),
                    $i = new F(Wi, Ji);
                  if (Un) {
                    const Xi = new F(-yi, yi - -17),
                      Yi = -Math.PI / 2,
                      Li = 12 - yi,
                      hi = new F(22 - Li, -(hr.imageName ? Li : 0)),
                      wo = new F(...$a);
                    Qi._rotateAround(Yi, Xi)._add(hi)._add(wo), xa._rotateAround(Yi, Xi)._add(hi)._add(wo), Xa._rotateAround(Yi, Xi)._add(hi)._add(wo), $i._rotateAround(Yi, Xi)._add(hi)._add(wo)
                  }
                  if (ur) {
                    const Xi = Math.sin(ur),
                      Yi = Math.cos(ur),
                      Li = [Yi, -Xi, Xi, Yi];
                    Qi._matMult(Li), xa._matMult(Li), Xa._matMult(Li), $i._matMult(Li)
                  }
                  const Ia = new F(0, 0),
                    Oi = new F(0, 0);
                  Kr.push({
                    tl: Qi,
                    tr: xa,
                    bl: Xa,
                    br: $i,
                    tex: Ct,
                    writingMode: Te.writingMode,
                    glyphOffset: Bi,
                    sectionIndex: hr.sectionIndex,
                    isSDF: yn,
                    pixelOffsetTL: Ia,
                    pixelOffsetBR: Oi,
                    minFontScaleX: 0,
                    minFontScaleY: 0
                  })
                }
              return Kr
            })(0, r, y, c, f, g, o, n.allowVerticalPlacement),
            se = n.textSizeData;
          let ge = null;
          se.kind === "source" ? (ge = [us * c.layout.get("text-size").evaluate(g, {})], ge[0] > Fs && Wt(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : se.kind === "composite" && (ge = [us * G.compositeTextSizes[0].evaluate(g, {}, W), us * G.compositeTextSizes[1].evaluate(g, {}, W)], (ge[0] > Fs || ge[1] > Fs) && Wt(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), n.addSymbols(n.text, ne, ge, y, f, g, P, t, w.lineStartIndex, w.lineLength, U, W);
          for (const We of M) R[We] = n.text.placedSymbolArray.length - 1;
          return 4 * ne.length
        }

        function Tv(n) {
          for (const t in n) return n[t];
          return null
        }

        function Ox(n, t, r, o) {
          const c = n.compareText;
          if (t in c) {
            const f = c[t];
            for (let g = f.length - 1; g >= 0; g--)
              if (o.dist(f[g]) < r) return !0
          } else c[t] = [];
          return c[t].push(o), !1
        }
        const Sv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class nm {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [r, o] = new Uint8Array(t, 0, 2);
            if (r !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const c = o >> 4;
            if (c !== 1) throw new Error(`Got v${c} data when expected v1.`);
            const f = Sv[15 & o];
            if (!f) throw new Error("Unrecognized array type.");
            const [g] = new Uint16Array(t, 2, 1), [y] = new Uint32Array(t, 4, 1);
            return new nm(y, g, f, t)
          }
          constructor(t, r = 64, o = Float64Array, c) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = o, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const f = Sv.indexOf(this.ArrayType),
              g = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
              y = t * this.IndexArrayType.BYTES_PER_ELEMENT,
              w = (8 - y % 8) % 8;
            if (f < 0) throw new Error(`Unexpected typed array class: ${o}.`);
            c && c instanceof ArrayBuffer ? (this.data = c, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + y + w, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + g + y + w), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + y + w, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + f]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = t)
          }
          add(t, r) {
            const o = this._pos >> 1;
            return this.ids[o] = o, this.coords[this._pos++] = t, this.coords[this._pos++] = r, o
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return im(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this
          }
          range(t, r, o, c) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: f,
              coords: g,
              nodeSize: y
            } = this, w = [0, f.length - 1, 0], P = [];
            for (; w.length;) {
              const M = w.pop() || 0,
                R = w.pop() || 0,
                U = w.pop() || 0;
              if (R - U <= y) {
                for (let se = U; se <= R; se++) {
                  const ge = g[2 * se],
                    We = g[2 * se + 1];
                  ge >= t && ge <= o && We >= r && We <= c && P.push(f[se])
                }
                continue
              }
              const G = U + R >> 1,
                W = g[2 * G],
                ne = g[2 * G + 1];
              W >= t && W <= o && ne >= r && ne <= c && P.push(f[G]), (M === 0 ? t <= W : r <= ne) && (w.push(U), w.push(G - 1), w.push(1 - M)), (M === 0 ? o >= W : c >= ne) && (w.push(G + 1), w.push(R), w.push(1 - M))
            }
            return P
          }
          within(t, r, o) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: c,
              coords: f,
              nodeSize: g
            } = this, y = [0, c.length - 1, 0], w = [], P = o * o;
            for (; y.length;) {
              const M = y.pop() || 0,
                R = y.pop() || 0,
                U = y.pop() || 0;
              if (R - U <= g) {
                for (let se = U; se <= R; se++) Cv(f[2 * se], f[2 * se + 1], t, r) <= P && w.push(c[se]);
                continue
              }
              const G = U + R >> 1,
                W = f[2 * G],
                ne = f[2 * G + 1];
              Cv(W, ne, t, r) <= P && w.push(c[G]), (M === 0 ? t - o <= W : r - o <= ne) && (y.push(U), y.push(G - 1), y.push(1 - M)), (M === 0 ? t + o >= W : r + o >= ne) && (y.push(G + 1), y.push(R), y.push(1 - M))
            }
            return w
          }
        }

        function im(n, t, r, o, c, f) {
          if (c - o <= r) return;
          const g = o + c >> 1;
          Pv(n, t, g, o, c, f), im(n, t, r, o, g - 1, 1 - f), im(n, t, r, g + 1, c, 1 - f)
        }

        function Pv(n, t, r, o, c, f) {
          for (; c > o;) {
            if (c - o > 600) {
              const P = c - o + 1,
                M = r - o + 1,
                R = Math.log(P),
                U = .5 * Math.exp(2 * R / 3),
                G = .5 * Math.sqrt(R * U * (P - U) / P) * (M - P / 2 < 0 ? -1 : 1);
              Pv(n, t, r, Math.max(o, Math.floor(r - M * U / P + G)), Math.min(c, Math.floor(r + (P - M) * U / P + G)), f)
            }
            const g = t[2 * r + f];
            let y = o,
              w = c;
            for (Wu(n, t, o, r), t[2 * c + f] > g && Wu(n, t, o, c); y < w;) {
              for (Wu(n, t, y, w), y++, w--; t[2 * y + f] < g;) y++;
              for (; t[2 * w + f] > g;) w--
            }
            t[2 * o + f] === g ? Wu(n, t, o, w) : (w++, Wu(n, t, w, c)), w <= r && (o = w + 1), r <= w && (c = w - 1)
          }
        }

        function Wu(n, t, r, o) {
          am(n, r, o), am(t, 2 * r, 2 * o), am(t, 2 * r + 1, 2 * o + 1)
        }

        function am(n, t, r) {
          const o = n[t];
          n[t] = n[r], n[r] = o
        }

        function Cv(n, t, r, o) {
          const c = n - r,
            f = t - o;
          return c * c + f * f
        }
        var om;
        b.cA = void 0, (om = b.cA || (b.cA = {})).create = "create", om.load = "load", om.fullLoad = "fullLoad";
        let _p = null,
          $u = [];
        const sm = 1e3 / 60,
          lm = "loadTime",
          cm = "fullLoadTime",
          Nx = {
            mark(n) {
              performance.mark(n)
            },
            frame(n) {
              const t = n;
              _p != null && $u.push(t - _p), _p = t
            },
            clearMetrics() {
              _p = null, $u = [], performance.clearMeasures(lm), performance.clearMeasures(cm);
              for (const n in b.cA) performance.clearMarks(b.cA[n])
            },
            getPerformanceMetrics() {
              performance.measure(lm, b.cA.create, b.cA.load), performance.measure(cm, b.cA.create, b.cA.fullLoad);
              const n = performance.getEntriesByName(lm)[0].duration,
                t = performance.getEntriesByName(cm)[0].duration,
                r = $u.length,
                o = 1 / ($u.reduce(((f, g) => f + g), 0) / r / 1e3),
                c = $u.filter((f => f > sm)).reduce(((f, g) => f + (g - sm) / sm), 0);
              return {
                loadTime: n,
                fullLoadTime: t,
                fps: o,
                percentDroppedFrames: c / (r + c) * 100,
                totalFrames: r
              }
            }
          };
        b.$ = Lr, b.A = Ie, b.B = ks, b.C = function([n, t, r]) {
          return t += 90, t *= Math.PI / 180, r *= Math.PI / 180, {
            x: n * Math.cos(t) * Math.sin(r),
            y: n * Math.sin(t) * Math.sin(r),
            z: n * Math.cos(r)
          }
        }, b.D = Hr, b.E = he, b.F = Fa, b.G = ai, b.H = ol, b.I = Gf, b.J = Lt, b.K = class {
          constructor(n, t) {
            this.target = n, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Ax((() => this.process())), this.subscription = Tr(this.target, "message", (r => this.receive(r)), !1), this.globalScope = jt(self) ? n : window
          }
          registerMessageHandler(n, t) {
            this.messageHandlers[n] = t
          }
          sendAsync(n, t) {
            return new Promise(((r, o) => {
              const c = Math.round(1e18 * Math.random()).toString(36).substring(0, 10),
                f = t ? Tr(t.signal, "abort", (() => {
                  f == null || f.unsubscribe(), delete this.resolveRejects[c];
                  const w = {
                    id: c,
                    type: "<cancel>",
                    origin: location.origin,
                    targetMapId: n.targetMapId,
                    sourceMapId: this.mapId
                  };
                  this.target.postMessage(w)
                }), kx) : null;
              this.resolveRejects[c] = {
                resolve: w => {
                  f == null || f.unsubscribe(), r(w)
                },
                reject: w => {
                  f == null || f.unsubscribe(), o(w)
                }
              };
              const g = [],
                y = Object.assign(Object.assign({}, n), {
                  id: c,
                  sourceMapId: this.mapId,
                  origin: location.origin,
                  data: go(n.data, g)
                });
              this.target.postMessage(y, {
                transfer: g
              })
            }))
          }
          receive(n) {
            const t = n.data,
              r = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[r];
                const o = this.abortControllers[r];
                return delete this.abortControllers[r], void(o && o.abort())
              }
              if (jt(self) || t.mustQueue) return this.tasks[r] = t, this.taskQueue.push(r), void this.invoker.trigger();
              this.processTask(r, t)
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const n = this.taskQueue.shift(),
              t = this.tasks[n];
            delete this.tasks[n], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(n, t)
          }
          processTask(n, t) {
            return s(this, void 0, void 0, (function*() {
              if (t.type === "<response>") {
                const c = this.resolveRejects[n];
                return delete this.resolveRejects[n], c ? void(t.error ? c.reject(sl(t.error)) : c.resolve(sl(t.data))) : void 0
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(n, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const r = sl(t.data),
                o = new AbortController;
              this.abortControllers[n] = o;
              try {
                const c = yield this.messageHandlers[t.type](t.sourceMapId, r, o);
                this.completeTask(n, null, c)
              } catch (c) {
                this.completeTask(n, c)
              }
            }))
          }
          completeTask(n, t, r) {
            const o = [];
            delete this.abortControllers[n];
            const c = {
              id: n,
              type: "<response>",
              sourceMapId: this.mapId,
              origin: location.origin,
              error: t ? go(t) : null,
              data: go(r, o)
            };
            this.target.postMessage(c, {
              transfer: o
            })
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe()
          }
        }, b.L = N, b.M = function() {
          var n = new Ie(16);
          return Ie != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0), n[0] = 1, n[5] = 1, n[10] = 1, n[15] = 1, n
        }, b.N = function(n, t, r) {
          var o, c, f, g, y, w, P, M, R, U, G, W, ne = r[0],
            se = r[1],
            ge = r[2];
          return t === n ? (n[12] = t[0] * ne + t[4] * se + t[8] * ge + t[12], n[13] = t[1] * ne + t[5] * se + t[9] * ge + t[13], n[14] = t[2] * ne + t[6] * se + t[10] * ge + t[14], n[15] = t[3] * ne + t[7] * se + t[11] * ge + t[15]) : (c = t[1], f = t[2], g = t[3], y = t[4], w = t[5], P = t[6], M = t[7], R = t[8], U = t[9], G = t[10], W = t[11], n[0] = o = t[0], n[1] = c, n[2] = f, n[3] = g, n[4] = y, n[5] = w, n[6] = P, n[7] = M, n[8] = R, n[9] = U, n[10] = G, n[11] = W, n[12] = o * ne + y * se + R * ge + t[12], n[13] = c * ne + w * se + U * ge + t[13], n[14] = f * ne + P * se + G * ge + t[14], n[15] = g * ne + M * se + W * ge + t[15]), n
        }, b.O = function(n, t, r) {
          var o = r[0],
            c = r[1],
            f = r[2];
          return n[0] = t[0] * o, n[1] = t[1] * o, n[2] = t[2] * o, n[3] = t[3] * o, n[4] = t[4] * c, n[5] = t[5] * c, n[6] = t[6] * c, n[7] = t[7] * c, n[8] = t[8] * f, n[9] = t[9] * f, n[10] = t[10] * f, n[11] = t[11] * f, n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n
        }, b.P = F, b.Q = function(n, t, r) {
          var o = t[0],
            c = t[1],
            f = t[2],
            g = t[3],
            y = t[4],
            w = t[5],
            P = t[6],
            M = t[7],
            R = t[8],
            U = t[9],
            G = t[10],
            W = t[11],
            ne = t[12],
            se = t[13],
            ge = t[14],
            We = t[15],
            Te = r[0],
            De = r[1],
            nt = r[2],
            gt = r[3];
          return n[0] = Te * o + De * y + nt * R + gt * ne, n[1] = Te * c + De * w + nt * U + gt * se, n[2] = Te * f + De * P + nt * G + gt * ge, n[3] = Te * g + De * M + nt * W + gt * We, n[4] = (Te = r[4]) * o + (De = r[5]) * y + (nt = r[6]) * R + (gt = r[7]) * ne, n[5] = Te * c + De * w + nt * U + gt * se, n[6] = Te * f + De * P + nt * G + gt * ge, n[7] = Te * g + De * M + nt * W + gt * We, n[8] = (Te = r[8]) * o + (De = r[9]) * y + (nt = r[10]) * R + (gt = r[11]) * ne, n[9] = Te * c + De * w + nt * U + gt * se, n[10] = Te * f + De * P + nt * G + gt * ge, n[11] = Te * g + De * M + nt * W + gt * We, n[12] = (Te = r[12]) * o + (De = r[13]) * y + (nt = r[14]) * R + (gt = r[15]) * ne, n[13] = Te * c + De * w + nt * U + gt * se, n[14] = Te * f + De * P + nt * G + gt * ge, n[15] = Te * g + De * M + nt * W + gt * We, n
        }, b.R = Pa, b.S = function(n, t) {
          const r = {};
          for (let o = 0; o < t.length; o++) {
            const c = t[o];
            c in n && (r[c] = n[c])
          }
          return r
        }, b.T = Rf, b.U = Bs, b.V = tt, b.W = rv, b.X = tv, b.Y = Se, b.Z = Me, b._ = s, b.a = E, b.a$ = function(n, t, r) {
          return n[0] = t[0] * r[0], n[1] = t[1] * r[1], n[2] = t[2] * r[2], n[3] = t[3] * r[3], n
        }, b.a0 = Wa, b.a1 = iv, b.a2 = dp, b.a3 = Je, b.a4 = function(n, t) {
          var r, o, c, f, g;
          if (!n) return t ?? {};
          if (!t) return n;
          let y = Object.assign({}, n);
          if (t.removeAll && (y = {
              removeAll: !0
            }), t.remove) {
            const w = new Set(t.remove);
            y.add && (y.add = y.add.filter((M => !w.has(M.id)))), y.update && (y.update = y.update.filter((M => !w.has(M.id))));
            const P = new Set(((r = n.add) !== null && r !== void 0 ? r : []).map((M => M.id)));
            t.remove = t.remove.filter((M => !P.has(M)))
          }
          if (t.remove) {
            const w = new Set(y.remove ? y.remove.concat(t.remove) : t.remove);
            y.remove = Array.from(w.values())
          }
          if (t.add) {
            const w = y.add ? y.add.concat(t.add) : t.add,
              P = new Map(w.map((M => [M.id, M])));
            y.add = Array.from(P.values())
          }
          if (t.update) {
            const w = new Map((o = y.update) === null || o === void 0 ? void 0 : o.map((P => [P.id, P])));
            for (const P of t.update) {
              const M = (c = w.get(P.id)) !== null && c !== void 0 ? c : {
                id: P.id
              };
              P.newGeometry && (M.newGeometry = P.newGeometry), P.addOrUpdateProperties && (M.addOrUpdateProperties = ((f = M.addOrUpdateProperties) !== null && f !== void 0 ? f : []).concat(P.addOrUpdateProperties)), P.removeProperties && (M.removeProperties = ((g = M.removeProperties) !== null && g !== void 0 ? g : []).concat(P.removeProperties)), P.removeAllProperties && (M.removeAllProperties = !0), w.set(P.id, M)
            }
            y.update = Array.from(w.values())
          }
          return y.remove && y.add && (y.remove = y.remove.filter((w => y.add.findIndex((P => P.id === w)) === -1))), y
        }, b.a5 = Gu, b.a6 = ml, b.a7 = 25, b.a8 = em, b.a9 = n => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise((r => {
            t.onloadstart = () => {
              r(t)
            };
            for (const o of n) {
              const c = window.document.createElement("source");
              be(o) || (t.crossOrigin = "Anonymous"), c.src = o, t.appendChild(c)
            }
          }))
        }, b.aA = Xe, b.aB = function(n, t, r, o) {
          const c = t.y - n.y,
            f = t.x - n.x,
            g = o.y - r.y,
            y = o.x - r.x,
            w = g * f - y * c;
          if (w === 0) return null;
          const P = (y * (n.y - r.y) - g * (n.x - r.x)) / w;
          return new F(n.x + P * f, n.y + P * c)
        }, b.aC = dv, b.aD = t_, b.aE = function(n) {
          let t = 1 / 0,
            r = 1 / 0,
            o = -1 / 0,
            c = -1 / 0;
          for (const f of n) t = Math.min(t, f.x), r = Math.min(r, f.y), o = Math.max(o, f.x), c = Math.max(c, f.y);
          return [t, r, o, c]
        }, b.aF = Hi, b.aG = zt, b.aH = function(n, t, r, o, c = !1) {
          if (!r[0] && !r[1]) return [0, 0];
          const f = c ? o === "map" ? -n.bearingInRadians : 0 : o === "viewport" ? n.bearingInRadians : 0;
          if (f) {
            const g = Math.sin(f),
              y = Math.cos(f);
            r = [r[0] * y - r[1] * g, r[0] * g + r[1] * y]
          }
          return [c ? r[0] : zt(t, r[0], n.zoom), c ? r[1] : zt(t, r[1], n.zoom)]
        }, b.aJ = $f, b.aK = rm, b.aL = Wf, b.aM = nm, b.aN = Si, b.aO = op, b.aP = ve, b.aQ = An, b.aR = kt, b.aS = xr, b.aT = av, b.aU = we, b.aV = He, b.aW = function(n) {
          var t = new Ie(3);
          return t[0] = n[0], t[1] = n[1], t[2] = n[2], t
        }, b.aX = function(n, t, r) {
          return n[0] = t[0] - r[0], n[1] = t[1] - r[1], n[2] = t[2] - r[2], n
        }, b.aY = function(n, t) {
          var r = t[0],
            o = t[1],
            c = t[2],
            f = r * r + o * o + c * c;
          return f > 0 && (f = 1 / Math.sqrt(f)), n[0] = t[0] * f, n[1] = t[1] * f, n[2] = t[2] * f, n
        }, b.aZ = it, b.a_ = function(n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2]
        }, b.aa = Ze, b.ab = function() {
          return It++
        }, b.ac = T, b.ad = vc, b.ae = rl, b.af = Fo, b.ag = cv, b.ah = function(n) {
          const t = {};
          if (n.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((r, o, c, f) => {
              const g = c || f;
              return t[o] = !g || g.toLowerCase(), ""
            })), t["max-age"]) {
            const r = parseInt(t["max-age"], 10);
            isNaN(r) ? delete t["max-age"] : t["max-age"] = r
          }
          return t
        }, b.ai = tr, b.aj = 85.051129, b.ak = Ar, b.al = function(n) {
          return Math.pow(2, n)
        }, b.am = je, b.an = nv, b.ao = function(n) {
          return Math.log(n) / Math.LN2
        }, b.ap = function(n) {
          var t = n[0],
            r = n[1];
          return t * t + r * r
        }, b.aq = function(n) {
          if (!n.length) return new Set;
          const t = Math.max(...n.map((w => w.canonical.z)));
          let r = 1 / 0,
            o = -1 / 0,
            c = 1 / 0,
            f = -1 / 0;
          const g = [];
          for (const w of n) {
            const {
              x: P,
              y: M,
              z: R
            } = w.canonical, U = Math.pow(2, t - R), G = P * U, W = M * U;
            g.push({
              id: w,
              x: G,
              y: W
            }), G < r && (r = G), G > o && (o = G), W < c && (c = W), W > f && (f = W)
          }
          const y = new Set;
          for (const w of g) w.x !== r && w.x !== o && w.y !== c && w.y !== f || y.add(w.id);
          return y
        }, b.ar = function(n, t) {
          let r = 0,
            o = 0;
          if (n.kind === "constant") o = n.layoutSize;
          else if (n.kind !== "source") {
            const {
              interpolationType: c,
              minZoom: f,
              maxZoom: g
            } = n, y = c ? tr(Qn.interpolationFactor(c, t, f, g), 0, 1) : 0;
            n.kind === "camera" ? o = Fa.number(n.minSize, n.maxSize, y) : r = y
          }
          return {
            uSizeT: r,
            uSize: o
          }
        }, b.at = function(n, {
          uSize: t,
          uSizeT: r
        }, {
          lowerSize: o,
          upperSize: c
        }) {
          return n.kind === "source" ? o / us : n.kind === "composite" ? Fa.number(o / us, c / us, r) : t
        }, b.au = function(n, t) {
          var r = t[0],
            o = t[1],
            c = t[2],
            f = t[3],
            g = t[4],
            y = t[5],
            w = t[6],
            P = t[7],
            M = t[8],
            R = t[9],
            U = t[10],
            G = t[11],
            W = t[12],
            ne = t[13],
            se = t[14],
            ge = t[15],
            We = r * y - o * g,
            Te = r * w - c * g,
            De = r * P - f * g,
            nt = o * w - c * y,
            gt = o * P - f * y,
            Vt = c * P - f * w,
            pr = M * ne - R * W,
            ir = M * se - U * W,
            ur = M * ge - G * W,
            Kr = R * se - U * ne,
            lr = R * ge - G * ne,
            hr = U * ge - G * se,
            Ct = We * hr - Te * lr + De * Kr + nt * ur - gt * ir + Vt * pr;
          return Ct ? (n[0] = (y * hr - w * lr + P * Kr) * (Ct = 1 / Ct), n[1] = (c * lr - o * hr - f * Kr) * Ct, n[2] = (ne * Vt - se * gt + ge * nt) * Ct, n[3] = (U * gt - R * Vt - G * nt) * Ct, n[4] = (w * ur - g * hr - P * ir) * Ct, n[5] = (r * hr - c * ur + f * ir) * Ct, n[6] = (se * De - W * Vt - ge * Te) * Ct, n[7] = (M * Vt - U * De + G * Te) * Ct, n[8] = (g * lr - y * ur + P * pr) * Ct, n[9] = (o * ur - r * lr - f * pr) * Ct, n[10] = (W * gt - ne * De + ge * We) * Ct, n[11] = (R * De - M * gt - G * We) * Ct, n[12] = (y * ir - g * Kr - w * pr) * Ct, n[13] = (r * Kr - o * ir + c * pr) * Ct, n[14] = (ne * Te - W * nt - se * We) * Ct, n[15] = (M * nt - R * Te + U * We) * Ct, n) : null
        }, b.av = _t, b.aw = function(n) {
          var t = n[0],
            r = n[1];
          return Math.sqrt(t * t + r * r)
        }, b.ax = function(n) {
          return n[0] = 0, n[1] = 0, n
        }, b.ay = function(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n
        }, b.az = Xf, b.b = Gt, b.b$ = function(n, t, r) {
          var o = t[0],
            c = t[1],
            f = t[2];
          return n[0] = o * r[0] + c * r[3] + f * r[6], n[1] = o * r[1] + c * r[4] + f * r[7], n[2] = o * r[2] + c * r[5] + f * r[8], n
        }, b.b0 = qe, b.b1 = function(n, t, r) {
          const o = t[0] * r[0] + t[1] * r[1] + t[2] * r[2];
          return o === 0 ? null : (-(n[0] * r[0] + n[1] * r[1] + n[2] * r[2]) - r[3]) / o
        }, b.b2 = Ge, b.b3 = function(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n[3] = t[3] * r, n
        }, b.b4 = function(n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3]
        }, b.b5 = sv, b.b6 = yc, b.b7 = function(n, t, r, o, c) {
          var f = 1 / Math.tan(t / 2);
          if (n[0] = f / r, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = f, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, c != null && c !== 1 / 0) {
            var g = 1 / (o - c);
            n[10] = (c + o) * g, n[14] = 2 * c * o * g
          } else n[10] = -1, n[14] = -2 * o;
          return n
        }, b.b8 = function(n) {
          var t = new Ie(16);
          return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t
        }, b.b9 = function(n, t, r) {
          var o = Math.sin(r),
            c = Math.cos(r),
            f = t[0],
            g = t[1],
            y = t[2],
            w = t[3],
            P = t[4],
            M = t[5],
            R = t[6],
            U = t[7];
          return t !== n && (n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = f * c + P * o, n[1] = g * c + M * o, n[2] = y * c + R * o, n[3] = w * c + U * o, n[4] = P * c - f * o, n[5] = M * c - g * o, n[6] = R * c - y * o, n[7] = U * c - w * o, n
        }, b.bA = function(n, t, r, o) {
          var c = [],
            f = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], f[0] = c[0], f[1] = c[1] * Math.cos(o) - c[2] * Math.sin(o), f[2] = c[1] * Math.sin(o) + c[2] * Math.cos(o), n[0] = f[0] + r[0], n[1] = f[1] + r[1], n[2] = f[2] + r[2], n
        }, b.bB = function(n, t, r, o) {
          var c = [],
            f = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], f[0] = c[2] * Math.sin(o) + c[0] * Math.cos(o), f[1] = c[1], f[2] = c[2] * Math.cos(o) - c[0] * Math.sin(o), n[0] = f[0] + r[0], n[1] = f[1] + r[1], n[2] = f[2] + r[2], n
        }, b.bC = function(n, t, r) {
          var o = Math.sin(r),
            c = Math.cos(r),
            f = t[0],
            g = t[1],
            y = t[2],
            w = t[3],
            P = t[8],
            M = t[9],
            R = t[10],
            U = t[11];
          return t !== n && (n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = f * c - P * o, n[1] = g * c - M * o, n[2] = y * c - R * o, n[3] = w * c - U * o, n[8] = f * o + P * c, n[9] = g * o + M * c, n[10] = y * o + R * c, n[11] = w * o + U * c, n
        }, b.bD = function(n, t) {
          const r = bt(n, 360),
            o = bt(t, 360),
            c = o - r,
            f = o > r ? c - 360 : c + 360;
          return Math.abs(c) < Math.abs(f) ? c : f
        }, b.bE = function(n) {
          return n[0] = 0, n[1] = 0, n[2] = 0, n
        }, b.bF = function(n, t, r, o) {
          const c = Math.sqrt(n * n + t * t),
            f = Math.sqrt(r * r + o * o);
          n /= c, t /= c, r /= f, o /= f;
          const g = Math.acos(n * r + t * o);
          return -t * r + n * o > 0 ? g : -g
        }, b.bG = function(n, t) {
          const r = bt(n, 2 * Math.PI),
            o = bt(t, 2 * Math.PI);
          return Math.min(Math.abs(r - o), Math.abs(r - o + 2 * Math.PI), Math.abs(r - o - 2 * Math.PI))
        }, b.bH = function() {
          const n = {},
            t = Q.$version;
          for (const r in Q.$root) {
            const o = Q.$root[r];
            if (o.required) {
              let c = null;
              c = r === "version" ? t : o.type === "array" ? [] : {}, c != null && (n[r] = c)
            }
          }
          return n
        }, b.bI = yu, b.bJ = ee, b.bK = function n(t, r) {
          if (Array.isArray(t)) {
            if (!Array.isArray(r) || t.length !== r.length) return !1;
            for (let o = 0; o < t.length; o++)
              if (!n(t[o], r[o])) return !1;
            return !0
          }
          if (typeof t == "object" && t !== null && r !== null) {
            if (typeof r != "object" || Object.keys(t).length !== Object.keys(r).length) return !1;
            for (const o in t)
              if (!n(t[o], r[o])) return !1;
            return !0
          }
          return t === r
        }, b.bL = function(n) {
          n = n.slice();
          const t = Object.create(null);
          for (let r = 0; r < n.length; r++) t[n[r].id] = n[r];
          for (let r = 0; r < n.length; r++) "ref" in n[r] && (n[r] = $e(n[r], t[n[r].ref]));
          return n
        }, b.bM = function(n, t) {
          if (n.type === "custom") return new Mx(n, t);
          switch (n.type) {
            case "background":
              return new Ix(n, t);
            case "circle":
              return new d1(n, t);
            case "color-relief":
              return new v1(n, t);
            case "fill":
              return new z1(n, t);
            case "fill-extrusion":
              return new Z1(n, t);
            case "heatmap":
              return new f1(n, t);
            case "hillshade":
              return new g1(n, t);
            case "line":
              return new K1(n, t);
            case "raster":
              return new Cf(n, t);
            case "symbol":
              return new hp(n, t)
          }
        }, b.bN = n => n.type === "raster", b.bO = Ht, b.bP = function(n, t) {
          if (!n) return [{
            command: "setStyle",
            args: [t]
          }];
          let r = [];
          try {
            if (!Re(n.version, t.version)) return [{
              command: "setStyle",
              args: [t]
            }];
            Re(n.center, t.center) || r.push({
              command: "setCenter",
              args: [t.center]
            }), Re(n.state, t.state) || r.push({
              command: "setGlobalState",
              args: [t.state]
            }), Re(n.centerAltitude, t.centerAltitude) || r.push({
              command: "setCenterAltitude",
              args: [t.centerAltitude]
            }), Re(n.zoom, t.zoom) || r.push({
              command: "setZoom",
              args: [t.zoom]
            }), Re(n.bearing, t.bearing) || r.push({
              command: "setBearing",
              args: [t.bearing]
            }), Re(n.pitch, t.pitch) || r.push({
              command: "setPitch",
              args: [t.pitch]
            }), Re(n.roll, t.roll) || r.push({
              command: "setRoll",
              args: [t.roll]
            }), Re(n.sprite, t.sprite) || r.push({
              command: "setSprite",
              args: [t.sprite]
            }), Re(n.glyphs, t.glyphs) || r.push({
              command: "setGlyphs",
              args: [t.glyphs]
            }), Re(n.transition, t.transition) || r.push({
              command: "setTransition",
              args: [t.transition]
            }), Re(n.light, t.light) || r.push({
              command: "setLight",
              args: [t.light]
            }), Re(n.terrain, t.terrain) || r.push({
              command: "setTerrain",
              args: [t.terrain]
            }), Re(n.sky, t.sky) || r.push({
              command: "setSky",
              args: [t.sky]
            }), Re(n.projection, t.projection) || r.push({
              command: "setProjection",
              args: [t.projection]
            });
            const o = {},
              c = [];
            (function(g, y, w, P) {
              let M;
              for (M in y = y || {}, g = g || {}) Object.prototype.hasOwnProperty.call(g, M) && (Object.prototype.hasOwnProperty.call(y, M) || Et(M, w, P));
              for (M in y) Object.prototype.hasOwnProperty.call(y, M) && (Object.prototype.hasOwnProperty.call(g, M) ? Re(g[M], y[M]) || (g[M].type === "geojson" && y[M].type === "geojson" && Kt(g, y, M) ? ft(w, {
                command: "setGeoJSONSourceData",
                args: [M, y[M].data]
              }) : dt(M, y, w, P)) : Mt(M, y, w))
            })(n.sources, t.sources, c, o);
            const f = [];
            n.layers && n.layers.forEach((g => {
              "source" in g && o[g.source] ? r.push({
                command: "removeLayer",
                args: [g.id]
              }) : f.push(g)
            })), r = r.concat(c), (function(g, y, w) {
              y = y || [];
              const P = (g = g || []).map(Sr),
                M = y.map(Sr),
                R = g.reduce(Ft, {}),
                U = y.reduce(Ft, {}),
                G = P.slice(),
                W = Object.create(null);
              let ne, se, ge, We, Te;
              for (let De = 0, nt = 0; De < P.length; De++) ne = P[De], Object.prototype.hasOwnProperty.call(U, ne) ? nt++ : (ft(w, {
                command: "removeLayer",
                args: [ne]
              }), G.splice(G.indexOf(ne, nt), 1));
              for (let De = 0, nt = 0; De < M.length; De++) ne = M[M.length - 1 - De], G[G.length - 1 - De] !== ne && (Object.prototype.hasOwnProperty.call(R, ne) ? (ft(w, {
                command: "removeLayer",
                args: [ne]
              }), G.splice(G.lastIndexOf(ne, G.length - nt), 1)) : nt++, We = G[G.length - De], ft(w, {
                command: "addLayer",
                args: [U[ne], We]
              }), G.splice(G.length - De, 0, ne), W[ne] = !0);
              for (let De = 0; De < M.length; De++)
                if (ne = M[De], se = R[ne], ge = U[ne], !W[ne] && !Re(se, ge))
                  if (Re(se.source, ge.source) && Re(se["source-layer"], ge["source-layer"]) && Re(se.type, ge.type)) {
                    for (Te in Qt(se.layout, ge.layout, w, ne, null, "setLayoutProperty"), Qt(se.paint, ge.paint, w, ne, null, "setPaintProperty"), Re(se.filter, ge.filter) || ft(w, {
                        command: "setFilter",
                        args: [ne, ge.filter]
                      }), Re(se.minzoom, ge.minzoom) && Re(se.maxzoom, ge.maxzoom) || ft(w, {
                        command: "setLayerZoomRange",
                        args: [ne, ge.minzoom, ge.maxzoom]
                      }), se) Object.prototype.hasOwnProperty.call(se, Te) && Te !== "layout" && Te !== "paint" && Te !== "filter" && Te !== "metadata" && Te !== "minzoom" && Te !== "maxzoom" && (Te.indexOf("paint.") === 0 ? Qt(se[Te], ge[Te], w, ne, Te.slice(6), "setPaintProperty") : Re(se[Te], ge[Te]) || ft(w, {
                      command: "setLayerProperty",
                      args: [ne, Te, ge[Te]]
                    }));
                    for (Te in ge) Object.prototype.hasOwnProperty.call(ge, Te) && !Object.prototype.hasOwnProperty.call(se, Te) && Te !== "layout" && Te !== "paint" && Te !== "filter" && Te !== "metadata" && Te !== "minzoom" && Te !== "maxzoom" && (Te.indexOf("paint.") === 0 ? Qt(se[Te], ge[Te], w, ne, Te.slice(6), "setPaintProperty") : Re(se[Te], ge[Te]) || ft(w, {
                      command: "setLayerProperty",
                      args: [ne, Te, ge[Te]]
                    }))
                  } else ft(w, {
                    command: "removeLayer",
                    args: [ne]
                  }), We = G[G.lastIndexOf(ne) + 1], ft(w, {
                    command: "addLayer",
                    args: [ge, We]
                  })
            })(f, t.layers, r)
          } catch (o) {
            console.warn("Unable to compute style diff:", o), r = [{
              command: "setStyle",
              args: [t]
            }]
          }
          return r
        }, b.bQ = function(n) {
          const t = [],
            r = n.id;
          return r === void 0 && t.push({
            message: `layers.${r}: missing required property "id"`
          }), n.render === void 0 && t.push({
            message: `layers.${r}: missing required method "render"`
          }), n.renderingMode && n.renderingMode !== "2d" && n.renderingMode !== "3d" && t.push({
            message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
          }), t
        }, b.bR = Bt, b.bS = Nt, b.bT = class extends ya {
          constructor(n, t) {
            super(n, t), this.current = 0
          }
          set(n) {
            this.current !== n && (this.current = n, this.gl.uniform1i(this.location, n))
          }
        }, b.bU = Do, b.bV = class extends ya {
          constructor(n, t) {
            super(n, t), this.current = dl
          }
          set(n) {
            if (n[12] !== this.current[12] || n[0] !== this.current[0]) return this.current = n, void this.gl.uniformMatrix4fv(this.location, !1, n);
            for (let t = 1; t < 16; t++)
              if (n[t] !== this.current[t]) {
                this.current = n, this.gl.uniformMatrix4fv(this.location, !1, n);
                break
              }
          }
        }, b.bW = xo, b.bX = class extends ya {
          constructor(n, t) {
            super(n, t), this.current = [0, 0, 0]
          }
          set(n) {
            n[0] === this.current[0] && n[1] === this.current[1] && n[2] === this.current[2] || (this.current = n, this.gl.uniform3f(this.location, n[0], n[1], n[2]))
          }
        }, b.bY = class extends ya {
          constructor(n, t) {
            super(n, t), this.current = [0, 0]
          }
          set(n) {
            n[0] === this.current[0] && n[1] === this.current[1] || (this.current = n, this.gl.uniform2f(this.location, n[0], n[1]))
          }
        }, b.bZ = Ce, b.b_ = function(n, t) {
          var r = Math.sin(t),
            o = Math.cos(t);
          return n[0] = o, n[1] = r, n[2] = 0, n[3] = -r, n[4] = o, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n
        }, b.ba = function(n, t, r) {
          var o = Math.sin(r),
            c = Math.cos(r),
            f = t[4],
            g = t[5],
            y = t[6],
            w = t[7],
            P = t[8],
            M = t[9],
            R = t[10],
            U = t[11];
          return t !== n && (n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[4] = f * c + P * o, n[5] = g * c + M * o, n[6] = y * c + R * o, n[7] = w * c + U * o, n[8] = P * c - f * o, n[9] = M * c - g * o, n[10] = R * c - y * o, n[11] = U * c - w * o, n
        }, b.bb = function() {
          const n = new Float32Array(16);
          return je(n), n
        }, b.bc = function() {
          const n = new Float64Array(16);
          return je(n), n
        }, b.bd = function() {
          return new Float64Array(16)
        }, b.be = function(n, t, r) {
          const o = new Float64Array(4);
          return Ut(o, n, t - 90, r), o
        }, b.bf = function(n, t, r, o) {
          var c, f, g, y, w, P = t[0],
            M = t[1],
            R = t[2],
            U = t[3],
            G = r[0],
            W = r[1],
            ne = r[2],
            se = r[3];
          return (f = P * G + M * W + R * ne + U * se) < 0 && (f = -f, G = -G, W = -W, ne = -ne, se = -se), 1 - f > Pe ? (c = Math.acos(f), g = Math.sin(c), y = Math.sin((1 - o) * c) / g, w = Math.sin(o * c) / g) : (y = 1 - o, w = o), n[0] = y * P + w * G, n[1] = y * M + w * W, n[2] = y * R + w * ne, n[3] = y * U + w * se, n
        }, b.bg = function(n) {
          const t = new Float64Array(9);
          var r, o, c, f, g, y, w, P, M, R, U, G, W, ne, se, ge, We, Te;
          R = (c = (o = n)[0]) * (w = c + c), U = (f = o[1]) * w, W = (g = o[2]) * w, ne = g * (P = f + f), ge = (y = o[3]) * w, We = y * P, Te = y * (M = g + g), (r = t)[0] = 1 - (G = f * P) - (se = g * M), r[3] = U - Te, r[6] = W + We, r[1] = U + Te, r[4] = 1 - R - se, r[7] = ne - ge, r[2] = W - We, r[5] = ne + ge, r[8] = 1 - R - G;
          const De = xr(-Math.asin(tr(t[2], -1, 1)));
          let nt, gt;
          return Math.hypot(t[5], t[8]) < .001 ? (nt = 0, gt = -xr(Math.atan2(t[3], t[4]))) : (nt = xr(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), gt = xr(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), {
            roll: nt,
            pitch: De + 90,
            bearing: gt
          }
        }, b.bh = function(n, t) {
          return n.roll == t.roll && n.pitch == t.pitch && n.bearing == t.bearing
        }, b.bi = gr, b.bj = pa, b.bk = fc, b.bl = Nu, b.bm = pc, b.bn = Rt, b.bo = Pt, b.bp = vn, b.bq = function(n, t, r, o, c) {
          return Rt(o, c, tr((n - t) / (r - t), 0, 1))
        }, b.br = bt, b.bs = function() {
          return new Float64Array(3)
        }, b.bt = function(n, t, r, o) {
          return n[0] = t[0] + r[0] * o, n[1] = t[1] + r[1] * o, n[2] = t[2] + r[2] * o, n
        }, b.bu = Ut, b.bv = function(n, t, r) {
          var o = r[0],
            c = r[1],
            f = r[2],
            g = r[3],
            y = t[0],
            w = t[1],
            P = t[2],
            M = c * P - f * w,
            R = f * y - o * P,
            U = o * w - c * y;
          return n[0] = y + g * (M += M) + c * (U += U) - f * (R += R), n[1] = w + g * R + f * M - o * U, n[2] = P + g * U + o * R - c * M, n
        }, b.bw = function(n, t, r) {
          const o = (c = [n[0], n[1], n[2], t[0], t[1], t[2], r[0], r[1], r[2]])[0] * ((M = c[8]) * (g = c[4]) - (y = c[5]) * (P = c[7])) + c[1] * (-M * (f = c[3]) + y * (w = c[6])) + c[2] * (P * f - g * w);
          var c, f, g, y, w, P, M;
          if (o === 0) return null;
          const R = it([], [t[0], t[1], t[2]], [r[0], r[1], r[2]]),
            U = it([], [r[0], r[1], r[2]], [n[0], n[1], n[2]]),
            G = it([], [n[0], n[1], n[2]], [t[0], t[1], t[2]]),
            W = we([], R, -n[3]);
          return He(W, W, we([], U, -t[3])), He(W, W, we([], G, -r[3])), we(W, W, 1 / o), W
        }, b.bx = Qf, b.by = function() {
          return new Float64Array(4)
        }, b.bz = function(n, t, r, o) {
          var c = [],
            f = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], f[0] = c[0] * Math.cos(o) - c[1] * Math.sin(o), f[1] = c[0] * Math.sin(o) + c[1] * Math.cos(o), f[2] = c[2], n[0] = f[0] + r[0], n[1] = f[1] + r[1], n[2] = f[2] + r[2], n
        }, b.c = j, b.c0 = function(n, t, r, o, c, f, g) {
          var y = 1 / (t - r),
            w = 1 / (o - c),
            P = 1 / (f - g);
          return n[0] = -2 * y, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * w, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * P, n[11] = 0, n[12] = (t + r) * y, n[13] = (c + o) * w, n[14] = (g + f) * P, n[15] = 1, n
        }, b.c1 = class extends ya {
          constructor(n, t) {
            super(n, t), this.current = new Array
          }
          set(n) {
            if (n != this.current) {
              this.current = n;
              const t = new Float32Array(4 * n.length);
              for (let r = 0; r < n.length; r++) t[4 * r] = n[r].r, t[4 * r + 1] = n[r].g, t[4 * r + 2] = n[r].b, t[4 * r + 3] = n[r].a;
              this.gl.uniform4fv(this.location, t)
            }
          }
        }, b.c2 = class extends ya {
          constructor(n, t) {
            super(n, t), this.current = new Array
          }
          set(n) {
            if (n != this.current) {
              this.current = n;
              const t = new Float32Array(n);
              this.gl.uniform1fv(this.location, t)
            }
          }
        }, b.c3 = class extends is {}, b.c4 = tx, b.c5 = class extends oc {}, b.c6 = Df, b.c7 = function(n) {
          return n <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
        }, b.c8 = h_, b.c9 = function(n, t, r) {
          var o = t[0],
            c = t[1],
            f = t[2],
            g = r[3] * o + r[7] * c + r[11] * f + r[15];
          return n[0] = (r[0] * o + r[4] * c + r[8] * f + r[12]) / (g = g || 1), n[1] = (r[1] * o + r[5] * c + r[9] * f + r[13]) / g, n[2] = (r[2] * o + r[6] * c + r[10] * f + r[14]) / g, n
        }, b.cB = function(n) {
          return n.message === Le
        }, b.cC = X, b.cD = function(n, t) {
          E.REGISTERED_PROTOCOLS[n] = t
        }, b.cE = function(n) {
          delete E.REGISTERED_PROTOCOLS[n]
        }, b.cF = function(n, t) {
          const r = {};
          for (let c = 0; c < n.length; c++) {
            const f = t && t[n[c].id] || Cd(n[c]);
            t && (t[n[c].id] = f);
            let g = r[f];
            g || (g = r[f] = []), g.push(n[c])
          }
          const o = [];
          for (const c in r) o.push(r[c]);
          return o
        }, b.cG = Cr, b.cH = lv, b.cI = uv, b.cJ = j_, b.cK = function(n) {
          n.bucket.createArrays(), n.bucket.tilePixelRatio = Je / (512 * n.bucket.overscaling), n.bucket.compareText = {}, n.bucket.iconsNeedLinear = !1;
          const t = n.bucket.layers[0],
            r = t.layout,
            o = t._unevaluatedLayout._values,
            c = {
              layoutIconSize: o["icon-size"].possiblyEvaluate(new ai(n.bucket.zoom + 1), n.canonical),
              layoutTextSize: o["text-size"].possiblyEvaluate(new ai(n.bucket.zoom + 1), n.canonical),
              textMaxSize: o["text-size"].possiblyEvaluate(new ai(18))
            };
          if (n.bucket.textSizeData.kind === "composite") {
            const {
              minZoom: P,
              maxZoom: M
            } = n.bucket.textSizeData;
            c.compositeTextSizes = [o["text-size"].possiblyEvaluate(new ai(P), n.canonical), o["text-size"].possiblyEvaluate(new ai(M), n.canonical)]
          }
          if (n.bucket.iconSizeData.kind === "composite") {
            const {
              minZoom: P,
              maxZoom: M
            } = n.bucket.iconSizeData;
            c.compositeIconSizes = [o["icon-size"].possiblyEvaluate(new ai(P), n.canonical), o["icon-size"].possiblyEvaluate(new ai(M), n.canonical)]
          }
          const f = r.get("text-line-height") * Hi,
            g = r.get("text-rotation-alignment") !== "viewport" && r.get("symbol-placement") !== "point",
            y = r.get("text-keep-upright"),
            w = r.get("text-size");
          for (const P of n.bucket.features) {
            const M = r.get("text-font").evaluate(P, {}, n.canonical).join(","),
              R = w.evaluate(P, {}, n.canonical),
              U = c.layoutTextSize.evaluate(P, {}, n.canonical),
              G = c.layoutIconSize.evaluate(P, {}, n.canonical),
              W = {
                horizontal: {},
                vertical: void 0
              },
              ne = P.text;
            let se, ge = [0, 0];
            if (ne) {
              const De = ne.toString(),
                nt = r.get("text-letter-spacing").evaluate(P, {}, n.canonical) * Hi,
                gt = bu(De) ? nt : 0,
                Vt = r.get("text-anchor").evaluate(P, {}, n.canonical),
                pr = bv(t, P, n.canonical);
              if (!pr) {
                const lr = r.get("text-radial-offset").evaluate(P, {}, n.canonical);
                ge = lr ? xv(Vt, [lr * Hi, tm]) : r.get("text-offset").evaluate(P, {}, n.canonical).map((hr => hr * Hi))
              }
              let ir = g ? "center" : r.get("text-justify").evaluate(P, {}, n.canonical);
              const ur = r.get("symbol-placement") === "point" ? r.get("text-max-width").evaluate(P, {}, n.canonical) * Hi : 1 / 0,
                Kr = () => {
                  n.bucket.allowVerticalPlacement && xu(De) && (W.vertical = lp(ne, n.glyphMap, n.glyphPositions, n.imagePositions, M, ur, f, Vt, "left", gt, ge, b.as.vertical, !0, U, R))
                };
              if (!g && pr) {
                const lr = new Set;
                if (ir === "auto")
                  for (let Ct = 0; Ct < pr.values.length; Ct += 2) lr.add(rm(pr.values[Ct]));
                else lr.add(ir);
                let hr = !1;
                for (const Ct of lr)
                  if (!W.horizontal[Ct])
                    if (hr) W.horizontal[Ct] = W.horizontal[0];
                    else {
                      const un = lp(ne, n.glyphMap, n.glyphPositions, n.imagePositions, M, ur, f, "center", Ct, gt, ge, b.as.horizontal, !1, U, R);
                      un && (W.horizontal[Ct] = un, hr = un.positionedLines.length === 1)
                    } Kr()
              } else {
                ir === "auto" && (ir = rm(Vt));
                const lr = lp(ne, n.glyphMap, n.glyphPositions, n.imagePositions, M, ur, f, Vt, ir, gt, ge, b.as.horizontal, !1, U, R);
                lr && (W.horizontal[ir] = lr), Kr(), xu(De) && g && y && (W.vertical = lp(ne, n.glyphMap, n.glyphPositions, n.imagePositions, M, ur, f, Vt, ir, gt, ge, b.as.vertical, !1, U, R))
              }
            }
            let We = !1;
            if (P.icon && P.icon.name) {
              const De = n.imageMap[P.icon.name];
              De && (se = Tx(n.imagePositions[P.icon.name], r.get("icon-offset").evaluate(P, {}, n.canonical), r.get("icon-anchor").evaluate(P, {}, n.canonical)), We = !!De.sdf, n.bucket.sdfIcons === void 0 ? n.bucket.sdfIcons = We : n.bucket.sdfIcons !== We && Wt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (De.pixelRatio !== n.bucket.pixelRatio || r.get("icon-rotate").constantOr(1) !== 0) && (n.bucket.iconsNeedLinear = !0))
            }
            const Te = Tv(W.horizontal) || W.vertical;
            n.bucket.iconsInText = !!Te && Te.iconsInText, (Te || se) && Bx(n.bucket, P, W, se, n.imageMap, c, U, G, ge, We, n.canonical, n.subdivisionGranularity)
          }
          n.showCollisionBoxes && n.bucket.generateCollisionDebugBuffers()
        }, b.cL = Nf, b.cM = qf, b.cN = Vf, b.cO = C_, b.cP = Zf, b.cQ = class {
          constructor(n) {
            this._marks = {
              start: [n.url, "start"].join("#"),
              end: [n.url, "end"].join("#"),
              measure: n.url.toString()
            }, performance.mark(this._marks.start)
          }
          finish() {
            performance.mark(this._marks.end);
            let n = performance.getEntriesByName(this._marks.measure);
            return n.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), n = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), n
          }
        }, b.cR = function(n, t, r, o, c) {
          return s(this, void 0, void 0, (function*() {
            if (Me()) try {
              return yield Lr(n, t, r, o, c)
            } catch {}
            return (function(f, g, y, w, P) {
              const M = f.width,
                R = f.height;
              Ir && Jr || (Ir = new OffscreenCanvas(M, R), Jr = Ir.getContext("2d", {
                willReadFrequently: !0
              })), Ir.width = M, Ir.height = R, Jr.drawImage(f, 0, 0, M, R);
              const U = Jr.getImageData(g, y, w, P);
              return Jr.clearRect(0, 0, M, R), U.data
            })(n, t, r, o, c)
          }))
        }, b.cS = f_, b.cT = q, b.cU = P_, b.cV = mc, b.cW = Jo, b.cX = function(n, t) {
          const r = new Map;
          if (n != null)
            if (n.type === "Feature") r.set(Hu(n, t), n);
            else
              for (const o of n.features) r.set(Hu(o, t), o);
          return r
        }, b.cY = function(n, t) {
          if (n == null) return !0;
          if (n.type === "Feature") return Hu(n, t) != null;
          if (n.type === "FeatureCollection") {
            const r = new Set;
            for (const o of n.features) {
              const c = Hu(o, t);
              if (c == null || r.has(c)) return !1;
              r.add(c)
            }
            return !0
          }
          return !1
        }, b.cZ = function(n, t, r) {
          var o, c, f, g;
          if (t.removeAll && n.clear(), t.remove)
            for (const y of t.remove) n.delete(y);
          if (t.add)
            for (const y of t.add) {
              const w = Hu(y, r);
              w != null && n.set(w, y)
            }
          if (t.update)
            for (const y of t.update) {
              let w = n.get(y.id);
              if (w == null) continue;
              const P = !y.removeAllProperties && (((o = y.removeProperties) === null || o === void 0 ? void 0 : o.length) > 0 || ((c = y.addOrUpdateProperties) === null || c === void 0 ? void 0 : c.length) > 0);
              if ((y.newGeometry || y.removeAllProperties || P) && (w = Object.assign({}, w), n.set(y.id, w), P && (w.properties = Object.assign({}, w.properties))), y.newGeometry && (w.geometry = y.newGeometry), y.removeAllProperties) w.properties = {};
              else if (((f = y.removeProperties) === null || f === void 0 ? void 0 : f.length) > 0)
                for (const M of y.removeProperties) Object.prototype.hasOwnProperty.call(w.properties, M) && delete w.properties[M];
              if (((g = y.addOrUpdateProperties) === null || g === void 0 ? void 0 : g.length) > 0)
                for (const {
                    key: M,
                    value: R
                  }
                  of y.addOrUpdateProperties) w.properties[M] = R
            }
        }, b.c_ = _o, b.ca = class extends Iu {}, b.cb = class extends u {}, b.cc = function(n, t) {
          return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] && n[4] === t[4] && n[5] === t[5] && n[6] === t[6] && n[7] === t[7] && n[8] === t[8] && n[9] === t[9] && n[10] === t[10] && n[11] === t[11] && n[12] === t[12] && n[13] === t[13] && n[14] === t[14] && n[15] === t[15]
        }, b.cd = function(n, t) {
          var r = n[0],
            o = n[1],
            c = n[2],
            f = n[3],
            g = n[4],
            y = n[5],
            w = n[6],
            P = n[7],
            M = n[8],
            R = n[9],
            U = n[10],
            G = n[11],
            W = n[12],
            ne = n[13],
            se = n[14],
            ge = n[15],
            We = t[0],
            Te = t[1],
            De = t[2],
            nt = t[3],
            gt = t[4],
            Vt = t[5],
            pr = t[6],
            ir = t[7],
            ur = t[8],
            Kr = t[9],
            lr = t[10],
            hr = t[11],
            Ct = t[12],
            un = t[13],
            yn = t[14],
            rn = t[15];
          return Math.abs(r - We) <= Pe * Math.max(1, Math.abs(r), Math.abs(We)) && Math.abs(o - Te) <= Pe * Math.max(1, Math.abs(o), Math.abs(Te)) && Math.abs(c - De) <= Pe * Math.max(1, Math.abs(c), Math.abs(De)) && Math.abs(f - nt) <= Pe * Math.max(1, Math.abs(f), Math.abs(nt)) && Math.abs(g - gt) <= Pe * Math.max(1, Math.abs(g), Math.abs(gt)) && Math.abs(y - Vt) <= Pe * Math.max(1, Math.abs(y), Math.abs(Vt)) && Math.abs(w - pr) <= Pe * Math.max(1, Math.abs(w), Math.abs(pr)) && Math.abs(P - ir) <= Pe * Math.max(1, Math.abs(P), Math.abs(ir)) && Math.abs(M - ur) <= Pe * Math.max(1, Math.abs(M), Math.abs(ur)) && Math.abs(R - Kr) <= Pe * Math.max(1, Math.abs(R), Math.abs(Kr)) && Math.abs(U - lr) <= Pe * Math.max(1, Math.abs(U), Math.abs(lr)) && Math.abs(G - hr) <= Pe * Math.max(1, Math.abs(G), Math.abs(hr)) && Math.abs(W - Ct) <= Pe * Math.max(1, Math.abs(W), Math.abs(Ct)) && Math.abs(ne - un) <= Pe * Math.max(1, Math.abs(ne), Math.abs(un)) && Math.abs(se - yn) <= Pe * Math.max(1, Math.abs(se), Math.abs(yn)) && Math.abs(ge - rn) <= Pe * Math.max(1, Math.abs(ge), Math.abs(rn))
        }, b.ce = function(n, t) {
          return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n
        }, b.cf = n => n.type === "symbol", b.cg = n => n.type === "circle", b.ch = n => n.type === "heatmap", b.ci = n => n.type === "line", b.cj = n => n.type === "fill", b.ck = n => n.type === "fill-extrusion", b.cl = n => n.type === "hillshade", b.cm = n => n.type === "color-relief", b.cn = n => n.type === "background", b.co = n => n.type === "custom", b.cp = yt, b.cq = function(n, t, r) {
          const o = wt(t.x - r.x, t.y - r.y),
            c = wt(n.x - r.x, n.y - r.y);
          var f, g;
          return xr(Math.atan2(o[0] * c[1] - o[1] * c[0], (f = o)[0] * (g = c)[0] + f[1] * g[1]))
        }, b.cr = sr, b.cs = function(n, t) {
          return Yr[t] && (n instanceof MouseEvent || n instanceof WheelEvent)
        }, b.ct = function(n, t) {
          return qt[t] && "touches" in n
        }, b.cu = function(n) {
          return qt[n] || Yr[n]
        }, b.cv = function(n, t, r) {
          var o = t[0],
            c = t[1];
          return n[0] = r[0] * o + r[4] * c + r[12], n[1] = r[1] * o + r[5] * c + r[13], n
        }, b.cw = function(n, t) {
          const {
            x: r,
            y: o
          } = Gu.fromLngLat(t);
          return !(n < 0 || n > 25 || o < 0 || o >= 1 || r < 0 || r >= 1)
        }, b.cx = function(n, t) {
          return n[0] = t[0], n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = t[1], n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = t[2], n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n
        }, b.cy = class extends rc {}, b.cz = Nx, b.d = be, b.e = ht, b.f = n => s(void 0, void 0, void 0, (function*() {
          if (n.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(n)], {
            type: "image/png"
          });
          try {
            return createImageBitmap(t)
          } catch (r) {
            throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
          }
        })), b.g = D, b.h = n => new Promise(((t, r) => {
          const o = new Image;
          o.onload = () => {
            t(o), URL.revokeObjectURL(o.src), o.onload = null, window.requestAnimationFrame((() => {
              o.src = Yt
            }))
          }, o.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const c = new Blob([new Uint8Array(n)], {
            type: "image/png"
          });
          o.src = n.byteLength ? URL.createObjectURL(c) : Yt
        })), b.i = jt, b.j = (n, t) => pe(ht(n, {
          type: "json"
        }), t), b.k = K, b.l = oe, b.m = pe, b.n = (n, t) => pe(ht(n, {
          type: "arrayBuffer"
        }), t), b.o = function(n) {
          return new Zf(n).readFields(dx, [])
        }, b.p = N_, b.q = Du, b.r = na, b.s = Tr, b.t = Q, b.u = Dn, b.v = Rd, b.w = Wt, b.x = Hd, b.y = Tf, b.z = Bd
      })), A("worker", ["./shared"], (function(b) {
        class s {
          constructor(E, D) {
            this.keyCache = {}, E && this.replace(E, D)
          }
          replace(E, D) {
            this._layerConfigs = {}, this._layers = {}, this.update(E, [], D)
          }
          update(E, D, N) {
            for (const ee of E) {
              this._layerConfigs[ee.id] = ee;
              const pe = this._layers[ee.id] = b.bM(ee, N);
              pe._featureFilter = b.ae(pe.filter, N), this.keyCache[ee.id] && delete this.keyCache[ee.id]
            }
            for (const ee of D) delete this.keyCache[ee], delete this._layerConfigs[ee], delete this._layers[ee];
            this.familiesBySource = {};
            const X = b.cF(Object.values(this._layerConfigs), this.keyCache);
            for (const ee of X) {
              const pe = ee.map((he => this._layers[he.id])),
                be = pe[0];
              if (be.visibility === "none") continue;
              const ye = be.source || "";
              let Oe = this.familiesBySource[ye];
              Oe || (Oe = this.familiesBySource[ye] = {});
              const oe = be.sourceLayer || "_geojsonTileLayer";
              let K = Oe[oe];
              K || (K = Oe[oe] = []), K.push(pe)
            }
          }
        }
        class F {
          constructor(E) {
            const D = {},
              N = [];
            for (const be in E) {
              const ye = E[be],
                Oe = D[be] = {};
              for (const oe in ye) {
                const K = ye[+oe];
                if (!K || K.bitmap.width === 0 || K.bitmap.height === 0) continue;
                const he = {
                  x: 0,
                  y: 0,
                  w: K.bitmap.width + 2,
                  h: K.bitmap.height + 2
                };
                N.push(he), Oe[oe] = {
                  rect: he,
                  metrics: K.metrics
                }
              }
            }
            const {
              w: X,
              h: ee
            } = b.p(N), pe = new b.q({
              width: X || 1,
              height: ee || 1
            });
            for (const be in E) {
              const ye = E[be];
              for (const Oe in ye) {
                const oe = ye[+Oe];
                if (!oe || oe.bitmap.width === 0 || oe.bitmap.height === 0) continue;
                const K = D[be][Oe].rect;
                b.q.copy(oe.bitmap, pe, {
                  x: 0,
                  y: 0
                }, {
                  x: K.x + 1,
                  y: K.y + 1
                }, oe.bitmap)
              }
            }
            this.image = pe, this.positions = D
          }
        }
        b.cG("GlyphAtlas", F);
        class q {
          constructor(E) {
            this.tileID = new b.a0(E.tileID.overscaledZ, E.tileID.wrap, E.tileID.canonical.z, E.tileID.canonical.x, E.tileID.canonical.y), this.uid = E.uid, this.zoom = E.zoom, this.pixelRatio = E.pixelRatio, this.tileSize = E.tileSize, this.source = E.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = E.showCollisionBoxes, this.collectResourceTiming = !!E.collectResourceTiming, this.returnDependencies = !!E.returnDependencies, this.promoteId = E.promoteId, this.inFlightDependencies = []
          }
          parse(E, D, N, X, ee) {
            return b._(this, void 0, void 0, (function*() {
              this.status = "parsing", this.data = E, this.collisionBoxArray = new b.ac;
              const pe = new b.cH(Object.keys(E.layers).sort()),
                be = new b.cI(this.tileID, this.promoteId);
              be.bucketLayerIDs = [];
              const ye = {},
                Oe = {
                  featureIndex: be,
                  iconDependencies: {},
                  patternDependencies: {},
                  glyphDependencies: {},
                  dashDependencies: {},
                  availableImages: N,
                  subdivisionGranularity: ee
                },
                oe = D.familiesBySource[this.source];
              for (const Ze in oe) {
                const Pr = E.layers[Ze];
                if (!Pr) continue;
                Pr.version === 1 && b.w(`Vector tile source "${this.source}" layer "${Ze}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const br = pe.encode(Ze),
                  Rr = [];
                for (let Dr = 0; Dr < Pr.length; Dr++) {
                  const ot = Pr.feature(Dr),
                    dr = be.getId(ot, Ze);
                  Rr.push({
                    feature: ot,
                    id: dr,
                    index: Dr,
                    sourceLayerIndex: br
                  })
                }
                for (const Dr of oe[Ze]) {
                  const ot = Dr[0];
                  ot.source !== this.source && b.w(`layer.source = ${ot.source} does not equal this.source = ${this.source}`), ot.isHidden(this.zoom, !0) || (J(Dr, this.zoom, N), (ye[ot.id] = ot.createBucket({
                    index: be.bucketLayerIDs.length,
                    layers: Dr,
                    zoom: this.zoom,
                    pixelRatio: this.pixelRatio,
                    overscaling: this.overscaling,
                    collisionBoxArray: this.collisionBoxArray,
                    sourceLayerIndex: br,
                    sourceID: this.source
                  })).populate(Rr, Oe, this.tileID.canonical), be.bucketLayerIDs.push(Dr.map((dr => dr.id))))
                }
              }
              const K = b.bR(Oe.glyphDependencies, (Ze => Object.keys(Ze).map(Number)));
              this.inFlightDependencies.forEach((Ze => Ze == null ? void 0 : Ze.abort())), this.inFlightDependencies = [];
              let he = Promise.resolve({});
              if (Object.keys(K).length) {
                const Ze = new AbortController;
                this.inFlightDependencies.push(Ze), he = X.sendAsync({
                  type: "GG",
                  data: {
                    stacks: K,
                    source: this.source,
                    tileID: this.tileID,
                    type: "glyphs"
                  }
                }, Ze)
              }
              const Q = Object.keys(Oe.iconDependencies);
              let ze = Promise.resolve({});
              if (Q.length) {
                const Ze = new AbortController;
                this.inFlightDependencies.push(Ze), ze = X.sendAsync({
                  type: "GI",
                  data: {
                    icons: Q,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                  }
                }, Ze)
              }
              const $e = Object.keys(Oe.patternDependencies);
              let Re = Promise.resolve({});
              if ($e.length) {
                const Ze = new AbortController;
                this.inFlightDependencies.push(Ze), Re = X.sendAsync({
                  type: "GI",
                  data: {
                    icons: $e,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                  }
                }, Ze)
              }
              const ft = Oe.dashDependencies;
              let Mt = Promise.resolve({});
              if (Object.keys(ft).length) {
                const Ze = new AbortController;
                this.inFlightDependencies.push(Ze), Mt = X.sendAsync({
                  type: "GDA",
                  data: {
                    dashes: ft
                  }
                }, Ze)
              }
              const [Et, dt, Kt, Qt] = yield Promise.all([he, ze, Re, Mt]), Sr = new F(Et), Ft = new b.cJ(dt, Kt);
              for (const Ze in ye) {
                const Pr = ye[Ze];
                Pr instanceof b.ad ? (J(Pr.layers, this.zoom, N), b.cK({
                  bucket: Pr,
                  glyphMap: Et,
                  glyphPositions: Sr.positions,
                  imageMap: dt,
                  imagePositions: Ft.iconPositions,
                  showCollisionBoxes: this.showCollisionBoxes,
                  canonical: this.tileID.canonical,
                  subdivisionGranularity: Oe.subdivisionGranularity
                })) : Pr.hasDependencies && (Pr instanceof b.cL || Pr instanceof b.cM || Pr instanceof b.cN) && (J(Pr.layers, this.zoom, N), Pr.addFeatures(Oe, this.tileID.canonical, Ft.patternPositions, Qt))
              }
              return this.status = "done", {
                buckets: Object.values(ye).filter((Ze => !Ze.isEmpty())),
                featureIndex: be,
                collisionBoxArray: this.collisionBoxArray,
                glyphAtlasImage: Sr.image,
                imageAtlas: Ft,
                dashPositions: Qt,
                glyphMap: this.returnDependencies ? Et : null,
                iconMap: this.returnDependencies ? dt : null,
                glyphPositions: this.returnDependencies ? Sr.positions : null
              }
            }))
          }
        }

        function J(j, E, D) {
          const N = new b.G(E);
          for (const X of j) X.recalculate(N, D)
        }
        class te {
          constructor(E, D, N) {
            this.actor = E, this.layerIndex = D, this.availableImages = N, this.fetching = {}, this.loading = {}, this.loaded = {}
          }
          loadVectorTile(E, D) {
            return b._(this, void 0, void 0, (function*() {
              const N = yield b.n(E.request, D);
              try {
                return {
                  vectorTile: new b.cO(new b.cP(N.data)),
                  rawData: N.data,
                  cacheControl: N.cacheControl,
                  expires: N.expires
                }
              } catch (X) {
                const ee = new Uint8Array(N.data);
                let pe = `Unable to parse the tile at ${E.request.url}, `;
                throw pe += ee[0] === 31 && ee[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${X.message}`, new Error(pe)
              }
            }))
          }
          loadTile(E) {
            return b._(this, void 0, void 0, (function*() {
              const D = E.uid,
                N = !!(E && E.request && E.request.collectResourceTiming) && new b.cQ(E.request),
                X = new q(E);
              this.loading[D] = X;
              const ee = new AbortController;
              X.abort = ee;
              try {
                const pe = yield this.loadVectorTile(E, ee);
                if (delete this.loading[D], !pe) return null;
                const be = pe.rawData,
                  ye = {};
                pe.expires && (ye.expires = pe.expires), pe.cacheControl && (ye.cacheControl = pe.cacheControl);
                const Oe = {};
                if (N) {
                  const K = N.finish();
                  K && (Oe.resourceTiming = JSON.parse(JSON.stringify(K)))
                }
                X.vectorTile = pe.vectorTile;
                const oe = X.parse(pe.vectorTile, this.layerIndex, this.availableImages, this.actor, E.subdivisionGranularity);
                this.loaded[D] = X, this.fetching[D] = {
                  rawTileData: be,
                  cacheControl: ye,
                  resourceTiming: Oe
                };
                try {
                  const K = yield oe;
                  return b.e({
                    rawTileData: be.slice(0)
                  }, K, ye, Oe)
                } finally {
                  delete this.fetching[D]
                }
              } catch (pe) {
                throw delete this.loading[D], X.status = "done", this.loaded[D] = X, pe
              }
            }))
          }
          reloadTile(E) {
            return b._(this, void 0, void 0, (function*() {
              const D = E.uid;
              if (!this.loaded || !this.loaded[D]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const N = this.loaded[D];
              if (N.showCollisionBoxes = E.showCollisionBoxes, N.status === "parsing") {
                const X = yield N.parse(N.vectorTile, this.layerIndex, this.availableImages, this.actor, E.subdivisionGranularity);
                let ee;
                if (this.fetching[D]) {
                  const {
                    rawTileData: pe,
                    cacheControl: be,
                    resourceTiming: ye
                  } = this.fetching[D];
                  delete this.fetching[D], ee = b.e({
                    rawTileData: pe.slice(0)
                  }, X, be, ye)
                } else ee = X;
                return ee
              }
              if (N.status === "done" && N.vectorTile) return N.parse(N.vectorTile, this.layerIndex, this.availableImages, this.actor, E.subdivisionGranularity)
            }))
          }
          abortTile(E) {
            return b._(this, void 0, void 0, (function*() {
              const D = this.loading,
                N = E.uid;
              D && D[N] && D[N].abort && (D[N].abort.abort(), delete D[N])
            }))
          }
          removeTile(E) {
            return b._(this, void 0, void 0, (function*() {
              this.loaded && this.loaded[E.uid] && delete this.loaded[E.uid]
            }))
          }
        }
        class ae {
          constructor() {
            this.loaded = {}
          }
          loadTile(E) {
            return b._(this, void 0, void 0, (function*() {
              const {
                uid: D,
                encoding: N,
                rawImageData: X,
                redFactor: ee,
                greenFactor: pe,
                blueFactor: be,
                baseShift: ye
              } = E, Oe = X.width + 2, oe = X.height + 2, K = b.b(X) ? new b.R({
                width: Oe,
                height: oe
              }, yield b.cR(X, -1, -1, Oe, oe)) : X, he = new b.cS(D, K, N, ee, pe, be, ye);
              return this.loaded = this.loaded || {}, this.loaded[D] = he, he
            }))
          }
          removeTile(E) {
            const D = this.loaded,
              N = E.uid;
            D && D[N] && delete D[N]
          }
        }
        var fe, ie, $ = (function() {
            if (ie) return fe;

            function j(D, N) {
              if (D.length !== 0) {
                E(D[0], N);
                for (var X = 1; X < D.length; X++) E(D[X], !N)
              }
            }

            function E(D, N) {
              for (var X = 0, ee = 0, pe = 0, be = D.length, ye = be - 1; pe < be; ye = pe++) {
                var Oe = (D[pe][0] - D[ye][0]) * (D[ye][1] + D[pe][1]),
                  oe = X + Oe;
                ee += Math.abs(X) >= Math.abs(Oe) ? X - oe + Oe : Oe - oe + X, X = oe
              }
              X + ee >= 0 != !!N && D.reverse()
            }
            return ie = 1, fe = function D(N, X) {
              var ee, pe = N && N.type;
              if (pe === "FeatureCollection")
                for (ee = 0; ee < N.features.length; ee++) D(N.features[ee], X);
              else if (pe === "GeometryCollection")
                for (ee = 0; ee < N.geometries.length; ee++) D(N.geometries[ee], X);
              else if (pe === "Feature") D(N.geometry, X);
              else if (pe === "Polygon") j(N.coordinates, X);
              else if (pe === "MultiPolygon")
                for (ee = 0; ee < N.coordinates.length; ee++) j(N.coordinates[ee], X);
              return N
            }
          })(),
          Se = b.cT($);
        class Me extends b.cV {
          constructor(E, D) {
            super(new b.cP, 0, D, [], []), this.feature = E, this.type = E.type, this.properties = E.tags ? E.tags : {}, "id" in E && (typeof E.id == "string" ? this.id = parseInt(E.id, 10) : typeof E.id != "number" || isNaN(E.id) || (this.id = E.id))
          }
          loadGeometry() {
            const E = [],
              D = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const N of D) {
              const X = [];
              for (const ee of N) X.push(new b.P(ee[0], ee[1]));
              E.push(X)
            }
            return E
          }
        }
        class Pe extends b.cU {
          constructor(E, D) {
            super(new b.cP), this.layers = {
              _geojsonTileLayer: this
            }, this.name = "_geojsonTileLayer", this.version = D ? D.version : 1, this.extent = D ? D.extent : 4096, this.length = E.length, this.features = E
          }
          feature(E) {
            return new Me(this.features[E], this.extent)
          }
        }

        function Ie(j, E) {
          E.writeVarintField(15, j.version || 1), E.writeStringField(1, j.name || ""), E.writeVarintField(5, j.extent || 4096);
          const D = {
            keys: [],
            values: [],
            keycache: {},
            valuecache: {}
          };
          for (let ee = 0; ee < j.length; ee++) D.feature = j.feature(ee), E.writeMessage(2, Ce, D);
          const N = D.keys;
          for (const ee of N) E.writeStringField(3, ee);
          const X = D.values;
          for (const ee of X) E.writeMessage(4, He, ee)
        }

        function Ce(j, E) {
          if (!j.feature) return;
          const D = j.feature;
          D.id !== void 0 && E.writeVarintField(1, D.id), E.writeMessage(2, je, j), E.writeVarintField(3, D.type), E.writeMessage(4, Be, D)
        }

        function je(j, E) {
          var D;
          for (const N in (D = j.feature) == null ? void 0 : D.properties) {
            let X = j.feature.properties[N],
              ee = j.keycache[N];
            if (X === null) continue;
            ee === void 0 && (j.keys.push(N), ee = j.keys.length - 1, j.keycache[N] = ee), E.writeVarint(ee), typeof X != "string" && typeof X != "boolean" && typeof X != "number" && (X = JSON.stringify(X));
            const pe = typeof X + ":" + X;
            let be = j.valuecache[pe];
            be === void 0 && (j.values.push(X), be = j.values.length - 1, j.valuecache[pe] = be), E.writeVarint(be)
          }
        }

        function Ye(j, E) {
          return (E << 3) + (7 & j)
        }

        function qe(j) {
          return j << 1 ^ j >> 31
        }

        function Be(j, E) {
          const D = j.loadGeometry(),
            N = j.type;
          let X = 0,
            ee = 0;
          for (const pe of D) {
            let be = 1;
            N === 1 && (be = pe.length), E.writeVarint(Ye(1, be));
            const ye = N === 3 ? pe.length - 1 : pe.length;
            for (let Oe = 0; Oe < ye; Oe++) {
              Oe === 1 && N !== 1 && E.writeVarint(Ye(2, ye - 1));
              const oe = pe[Oe].x - X,
                K = pe[Oe].y - ee;
              E.writeVarint(qe(oe)), E.writeVarint(qe(K)), X += oe, ee += K
            }
            j.type === 3 && E.writeVarint(Ye(7, 1))
          }
        }

        function He(j, E) {
          const D = typeof j;
          D === "string" ? E.writeStringField(1, j) : D === "boolean" ? E.writeBooleanField(7, j) : D === "number" && (j % 1 != 0 ? E.writeDoubleField(3, j) : j < 0 ? E.writeSVarintField(6, j) : E.writeVarintField(5, j))
        }
        const we = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: j => j
          },
          it = Math.fround || (mt = new Float32Array(1), j => (mt[0] = +j, mt[0]));
        var mt;
        class Ge {
          constructor(E) {
            this.options = Object.assign(Object.create(we), E), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []
          }
          load(E) {
            const {
              log: D,
              minZoom: N,
              maxZoom: X
            } = this.options;
            D && console.time("total time");
            const ee = `prepare ${E.length} points`;
            D && console.time(ee), this.points = E;
            const pe = [];
            for (let ye = 0; ye < E.length; ye++) {
              const Oe = E[ye];
              if (!Oe.geometry) continue;
              const [oe, K] = Oe.geometry.coordinates, he = it(Ut(oe)), Q = it(_t(K));
              pe.push(he, Q, 1 / 0, ye, -1, 1), this.options.reduce && pe.push(0)
            }
            let be = this.trees[X + 1] = this._createTree(pe);
            D && console.timeEnd(ee);
            for (let ye = X; ye >= N; ye--) {
              const Oe = +Date.now();
              be = this.trees[ye] = this._createTree(this._cluster(be, ye)), D && console.log("z%d: %d clusters in %dms", ye, be.numItems, +Date.now() - Oe)
            }
            return D && console.timeEnd("total time"), this
          }
          getClusters(E, D) {
            let N = ((E[0] + 180) % 360 + 360) % 360 - 180;
            const X = Math.max(-90, Math.min(90, E[1]));
            let ee = E[2] === 180 ? 180 : ((E[2] + 180) % 360 + 360) % 360 - 180;
            const pe = Math.max(-90, Math.min(90, E[3]));
            if (E[2] - E[0] >= 360) N = -180, ee = 180;
            else if (N > ee) {
              const K = this.getClusters([N, X, 180, pe], D),
                he = this.getClusters([-180, X, ee, pe], D);
              return K.concat(he)
            }
            const be = this.trees[this._limitZoom(D)],
              ye = be.range(Ut(N), _t(pe), Ut(ee), _t(X)),
              Oe = be.data,
              oe = [];
            for (const K of ye) {
              const he = this.stride * K;
              oe.push(Oe[he + 5] > 1 ? Xe(Oe, he, this.clusterProps) : this.points[Oe[he + 3]])
            }
            return oe
          }
          getChildren(E) {
            const D = this._getOriginId(E),
              N = this._getOriginZoom(E),
              X = "No cluster with the specified id.",
              ee = this.trees[N];
            if (!ee) throw new Error(X);
            const pe = ee.data;
            if (D * this.stride >= pe.length) throw new Error(X);
            const be = this.options.radius / (this.options.extent * Math.pow(2, N - 1)),
              ye = ee.within(pe[D * this.stride], pe[D * this.stride + 1], be),
              Oe = [];
            for (const oe of ye) {
              const K = oe * this.stride;
              pe[K + 4] === E && Oe.push(pe[K + 5] > 1 ? Xe(pe, K, this.clusterProps) : this.points[pe[K + 3]])
            }
            if (Oe.length === 0) throw new Error(X);
            return Oe
          }
          getLeaves(E, D, N) {
            const X = [];
            return this._appendLeaves(X, E, D = D || 10, N = N || 0, 0), X
          }
          getTile(E, D, N) {
            const X = this.trees[this._limitZoom(E)],
              ee = Math.pow(2, E),
              {
                extent: pe,
                radius: be
              } = this.options,
              ye = be / pe,
              Oe = (N - ye) / ee,
              oe = (N + 1 + ye) / ee,
              K = {
                features: []
              };
            return this._addTileFeatures(X.range((D - ye) / ee, Oe, (D + 1 + ye) / ee, oe), X.data, D, N, ee, K), D === 0 && this._addTileFeatures(X.range(1 - ye / ee, Oe, 1, oe), X.data, ee, N, ee, K), D === ee - 1 && this._addTileFeatures(X.range(0, Oe, ye / ee, oe), X.data, -1, N, ee, K), K.features.length ? K : null
          }
          getClusterExpansionZoom(E) {
            let D = this._getOriginZoom(E) - 1;
            for (; D <= this.options.maxZoom;) {
              const N = this.getChildren(E);
              if (D++, N.length !== 1) break;
              E = N[0].properties.cluster_id
            }
            return D
          }
          _appendLeaves(E, D, N, X, ee) {
            const pe = this.getChildren(D);
            for (const be of pe) {
              const ye = be.properties;
              if (ye && ye.cluster ? ee + ye.point_count <= X ? ee += ye.point_count : ee = this._appendLeaves(E, ye.cluster_id, N, X, ee) : ee < X ? ee++ : E.push(be), E.length === N) break
            }
            return ee
          }
          _createTree(E) {
            const D = new b.aM(E.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let N = 0; N < E.length; N += this.stride) D.add(E[N], E[N + 1]);
            return D.finish(), D.data = E, D
          }
          _addTileFeatures(E, D, N, X, ee, pe) {
            for (const be of E) {
              const ye = be * this.stride,
                Oe = D[ye + 5] > 1;
              let oe, K, he;
              if (Oe) oe = vt(D, ye, this.clusterProps), K = D[ye], he = D[ye + 1];
              else {
                const $e = this.points[D[ye + 3]];
                oe = $e.properties;
                const [Re, ft] = $e.geometry.coordinates;
                K = Ut(Re), he = _t(ft)
              }
              const Q = {
                type: 1,
                geometry: [
                  [Math.round(this.options.extent * (K * ee - N)), Math.round(this.options.extent * (he * ee - X))]
                ],
                tags: oe
              };
              let ze;
              ze = Oe || this.options.generateId ? D[ye + 3] : this.points[D[ye + 3]].id, ze !== void 0 && (Q.id = ze), pe.features.push(Q)
            }
          }
          _limitZoom(E) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+E), this.options.maxZoom + 1))
          }
          _cluster(E, D) {
            const {
              radius: N,
              extent: X,
              reduce: ee,
              minPoints: pe
            } = this.options, be = N / (X * Math.pow(2, D)), ye = E.data, Oe = [], oe = this.stride;
            for (let K = 0; K < ye.length; K += oe) {
              if (ye[K + 2] <= D) continue;
              ye[K + 2] = D;
              const he = ye[K],
                Q = ye[K + 1],
                ze = E.within(ye[K], ye[K + 1], be),
                $e = ye[K + 5];
              let Re = $e;
              for (const ft of ze) {
                const Mt = ft * oe;
                ye[Mt + 2] > D && (Re += ye[Mt + 5])
              }
              if (Re > $e && Re >= pe) {
                let ft, Mt = he * $e,
                  Et = Q * $e,
                  dt = -1;
                const Kt = (K / oe << 5) + (D + 1) + this.points.length;
                for (const Qt of ze) {
                  const Sr = Qt * oe;
                  if (ye[Sr + 2] <= D) continue;
                  ye[Sr + 2] = D;
                  const Ft = ye[Sr + 5];
                  Mt += ye[Sr] * Ft, Et += ye[Sr + 1] * Ft, ye[Sr + 4] = Kt, ee && (ft || (ft = this._map(ye, K, !0), dt = this.clusterProps.length, this.clusterProps.push(ft)), ee(ft, this._map(ye, Sr)))
                }
                ye[K + 4] = Kt, Oe.push(Mt / Re, Et / Re, 1 / 0, Kt, -1, Re), ee && Oe.push(dt)
              } else {
                for (let ft = 0; ft < oe; ft++) Oe.push(ye[K + ft]);
                if (Re > 1)
                  for (const ft of ze) {
                    const Mt = ft * oe;
                    if (!(ye[Mt + 2] <= D)) {
                      ye[Mt + 2] = D;
                      for (let Et = 0; Et < oe; Et++) Oe.push(ye[Mt + Et])
                    }
                  }
              }
            }
            return Oe
          }
          _getOriginId(E) {
            return E - this.points.length >> 5
          }
          _getOriginZoom(E) {
            return (E - this.points.length) % 32
          }
          _map(E, D, N) {
            if (E[D + 5] > 1) {
              const pe = this.clusterProps[E[D + 6]];
              return N ? Object.assign({}, pe) : pe
            }
            const X = this.points[E[D + 3]].properties,
              ee = this.options.map(X);
            return N && ee === X ? Object.assign({}, ee) : ee
          }
        }

        function Xe(j, E, D) {
          return {
            type: "Feature",
            id: j[E + 3],
            properties: vt(j, E, D),
            geometry: {
              type: "Point",
              coordinates: [(N = j[E], 360 * (N - .5)), wt(j[E + 1])]
            }
          };
          var N
        }

        function vt(j, E, D) {
          const N = j[E + 5],
            X = N >= 1e4 ? `${Math.round(N/1e3)}k` : N >= 1e3 ? Math.round(N / 100) / 10 + "k" : N,
            ee = j[E + 6],
            pe = ee === -1 ? {} : Object.assign({}, D[ee]);
          return Object.assign(pe, {
            cluster: !0,
            cluster_id: j[E + 3],
            point_count: N,
            point_count_abbreviated: X
          })
        }

        function Ut(j) {
          return j / 360 + .5
        }

        function _t(j) {
          const E = Math.sin(j * Math.PI / 180),
            D = .5 - .25 * Math.log((1 + E) / (1 - E)) / Math.PI;
          return D < 0 ? 0 : D > 1 ? 1 : D
        }

        function wt(j) {
          const E = (180 - 360 * j) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(E)) / Math.PI - 90
        }

        function Je(j, E, D, N) {
          let X = N;
          const ee = E + (D - E >> 1);
          let pe, be = D - E;
          const ye = j[E],
            Oe = j[E + 1],
            oe = j[D],
            K = j[D + 1];
          for (let he = E + 3; he < D; he += 3) {
            const Q = zt(j[he], j[he + 1], ye, Oe, oe, K);
            if (Q > X) pe = he, X = Q;
            else if (Q === X) {
              const ze = Math.abs(he - ee);
              ze < be && (pe = he, be = ze)
            }
          }
          X > N && (pe - E > 3 && Je(j, E, pe, N), j[pe + 2] = X, D - pe > 3 && Je(j, pe, D, N))
        }

        function zt(j, E, D, N, X, ee) {
          let pe = X - D,
            be = ee - N;
          if (pe !== 0 || be !== 0) {
            const ye = ((j - D) * pe + (E - N) * be) / (pe * pe + be * be);
            ye > 1 ? (D = X, N = ee) : ye > 0 && (D += pe * ye, N += be * ye)
          }
          return pe = j - D, be = E - N, pe * pe + be * be
        }

        function bt(j, E, D, N) {
          const X = {
            id: j ?? null,
            type: E,
            geometry: D,
            tags: N,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
          };
          if (E === "Point" || E === "MultiPoint" || E === "LineString") Rt(X, D);
          else if (E === "Polygon") Rt(X, D[0]);
          else if (E === "MultiLineString")
            for (const ee of D) Rt(X, ee);
          else if (E === "MultiPolygon")
            for (const ee of D) Rt(X, ee[0]);
          return X
        }

        function Rt(j, E) {
          for (let D = 0; D < E.length; D += 3) j.minX = Math.min(j.minX, E[D]), j.minY = Math.min(j.minY, E[D + 1]), j.maxX = Math.max(j.maxX, E[D]), j.maxY = Math.max(j.maxY, E[D + 1])
        }

        function Pt(j, E, D, N) {
          if (!E.geometry) return;
          const X = E.geometry.coordinates;
          if (X && X.length === 0) return;
          const ee = E.geometry.type,
            pe = Math.pow(D.tolerance / ((1 << D.maxZoom) * D.extent), 2);
          let be = [],
            ye = E.id;
          if (D.promoteId ? ye = E.properties[D.promoteId] : D.generateId && (ye = N || 0), ee === "Point") yt(X, be);
          else if (ee === "MultiPoint")
            for (const Oe of X) yt(Oe, be);
          else if (ee === "LineString") sr(X, be, pe, !1);
          else if (ee === "MultiLineString") {
            if (D.lineMetrics) {
              for (const Oe of X) be = [], sr(Oe, be, pe, !1), j.push(bt(ye, "LineString", be, E.properties));
              return
            }
            tr(X, be, pe, !1)
          } else if (ee === "Polygon") tr(X, be, pe, !0);
          else {
            if (ee !== "MultiPolygon") {
              if (ee === "GeometryCollection") {
                for (const Oe of E.geometry.geometries) Pt(j, {
                  id: ye,
                  geometry: Oe,
                  properties: E.properties
                }, D, N);
                return
              }
              throw new Error("Input data is not a valid GeoJSON object.")
            }
            for (const Oe of X) {
              const oe = [];
              tr(Oe, oe, pe, !0), be.push(oe)
            }
          }
          j.push(bt(ye, ee, be, E.properties))
        }

        function yt(j, E) {
          E.push(tt(j[0]), ht(j[1]), 0)
        }

        function sr(j, E, D, N) {
          let X, ee, pe = 0;
          for (let ye = 0; ye < j.length; ye++) {
            const Oe = tt(j[ye][0]),
              oe = ht(j[ye][1]);
            E.push(Oe, oe, 0), ye > 0 && (pe += N ? (X * oe - Oe * ee) / 2 : Math.sqrt(Math.pow(Oe - X, 2) + Math.pow(oe - ee, 2))), X = Oe, ee = oe
          }
          const be = E.length - 3;
          E[2] = 1, Je(E, 0, be, D), E[be + 2] = 1, E.size = Math.abs(pe), E.start = 0, E.end = E.size
        }

        function tr(j, E, D, N) {
          for (let X = 0; X < j.length; X++) {
            const ee = [];
            sr(j[X], ee, D, N), E.push(ee)
          }
        }

        function tt(j) {
          return j / 360 + .5
        }

        function ht(j) {
          const E = Math.sin(j * Math.PI / 180),
            D = .5 - .25 * Math.log((1 + E) / (1 - E)) / Math.PI;
          return D < 0 ? 0 : D > 1 ? 1 : D
        }

        function It(j, E, D, N, X, ee, pe, be) {
          if (N /= E, ee >= (D /= E) && pe < N) return j;
          if (pe < D || ee >= N) return null;
          const ye = [];
          for (const Oe of j) {
            const oe = Oe.geometry;
            let K = Oe.type;
            const he = X === 0 ? Oe.minX : Oe.minY,
              Q = X === 0 ? Oe.maxX : Oe.maxY;
            if (he >= D && Q < N) {
              ye.push(Oe);
              continue
            }
            if (Q < D || he >= N) continue;
            let ze = [];
            if (K === "Point" || K === "MultiPoint") Bt(oe, ze, D, N, X);
            else if (K === "LineString") Nt(oe, ze, D, N, X, !1, be.lineMetrics);
            else if (K === "MultiLineString") yr(oe, ze, D, N, X, !1);
            else if (K === "Polygon") yr(oe, ze, D, N, X, !0);
            else if (K === "MultiPolygon")
              for (const $e of oe) {
                const Re = [];
                yr($e, Re, D, N, X, !0), Re.length && ze.push(Re)
              }
            if (ze.length) {
              if (be.lineMetrics && K === "LineString") {
                for (const $e of ze) ye.push(bt(Oe.id, K, $e, Oe.tags));
                continue
              }
              K !== "LineString" && K !== "MultiLineString" || (ze.length === 1 ? (K = "LineString", ze = ze[0]) : K = "MultiLineString"), K !== "Point" && K !== "MultiPoint" || (K = ze.length === 3 ? "Point" : "MultiPoint"), ye.push(bt(Oe.id, K, ze, Oe.tags))
            }
          }
          return ye.length ? ye : null
        }

        function Bt(j, E, D, N, X) {
          for (let ee = 0; ee < j.length; ee += 3) {
            const pe = j[ee + X];
            pe >= D && pe <= N && Wt(E, j[ee], j[ee + 1], j[ee + 2])
          }
        }

        function Nt(j, E, D, N, X, ee, pe) {
          let be = Ht(j);
          const ye = X === 0 ? Zt : jt;
          let Oe, oe, K = j.start;
          for (let Re = 0; Re < j.length - 3; Re += 3) {
            const ft = j[Re],
              Mt = j[Re + 1],
              Et = j[Re + 2],
              dt = j[Re + 3],
              Kt = j[Re + 4],
              Qt = X === 0 ? ft : Mt,
              Sr = X === 0 ? dt : Kt;
            let Ft = !1;
            pe && (Oe = Math.sqrt(Math.pow(ft - dt, 2) + Math.pow(Mt - Kt, 2))), Qt < D ? Sr > D && (oe = ye(be, ft, Mt, dt, Kt, D), pe && (be.start = K + Oe * oe)) : Qt > N ? Sr < N && (oe = ye(be, ft, Mt, dt, Kt, N), pe && (be.start = K + Oe * oe)) : Wt(be, ft, Mt, Et), Sr < D && Qt >= D && (oe = ye(be, ft, Mt, dt, Kt, D), Ft = !0), Sr > N && Qt <= N && (oe = ye(be, ft, Mt, dt, Kt, N), Ft = !0), !ee && Ft && (pe && (be.end = K + Oe * oe), E.push(be), be = Ht(j)), pe && (K += Oe)
          }
          let he = j.length - 3;
          const Q = j[he],
            ze = j[he + 1],
            $e = X === 0 ? Q : ze;
          $e >= D && $e <= N && Wt(be, Q, ze, j[he + 2]), he = be.length - 3, ee && he >= 3 && (be[he] !== be[0] || be[he + 1] !== be[1]) && Wt(be, be[0], be[1], be[2]), be.length && E.push(be)
        }

        function Ht(j) {
          const E = [];
          return E.size = j.size, E.start = j.start, E.end = j.end, E
        }

        function yr(j, E, D, N, X, ee) {
          for (const pe of j) Nt(pe, E, D, N, X, ee, !1)
        }

        function Wt(j, E, D, N) {
          j.push(E, D, N)
        }

        function Zt(j, E, D, N, X, ee) {
          const pe = (ee - E) / (N - E);
          return Wt(j, ee, D + (X - D) * pe, 1), pe
        }

        function jt(j, E, D, N, X, ee) {
          const pe = (ee - D) / (X - D);
          return Wt(j, E + (N - E) * pe, ee, 1), pe
        }

        function Jt(j, E) {
          const D = [];
          for (let N = 0; N < j.length; N++) {
            const X = j[N],
              ee = X.type;
            let pe;
            if (ee === "Point" || ee === "MultiPoint" || ee === "LineString") pe = Lt(X.geometry, E);
            else if (ee === "MultiLineString" || ee === "Polygon") {
              pe = [];
              for (const be of X.geometry) pe.push(Lt(be, E))
            } else if (ee === "MultiPolygon") {
              pe = [];
              for (const be of X.geometry) {
                const ye = [];
                for (const Oe of be) ye.push(Lt(Oe, E));
                pe.push(ye)
              }
            }
            D.push(bt(X.id, ee, pe, X.tags))
          }
          return D
        }

        function Lt(j, E) {
          const D = [];
          D.size = j.size, j.start !== void 0 && (D.start = j.start, D.end = j.end);
          for (let N = 0; N < j.length; N += 3) D.push(j[N] + E, j[N + 1], j[N + 2]);
          return D
        }

        function Gt(j, E) {
          if (j.transformed) return j;
          const D = 1 << j.z,
            N = j.x,
            X = j.y;
          for (const ee of j.features) {
            const pe = ee.geometry,
              be = ee.type;
            if (ee.geometry = [], be === 1)
              for (let ye = 0; ye < pe.length; ye += 2) ee.geometry.push(Yt(pe[ye], pe[ye + 1], E, D, N, X));
            else
              for (let ye = 0; ye < pe.length; ye++) {
                const Oe = [];
                for (let oe = 0; oe < pe[ye].length; oe += 2) Oe.push(Yt(pe[ye][oe], pe[ye][oe + 1], E, D, N, X));
                ee.geometry.push(Oe)
              }
          }
          return j.transformed = !0, j
        }

        function Yt(j, E, D, N, X, ee) {
          return [Math.round(D * (j * N - X)), Math.round(D * (E * N - ee))]
        }

        function Lr(j, E, D, N, X) {
          const ee = E === X.maxZoom ? 0 : X.tolerance / ((1 << E) * X.extent),
            pe = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: j.length,
              source: null,
              x: D,
              y: N,
              z: E,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0
            };
          for (const be of j) Ir(pe, be, ee, X);
          return pe
        }

        function Ir(j, E, D, N) {
          const X = E.geometry,
            ee = E.type,
            pe = [];
          if (j.minX = Math.min(j.minX, E.minX), j.minY = Math.min(j.minY, E.minY), j.maxX = Math.max(j.maxX, E.maxX), j.maxY = Math.max(j.maxY, E.maxY), ee === "Point" || ee === "MultiPoint")
            for (let be = 0; be < X.length; be += 3) pe.push(X[be], X[be + 1]), j.numPoints++, j.numSimplified++;
          else if (ee === "LineString") Jr(pe, X, j, D, !1, !1);
          else if (ee === "MultiLineString" || ee === "Polygon")
            for (let be = 0; be < X.length; be++) Jr(pe, X[be], j, D, ee === "Polygon", be === 0);
          else if (ee === "MultiPolygon")
            for (let be = 0; be < X.length; be++) {
              const ye = X[be];
              for (let Oe = 0; Oe < ye.length; Oe++) Jr(pe, ye[Oe], j, D, !0, Oe === 0)
            }
          if (pe.length) {
            let be = E.tags || null;
            if (ee === "LineString" && N.lineMetrics) {
              be = {};
              for (const Oe in E.tags) be[Oe] = E.tags[Oe];
              be.mapbox_clip_start = X.start / X.size, be.mapbox_clip_end = X.end / X.size
            }
            const ye = {
              geometry: pe,
              type: ee === "Polygon" || ee === "MultiPolygon" ? 3 : ee === "LineString" || ee === "MultiLineString" ? 2 : 1,
              tags: be
            };
            E.id !== null && (ye.id = E.id), j.features.push(ye)
          }
        }

        function Jr(j, E, D, N, X, ee) {
          const pe = N * N;
          if (N > 0 && E.size < (X ? pe : N)) return void(D.numPoints += E.length / 3);
          const be = [];
          for (let ye = 0; ye < E.length; ye += 3)(N === 0 || E[ye + 2] > pe) && (D.numSimplified++, be.push(E[ye], E[ye + 1])), D.numPoints++;
          X && (function(ye, Oe) {
            let oe = 0;
            for (let K = 0, he = ye.length, Q = he - 2; K < he; Q = K, K += 2) oe += (ye[K] - ye[Q]) * (ye[K + 1] + ye[Q + 1]);
            if (oe > 0 === Oe)
              for (let K = 0, he = ye.length; K < he / 2; K += 2) {
                const Q = ye[K],
                  ze = ye[K + 1];
                ye[K] = ye[he - 2 - K], ye[K + 1] = ye[he - 1 - K], ye[he - 2 - K] = Q, ye[he - 1 - K] = ze
              }
          })(be, ee), j.push(be)
        }
        const Tr = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0
        };
        class Ar {
          constructor(E, D) {
            const N = (D = this.options = (function(ee, pe) {
              for (const be in pe) ee[be] = pe[be];
              return ee
            })(Object.create(Tr), D)).debug;
            if (N && console.time("preprocess data"), D.maxZoom < 0 || D.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (D.promoteId && D.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let X = (function(ee, pe) {
              const be = [];
              if (ee.type === "FeatureCollection")
                for (let ye = 0; ye < ee.features.length; ye++) Pt(be, ee.features[ye], pe, ye);
              else Pt(be, ee.type === "Feature" ? ee : {
                geometry: ee
              }, pe);
              return be
            })(E, D);
            this.tiles = {}, this.tileCoords = [], N && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", D.indexMaxZoom, D.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), X = (function(ee, pe) {
              const be = pe.buffer / pe.extent;
              let ye = ee;
              const Oe = It(ee, 1, -1 - be, be, 0, -1, 2, pe),
                oe = It(ee, 1, 1 - be, 2 + be, 0, -1, 2, pe);
              return (Oe || oe) && (ye = It(ee, 1, -be, 1 + be, 0, -1, 2, pe) || [], Oe && (ye = Jt(Oe, 1).concat(ye)), oe && (ye = ye.concat(Jt(oe, -1)))), ye
            })(X, D), X.length && this.splitTile(X, 0, 0, 0), N && (X.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
          }
          splitTile(E, D, N, X, ee, pe, be) {
            const ye = [E, D, N, X],
              Oe = this.options,
              oe = Oe.debug;
            for (; ye.length;) {
              X = ye.pop(), N = ye.pop(), D = ye.pop(), E = ye.pop();
              const K = 1 << D,
                he = xr(D, N, X);
              let Q = this.tiles[he];
              if (!Q && (oe > 1 && console.time("creation"), Q = this.tiles[he] = Lr(E, D, N, X, Oe), this.tileCoords.push({
                  z: D,
                  x: N,
                  y: X
                }), oe)) {
                oe > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", D, N, X, Q.numFeatures, Q.numPoints, Q.numSimplified), console.timeEnd("creation"));
                const Ft = `z${D}`;
                this.stats[Ft] = (this.stats[Ft] || 0) + 1, this.total++
              }
              if (Q.source = E, ee == null) {
                if (D === Oe.indexMaxZoom || Q.numPoints <= Oe.indexMaxPoints) continue
              } else {
                if (D === Oe.maxZoom || D === ee) continue;
                if (ee != null) {
                  const Ft = ee - D;
                  if (N !== pe >> Ft || X !== be >> Ft) continue
                }
              }
              if (Q.source = null, E.length === 0) continue;
              oe > 1 && console.time("clipping");
              const ze = .5 * Oe.buffer / Oe.extent,
                $e = .5 - ze,
                Re = .5 + ze,
                ft = 1 + ze;
              let Mt = null,
                Et = null,
                dt = null,
                Kt = null,
                Qt = It(E, K, N - ze, N + Re, 0, Q.minX, Q.maxX, Oe),
                Sr = It(E, K, N + $e, N + ft, 0, Q.minX, Q.maxX, Oe);
              E = null, Qt && (Mt = It(Qt, K, X - ze, X + Re, 1, Q.minY, Q.maxY, Oe), Et = It(Qt, K, X + $e, X + ft, 1, Q.minY, Q.maxY, Oe), Qt = null), Sr && (dt = It(Sr, K, X - ze, X + Re, 1, Q.minY, Q.maxY, Oe), Kt = It(Sr, K, X + $e, X + ft, 1, Q.minY, Q.maxY, Oe), Sr = null), oe > 1 && console.timeEnd("clipping"), ye.push(Mt || [], D + 1, 2 * N, 2 * X), ye.push(Et || [], D + 1, 2 * N, 2 * X + 1), ye.push(dt || [], D + 1, 2 * N + 1, 2 * X), ye.push(Kt || [], D + 1, 2 * N + 1, 2 * X + 1)
            }
          }
          getTile(E, D, N) {
            E = +E, D = +D, N = +N;
            const X = this.options,
              {
                extent: ee,
                debug: pe
              } = X;
            if (E < 0 || E > 24) return null;
            const be = 1 << E,
              ye = xr(E, D = D + be & be - 1, N);
            if (this.tiles[ye]) return Gt(this.tiles[ye], ee);
            pe > 1 && console.log("drilling down to z%d-%d-%d", E, D, N);
            let Oe, oe = E,
              K = D,
              he = N;
            for (; !Oe && oe > 0;) oe--, K >>= 1, he >>= 1, Oe = this.tiles[xr(oe, K, he)];
            return Oe && Oe.source ? (pe > 1 && (console.log("found parent tile z%d-%d-%d", oe, K, he), console.time("drilling down")), this.splitTile(Oe.source, oe, K, he, E, D, N), pe > 1 && console.timeEnd("drilling down"), this.tiles[ye] ? Gt(this.tiles[ye], ee) : null) : null
          }
        }

        function xr(j, E, D) {
          return 32 * ((1 << j) * D + E) + j
        }
        class qt extends te {
          constructor(E, D, N, X = Yr) {
            super(E, D, N), this._dataUpdateable = new Map, this._createGeoJSONIndex = X
          }
          loadVectorTile(E, D) {
            return b._(this, void 0, void 0, (function*() {
              const N = E.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const X = this._geoJSONIndex.getTile(N.z, N.x, N.y);
              if (!X) return null;
              const ee = new Pe(X.features, {
                version: 2,
                extent: b.a3
              });
              let pe = (function(be) {
                const ye = new b.cP;
                return (function(Oe, oe) {
                  for (const K in Oe.layers) oe.writeMessage(3, Ie, Oe.layers[K])
                })(be, ye), ye.finish()
              })(ee);
              return pe.byteOffset === 0 && pe.byteLength === pe.buffer.byteLength || (pe = new Uint8Array(pe)), {
                vectorTile: ee,
                rawData: pe.buffer
              }
            }))
          }
          loadData(E) {
            return b._(this, void 0, void 0, (function*() {
              var D;
              (D = this._pendingRequest) === null || D === void 0 || D.abort();
              const N = !!(E && E.request && E.request.collectResourceTiming) && new b.cQ(E.request);
              this._pendingRequest = new AbortController;
              try {
                (!this._pendingData || E.request || E.data || E.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(E, this._pendingRequest));
                const X = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(X, E), this.loaded = {};
                const ee = {
                  data: X
                };
                if (N) {
                  const pe = N.finish();
                  pe && (ee.resourceTiming = {}, ee.resourceTiming[E.source] = JSON.parse(JSON.stringify(pe)))
                }
                return ee
              } catch (X) {
                if (delete this._pendingRequest, b.cB(X)) return {
                  abandoned: !0
                };
                throw X
              }
            }))
          }
          getData() {
            return b._(this, void 0, void 0, (function*() {
              return this._pendingData
            }))
          }
          reloadTile(E) {
            const D = this.loaded;
            return D && D[E.uid] ? super.reloadTile(E) : this.loadTile(E)
          }
          loadAndProcessGeoJSON(E, D) {
            return b._(this, void 0, void 0, (function*() {
              let N = yield this.loadGeoJSON(E, D);
              if (delete this._pendingRequest, typeof N != "object") throw new Error(`Input data given to '${E.source}' is not a valid GeoJSON object.`);
              if (Se(N, !0), E.filter) {
                const X = b.cW(E.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1
                });
                if (X.result === "error") throw new Error(X.value.map((pe => `${pe.key}: ${pe.message}`)).join(", "));
                N = {
                  type: "FeatureCollection",
                  features: N.features.filter((pe => X.value.evaluate({
                    zoom: 0
                  }, pe)))
                }
              }
              return N
            }))
          }
          loadGeoJSON(E, D) {
            return b._(this, void 0, void 0, (function*() {
              const {
                promoteId: N
              } = E;
              if (E.request) {
                const X = yield b.j(E.request, D);
                return this._dataUpdateable = b.cY(X.data, N) ? b.cX(X.data, N) : void 0, X.data
              }
              if (typeof E.data == "string") try {
                const X = JSON.parse(E.data);
                return this._dataUpdateable = b.cY(X, N) ? b.cX(X, N) : void 0, X
              } catch {
                throw new Error(`Input data given to '${E.source}' is not a valid GeoJSON object.`)
              }
              if (!E.dataDiff) throw new Error(`Input data given to '${E.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${E.source}`);
              return b.cZ(this._dataUpdateable, E.dataDiff, N), {
                type: "FeatureCollection",
                features: Array.from(this._dataUpdateable.values())
              }
            }))
          }
          removeSource(E) {
            return b._(this, void 0, void 0, (function*() {
              this._pendingRequest && this._pendingRequest.abort()
            }))
          }
          getClusterExpansionZoom(E) {
            return this._geoJSONIndex.getClusterExpansionZoom(E.clusterId)
          }
          getClusterChildren(E) {
            return this._geoJSONIndex.getChildren(E.clusterId)
          }
          getClusterLeaves(E) {
            return this._geoJSONIndex.getLeaves(E.clusterId, E.limit, E.offset)
          }
        }

        function Yr(j, E) {
          return E.cluster ? new Ge((function({
            superclusterOptions: D,
            clusterProperties: N
          }) {
            if (!N || !D) return D;
            const X = {},
              ee = {},
              pe = {
                accumulated: null,
                zoom: 0
              },
              be = {
                properties: null
              },
              ye = Object.keys(N);
            for (const Oe of ye) {
              const [oe, K] = N[Oe], he = b.cW(K), Q = b.cW(typeof oe == "string" ? [oe, ["accumulated"],
                ["get", Oe]
              ] : oe);
              X[Oe] = he.value, ee[Oe] = Q.value
            }
            return D.map = Oe => {
              be.properties = Oe;
              const oe = {};
              for (const K of ye) oe[K] = X[K].evaluate(pe, be);
              return oe
            }, D.reduce = (Oe, oe) => {
              be.properties = oe;
              for (const K of ye) pe.accumulated = Oe[K], Oe[K] = ee[K].evaluate(pe, be)
            }, D
          })(E)).load(j.features) : (function(D, N) {
            return new Ar(D, N)
          })(j, E.geojsonVtOptions)
        }
        class Le {
          constructor(E) {
            this.self = E, this.actor = new b.K(E), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = new Map, this.self.registerWorkerSource = (D, N) => {
              if (this.externalWorkerSourceTypes[D]) throw new Error(`Worker source with name "${D}" already registered.`);
              this.externalWorkerSourceTypes[D] = N
            }, this.self.addProtocol = b.cD, this.self.removeProtocol = b.cE, this.self.registerRTLTextPlugin = D => {
              b.c_.setMethods(D)
            }, this.actor.registerMessageHandler("LDT", ((D, N) => this._getDEMWorkerSource(D, N.source).loadTile(N))), this.actor.registerMessageHandler("RDT", ((D, N) => b._(this, void 0, void 0, (function*() {
              this._getDEMWorkerSource(D, N.source).removeTile(N)
            })))), this.actor.registerMessageHandler("GCEZ", ((D, N) => b._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(D, N.type, N.source).getClusterExpansionZoom(N)
            })))), this.actor.registerMessageHandler("GCC", ((D, N) => b._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(D, N.type, N.source).getClusterChildren(N)
            })))), this.actor.registerMessageHandler("GCL", ((D, N) => b._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(D, N.type, N.source).getClusterLeaves(N)
            })))), this.actor.registerMessageHandler("LD", ((D, N) => this._getWorkerSource(D, N.type, N.source).loadData(N))), this.actor.registerMessageHandler("GD", ((D, N) => this._getWorkerSource(D, N.type, N.source).getData())), this.actor.registerMessageHandler("LT", ((D, N) => this._getWorkerSource(D, N.type, N.source).loadTile(N))), this.actor.registerMessageHandler("RT", ((D, N) => this._getWorkerSource(D, N.type, N.source).reloadTile(N))), this.actor.registerMessageHandler("AT", ((D, N) => this._getWorkerSource(D, N.type, N.source).abortTile(N))), this.actor.registerMessageHandler("RMT", ((D, N) => this._getWorkerSource(D, N.type, N.source).removeTile(N))), this.actor.registerMessageHandler("RS", ((D, N) => b._(this, void 0, void 0, (function*() {
              if (!this.workerSources[D] || !this.workerSources[D][N.type] || !this.workerSources[D][N.type][N.source]) return;
              const X = this.workerSources[D][N.type][N.source];
              delete this.workerSources[D][N.type][N.source], X.removeSource !== void 0 && X.removeSource(N)
            })))), this.actor.registerMessageHandler("RM", (D => b._(this, void 0, void 0, (function*() {
              delete this.layerIndexes[D], delete this.availableImages[D], delete this.workerSources[D], delete this.demWorkerSources[D], this.globalStates.delete(D)
            })))), this.actor.registerMessageHandler("SR", ((D, N) => b._(this, void 0, void 0, (function*() {
              this.referrer = N
            })))), this.actor.registerMessageHandler("SRPS", ((D, N) => this._syncRTLPluginState(D, N))), this.actor.registerMessageHandler("IS", ((D, N) => b._(this, void 0, void 0, (function*() {
              this.self.importScripts(N)
            })))), this.actor.registerMessageHandler("SI", ((D, N) => this._setImages(D, N))), this.actor.registerMessageHandler("UL", ((D, N) => b._(this, void 0, void 0, (function*() {
              this._getLayerIndex(D).update(N.layers, N.removedIds, this._getGlobalState(D))
            })))), this.actor.registerMessageHandler("UGS", ((D, N) => b._(this, void 0, void 0, (function*() {
              const X = this._getGlobalState(D);
              for (const ee in N) X[ee] = N[ee]
            })))), this.actor.registerMessageHandler("SL", ((D, N) => b._(this, void 0, void 0, (function*() {
              this._getLayerIndex(D).replace(N, this._getGlobalState(D))
            }))))
          }
          _getGlobalState(E) {
            let D = this.globalStates.get(E);
            return D || (D = {}, this.globalStates.set(E, D)), D
          }
          _setImages(E, D) {
            return b._(this, void 0, void 0, (function*() {
              this.availableImages[E] = D;
              for (const N in this.workerSources[E]) {
                const X = this.workerSources[E][N];
                for (const ee in X) X[ee].availableImages = D
              }
            }))
          }
          _syncRTLPluginState(E, D) {
            return b._(this, void 0, void 0, (function*() {
              return yield b.c_.syncState(D, this.self.importScripts)
            }))
          }
          _getAvailableImages(E) {
            let D = this.availableImages[E];
            return D || (D = []), D
          }
          _getLayerIndex(E) {
            let D = this.layerIndexes[E];
            return D || (D = this.layerIndexes[E] = new s), D
          }
          _getWorkerSource(E, D, N) {
            if (this.workerSources[E] || (this.workerSources[E] = {}), this.workerSources[E][D] || (this.workerSources[E][D] = {}), !this.workerSources[E][D][N]) {
              const X = {
                sendAsync: (ee, pe) => (ee.targetMapId = E, this.actor.sendAsync(ee, pe))
              };
              switch (D) {
                case "vector":
                  this.workerSources[E][D][N] = new te(X, this._getLayerIndex(E), this._getAvailableImages(E));
                  break;
                case "geojson":
                  this.workerSources[E][D][N] = new qt(X, this._getLayerIndex(E), this._getAvailableImages(E));
                  break;
                default:
                  this.workerSources[E][D][N] = new this.externalWorkerSourceTypes[D](X, this._getLayerIndex(E), this._getAvailableImages(E))
              }
            }
            return this.workerSources[E][D][N]
          }
          _getDEMWorkerSource(E, D) {
            return this.demWorkerSources[E] || (this.demWorkerSources[E] = {}), this.demWorkerSources[E][D] || (this.demWorkerSources[E][D] = new ae), this.demWorkerSources[E][D]
          }
        }
        return b.i(self) && (self.worker = new Le(self)), Le
      })), A("index", ["exports", "./shared"], (function(b, s) {
        var F = "5.11.0";

        function q() {
          var h = new s.A(4);
          return s.A != Float32Array && (h[1] = 0, h[2] = 0), h[0] = 1, h[3] = 1, h
        }
        let J, te;
        const ae = {
            frame(h, e, i) {
              const l = requestAnimationFrame((p => {
                  u(), e(p)
                })),
                {
                  unsubscribe: u
                } = s.s(h.signal, "abort", (() => {
                  u(), cancelAnimationFrame(l), i(s.c())
                }), !1)
            },
            frameAsync(h) {
              return new Promise(((e, i) => {
                this.frame(h, e, i)
              }))
            },
            getImageData(h, e = 0) {
              return this.getImageCanvasContext(h).getImageData(-e, -e, h.width + 2 * e, h.height + 2 * e)
            },
            getImageCanvasContext(h) {
              const e = window.document.createElement("canvas"),
                i = e.getContext("2d", {
                  willReadFrequently: !0
                });
              if (!i) throw new Error("failed to create canvas 2d context");
              return e.width = h.width, e.height = h.height, i.drawImage(h, 0, 0, h.width, h.height), i
            },
            resolveURL: h => (J || (J = document.createElement("a")), J.href = h, J.href),
            hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
            get prefersReducedMotion() {
              return !!matchMedia && (te == null && (te = matchMedia("(prefers-reduced-motion: reduce)")), te.matches)
            }
          },
          fe = new class {
            constructor() {
              this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null
            }
            getCurrentTime() {
              return this._frozenAt !== null ? this._frozenAt : this._realTime()
            }
            setNow(h) {
              this._frozenAt = h
            }
            restoreNow() {
              this._frozenAt = null
            }
            isFrozen() {
              return this._frozenAt !== null
            }
          };

        function ie() {
          return fe.getCurrentTime()
        }
        class $ {
          static testProp(e) {
            if (!$.docStyle) return e[0];
            for (let i = 0; i < e.length; i++)
              if (e[i] in $.docStyle) return e[i];
            return e[0]
          }
          static create(e, i, l) {
            const u = window.document.createElement(e);
            return i !== void 0 && (u.className = i), l && l.appendChild(u), u
          }
          static createNS(e, i) {
            return window.document.createElementNS(e, i)
          }
          static disableDrag() {
            $.docStyle && $.selectProp && ($.userSelect = $.docStyle[$.selectProp], $.docStyle[$.selectProp] = "none")
          }
          static enableDrag() {
            $.docStyle && $.selectProp && ($.docStyle[$.selectProp] = $.userSelect)
          }
          static setTransform(e, i) {
            e.style[$.transformProp] = i
          }
          static addEventListener(e, i, l, u = {}) {
            e.addEventListener(i, l, "passive" in u ? u : u.capture)
          }
          static removeEventListener(e, i, l, u = {}) {
            e.removeEventListener(i, l, "passive" in u ? u : u.capture)
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", $.suppressClickInternal, !0)
          }
          static suppressClick() {
            window.addEventListener("click", $.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", $.suppressClickInternal, !0)
            }), 0)
          }
          static getScale(e) {
            const i = e.getBoundingClientRect();
            return {
              x: i.width / e.offsetWidth || 1,
              y: i.height / e.offsetHeight || 1,
              boundingClientRect: i
            }
          }
          static getPoint(e, i, l) {
            const u = i.boundingClientRect;
            return new s.P((l.clientX - u.left) / i.x - e.clientLeft, (l.clientY - u.top) / i.y - e.clientTop)
          }
          static mousePos(e, i) {
            const l = $.getScale(e);
            return $.getPoint(e, l, i)
          }
          static touchPos(e, i) {
            const l = [],
              u = $.getScale(e);
            for (let p = 0; p < i.length; p++) l.push($.getPoint(e, u, i[p]));
            return l
          }
          static mouseButton(e) {
            return e.button
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e)
          }
          static sanitize(e) {
            const i = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"),
              l = i.querySelectorAll("script");
            for (const u of l) u.remove();
            return $.clean(i), i.innerHTML
          }
          static isPossiblyDangerous(e, i) {
            const l = i.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !l.includes("javascript:") && !l.includes("data:")) || !!e.startsWith("on") || void 0
          }
          static clean(e) {
            const i = e.children;
            for (const l of i) $.removeAttributes(l), $.clean(l)
          }
          static removeAttributes(e) {
            for (const {
                name: i,
                value: l
              }
              of e.attributes) $.isPossiblyDangerous(i, l) && e.removeAttribute(i)
          }
        }
        $.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, $.selectProp = $.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), $.transformProp = $.testProp(["transform", "WebkitTransform"]);
        const Se = {
          supported: !1,
          testSupport: function(h) {
            !Ie && Pe && (Ce ? je(h) : Me = h)
          }
        };
        let Me, Pe, Ie = !1,
          Ce = !1;

        function je(h) {
          const e = h.createTexture();
          h.bindTexture(h.TEXTURE_2D, e);
          try {
            if (h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, Pe), h.isContextLost()) return;
            Se.supported = !0
          } catch {}
          h.deleteTexture(e), Ie = !0
        }
        var Ye;
        typeof document < "u" && (Pe = document.createElement("img"), Pe.onload = () => {
          Me && je(Me), Me = null, Ce = !0
        }, Pe.onerror = () => {
          Ie = !0, Me = null
        }, Pe.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(h) {
          let e, i, l, u;
          h.resetRequestQueue = () => {
            e = [], i = 0, l = 0, u = {}
          }, h.addThrottleControl = S => {
            const k = l++;
            return u[k] = S, k
          }, h.removeThrottleControl = S => {
            delete u[S], v()
          }, h.getImage = (S, k, L = !0) => new Promise(((V, B) => {
            Se.supported && (S.headers || (S.headers = {}), S.headers.accept = "image/webp,*/*"), s.e(S, {
              type: "image"
            }), e.push({
              abortController: k,
              requestParameters: S,
              supportImageRefresh: L,
              state: "queued",
              onError: H => {
                B(H)
              },
              onSuccess: H => {
                V(H)
              }
            }), v()
          }));
          const p = S => s._(this, void 0, void 0, (function*() {
              S.state = "running";
              const {
                requestParameters: k,
                supportImageRefresh: L,
                onError: V,
                onSuccess: B,
                abortController: H
              } = S, re = L === !1 && !s.i(self) && !s.g(k.url) && (!k.headers || Object.keys(k.headers).reduce(((de, ve) => de && ve === "accept"), !0));
              i++;
              const le = re ? T(k, H) : s.m(k, H);
              try {
                const de = yield le;
                delete S.abortController, S.state = "completed", de.data instanceof HTMLImageElement || s.b(de.data) ? B(de) : de.data && B({
                  data: yield(ue = de.data, typeof createImageBitmap == "function" ? s.f(ue) : s.h(ue)),
                  cacheControl: de.cacheControl,
                  expires: de.expires
                })
              } catch (de) {
                delete S.abortController, V(de)
              } finally {
                i--, v()
              }
              var ue
            })),
            v = () => {
              const S = (() => {
                for (const k of Object.keys(u))
                  if (u[k]()) return !0;
                return !1
              })() ? s.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : s.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let k = i; k < S && e.length > 0; k++) {
                const L = e.shift();
                L.abortController.signal.aborted ? k-- : p(L)
              }
            },
            T = (S, k) => new Promise(((L, V) => {
              const B = new Image,
                H = S.url,
                re = S.credentials;
              re && re === "include" ? B.crossOrigin = "use-credentials" : (re && re === "same-origin" || !s.d(H)) && (B.crossOrigin = "anonymous"), k.signal.addEventListener("abort", (() => {
                B.src = "", V(s.c())
              })), B.fetchPriority = "high", B.onload = () => {
                B.onerror = B.onload = null, L({
                  data: B
                })
              }, B.onerror = () => {
                B.onerror = B.onload = null, k.signal.aborted || V(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
              }, B.src = H
            }))
        })(Ye || (Ye = {})), Ye.resetRequestQueue();
        class qe {
          constructor(e) {
            this._transformRequestFn = e ?? null
          }
          transformRequest(e, i) {
            return this._transformRequestFn && this._transformRequestFn(e, i) || {
              url: e
            }
          }
          setTransformRequest(e) {
            this._transformRequestFn = e
          }
        }

        function Be(h) {
          const e = [];
          if (typeof h == "string") e.push({
            id: "default",
            url: h
          });
          else if (h && h.length > 0) {
            const i = [];
            for (const {
                id: l,
                url: u
              }
              of h) {
              const p = `${l}${u}`;
              i.indexOf(p) === -1 && (i.push(p), e.push({
                id: l,
                url: u
              }))
            }
          }
          return e
        }

        function He(h, e, i) {
          try {
            const l = new URL(h);
            return l.pathname += `${e}${i}`, l.toString()
          } catch {
            throw new Error(`Invalid sprite URL "${h}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
          }
        }

        function we(h) {
          const {
            userImage: e
          } = h;
          return !!(e && e.render && e.render()) && (h.data.replace(new Uint8Array(e.data.buffer)), !0)
        }
        class it extends s.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new s.R({
              width: 1,
              height: 1
            }), this.dirty = !0
          }
          isLoaded() {
            return this.loaded
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const {
                  ids: i,
                  promiseResolve: l
                }
                of this.requestors) l(this._getImagesForIds(i));
              this.requestors = []
            }
          }
          getImage(e) {
            const i = this.images[e];
            if (i && !i.data && i.spriteData) {
              const l = i.spriteData;
              i.data = new s.R({
                width: l.width,
                height: l.height
              }, l.context.getImageData(l.x, l.y, l.width, l.height).data), i.spriteData = null
            }
            return i
          }
          addImage(e, i) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, i) && (this.images[e] = i)
          }
          _validate(e, i) {
            let l = !0;
            const u = i.data || i.spriteData;
            return this._validateStretch(i.stretchX, u && u.width) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchX" value`))), l = !1), this._validateStretch(i.stretchY, u && u.height) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchY" value`))), l = !1), this._validateContent(i.content, i) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "content" value`))), l = !1), l
          }
          _validateStretch(e, i) {
            if (!e) return !0;
            let l = 0;
            for (const u of e) {
              if (u[0] < l || u[1] < u[0] || i < u[1]) return !1;
              l = u[1]
            }
            return !0
          }
          _validateContent(e, i) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const l = i.spriteData,
              u = l && l.width || i.data.width,
              p = l && l.height || i.data.height;
            return !(e[0] < 0 || u < e[0] || e[1] < 0 || p < e[1] || e[2] < 0 || u < e[2] || e[3] < 0 || p < e[3] || e[2] < e[0] || e[3] < e[1])
          }
          updateImage(e, i, l = !0) {
            const u = this.getImage(e);
            if (l && (u.data.width !== i.data.width || u.data.height !== i.data.height)) throw new Error(`size mismatch between old image (${u.data.width}x${u.data.height}) and new image (${i.data.width}x${i.data.height}).`);
            i.version = u.version + 1, this.images[e] = i, this.updatedImages[e] = !0
          }
          removeImage(e) {
            const i = this.images[e];
            delete this.images[e], delete this.patterns[e], i.userImage && i.userImage.onRemove && i.userImage.onRemove()
          }
          listImages() {
            return Object.keys(this.images)
          }
          getImages(e) {
            return new Promise(((i, l) => {
              let u = !0;
              if (!this.isLoaded())
                for (const p of e) this.images[p] || (u = !1);
              this.isLoaded() || u ? i(this._getImagesForIds(e)) : this.requestors.push({
                ids: e,
                promiseResolve: i
              })
            }))
          }
          _getImagesForIds(e) {
            const i = {};
            for (const l of e) {
              let u = this.getImage(l);
              u || (this.fire(new s.l("styleimagemissing", {
                id: l
              })), u = this.getImage(l)), u ? i[l] = {
                data: u.data.clone(),
                pixelRatio: u.pixelRatio,
                sdf: u.sdf,
                version: u.version,
                stretchX: u.stretchX,
                stretchY: u.stretchY,
                content: u.content,
                textFitWidth: u.textFitWidth,
                textFitHeight: u.textFitHeight,
                hasRenderCallback: !!(u.userImage && u.userImage.render)
              } : s.w(`Image "${l}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
            }
            return i
          }
          getPixelSize() {
            const {
              width: e,
              height: i
            } = this.atlasImage;
            return {
              width: e,
              height: i
            }
          }
          getPattern(e) {
            const i = this.patterns[e],
              l = this.getImage(e);
            if (!l) return null;
            if (i && i.position.version === l.version) return i.position;
            if (i) i.position.version = l.version;
            else {
              const u = {
                  w: l.data.width + 2,
                  h: l.data.height + 2,
                  x: 0,
                  y: 0
                },
                p = new s.I(u, l);
              this.patterns[e] = {
                bin: u,
                position: p
              }
            }
            return this._updatePatternAtlas(), this.patterns[e].position
          }
          bind(e) {
            const i = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new s.T(e, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE)
          }
          _updatePatternAtlas() {
            const e = [];
            for (const p in this.patterns) e.push(this.patterns[p].bin);
            const {
              w: i,
              h: l
            } = s.p(e), u = this.atlasImage;
            u.resize({
              width: i || 1,
              height: l || 1
            });
            for (const p in this.patterns) {
              const {
                bin: v
              } = this.patterns[p], T = v.x + 1, S = v.y + 1, k = this.getImage(p).data, L = k.width, V = k.height;
              s.R.copy(k, u, {
                x: 0,
                y: 0
              }, {
                x: T,
                y: S
              }, {
                width: L,
                height: V
              }), s.R.copy(k, u, {
                x: 0,
                y: V - 1
              }, {
                x: T,
                y: S - 1
              }, {
                width: L,
                height: 1
              }), s.R.copy(k, u, {
                x: 0,
                y: 0
              }, {
                x: T,
                y: S + V
              }, {
                width: L,
                height: 1
              }), s.R.copy(k, u, {
                x: L - 1,
                y: 0
              }, {
                x: T - 1,
                y: S
              }, {
                width: 1,
                height: V
              }), s.R.copy(k, u, {
                x: 0,
                y: 0
              }, {
                x: T + L,
                y: S
              }, {
                width: 1,
                height: V
              })
            }
            this.dirty = !0
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {}
          }
          dispatchRenderCallbacks(e) {
            for (const i of e) {
              if (this.callbackDispatchedThisFrame[i]) continue;
              this.callbackDispatchedThisFrame[i] = !0;
              const l = this.getImage(i);
              l || s.w(`Image with ID: "${i}" was not found`), we(l) && this.updateImage(i, l)
            }
          }
        }
        const mt = 1e20;

        function Ge(h, e, i, l, u, p, v, T, S) {
          for (let k = e; k < e + l; k++) Xe(h, i * p + k, p, u, v, T, S);
          for (let k = i; k < i + u; k++) Xe(h, k * p + e, 1, l, v, T, S)
        }

        function Xe(h, e, i, l, u, p, v) {
          p[0] = 0, v[0] = -mt, v[1] = mt, u[0] = h[e];
          for (let T = 1, S = 0, k = 0; T < l; T++) {
            u[T] = h[e + T * i];
            const L = T * T;
            do {
              const V = p[S];
              k = (u[T] - u[V] + L - V * V) / (T - V) / 2
            } while (k <= v[S] && --S > -1);
            S++, p[S] = T, v[S] = k, v[S + 1] = mt
          }
          for (let T = 0, S = 0; T < l; T++) {
            for (; v[S + 1] < T;) S++;
            const k = p[S],
              L = T - k;
            h[e + T * i] = u[k] + L * L
          }
        }
        const vt = s.v.layout_symbol["text-font"].default.join(",");
        class Ut {
          constructor(e, i, l) {
            this.requestManager = e, this.localIdeographFontFamily = i, this.entries = {}, this.lang = l
          }
          setURL(e) {
            this.url = e
          }
          getGlyphs(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = [];
              for (const p in e)
                for (const v of e[p]) i.push(this._getAndCacheGlyphsPromise(p, v));
              const l = yield Promise.all(i), u = {};
              for (const {
                  stack: p,
                  id: v,
                  glyph: T
                }
                of l) u[p] || (u[p] = {}), u[p][v] = T && {
                id: T.id,
                bitmap: T.bitmap.clone(),
                metrics: T.metrics
              };
              return u
            }))
          }
          _getAndCacheGlyphsPromise(e, i) {
            return s._(this, void 0, void 0, (function*() {
              let l = this.entries[e];
              l || (l = this.entries[e] = {
                glyphs: {},
                requests: {},
                ranges: {}
              });
              let u = l.glyphs[i];
              return u !== void 0 ? {
                stack: e,
                id: i,
                glyph: u
              } : !this.url || this._charUsesLocalIdeographFontFamily(i) ? (u = l.glyphs[i] = this._drawGlyph(l, e, i), {
                stack: e,
                id: i,
                glyph: u
              }) : yield this._downloadAndCacheRangePromise(e, i)
            }))
          }
          _downloadAndCacheRangePromise(e, i) {
            return s._(this, void 0, void 0, (function*() {
              const l = Math.floor(i / 256);
              if (256 * l > 65535) throw new Error("glyphs > 65535 not supported");
              const u = this.entries[e];
              if (u.ranges[l]) return {
                stack: e,
                id: i,
                glyph: null
              };
              if (!u.requests[l]) {
                const p = Ut.loadGlyphRange(e, l, this.url, this.requestManager);
                u.requests[l] = p
              }
              try {
                const p = yield u.requests[l];
                for (const v in p) u.glyphs[+v] = p[+v];
                return u.ranges[l] = !0, {
                  stack: e,
                  id: i,
                  glyph: p[i] || null
                }
              } catch (p) {
                const v = u.glyphs[i] = this._drawGlyph(u, e, i);
                return this._warnOnMissingGlyphRange(v, l, i, p), {
                  stack: e,
                  id: i,
                  glyph: v
                }
              }
            }))
          }
          _warnOnMissingGlyphRange(e, i, l, u) {
            const p = 256 * i,
              v = p + 255,
              T = l.toString(16).padStart(4, "0").toUpperCase();
            s.w(`Unable to load glyph range ${i}, ${p}-${v}. Rendering codepoint U+${T} locally instead. ${u}`)
          }
          _charUsesLocalIdeographFontFamily(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || s.u["CJK Unified Ideographs"](e) || s.u["Hangul Syllables"](e) || s.u.Hiragana(e) || s.u.Katakana(e) || s.u["CJK Symbols and Punctuation"](e) || s.u["Halfwidth and Fullwidth Forms"](e))
          }
          _drawGlyph(e, i, l) {
            const u = i === vt && this.localIdeographFontFamily !== "" && this._charUsesLocalIdeographFontFamily(l),
              p = u ? "ideographTinySDF" : "tinySDF";
            e[p] || (e[p] = this._createTinySDF(u ? this.localIdeographFontFamily : i));
            const v = e[p].draw(String.fromCharCode(l));
            return {
              id: l,
              bitmap: new s.q({
                width: v.width || 60,
                height: v.height || 60
              }, v.data),
              metrics: {
                width: v.glyphWidth / 2 || 24,
                height: v.glyphHeight / 2 || 24,
                left: v.glyphLeft / 2 + .5 || 0,
                top: v.glyphTop / 2 - 27.5 || -8,
                advance: v.glyphAdvance / 2 || 24,
                isDoubleResolution: !0
              }
            }
          }
          _createTinySDF(e) {
            const i = e ? e.split(",") : [];
            i.push("sans-serif");
            const l = i.map((u => /[-\w]+/.test(u) ? u : `'${CSS.escape(u)}'`)).join(",");
            return new Ut.TinySDF({
              fontSize: 48,
              buffer: 6,
              radius: 16,
              cutoff: .25,
              fontFamily: l,
              fontWeight: this._fontWeight(i[0]),
              fontStyle: this._fontStyle(i[0]),
              lang: this.lang
            })
          }
          _fontStyle(e) {
            return /italic/i.test(e) ? "italic" : /oblique/i.test(e) ? "oblique" : "normal"
          }
          _fontWeight(e) {
            const i = {
              thin: 100,
              hairline: 100,
              "extra light": 200,
              "ultra light": 200,
              light: 300,
              normal: 400,
              regular: 400,
              medium: 500,
              semibold: 600,
              demibold: 600,
              bold: 700,
              "extra bold": 800,
              "ultra bold": 800,
              black: 900,
              heavy: 900,
              "extra black": 950,
              "ultra black": 950
            };
            let l;
            for (const [u, p] of Object.entries(i)) new RegExp(`\\b${u}\\b`, "i").test(e) && (l = `${p}`);
            return l
          }
        }
        Ut.loadGlyphRange = function(h, e, i, l) {
          return s._(this, void 0, void 0, (function*() {
            const u = 256 * e,
              p = u + 255,
              v = l.transformRequest(i.replace("{fontstack}", h).replace("{range}", `${u}-${p}`), "Glyphs"),
              T = yield s.n(v, new AbortController);
            if (!T || !T.data) throw new Error(`Could not load glyph range. range: ${e}, ${u}-${p}`);
            const S = {};
            for (const k of s.o(T.data)) S[k.id] = k;
            return S
          }))
        }, Ut.TinySDF = class {
          constructor({
            fontSize: h = 24,
            buffer: e = 3,
            radius: i = 8,
            cutoff: l = .25,
            fontFamily: u = "sans-serif",
            fontWeight: p = "normal",
            fontStyle: v = "normal",
            lang: T = null
          } = {}) {
            this.buffer = e, this.cutoff = l, this.radius = i, this.lang = T;
            const S = this.size = h + 4 * e,
              k = this._createCanvas(S),
              L = this.ctx = k.getContext("2d", {
                willReadFrequently: !0
              });
            L.font = `${v} ${p} ${h}px ${u}`, L.textBaseline = "alphabetic", L.textAlign = "left", L.fillStyle = "black", this.gridOuter = new Float64Array(S * S), this.gridInner = new Float64Array(S * S), this.f = new Float64Array(S), this.z = new Float64Array(S + 1), this.v = new Uint16Array(S)
          }
          _createCanvas(h) {
            const e = document.createElement("canvas");
            return e.width = e.height = h, e
          }
          draw(h) {
            const {
              width: e,
              actualBoundingBoxAscent: i,
              actualBoundingBoxDescent: l,
              actualBoundingBoxLeft: u,
              actualBoundingBoxRight: p
            } = this.ctx.measureText(h), v = Math.ceil(i), T = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(p - u))), S = Math.min(this.size - this.buffer, v + Math.ceil(l)), k = T + 2 * this.buffer, L = S + 2 * this.buffer, V = Math.max(k * L, 0), B = new Uint8ClampedArray(V), H = {
              data: B,
              width: k,
              height: L,
              glyphWidth: T,
              glyphHeight: S,
              glyphTop: v,
              glyphLeft: 0,
              glyphAdvance: e
            };
            if (T === 0 || S === 0) return H;
            const {
              ctx: re,
              buffer: le,
              gridInner: ue,
              gridOuter: de
            } = this;
            this.lang && (re.lang = this.lang), re.clearRect(le, le, T, S), re.fillText(h, le, le + v);
            const ve = re.getImageData(le, le, T, S);
            de.fill(mt, 0, V), ue.fill(0, 0, V);
            for (let Ae = 0; Ae < S; Ae++)
              for (let _e = 0; _e < T; _e++) {
                const ke = ve.data[4 * (Ae * T + _e) + 3] / 255;
                if (ke === 0) continue;
                const Fe = (Ae + le) * k + _e + le;
                if (ke === 1) de[Fe] = 0, ue[Fe] = mt;
                else {
                  const xe = .5 - ke;
                  de[Fe] = xe > 0 ? xe * xe : 0, ue[Fe] = xe < 0 ? xe * xe : 0
                }
              }
            Ge(de, 0, 0, k, L, k, this.f, this.v, this.z), Ge(ue, le, le, T, S, k, this.f, this.v, this.z);
            for (let Ae = 0; Ae < V; Ae++) {
              const _e = Math.sqrt(de[Ae]) - Math.sqrt(ue[Ae]);
              B[Ae] = Math.round(255 - 255 * (_e / this.radius + this.cutoff))
            }
            return H
          }
        };
        class _t {
          constructor() {
            this.specification = s.t.light.position
          }
          possiblyEvaluate(e, i) {
            return s.C(e.expression.evaluate(i))
          }
          interpolate(e, i, l) {
            return {
              x: s.F.number(e.x, i.x, l),
              y: s.F.number(e.y, i.y, l),
              z: s.F.number(e.z, i.z, l)
            }
          }
        }
        let wt;
        class Je extends s.E {
          constructor(e) {
            super(), wt = wt || new s.r({
              anchor: new s.D(s.t.light.anchor),
              position: new _t,
              color: new s.D(s.t.light.color),
              intensity: new s.D(s.t.light.intensity)
            }), this._transitionable = new s.x(wt, void 0), this.setLight(e), this._transitioning = this._transitionable.untransitioned()
          }
          getLight() {
            return this._transitionable.serialize()
          }
          setLight(e, i = {}) {
            if (!this._validate(s.y, e, i))
              for (const l in e) {
                const u = e[l];
                l.endsWith("-transition") ? this._transitionable.setTransition(l.slice(0, -11), u) : this._transitionable.setValue(l, u)
              }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, i, l) {
            return (!l || l.validate !== !1) && s.z(this, e.call(s.B, {
              value: i,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: s.t
            }))
          }
        }
        const zt = new s.r({
          "sky-color": new s.D(s.t.sky["sky-color"]),
          "horizon-color": new s.D(s.t.sky["horizon-color"]),
          "fog-color": new s.D(s.t.sky["fog-color"]),
          "fog-ground-blend": new s.D(s.t.sky["fog-ground-blend"]),
          "horizon-fog-blend": new s.D(s.t.sky["horizon-fog-blend"]),
          "sky-horizon-blend": new s.D(s.t.sky["sky-horizon-blend"]),
          "atmosphere-blend": new s.D(s.t.sky["atmosphere-blend"])
        });
        class bt extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.x(zt, void 0), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.G(0))
          }
          setSky(e, i = {}) {
            if (!this._validate(s.H, e, i)) {
              e || (e = {
                "sky-color": "transparent",
                "horizon-color": "transparent",
                "fog-color": "transparent",
                "fog-ground-blend": 1,
                "atmosphere-blend": 0
              });
              for (const l in e) {
                const u = e[l];
                l.endsWith("-transition") ? this._transitionable.setTransition(l.slice(0, -11), u) : this._transitionable.setValue(l, u)
              }
            }
          }
          getSky() {
            return this._transitionable.serialize()
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, i, l = {}) {
            return (l == null ? void 0 : l.validate) !== !1 && s.z(this, e.call(s.B, s.e({
              value: i,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: s.t
            })))
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
          }
        }
        class Rt {
          constructor(e, i) {
            this.width = e, this.height = i, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {}
          }
          getDash(e, i) {
            const l = e.join(",") + String(i);
            return this.dashEntry[l] || (this.dashEntry[l] = this.addDash(e, i)), this.dashEntry[l]
          }
          getDashRanges(e, i, l) {
            const u = [];
            let p = e.length % 2 == 1 ? -e[e.length - 1] * l : 0,
              v = e[0] * l,
              T = !0;
            u.push({
              left: p,
              right: v,
              isDash: T,
              zeroLength: e[0] === 0
            });
            let S = e[0];
            for (let k = 1; k < e.length; k++) {
              T = !T;
              const L = e[k];
              p = S * l, S += L, v = S * l, u.push({
                left: p,
                right: v,
                isDash: T,
                zeroLength: L === 0
              })
            }
            return u
          }
          addRoundDash(e, i, l) {
            const u = i / 2;
            for (let p = -l; p <= l; p++) {
              const v = this.width * (this.nextRow + l + p);
              let T = 0,
                S = e[T];
              for (let k = 0; k < this.width; k++) {
                k / S.right > 1 && (S = e[++T]);
                const L = Math.abs(k - S.left),
                  V = Math.abs(k - S.right),
                  B = Math.min(L, V);
                let H;
                const re = p / l * (u + 1);
                if (S.isDash) {
                  const le = u - Math.abs(re);
                  H = Math.sqrt(B * B + le * le)
                } else H = u - Math.sqrt(B * B + re * re);
                this.data[v + k] = Math.max(0, Math.min(255, H + 128))
              }
            }
          }
          addRegularDash(e) {
            for (let T = e.length - 1; T >= 0; --T) {
              const S = e[T],
                k = e[T + 1];
              S.zeroLength ? e.splice(T, 1) : k && k.isDash === S.isDash && (k.left = S.left, e.splice(T, 1))
            }
            const i = e[0],
              l = e[e.length - 1];
            i.isDash === l.isDash && (i.left = l.left - this.width, l.right = i.right + this.width);
            const u = this.width * this.nextRow;
            let p = 0,
              v = e[p];
            for (let T = 0; T < this.width; T++) {
              T / v.right > 1 && (v = e[++p]);
              const S = Math.abs(T - v.left),
                k = Math.abs(T - v.right),
                L = Math.min(S, k);
              this.data[u + T] = Math.max(0, Math.min(255, (v.isDash ? L : -L) + 128))
            }
          }
          addDash(e, i) {
            const l = i ? 7 : 0,
              u = 2 * l + 1;
            if (this.nextRow + u > this.height) return s.w("LineAtlas out of space"), null;
            let p = 0;
            for (let T = 0; T < e.length; T++) p += e[T];
            if (p !== 0) {
              const T = this.width / p,
                S = this.getDashRanges(e, this.width, T);
              i ? this.addRoundDash(S, T, l) : this.addRegularDash(S)
            }
            const v = {
              y: this.nextRow + l,
              height: 2 * l,
              width: p
            };
            return this.nextRow += u, this.dirty = !0, v
          }
          bind(e) {
            const i = e.gl;
            this.texture ? (i.bindTexture(i.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, this.width, this.height, i.ALPHA, i.UNSIGNED_BYTE, this.data))) : (this.texture = i.createTexture(), i.bindTexture(i.TEXTURE_2D, this.texture), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), i.texImage2D(i.TEXTURE_2D, 0, i.ALPHA, this.width, this.height, 0, i.ALPHA, i.UNSIGNED_BYTE, this.data))
          }
        }
        const Pt = "maplibre_preloaded_worker_pool";
        class yt {
          constructor() {
            this.active = {}
          }
          acquire(e) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < yt.workerCount;) this.workers.push(new Worker(s.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice()
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach((i => {
              i.terminate()
            })), this.workers = null)
          }
          isPreloaded() {
            return !!this.active[Pt]
          }
          numActive() {
            return Object.keys(this.active).length
          }
        }
        const sr = Math.floor(ae.hardwareConcurrency / 2);
        let tr, tt;

        function ht() {
          return tr || (tr = new yt), tr
        }
        yt.workerCount = s.J(globalThis) ? Math.max(Math.min(sr, 3), 1) : 1;
        class It {
          constructor(e, i) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = i;
            const l = this.workerPool.acquire(i);
            for (let u = 0; u < l.length; u++) {
              const p = new s.K(l[u], i);
              p.name = `Worker ${u}`, this.actors.push(p)
            }
            if (!this.actors.length) throw new Error("No actors found")
          }
          broadcast(e, i) {
            const l = [];
            for (const u of this.actors) l.push(u.sendAsync({
              type: e,
              data: i
            }));
            return Promise.all(l)
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
          }
          remove(e = !0) {
            this.actors.forEach((i => {
              i.remove()
            })), this.actors = [], e && this.workerPool.release(this.id)
          }
          registerMessageHandler(e, i) {
            for (const l of this.actors) l.registerMessageHandler(e, i)
          }
        }

        function Bt() {
          return tt || (tt = new It(ht(), s.L), tt.registerMessageHandler("GR", ((h, e, i) => s.m(e, i)))), tt
        }

        function Nt(h, e) {
          const i = s.M();
          return s.N(i, i, [1, 1, 0]), s.O(i, i, [.5 * h.width, .5 * h.height, 1]), h.calculatePosMatrix ? s.Q(i, i, h.calculatePosMatrix(e.toUnwrapped())) : i
        }

        function Ht(h, e, i, l, u, p, v) {
          var T;
          const S = (function(B, H, re) {
              if (B)
                for (const le of B) {
                  const ue = H[le];
                  if (ue && ue.source === re && ue.type === "fill-extrusion") return !0
                } else
                  for (const le in H) {
                    const ue = H[le];
                    if (ue.source === re && ue.type === "fill-extrusion") return !0
                  }
              return !1
            })((T = u == null ? void 0 : u.layers) !== null && T !== void 0 ? T : null, e, h.id),
            k = p.maxPitchScaleFactor(),
            L = h.tilesIn(l, k, S);
          L.sort(yr);
          const V = [];
          for (const B of L) V.push({
            wrappedTileID: B.tileID.wrapped().key,
            queryResults: B.tile.queryRenderedFeatures(e, i, h.getState(), B.queryGeometry, B.cameraQueryGeometry, B.scale, u, p, k, Nt(p, B.tileID), v ? (H, re) => v(B.tileID, H, re) : void 0)
          });
          return (function(B, H) {
            for (const re in B)
              for (const le of B[re]) Wt(le, H);
            return B
          })((function(B) {
            const H = {},
              re = {};
            for (const le of B) {
              const ue = le.queryResults,
                de = le.wrappedTileID,
                ve = re[de] = re[de] || {};
              for (const Ae in ue) {
                const _e = ue[Ae],
                  ke = ve[Ae] = ve[Ae] || {},
                  Fe = H[Ae] = H[Ae] || [];
                for (const xe of _e) ke[xe.featureIndex] || (ke[xe.featureIndex] = !0, Fe.push(xe))
              }
            }
            return H
          })(V), h)
        }

        function yr(h, e) {
          const i = h.tileID,
            l = e.tileID;
          return i.overscaledZ - l.overscaledZ || i.canonical.y - l.canonical.y || i.wrap - l.wrap || i.canonical.x - l.canonical.x
        }

        function Wt(h, e) {
          const i = h.feature,
            l = e.getFeatureState(i.layer["source-layer"], i.id);
          i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = l
        }

        function Zt(h, e, i) {
          return s._(this, void 0, void 0, (function*() {
            let l = h;
            if (h.url ? l = (yield s.j(e.transformRequest(h.url, "Source"), i)).data : yield ae.frameAsync(i), !l) return null;
            const u = s.S(s.e(l, h), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in l && l.vector_layers && (u.vectorLayerIds = l.vector_layers.map((p => p.id))), u
          }))
        }
        class jt {
          constructor(e, i) {
            e && (i ? this.setSouthWest(e).setNorthEast(i) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
          }
          setNorthEast(e) {
            return this._ne = e instanceof s.U ? new s.U(e.lng, e.lat) : s.U.convert(e), this
          }
          setSouthWest(e) {
            return this._sw = e instanceof s.U ? new s.U(e.lng, e.lat) : s.U.convert(e), this
          }
          extend(e) {
            const i = this._sw,
              l = this._ne;
            let u, p;
            if (e instanceof s.U) u = e, p = e;
            else {
              if (!(e instanceof jt)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(jt.convert(e)) : this.extend(s.U.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(s.U.convert(e)) : this;
              if (u = e._sw, p = e._ne, !u || !p) return this
            }
            return i || l ? (i.lng = Math.min(u.lng, i.lng), i.lat = Math.min(u.lat, i.lat), l.lng = Math.max(p.lng, l.lng), l.lat = Math.max(p.lat, l.lat)) : (this._sw = new s.U(u.lng, u.lat), this._ne = new s.U(p.lng, p.lat)), this
          }
          getCenter() {
            return new s.U((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
          }
          getSouthWest() {
            return this._sw
          }
          getNorthEast() {
            return this._ne
          }
          getNorthWest() {
            return new s.U(this.getWest(), this.getNorth())
          }
          getSouthEast() {
            return new s.U(this.getEast(), this.getSouth())
          }
          getWest() {
            return this._sw.lng
          }
          getSouth() {
            return this._sw.lat
          }
          getEast() {
            return this._ne.lng
          }
          getNorth() {
            return this._ne.lat
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()]
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
          }
          isEmpty() {
            return !(this._sw && this._ne)
          }
          contains(e) {
            const {
              lng: i,
              lat: l
            } = s.U.convert(e);
            let u = this._sw.lng <= i && i <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (u = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= l && l <= this._ne.lat && u
          }
          intersects(e) {
            if ((e = jt.convert(e)).getNorth() < this.getSouth() || e.getSouth() > this.getNorth()) return !1;
            const i = s.V(this.getWest(), -180, 180),
              l = s.V(this.getEast(), -180, 180),
              u = s.V(e.getWest(), -180, 180),
              p = s.V(e.getEast(), -180, 180),
              v = i > l,
              T = u > p;
            return !(!v || !T) || (v ? p >= i || u <= l : T ? l >= u || i <= p : !(u > l || p < i))
          }
          static convert(e) {
            return e instanceof jt ? e : e && new jt(e)
          }
          static fromLngLat(e, i = 0) {
            const l = 360 * i / 40075017,
              u = l / Math.cos(Math.PI / 180 * e.lat);
            return new jt(new s.U(e.lng - u, e.lat - l), new s.U(e.lng + u, e.lat + l))
          }
          adjustAntiMeridian() {
            const e = new s.U(this._sw.lng, this._sw.lat),
              i = new s.U(this._ne.lng, this._ne.lat);
            return new jt(e, e.lng > i.lng ? new s.U(i.lng + 360, i.lat) : i)
          }
        }
        class Jt {
          constructor(e, i, l) {
            this.bounds = jt.convert(this.validateBounds(e)), this.minzoom = i || 0, this.maxzoom = l || 24
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
          }
          contains(e) {
            const i = Math.pow(2, e.z),
              l = Math.floor(s.X(this.bounds.getWest()) * i),
              u = Math.floor(s.W(this.bounds.getNorth()) * i),
              p = Math.ceil(s.X(this.bounds.getEast()) * i),
              v = Math.ceil(s.W(this.bounds.getSouth()) * i);
            return e.x >= l && e.x < p && e.y >= u && e.y < v
          }
        }
        class Lt extends s.E {
          constructor(e, i, l, u) {
            if (super(), this.id = e, this.dispatcher = l, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, s.e(this, s.S(i, ["url", "scheme", "tileSize", "promoteId"])), this._options = s.e({
                type: "vector"
              }, i), this._collectResourceTiming = i.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(u)
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const e = yield Zt(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.tileManagers[this.id].clearTiles(), e && (s.e(this, e), e.bounds && (this.tileBounds = new Jt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "content"
                })))
              } catch (e) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new s.k(e))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load()
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          serialize() {
            return s.e({}, this._options)
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                l = {
                  request: this.map._requestManager.transformRequest(i, "Tile"),
                  uid: e.uid,
                  tileID: e.tileID,
                  zoom: e.tileID.overscaledZ,
                  tileSize: this.tileSize * e.tileID.overscaleFactor(),
                  type: this.type,
                  source: this.id,
                  pixelRatio: this.map.getPixelRatio(),
                  showCollisionBoxes: this.map.showCollisionBoxes,
                  promoteId: this.promoteId,
                  subdivisionGranularity: this.map.style.projection.subdivisionGranularity
                };
              l.request.collectResourceTiming = this._collectResourceTiming;
              let u = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((p, v) => {
                  e.reloadPromise = {
                    resolve: p,
                    reject: v
                  }
                }))
              } else e.actor = this.dispatcher.getActor(), u = "LT";
              e.abortController = new AbortController;
              try {
                const p = yield e.actor.sendAsync({
                  type: u,
                  data: l
                }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, p)
              } catch (p) {
                if (delete e.abortController, e.aborted) return;
                if (p && p.status !== 404) throw p;
                this._afterTileLoadWorkerResponse(e, null)
              }
            }))
          }
          _afterTileLoadWorkerResponse(e, i) {
            if (i && i.resourceTiming && (e.resourceTiming = i.resourceTiming), i && this.map._refreshExpiredTiles && e.setExpiryData(i), e.loadVectorData(i, this.map.painter), e.reloadPromise) {
              const l = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(l.resolve).catch(l.reject)
            }
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({
                type: "AT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class Gt extends s.E {
          constructor(e, i, l, u) {
            super(), this.id = e, this.dispatcher = l, this.setEventedParent(u), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = s.e({
              type: "raster"
            }, i), s.e(this, s.S(i, ["url", "scheme", "tileSize"]))
          }
          load() {
            return s._(this, arguments, void 0, (function*(e = !1) {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const i = yield Zt(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, i && (s.e(this, i), i.bounds && (this.tileBounds = new Jt(i.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "content",
                  sourceDataChanged: e
                })))
              } catch (i) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new s.k(i))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0)
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          serialize() {
            return s.e({}, this._options)
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController;
              try {
                const l = yield Ye.getImage(this.map._requestManager.transformRequest(i, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (l && l.data) {
                  this.map._refreshExpiredTiles && (l.cacheControl || l.expires) && e.setExpiryData({
                    cacheControl: l.cacheControl,
                    expires: l.expires
                  });
                  const u = this.map.painter.context,
                    p = u.gl,
                    v = l.data;
                  e.texture = this.map.painter.getTileTexture(v.width), e.texture ? e.texture.update(v, {
                    useMipmap: !0
                  }) : (e.texture = new s.T(u, v, p.RGBA, {
                    useMipmap: !0
                  }), e.texture.bind(p.LINEAR, p.CLAMP_TO_EDGE, p.LINEAR_MIPMAP_NEAREST)), e.state = "loaded"
                }
              } catch (l) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (l) throw e.state = "errored", l
              }
            }))
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController)
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.texture && this.map.painter.saveTileTexture(e.texture)
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class Yt extends Gt {
          constructor(e, i, l, u) {
            super(e, i, l, u), this.type = "raster-dem", this.maxzoom = 22, this._options = s.e({
              type: "raster-dem"
            }, i), this.encoding = i.encoding || "mapbox", this.redFactor = i.redFactor, this.greenFactor = i.greenFactor, this.blueFactor = i.blueFactor, this.baseShift = i.baseShift
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                l = this.map._requestManager.transformRequest(i, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController;
              try {
                const u = yield Ye.getImage(l, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (u && u.data) {
                  const p = u.data;
                  this.map._refreshExpiredTiles && (u.cacheControl || u.expires) && e.setExpiryData({
                    cacheControl: u.cacheControl,
                    expires: u.expires
                  });
                  const v = s.b(p) && s.Y() ? p : yield this.readImageNow(p), T = {
                    type: this.type,
                    uid: e.uid,
                    source: this.id,
                    rawImageData: v,
                    encoding: this.encoding,
                    redFactor: this.redFactor,
                    greenFactor: this.greenFactor,
                    blueFactor: this.blueFactor,
                    baseShift: this.baseShift
                  };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const S = yield e.actor.sendAsync({
                      type: "LDT",
                      data: T
                    });
                    e.dem = S, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded"
                  }
                }
              } catch (u) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (u) throw e.state = "errored", u
              }
            }))
          }
          readImageNow(e) {
            return s._(this, void 0, void 0, (function*() {
              if (typeof VideoFrame < "u" && s.Z()) {
                const i = e.width + 2,
                  l = e.height + 2;
                try {
                  return new s.R({
                    width: i,
                    height: l
                  }, yield s.$(e, -1, -1, i, l))
                } catch {}
              }
              return ae.getImageData(e, 1)
            }))
          }
          _getNeighboringTiles(e) {
            const i = e.canonical,
              l = Math.pow(2, i.z),
              u = (i.x - 1 + l) % l,
              p = i.x === 0 ? e.wrap - 1 : e.wrap,
              v = (i.x + 1 + l) % l,
              T = i.x + 1 === l ? e.wrap + 1 : e.wrap,
              S = {};
            return S[new s.a0(e.overscaledZ, p, i.z, u, i.y).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, T, i.z, v, i.y).key] = {
              backfilled: !1
            }, i.y > 0 && (S[new s.a0(e.overscaledZ, p, i.z, u, i.y - 1).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, T, i.z, v, i.y - 1).key] = {
              backfilled: !1
            }), i.y + 1 < l && (S[new s.a0(e.overscaledZ, p, i.z, u, i.y + 1).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, T, i.z, v, i.y + 1).key] = {
              backfilled: !1
            }), S
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({
                type: "RDT",
                data: {
                  type: this.type,
                  uid: e.uid,
                  source: this.id
                }
              }))
            }))
          }
        }

        function Lr(h) {
          return h.type === "GeometryCollection" ? h.geometries.map((e => e.coordinates)).flat(1 / 0) : h.coordinates.flat(1 / 0)
        }

        function Ir(h) {
          const e = new jt;
          let i;
          switch (h.type) {
            case "FeatureCollection":
              i = h.features.map((l => Lr(l.geometry))).flat(1 / 0);
              break;
            case "Feature":
              i = Lr(h.geometry);
              break;
            default:
              i = Lr(h)
          }
          if (i.length == 0) return e;
          for (let l = 0; l < i.length - 1; l += 2) e.extend([i[l], i[l + 1]]);
          return e
        }
        class Jr extends s.E {
          constructor(e, i, l, u) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = {
              data: i.data
            }, this.actor = l.getActor(), this.setEventedParent(u), this._data = i.data, this._options = s.e({}, i), this._collectResourceTiming = i.collectResourceTiming, i.maxzoom !== void 0 && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId, i.clusterMaxZoom !== void 0 && this.maxzoom <= i.clusterMaxZoom && s.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`), this.workerOptions = s.e({
              source: this.id,
              cluster: i.cluster || !1,
              geojsonVtOptions: {
                buffer: this._pixelsToTileUnits(i.buffer !== void 0 ? i.buffer : 128),
                tolerance: this._pixelsToTileUnits(i.tolerance !== void 0 ? i.tolerance : .375),
                extent: s.a3,
                maxZoom: this.maxzoom,
                lineMetrics: i.lineMetrics || !1,
                generateId: i.generateId || !1
              },
              superclusterOptions: {
                maxZoom: this._getClusterMaxZoom(i.clusterMaxZoom),
                minPoints: Math.max(2, i.clusterMinPoints || 2),
                extent: s.a3,
                radius: this._pixelsToTileUnits(i.clusterRadius || 50),
                log: !1,
                generateId: i.generateId || !1
              },
              clusterProperties: i.clusterProperties,
              filter: i.filter
            }, i.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
          }
          _hasPendingWorkerUpdate() {
            return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged
          }
          _pixelsToTileUnits(e) {
            return e * (s.a3 / this.tileSize)
          }
          _getClusterMaxZoom(e) {
            const i = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || s.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${i}"`), i
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              yield this._updateWorkerData()
            }))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = {
              data: e
            }, this._updateWorkerData(), this
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = s.a4(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this
          }
          getData() {
            return s._(this, void 0, void 0, (function*() {
              const e = s.e({
                type: this.type
              }, this.workerOptions);
              return this.actor.sendAsync({
                type: "GD",
                data: e
              })
            }))
          }
          getBounds() {
            return s._(this, void 0, void 0, (function*() {
              return Ir(yield this.getData())
            }))
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({
              type: "GCEZ",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({
              type: "GCC",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterLeaves(e, i, l) {
            return this.actor.sendAsync({
              type: "GCL",
              data: {
                type: this.type,
                source: this.id,
                clusterId: e,
                limit: i,
                offset: l
              }
            })
          }
          _updateWorkerData() {
            return s._(this, void 0, void 0, (function*() {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void s.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const {
                data: e,
                diff: i
              } = this._pendingWorkerUpdate, l = s.e({
                type: this.type
              }, this.workerOptions);
              e ? (typeof e == "string" ? (l.request = this.map._requestManager.transformRequest(ae.resolveURL(e), "Source"), l.request.collectResourceTiming = this._collectResourceTiming) : l.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : i && (l.dataDiff = i, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = !0, this.fire(new s.l("dataloading", {
                dataType: "source"
              }));
              try {
                const u = yield this.actor.sendAsync({
                  type: "LD",
                  data: l
                });
                if (this._isUpdatingWorker = !1, this._removed || u.abandoned) return void this.fire(new s.l("dataabort", {
                  dataType: "source"
                }));
                this._data = u.data;
                let p = null;
                u.resourceTiming && u.resourceTiming[this.id] && (p = u.resourceTiming[this.id].slice(0));
                const v = {
                  dataType: "source"
                };
                this._collectResourceTiming && p && p.length > 0 && s.e(v, {
                  resourceTiming: p
                }), this.fire(new s.l("data", Object.assign(Object.assign({}, v), {
                  sourceDataType: "metadata"
                }))), this.fire(new s.l("data", Object.assign(Object.assign({}, v), {
                  sourceDataType: "content",
                  shouldReloadTileOptions: this._getShouldReloadTileOptions(i)
                })))
              } catch (u) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new s.l("dataabort", {
                  dataType: "source"
                }));
                this.fire(new s.k(u))
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData()
              }
            }))
          }
          _getShouldReloadTileOptions(e) {
            if (!e || e.removeAll) return;
            const {
              add: i = [],
              update: l = [],
              remove: u = []
            } = e || {}, p = new Set([...l.map((v => v.id)), ...u]);
            return {
              nextBounds: [...l.map((v => v.newGeometry)), ...i.map((v => v.geometry))].map((v => Ir(v))),
              prevIds: p
            }
          }
          shouldReloadTile(e, {
            nextBounds: i,
            prevIds: l
          }) {
            const u = e.latestFeatureIndex.loadVTLayers();
            for (let S = 0; S < e.latestFeatureIndex.featureIndexArray.length; S++) {
              const k = e.latestFeatureIndex.featureIndexArray.get(S),
                L = u._geojsonTileLayer.feature(k.featureIndex);
              if (l.has(L.id)) return !0
            }
            const {
              buffer: p,
              extent: v
            } = this.workerOptions.geojsonVtOptions, T = (function({
              x: S,
              y: k,
              z: L
            }, V = 0) {
              const B = s.a1((S - V) / Math.pow(2, L)),
                H = s.a2((k + 1 + V) / Math.pow(2, L)),
                re = s.a1((S + 1 + V) / Math.pow(2, L)),
                le = s.a2((k - V) / Math.pow(2, L));
              return new jt([B, H], [re, le])
            })(e.tileID.canonical, p / v);
            for (const S of i)
              if (T.intersects(S)) return !0;
            return !1
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate()
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const l = {
                type: this.type,
                uid: e.uid,
                tileID: e.tileID,
                zoom: e.tileID.overscaledZ,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity: this.map.style.projection.subdivisionGranularity
              };
              e.abortController = new AbortController;
              const u = yield this.actor.sendAsync({
                type: i,
                data: l
              }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(u, this.map.painter, i === "RT")
            }))
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), yield this.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              })
            }))
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({
              type: "RS",
              data: {
                type: this.type,
                source: this.id
              }
            })
          }
          serialize() {
            return s.e({}, this._options, {
              type: this.type,
              data: this._data
            })
          }
          hasTransition() {
            return !1
          }
        }
        class Tr extends s.E {
          constructor(e, i, l, u) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = l, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(u), this.options = i
          }
          load(e) {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this.url = this.options.url, this._request = new AbortController;
              try {
                const i = yield Ye.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, i && i.data && (this.image = i.data, e && (this.coordinates = e), this._finishLoading())
              } catch (i) {
                this._request = null, this._loaded = !0, this.fire(new s.k(i))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null
            })), this) : this
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null)
          }
          setCoordinates(e) {
            this.coordinates = e;
            const i = e.map(s.a5.fromLngLat);
            var l;
            return this.tileID = (function(u) {
              const p = s.a6.fromPoints(u),
                v = p.width(),
                T = p.height(),
                S = Math.max(v, T),
                k = Math.max(0, Math.floor(-Math.log(S) / Math.LN2)),
                L = Math.pow(2, k);
              return new s.a8(k, Math.floor((p.minX + p.maxX) / 2 * L), Math.floor((p.minY + p.maxY) / 2 * L))
            })(i), this.terrainTileRanges = this._getOverlappingTileRanges(i), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i.map((u => this.tileID.getTilePoint(u)._round())), this.flippedWindingOrder = ((l = this.tileCoords)[1].x - l[0].x) * (l[2].y - l[0].y) - (l[1].y - l[0].y) * (l[2].x - l[0].x) < 0, this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "content"
            })), this
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context,
              i = e.gl;
            this.texture || (this.texture = new s.T(e, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let l = !1;
            for (const u in this.tiles) {
              const p = this.tiles[u];
              p.state !== "loaded" && (p.state = "loaded", p.texture = this.texture, l = !0)
            }
            l && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored"
            }))
          }
          serialize() {
            return {
              type: "image",
              url: this.options.url,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return !1
          }
          _getOverlappingTileRanges(e) {
            const {
              minX: i,
              minY: l,
              maxX: u,
              maxY: p
            } = s.a6.fromPoints(e), v = {};
            for (let T = 0; T <= s.a7; T++) {
              const S = Math.pow(2, T),
                k = Math.floor(i * S),
                L = Math.floor(l * S),
                V = Math.floor(u * S),
                B = Math.floor(p * S);
              v[T] = {
                minTileX: k,
                minTileY: L,
                maxTileX: V,
                maxTileY: B
              }
            }
            return v
          }
        }
        class Ar extends Tr {
          constructor(e, i, l, u) {
            super(e, i, l, u), this.roundZoom = !0, this.type = "video", this.options = i
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const i of e.urls) this.urls.push(this.map._requestManager.transformRequest(i, "Source").url);
              try {
                const i = yield s.a9(this.urls);
                if (this._loaded = !0, !i) return;
                this.video = i, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint()
                })), this.map && this.video.play(), this._finishLoading()
              } catch (i) {
                this.fire(new s.k(i))
              }
            }))
          }
          pause() {
            this.video && this.video.pause()
          }
          play() {
            this.video && this.video.play()
          }
          seek(e) {
            if (this.video) {
              const i = this.video.seekable;
              e < i.start(0) || e > i.end(0) ? this.fire(new s.k(new s.aa(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e
            }
          }
          getVideo() {
            return this.video
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context,
              i = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new s.T(e, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let l = !1;
            for (const u in this.tiles) {
              const p = this.tiles[u];
              p.state !== "loaded" && (p.state = "loaded", p.texture = this.texture, l = !0)
            }
            l && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this.video && !this.video.paused
          }
        }
        class xr extends Tr {
          constructor(e, i, l, u) {
            super(e, i, l, u), i.coordinates ? Array.isArray(i.coordinates) && i.coordinates.length === 4 && !i.coordinates.some((p => !Array.isArray(p) || p.length !== 2 || p.some((v => typeof v != "number")))) || this.fire(new s.k(new s.aa(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.k(new s.aa(`sources.${e}`, null, 'missing required property "coordinates"'))), i.animate && typeof i.animate != "boolean" && this.fire(new s.k(new s.aa(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? typeof i.canvas == "string" || i.canvas instanceof HTMLCanvasElement || this.fire(new s.k(new s.aa(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.k(new s.aa(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = i.animate === void 0 || i.animate
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint()
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1)
              }, this._finishLoading())
            }))
          }
          getCanvas() {
            return this.canvas
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play()
          }
          onRemove() {
            this.pause()
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const i = this.map.painter.context,
              l = i.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
              premultiply: !0
            }) : this.texture = new s.T(i, this.canvas, l.RGBA, {
              premultiply: !0
            });
            let u = !1;
            for (const p in this.tiles) {
              const v = this.tiles[p];
              v.state !== "loaded" && (v.state = "loaded", v.texture = this.texture, u = !0)
            }
            u && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "canvas",
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this._playing
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height])
              if (isNaN(e) || e <= 0) return !0;
            return !1
          }
        }
        const qt = {},
          Yr = h => {
            switch (h) {
              case "geojson":
                return Jr;
              case "image":
                return Tr;
              case "raster":
                return Gt;
              case "raster-dem":
                return Yt;
              case "vector":
                return Lt;
              case "video":
                return Ar;
              case "canvas":
                return xr
            }
            return qt[h]
          },
          Le = "RTLPluginLoaded";
        class j extends s.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Bt()
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", {
              pluginStatus: e,
              pluginURL: this.url
            }).catch((i => {
              throw this.status = "error", i
            }))
          }
          getRTLTextPluginStatus() {
            return this.status
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null
          }
          setRTLTextPlugin(e) {
            return s._(this, arguments, void 0, (function*(i, l = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = ae.resolveURL(i), !this.url) throw new Error(`requested url ${i} is invalid`);
              if (this.status === "unavailable") {
                if (!l) return this._requestImport();
                this.status = "deferred", this._syncState(this.status)
              } else if (this.status === "requested") return this._requestImport()
            }))
          }
          _requestImport() {
            return s._(this, void 0, void 0, (function*() {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new s.l(Le))
            }))
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
          }
        }
        let E = null;

        function D() {
          return E || (E = new j), E
        }
        var N, X;
        (function(h) {
          h[h.Base = 0] = "Base", h[h.Parent = 1] = "Parent"
        })(N || (N = {})), (function(h) {
          h[h.Departing = 0] = "Departing", h[h.Incoming = 1] = "Incoming"
        })(X || (X = {}));
        class ee {
          constructor(e, i) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e, this.uid = s.ab(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading"
          }
          isRenderable(e) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e || !this.holdingForSymbolFade())
          }
          setCrossFadeLogic({
            fadingRole: e,
            fadingDirection: i,
            fadingParentID: l,
            fadeEndTime: u
          }) {
            this.resetFadeLogic(), this.fadingRole = e, this.fadingDirection = i, this.fadingParentID = l, this.fadeEndTime = u
          }
          setSelfFadeLogic(e) {
            this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = e
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = ie(), this.fadeEndTime = 0, this.fadeOpacity = 1
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null
          }
          loadVectorData(e, i, l) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(u, p) {
                const v = {};
                if (!p) return v;
                for (const T of u) {
                  const S = T.layerIds.map((k => p.getLayer(k))).filter(Boolean);
                  if (S.length !== 0) {
                    T.layers = S, T.stateDependentLayerIds && (T.stateDependentLayers = T.stateDependentLayerIds.map((k => S.filter((L => L.id === k))[0])));
                    for (const k of S) v[k.id] = T
                  }
                }
                return v
              })(e.buckets, i == null ? void 0 : i.style), this.hasSymbolBuckets = !1;
              for (const u in this.buckets) {
                const p = this.buckets[u];
                if (p instanceof s.ad) {
                  if (this.hasSymbolBuckets = !0, !l) break;
                  p.justReloaded = !0
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets)
                for (const u in this.buckets) {
                  const p = this.buckets[u];
                  if (p instanceof s.ad && p.hasRTLText) {
                    this.hasRTLText = !0, D().lazyLoad();
                    break
                  }
                }
              this.queryPadding = 0;
              for (const u in this.buckets) {
                const p = this.buckets[u];
                this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(u).queryRadius(p))
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), this.dashPositions = e.dashPositions
            } else this.collisionBoxArray = new s.ac
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded"
          }
          getBucket(e) {
            return this.buckets[e.id]
          }
          upload(e) {
            for (const l in this.buckets) {
              const u = this.buckets[l];
              u.uploadPending() && u.upload(e)
            }
            const i = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new s.T(e, this.imageAtlas.image, i.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new s.T(e, this.glyphAtlasImage, i.ALPHA), this.glyphAtlasImage = null)
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
          }
          queryRenderedFeatures(e, i, l, u, p, v, T, S, k, L, V) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
              queryGeometry: u,
              cameraQueryGeometry: p,
              scale: v,
              tileSize: this.tileSize,
              pixelPosMatrix: L,
              transform: S,
              params: T,
              queryPadding: this.queryPadding * k,
              getElevation: V
            }, e, i, l) : {}
          }
          querySourceFeatures(e, i) {
            const l = this.latestFeatureIndex;
            if (!l || !l.rawTileData) return;
            const u = l.loadVTLayers(),
              p = i && i.sourceLayer ? i.sourceLayer : "",
              v = u._geojsonTileLayer || u[p];
            if (!v) return;
            const T = s.ae(i == null ? void 0 : i.filter, i == null ? void 0 : i.globalState),
              {
                z: S,
                x: k,
                y: L
              } = this.tileID.canonical,
              V = {
                z: S,
                x: k,
                y: L
              };
            for (let B = 0; B < v.length; B++) {
              const H = v.feature(B);
              if (T.needGeometry) {
                const ue = s.af(H, !0);
                if (!T.filter(new s.G(this.tileID.overscaledZ), ue, this.tileID.canonical)) continue
              } else if (!T.filter(new s.G(this.tileID.overscaledZ), H)) continue;
              const re = l.getId(H, p),
                le = new s.ag(H, S, k, L, re);
              le.tile = V, e.push(le)
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
          }
          setExpiryData(e) {
            const i = this.expirationTime;
            if (e.cacheControl) {
              const l = s.ah(e.cacheControl);
              l["max-age"] && (this.expirationTime = Date.now() + 1e3 * l["max-age"])
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const l = Date.now();
              let u = !1;
              if (this.expirationTime > l) u = !1;
              else if (i)
                if (this.expirationTime < i) u = !0;
                else {
                  const p = this.expirationTime - i;
                  p ? this.expirationTime = l + Math.max(p, 3e4) : u = !0
                }
              else u = !0;
              u ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
          }
          setFeatureState(e, i) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const l = this.latestFeatureIndex.loadVTLayers();
            for (const u in this.buckets) {
              if (!i.style.hasLayer(u)) continue;
              const p = this.buckets[u],
                v = p.layers[0].sourceLayer || "_geojsonTileLayer",
                T = l[v],
                S = e[v];
              if (!T || !S || Object.keys(S).length === 0) continue;
              p.update(S, T, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const k = i && i.style && i.style.getLayer(u);
              k && (this.queryPadding = Math.max(this.queryPadding, k.queryRadius(p)))
            }
          }
          holdingForSymbolFade() {
            return this.symbolFadeHoldUntil !== void 0
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < ie()
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0
          }
          setSymbolHoldDuration(e) {
            this.symbolFadeHoldUntil = ie() + e
          }
          setDependencies(e, i) {
            const l = {};
            for (const u of i) l[u] = !0;
            this.dependencies[e] = l
          }
          hasDependency(e, i) {
            for (const l of e) {
              const u = this.dependencies[l];
              if (u) {
                for (const p of i)
                  if (u[p]) return !0
              }
            }
            return !1
          }
        }
        class pe {
          constructor(e, i) {
            this.max = e, this.onRemove = i, this.reset()
          }
          reset() {
            for (const e in this.data)
              for (const i of this.data[e]) i.timeout && clearTimeout(i.timeout), this.onRemove(i.value);
            return this.data = {}, this.order = [], this
          }
          add(e, i, l) {
            const u = e.wrapped().key;
            this.data[u] === void 0 && (this.data[u] = []);
            const p = {
              value: i,
              timeout: void 0
            };
            if (l !== void 0 && (p.timeout = setTimeout((() => {
                this.remove(e, p)
              }), l)), this.data[u].push(p), this.order.push(u), this.order.length > this.max) {
              const v = this._getAndRemoveByKey(this.order[0]);
              v && this.onRemove(v)
            }
            return this
          }
          has(e) {
            return e.wrapped().key in this.data
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
          }
          _getAndRemoveByKey(e) {
            const i = this.data[e].shift();
            return i.timeout && clearTimeout(i.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), i.value
          }
          getByKey(e) {
            const i = this.data[e];
            return i ? i[0].value : null
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null
          }
          remove(e, i) {
            if (!this.has(e)) return this;
            const l = e.wrapped().key,
              u = i === void 0 ? 0 : this.data[l].indexOf(i),
              p = this.data[l][u];
            return this.data[l].splice(u, 1), p.timeout && clearTimeout(p.timeout), this.data[l].length === 0 && delete this.data[l], this.onRemove(p.value), this.order.splice(this.order.indexOf(l), 1), this
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max;) {
              const i = this._getAndRemoveByKey(this.order[0]);
              i && this.onRemove(i)
            }
            return this
          }
          filter(e) {
            const i = [];
            for (const l in this.data)
              for (const u of this.data[l]) e(u.value) || i.push(u);
            for (const l of i) this.remove(l.value.tileID, l)
          }
        }
        class be {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {}
          }
          updateState(e, i, l) {
            const u = String(i);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][u] = this.stateChanges[e][u] || {}, s.e(this.stateChanges[e][u], l), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const p in this.state[e]) p !== u && (this.deletedStates[e][p] = null)
            } else if (this.deletedStates[e] && this.deletedStates[e][u] === null) {
              this.deletedStates[e][u] = {};
              for (const p in this.state[e][u]) l[p] || (this.deletedStates[e][u][p] = null)
            } else
              for (const p in l) this.deletedStates[e] && this.deletedStates[e][u] && this.deletedStates[e][u][p] === null && delete this.deletedStates[e][u][p]
          }
          removeFeatureState(e, i, l) {
            if (this.deletedStates[e] === null) return;
            const u = String(i);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, l && i !== void 0) this.deletedStates[e][u] !== null && (this.deletedStates[e][u] = this.deletedStates[e][u] || {}, this.deletedStates[e][u][l] = null);
            else if (i !== void 0)
              if (this.stateChanges[e] && this.stateChanges[e][u])
                for (l in this.deletedStates[e][u] = {}, this.stateChanges[e][u]) this.deletedStates[e][u][l] = null;
              else this.deletedStates[e][u] = null;
            else this.deletedStates[e] = null
          }
          getState(e, i) {
            const l = String(i),
              u = s.e({}, (this.state[e] || {})[l], (this.stateChanges[e] || {})[l]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const p = this.deletedStates[e][i];
              if (p === null) return {};
              for (const v in p) delete u[v]
            }
            return u
          }
          initializeTileState(e, i) {
            e.setFeatureState(this.state, i)
          }
          coalesceChanges(e, i) {
            const l = {};
            for (const u in this.stateChanges) {
              this.state[u] = this.state[u] || {};
              const p = {};
              for (const v in this.stateChanges[u]) this.state[u][v] || (this.state[u][v] = {}), s.e(this.state[u][v], this.stateChanges[u][v]), p[v] = this.state[u][v];
              l[u] = p
            }
            for (const u in this.deletedStates) {
              this.state[u] = this.state[u] || {};
              const p = {};
              if (this.deletedStates[u] === null)
                for (const v in this.state[u]) p[v] = {}, this.state[u][v] = {};
              else
                for (const v in this.deletedStates[u]) {
                  if (this.deletedStates[u][v] === null) this.state[u][v] = {};
                  else
                    for (const T of Object.keys(this.deletedStates[u][v])) delete this.state[u][v][T];
                  p[v] = this.state[u][v]
                }
              l[u] = l[u] || {}, s.e(l[u], p)
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(l).length !== 0)
              for (const u in e) e[u].setFeatureState(l, i)
          }
        }
        const ye = 89.25;

        function Oe(h, e) {
          const i = s.ai(e.lat, -s.aj, s.aj);
          return new s.P(s.X(e.lng) * h, s.W(i) * h)
        }

        function oe(h, e) {
          return new s.a5(e.x / h, e.y / h).toLngLat()
        }

        function K(h) {
          return h.cameraToCenterDistance * Math.min(.85 * Math.tan(s.ak(90 - h.pitch)), Math.tan(s.ak(ye - h.pitch)))
        }

        function he(h, e) {
          const i = h.canonical,
            l = e / s.al(i.z),
            u = i.x + Math.pow(2, i.z) * h.wrap,
            p = s.am(new Float64Array(16));
          return s.N(p, p, [u * l, i.y * l, 0]), s.O(p, p, [l / s.a3, l / s.a3, 1]), p
        }

        function Q(h, e, i, l, u) {
          const p = s.a5.fromLngLat(h, e),
            v = u * s.an(1, h.lat),
            T = v * Math.cos(s.ak(i)),
            S = Math.sqrt(v * v - T * T),
            k = S * Math.sin(s.ak(-l)),
            L = S * Math.cos(s.ak(-l));
          return new s.a5(p.x + k, p.y + L, p.z + T)
        }

        function ze(h, e, i) {
          const l = e.intersectsFrustum(h);
          if (!i || l === 0) return l;
          const u = e.intersectsPlane(i);
          return u === 0 ? 0 : l === 2 && u === 2 ? 2 : 1
        }

        function $e(h, e, i) {
          let l = 0;
          const u = (i - e) / 10;
          for (let p = 0; p < 10; p++) l += u * Math.pow(Math.cos(e + (p + .5) / 10 * (i - e)), h);
          return l
        }

        function Re(h, e) {
          return function(i, l, u, p, v) {
            const T = 2 * ((h - 1) / s.ao(Math.cos(s.ak(ye - v)) / Math.cos(s.ak(ye))) - 1),
              S = Math.acos(u / p),
              k = 2 * $e(T - 1, 0, s.ak(v / 2)),
              L = Math.min(s.ak(ye), S + s.ak(v / 2)),
              V = $e(T - 1, Math.min(L, S - s.ak(v / 2)), L),
              B = Math.atan(l / u),
              H = Math.hypot(l, u);
            let re = i;
            return re += s.ao(p / H / Math.max(.5, Math.cos(s.ak(v / 2)))), re += T * s.ao(Math.cos(B)) / 2, re -= s.ao(Math.max(1, V / k / e)) / 2, re
          }
        }
        const ft = Re(9.314, 3);

        function Mt(h, e) {
          const i = (e.roundZoom ? Math.round : Math.floor)(h.zoom + s.ao(h.tileSize / e.tileSize));
          return Math.max(0, i)
        }

        function Et(h, e) {
          const i = h.getCameraFrustum(),
            l = h.getClippingPlane(),
            u = h.screenPointToMercatorCoordinate(h.getCameraPoint()),
            p = s.a5.fromLngLat(h.center, h.elevation);
          u.z = p.z + Math.cos(h.pitchInRadians) * h.cameraToCenterDistance / h.worldSize;
          const v = h.getCoveringTilesDetailsProvider(),
            T = v.allowVariableZoom(h, e),
            S = Mt(h, e),
            k = e.minzoom || 0,
            L = e.maxzoom !== void 0 ? e.maxzoom : h.maxZoom,
            V = Math.min(Math.max(0, S), L),
            B = Math.pow(2, V),
            H = [B * u.x, B * u.y, 0],
            re = [B * p.x, B * p.y, 0],
            le = Math.hypot(p.x - u.x, p.y - u.y),
            ue = Math.abs(p.z - u.z),
            de = Math.hypot(le, ue),
            ve = ke => ({
              zoom: 0,
              x: 0,
              y: 0,
              wrap: ke,
              fullyVisible: !1
            }),
            Ae = [],
            _e = [];
          if (h.renderWorldCopies && v.allowWorldCopies())
            for (let ke = 1; ke <= 3; ke++) Ae.push(ve(-ke)), Ae.push(ve(ke));
          for (Ae.push(ve(0)); Ae.length > 0;) {
            const ke = Ae.pop(),
              Fe = ke.x,
              xe = ke.y;
            let Ve = ke.fullyVisible;
            const lt = {
                x: Fe,
                y: xe,
                z: ke.zoom
              },
              rt = v.getTileBoundingVolume(lt, ke.wrap, h.elevation, e);
            if (!Ve) {
              const rr = ze(i, rt, l);
              if (rr === 0) continue;
              Ve = rr === 2
            }
            const at = v.distanceToTile2d(u.x, u.y, lt, rt);
            let ct = S;
            T && (ct = (e.calculateTileZoom || ft)(h.zoom + s.ao(h.tileSize / e.tileSize), at, ue, de, h.fov)), ct = (e.roundZoom ? Math.round : Math.floor)(ct), ct = Math.max(0, ct);
            const er = Math.min(ct, L);
            if (ke.wrap = v.getWrap(p, lt, ke.wrap), ke.zoom >= er) {
              if (ke.zoom < k) continue;
              const rr = V - ke.zoom,
                kt = H[0] - .5 - (Fe << rr),
                Br = H[1] - .5 - (xe << rr),
                Pn = e.reparseOverscaled ? Math.max(ke.zoom, ct) : ke.zoom;
              _e.push({
                tileID: new s.a0(ke.zoom === L ? Pn : ke.zoom, ke.wrap, ke.zoom, Fe, xe),
                distanceSq: s.ap([re[0] - .5 - Fe, re[1] - .5 - xe]),
                tileDistanceToCamera: Math.sqrt(kt * kt + Br * Br)
              })
            } else
              for (let rr = 0; rr < 4; rr++) Ae.push({
                zoom: ke.zoom + 1,
                x: (Fe << 1) + rr % 2,
                y: (xe << 1) + (rr >> 1),
                wrap: ke.wrap,
                fullyVisible: Ve
              })
          }
          return _e.sort(((ke, Fe) => ke.distanceSq - Fe.distanceSq)).map((ke => ke.tileID))
        }
        const dt = s.a6.fromPoints([new s.P(0, 0), new s.P(s.a3, s.a3)]);
        class Kt extends s.E {
          constructor(e, i, l) {
            super(), this.id = e, this.dispatcher = l, this.on("data", (u => this._dataHandler(u))), this.on("dataloading", (() => {
              this._sourceErrored = !1
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded()
            })), this._source = ((u, p, v, T) => {
              const S = new(Yr(p.type))(u, p, v, T);
              if (S.id !== u) throw new Error(`Expected Source id to be ${u} instead of ${S.id}`);
              return S
            })(e, i, l, this), this._tiles = {}, this._cache = new pe(0, (u => this._unloadTile(u))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new be, this._didEmitContent = !1, this._updated = !1
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e)
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e)
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const i = this._tiles[e];
              if (i.state !== "loaded" && i.state !== "errored") return !1
            }
            return !0
          }
          getSource() {
            return this._source
          }
          getState() {
            return this._state
          }
          pause() {
            this._paused = !0
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain)
          }
          _loadTile(e, i, l) {
            return s._(this, void 0, void 0, (function*() {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, i, l)
              } catch (u) {
                e.state = "errored", u.status !== 404 ? this._source.fire(new s.k(u, {
                  tile: e
                })) : this.update(this.transform, this.terrain)
              }
            }))
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e)
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new s.l("dataabort", {
              tile: e,
              coord: e.tileID,
              dataType: "source"
            }))
          }
          serialize() {
            return this._source.serialize()
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const i in this._tiles) {
              const l = this._tiles[i];
              l.upload(e), l.prepare(this.map.style.imageManager)
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e => e.tileID)).sort(Qt).map((e => e.key))
          }
          getRenderableIds(e) {
            const i = [];
            for (const l in this._tiles) this._isIdRenderable(l, e) && i.push(this._tiles[l]);
            return e ? i.sort(((l, u) => {
              const p = l.tileID,
                v = u.tileID,
                T = new s.P(p.canonical.x, p.canonical.y)._rotate(-this.transform.bearingInRadians),
                S = new s.P(v.canonical.x, v.canonical.y)._rotate(-this.transform.bearingInRadians);
              return p.overscaledZ - v.overscaledZ || S.y - T.y || S.x - T.x
            })).map((l => l.tileID.key)) : i.map((l => l.tileID)).sort(Qt).map((l => l.key))
          }
          hasRenderableParent(e) {
            const i = e.overscaledZ - 1;
            if (i >= this._source.minzoom) {
              const l = this.getLoadedTile(e.scaledTo(i));
              if (l) return this._isIdRenderable(l.tileID.key)
            }
            return !1
          }
          _isIdRenderable(e, i = !1) {
            var l;
            return (l = this._tiles[e]) === null || l === void 0 ? void 0 : l.isRenderable(i)
          }
          reload(e, i = void 0) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const l in this._tiles) i && this._source.shouldReloadTile && !this._source.shouldReloadTile(this._tiles[l], i) || (e ? this._reloadTile(l, "expired") : this._tiles[l].state !== "errored" && this._reloadTile(l, "reloading"))
            }
          }
          _reloadTile(e, i) {
            return s._(this, void 0, void 0, (function*() {
              const l = this._tiles[e];
              l && (l.state !== "loading" && (l.state = i), yield this._loadTile(l, e, i))
            }))
          }
          _tileLoaded(e, i, l) {
            e.timeAdded = ie(), e.selfFading && (e.fadeEndTime = e.timeAdded + this._rasterFadeDuration), l === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new s.l("data", {
              dataType: "source",
              tile: e,
              coord: e.tileID
            }))
          }
          _backfillDEM(e) {
            const i = this.getRenderableIds();
            for (let u = 0; u < i.length; u++) {
              const p = i[u];
              if (e.neighboringTiles && e.neighboringTiles[p]) {
                const v = this.getTileByID(p);
                l(e, v), l(v, e)
              }
            }

            function l(u, p) {
              u.needsHillshadePrepare = !0, u.needsTerrainPrepare = !0;
              let v = p.tileID.canonical.x - u.tileID.canonical.x;
              const T = p.tileID.canonical.y - u.tileID.canonical.y,
                S = Math.pow(2, u.tileID.canonical.z),
                k = p.tileID.key;
              v === 0 && T === 0 || Math.abs(T) > 1 || (Math.abs(v) > 1 && (Math.abs(v + S) === 1 ? v += S : Math.abs(v - S) === 1 && (v -= S)), p.dem && u.dem && (u.dem.backfillBorder(p.dem, v, T), u.neighboringTiles && u.neighboringTiles[k] && (u.neighboringTiles[k].backfilled = !0)))
            }
          }
          getTile(e) {
            return this.getTileByID(e.key)
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          _retainLoadedChildren(e, i) {
            const l = Object.values(e),
              u = this._getLoadedDescendents(l),
              p = {};
            for (const v of l) {
              const T = u[v.key];
              if (!(T != null && T.length)) {
                p[v.key] = v;
                continue
              }
              const S = v.overscaledZ + Kt.maxUnderzooming,
                k = T.filter((B => B.tileID.overscaledZ <= S));
              if (!k.length) {
                p[v.key] = v;
                continue
              }
              const L = Math.min(...k.map((B => B.tileID.overscaledZ))),
                V = k.filter((B => B.tileID.overscaledZ === L)).map((B => B.tileID));
              for (const B of V) i[B.key] = B;
              this._areDescendentsComplete(V, L, v.overscaledZ) || (p[v.key] = v)
            }
            return p
          }
          _getLoadedDescendents(e) {
            var i;
            const l = {};
            for (const u in this._tiles) {
              const p = this._tiles[u];
              if (p.hasData())
                for (const v of e) p.tileID.isChildOf(v) && (l[i = v.key] || (l[i] = [])).push(p)
            }
            return l
          }
          _areDescendentsComplete(e, i, l) {
            return e.length === 1 && e[0].isOverscaled() ? e[0].overscaledZ === i : Math.pow(4, i - l) === e.length
          }
          getLoadedTile(e) {
            const i = this._tiles[e.key];
            return i != null && i.hasData() ? i : null
          }
          updateCacheSize(e) {
            const i = Math.ceil(e.width / this._source.tileSize) + 1,
              l = Math.ceil(e.height / this._source.tileSize) + 1,
              u = Math.floor(i * l * (this._maxTileCacheZoomLevels === null ? s.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)),
              p = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, u) : u;
            this._cache.setMaxSize(p)
          }
          handleWrapJump(e) {
            const i = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, i) {
              const l = {};
              for (const u in this._tiles) {
                const p = this._tiles[u];
                p.tileID = p.tileID.unwrapTo(p.tileID.wrap + i), l[p.tileID.key] = p
              }
              this._tiles = l, this._resetTileReloadTimers()
            }
          }
          update(e, i) {
            if (!this._sourceLoaded || this._paused) return;
            let l;
            this.transform = e, this.terrain = i, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? l = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((S => new s.a0(S.canonical.z, S.wrap, S.canonical.z, S.canonical.x, S.canonical.y))) : (l = Et(e, {
              tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
              minzoom: this._source.minzoom,
              maxzoom: this._source.maxzoom,
              roundZoom: !this.usedForTerrain && this._source.roundZoom,
              reparseOverscaled: this._source.reparseOverscaled,
              terrain: i,
              calculateTileZoom: this._source.calculateTileZoom
            }), this._source.hasTile && (l = l.filter((S => this._source.hasTile(S))))) : l = [], this.usedForTerrain && (l = this._addTerrainIdealTiles(l));
            const u = l.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, u && this.fire(new s.l("data", {
              sourceDataType: "idle",
              dataType: "source",
              sourceId: this.id
            }));
            const p = Mt(e, this._source),
              v = this._updateRetainedTiles(l, p),
              T = Sr(this._source.type);
            T && this._rasterFadeDuration > 0 && !i && this._updateFadingTiles(l, v), T ? this._cleanUpRasterTiles(v) : this._cleanUpVectorTiles(v)
          }
          _cleanUpRasterTiles(e) {
            for (const i in this._tiles) e[i] || this._removeTile(i)
          }
          _cleanUpVectorTiles(e) {
            for (const i in this._tiles) {
              const l = this._tiles[i];
              e[i] ? l.clearSymbolFadeHold() : l.hasSymbolBuckets ? l.holdingForSymbolFade() ? l.symbolFadeFinished() && this._removeTile(i) : l.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(i)
            }
          }
          _addTerrainIdealTiles(e) {
            const i = [];
            for (const l of e)
              if (l.canonical.z > this._source.minzoom) {
                const u = l.scaledTo(l.canonical.z - 1);
                i.push(u);
                const p = l.scaledTo(Math.max(this._source.minzoom, Math.min(l.canonical.z, 5)));
                i.push(p)
              } return e.concat(i)
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForSymbolFade() && this._removeTile(e)
          }
          _updateRetainedTiles(e, i) {
            var l;
            const u = {},
              p = {},
              v = Math.max(i - Kt.maxOverzooming, this._source.minzoom);
            let T = {};
            for (const S of e) {
              const k = this._addTile(S);
              u[S.key] = S, k.hasData() || (T[S.key] = S)
            }
            T = this._retainLoadedChildren(T, u);
            for (const S in T) {
              const k = T[S];
              let L = this._tiles[S],
                V = L == null ? void 0 : L.wasRequested();
              for (let B = k.overscaledZ - 1; B >= v; --B) {
                const H = k.scaledTo(B);
                if (p[H.key]) break;
                if (p[H.key] = !0, L = this.getTile(H), !L && V && (L = this._addTile(H)), L) {
                  const re = L.hasData();
                  if ((re || !(!((l = this.map) === null || l === void 0) && l.cancelPendingTileRequestsWhileZooming) || V) && (u[H.key] = H), V = L.wasRequested(), re) break
                }
              }
            }
            return u
          }
          _updateFadingTiles(e, i) {
            const l = ie(),
              u = s.aq(e);
            for (const p of e) {
              const v = this._tiles[p.key];
              v.fadingDirection !== X.Departing && v.fadeOpacity !== 0 || v.resetFadeLogic(), this._updateFadingAncestor(v, i, l) || this._updateFadingDescendents(v, i, l) || this._updateFadingEdge(v, u, l) || v.resetFadeLogic()
            }
          }
          _updateFadingAncestor(e, i, l) {
            if (!e.hasData()) return !1;
            const {
              tileID: u,
              fadingRole: p,
              fadingDirection: v,
              fadingParentID: T
            } = e;
            if (p === N.Base && v === X.Incoming && T) return i[T.key] = T, !0;
            const S = Math.max(u.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
            for (let k = u.overscaledZ - 1; k >= S; k--) {
              const L = u.scaledTo(k),
                V = this.getLoadedTile(L);
              if (V) return e.setCrossFadeLogic({
                fadingRole: N.Base,
                fadingDirection: X.Incoming,
                fadingParentID: V.tileID,
                fadeEndTime: l + this._rasterFadeDuration
              }), V.setCrossFadeLogic({
                fadingRole: N.Parent,
                fadingDirection: X.Departing,
                fadeEndTime: l + this._rasterFadeDuration
              }), i[L.key] = L, !0
            }
            return !1
          }
          _updateFadingDescendents(e, i, l) {
            if (!e.hasData()) return !1;
            const u = e.tileID.children(this._source.maxzoom);
            let p = this._updateFadingChildren(e, u, i, l);
            if (p) return !0;
            for (const v of u) {
              const T = v.children(this._source.maxzoom);
              this._updateFadingChildren(e, T, i, l) && (p = !0)
            }
            return p
          }
          _updateFadingChildren(e, i, l, u) {
            if (i[0].overscaledZ >= this._source.maxzoom) return !1;
            let p = !1;
            for (const v of i) {
              const T = this.getLoadedTile(v);
              if (!T) continue;
              const {
                fadingRole: S,
                fadingDirection: k,
                fadingParentID: L
              } = T;
              S === N.Base && k === X.Departing && L || (T.setCrossFadeLogic({
                fadingRole: N.Base,
                fadingDirection: X.Departing,
                fadingParentID: e.tileID,
                fadeEndTime: u + this._rasterFadeDuration
              }), e.setCrossFadeLogic({
                fadingRole: N.Parent,
                fadingDirection: X.Incoming,
                fadeEndTime: u + this._rasterFadeDuration
              })), l[v.key] = v, p = !0
            }
            return p
          }
          _updateFadingEdge(e, i, l) {
            const u = e.tileID;
            return !!e.selfFading || !e.hasData() && !!i.has(u) && (e.setSelfFadeLogic(l + this._rasterFadeDuration), !0)
          }
          _addTile(e) {
            let i = this._tiles[e.key];
            if (i) return i;
            i = this._cache.getAndRemove(e), i && (i.resetFadeLogic(), this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null));
            const l = i;
            return i || (i = new ee(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(i, e.key, i.state)), i.uses++, this._tiles[e.key] = i, l || this._source.fire(new s.l("dataloading", {
              tile: i,
              coord: i.tileID,
              dataType: "source"
            })), i
          }
          _setTileReloadTimer(e, i) {
            this._clearTileReloadTimer(e);
            const l = i.getExpiryTimeout();
            l && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e]
            }), l))
          }
          _clearTileReloadTimer(e) {
            const i = this._timers[e];
            i && (clearTimeout(i), delete this._timers[e])
          }
          _resetTileReloadTimers() {
            for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];
            for (const e in this._tiles) this._setTileReloadTimer(e, this._tiles[e])
          }
          refreshTiles(e) {
            for (const i in this._tiles)(this._isIdRenderable(i) || this._tiles[i].state == "errored") && e.some((l => l.equals(this._tiles[i].tileID.canonical))) && this._reloadTile(i, "expired")
          }
          _removeTile(e) {
            const i = this._tiles[e];
            i && (i.uses--, delete this._tiles[e], this._clearTileReloadTimer(e), i.uses > 0 || (i.hasData() && i.state !== "reloading" ? this._cache.add(i.tileID, i, i.getExpiryTimeout()) : (i.aborted = !0, this._abortTile(i), this._unloadTile(i))))
          }
          _dataHandler(e) {
            e.dataType === "source" && (e.sourceDataType !== "metadata" ? e.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(e.sourceDataChanged, e.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0)
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset()
          }
          tilesIn(e, i, l) {
            const u = [],
              p = this.transform;
            if (!p) return u;
            const v = p.getCoveringTilesDetailsProvider().allowWorldCopies(),
              T = l ? p.getCameraQueryGeometry(e) : e,
              S = H => p.screenPointToMercatorCoordinate(H, this.terrain),
              k = this.transformBbox(e, S, !v),
              L = this.transformBbox(T, S, !v),
              V = this.getIds(),
              B = s.a6.fromPoints(L);
            for (let H = 0; H < V.length; H++) {
              const re = this._tiles[V[H]];
              if (re.holdingForSymbolFade()) continue;
              const le = v ? [re.tileID] : [re.tileID.unwrapTo(-1), re.tileID.unwrapTo(0)],
                ue = Math.pow(2, p.zoom - re.tileID.overscaledZ),
                de = i * re.queryPadding * s.a3 / re.tileSize / ue;
              for (const ve of le) {
                const Ae = B.map((_e => ve.getTilePoint(new s.a5(_e.x, _e.y))));
                if (Ae.expandBy(de), Ae.intersects(dt)) {
                  const _e = k.map((Fe => ve.getTilePoint(Fe))),
                    ke = L.map((Fe => ve.getTilePoint(Fe)));
                  u.push({
                    tile: re,
                    tileID: v ? ve : ve.unwrapTo(0),
                    queryGeometry: _e,
                    cameraQueryGeometry: ke,
                    scale: ue
                  })
                }
              }
            }
            return u
          }
          transformBbox(e, i, l) {
            let u = e.map(i);
            if (l) {
              const p = s.a6.fromPoints(e);
              p.shrinkBy(.001 * Math.min(p.width(), p.height()));
              const v = p.map(i);
              s.a6.fromPoints(u).covers(v) || (u = u.map((T => T.x > .5 ? new s.a5(T.x - 1, T.y, T.z) : T)))
            }
            return u
          }
          getVisibleCoordinates(e) {
            const i = this.getRenderableIds(e).map((l => this._tiles[l].tileID));
            return this.transform && this.transform.populateCache(i), i
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (Sr(this._source.type) && this._rasterFadeDuration > 0) {
              const e = ie();
              for (const i in this._tiles)
                if (this._tiles[i].fadeEndTime >= e) return !0
            }
            return !1
          }
          setRasterFadeDuration(e) {
            this._rasterFadeDuration = e
          }
          setFeatureState(e, i, l) {
            this._state.updateState(e = e || "_geojsonTileLayer", i, l)
          }
          removeFeatureState(e, i, l) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", i, l)
          }
          getFeatureState(e, i) {
            return this._state.getState(e = e || "_geojsonTileLayer", i)
          }
          setDependencies(e, i, l) {
            const u = this._tiles[e];
            u && u.setDependencies(i, l)
          }
          reloadTilesForDependencies(e, i) {
            for (const l in this._tiles) this._tiles[l].hasDependency(e, i) && this._reloadTile(l, "reloading");
            this._cache.filter((l => !l.hasDependency(e, i)))
          }
        }

        function Qt(h, e) {
          const i = Math.abs(2 * h.wrap) - +(h.wrap < 0),
            l = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return h.overscaledZ - e.overscaledZ || l - i || e.canonical.y - h.canonical.y || e.canonical.x - h.canonical.x
        }

        function Sr(h) {
          return h === "raster" || h === "image" || h === "video"
        }
        Kt.maxOverzooming = 10, Kt.maxUnderzooming = 3;
        class Ft {
          constructor(e, i) {
            this.reset(e, i)
          }
          reset(e, i) {
            this.points = e || [], this._distances = [0];
            for (let l = 1; l < this.points.length; l++) this._distances[l] = this._distances[l - 1] + this.points[l].dist(this.points[l - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(i || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = s.ai(e, 0, 1);
            let i = 1,
              l = this._distances[i];
            const u = e * this.paddedLength + this.padding;
            for (; l < u && i < this._distances.length;) l = this._distances[++i];
            const p = i - 1,
              v = this._distances[p],
              T = l - v,
              S = T > 0 ? (u - v) / T : 0;
            return this.points[p].mult(1 - S).add(this.points[i].mult(S))
          }
        }

        function Ze(h, e) {
          let i = !0;
          return h === "always" || h !== "never" && e !== "never" || (i = !1), i
        }
        class Pr {
          constructor(e, i, l) {
            const u = this.boxCells = [],
              p = this.circleCells = [];
            this.xCellCount = Math.ceil(e / l), this.yCellCount = Math.ceil(i / l);
            for (let v = 0; v < this.xCellCount * this.yCellCount; v++) u.push([]), p.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = i, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / i, this.boxUid = 0, this.circleUid = 0
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length
          }
          insert(e, i, l, u, p) {
            this._forEachCell(i, l, u, p, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(i), this.bboxes.push(l), this.bboxes.push(u), this.bboxes.push(p)
          }
          insertCircle(e, i, l, u) {
            this._forEachCell(i - u, l - u, i + u, l + u, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(i), this.circles.push(l), this.circles.push(u)
          }
          _insertBoxCell(e, i, l, u, p, v) {
            this.boxCells[p].push(v)
          }
          _insertCircleCell(e, i, l, u, p, v) {
            this.circleCells[p].push(v)
          }
          _query(e, i, l, u, p, v, T) {
            if (l < 0 || e > this.width || u < 0 || i > this.height) return [];
            const S = [];
            if (e <= 0 && i <= 0 && this.width <= l && this.height <= u) {
              if (p) return [{
                key: null,
                x1: e,
                y1: i,
                x2: l,
                y2: u
              }];
              for (let k = 0; k < this.boxKeys.length; k++) S.push({
                key: this.boxKeys[k],
                x1: this.bboxes[4 * k],
                y1: this.bboxes[4 * k + 1],
                x2: this.bboxes[4 * k + 2],
                y2: this.bboxes[4 * k + 3]
              });
              for (let k = 0; k < this.circleKeys.length; k++) {
                const L = this.circles[3 * k],
                  V = this.circles[3 * k + 1],
                  B = this.circles[3 * k + 2];
                S.push({
                  key: this.circleKeys[k],
                  x1: L - B,
                  y1: V - B,
                  x2: L + B,
                  y2: V + B
                })
              }
            } else this._forEachCell(e, i, l, u, this._queryCell, S, {
              hitTest: p,
              overlapMode: v,
              seenUids: {
                box: {},
                circle: {}
              }
            }, T);
            return S
          }
          query(e, i, l, u) {
            return this._query(e, i, l, u, !1, null)
          }
          hitTest(e, i, l, u, p, v) {
            return this._query(e, i, l, u, !0, p, v).length > 0
          }
          hitTestCircle(e, i, l, u, p) {
            const v = e - l,
              T = e + l,
              S = i - l,
              k = i + l;
            if (T < 0 || v > this.width || k < 0 || S > this.height) return !1;
            const L = [];
            return this._forEachCell(v, S, T, k, this._queryCellCircle, L, {
              hitTest: !0,
              overlapMode: u,
              circle: {
                x: e,
                y: i,
                radius: l
              },
              seenUids: {
                box: {},
                circle: {}
              }
            }, p), L.length > 0
          }
          _queryCell(e, i, l, u, p, v, T, S) {
            const {
              seenUids: k,
              hitTest: L,
              overlapMode: V
            } = T, B = this.boxCells[p];
            if (B !== null) {
              const re = this.bboxes;
              for (const le of B)
                if (!k.box[le]) {
                  k.box[le] = !0;
                  const ue = 4 * le,
                    de = this.boxKeys[le];
                  if (e <= re[ue + 2] && i <= re[ue + 3] && l >= re[ue + 0] && u >= re[ue + 1] && (!S || S(de)) && (!L || !Ze(V, de.overlapMode)) && (v.push({
                      key: de,
                      x1: re[ue],
                      y1: re[ue + 1],
                      x2: re[ue + 2],
                      y2: re[ue + 3]
                    }), L)) return !0
                }
            }
            const H = this.circleCells[p];
            if (H !== null) {
              const re = this.circles;
              for (const le of H)
                if (!k.circle[le]) {
                  k.circle[le] = !0;
                  const ue = 3 * le,
                    de = this.circleKeys[le];
                  if (this._circleAndRectCollide(re[ue], re[ue + 1], re[ue + 2], e, i, l, u) && (!S || S(de)) && (!L || !Ze(V, de.overlapMode))) {
                    const ve = re[ue],
                      Ae = re[ue + 1],
                      _e = re[ue + 2];
                    if (v.push({
                        key: de,
                        x1: ve - _e,
                        y1: Ae - _e,
                        x2: ve + _e,
                        y2: Ae + _e
                      }), L) return !0
                  }
                }
            }
            return !1
          }
          _queryCellCircle(e, i, l, u, p, v, T, S) {
            const {
              circle: k,
              seenUids: L,
              overlapMode: V
            } = T, B = this.boxCells[p];
            if (B !== null) {
              const re = this.bboxes;
              for (const le of B)
                if (!L.box[le]) {
                  L.box[le] = !0;
                  const ue = 4 * le,
                    de = this.boxKeys[le];
                  if (this._circleAndRectCollide(k.x, k.y, k.radius, re[ue + 0], re[ue + 1], re[ue + 2], re[ue + 3]) && (!S || S(de)) && !Ze(V, de.overlapMode)) return v.push(!0), !0
                }
            }
            const H = this.circleCells[p];
            if (H !== null) {
              const re = this.circles;
              for (const le of H)
                if (!L.circle[le]) {
                  L.circle[le] = !0;
                  const ue = 3 * le,
                    de = this.circleKeys[le];
                  if (this._circlesCollide(re[ue], re[ue + 1], re[ue + 2], k.x, k.y, k.radius) && (!S || S(de)) && !Ze(V, de.overlapMode)) return v.push(!0), !0
                }
            }
          }
          _forEachCell(e, i, l, u, p, v, T, S) {
            const k = this._convertToXCellCoord(e),
              L = this._convertToYCellCoord(i),
              V = this._convertToXCellCoord(l),
              B = this._convertToYCellCoord(u);
            for (let H = k; H <= V; H++)
              for (let re = L; re <= B; re++)
                if (p.call(this, e, i, l, u, this.xCellCount * re + H, v, T, S)) return
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
          }
          _circlesCollide(e, i, l, u, p, v) {
            const T = u - e,
              S = p - i,
              k = l + v;
            return k * k > T * T + S * S
          }
          _circleAndRectCollide(e, i, l, u, p, v, T) {
            const S = (v - u) / 2,
              k = Math.abs(e - (u + S));
            if (k > S + l) return !1;
            const L = (T - p) / 2,
              V = Math.abs(i - (p + L));
            if (V > L + l) return !1;
            if (k <= S || V <= L) return !0;
            const B = k - S,
              H = V - L;
            return B * B + H * H <= l * l
          }
        }

        function br(h, e, i) {
          const l = s.M();
          if (!h) {
            const {
              vecSouth: V,
              vecEast: B
            } = Dr(e), H = q();
            H[0] = B[0], H[1] = B[1], H[2] = V[0], H[3] = V[1], u = H, (L = (v = (p = H)[0]) * (k = p[3]) - (S = p[2]) * (T = p[1])) && (u[0] = k * (L = 1 / L), u[1] = -T * L, u[2] = -S * L, u[3] = v * L), l[0] = H[0], l[1] = H[1], l[4] = H[2], l[5] = H[3]
          }
          var u, p, v, T, S, k, L;
          return s.O(l, l, [1 / i, 1 / i, 1]), l
        }

        function Rr(h, e, i, l) {
          if (h) {
            const u = s.M();
            if (!e) {
              const {
                vecSouth: p,
                vecEast: v
              } = Dr(i);
              u[0] = v[0], u[1] = v[1], u[4] = p[0], u[5] = p[1]
            }
            return s.O(u, u, [l, l, 1]), u
          }
          return i.pixelsToClipSpaceMatrix
        }

        function Dr(h) {
          const e = Math.cos(h.rollInRadians),
            i = Math.sin(h.rollInRadians),
            l = Math.cos(h.pitchInRadians),
            u = Math.cos(h.bearingInRadians),
            p = Math.sin(h.bearingInRadians),
            v = s.av();
          v[0] = -u * l * i - p * e, v[1] = -p * l * i + u * e;
          const T = s.aw(v);
          T < 1e-9 ? s.ax(v) : s.ay(v, v, 1 / T);
          const S = s.av();
          S[0] = u * l * e - p * i, S[1] = p * l * e + u * i;
          const k = s.aw(S);
          return k < 1e-9 ? s.ax(S) : s.ay(S, S, 1 / k), {
            vecEast: S,
            vecSouth: v
          }
        }

        function ot(h, e, i, l) {
          let u;
          l ? (u = [h, e, l(h, e), 1], s.aA(u, u, i)) : (u = [h, e, 0, 1], wr(u, u, i));
          const p = u[3];
          return {
            point: new s.P(u[0] / p, u[1] / p),
            signedDistanceFromCamera: p,
            isOccluded: !1
          }
        }

        function dr(h, e) {
          return .5 + h / e * .5
        }

        function st(h, e) {
          return h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1]
        }

        function Tt(h, e, i, l, u, p, v, T, S, k, L, V, B) {
          const H = i ? h.textSizeData : h.iconSizeData,
            re = s.ar(H, e.transform.zoom),
            le = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1],
            ue = i ? h.text.dynamicLayoutVertexArray : h.icon.dynamicLayoutVertexArray;
          ue.clear();
          const de = h.lineVertexArray,
            ve = i ? h.text.placedSymbolArray : h.icon.placedSymbolArray,
            Ae = e.transform.width / e.transform.height;
          let _e = !1;
          for (let ke = 0; ke < ve.length; ke++) {
            const Fe = ve.get(ke);
            if (Fe.hidden || Fe.writingMode === s.as.vertical && !_e) {
              kr(Fe.numGlyphs, ue);
              continue
            }
            _e = !1;
            const xe = new s.P(Fe.anchorX, Fe.anchorY),
              Ve = {
                getElevation: B,
                pitchedLabelPlaneMatrix: l,
                lineVertexArray: de,
                pitchWithMap: p,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: e.transform,
                tileAnchorPoint: xe,
                unwrappedTileID: S,
                width: k,
                height: L,
                translation: V
              },
              lt = hn(Fe.anchorX, Fe.anchorY, Ve);
            if (!st(lt.point, le)) {
              kr(Fe.numGlyphs, ue);
              continue
            }
            const rt = dr(e.transform.cameraToCenterDistance, lt.signedDistanceFromCamera),
              at = s.at(H, re, Fe),
              ct = p ? at * e.transform.getPitchedTextCorrection(Fe.anchorX, Fe.anchorY, S) / rt : at * rt,
              er = Ot({
                projectionContext: Ve,
                pitchedLabelPlaneMatrixInverse: u,
                symbol: Fe,
                fontSize: ct,
                flip: !1,
                keepUpright: v,
                glyphOffsetArray: h.glyphOffsetArray,
                dynamicLayoutVertexArray: ue,
                aspectRatio: Ae,
                rotateToLine: T
              });
            _e = er.useVertical, (er.notEnoughRoom || _e || er.needsFlipping && Ot({
              projectionContext: Ve,
              pitchedLabelPlaneMatrixInverse: u,
              symbol: Fe,
              fontSize: ct,
              flip: !0,
              keepUpright: v,
              glyphOffsetArray: h.glyphOffsetArray,
              dynamicLayoutVertexArray: ue,
              aspectRatio: Ae,
              rotateToLine: T
            }).notEnoughRoom) && kr(Fe.numGlyphs, ue)
          }
          i ? h.text.dynamicLayoutVertexBuffer.updateData(ue) : h.icon.dynamicLayoutVertexBuffer.updateData(ue)
        }

        function nr(h, e, i, l, u, p, v, T) {
          const S = p.glyphStartIndex + p.numGlyphs,
            k = p.lineStartIndex,
            L = p.lineStartIndex + p.lineLength,
            V = e.getoffsetX(p.glyphStartIndex),
            B = e.getoffsetX(S - 1),
            H = Ke(h * V, i, l, u, p.segment, k, L, T, v);
          if (!H) return null;
          const re = Ke(h * B, i, l, u, p.segment, k, L, T, v);
          return re ? T.projectionCache.anyProjectionOccluded ? null : {
            first: H,
            last: re
          } : null
        }

        function Ur(h, e, i, l) {
          return h === s.as.horizontal && Math.abs(i.y - e.y) > Math.abs(i.x - e.x) * l ? {
            useVertical: !0
          } : (h === s.as.vertical ? e.y < i.y : e.x > i.x) ? {
            needsFlipping: !0
          } : null
        }

        function Ot(h) {
          const {
            projectionContext: e,
            pitchedLabelPlaneMatrixInverse: i,
            symbol: l,
            fontSize: u,
            flip: p,
            keepUpright: v,
            glyphOffsetArray: T,
            dynamicLayoutVertexArray: S,
            aspectRatio: k,
            rotateToLine: L
          } = h, V = u / 24, B = l.lineOffsetX * V, H = l.lineOffsetY * V;
          let re;
          if (l.numGlyphs > 1) {
            const le = l.glyphStartIndex + l.numGlyphs,
              ue = l.lineStartIndex,
              de = l.lineStartIndex + l.lineLength,
              ve = nr(V, T, B, H, p, l, L, e);
            if (!ve) return {
              notEnoughRoom: !0
            };
            const Ae = sn(ve.first.point.x, ve.first.point.y, e, i),
              _e = sn(ve.last.point.x, ve.last.point.y, e, i);
            if (v && !p) {
              const ke = Ur(l.writingMode, Ae, _e, k);
              if (ke) return ke
            }
            re = [ve.first];
            for (let ke = l.glyphStartIndex + 1; ke < le - 1; ke++) {
              const Fe = Ke(V * T.getoffsetX(ke), B, H, p, l.segment, ue, de, e, L);
              if (!Fe) return {
                notEnoughRoom: !0
              };
              re.push(Fe)
            }
            re.push(ve.last)
          } else {
            if (v && !p) {
              const ue = mn(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point,
                de = l.lineStartIndex + l.segment + 1,
                ve = new s.P(e.lineVertexArray.getx(de), e.lineVertexArray.gety(de)),
                Ae = mn(ve.x, ve.y, e),
                _e = Ae.signedDistanceFromCamera > 0 ? Ae.point : Fr(e.tileAnchorPoint, ve, ue, 1, e),
                ke = sn(ue.x, ue.y, e, i),
                Fe = sn(_e.x, _e.y, e, i),
                xe = Ur(l.writingMode, ke, Fe, k);
              if (xe) return xe
            }
            const le = Ke(V * T.getoffsetX(l.glyphStartIndex), B, H, p, l.segment, l.lineStartIndex, l.lineStartIndex + l.lineLength, e, L);
            if (!le || e.projectionCache.anyProjectionOccluded) return {
              notEnoughRoom: !0
            };
            re = [le]
          }
          for (const le of re) s.az(S, le.point, le.angle);
          return {}
        }

        function Fr(h, e, i, l, u) {
          const p = h.add(h.sub(e)._unit()),
            v = mn(p.x, p.y, u).point,
            T = i.sub(v);
          return i.add(T._mult(l / T.mag()))
        }

        function Xr(h, e, i) {
          const l = e.projectionCache;
          if (l.projections[h]) return l.projections[h];
          const u = new s.P(e.lineVertexArray.getx(h), e.lineVertexArray.gety(h)),
            p = mn(u.x, u.y, e);
          if (p.signedDistanceFromCamera > 0) return l.projections[h] = p.point, l.anyProjectionOccluded = l.anyProjectionOccluded || p.isOccluded, p.point;
          const v = h - i.direction;
          return Fr(i.distanceFromAnchor === 0 ? e.tileAnchorPoint : new s.P(e.lineVertexArray.getx(v), e.lineVertexArray.gety(v)), u, i.previousVertex, i.absOffsetX - i.distanceFromAnchor + 1, e)
        }

        function mn(h, e, i) {
          const l = h + i.translation[0],
            u = e + i.translation[1];
          let p;
          return i.pitchWithMap ? (p = ot(l, u, i.pitchedLabelPlaneMatrix, i.getElevation), p.isOccluded = !1) : (p = i.transform.projectTileCoordinates(l, u, i.unwrappedTileID, i.getElevation), p.point.x = (.5 * p.point.x + .5) * i.width, p.point.y = (.5 * -p.point.y + .5) * i.height), p
        }

        function sn(h, e, i, l) {
          if (i.pitchWithMap) {
            const u = [h, e, 0, 1];
            return s.aA(u, u, l), i.transform.projectTileCoordinates(u[0] / u[3], u[1] / u[3], i.unwrappedTileID, i.getElevation).point
          }
          return {
            x: h / i.width * 2 - 1,
            y: 1 - e / i.height * 2
          }
        }

        function hn(h, e, i) {
          return i.transform.projectTileCoordinates(h, e, i.unwrappedTileID, i.getElevation)
        }

        function dn(h, e, i) {
          return h._unit()._perp()._mult(e * i)
        }

        function nn(h, e, i, l, u, p, v, T, S) {
          if (T.projectionCache.offsets[h]) return T.projectionCache.offsets[h];
          const k = i.add(e);
          if (h + S.direction < l || h + S.direction >= u) return T.projectionCache.offsets[h] = k, k;
          const L = Xr(h + S.direction, T, S),
            V = dn(L.sub(i), v, S.direction),
            B = i.add(V),
            H = L.add(V);
          return T.projectionCache.offsets[h] = s.aB(p, k, B, H) || k, T.projectionCache.offsets[h]
        }

        function Ke(h, e, i, l, u, p, v, T, S) {
          const k = l ? h - e : h + e;
          let L = k > 0 ? 1 : -1,
            V = 0;
          l && (L *= -1, V = Math.PI), L < 0 && (V += Math.PI);
          let B, H = L > 0 ? p + u : p + u + 1;
          T.projectionCache.cachedAnchorPoint ? B = T.projectionCache.cachedAnchorPoint : (B = mn(T.tileAnchorPoint.x, T.tileAnchorPoint.y, T).point, T.projectionCache.cachedAnchorPoint = B);
          let re, le, ue = B,
            de = B,
            ve = 0,
            Ae = 0;
          const _e = Math.abs(k),
            ke = [];
          let Fe;
          for (; ve + Ae <= _e;) {
            if (H += L, H < p || H >= v) return null;
            ve += Ae, de = ue, le = re;
            const lt = {
              absOffsetX: _e,
              direction: L,
              distanceFromAnchor: ve,
              previousVertex: de
            };
            if (ue = Xr(H, T, lt), i === 0) ke.push(de), Fe = ue.sub(de);
            else {
              let rt;
              const at = ue.sub(de);
              rt = at.mag() === 0 ? dn(Xr(H + L, T, lt).sub(ue), i, L) : dn(at, i, L), le || (le = de.add(rt)), re = nn(H, rt, ue, p, v, le, i, T, lt), ke.push(le), Fe = re.sub(le)
            }
            Ae = Fe.mag()
          }
          const xe = Fe._mult((_e - ve) / Ae)._add(le || de),
            Ve = V + Math.atan2(ue.y - de.y, ue.x - de.x);
          return ke.push(xe), {
            point: xe,
            angle: S ? Ve : 0,
            path: ke
          }
        }
        const St = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

        function kr(h, e) {
          for (let i = 0; i < h; i++) {
            const l = e.length;
            e.resize(l + 4), e.float32.set(St, 3 * l)
          }
        }

        function wr(h, e, i) {
          const l = e[0],
            u = e[1];
          return h[0] = i[0] * l + i[4] * u + i[12], h[1] = i[1] * l + i[5] * u + i[13], h[3] = i[3] * l + i[7] * u + i[15], h
        }
        const mr = 100;
        class Mr {
          constructor(e, i = new Pr(e.width + 200, e.height + 200, 25), l = new Pr(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = i, this.ignoredGrid = l, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + mr, this.screenBottomBoundary = e.height + mr, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6
          }
          placeCollisionBox(e, i, l, u, p, v, T, S, k, L, V, B) {
            const H = this.projectAndGetPerspectiveRatio(e.anchorPointX + S[0], e.anchorPointY + S[1], p, L, B),
              re = l * H.perspectiveRatio;
            let le;
            if (v || T) le = this._projectCollisionBox(e, re, u, p, v, T, S, H, L, V, B);
            else {
              const Fe = H.x + (V ? V.x * re : 0),
                xe = H.y + (V ? V.y * re : 0);
              le = {
                allPointsOccluded: !1,
                box: [Fe + e.x1 * re, xe + e.y1 * re, Fe + e.x2 * re, xe + e.y2 * re]
              }
            }
            const [ue, de, ve, Ae] = le.box, _e = v ? le.allPointsOccluded : H.isOccluded;
            let ke = _e;
            return ke || (ke = H.perspectiveRatio < this.perspectiveRatioCutoff), ke || (ke = !this.isInsideGrid(ue, de, ve, Ae)), ke || i !== "always" && this.grid.hitTest(ue, de, ve, Ae, i, k) ? {
              box: [ue, de, ve, Ae],
              placeable: !1,
              offscreen: !1,
              occluded: _e
            } : {
              box: [ue, de, ve, Ae],
              placeable: !0,
              offscreen: this.isOffscreen(ue, de, ve, Ae),
              occluded: _e
            }
          }
          placeCollisionCircles(e, i, l, u, p, v, T, S, k, L, V, B, H, re) {
            const le = [],
              ue = new s.P(i.anchorX, i.anchorY),
              de = this.getPerspectiveRatio(ue.x, ue.y, v, re),
              ve = (k ? p * this.transform.getPitchedTextCorrection(i.anchorX, i.anchorY, v) / de : p * de) / s.aF,
              Ae = {
                getElevation: re,
                pitchedLabelPlaneMatrix: T,
                lineVertexArray: l,
                pitchWithMap: k,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: this.transform,
                tileAnchorPoint: ue,
                unwrappedTileID: v,
                width: this.transform.width,
                height: this.transform.height,
                translation: H
              },
              _e = nr(ve, u, i.lineOffsetX * ve, i.lineOffsetY * ve, !1, i, !1, Ae);
            let ke = !1,
              Fe = !1,
              xe = !0;
            if (_e) {
              const Ve = .5 * V * de + B,
                lt = new s.P(-100, -100),
                rt = new s.P(this.screenRightBoundary, this.screenBottomBoundary),
                at = new Ft,
                ct = _e.first,
                er = _e.last;
              let rr = [];
              for (let Pn = ct.path.length - 1; Pn >= 1; Pn--) rr.push(ct.path[Pn]);
              for (let Pn = 1; Pn < er.path.length; Pn++) rr.push(er.path[Pn]);
              const kt = 2.5 * Ve;
              if (k) {
                const Pn = this.projectPathToScreenSpace(rr, Ae);
                rr = Pn.some((ei => ei.signedDistanceFromCamera <= 0)) ? [] : Pn.map((ei => ei.point))
              }
              let Br = [];
              if (rr.length > 0) {
                const Pn = rr[0].clone(),
                  ei = rr[0].clone();
                for (let An = 1; An < rr.length; An++) Pn.x = Math.min(Pn.x, rr[An].x), Pn.y = Math.min(Pn.y, rr[An].y), ei.x = Math.max(ei.x, rr[An].x), ei.y = Math.max(ei.y, rr[An].y);
                Br = Pn.x >= lt.x && ei.x <= rt.x && Pn.y >= lt.y && ei.y <= rt.y ? [rr] : ei.x < lt.x || Pn.x > rt.x || ei.y < lt.y || Pn.y > rt.y ? [] : s.aC([rr], lt.x, lt.y, rt.x, rt.y)
              }
              for (const Pn of Br) {
                at.reset(Pn, .25 * Ve);
                let ei = 0;
                ei = at.length <= .5 * Ve ? 1 : Math.ceil(at.paddedLength / kt) + 1;
                for (let An = 0; An < ei; An++) {
                  const oi = An / Math.max(ei - 1, 1),
                    _i = at.lerp(oi),
                    li = _i.x + mr,
                    Ei = _i.y + mr;
                  le.push(li, Ei, Ve, 0);
                  const di = li - Ve,
                    Zi = Ei - Ve,
                    pi = li + Ve,
                    Mi = Ei + Ve;
                  if (xe = xe && this.isOffscreen(di, Zi, pi, Mi), Fe = Fe || this.isInsideGrid(di, Zi, pi, Mi), e !== "always" && this.grid.hitTestCircle(li, Ei, Ve, e, L) && (ke = !0, !S)) return {
                    circles: [],
                    offscreen: !1,
                    collisionDetected: ke
                  }
                }
              }
            }
            return {
              circles: !S && ke || !Fe || de < this.perspectiveRatioCutoff ? [] : le,
              offscreen: xe,
              collisionDetected: ke
            }
          }
          projectPathToScreenSpace(e, i) {
            const l = (function(u, p) {
              const v = s.M();
              return s.au(v, p.pitchedLabelPlaneMatrix), u.map((T => {
                const S = ot(T.x, T.y, v, p.getElevation),
                  k = p.transform.projectTileCoordinates(S.point.x, S.point.y, p.unwrappedTileID, p.getElevation);
                return k.point.x = (.5 * k.point.x + .5) * p.width, k.point.y = (.5 * -k.point.y + .5) * p.height, k
              }))
            })(e, i);
            return (function(u) {
              let p = 0,
                v = 0,
                T = 0,
                S = 0;
              for (let k = 0; k < u.length; k++) u[k].isOccluded ? (T = k + 1, S = 0) : (S++, S > v && (v = S, p = T));
              return u.slice(p, p + v)
            })(l)
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const i = [],
              l = new s.a6;
            for (const V of e) {
              const B = new s.P(V.x + mr, V.y + mr);
              l.extend(B), i.push(B)
            }
            const {
              minX: u,
              minY: p,
              maxX: v,
              maxY: T
            } = l, S = this.grid.query(u, p, v, T).concat(this.ignoredGrid.query(u, p, v, T)), k = {}, L = {};
            for (const V of S) {
              const B = V.key;
              if (k[B.bucketInstanceId] === void 0 && (k[B.bucketInstanceId] = {}), k[B.bucketInstanceId][B.featureIndex]) continue;
              const H = [new s.P(V.x1, V.y1), new s.P(V.x2, V.y1), new s.P(V.x2, V.y2), new s.P(V.x1, V.y2)];
              s.aD(i, H) && (k[B.bucketInstanceId][B.featureIndex] = !0, L[B.bucketInstanceId] === void 0 && (L[B.bucketInstanceId] = []), L[B.bucketInstanceId].push(B.featureIndex))
            }
            return L
          }
          insertCollisionBox(e, i, l, u, p, v) {
            (l ? this.ignoredGrid : this.grid).insert({
              bucketInstanceId: u,
              featureIndex: p,
              collisionGroupID: v,
              overlapMode: i
            }, e[0], e[1], e[2], e[3])
          }
          insertCollisionCircles(e, i, l, u, p, v) {
            const T = l ? this.ignoredGrid : this.grid,
              S = {
                bucketInstanceId: u,
                featureIndex: p,
                collisionGroupID: v,
                overlapMode: i
              };
            for (let k = 0; k < e.length; k += 4) T.insertCircle(S, e[k], e[k + 1], e[k + 2])
          }
          projectAndGetPerspectiveRatio(e, i, l, u, p) {
            if (p) {
              let v;
              u ? (v = [e, i, u(e, i), 1], s.aA(v, v, p)) : (v = [e, i, 0, 1], wr(v, v, p));
              const T = v[3];
              return {
                x: (v[0] / T + 1) / 2 * this.transform.width + mr,
                y: (-v[1] / T + 1) / 2 * this.transform.height + mr,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / T * .5,
                isOccluded: !1,
                signedDistanceFromCamera: T
              }
            } {
              const v = this.transform.projectTileCoordinates(e, i, l, u);
              return {
                x: (v.point.x + 1) / 2 * this.transform.width + mr,
                y: (1 - v.point.y) / 2 * this.transform.height + mr,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / v.signedDistanceFromCamera * .5,
                isOccluded: v.isOccluded,
                signedDistanceFromCamera: v.signedDistanceFromCamera
              }
            }
          }
          getPerspectiveRatio(e, i, l, u) {
            const p = this.transform.projectTileCoordinates(e, i, l, u);
            return .5 + this.transform.cameraToCenterDistance / p.signedDistanceFromCamera * .5
          }
          isOffscreen(e, i, l, u) {
            return l < mr || e >= this.screenRightBoundary || u < mr || i > this.screenBottomBoundary
          }
          isInsideGrid(e, i, l, u) {
            return l >= 0 && e < this.gridRightBoundary && u >= 0 && i < this.gridBottomBoundary
          }
          getViewportMatrix() {
            const e = s.am([]);
            return s.N(e, e, [-100, -100, 0]), e
          }
          _projectCollisionBox(e, i, l, u, p, v, T, S, k, L, V) {
            let B = 1,
              H = 0,
              re = 0,
              le = 1;
            const ue = e.anchorPointX + T[0],
              de = e.anchorPointY + T[1];
            if (v && !p) {
              const rr = this.projectAndGetPerspectiveRatio(ue + 1, de, u, k, V),
                kt = rr.x - S.x,
                Br = Math.atan((rr.y - S.y) / kt) + (kt < 0 ? Math.PI : 0),
                Pn = Math.sin(Br),
                ei = Math.cos(Br);
              B = ei, H = Pn, re = -Pn, le = ei
            } else if (!v && p) {
              const rr = Dr(this.transform);
              B = rr.vecEast[0], H = rr.vecEast[1], re = rr.vecSouth[0], le = rr.vecSouth[1]
            }
            let ve = S.x,
              Ae = S.y,
              _e = i;
            p && (ve = ue, Ae = de, _e = Math.pow(2, -(this.transform.zoom - l.overscaledZ)), _e *= this.transform.getPitchedTextCorrection(ue, de, u), L || (_e *= s.ai(.5 + S.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), L && (ve += B * L.x * _e + re * L.y * _e, Ae += H * L.x * _e + le * L.y * _e);
            const ke = e.x1 * _e,
              Fe = e.x2 * _e,
              xe = (ke + Fe) / 2,
              Ve = e.y1 * _e,
              lt = e.y2 * _e,
              rt = (Ve + lt) / 2,
              at = [{
                offsetX: ke,
                offsetY: Ve
              }, {
                offsetX: xe,
                offsetY: Ve
              }, {
                offsetX: Fe,
                offsetY: Ve
              }, {
                offsetX: Fe,
                offsetY: rt
              }, {
                offsetX: Fe,
                offsetY: lt
              }, {
                offsetX: xe,
                offsetY: lt
              }, {
                offsetX: ke,
                offsetY: lt
              }, {
                offsetX: ke,
                offsetY: rt
              }];
            let ct = [];
            for (const {
                offsetX: rr,
                offsetY: kt
              }
              of at) ct.push(new s.P(ve + B * rr + re * kt, Ae + H * rr + le * kt));
            let er = !1;
            if (p) {
              const rr = ct.map((kt => this.projectAndGetPerspectiveRatio(kt.x, kt.y, u, k, V)));
              er = rr.some((kt => !kt.isOccluded)), ct = rr.map((kt => new s.P(kt.x, kt.y)))
            } else er = !0;
            return {
              box: s.aE(ct),
              allPointsOccluded: !er
            }
          }
        }
        class gn {
          constructor(e, i, l, u) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? i : -i))) : u && l ? 1 : 0, this.placed = l
          }
          isHidden() {
            return this.opacity === 0 && !this.placed
          }
        }
        class Rn {
          constructor(e, i, l, u, p) {
            this.text = new gn(e ? e.text : null, i, l, p), this.icon = new gn(e ? e.icon : null, i, u, p)
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden()
          }
        }
        class ln {
          constructor(e, i, l) {
            this.text = e, this.icon = i, this.skipFade = l
          }
        }
        class Gn {
          constructor(e, i, l, u, p) {
            this.bucketInstanceId = e, this.featureIndex = i, this.sourceLayerIndex = l, this.bucketIndex = u, this.tileID = p
          }
        }
        class On {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {}
          }
          get(e) {
            if (this.crossSourceCollisions) return {
              ID: 0,
              predicate: null
            };
            if (!this.collisionGroups[e]) {
              const i = ++this.maxGroupID;
              this.collisionGroups[e] = {
                ID: i,
                predicate: l => l.collisionGroupID === i
              }
            }
            return this.collisionGroups[e]
          }
        }

        function Wn(h, e, i, l, u) {
          const {
            horizontalAlign: p,
            verticalAlign: v
          } = s.aL(h);
          return new s.P(-(p - .5) * e + l[0] * u, -(v - .5) * i + l[1] * u)
        }
        class ti {
          constructor(e, i, l, u, p) {
            this.transform = e.clone(), this.terrain = i, this.collisionIndex = new Mr(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = l, this.retainedQueryData = {}, this.collisionGroups = new On(u), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = p, p && (p.prevPlacement = void 0), this.placedOrientations = {}
          }
          _getTerrainElevationFunc(e) {
            const i = this.terrain;
            return i ? (l, u) => i.getElevation(e, l, u) : null
          }
          getBucketParts(e, i, l, u) {
            const p = l.getBucket(i),
              v = l.latestFeatureIndex;
            if (!p || !v || i.id !== p.layerIds[0]) return;
            const T = l.collisionBoxArray,
              S = p.layers[0].layout,
              k = p.layers[0].paint,
              L = Math.pow(2, this.transform.zoom - l.tileID.overscaledZ),
              V = l.tileSize / s.a3,
              B = l.tileID.toUnwrapped(),
              H = S.get("text-rotation-alignment") === "map",
              re = s.aG(l, 1, this.transform.zoom),
              le = s.aH(this.collisionIndex.transform, l, k.get("text-translate"), k.get("text-translate-anchor")),
              ue = s.aH(this.collisionIndex.transform, l, k.get("icon-translate"), k.get("icon-translate-anchor")),
              de = br(H, this.transform, re);
            this.retainedQueryData[p.bucketInstanceId] = new Gn(p.bucketInstanceId, v, p.sourceLayerIndex, p.index, l.tileID);
            const ve = {
              bucket: p,
              layout: S,
              translationText: le,
              translationIcon: ue,
              unwrappedTileID: B,
              pitchedLabelPlaneMatrix: de,
              scale: L,
              textPixelRatio: V,
              holdingForFade: l.holdingForSymbolFade(),
              collisionBoxArray: T,
              partiallyEvaluatedTextSize: s.ar(p.textSizeData, this.transform.zoom),
              collisionGroup: this.collisionGroups.get(p.sourceID)
            };
            if (u)
              for (const Ae of p.sortKeyRanges) {
                const {
                  sortKey: _e,
                  symbolInstanceStart: ke,
                  symbolInstanceEnd: Fe
                } = Ae;
                e.push({
                  sortKey: _e,
                  symbolInstanceStart: ke,
                  symbolInstanceEnd: Fe,
                  parameters: ve
                })
              } else e.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: p.symbolInstances.length,
                parameters: ve
              })
          }
          attemptAnchorPlacement(e, i, l, u, p, v, T, S, k, L, V, B, H, re, le, ue, de, ve, Ae, _e) {
            const ke = s.aI[e.textAnchor],
              Fe = [e.textOffset0, e.textOffset1],
              xe = Wn(ke, l, u, Fe, p),
              Ve = this.collisionIndex.placeCollisionBox(i, B, S, k, L, T, v, ue, V.predicate, Ae, xe, _e);
            if ((!ve || this.collisionIndex.placeCollisionBox(ve, B, S, k, L, T, v, de, V.predicate, Ae, xe, _e).placeable) && Ve.placeable) {
              let lt;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[H.crossTileID] && this.prevPlacement.placements[H.crossTileID] && this.prevPlacement.placements[H.crossTileID].text && (lt = this.prevPlacement.variableOffsets[H.crossTileID].anchor), H.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[H.crossTileID] = {
                textOffset: Fe,
                width: l,
                height: u,
                anchor: ke,
                textBoxScale: p,
                prevAnchor: lt
              }, this.markUsedJustification(re, ke, H, le), re.allowVerticalPlacement && (this.markUsedOrientation(re, le, H), this.placedOrientations[H.crossTileID] = le), {
                shift: xe,
                placedGlyphBoxes: Ve
              }
            }
          }
          placeLayerBucketPart(e, i, l) {
            const {
              bucket: u,
              layout: p,
              translationText: v,
              translationIcon: T,
              unwrappedTileID: S,
              pitchedLabelPlaneMatrix: k,
              textPixelRatio: L,
              holdingForFade: V,
              collisionBoxArray: B,
              partiallyEvaluatedTextSize: H,
              collisionGroup: re
            } = e.parameters, le = p.get("text-optional"), ue = p.get("icon-optional"), de = s.aJ(p, "text-overlap", "text-allow-overlap"), ve = de === "always", Ae = s.aJ(p, "icon-overlap", "icon-allow-overlap"), _e = Ae === "always", ke = p.get("text-rotation-alignment") === "map", Fe = p.get("text-pitch-alignment") === "map", xe = p.get("icon-text-fit") !== "none", Ve = p.get("symbol-z-order") === "viewport-y", lt = ve && (_e || !u.hasIconData() || ue), rt = _e && (ve || !u.hasTextData() || le);
            !u.collisionArrays && B && u.deserializeCollisionBoxes(B);
            const at = this.retainedQueryData[u.bucketInstanceId].tileID,
              ct = this._getTerrainElevationFunc(at),
              er = this.transform.getFastPathSimpleProjectionMatrix(at),
              rr = (kt, Br, Pn) => {
                var ei, An;
                if (i[kt.crossTileID]) return;
                if (V) return void(this.placements[kt.crossTileID] = new ln(!1, !1, !1));
                let oi = !1,
                  _i = !1,
                  li = !0,
                  Ei = null,
                  di = {
                    box: null,
                    placeable: !1,
                    offscreen: null,
                    occluded: !1
                  },
                  Zi = {
                    placeable: !1
                  },
                  pi = null,
                  Mi = null,
                  da = null,
                  as = 0,
                  yo = 0,
                  no = 0;
                Br.textFeatureIndex ? as = Br.textFeatureIndex : kt.useRuntimeCollisionCircles && (as = kt.featureIndex), Br.verticalTextFeatureIndex && (yo = Br.verticalTextFeatureIndex);
                const os = Br.textBox;
                if (os) {
                  const pa = Ai => {
                      let Pi = s.as.horizontal;
                      if (u.allowVerticalPlacement && !Ai && this.prevPlacement) {
                        const Gi = this.prevPlacement.placedOrientations[kt.crossTileID];
                        Gi && (this.placedOrientations[kt.crossTileID] = Gi, Pi = Gi, this.markUsedOrientation(u, Pi, kt))
                      }
                      return Pi
                    },
                    xo = (Ai, Pi) => {
                      if (u.allowVerticalPlacement && kt.numVerticalGlyphVertices > 0 && Br.verticalTextBox) {
                        for (const Gi of u.writingModes)
                          if (Gi === s.as.vertical ? (di = Pi(), Zi = di) : di = Ai(), di && di.placeable) break
                      } else di = Ai()
                    },
                    Do = kt.textAnchorOffsetStartIndex,
                    dl = kt.textAnchorOffsetEndIndex;
                  if (dl === Do) {
                    const Ai = (Pi, Gi) => {
                      const ui = this.collisionIndex.placeCollisionBox(Pi, de, L, at, S, Fe, ke, v, re.predicate, ct, void 0, er);
                      return ui && ui.placeable && (this.markUsedOrientation(u, Gi, kt), this.placedOrientations[kt.crossTileID] = Gi), ui
                    };
                    xo((() => Ai(os, s.as.horizontal)), (() => {
                      const Pi = Br.verticalTextBox;
                      return u.allowVerticalPlacement && kt.numVerticalGlyphVertices > 0 && Pi ? Ai(Pi, s.as.vertical) : {
                        box: null,
                        offscreen: null
                      }
                    })), pa(di && di.placeable)
                  } else {
                    let Ai = s.aI[(An = (ei = this.prevPlacement) === null || ei === void 0 ? void 0 : ei.variableOffsets[kt.crossTileID]) === null || An === void 0 ? void 0 : An.anchor];
                    const Pi = (ui, Ha, Ro) => {
                      const Kd = ui.x2 - ui.x1,
                        Jd = ui.y2 - ui.y1,
                        Qd = kt.textBoxScale,
                        ls = xe && Ae === "never" ? Ha : null;
                      let cs = null,
                        Lu = de === "never" ? 1 : 2,
                        lc = "never";
                      Ai && Lu++;
                      for (let zu = 0; zu < Lu; zu++) {
                        for (let bo = Do; bo < dl; bo++) {
                          const Fo = u.textAnchorOffsets.get(bo);
                          if (Ai && Fo.textAnchor !== Ai) continue;
                          const cc = this.attemptAnchorPlacement(Fo, ui, Kd, Jd, Qd, ke, Fe, L, at, S, re, lc, kt, u, Ro, v, T, ls, ct);
                          if (cc && (cs = cc.placedGlyphBoxes, cs && cs.placeable)) return oi = !0, Ei = cc.shift, cs
                        }
                        Ai ? Ai = null : lc = de
                      }
                      return l && !cs && (cs = {
                        box: this.collisionIndex.placeCollisionBox(os, "always", L, at, S, Fe, ke, v, re.predicate, ct, void 0, er).box,
                        offscreen: !1,
                        placeable: !1,
                        occluded: !1
                      }), cs
                    };
                    xo((() => Pi(os, Br.iconBox, s.as.horizontal)), (() => {
                      const ui = Br.verticalTextBox;
                      return u.allowVerticalPlacement && (!di || !di.placeable) && kt.numVerticalGlyphVertices > 0 && ui ? Pi(ui, Br.verticalIconBox, s.as.vertical) : {
                        box: null,
                        occluded: !0,
                        offscreen: null
                      }
                    })), di && (oi = di.placeable, li = di.offscreen);
                    const Gi = pa(di && di.placeable);
                    if (!oi && this.prevPlacement) {
                      const ui = this.prevPlacement.variableOffsets[kt.crossTileID];
                      ui && (this.variableOffsets[kt.crossTileID] = ui, this.markUsedJustification(u, ui.anchor, kt, Gi))
                    }
                  }
                }
                if (pi = di, oi = pi && pi.placeable, li = pi && pi.offscreen, kt.useRuntimeCollisionCircles && kt.centerJustifiedTextSymbolIndex >= 0) {
                  const pa = u.text.placedSymbolArray.get(kt.centerJustifiedTextSymbolIndex),
                    xo = s.at(u.textSizeData, H, pa),
                    Do = p.get("text-padding");
                  Mi = this.collisionIndex.placeCollisionCircles(de, pa, u.lineVertexArray, u.glyphOffsetArray, xo, S, k, l, Fe, re.predicate, kt.collisionCircleDiameter, Do, v, ct), Mi.circles.length && Mi.collisionDetected && !l && s.w("Collisions detected, but collision boxes are not shown"), oi = ve || Mi.circles.length > 0 && !Mi.collisionDetected, li = li && Mi.offscreen
                }
                if (Br.iconFeatureIndex && (no = Br.iconFeatureIndex), Br.iconBox) {
                  const pa = xo => this.collisionIndex.placeCollisionBox(xo, Ae, L, at, S, Fe, ke, T, re.predicate, ct, xe && Ei ? Ei : void 0, er);
                  Zi && Zi.placeable && Br.verticalIconBox ? (da = pa(Br.verticalIconBox), _i = da.placeable) : (da = pa(Br.iconBox), _i = da.placeable), li = li && da.offscreen
                }
                const Ds = le || kt.numHorizontalGlyphVertices === 0 && kt.numVerticalGlyphVertices === 0,
                  ss = ue || kt.numIconVertices === 0;
                Ds || ss ? ss ? Ds || (_i = _i && oi) : oi = _i && oi : _i = oi = _i && oi;
                const ya = _i && da.placeable;
                if (oi && pi.placeable && this.collisionIndex.insertCollisionBox(pi.box, de, p.get("text-ignore-placement"), u.bucketInstanceId, Zi && Zi.placeable && yo ? yo : as, re.ID), ya && this.collisionIndex.insertCollisionBox(da.box, Ae, p.get("icon-ignore-placement"), u.bucketInstanceId, no, re.ID), Mi && oi && this.collisionIndex.insertCollisionCircles(Mi.circles, de, p.get("text-ignore-placement"), u.bucketInstanceId, as, re.ID), l && this.storeCollisionData(u.bucketInstanceId, Pn, Br, pi, da, Mi), kt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                if (u.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[kt.crossTileID] = new ln((oi || lt) && !(pi != null && pi.occluded), (_i || rt) && !(da != null && da.occluded), li || u.justReloaded), i[kt.crossTileID] = !0
              };
            if (Ve) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const kt = u.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Br = kt.length - 1; Br >= 0; --Br) {
                const Pn = kt[Br];
                rr(u.symbolInstances.get(Pn), u.collisionArrays[Pn], Pn)
              }
            } else
              for (let kt = e.symbolInstanceStart; kt < e.symbolInstanceEnd; kt++) rr(u.symbolInstances.get(kt), u.collisionArrays[kt], kt);
            u.justReloaded = !1
          }
          storeCollisionData(e, i, l, u, p, v) {
            if (l.textBox || l.iconBox) {
              let T, S;
              this.collisionBoxArrays.has(e) ? T = this.collisionBoxArrays.get(e) : (T = new Map, this.collisionBoxArrays.set(e, T)), T.has(i) ? S = T.get(i) : (S = {
                text: null,
                icon: null
              }, T.set(i, S)), l.textBox && (S.text = u.box), l.iconBox && (S.icon = p.box)
            }
            if (v) {
              let T = this.collisionCircleArrays[e];
              T === void 0 && (T = this.collisionCircleArrays[e] = []);
              for (let S = 0; S < v.circles.length; S += 4) T.push(v.circles[S + 0] - mr), T.push(v.circles[S + 1] - mr), T.push(v.circles[S + 2]), T.push(v.collisionDetected ? 1 : 0)
            }
          }
          markUsedJustification(e, i, l, u) {
            let p;
            p = u === s.as.vertical ? l.verticalPlacedTextSymbolIndex : {
              left: l.leftJustifiedTextSymbolIndex,
              center: l.centerJustifiedTextSymbolIndex,
              right: l.rightJustifiedTextSymbolIndex
            } [s.aK(i)];
            const v = [l.leftJustifiedTextSymbolIndex, l.centerJustifiedTextSymbolIndex, l.rightJustifiedTextSymbolIndex, l.verticalPlacedTextSymbolIndex];
            for (const T of v) T >= 0 && (e.text.placedSymbolArray.get(T).crossTileID = p >= 0 && T !== p ? 0 : l.crossTileID)
          }
          markUsedOrientation(e, i, l) {
            const u = i === s.as.horizontal || i === s.as.horizontalOnly ? i : 0,
              p = i === s.as.vertical ? i : 0,
              v = [l.leftJustifiedTextSymbolIndex, l.centerJustifiedTextSymbolIndex, l.rightJustifiedTextSymbolIndex];
            for (const T of v) e.text.placedSymbolArray.get(T).placedOrientation = u;
            l.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(l.verticalPlacedTextSymbolIndex).placedOrientation = p)
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const i = this.prevPlacement;
            let l = !1;
            this.prevZoomAdjustment = i ? i.zoomAdjustment(this.transform.zoom) : 0;
            const u = i ? i.symbolFadeChange(e) : 1,
              p = i ? i.opacities : {},
              v = i ? i.variableOffsets : {},
              T = i ? i.placedOrientations : {};
            for (const S in this.placements) {
              const k = this.placements[S],
                L = p[S];
              L ? (this.opacities[S] = new Rn(L, u, k.text, k.icon), l = l || k.text !== L.text.placed || k.icon !== L.icon.placed) : (this.opacities[S] = new Rn(null, u, k.text, k.icon, k.skipFade), l = l || k.text || k.icon)
            }
            for (const S in p) {
              const k = p[S];
              if (!this.opacities[S]) {
                const L = new Rn(k, u, !1, !1);
                L.isHidden() || (this.opacities[S] = L, l = l || k.text.placed || k.icon.placed)
              }
            }
            for (const S in v) this.variableOffsets[S] || !this.opacities[S] || this.opacities[S].isHidden() || (this.variableOffsets[S] = v[S]);
            for (const S in T) this.placedOrientations[S] || !this.opacities[S] || this.opacities[S].isHidden() || (this.placedOrientations[S] = T[S]);
            if (i && i.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            l ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = i ? i.lastPlacementChangeTime : e)
          }
          updateLayerOpacities(e, i) {
            const l = {};
            for (const u of i) {
              const p = u.getBucket(e);
              p && u.latestFeatureIndex && e.id === p.layerIds[0] && this.updateBucketOpacities(p, u.tileID, l, u.collisionBoxArray)
            }
          }
          updateBucketOpacities(e, i, l, u) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const p = e.layers[0],
              v = p.layout,
              T = new Rn(null, 0, !1, !1, !0),
              S = v.get("text-allow-overlap"),
              k = v.get("icon-allow-overlap"),
              L = p._unevaluatedLayout.hasValue("text-variable-anchor") || p._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
              V = v.get("text-rotation-alignment") === "map",
              B = v.get("text-pitch-alignment") === "map",
              H = v.get("icon-text-fit") !== "none",
              re = new Rn(null, 0, S && (k || !e.hasIconData() || v.get("icon-optional")), k && (S || !e.hasTextData() || v.get("text-optional")), !0);
            !e.collisionArrays && u && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(u);
            const le = (de, ve, Ae) => {
                for (let _e = 0; _e < ve / 4; _e++) de.opacityVertexArray.emplaceBack(Ae);
                de.hasVisibleVertices = de.hasVisibleVertices || Ae !== Or
              },
              ue = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let de = 0; de < e.symbolInstances.length; de++) {
              const ve = e.symbolInstances.get(de),
                {
                  numHorizontalGlyphVertices: Ae,
                  numVerticalGlyphVertices: _e,
                  crossTileID: ke
                } = ve;
              let Fe = this.opacities[ke];
              l[ke] ? Fe = T : Fe || (Fe = re, this.opacities[ke] = Fe), l[ke] = !0;
              const xe = ve.numIconVertices > 0,
                Ve = this.placedOrientations[ve.crossTileID],
                lt = Ve === s.as.vertical,
                rt = Ve === s.as.horizontal || Ve === s.as.horizontalOnly;
              if (Ae > 0 || _e > 0) {
                const ct = $t(Fe.text);
                le(e.text, Ae, lt ? Or : ct), le(e.text, _e, rt ? Or : ct);
                const er = Fe.text.isHidden();
                [ve.rightJustifiedTextSymbolIndex, ve.centerJustifiedTextSymbolIndex, ve.leftJustifiedTextSymbolIndex].forEach((Br => {
                  Br >= 0 && (e.text.placedSymbolArray.get(Br).hidden = er || lt ? 1 : 0)
                })), ve.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(ve.verticalPlacedTextSymbolIndex).hidden = er || rt ? 1 : 0);
                const rr = this.variableOffsets[ve.crossTileID];
                rr && this.markUsedJustification(e, rr.anchor, ve, Ve);
                const kt = this.placedOrientations[ve.crossTileID];
                kt && (this.markUsedJustification(e, "left", ve, kt), this.markUsedOrientation(e, kt, ve))
              }
              if (xe) {
                const ct = $t(Fe.icon),
                  er = !(H && ve.verticalPlacedIconSymbolIndex && lt);
                ve.placedIconSymbolIndex >= 0 && (le(e.icon, ve.numIconVertices, er ? ct : Or), e.icon.placedSymbolArray.get(ve.placedIconSymbolIndex).hidden = Fe.icon.isHidden()), ve.verticalPlacedIconSymbolIndex >= 0 && (le(e.icon, ve.numVerticalIconVertices, er ? Or : ct), e.icon.placedSymbolArray.get(ve.verticalPlacedIconSymbolIndex).hidden = Fe.icon.isHidden())
              }
              const at = ue && ue.has(de) ? ue.get(de) : {
                text: null,
                icon: null
              };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const ct = e.collisionArrays[de];
                if (ct) {
                  let er = new s.P(0, 0);
                  if (ct.textBox || ct.verticalTextBox) {
                    let rr = !0;
                    if (L) {
                      const kt = this.variableOffsets[ke];
                      kt ? (er = Wn(kt.anchor, kt.width, kt.height, kt.textOffset, kt.textBoxScale), V && er._rotate(B ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : rr = !1
                    }
                    if (ct.textBox || ct.verticalTextBox) {
                      let kt;
                      ct.textBox && (kt = lt), ct.verticalTextBox && (kt = rt), Zn(e.textCollisionBox.collisionVertexArray, Fe.text.placed, !rr || kt, at.text, er.x, er.y)
                    }
                  }
                  if (ct.iconBox || ct.verticalIconBox) {
                    const rr = !!(!rt && ct.verticalIconBox);
                    let kt;
                    ct.iconBox && (kt = rr), ct.verticalIconBox && (kt = !rr), Zn(e.iconCollisionBox.collisionVertexArray, Fe.icon.placed, kt, at.icon, H ? er.x : 0, H ? er.y : 0)
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId])
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5)
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
          }
          stillRecent(e, i) {
            const l = this.zoomAtLastRecencyCheck === i ? 1 - this.zoomAdjustment(i) : 1;
            return this.zoomAtLastRecencyCheck = i, this.commitTime + this.fadeDuration * l > e
          }
          setStale() {
            this.stale = !0
          }
        }

        function Zn(h, e, i, l, u, p) {
          l && l.length !== 0 || (l = [0, 0, 0, 0]);
          const v = l[0] - mr,
            T = l[1] - mr,
            S = l[2] - mr,
            k = l[3] - mr;
          h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, p || 0, v, T), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, p || 0, S, T), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, p || 0, S, k), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, p || 0, v, k)
        }
        const cn = Math.pow(2, 25),
          kn = Math.pow(2, 24),
          Xn = Math.pow(2, 17),
          Ri = Math.pow(2, 16),
          Ii = Math.pow(2, 9),
          Vi = Math.pow(2, 8),
          pt = Math.pow(2, 1);

        function $t(h) {
          if (h.opacity === 0 && !h.placed) return 0;
          if (h.opacity === 1 && h.placed) return 4294967295;
          const e = h.placed ? 1 : 0,
            i = Math.floor(127 * h.opacity);
          return i * cn + e * kn + i * Xn + e * Ri + i * Ii + e * Vi + i * pt + e
        }
        const Or = 0;
        class on {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []
          }
          continuePlacement(e, i, l, u, p) {
            const v = this._bucketParts;
            for (; this._currentTileIndex < e.length;)
              if (i.getBucketParts(v, u, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, p()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, v.sort(((T, S) => T.sortKey - S.sortKey))); this._currentPartIndex < v.length;)
              if (i.placeLayerBucketPart(v[this._currentPartIndex], this._seenCrossTileIDs, l), this._currentPartIndex++, p()) return !0;
            return !1
          }
        }
        class Er {
          constructor(e, i, l, u, p, v, T, S) {
            this.placement = new ti(e, i, v, T, S), this._currentPlacementIndex = l.length - 1, this._forceFullPlacement = u, this._showCollisionBoxes = p, this._done = !1
          }
          isDone() {
            return this._done
          }
          continuePlacement(e, i, l) {
            const u = ie(),
              p = () => !this._forceFullPlacement && ie() - u > 2;
            for (; this._currentPlacementIndex >= 0;) {
              const v = i[e[this._currentPlacementIndex]],
                T = this.placement.collisionIndex.transform.zoom;
              if (v.type === "symbol" && (!v.minzoom || v.minzoom <= T) && (!v.maxzoom || v.maxzoom > T)) {
                if (this._inProgressLayer || (this._inProgressLayer = new on(v)), this._inProgressLayer.continuePlacement(l[v.source], this.placement, this._showCollisionBoxes, v, p)) return;
                delete this._inProgressLayer
              }
              this._currentPlacementIndex--
            }
            this._done = !0
          }
          commit(e) {
            return this.placement.commit(e), this.placement
          }
        }
        const Hn = 512 / s.a3 / 2;
        class jn {
          constructor(e, i, l) {
            this.tileID = e, this.bucketInstanceId = l, this._symbolsByKey = {};
            const u = new Map;
            for (let p = 0; p < i.length; p++) {
              const v = i.get(p),
                T = v.key,
                S = u.get(T);
              S ? S.push(v) : u.set(T, [v])
            }
            for (const [p, v] of u) {
              const T = {
                positions: v.map((S => ({
                  x: Math.floor(S.anchorX * Hn),
                  y: Math.floor(S.anchorY * Hn)
                }))),
                crossTileIDs: v.map((S => S.crossTileID))
              };
              if (T.positions.length > 128) {
                const S = new s.aM(T.positions.length, 16, Uint16Array);
                for (const {
                    x: k,
                    y: L
                  }
                  of T.positions) S.add(k, L);
                S.finish(), delete T.positions, T.index = S
              }
              this._symbolsByKey[p] = T
            }
          }
          getScaledCoordinates(e, i) {
            const {
              x: l,
              y: u,
              z: p
            } = this.tileID.canonical, {
              x: v,
              y: T,
              z: S
            } = i.canonical, k = Hn / Math.pow(2, S - p), L = (T * s.a3 + e.anchorY) * k, V = u * s.a3 * Hn;
            return {
              x: Math.floor((v * s.a3 + e.anchorX) * k - l * s.a3 * Hn),
              y: Math.floor(L - V)
            }
          }
          findMatches(e, i, l) {
            const u = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z);
            for (let p = 0; p < e.length; p++) {
              const v = e.get(p);
              if (v.crossTileID) continue;
              const T = this._symbolsByKey[v.key];
              if (!T) continue;
              const S = this.getScaledCoordinates(v, i);
              if (T.index) {
                const k = T.index.range(S.x - u, S.y - u, S.x + u, S.y + u).sort();
                for (const L of k) {
                  const V = T.crossTileIDs[L];
                  if (!l[V]) {
                    l[V] = !0, v.crossTileID = V;
                    break
                  }
                }
              } else if (T.positions)
                for (let k = 0; k < T.positions.length; k++) {
                  const L = T.positions[k],
                    V = T.crossTileIDs[k];
                  if (Math.abs(L.x - S.x) <= u && Math.abs(L.y - S.y) <= u && !l[V]) {
                    l[V] = !0, v.crossTileID = V;
                    break
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({
              crossTileIDs: e
            }) => e))
          }
        }
        class Cn {
          constructor() {
            this.maxCrossTileID = 0
          }
          generate() {
            return ++this.maxCrossTileID
          }
        }
        class Yn {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
          }
          handleWrapJump(e) {
            const i = Math.round((e - this.lng) / 360);
            if (i !== 0)
              for (const l in this.indexes) {
                const u = this.indexes[l],
                  p = {};
                for (const v in u) {
                  const T = u[v];
                  T.tileID = T.tileID.unwrapTo(T.tileID.wrap + i), p[T.tileID.key] = T
                }
                this.indexes[l] = p
              }
            this.lng = e
          }
          addBucket(e, i, l) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === i.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
            }
            for (let p = 0; p < i.symbolInstances.length; p++) i.symbolInstances.get(p).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const u = this.usedCrossTileIDs[e.overscaledZ];
            for (const p in this.indexes) {
              const v = this.indexes[p];
              if (Number(p) > e.overscaledZ)
                for (const T in v) {
                  const S = v[T];
                  S.tileID.isChildOf(e) && S.findMatches(i.symbolInstances, e, u)
                } else {
                  const T = v[e.scaledTo(Number(p)).key];
                  T && T.findMatches(i.symbolInstances, e, u)
                }
            }
            for (let p = 0; p < i.symbolInstances.length; p++) {
              const v = i.symbolInstances.get(p);
              v.crossTileID || (v.crossTileID = l.generate(), u[v.crossTileID] = !0)
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new jn(e, i.symbolInstances, i.bucketInstanceId), !0
          }
          removeBucketCrossTileIDs(e, i) {
            for (const l of i.getCrossTileIDsLists())
              for (const u of l) delete this.usedCrossTileIDs[e][u]
          }
          removeStaleBuckets(e) {
            let i = !1;
            for (const l in this.indexes) {
              const u = this.indexes[l];
              for (const p in u) e[u[p].bucketInstanceId] || (this.removeBucketCrossTileIDs(l, u[p]), delete u[p], i = !0)
            }
            return i
          }
        }
        class vr {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Cn, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
          }
          addLayer(e, i, l) {
            let u = this.layerIndexes[e.id];
            u === void 0 && (u = this.layerIndexes[e.id] = new Yn);
            let p = !1;
            const v = {};
            u.handleWrapJump(l);
            for (const T of i) {
              const S = T.getBucket(e);
              S && e.id === S.layerIds[0] && (S.bucketInstanceId || (S.bucketInstanceId = ++this.maxBucketInstanceId), u.addBucket(T.tileID, S, this.crossTileIDs) && (p = !0), v[S.bucketInstanceId] = !0)
            }
            return u.removeStaleBuckets(v) && (p = !0), p
          }
          pruneUnusedLayers(e) {
            const i = {};
            e.forEach((l => {
              i[l] = !0
            }));
            for (const l in this.layerIndexes) i[l] || delete this.layerIndexes[l]
          }
        }
        var ar = "void main() {fragColor=vec4(1.0);}";
        const gr = {
          prelude: zr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
          projectionMercator: zr("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
          projectionGlobe: zr("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
          background: zr(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          backgroundPattern: zr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
          circle: zr(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
          clippingMask: zr(ar, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          heatmap: zr(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
          heatmapTexture: zr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
          collisionBox: zr("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
          collisionCircle: zr("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
          colorRelief: zr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          debug: zr("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
          depth: zr(ar, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
          fill: zr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
          fillOutline: zr(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillOutlinePattern: zr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillPattern: zr(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
          fillExtrusion: zr(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
          fillExtrusionPattern: zr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
          hillshadePrepare: zr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
          hillshade: zr(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          line: zr(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          lineGradient: zr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          linePattern: zr(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
          lineSDF: zr(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          lineGradientSDF: zr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          raster: zr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
          symbolIcon: zr(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
          symbolSDF: zr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
          symbolTextAndIcon: zr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
          terrain: zr("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
          terrainDepth: zr("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
          terrainCoords: zr("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
          projectionErrorMeasurement: zr("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
          atmosphere: zr(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
          sky: zr("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
        };

        function zr(h, e) {
          const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            l = e.match(/in ([\w]+) ([\w]+)/g),
            u = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            p = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            v = p ? p.concat(u) : u,
            T = {};
          return {
            fragmentSource: h = h.replace(i, ((S, k, L, V, B) => (T[B] = !0, k === "define" ? `
#ifndef HAS_UNIFORM_u_${B}
in ${L} ${V} ${B};
#else
uniform ${L} ${V} u_${B};
#endif
` : `
#ifdef HAS_UNIFORM_u_${B}
    ${L} ${V} ${B} = u_${B};
#endif
`))),
            vertexSource: e = e.replace(i, ((S, k, L, V, B) => {
              const H = V === "float" ? "vec2" : "vec4",
                re = B.match(/color/) ? "color" : H;
              return T[B] ? k === "define" ? `
#ifndef HAS_UNIFORM_u_${B}
uniform lowp float u_${B}_t;
in ${L} ${H} a_${B};
out ${L} ${V} ${B};
#else
uniform ${L} ${V} u_${B};
#endif
` : re === "vec4" ? `
#ifndef HAS_UNIFORM_u_${B}
    ${B} = a_${B};
#else
    ${L} ${V} ${B} = u_${B};
#endif
` : `
#ifndef HAS_UNIFORM_u_${B}
    ${B} = unpack_mix_${re}(a_${B}, u_${B}_t);
#else
    ${L} ${V} ${B} = u_${B};
#endif
` : k === "define" ? `
#ifndef HAS_UNIFORM_u_${B}
uniform lowp float u_${B}_t;
in ${L} ${H} a_${B};
#else
uniform ${L} ${V} u_${B};
#endif
` : re === "vec4" ? `
#ifndef HAS_UNIFORM_u_${B}
    ${L} ${V} ${B} = a_${B};
#else
    ${L} ${V} ${B} = u_${B};
#endif
` : `
#ifndef HAS_UNIFORM_u_${B}
    ${L} ${V} ${B} = unpack_mix_${re}(a_${B}, u_${B}_t);
#else
    ${L} ${V} ${B} = u_${B};
#endif
`
            })),
            staticAttributes: l,
            staticUniforms: v
          }
        }
        class Fn {
          constructor(e, i, l) {
            this.vertexBuffer = e, this.indexBuffer = i, this.segments = l
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null
          }
        }
        var xn = s.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }]);
        const In = "#define PROJECTION_MERCATOR",
          qn = "mercator";
        class $n {
          constructor() {
            this._cachedMesh = null
          }
          get name() {
            return "mercator"
          }
          get useSubdivision() {
            return !1
          }
          get shaderVariantName() {
            return qn
          }
          get shaderDefine() {
            return In
          }
          get shaderPreludeCode() {
            return gr.projectionMercator
          }
          get vertexShaderPreludeCode() {
            return gr.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return s.aO.noSubdivision
          }
          get useGlobeControls() {
            return !1
          }
          get transitionState() {
            return 0
          }
          get latitudeErrorCorrectionRadians() {
            return 0
          }
          destroy() {}
          updateGPUdependent(e) {}
          getMeshFromTileID(e, i, l, u, p) {
            if (this._cachedMesh) return this._cachedMesh;
            const v = new s.aP;
            v.emplaceBack(0, 0), v.emplaceBack(s.a3, 0), v.emplaceBack(0, s.a3), v.emplaceBack(s.a3, s.a3);
            const T = e.createVertexBuffer(v, xn.members),
              S = s.aQ.simpleSegment(0, 0, 4, 2),
              k = new s.aR;
            k.emplaceBack(1, 0, 2), k.emplaceBack(1, 2, 3);
            const L = e.createIndexBuffer(k);
            return this._cachedMesh = new Fn(T, L, S), this._cachedMesh
          }
          recalculate() {}
          hasTransition() {
            return !1
          }
          setErrorQueryLatitudeDegrees(e) {}
        }
        class Mn {
          constructor(e = 0, i = 0, l = 0, u = 0) {
            if (isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(l) || l < 0 || isNaN(u) || u < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = i, this.left = l, this.right = u
          }
          interpolate(e, i, l) {
            return i.top != null && e.top != null && (this.top = s.F.number(e.top, i.top, l)), i.bottom != null && e.bottom != null && (this.bottom = s.F.number(e.bottom, i.bottom, l)), i.left != null && e.left != null && (this.left = s.F.number(e.left, i.left, l)), i.right != null && e.right != null && (this.right = s.F.number(e.right, i.right, l)), this
          }
          getCenter(e, i) {
            const l = s.ai((this.left + e - this.right) / 2, 0, e),
              u = s.ai((this.top + i - this.bottom) / 2, 0, i);
            return new s.P(l, u)
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
          }
          clone() {
            return new Mn(this.top, this.bottom, this.left, this.right)
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right
            }
          }
        }

        function Qr(h, e) {
          if (!h.renderWorldCopies || h.lngRange) return;
          const i = e.lng - h.center.lng;
          e.lng += i > 180 ? -360 : i < -180 ? 360 : 0
        }

        function Tn(h) {
          return Math.max(0, Math.floor(h))
        }
        class Bn {
          constructor(e, i) {
            var l;
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = (i == null ? void 0 : i.renderWorldCopies) === void 0 || !!(i != null && i.renderWorldCopies), this._minZoom = (i == null ? void 0 : i.minZoom) || 0, this._maxZoom = (i == null ? void 0 : i.maxZoom) || 22, this._minPitch = (i == null ? void 0 : i.minPitch) == null ? 0 : i == null ? void 0 : i.minPitch, this._maxPitch = (i == null ? void 0 : i.maxPitch) == null ? 60 : i == null ? void 0 : i.maxPitch, this._constrain = (l = i == null ? void 0 : i.constrain) !== null && l !== void 0 ? l : this._callbacks.constrain, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new s.U(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Tn(this._zoom), this._scale = s.al(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Mn, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0
          }
          apply(e, i, l) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = Tn(this._zoom), this._scale = s.al(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new Mn(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !l && e.autoCalculateNearFarZ, i && this.constrainInternal(), this._calcMatrices()
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e
          }
          get tileSize() {
            return this._tileSize
          }
          get tileZoom() {
            return this._tileZoom
          }
          get scale() {
            return this._scale
          }
          get width() {
            return this._width
          }
          get height() {
            return this._height
          }
          get bearingInRadians() {
            return this._bearingInRadians
          }
          get lngRange() {
            return this._lngRange
          }
          get latRange() {
            return this._latRange
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits
          }
          get minZoom() {
            return this._minZoom
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get maxZoom() {
            return this._maxZoom
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get minPitch() {
            return this._minPitch
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)))
          }
          get maxPitch() {
            return this._maxPitch
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)))
          }
          get renderWorldCopies() {
            return this._renderWorldCopies
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e
          }
          get constrain() {
            return this._constrain
          }
          setConstrain(e) {
            e || (e = this._callbacks.constrain), this._constrain = e, this.constrainInternal(), this._calcMatrices()
          }
          get worldSize() {
            return this._tileSize * this._scale
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2))
          }
          get size() {
            return new s.P(this._width, this._height)
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180
          }
          setBearing(e) {
            const i = s.V(e, -180, 180) * Math.PI / 180;
            var l, u, p, v, T, S, k, L, V;
            this._bearingInRadians !== i && (this._unmodified = !1, this._bearingInRadians = i, this._calcMatrices(), this._rotationMatrix = q(), l = this._rotationMatrix, p = -this._bearingInRadians, v = (u = this._rotationMatrix)[0], T = u[1], S = u[2], k = u[3], L = Math.sin(p), V = Math.cos(p), l[0] = v * V + S * L, l[1] = T * V + k * L, l[2] = v * -L + S * V, l[3] = T * -L + k * V)
          }
          get rotationMatrix() {
            return this._rotationMatrix
          }
          get pitchInRadians() {
            return this._pitchInRadians
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180
          }
          setPitch(e) {
            const i = s.ai(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== i && (this._unmodified = !1, this._pitchInRadians = i, this._calcMatrices())
          }
          get rollInRadians() {
            return this._rollInRadians
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180
          }
          setRoll(e) {
            const i = e / 180 * Math.PI;
            this._rollInRadians !== i && (this._unmodified = !1, this._rollInRadians = i, this._calcMatrices())
          }
          get fovInRadians() {
            return this._fovInRadians
          }
          get fov() {
            return s.aS(this._fovInRadians)
          }
          setFov(e) {
            e = s.ai(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = s.ak(e), this._calcMatrices())
          }
          get zoom() {
            return this._zoom
          }
          setZoom(e) {
            const i = this.constrain(this._center, e).zoom;
            this._zoom !== i && (this._unmodified = !1, this._zoom = i, this._tileZoom = Math.max(0, Math.floor(i)), this._scale = s.al(i), this.constrainInternal(), this._calcMatrices())
          }
          get center() {
            return this._center
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this.constrainInternal(), this._calcMatrices())
          }
          get elevation() {
            return this._elevation
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this.constrainInternal(), this._calcMatrices())
          }
          get padding() {
            return this._edgeInsets.toJSON()
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices())
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height)
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter
          }
          get unmodified() {
            return this._unmodified
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance
          }
          get nearZ() {
            return this._nearZ
          }
          get farZ() {
            return this._farZ
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ
          }
          overrideNearFarZ(e, i) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = i, this._calcMatrices()
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices()
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e)
          }
          interpolatePadding(e, i, l) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, i, l), this.constrainInternal(), this._calcMatrices()
          }
          resize(e, i, l = !0) {
            this._width = e, this._height = i, l && this.constrainInternal(), this._calcMatrices()
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new jt([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-s.aj, s.aj])
          }
          getCameraQueryGeometry(e, i) {
            if (i.length === 1) return [i[0], e];
            {
              const {
                minX: l,
                minY: u,
                maxX: p,
                maxY: v
              } = s.a6.fromPoints(i).extend(e);
              return [new s.P(l, u), new s.P(p, u), new s.P(p, v), new s.P(l, v), new s.P(l, u)]
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified,
              {
                center: i,
                zoom: l
              } = this.constrain(this.center, this.zoom);
            this.setCenter(i), this.setZoom(l), this._unmodified = e, this._constraining = !1
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = s.am(new Float64Array(16));
              s.O(e, e, [this._width / 2, -this._height / 2, 1]), s.N(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = s.am(new Float64Array(16)), s.O(e, e, [1, -1, 1]), s.N(e, e, [-1, -1, 0]), s.O(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
            }
            this._callbacks.calcMatrices()
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            const p = l !== void 0 ? l : this.bearing,
              v = u = u !== void 0 ? u : this.pitch,
              T = s.a5.fromLngLat(e, i),
              S = -Math.cos(s.ak(v)),
              k = Math.sin(s.ak(v)),
              L = k * Math.sin(s.ak(p)),
              V = -k * Math.cos(s.ak(p));
            let B = this.elevation;
            const H = i - B;
            let re;
            S * H >= 0 || Math.abs(S) < .1 ? (re = 1e4, B = i + re * S) : re = -H / S;
            let le, ue, de = s.aT(1, T.y),
              ve = 0;
            do {
              if (ve += 1, ve > 10) break;
              ue = re / de, le = new s.a5(T.x + L * ue, T.y + V * ue), de = 1 / le.meterInMercatorCoordinateUnits()
            } while (Math.abs(re - ue * de) > 1e-12);
            return {
              center: le.toLngLat(),
              elevation: B,
              zoom: s.ao(this.height / 2 / Math.tan(this.fovInRadians / 2) / ue / this.tileSize)
            }
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const i = s.an(1, this.center.lat) * this.worldSize,
              l = this.cameraToCenterDistance / i,
              u = s.a5.fromLngLat(this.center, this.elevation),
              p = Q(this.center, this.elevation, this.pitch, this.bearing, l);
            this._elevation = e;
            const v = this.calculateCenterFromCameraLngLatAlt(p.toLngLat(), s.aT(p.z, u.y), this.bearing, this.pitch);
            this._elevation = v.elevation, this._center = v.center, this.setZoom(v.zoom)
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new s.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)))
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
          }
          getCameraLngLat() {
            const e = s.an(1, this.center.lat) * this.worldSize;
            return Q(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const i = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / i, e.canonical.y / i, 1 / i / s.a3, 1 / i / s.a3]
          }
        }
        class bn {
          constructor(e, i) {
            this.min = e, this.max = i, this.center = s.aU([], s.aV([], this.min, this.max), .5)
          }
          quadrant(e) {
            const i = [e % 2 == 0, e < 2],
              l = s.aW(this.min),
              u = s.aW(this.max);
            for (let p = 0; p < i.length; p++) l[p] = i[p] ? this.min[p] : this.center[p], u[p] = i[p] ? this.center[p] : this.max[p];
            return u[2] = this.max[2], new bn(l, u)
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
          }
          intersectsFrustum(e) {
            let i = !0;
            for (let l = 0; l < e.planes.length; l++) {
              const u = this.intersectsPlane(e.planes[l]);
              if (u === 0) return 0;
              u === 1 && (i = !1)
            }
            return i ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
          }
          intersectsPlane(e) {
            let i = e[3],
              l = e[3];
            for (let u = 0; u < 3; u++) e[u] > 0 ? (i += e[u] * this.min[u], l += e[u] * this.max[u]) : (l += e[u] * this.min[u], i += e[u] * this.max[u]);
            return i >= 0 ? 2 : l < 0 ? 0 : 1
          }
        }
        class vn {
          distanceToTile2d(e, i, l, u) {
            const p = u.distanceX([e, i]),
              v = u.distanceY([e, i]);
            return Math.hypot(p, v)
          }
          getWrap(e, i, l) {
            return l
          }
          getTileBoundingVolume(e, i, l, u) {
            var p, v;
            let T = 0,
              S = 0;
            if (u != null && u.terrain) {
              const L = new s.a0(e.z, i, e.z, e.x, e.y),
                V = u.terrain.getMinMaxElevation(L);
              T = (p = V.minElevation) !== null && p !== void 0 ? p : Math.min(0, l), S = (v = V.maxElevation) !== null && v !== void 0 ? v : Math.max(0, l)
            }
            const k = 1 << e.z;
            return new bn([i + e.x / k, e.y / k, T], [i + (e.x + 1) / k, (e.y + 1) / k, S])
          }
          allowVariableZoom(e, i) {
            const l = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height,
              u = s.ai(78.5 - l / 2, 0, 60);
            return !!i.terrain || e.pitch > u
          }
          allowWorldCopies() {
            return !0
          }
          prepareNextFrame() {}
        }
        class ii {
          constructor(e, i, l) {
            this.points = e, this.planes = i, this.aabb = l
          }
          static fromInvProjectionMatrix(e, i = 1, l = 0, u, p) {
            const v = p ? [
                [6, 5, 4],
                [0, 1, 2],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ] : [
                [0, 1, 2],
                [6, 5, 4],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ],
              T = Math.pow(2, l),
              S = [
                [-1, 1, -1, 1],
                [1, 1, -1, 1],
                [1, -1, -1, 1],
                [-1, -1, -1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, -1, 1, 1],
                [-1, -1, 1, 1]
              ].map((B => (function(H, re, le, ue) {
                const de = s.aA([], H, re),
                  ve = 1 / de[3] / le * ue;
                return s.a$(de, de, [ve, ve, 1 / de[3], ve])
              })(B, e, i, T)));
            u && (function(B, H, re, le) {
              const ue = le ? 4 : 0,
                de = le ? 0 : 4;
              let ve = 0;
              const Ae = [],
                _e = [];
              for (let xe = 0; xe < 4; xe++) {
                const Ve = s.aX([], B[xe + de], B[xe + ue]),
                  lt = s.b0(Ve);
                s.aU(Ve, Ve, 1 / lt), Ae.push(lt), _e.push(Ve)
              }
              for (let xe = 0; xe < 4; xe++) {
                const Ve = s.b1(B[xe + ue], _e[xe], re);
                ve = Ve !== null && Ve >= 0 ? Math.max(ve, Ve) : Math.max(ve, Ae[xe])
              }
              const ke = (function(xe, Ve) {
                  const lt = s.aX([], xe[Ve[0]], xe[Ve[1]]),
                    rt = s.aX([], xe[Ve[2]], xe[Ve[1]]),
                    at = [0, 0, 0, 0];
                  return s.aY(at, s.aZ([], lt, rt)), at[3] = -s.a_(at, xe[Ve[0]]), at
                })(B, H),
                Fe = (function(xe, Ve) {
                  const lt = s.b2(xe),
                    rt = s.b3([], xe, 1 / lt),
                    at = s.aX([], Ve, s.aU([], rt, s.a_(Ve, rt))),
                    ct = s.b2(at);
                  if (ct > 0) {
                    const er = Math.sqrt(1 - rt[3] * rt[3]),
                      rr = s.aU([], rt, -rt[3]),
                      kt = s.aV([], rr, s.aU([], at, er / ct));
                    return s.b4(Ve, kt)
                  }
                  return null
                })(re, ke);
              if (Fe !== null) {
                const xe = Fe / s.a_(_e[0], ke);
                ve = Math.min(ve, xe)
              }
              for (let xe = 0; xe < 4; xe++) {
                const Ve = Math.min(ve, Ae[xe]);
                B[xe + de] = [B[xe + ue][0] + _e[xe][0] * Ve, B[xe + ue][1] + _e[xe][1] * Ve, B[xe + ue][2] + _e[xe][2] * Ve, 1]
              }
            })(S, v[0], u, p);
            const k = v.map((B => {
                const H = s.aX([], S[B[0]], S[B[1]]),
                  re = s.aX([], S[B[2]], S[B[1]]),
                  le = s.aY([], s.aZ([], H, re)),
                  ue = -s.a_(le, S[B[1]]);
                return le.concat(ue)
              })),
              L = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
              V = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const B of S)
              for (let H = 0; H < 3; H++) L[H] = Math.min(L[H], B[H]), V[H] = Math.max(V[H], B[H]);
            return new ii(S, k, new bn(L, V))
          }
        }
        class Kn {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, i, l) {
            return this._helper.interpolatePadding(e, i, l)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, i, l = !0) {
            this._helper.resize(e, i, l)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e, i) {}
          constructor(e) {
            this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this.defaultConstrain = (i, l) => {
              l = s.ai(+l, this.minZoom, this.maxZoom);
              const u = {
                center: new s.U(i.lng, i.lat),
                zoom: l
              };
              let p = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && p === null) {
                const _e = 179.9999999999;
                p = [-_e, _e]
              }
              const v = this.tileSize * s.al(u.zoom);
              let T = 0,
                S = v,
                k = 0,
                L = v,
                V = 0,
                B = 0;
              const {
                x: H,
                y: re
              } = this.size;
              if (this._helper._latRange) {
                const _e = this._helper._latRange;
                T = s.W(_e[1]) * v, S = s.W(_e[0]) * v, S - T < re && (V = re / (S - T))
              }
              p && (k = s.V(s.X(p[0]) * v, 0, v), L = s.V(s.X(p[1]) * v, 0, v), L < k && (L += v), L - k < H && (B = H / (L - k)));
              const {
                x: le,
                y: ue
              } = Oe(v, i);
              let de, ve;
              const Ae = Math.max(B || 0, V || 0);
              if (Ae) {
                const _e = new s.P(B ? (L + k) / 2 : le, V ? (S + T) / 2 : ue);
                return u.center = oe(v, _e).wrap(), u.zoom += s.ao(Ae), u
              }
              if (this._helper._latRange) {
                const _e = re / 2;
                ue - _e < T && (ve = T + _e), ue + _e > S && (ve = S - _e)
              }
              if (p) {
                const _e = (k + L) / 2;
                let ke = le;
                this._helper._renderWorldCopies && (ke = s.V(le, _e - v / 2, _e + v / 2));
                const Fe = H / 2;
                ke - Fe < k && (de = k + Fe), ke + Fe > L && (de = L - Fe)
              }
              if (de !== void 0 || ve !== void 0) {
                const _e = new s.P(de ?? le, ve ?? ue);
                u.center = oe(v, _e).wrap()
              }
              return u
            }, this._helper = new Bn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (i, l) => this.defaultConstrain(i, l)
            }, e), this._coveringTilesDetailsProvider = new vn
          }
          clone() {
            const e = new Kn;
            return e.apply(this), e
          }
          apply(e, i, l) {
            this._helper.apply(e, i, l)
          }
          get cameraPosition() {
            return this._cameraPosition
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix
          }
          get mercatorMatrix() {
            return this._mercatorMatrix
          }
          getVisibleUnwrappedCoordinates(e) {
            const i = [new s.b5(0, e)];
            if (this._helper._renderWorldCopies) {
              const l = this.screenPointToMercatorCoordinate(new s.P(0, 0)),
                u = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, 0)),
                p = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, this._helper._height)),
                v = this.screenPointToMercatorCoordinate(new s.P(0, this._helper._height)),
                T = Math.floor(Math.min(l.x, u.x, p.x, v.x)),
                S = Math.floor(Math.max(l.x, u.x, p.x, v.x)),
                k = 1;
              for (let L = T - k; L <= S + k; L++) L !== 0 && i.push(new s.b5(L, e))
            }
            return i
          }
          getCameraFrustum() {
            return ii.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
          }
          getClippingPlane() {
            return null
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            const i = this.screenPointToLocation(this.centerPoint, e),
              l = e ? e.getElevationForLngLatZoom(i, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(l)
          }
          setLocationAtPoint(e, i) {
            const l = s.an(this.elevation, this.center.lat),
              u = this.screenPointToMercatorCoordinateAtZ(i, l),
              p = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, l),
              v = s.a5.fromLngLat(e),
              T = new s.a5(v.x - (u.x - p.x), v.y - (u.y - p.y));
            this.setCenter(T == null ? void 0 : T.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
          }
          locationToScreenPoint(e, i) {
            return i ? this.coordinatePoint(s.a5.fromLngLat(e), i.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(s.a5.fromLngLat(e))
          }
          screenPointToLocation(e, i) {
            var l;
            return (l = this.screenPointToMercatorCoordinate(e, i)) === null || l === void 0 ? void 0 : l.toLngLat()
          }
          screenPointToMercatorCoordinate(e, i) {
            if (i) {
              const l = i.pointCoordinate(e);
              if (l != null) return l
            }
            return this.screenPointToMercatorCoordinateAtZ(e)
          }
          screenPointToMercatorCoordinateAtZ(e, i) {
            const l = i || 0,
              u = [e.x, e.y, 0, 1],
              p = [e.x, e.y, 1, 1];
            s.aA(u, u, this._pixelMatrixInverse), s.aA(p, p, this._pixelMatrixInverse);
            const v = u[3],
              T = p[3],
              S = u[1] / v,
              k = p[1] / T,
              L = u[2] / v,
              V = p[2] / T,
              B = L === V ? 0 : (l - L) / (V - L);
            return new s.a5(s.F.number(u[0] / v, p[0] / T, B) / this.worldSize, s.F.number(S, k, B) / this.worldSize, l)
          }
          coordinatePoint(e, i = 0, l = this._pixelMatrix) {
            const u = [e.x * this.worldSize, e.y * this.worldSize, i, 1];
            return s.aA(u, u, l), new s.P(u[0] / u[3], u[1] / u[3])
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - K(this));
            return new jt().extend(this.screenPointToLocation(new s.P(0, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new s.P(0, this._helper._height)))
          }
          isPointOnMapSurface(e, i) {
            return i ? i.pointCoordinate(e) != null : e.y > this.height / 2 - K(this)
          }
          calculatePosMatrix(e, i = !1, l) {
            var u;
            const p = (u = e.key) !== null && u !== void 0 ? u : s.b6(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y),
              v = i ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (v.has(p)) {
              const k = v.get(p);
              return l ? k.f32 : k.f64
            }
            const T = he(e, this.worldSize);
            s.Q(T, i ? this._alignedProjMatrix : this._viewProjMatrix, T);
            const S = {
              f64: T,
              f32: new Float32Array(T)
            };
            return v.set(p, S), l ? S.f32 : S.f64
          }
          calculateFogMatrix(e) {
            const i = e.key,
              l = this._fogMatrixCacheF32;
            if (l.has(i)) return l.get(i);
            const u = he(e, this.worldSize);
            return s.Q(u, this._fogMatrix, u), l.set(i, new Float32Array(u)), l.get(i)
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, l, u)
          }
          _calculateNearFarZIfNeeded(e, i, l) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const u = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100),
              p = e - u * this._helper._pixelPerMeter / Math.cos(i),
              v = u < 0 ? p : e,
              T = Math.PI / 2 + this.pitchInRadians,
              S = s.ak(this.fov) * (Math.abs(Math.cos(s.ak(this.roll))) * this.height + Math.abs(Math.sin(s.ak(this.roll))) * this.width) / this.height * (.5 + l.y / this.height),
              k = Math.sin(S) * v / Math.sin(s.ai(Math.PI - T - S, .01, Math.PI - .01)),
              L = K(this),
              V = Math.atan(L / this._helper.cameraToCenterDistance),
              B = s.ak(.75),
              H = V > B ? 2 * V * (.5 + l.y / (2 * L)) : B,
              re = Math.sin(H) * v / Math.sin(s.ai(Math.PI - T - H, .01, Math.PI - .01)),
              le = Math.min(k, re);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i) * le + v), this._helper._nearZ = this._helper._height / 50
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset,
              i = Oe(this.worldSize, this.center),
              l = i.x,
              u = i.y;
            this._helper._pixelPerMeter = s.an(1, this.center.lat) * this.worldSize;
            const p = s.ak(Math.min(this.pitch, ye)),
              v = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(p));
            let T;
            this._calculateNearFarZIfNeeded(v, p, e), T = new Float64Array(16), s.b7(T, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), s.au(this._invProjMatrix, T), T[8] = 2 * -e.x / this._helper._width, T[9] = 2 * e.y / this._helper._height, this._projectionMatrix = s.b8(T), s.O(T, T, [1, -1, 1]), s.N(T, T, [0, 0, -this._helper.cameraToCenterDistance]), s.b9(T, T, -this.rollInRadians), s.ba(T, T, this.pitchInRadians), s.b9(T, T, -this.bearingInRadians), s.N(T, T, [-l, -u, 0]), this._mercatorMatrix = s.O([], T, [this.worldSize, this.worldSize, this.worldSize]), s.O(T, T, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = s.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, T), s.N(T, T, [0, 0, -this.elevation]), this._viewProjMatrix = T, this._invViewProjMatrix = s.au([], T);
            const S = [0, 0, -1, 1];
            s.aA(S, S, this._invViewProjMatrix), this._cameraPosition = [S[0] / S[3], S[1] / S[3], S[2] / S[3]], this._fogMatrix = new Float64Array(16), s.b7(this._fogMatrix, this.fovInRadians, this.width / this.height, v, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, s.O(this._fogMatrix, this._fogMatrix, [1, -1, 1]), s.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), s.b9(this._fogMatrix, this._fogMatrix, -this.rollInRadians), s.ba(this._fogMatrix, this._fogMatrix, this.pitchInRadians), s.b9(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), s.N(this._fogMatrix, this._fogMatrix, [-l, -u, 0]), s.O(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), s.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = s.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, T);
            const k = this._helper._width % 2 / 2,
              L = this._helper._height % 2 / 2,
              V = Math.cos(this.bearingInRadians),
              B = Math.sin(-this.bearingInRadians),
              H = l - Math.round(l) + V * k + B * L,
              re = u - Math.round(u) + V * L + B * k,
              le = new Float64Array(T);
            if (s.N(le, le, [H > .5 ? H - 1 : H, re > .5 ? re - 1 : re, 0]), this._alignedProjMatrix = le, T = s.au(new Float64Array(16), this._pixelMatrix), !T) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = T, this._clearMatrixCaches()
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear()
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new s.P(0, 0)),
              i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return s.aA(i, i, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            const e = s.an(1, this.center.lat) * this.worldSize;
            return Q(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
          }
          lngLatToCameraDepth(e, i) {
            const l = s.a5.fromLngLat(e),
              u = [l.x * this.worldSize, l.y * this.worldSize, i, 1];
            return s.aA(u, u, this._viewProjMatrix), u[2] / u[3]
          }
          getProjectionData(e) {
            const {
              overscaledTileID: i,
              aligned: l,
              applyTerrainMatrix: u
            } = e, p = this._helper.getMercatorTileCoordinates(i), v = i ? this.calculatePosMatrix(i, l, !0) : null;
            let T;
            return T = i && i.terrainRttPosMatrix32f && u ? i.terrainRttPosMatrix32f : v || s.bb(), {
              mainMatrix: T,
              tileMercatorCoords: p,
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: T
            }
          }
          isLocationOccluded(e) {
            return !1
          }
          getPixelScale() {
            return 1
          }
          getCircleRadiusCorrection() {
            return 1
          }
          getPitchedTextCorrection(e, i, l) {
            return 1
          }
          transformLightDirection(e) {
            return s.aW(e)
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.")
          }
          projectTileCoordinates(e, i, l, u) {
            const p = this.calculatePosMatrix(l);
            let v;
            u ? (v = [e, i, u(e, i), 1], s.aA(v, v, p)) : (v = [e, i, 0, 1], wr(v, v, p));
            const T = v[3];
            return {
              point: new s.P(v[0] / T, v[1] / T),
              signedDistanceFromCamera: T,
              isOccluded: !1
            }
          }
          populateCache(e) {
            for (const i of e) this.calculatePosMatrix(i)
          }
          getMatrixForModel(e, i) {
            const l = s.a5.fromLngLat(e, i),
              u = l.meterInMercatorCoordinateUnits(),
              p = s.bc();
            return s.N(p, p, [l.x, l.y, l.z]), s.b9(p, p, Math.PI), s.ba(p, p, Math.PI / 2), s.O(p, p, [-u, u, u]), p
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = new s.a0(0, 0, 0, 0, 0),
              l = this.getProjectionData({
                overscaledTileID: i,
                applyGlobeMatrix: e
              }),
              u = he(i, this.worldSize);
            s.Q(u, this._viewProjMatrix, u), l.tileMercatorCoords = [0, 0, 1, 1];
            const p = [s.a3, s.a3, this.worldSize / this._helper.pixelsPerMeter],
              v = s.bd();
            return s.O(v, u, p), l.fallbackMatrix = v, l.mainMatrix = v, l
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e)
          }
        }

        function Vn() {
          s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
        }

        function ga(h) {
          if (h.useSlerp)
            if (h.k < 1) {
              const e = s.be(h.startEulerAngles.roll, h.startEulerAngles.pitch, h.startEulerAngles.bearing),
                i = s.be(h.endEulerAngles.roll, h.endEulerAngles.pitch, h.endEulerAngles.bearing),
                l = new Float64Array(4);
              s.bf(l, e, i, h.k);
              const u = s.bg(l);
              h.tr.setRoll(u.roll), h.tr.setPitch(u.pitch), h.tr.setBearing(u.bearing)
            } else h.tr.setRoll(h.endEulerAngles.roll), h.tr.setPitch(h.endEulerAngles.pitch), h.tr.setBearing(h.endEulerAngles.bearing);
          else h.tr.setRoll(s.F.number(h.startEulerAngles.roll, h.endEulerAngles.roll, h.k)), h.tr.setPitch(s.F.number(h.startEulerAngles.pitch, h.endEulerAngles.pitch, h.k)), h.tr.setBearing(s.F.number(h.startEulerAngles.bearing, h.endEulerAngles.bearing, h.k))
        }

        function ta(h, e, i, l, u) {
          const p = u.padding,
            v = Oe(u.worldSize, i.getNorthWest()),
            T = Oe(u.worldSize, i.getNorthEast()),
            S = Oe(u.worldSize, i.getSouthEast()),
            k = Oe(u.worldSize, i.getSouthWest()),
            L = s.ak(-l),
            V = v.rotate(L),
            B = T.rotate(L),
            H = S.rotate(L),
            re = k.rotate(L),
            le = new s.P(Math.max(V.x, B.x, re.x, H.x), Math.max(V.y, B.y, re.y, H.y)),
            ue = new s.P(Math.min(V.x, B.x, re.x, H.x), Math.min(V.y, B.y, re.y, H.y)),
            de = le.sub(ue),
            ve = (u.width - (p.left + p.right + e.left + e.right)) / de.x,
            Ae = (u.height - (p.top + p.bottom + e.top + e.bottom)) / de.y;
          if (Ae < 0 || ve < 0) return void Vn();
          const _e = Math.min(s.ao(u.scale * Math.min(ve, Ae)), h.maxZoom),
            ke = s.P.convert(h.offset),
            Fe = new s.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(s.ak(l)),
            xe = ke.add(Fe).mult(u.scale / s.al(_e));
          return {
            center: oe(u.worldSize, v.add(S).div(2).sub(xe)),
            zoom: _e,
            bearing: l
          }
        }
        class Fi {
          get useGlobeControls() {
            return !1
          }
          handlePanInertia(e, i) {
            const l = e.mag(),
              u = Math.abs(K(i));
            return {
              easingOffset: e.mult(Math.min(.75 * u / l, 1)),
              easingCenter: i.center
            }
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta), e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta)
          }
          handleMapControlsPan(e, i, l) {
            e.around.distSqr(i.centerPoint) < .01 || i.setLocationAtPoint(l, e.around)
          }
          cameraForBoxAndBearing(e, i, l, u, p) {
            return ta(e, i, l, u, p)
          }
          handleJumpToCenterZoom(e, i) {
            e.zoom !== (i.zoom !== void 0 ? +i.zoom : e.zoom) && e.setZoom(+i.zoom), i.center !== void 0 && e.setCenter(s.U.convert(i.center))
          }
          handleEaseTo(e, i) {
            const l = e.zoom,
              u = e.padding,
              p = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              v = {
                roll: i.roll === void 0 ? e.roll : i.roll,
                pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                bearing: i.bearing === void 0 ? e.bearing : i.bearing
              },
              T = i.zoom !== void 0,
              S = !e.isPaddingEqual(i.padding);
            let k = !1;
            const L = T ? +i.zoom : e.zoom;
            let V = e.centerPoint.add(i.offsetAsPoint);
            const B = e.screenPointToLocation(V),
              {
                center: H,
                zoom: re
              } = e.constrain(s.U.convert(i.center || B), L ?? l);
            Qr(e, H);
            const le = Oe(e.worldSize, B),
              ue = Oe(e.worldSize, H).sub(le),
              de = s.al(re - l);
            return k = re !== l, {
              easeFunc: ve => {
                if (k && e.setZoom(s.F.number(l, re, ve)), s.bh(p, v) || ga({
                    startEulerAngles: p,
                    endEulerAngles: v,
                    tr: e,
                    k: ve,
                    useSlerp: p.roll != v.roll
                  }), S && (e.interpolatePadding(u, i.padding, ve), V = e.centerPoint.add(i.offsetAsPoint)), i.around) e.setLocationAtPoint(i.around, i.aroundPoint);
                else {
                  const Ae = s.al(e.zoom - l),
                    _e = re > l ? Math.min(2, de) : Math.max(.5, de),
                    ke = Math.pow(_e, 1 - ve),
                    Fe = oe(e.worldSize, le.add(ue.mult(ve * ke)).mult(Ae));
                  e.setLocationAtPoint(e.renderWorldCopies ? Fe.wrap() : Fe, V)
                }
              },
              isZooming: k,
              elevationCenter: H
            }
          }
          handleFlyTo(e, i) {
            const l = i.zoom !== void 0,
              u = e.zoom,
              p = e.constrain(s.U.convert(i.center || i.locationAtOffset), l ? +i.zoom : u),
              v = p.center,
              T = p.zoom;
            Qr(e, v);
            const S = Oe(e.worldSize, i.locationAtOffset),
              k = Oe(e.worldSize, v).sub(S),
              L = k.mag(),
              V = s.al(T - u);
            let B;
            if (i.minZoom !== void 0) {
              const H = Math.min(+i.minZoom, u, T),
                re = e.constrain(v, H).zoom;
              B = s.al(re - u)
            }
            return {
              easeFunc: (H, re, le, ue) => {
                e.setZoom(H === 1 ? T : u + s.ao(re));
                const de = H === 1 ? v : oe(e.worldSize, S.add(k.mult(le)).mult(re));
                e.setLocationAtPoint(e.renderWorldCopies ? de.wrap() : de, ue)
              },
              scaleOfZoom: V,
              targetCenter: v,
              scaleOfMinZoom: B,
              pixelPathLength: L
            }
          }
        }
        class zn {
          constructor(e, i, l) {
            this.blendFunction = e, this.blendColor = i, this.mask = l
          }
        }
        zn.Replace = [1, 0], zn.disabled = new zn(zn.Replace, s.bi.transparent, [!1, !1, !1, !1]), zn.unblended = new zn(zn.Replace, s.bi.transparent, [!0, !0, !0, !0]), zn.alphaBlended = new zn([1, 771], s.bi.transparent, [!0, !0, !0, !0]);
        const ja = 2305;
        class Sn {
          constructor(e, i, l) {
            this.enable = e, this.mode = i, this.frontFace = l
          }
        }
        Sn.disabled = new Sn(!1, 1029, ja), Sn.backCCW = new Sn(!0, 1029, ja), Sn.frontCCW = new Sn(!0, 1028, ja);
        class _n {
          constructor(e, i, l) {
            this.func = e, this.mask = i, this.range = l
          }
        }
        _n.ReadOnly = !1, _n.ReadWrite = !0, _n.disabled = new _n(519, _n.ReadOnly, [0, 1]);
        const Ta = 7680;
        class En {
          constructor(e, i, l, u, p, v) {
            this.test = e, this.ref = i, this.mask = l, this.fail = u, this.depthFail = p, this.pass = v
          }
        }
        En.disabled = new En({
          func: 519,
          mask: 0
        }, 0, 0, Ta, Ta, Ta);
        const qa = new WeakMap;

        function Ui(h) {
          var e;
          if (qa.has(h)) return qa.get(h);
          {
            const i = (e = h.getParameter(h.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return qa.set(h, i), i
          }
        }
        class Va {
          get awaitingQuery() {
            return !!this._readbackQueue
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const i = e.context,
              l = i.gl;
            this._texFormat = l.RGBA, this._texType = l.UNSIGNED_BYTE;
            const u = new s.aP;
            u.emplaceBack(-1, -1), u.emplaceBack(2, -1), u.emplaceBack(-1, 2);
            const p = new s.aR;
            p.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Fn(i.createVertexBuffer(u, xn.members), i.createIndexBuffer(p), s.aQ.simpleSegment(0, 0, u.length, p.length)), this._resultBuffer = new Uint8Array(4), i.activeTexture.set(l.TEXTURE1);
            const v = l.createTexture();
            l.bindTexture(l.TEXTURE_2D, v), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, l.NEAREST), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, l.NEAREST), l.texImage2D(l.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(v), Ui(l) && (this._pbo = l.createBuffer(), l.bindBuffer(l.PIXEL_PACK_BUFFER, this._pbo), l.bufferData(l.PIXEL_PACK_BUFFER, 4, l.STREAM_READ), l.bindBuffer(l.PIXEL_PACK_BUFFER, null))
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null
          }
          updateErrorLoop(e, i) {
            const l = this._updateCount;
            return this._readbackQueue ? l >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : l >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, i), this._updateCount++, this._measuredError
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context,
              i = e.gl;
            e.activeTexture.set(i.TEXTURE1), i.bindTexture(i.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer)
          }
          _renderErrorTexture(e, i) {
            const l = this._cachedRenderContext.context,
              u = l.gl;
            if (this._bindFramebuffer(), l.viewport.set([0, 0, this._texWidth, this._texHeight]), l.clear({
                color: s.bi.transparent
              }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(l, u.TRIANGLES, _n.disabled, En.disabled, zn.unblended, Sn.disabled, ((p, v) => ({
                u_input: p,
                u_output_expected: v
              }))(e, i), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Ui(u)) {
              u.bindBuffer(u.PIXEL_PACK_BUFFER, this._pbo), u.readBuffer(u.COLOR_ATTACHMENT0), u.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), u.bindBuffer(u.PIXEL_PACK_BUFFER, null);
              const p = u.fenceSync(u.SYNC_GPU_COMMANDS_COMPLETE, 0);
              u.flush(), this._readbackQueue = {
                frameNumberIssued: this._updateCount,
                sync: p
              }
            } else this._readbackQueue = {
              frameNumberIssued: this._updateCount,
              sync: null
            }
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Ui(e)) {
              const i = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (i === e.WAIT_FAILED) return s.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void(this._lastReadbackFrame = this._updateCount);
              if (i === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = Va._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount
          }
          static _parseRGBA8float(e) {
            let i = 0;
            return i += e[0] / 256, i += e[1] / 65536, i += e[2] / 16777216, e[3] < 127 && (i = -i), i / 128
          }
        }
        const ci = s.a3 / 128;

        function wi(h, e) {
          const i = h.granularity !== void 0 ? Math.max(h.granularity, 1) : 1,
            l = i + (h.generateBorders ? 2 : 0),
            u = i + (h.extendToNorthPole || h.generateBorders ? 1 : 0) + (h.extendToSouthPole || h.generateBorders ? 1 : 0),
            p = l + 1,
            v = u + 1,
            T = h.generateBorders ? -1 : 0,
            S = h.generateBorders || h.extendToNorthPole ? -1 : 0,
            k = i + (h.generateBorders ? 1 : 0),
            L = i + (h.generateBorders || h.extendToSouthPole ? 1 : 0),
            V = p * v,
            B = l * u * 6,
            H = p * v > 65536;
          if (H && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const re = H || e === "32bit",
            le = new Int16Array(2 * V);
          let ue = 0;
          for (let Ae = S; Ae <= L; Ae++)
            for (let _e = T; _e <= k; _e++) {
              let ke = _e / i * s.a3;
              _e === -1 && (ke = -ci), _e === i + 1 && (ke = s.a3 + ci);
              let Fe = Ae / i * s.a3;
              Ae === -1 && (Fe = h.extendToNorthPole ? s.bk : -ci), Ae === i + 1 && (Fe = h.extendToSouthPole ? s.bl : s.a3 + ci), le[ue++] = ke, le[ue++] = Fe
            }
          const de = re ? new Uint32Array(B) : new Uint16Array(B);
          let ve = 0;
          for (let Ae = 0; Ae < u; Ae++)
            for (let _e = 0; _e < l; _e++) {
              const ke = _e + 1 + Ae * p,
                Fe = _e + (Ae + 1) * p,
                xe = _e + 1 + (Ae + 1) * p;
              de[ve++] = _e + Ae * p, de[ve++] = Fe, de[ve++] = ke, de[ve++] = ke, de[ve++] = Fe, de[ve++] = xe
            }
          return {
            vertices: le.buffer.slice(0),
            indices: de.buffer.slice(0),
            uses32bitIndices: re
          }
        }
        const sa = new s.aO({
          fill: new s.bm(128, 2),
          line: new s.bm(512, 0),
          tile: new s.bm(128, 32),
          stencil: new s.bm(128, 1),
          circle: 3
        });
        class Ra {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3
          }
          get name() {
            return "vertical-perspective"
          }
          get transitionState() {
            return 1
          }
          get useSubdivision() {
            return !0
          }
          get shaderVariantName() {
            return "globe"
          }
          get shaderDefine() {
            return "#define GLOBE"
          }
          get shaderPreludeCode() {
            return gr.projectionGlobe
          }
          get vertexShaderPreludeCode() {
            return gr.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return sa
          }
          get useGlobeControls() {
            return !0
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy()
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new Va(e));
            const i = s.W(this._errorQueryLatitudeDegrees),
              l = 2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) - .5 * Math.PI,
              u = this._errorMeasurement.updateErrorLoop(i, l),
              p = ie();
            u !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = u, this._errorMeasurementLastChangeTime = p);
            const v = Math.min(Math.max((p - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
            this._errorCorrectionUsable = s.bn(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, s.bo(v))
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders?"b":""}${e.extendToNorthPole?"n":""}${e.extendToSouthPole?"s":""}`
          }
          getMeshFromTileID(e, i, l, u, p) {
            const v = (p === "stencil" ? sa.stencil : sa.tile).getGranularityForZoomLevel(i.z);
            return this._getMesh(e, {
              granularity: v,
              generateBorders: l,
              extendToNorthPole: i.y === 0 && u,
              extendToSouthPole: i.y === (1 << i.z) - 1 && u
            })
          }
          _getMesh(e, i) {
            const l = this._getMeshKey(i);
            if (l in this._tileMeshCache) return this._tileMeshCache[l];
            const u = (function(p, v) {
              const T = wi(v, "16bit"),
                S = s.aP.deserialize({
                  arrayBuffer: T.vertices,
                  length: T.vertices.byteLength / 2 / 2
                }),
                k = s.aR.deserialize({
                  arrayBuffer: T.indices,
                  length: T.indices.byteLength / 2 / 3
                });
              return new Fn(p.createVertexBuffer(S, xn.members), p.createIndexBuffer(k), s.aQ.simpleSegment(0, 0, S.length, k.length))
            })(e, i);
            return this._tileMeshCache[l] = u, u
          }
          recalculate(e) {}
          hasTransition() {
            const e = ie();
            let i = !1;
            return i = i || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, i = i || this._errorMeasurement && this._errorMeasurement.awaitingQuery, i
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e
          }
        }
        const Sa = new s.r({
          type: new s.D(s.t.projection.type)
        });
        class la extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.x(Sa, void 0), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.G(0)), this._mercatorProjection = new $n, this._verticalPerspectiveProjection = new Ra
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof s.bp) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition
            }
            return 1
          }
          get useGlobeRendering() {
            return this.transitionState > 0
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
          }
          get name() {
            return "globe"
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity
          }
          get useGlobeControls() {
            return this.transitionState > 0
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy()
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e)
          }
          getMeshFromTileID(e, i, l, u, p) {
            return this.currentProjection.getMeshFromTileID(e, i, l, u, p)
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator")
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
          }
        }

        function eo(h) {
          const e = Zo(h.worldSize, h.center.lat);
          return 2 * Math.PI * e
        }

        function ca(h, e, i, l, u) {
          const p = 1 / (1 << u),
            v = e / s.a3 * p + l * p,
            T = s.br((h / s.a3 * p + i * p) * Math.PI * 2 + Math.PI, 2 * Math.PI),
            S = 2 * Math.atan(Math.exp(Math.PI - v * Math.PI * 2)) - .5 * Math.PI,
            k = Math.cos(S),
            L = new Float64Array(3);
          return L[0] = Math.sin(T) * k, L[1] = Math.sin(S), L[2] = Math.cos(T) * k, L
        }

        function Ti(h) {
          return (function(e, i) {
            const l = Math.cos(i),
              u = new Float64Array(3);
            return u[0] = Math.sin(e) * l, u[1] = Math.sin(i), u[2] = Math.cos(e) * l, u
          })(h.lng * Math.PI / 180, h.lat * Math.PI / 180)
        }

        function Zo(h, e) {
          return h / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
        }

        function rd(h) {
          const e = Math.asin(h[1]) / Math.PI * 180,
            i = Math.sqrt(h[0] * h[0] + h[2] * h[2]);
          if (i > 1e-6) {
            const l = h[0] / i,
              u = Math.acos(h[2] / i),
              p = (l > 0 ? u : -u) / Math.PI * 180;
            return new s.U(s.V(p, -180, 180), e)
          }
          return new s.U(0, e)
        }

        function Al(h) {
          return Math.cos(h * Math.PI / 180)
        }

        function Qn(h, e) {
          const i = Al(h),
            l = Al(e);
          return s.ao(l / i)
        }

        function kl(h, e) {
          const i = h.rotate(e.bearingInRadians),
            l = e.zoom + Qn(e.center.lat, 0),
            u = s.bn(1 / Al(e.center.lat), 1 / Al(Math.min(Math.abs(e.center.lat), 60)), s.bq(l, 7, 3, 0, 1)),
            p = 360 / eo({
              worldSize: e.worldSize,
              center: {
                lat: e.center.lat
              }
            });
          return new s.U(e.center.lng - i.x * p * u, s.ai(e.center.lat + i.y * p, -s.aj, s.aj))
        }

        function Fa(h) {
          const e = .5 * h,
            i = Math.sin(e),
            l = Math.cos(e);
          return Math.log(i + l) - Math.log(l - i)
        }

        function Ws(h, e, i, l) {
          const u = h.lat + i * l;
          if (Math.abs(i) > 1) {
            const p = (Math.sign(h.lat + i) !== Math.sign(h.lat) ? -Math.abs(h.lat) : Math.abs(h.lat)) * Math.PI / 180,
              v = Math.abs(h.lat + i) * Math.PI / 180,
              T = Fa(p + l * (v - p)),
              S = Fa(p),
              k = Fa(v);
            return new s.U(h.lng + e * ((T - S) / (k - S)), u)
          }
          return new s.U(h.lng + e * l, u)
        }
        class nd {
          constructor(e) {
            this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._boundingVolumeFactory = e
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1
          }
          getTileBoundingVolume(e, i, l, u) {
            const p = `${e.z}_${e.x}_${e.y}_${u!=null&&u.terrain?"t":""}`,
              v = this._cache.get(p);
            if (v) return v;
            const T = this._cachePrevious.get(p);
            if (T) return this._cache.set(p, T), T;
            const S = this._boundingVolumeFactory(e, i, l, u);
            return this._cache.set(p, S), this._hadAnyChanges = !0, S
          }
        }
        class Go {
          constructor(e, i, l, u) {
            this.min = l, this.max = u, this.points = e, this.planes = i
          }
          static fromAabb(e, i) {
            const l = [];
            for (let u = 0; u < 8; u++) l.push([1 & ~u ? e[0] : i[0], (u >> 1 & 1) == 1 ? i[1] : e[1], (u >> 2 & 1) == 1 ? i[2] : e[2]]);
            return new Go(l, [
              [-1, 0, 0, i[0]],
              [1, 0, 0, -e[0]],
              [0, -1, 0, i[1]],
              [0, 1, 0, -e[1]],
              [0, 0, -1, i[2]],
              [0, 0, 1, -e[2]]
            ], e, i)
          }
          static fromCenterSizeAngles(e, i, l) {
            const u = s.bu([], l[0], l[1], l[2]),
              p = s.bv([], [i[0], 0, 0], u),
              v = s.bv([], [0, i[1], 0], u),
              T = s.bv([], [0, 0, i[2]], u),
              S = [...e],
              k = [...e];
            for (let V = 0; V < 8; V++)
              for (let B = 0; B < 3; B++) {
                const H = e[B] + p[B] * (1 & ~V ? -1 : 1) + v[B] * ((V >> 1 & 1) == 1 ? 1 : -1) + T[B] * ((V >> 2 & 1) == 1 ? 1 : -1);
                S[B] = Math.min(S[B], H), k[B] = Math.max(k[B], H)
              }
            const L = [];
            for (let V = 0; V < 8; V++) {
              const B = [...e];
              s.aV(B, B, s.aU([], p, 1 & ~V ? -1 : 1)), s.aV(B, B, s.aU([], v, (V >> 1 & 1) == 1 ? 1 : -1)), s.aV(B, B, s.aU([], T, (V >> 2 & 1) == 1 ? 1 : -1)), L.push(B)
            }
            return new Go(L, [
              [...p, -s.a_(p, L[0])],
              [...v, -s.a_(v, L[0])],
              [...T, -s.a_(T, L[0])],
              [-p[0], -p[1], -p[2], -s.a_(p, L[7])],
              [-v[0], -v[1], -v[2], -s.a_(v, L[7])],
              [-T[0], -T[1], -T[2], -s.a_(T, L[7])]
            ], S, k)
          }
          intersectsFrustum(e) {
            let i = !0;
            const l = this.points.length,
              u = this.planes.length,
              p = e.planes.length,
              v = e.points.length;
            for (let T = 0; T < p; T++) {
              const S = e.planes[T];
              let k = 0;
              for (let L = 0; L < l; L++) {
                const V = this.points[L];
                S[0] * V[0] + S[1] * V[1] + S[2] * V[2] + S[3] >= 0 && k++
              }
              if (k === 0) return 0;
              k < l && (i = !1)
            }
            if (i) return 2;
            for (let T = 0; T < u; T++) {
              const S = this.planes[T];
              let k = 0;
              for (let L = 0; L < v; L++) {
                const V = e.points[L];
                S[0] * V[0] + S[1] * V[1] + S[2] * V[2] + S[3] >= 0 && k++
              }
              if (k === 0) return 0
            }
            return 1
          }
          intersectsPlane(e) {
            const i = this.points.length;
            let l = 0;
            for (let u = 0; u < i; u++) {
              const p = this.points[u];
              e[0] * p[0] + e[1] * p[1] + e[2] * p[2] + e[3] >= 0 && l++
            }
            return l === i ? 2 : l === 0 ? 0 : 1
          }
        }

        function ho(h, e, i) {
          const l = h - e;
          return l < 0 ? -l : Math.max(0, l - i)
        }

        function Uc(h, e, i, l, u) {
          const p = h - i;
          let v;
          return v = p < 0 ? Math.min(-p, 1 + p - u) : p > 1 ? Math.min(Math.max(p - u, 0), 1 - p) : 0, Math.max(v, ho(e, l, u))
        }
        class sf {
          constructor() {
            this._boundingVolumeCache = new nd(this._computeTileBoundingVolume)
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers()
          }
          distanceToTile2d(e, i, l, u) {
            const p = 1 << l.z,
              v = 1 / p,
              T = l.x / p,
              S = l.y / p;
            let k = 2;
            return k = Math.min(k, Uc(e, i, T, S, v)), k = Math.min(k, Uc(e, i, T + .5, -S - v, v)), k = Math.min(k, Uc(e, i, T + .5, 2 - S - v, v)), k
          }
          getWrap(e, i, l) {
            const u = 1 << i.z,
              p = 1 / u,
              v = i.x / u,
              T = ho(e.x, v, p),
              S = ho(e.x, v - 1, p),
              k = ho(e.x, v + 1, p),
              L = Math.min(T, S, k);
            return L === k ? 1 : L === S ? -1 : 0
          }
          allowVariableZoom(e, i) {
            return Mt(e, i) > 4
          }
          allowWorldCopies() {
            return !1
          }
          getTileBoundingVolume(e, i, l, u) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, i, l, u)
          }
          _computeTileBoundingVolume(e, i, l, u) {
            var p, v;
            let T = 0,
              S = 0;
            if (u != null && u.terrain) {
              const k = new s.a0(e.z, i, e.z, e.x, e.y),
                L = u.terrain.getMinMaxElevation(k);
              T = (p = L.minElevation) !== null && p !== void 0 ? p : Math.min(0, l), S = (v = L.maxElevation) !== null && v !== void 0 ? v : Math.max(0, l)
            }
            if (T /= s.bx, S /= s.bx, T += 1, S += 1, e.z <= 0) return Go.fromAabb([-S, -S, -S], [S, S, S]);
            if (e.z === 1) return Go.fromAabb([e.x === 0 ? -S : 0, e.y === 0 ? 0 : -S, -S], [e.x === 0 ? 0 : S, e.y === 0 ? S : 0, S]);
            {
              const k = [ca(0, 0, e.x, e.y, e.z), ca(s.a3, 0, e.x, e.y, e.z), ca(s.a3, s.a3, e.x, e.y, e.z), ca(0, s.a3, e.x, e.y, e.z)],
                L = [];
              for (const at of k) L.push(s.aU([], at, S));
              if (S !== T)
                for (const at of k) L.push(s.aU([], at, T));
              e.y === 0 && L.push([0, 1, 0]), e.y === (1 << e.z) - 1 && L.push([0, -1, 0]);
              const V = [1, 1, 1],
                B = [-1, -1, -1];
              for (const at of L)
                for (let ct = 0; ct < 3; ct++) V[ct] = Math.min(V[ct], at[ct]), B[ct] = Math.max(B[ct], at[ct]);
              const H = ca(s.a3 / 2, s.a3 / 2, e.x, e.y, e.z),
                re = s.aZ([], [0, 1, 0], H);
              s.aY(re, re);
              const le = s.aZ([], H, re);
              s.aY(le, le);
              const ue = s.aZ([], k[2], k[1]);
              s.aY(ue, ue);
              const de = s.aZ([], k[0], k[3]);
              s.aY(de, de), L.push(s.aU([], H, S)), e.y >= (1 << e.z) / 2 && L.push(s.aU([], ca(s.a3 / 2, 0, e.x, e.y, e.z), S)), e.y < (1 << e.z) / 2 && L.push(s.aU([], ca(s.a3 / 2, s.a3, e.x, e.y, e.z), S));
              const ve = id(H, L),
                Ae = id(le, L),
                _e = [-H[0], -H[1], -H[2], ve.max],
                ke = [H[0], H[1], H[2], -ve.min],
                Fe = [-le[0], -le[1], -le[2], Ae.max],
                xe = [le[0], le[1], le[2], -Ae.min],
                Ve = [...ue, 0],
                lt = [...de, 0],
                rt = [];
              return e.y === 0 ? rt.push(s.bw(lt, Ve, _e), s.bw(lt, Ve, ke)) : rt.push(s.bw(Fe, Ve, _e), s.bw(Fe, Ve, ke), s.bw(Fe, lt, _e), s.bw(Fe, lt, ke)), e.y === (1 << e.z) - 1 ? rt.push(s.bw(lt, Ve, _e), s.bw(lt, Ve, ke)) : rt.push(s.bw(xe, Ve, _e), s.bw(xe, Ve, ke), s.bw(xe, lt, _e), s.bw(xe, lt, ke)), new Go(rt, [_e, ke, Fe, xe, Ve, lt], V, B)
            }
          }
        }

        function id(h, e) {
          let i = 1 / 0,
            l = -1 / 0;
          for (const u of e) {
            const p = s.a_(h, u);
            i = Math.min(i, p), l = Math.max(l, p)
          }
          return {
            min: i,
            max: l
          }
        }
        class El {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, i, l) {
            return this._helper.interpolatePadding(e, i, l)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, i) {
            this._helper.resize(e, i)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e) {}
          constructor(e) {
            this._cachedClippingPlane = s.by(), this._projectionMatrix = s.bc(), this._globeViewProjMatrix32f = s.bb(), this._globeViewProjMatrixNoCorrection = s.bc(), this._globeViewProjMatrixNoCorrectionInverted = s.bc(), this._globeProjMatrixInverted = s.bc(), this._cameraPosition = s.bs(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (i, l) => {
              const u = s.ai(i.lat, -s.aj, s.aj),
                p = s.ai(+l, this.minZoom + Qn(0, u), this.maxZoom);
              return {
                center: new s.U(i.lng, u),
                zoom: p
              }
            }, this._helper = new Bn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (i, l) => this.defaultConstrain(i, l)
            }, e), this._coveringTilesDetailsProvider = new sf
          }
          clone() {
            const e = new El;
            return e.apply(this), e
          }
          apply(e, i) {
            this._globeLatitudeErrorCorrectionRadians = i || 0, this._helper.apply(e)
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted
          }
          get cameraPosition() {
            const e = s.bs();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          getProjectionData(e) {
            const {
              overscaledTileID: i,
              applyGlobeMatrix: l
            } = e, u = this._helper.getMercatorTileCoordinates(i);
            return {
              mainMatrix: this._globeViewProjMatrix32f,
              tileMercatorCoords: u,
              clippingPlane: this._cachedClippingPlane,
              projectionTransition: l ? 1 : 0,
              fallbackMatrix: this._globeViewProjMatrix32f
            }
          }
          _computeClippingPlane(e) {
            const i = this.pitchInRadians,
              l = this.cameraToCenterDistance / e,
              u = Math.sin(i) * l,
              p = Math.cos(i) * l + 1,
              v = 1 / Math.sqrt(u * u + p * p) * 1;
            let T = -u,
              S = p;
            const k = Math.sqrt(T * T + S * S);
            T /= k, S /= k;
            const L = [0, T, S];
            s.bz(L, L, [0, 0, 0], -this.bearingInRadians), s.bA(L, L, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), s.bB(L, L, [0, 0, 0], this.center.lng * Math.PI / 180);
            const V = 1 / s.b0(L);
            return s.aU(L, L, V), [...L, -v * V]
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(Ti(e))
          }
          transformLightDirection(e) {
            const i = this._helper._center.lng * Math.PI / 180,
              l = this._helper._center.lat * Math.PI / 180,
              u = Math.cos(l),
              p = [Math.sin(i) * u, Math.sin(l), Math.cos(i) * u],
              v = [p[2], 0, -p[0]],
              T = [0, 0, 0];
            s.aZ(T, v, p), s.aY(v, v), s.aY(T, T);
            const S = [0, 0, 0];
            return s.aY(S, [v[0] * e[0] + T[0] * e[1] + p[0] * e[2], v[1] * e[0] + T[1] * e[1] + p[1] * e[2], v[2] * e[0] + T[2] * e[1] + p[2] * e[2]]), S
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getPitchedTextCorrection(e, i, l) {
            const u = (function(T, S, k) {
                const L = 1 / (1 << k.z);
                return new s.a5(T / s.a3 * L + k.x * L, S / s.a3 * L + k.y * L)
              })(e, i, l.canonical),
              p = (v = u.y, [s.br(u.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - v * Math.PI * 2)) - .5 * Math.PI]);
            var v;
            return this.getCircleRadiusCorrection() / Math.cos(p[1])
          }
          projectTileCoordinates(e, i, l, u) {
            const p = l.canonical,
              v = ca(e, i, p.x, p.y, p.z),
              T = 1 + (u ? u(e, i) : 0) / s.bx,
              S = [v[0] * T, v[1] * T, v[2] * T, 1];
            s.aA(S, S, this._globeViewProjMatrixNoCorrection);
            const k = this._cachedClippingPlane,
              L = k[0] * v[0] + k[1] * v[1] + k[2] * v[2] + k[3] < 0;
            return {
              point: new s.P(S[0] / S[3], S[1] / S[3]),
              signedDistanceFromCamera: S[3],
              isOccluded: L
            }
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = Zo(this.worldSize, this.center.lat),
              i = s.bd(),
              l = s.bd();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), s.b7(i, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const u = this.centerOffset;
            i[8] = 2 * -u.x / this._helper._width, i[9] = 2 * u.y / this._helper._height, this._projectionMatrix = s.b8(i), this._globeProjMatrixInverted = s.bd(), s.au(this._globeProjMatrixInverted, i), s.N(i, i, [0, 0, -this.cameraToCenterDistance]), s.b9(i, i, this.rollInRadians), s.ba(i, i, -this.pitchInRadians), s.b9(i, i, this.bearingInRadians), s.N(i, i, [0, 0, -e]);
            const p = s.bs();
            p[0] = e, p[1] = e, p[2] = e, s.ba(l, i, this.center.lat * Math.PI / 180), s.bC(l, l, -this.center.lng * Math.PI / 180), s.O(l, l, p), this._globeViewProjMatrixNoCorrection = l, s.ba(i, i, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), s.bC(i, i, -this.center.lng * Math.PI / 180), s.O(i, i, p), this._globeViewProjMatrix32f = new Float32Array(i), this._globeViewProjMatrixNoCorrectionInverted = s.bd(), s.au(this._globeViewProjMatrixNoCorrectionInverted, l);
            const v = s.bs();
            this._cameraPosition = s.bs(), this._cameraPosition[2] = this.cameraToCenterDistance / e, s.bz(this._cameraPosition, this._cameraPosition, v, -this.rollInRadians), s.bA(this._cameraPosition, this._cameraPosition, v, this.pitchInRadians), s.bz(this._cameraPosition, this._cameraPosition, v, -this.bearingInRadians), s.aV(this._cameraPosition, this._cameraPosition, [0, 0, 1]), s.bA(this._cameraPosition, this._cameraPosition, v, -this.center.lat * Math.PI / 180), s.bB(this._cameraPosition, this._cameraPosition, v, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const T = s.b8(this._globeViewProjMatrixNoCorrectionInverted);
            s.O(T, T, [1, 1, -1]), this._cachedFrustum = ii.fromInvProjectionMatrix(T, 1, 0, this._cachedClippingPlane, !0)
          }
          calculateFogMatrix(e) {
            s.w("calculateFogMatrix is not supported on globe projection.");
            const i = s.bd();
            return s.am(i), i
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new s.b5(0, e)]
          }
          getCameraFrustum() {
            return this._cachedFrustum
          }
          getClippingPlane() {
            return this._cachedClippingPlane
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            e && s.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0)
          }
          maxPitchScaleFactor() {
            return 1
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, i) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const l = Ti(e);
            s.aU(l, l, 1 + i / s.bx);
            const u = s.by();
            return s.aA(u, [l[0], l[1], l[2], 1], this._globeViewProjMatrixNoCorrection), u[2] / u[3]
          }
          populateCache(e) {}
          getBounds() {
            const e = .5 * this.width,
              i = .5 * this.height,
              l = [new s.P(0, 0), new s.P(e, 0), new s.P(this.width, 0), new s.P(this.width, i), new s.P(this.width, this.height), new s.P(e, this.height), new s.P(0, this.height), new s.P(0, i)],
              u = [];
            for (const V of l) u.push(this.unprojectScreenPoint(V));
            let p = 0,
              v = 0,
              T = 0,
              S = 0;
            const k = this.center;
            for (const V of u) {
              const B = s.bD(k.lng, V.lng),
                H = s.bD(k.lat, V.lat);
              B < v && (v = B), B > p && (p = B), H < S && (S = H), H > T && (T = H)
            }
            const L = [k.lng + v, k.lat + S, k.lng + p, k.lat + T];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (L[3] = 90, L[0] = -180, L[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (L[1] = -90, L[0] = -180, L[2] = 180), new jt(L)
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, l, u)
          }
          setLocationAtPoint(e, i) {
            const l = Ti(this.unprojectScreenPoint(i)),
              u = Ti(e),
              p = s.bs();
            s.bE(p);
            const v = s.bs();
            s.bB(v, l, p, -this.center.lng * Math.PI / 180), s.bA(v, v, p, this.center.lat * Math.PI / 180);
            const T = u[0] * u[0] + u[2] * u[2],
              S = v[0] * v[0];
            if (T < S) return;
            const k = Math.sqrt(T - S),
              L = -k,
              V = s.bF(u[0], u[2], v[0], k),
              B = s.bF(u[0], u[2], v[0], L),
              H = s.bs();
            s.bB(H, u, p, -V);
            const re = s.bF(H[1], H[2], v[1], v[2]),
              le = s.bs();
            s.bB(le, u, p, -B);
            const ue = s.bF(le[1], le[2], v[1], v[2]),
              de = .5 * Math.PI,
              ve = re >= -de && re <= de,
              Ae = ue >= -de && ue <= de;
            let _e, ke;
            if (ve && Ae) {
              const lt = this.center.lng * Math.PI / 180,
                rt = this.center.lat * Math.PI / 180;
              s.bG(V, lt) + s.bG(re, rt) < s.bG(B, lt) + s.bG(ue, rt) ? (_e = V, ke = re) : (_e = B, ke = ue)
            } else if (ve) _e = V, ke = re;
            else {
              if (!Ae) return;
              _e = B, ke = ue
            }
            const Fe = _e / Math.PI * 180,
              xe = ke / Math.PI * 180,
              Ve = this.center.lat;
            this.setCenter(new s.U(Fe, s.ai(xe, -90, 90))), this.setZoom(this.zoom + Qn(Ve, this.center.lat))
          }
          locationToScreenPoint(e, i) {
            const l = Ti(e);
            if (i) {
              const u = i.getElevationForLngLatZoom(e, this._helper._tileZoom);
              s.aU(l, l, 1 + u / s.bx)
            }
            return this._projectSurfacePointToScreen(l)
          }
          _projectSurfacePointToScreen(e) {
            const i = s.by();
            return s.aA(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], new s.P((.5 * i[0] + .5) * this.width, (.5 * -i[1] + .5) * this.height)
          }
          screenPointToMercatorCoordinate(e, i) {
            if (i) {
              const l = i.pointCoordinate(e);
              if (l) return l
            }
            return s.a5.fromLngLat(this.unprojectScreenPoint(e))
          }
          screenPointToLocation(e, i) {
            var l;
            return (l = this.screenPointToMercatorCoordinate(e, i)) === null || l === void 0 ? void 0 : l.toLngLat()
          }
          isPointOnMapSurface(e, i) {
            const l = this._cameraPosition,
              u = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(l, u)
          }
          getRayDirectionFromPixel(e) {
            const i = s.by();
            i[0] = e.x / this.width * 2 - 1, i[1] = -1 * (e.y / this.height * 2 - 1), i[2] = 1, i[3] = 1, s.aA(i, i, this._globeViewProjMatrixNoCorrectionInverted), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3];
            const l = s.bs();
            l[0] = i[0] - this._cameraPosition[0], l[1] = i[1] - this._cameraPosition[1], l[2] = i[2] - this._cameraPosition[2];
            const u = s.bs();
            return s.aY(u, l), u
          }
          isSurfacePointVisible(e) {
            const i = this._cachedClippingPlane;
            return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] >= 0
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const i = s.by();
            return s.aA(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3], i[0] > -1 && i[0] < 1 && i[1] > -1 && i[1] < 1 && i[2] > -1 && i[2] < 1
          }
          rayPlanetIntersection(e, i) {
            const l = s.a_(e, i),
              u = s.bs(),
              p = s.bs();
            s.aU(p, i, l), s.aX(u, e, p);
            const v = 1 - s.a_(u, u);
            if (v < 0) return null;
            const T = s.a_(e, e) - 1,
              S = -l + (l < 0 ? 1 : -1) * Math.sqrt(v),
              k = T / S,
              L = S;
            return {
              tMin: Math.min(k, L),
              tMax: Math.max(k, L)
            }
          }
          unprojectScreenPoint(e) {
            const i = this._cameraPosition,
              l = this.getRayDirectionFromPixel(e),
              u = this.rayPlanetIntersection(i, l);
            if (u) {
              const L = s.bs();
              s.aV(L, i, [l[0] * u.tMin, l[1] * u.tMin, l[2] * u.tMin]);
              const V = s.bs();
              return s.aY(V, L), rd(V)
            }
            const p = this._cachedClippingPlane,
              v = p[0] * l[0] + p[1] * l[1] + p[2] * l[2],
              T = -s.b4(p, i) / v,
              S = s.bs();
            if (T > 0) s.aV(S, i, [l[0] * T, l[1] * T, l[2] * T]);
            else {
              const L = s.bs();
              s.aV(L, i, [2 * l[0], 2 * l[1], 2 * l[2]]);
              const V = s.b4(this._cachedClippingPlane, L);
              s.aX(S, L, [this._cachedClippingPlane[0] * V, this._cachedClippingPlane[1] * V, this._cachedClippingPlane[2] * V])
            }
            const k = (function(L) {
              const V = s.bs();
              return V[0] = L[0] * -L[3], V[1] = L[1] * -L[3], V[2] = L[2] * -L[3], {
                center: V,
                radius: Math.sqrt(1 - L[3] * L[3])
              }
            })(p);
            return rd((function(L, V, B) {
              const H = s.bs();
              s.aX(H, B, L);
              const re = s.bs();
              return s.bt(re, L, H, V / s.b2(H)), re
            })(k.center, k.radius, S))
          }
          getMatrixForModel(e, i) {
            const l = s.U.convert(e),
              u = 1 / s.bx,
              p = s.bc();
            return s.bC(p, p, l.lng / 180 * Math.PI), s.ba(p, p, -l.lat / 180 * Math.PI), s.N(p, p, [0, 0, 1 + i / s.bx]), s.ba(p, p, .5 * Math.PI), s.O(p, p, [u, u, u]), p
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = this.getProjectionData({
              overscaledTileID: new s.a0(0, 0, 0, 0, 0),
              applyGlobeMatrix: e
            });
            return i.tileMercatorCoords = [0, 0, 1, 1], i
          }
          getFastPathSimpleProjectionMatrix(e) {}
        }
        class Ll {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, i, l) {
            return this._helper.interpolatePadding(e, i, l)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, i, l = !0) {
            this._helper.resize(e, i, l)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          get isGlobeRendering() {
            return this._globeness > 0
          }
          setTransitionState(e, i) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = i, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
          }
          constructor(e) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (i, l) => this.currentTransform.defaultConstrain(i, l), this._helper = new Bn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (i, l) => this.defaultConstrain(i, l)
            }, e), this._globeness = 1, this._mercatorTransform = new Kn, this._verticalPerspectiveTransform = new El
          }
          clone() {
            const e = new Ll;
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition
          }
          getProjectionData(e) {
            const i = this._mercatorTransform.getProjectionData(e),
              l = this._verticalPerspectiveTransform.getProjectionData(e);
            return {
              mainMatrix: this.isGlobeRendering ? l.mainMatrix : i.mainMatrix,
              clippingPlane: l.clippingPlane,
              tileMercatorCoords: l.tileMercatorCoords,
              projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
              fallbackMatrix: i.fallbackMatrix
            }
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e)
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e)
          }
          getPixelScale() {
            return s.bn(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
          }
          getCircleRadiusCorrection() {
            return s.bn(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
          }
          getPitchedTextCorrection(e, i, l) {
            const u = this._mercatorTransform.getPitchedTextCorrection(e, i, l),
              p = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, i, l);
            return s.bn(u, p, this._globeness)
          }
          projectTileCoordinates(e, i, l, u) {
            return this.currentTransform.projectTileCoordinates(e, i, l, u)
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ)
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e)
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e)
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum()
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane()
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider()
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor()
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, i) {
            return this.currentTransform.lngLatToCameraDepth(e, i)
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e)
          }
          getBounds() {
            return this.currentTransform.getBounds()
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, l, u)
          }
          setLocationAtPoint(e, i) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, i), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, i), this.apply(this._verticalPerspectiveTransform)
          }
          locationToScreenPoint(e, i) {
            return this.currentTransform.locationToScreenPoint(e, i)
          }
          screenPointToMercatorCoordinate(e, i) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, i)
          }
          screenPointToLocation(e, i) {
            return this.currentTransform.screenPointToLocation(e, i)
          }
          isPointOnMapSurface(e, i) {
            return this.currentTransform.isPointOnMapSurface(e, i)
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
          }
          getMatrixForModel(e, i) {
            return this.currentTransform.getMatrixForModel(e, i)
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return i;
            const l = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return l.fallbackMatrix = i.mainMatrix, l
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
          }
        }
        class Ua {
          get useGlobeControls() {
            return !0
          }
          handlePanInertia(e, i) {
            const l = kl(e, i);
            return Math.abs(l.lng - i.center.lng) > 180 && (l.lng = i.center.lng + 179.5 * Math.sign(l.lng - i.center.lng)), {
              easingCenter: l,
              easingOffset: new s.P(0, 0)
            }
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            const l = e.around,
              u = i.screenPointToLocation(l);
            e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta);
            const p = i.zoom;
            e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
            const v = i.zoom - p;
            if (v === 0) return;
            const T = s.bD(i.center.lng, u.lng),
              S = T / (Math.abs(T / 180) + 1),
              k = s.bD(i.center.lat, u.lat),
              L = i.getRayDirectionFromPixel(l),
              V = i.cameraPosition,
              B = -1 * s.a_(V, L),
              H = s.bs();
            s.aV(H, V, [L[0] * B, L[1] * B, L[2] * B]);
            const re = s.b0(H) - 1,
              le = Math.exp(.5 * -Math.max(re - .3, 0)),
              ue = Zo(i.worldSize, i.center.lat) / Math.min(i.width, i.height),
              de = s.bq(ue, .9, .5, 1, .25),
              ve = (1 - s.al(-v)) * Math.min(le, de),
              Ae = i.center.lat,
              _e = i.zoom,
              ke = new s.U(i.center.lng + S * ve, s.ai(i.center.lat + k * ve, -s.aj, s.aj));
            i.setLocationAtPoint(u, l);
            const Fe = i.center,
              xe = s.bq(Math.abs(T), 45, 85, 0, 1),
              Ve = s.bq(ue, .75, .35, 0, 1),
              lt = Math.pow(Math.max(xe, Ve), .25),
              rt = s.bD(Fe.lng, ke.lng),
              at = s.bD(Fe.lat, ke.lat);
            i.setCenter(new s.U(Fe.lng + rt * lt, Fe.lat + at * lt).wrap()), i.setZoom(_e + Qn(Ae, i.center.lat))
          }
          handleMapControlsPan(e, i, l) {
            if (!e.panDelta) return;
            const u = i.center.lat,
              p = i.zoom;
            i.setCenter(kl(e.panDelta, i).wrap()), i.setZoom(p + Qn(u, i.center.lat))
          }
          cameraForBoxAndBearing(e, i, l, u, p) {
            const v = ta(e, i, l, u, p),
              T = i.left / p.width * 2 - 1,
              S = (p.width - i.right) / p.width * 2 - 1,
              k = i.top / p.height * -2 + 1,
              L = (p.height - i.bottom) / p.height * -2 + 1,
              V = s.bD(l.getWest(), l.getEast()) < 0,
              B = V ? l.getEast() : l.getWest(),
              H = V ? l.getWest() : l.getEast(),
              re = Math.max(l.getNorth(), l.getSouth()),
              le = Math.min(l.getNorth(), l.getSouth()),
              ue = B + .5 * s.bD(B, H),
              de = re + .5 * s.bD(re, le),
              ve = p.clone();
            ve.setCenter(v.center), ve.setBearing(v.bearing), ve.setPitch(0), ve.setRoll(0), ve.setZoom(v.zoom);
            const Ae = ve.modelViewProjectionMatrix,
              _e = [Ti(l.getNorthWest()), Ti(l.getNorthEast()), Ti(l.getSouthWest()), Ti(l.getSouthEast()), Ti(new s.U(H, de)), Ti(new s.U(B, de)), Ti(new s.U(ue, re)), Ti(new s.U(ue, le))],
              ke = Ti(v.center);
            let Fe = Number.POSITIVE_INFINITY;
            for (const xe of _e) T < 0 && (Fe = Ua.getLesserNonNegativeNonNull(Fe, Ua.solveVectorScale(xe, ke, Ae, "x", T))), S > 0 && (Fe = Ua.getLesserNonNegativeNonNull(Fe, Ua.solveVectorScale(xe, ke, Ae, "x", S))), k > 0 && (Fe = Ua.getLesserNonNegativeNonNull(Fe, Ua.solveVectorScale(xe, ke, Ae, "y", k))), L < 0 && (Fe = Ua.getLesserNonNegativeNonNull(Fe, Ua.solveVectorScale(xe, ke, Ae, "y", L)));
            if (Number.isFinite(Fe) && Fe !== 0) return v.zoom = ve.zoom + s.ao(Fe), v;
            Vn()
          }
          handleJumpToCenterZoom(e, i) {
            const l = e.center.lat,
              u = e.constrain(i.center ? s.U.convert(i.center) : e.center, e.zoom).center;
            e.setCenter(u.wrap());
            const p = i.zoom !== void 0 ? +i.zoom : e.zoom + Qn(l, u.lat);
            e.zoom !== p && e.setZoom(p)
          }
          handleEaseTo(e, i) {
            const l = e.zoom,
              u = e.center,
              p = e.padding,
              v = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              T = {
                roll: i.roll === void 0 ? e.roll : i.roll,
                pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                bearing: i.bearing === void 0 ? e.bearing : i.bearing
              },
              S = i.zoom !== void 0,
              k = !e.isPaddingEqual(i.padding);
            let L = !1;
            const V = i.center ? s.U.convert(i.center) : u,
              B = e.constrain(V, l).center;
            Qr(e, B);
            const H = e.clone();
            H.setCenter(B), H.setZoom(S ? +i.zoom : l + Qn(u.lat, V.lat)), H.setBearing(i.bearing);
            const re = new s.P(s.ai(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), s.ai(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
            H.setLocationAtPoint(B, re);
            const le = (i.offset && i.offsetAsPoint.mag()) > 0 ? H.center : B,
              ue = S ? +i.zoom : l + Qn(u.lat, le.lat),
              de = l + Qn(u.lat, 0),
              ve = ue + Qn(le.lat, 0),
              Ae = s.bD(u.lng, le.lng),
              _e = s.bD(u.lat, le.lat),
              ke = s.al(ve - de);
            return L = ue !== l, {
              easeFunc: Fe => {
                if (s.bh(v, T) || ga({
                    startEulerAngles: v,
                    endEulerAngles: T,
                    tr: e,
                    k: Fe,
                    useSlerp: v.roll != T.roll
                  }), k && e.interpolatePadding(p, i.padding, Fe), i.around) s.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(i.around, i.aroundPoint);
                else {
                  const xe = ve > de ? Math.min(2, ke) : Math.max(.5, ke),
                    Ve = Math.pow(xe, 1 - Fe),
                    lt = Ws(u, Ae, _e, Fe * Ve);
                  e.setCenter(lt.wrap())
                }
                if (L) {
                  const xe = s.F.number(de, ve, Fe) + Qn(0, e.center.lat);
                  e.setZoom(xe)
                }
              },
              isZooming: L,
              elevationCenter: le
            }
          }
          handleFlyTo(e, i) {
            const l = i.zoom !== void 0,
              u = e.center,
              p = e.zoom,
              v = e.padding,
              T = !e.isPaddingEqual(i.padding),
              S = e.constrain(s.U.convert(i.center || i.locationAtOffset), p).center,
              k = l ? +i.zoom : e.zoom + Qn(e.center.lat, S.lat),
              L = e.clone();
            L.setCenter(S), L.setZoom(k), L.setBearing(i.bearing);
            const V = new s.P(s.ai(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), s.ai(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
            L.setLocationAtPoint(S, V);
            const B = L.center;
            Qr(e, B);
            const H = (function(_e, ke, Fe) {
                const xe = Ti(ke),
                  Ve = Ti(Fe),
                  lt = s.a_(xe, Ve),
                  rt = Math.acos(lt),
                  at = eo(_e);
                return rt / (2 * Math.PI) * at
              })(e, u, B),
              re = p + Qn(u.lat, 0),
              le = k + Qn(B.lat, 0),
              ue = s.al(le - re);
            let de;
            if (typeof i.minZoom == "number") {
              const _e = +i.minZoom + Qn(B.lat, 0),
                ke = Math.min(_e, re, le) + Qn(0, B.lat),
                Fe = e.constrain(B, ke).zoom + Qn(B.lat, 0);
              de = s.al(Fe - re)
            }
            const ve = s.bD(u.lng, B.lng),
              Ae = s.bD(u.lat, B.lat);
            return {
              easeFunc: (_e, ke, Fe, xe) => {
                const Ve = Ws(u, ve, Ae, Fe);
                T && e.interpolatePadding(v, i.padding, _e);
                const lt = _e === 1 ? B : Ve;
                e.setCenter(lt.wrap());
                const rt = re + s.ao(ke);
                e.setZoom(_e === 1 ? k : rt + Qn(0, lt.lat))
              },
              scaleOfZoom: ue,
              targetCenter: B,
              scaleOfMinZoom: de,
              pixelPathLength: H
            }
          }
          static solveVectorScale(e, i, l, u, p) {
            const v = u === "x" ? [l[0], l[4], l[8], l[12]] : [l[1], l[5], l[9], l[13]],
              T = [l[3], l[7], l[11], l[15]],
              S = e[0] * v[0] + e[1] * v[1] + e[2] * v[2],
              k = e[0] * T[0] + e[1] * T[1] + e[2] * T[2],
              L = i[0] * v[0] + i[1] * v[1] + i[2] * v[2],
              V = i[0] * T[0] + i[1] * T[1] + i[2] * T[2];
            return L + p * k === S + p * V || T[3] * (S - L) + v[3] * (V - k) + S * V == L * k ? null : (L + v[3] - p * V - p * T[3]) / (L - S - p * V + p * k)
          }
          static getLesserNonNegativeNonNull(e, i) {
            return i !== null && i >= 0 && i < e ? i : e
          }
        }
        class $s {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new Fi, this._verticalPerspectiveCameraHelper = new Ua
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
          }
          handlePanInertia(e, i) {
            return this.currentHelper.handlePanInertia(e, i)
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, i)
          }
          handleMapControlsPan(e, i, l) {
            this.currentHelper.handleMapControlsPan(e, i, l)
          }
          cameraForBoxAndBearing(e, i, l, u, p) {
            return this.currentHelper.cameraForBoxAndBearing(e, i, l, u, p)
          }
          handleJumpToCenterZoom(e, i) {
            this.currentHelper.handleJumpToCenterZoom(e, i)
          }
          handleEaseTo(e, i) {
            return this.currentHelper.handleEaseTo(e, i)
          }
          handleFlyTo(e, i) {
            return this.currentHelper.handleFlyTo(e, i)
          }
        }
        const Ts = (h, e) => s.z(h, e && e.filter((i => i.identifier !== "source.canvas"))),
          zl = s.bH();
        class Xs extends s.E {
          constructor(e, i = {}) {
            var l, u;
            super(), this._rtlPluginLoaded = () => {
              for (const v in this.tileManagers) {
                const T = this.tileManagers[v].getSource().type;
                T !== "vector" && T !== "geojson" || this.tileManagers[v].reload()
              }
            }, this.map = e, this.dispatcher = new It(ht(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((v, T) => this.getGlyphs(v, T))), this.dispatcher.registerMessageHandler("GI", ((v, T) => this.getImages(v, T))), this.dispatcher.registerMessageHandler("GDA", ((v, T) => this.getDashes(v, T))), this.imageManager = new it, this.imageManager.setEventedParent(this);
            const p = ((l = e._container) === null || l === void 0 ? void 0 : l.lang) || typeof document < "u" && ((u = document.documentElement) === null || u === void 0 ? void 0 : u.lang) || void 0;
            this.glyphManager = new Ut(e._requestManager, i.localIdeographFontFamily, p), this.lineAtlas = new Rt(256, 512), this.crossTileSymbolIndex = new vr, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new s.bI, this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", s.bJ()), D().on(Le, this._rtlPluginLoaded), this.on("data", (v => {
              if (v.dataType !== "source" || v.sourceDataType !== "metadata") return;
              const T = this.tileManagers[v.sourceId];
              if (!T) return;
              const S = T.getSource();
              if (S && S.vectorLayerIds)
                for (const k in this._layers) {
                  const L = this._layers[k];
                  L.source === S.id && this._validateLayer(L)
                }
            }))
          }
          setGlobalStateProperty(e, i) {
            var l, u, p;
            this._checkLoaded();
            const v = i === null ? (p = (u = (l = this.stylesheet.state) === null || l === void 0 ? void 0 : l[e]) === null || u === void 0 ? void 0 : u.default) !== null && p !== void 0 ? p : null : i;
            if (s.bK(v, this._globalState[e])) return this;
            this._globalState[e] = v, this._applyGlobalStateChanges([e])
          }
          getGlobalState() {
            return this._globalState
          }
          setGlobalState(e) {
            this._checkLoaded();
            const i = [];
            for (const l in e) !s.bK(this._globalState[l], e[l].default) && (i.push(l), this._globalState[l] = e[l].default);
            this._applyGlobalStateChanges(i)
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const i = new Set,
              l = {};
            for (const u of e) {
              l[u] = this._globalState[u];
              for (const p in this._layers) {
                const v = this._layers[p],
                  T = v.getLayoutAffectingGlobalStateRefs(),
                  S = v.getPaintAffectingGlobalStateRefs();
                if (T.has(u) && i.add(v.source), S.has(u))
                  for (const {
                      name: k,
                      value: L
                    }
                    of S.get(u)) this._updatePaintProperty(v, k, L)
              }
            }
            this.dispatcher.broadcast("UGS", l);
            for (const u in this.tileManagers) i.has(u) && (this._reloadSource(u), this._changed = !0)
          }
          loadURL(e, i = {}, l) {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), i.validate = typeof i.validate != "boolean" || i.validate;
            const u = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController;
            const p = this._loadStyleRequest;
            s.j(u, this._loadStyleRequest).then((v => {
              this._loadStyleRequest = null, this._load(v.data, i, l)
            })).catch((v => {
              this._loadStyleRequest = null, v && !p.signal.aborted && this.fire(new s.k(v))
            }))
          }
          loadJSON(e, i = {}, l) {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), this._frameRequest = new AbortController, ae.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, i.validate = i.validate !== !1, this._load(e, i, l)
            })).catch((() => {}))
          }
          loadEmpty() {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), this._load(zl, {
              validate: !1
            })
          }
          _load(e, i, l) {
            var u, p;
            let v = i.transformStyle ? i.transformStyle(l, e) : e;
            if (!i.validate || !Ts(this, s.B(v))) {
              v = Object.assign({}, v), this._loaded = !0, this.stylesheet = v;
              for (const T in v.sources) this.addSource(T, v.sources[T], {
                validate: !1
              });
              v.sprite ? this._loadSprite(v.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(v.glyphs), this._createLayers(), this.light = new Je(this.stylesheet.light), this._setProjectionInternal(((u = this.stylesheet.projection) === null || u === void 0 ? void 0 : u.type) || "mercator"), this.sky = new bt(this.stylesheet.sky), this.map.setTerrain((p = this.stylesheet.terrain) !== null && p !== void 0 ? p : null), this.fire(new s.l("data", {
                dataType: "style"
              })), this.fire(new s.l("style.load"))
            }
          }
          _createLayers() {
            var e, i, l;
            const u = s.bL(this.stylesheet.layers);
            this.setGlobalState((e = this.stylesheet.state) !== null && e !== void 0 ? e : null), this.dispatcher.broadcast("SL", u), this._order = u.map((p => p.id)), this._layers = {}, this._serializedLayers = null;
            for (const p of u) {
              const v = s.bM(p, this._globalState);
              if (v.setEventedParent(this, {
                  layer: {
                    id: p.id
                  }
                }), this._layers[p.id] = v, s.bN(v) && this.tileManagers[v.source]) {
                const T = (l = (i = p.paint) === null || i === void 0 ? void 0 : i["raster-fade-duration"]) !== null && l !== void 0 ? l : v.paint.get("raster-fade-duration");
                this.tileManagers[v.source].setRasterFadeDuration(T)
              }
            }
          }
          _loadSprite(e, i = !1, l = void 0) {
            let u;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController, (function(p, v, T, S) {
              return s._(this, void 0, void 0, (function*() {
                const k = Be(p),
                  L = T > 1 ? "@2x" : "",
                  V = {},
                  B = {};
                for (const {
                    id: H,
                    url: re
                  }
                  of k) {
                  const le = v.transformRequest(He(re, L, ".json"), "SpriteJSON");
                  V[H] = s.j(le, S);
                  const ue = v.transformRequest(He(re, L, ".png"), "SpriteImage");
                  B[H] = Ye.getImage(ue, S)
                }
                return yield Promise.all([...Object.values(V), ...Object.values(B)]), (function(H, re) {
                  return s._(this, void 0, void 0, (function*() {
                    const le = {};
                    for (const ue in H) {
                      le[ue] = {};
                      const de = ae.getImageCanvasContext((yield re[ue]).data),
                        ve = (yield H[ue]).data;
                      for (const Ae in ve) {
                        const {
                          width: _e,
                          height: ke,
                          x: Fe,
                          y: xe,
                          sdf: Ve,
                          pixelRatio: lt,
                          stretchX: rt,
                          stretchY: at,
                          content: ct,
                          textFitWidth: er,
                          textFitHeight: rr
                        } = ve[Ae];
                        le[ue][Ae] = {
                          data: null,
                          pixelRatio: lt,
                          sdf: Ve,
                          stretchX: rt,
                          stretchY: at,
                          content: ct,
                          textFitWidth: er,
                          textFitHeight: rr,
                          spriteData: {
                            width: _e,
                            height: ke,
                            x: Fe,
                            y: xe,
                            context: de
                          }
                        }
                      }
                    }
                    return le
                  }))
                })(V, B)
              }))
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((p => {
              if (this._spriteRequest = null, p)
                for (const v in p) {
                  this._spritesImagesIds[v] = [];
                  const T = this._spritesImagesIds[v] ? this._spritesImagesIds[v].filter((S => !(S in p))) : [];
                  for (const S of T) this.imageManager.removeImage(S), this._changedImages[S] = !0;
                  for (const S in p[v]) {
                    const k = v === "default" ? S : `${v}:${S}`;
                    this._spritesImagesIds[v].push(k), k in this.imageManager.images ? this.imageManager.updateImage(k, p[v][S], !1) : this.imageManager.addImage(k, p[v][S]), i && (this._changedImages[k] = !0)
                  }
                }
            })).catch((p => {
              this._spriteRequest = null, u = p, this.fire(new s.k(u))
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), i && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
                dataType: "style"
              })), l && l(u)
            }))
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          _validateLayer(e) {
            const i = this.tileManagers[e.source];
            if (!i) return;
            const l = e.sourceLayer;
            if (!l) return;
            const u = i.getSource();
            (u.type === "geojson" || u.vectorLayerIds && u.vectorLayerIds.indexOf(l) === -1) && this.fire(new s.k(new Error(`Source layer "${l}" does not exist on source "${u.id}" as specified by style layer "${e.id}".`)))
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.tileManagers)
              if (!this.tileManagers[e].loaded()) return !1;
            return !!this.imageManager.isLoaded()
          }
          _serializeByIds(e, i = !1) {
            const l = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(i ? s.bO(l) : l);
            const u = [];
            for (const p of e)
              if (l[p]) {
                const v = i ? s.bO(l[p]) : l[p];
                u.push(v)
              } return u
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const i = Object.keys(this._layers);
            for (const l of i) {
              const u = this._layers[l];
              u.type !== "custom" && (e[l] = u.serialize())
            }
            return e
          }
          hasTransitions() {
            var e, i, l;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((i = this.sky) === null || i === void 0) && i.hasTransition() || !((l = this.projection) === null || l === void 0) && l.hasTransition()) return !0;
            for (const u in this.tileManagers)
              if (this.tileManagers[u].hasTransition()) return !0;
            for (const u in this._layers)
              if (this._layers[u].hasTransition()) return !0;
            return !1
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.")
          }
          update(e) {
            if (!this._loaded) return;
            const i = this._changed;
            if (i) {
              const u = Object.keys(this._updatedLayers),
                p = Object.keys(this._removedLayers);
              (u.length || p.length) && this._updateWorkerLayers(u, p);
              for (const v in this._updatedSources) {
                const T = this._updatedSources[v];
                if (T === "reload") this._reloadSource(v);
                else {
                  if (T !== "clear") throw new Error(`Invalid action ${T}`);
                  this._clearSource(v)
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const v in this._updatedPaintProps) this._layers[v].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates()
            }
            const l = {};
            for (const u in this.tileManagers) {
              const p = this.tileManagers[u];
              l[u] = p.used, p.used = !1
            }
            for (const u of this._order) {
              const p = this._layers[u];
              p.recalculate(e, this._availableImages), !p.isHidden(e.zoom) && p.source && (this.tileManagers[p.source].used = !0)
            }
            for (const u in l) {
              const p = this.tileManagers[u];
              !!l[u] != !!p.used && p.fire(new s.l("data", {
                sourceDataType: "visibility",
                dataType: "source",
                sourceId: u
              }))
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, i && this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const i in this.tileManagers) this.tileManagers[i].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {}
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.tileManagers) this.tileManagers[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1
            }
          }
          _updateWorkerLayers(e, i) {
            this.dispatcher.broadcast("UL", {
              layers: this._serializeByIds(e, !1),
              removedIds: i
            })
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1
          }
          setState(e, i = {}) {
            var l;
            this._checkLoaded();
            const u = this.serialize();
            if (e = i.transformStyle ? i.transformStyle(u, e) : e, ((l = i.validate) === null || l === void 0 || l) && Ts(this, s.B(e))) return !1;
            (e = s.bO(e)).layers = s.bL(e.layers);
            const p = s.bP(u, e),
              v = this._getOperationsToPerform(p);
            if (v.unimplemented.length > 0) throw new Error(`Unimplemented: ${v.unimplemented.join(", ")}.`);
            if (v.operations.length === 0) return !1;
            for (const T of v.operations) T();
            return this.stylesheet = e, this._serializedLayers = null, !0
          }
          _getOperationsToPerform(e) {
            const i = [],
              l = [];
            for (const u of e) switch (u.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                i.push((() => this.addLayer.apply(this, u.args)));
                break;
              case "removeLayer":
                i.push((() => this.removeLayer.apply(this, u.args)));
                break;
              case "setPaintProperty":
                i.push((() => this.setPaintProperty.apply(this, u.args)));
                break;
              case "setLayoutProperty":
                i.push((() => this.setLayoutProperty.apply(this, u.args)));
                break;
              case "setFilter":
                i.push((() => this.setFilter.apply(this, u.args)));
                break;
              case "addSource":
                i.push((() => this.addSource.apply(this, u.args)));
                break;
              case "removeSource":
                i.push((() => this.removeSource.apply(this, u.args)));
                break;
              case "setLayerZoomRange":
                i.push((() => this.setLayerZoomRange.apply(this, u.args)));
                break;
              case "setLight":
                i.push((() => this.setLight.apply(this, u.args)));
                break;
              case "setGeoJSONSourceData":
                i.push((() => this.setGeoJSONSourceData.apply(this, u.args)));
                break;
              case "setGlyphs":
                i.push((() => this.setGlyphs.apply(this, u.args)));
                break;
              case "setSprite":
                i.push((() => this.setSprite.apply(this, u.args)));
                break;
              case "setTerrain":
                i.push((() => this.map.setTerrain.apply(this, u.args)));
                break;
              case "setSky":
                i.push((() => this.setSky.apply(this, u.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, u.args);
                break;
              case "setGlobalState":
                i.push((() => this.setGlobalState.apply(this, u.args)));
                break;
              case "setTransition":
                i.push((() => {}));
                break;
              default:
                l.push(u.command)
            }
            return {
              operations: i,
              unimplemented: l
            }
          }
          addImage(e, i) {
            if (this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, i), this._afterImageUpdated(e)
          }
          updateImage(e, i) {
            this.imageManager.updateImage(e, i)
          }
          getImage(e) {
            return this.imageManager.getImage(e)
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e)
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages()
          }
          addSource(e, i, l = {}) {
            if (this._checkLoaded(), this.tileManagers[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(s.B.source, `sources.${e}`, i, null, l)) return;
            this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
            const u = this.tileManagers[e] = new Kt(e, i, this.dispatcher);
            u.style = this, u.setEventedParent(this, (() => ({
              isSourceLoaded: u.loaded(),
              source: u.serialize(),
              sourceId: e
            }))), u.onAdd(this.map), this._changed = !0
          }
          removeSource(e) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error("There is no source with this ID");
            for (const l in this._layers)
              if (this._layers[l].source === e) return this.fire(new s.k(new Error(`Source "${e}" cannot be removed while layer "${l}" is using it.`)));
            const i = this.tileManagers[e];
            delete this.tileManagers[e], delete this._updatedSources[e], i.fire(new s.l("data", {
              sourceDataType: "metadata",
              dataType: "source",
              sourceId: e
            })), i.setEventedParent(null), i.onRemove(this.map), this._changed = !0
          }
          setGeoJSONSourceData(e, i) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const l = this.tileManagers[e].getSource();
            if (l.type !== "geojson") throw new Error(`geojsonSource.type is ${l.type}, which is !== 'geojson`);
            l.setData(i), this._changed = !0
          }
          getSource(e) {
            return this.tileManagers[e] && this.tileManagers[e].getSource()
          }
          addLayer(e, i, l = {}) {
            this._checkLoaded();
            const u = e.id;
            if (this.getLayer(u)) return void this.fire(new s.k(new Error(`Layer "${u}" already exists on this map.`)));
            let p;
            if (e.type === "custom") {
              if (Ts(this, s.bQ(e))) return;
              p = s.bM(e, this._globalState)
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(u, e.source), e = s.bO(e), e = s.e(e, {
                  source: u
                })), this._validate(s.B.layer, `layers.${u}`, e, {
                  arrayIndex: -1
                }, l)) return;
              p = s.bM(e, this._globalState), this._validateLayer(p), p.setEventedParent(this, {
                layer: {
                  id: u
                }
              })
            }
            const v = i ? this._order.indexOf(i) : this._order.length;
            if (i && v === -1) this.fire(new s.k(new Error(`Cannot add layer "${u}" before non-existing layer "${i}".`)));
            else {
              if (this._order.splice(v, 0, u), this._layerOrderChanged = !0, this._layers[u] = p, this._removedLayers[u] && p.source && p.type !== "custom") {
                const T = this._removedLayers[u];
                delete this._removedLayers[u], T.type !== p.type ? this._updatedSources[p.source] = "clear" : (this._updatedSources[p.source] = "reload", this.tileManagers[p.source].pause())
              }
              this._updateLayer(p), p.onAdd && p.onAdd(this.map)
            }
          }
          moveLayer(e, i) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new s.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === i) return;
            const l = this._order.indexOf(e);
            this._order.splice(l, 1);
            const u = i ? this._order.indexOf(i) : this._order.length;
            i && u === -1 ? this.fire(new s.k(new Error(`Cannot move layer "${e}" before non-existing layer "${i}".`))) : (this._order.splice(u, 0, e), this._layerOrderChanged = !0)
          }
          removeLayer(e) {
            this._checkLoaded();
            const i = this._layers[e];
            if (!i) return void this.fire(new s.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            i.setEventedParent(null);
            const l = this._order.indexOf(e);
            this._order.splice(l, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = i, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], i.onRemove && i.onRemove(this.map)
          }
          getLayer(e) {
            return this._layers[e]
          }
          getLayersOrder() {
            return [...this._order]
          }
          hasLayer(e) {
            return e in this._layers
          }
          setLayerZoomRange(e, i, l) {
            this._checkLoaded();
            const u = this.getLayer(e);
            u ? u.minzoom === i && u.maxzoom === l || (i != null && (u.minzoom = i), l != null && (u.maxzoom = l), this._updateLayer(u)) : this.fire(new s.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
          }
          setFilter(e, i, l = {}) {
            this._checkLoaded();
            const u = this.getLayer(e);
            if (u) {
              if (!s.bK(u.filter, i)) return i == null ? (u.setFilter(void 0), void this._updateLayer(u)) : void(this._validate(s.B.filter, `layers.${u.id}.filter`, i, null, l) || (u.setFilter(s.bO(i)), this._updateLayer(u)))
            } else this.fire(new s.k(new Error(`Cannot filter non-existing layer "${e}".`)))
          }
          getFilter(e) {
            return s.bO(this.getLayer(e).filter)
          }
          setLayoutProperty(e, i, l, u = {}) {
            this._checkLoaded();
            const p = this.getLayer(e);
            p ? s.bK(p.getLayoutProperty(i), l) || (p.setLayoutProperty(i, l, u), this._updateLayer(p)) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getLayoutProperty(e, i) {
            const l = this.getLayer(e);
            if (l) return l.getLayoutProperty(i);
            this.fire(new s.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
          }
          setPaintProperty(e, i, l, u = {}) {
            this._checkLoaded();
            const p = this.getLayer(e);
            p ? s.bK(p.getPaintProperty(i), l) || this._updatePaintProperty(p, i, l, u) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          _updatePaintProperty(e, i, l, u = {}) {
            e.setPaintProperty(i, l, u) && this._updateLayer(e), s.bN(e) && i === "raster-fade-duration" && this.tileManagers[e.source].setRasterFadeDuration(l), this._changed = !0, this._updatedPaintProps[e.id] = !0, this._serializedLayers = null
          }
          getPaintProperty(e, i) {
            return this.getLayer(e).getPaintProperty(i)
          }
          setFeatureState(e, i) {
            this._checkLoaded();
            const l = e.source,
              u = e.sourceLayer,
              p = this.tileManagers[l];
            if (p === void 0) return void this.fire(new s.k(new Error(`The source '${l}' does not exist in the map's style.`)));
            const v = p.getSource().type;
            v === "geojson" && u ? this.fire(new s.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : v !== "vector" || u ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), p.setFeatureState(u, e.id, i)) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          removeFeatureState(e, i) {
            this._checkLoaded();
            const l = e.source,
              u = this.tileManagers[l];
            if (u === void 0) return void this.fire(new s.k(new Error(`The source '${l}' does not exist in the map's style.`)));
            const p = u.getSource().type,
              v = p === "vector" ? e.sourceLayer : void 0;
            p !== "vector" || v ? i && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new s.k(new Error("A feature id is required to remove its specific state property."))) : u.removeFeatureState(v, e.id, i) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          getFeatureState(e) {
            this._checkLoaded();
            const i = e.source,
              l = e.sourceLayer,
              u = this.tileManagers[i];
            if (u !== void 0) return u.getSource().type !== "vector" || l ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), u.getFeatureState(l, e.id)) : void this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new s.k(new Error(`The source '${i}' does not exist in the map's style.`)))
          }
          getTransition() {
            return s.e({
              duration: 300,
              delay: 0
            }, this.stylesheet && this.stylesheet.transition)
          }
          serialize() {
            if (!this._loaded) return;
            const e = s.bR(this.tileManagers, (p => p.serialize())),
              i = this._serializeByIds(this._order, !0),
              l = this.map.getTerrain() || void 0,
              u = this.stylesheet;
            return s.bS({
              version: u.version,
              name: u.name,
              metadata: u.metadata,
              light: u.light,
              sky: u.sky,
              center: u.center,
              zoom: u.zoom,
              bearing: u.bearing,
              pitch: u.pitch,
              sprite: u.sprite,
              glyphs: u.glyphs,
              transition: u.transition,
              projection: u.projection,
              sources: e,
              layers: i,
              terrain: l
            }, (p => p !== void 0))
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.tileManagers[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.tileManagers[e.source].pause()), this._serializedLayers = null, this._changed = !0
          }
          _flattenAndSortRenderedFeatures(e) {
            const i = v => this._layers[v].type === "fill-extrusion",
              l = {},
              u = [];
            for (let v = this._order.length - 1; v >= 0; v--) {
              const T = this._order[v];
              if (i(T)) {
                l[T] = v;
                for (const S of e) {
                  const k = S[T];
                  if (k)
                    for (const L of k) u.push(L)
                }
              }
            }
            u.sort(((v, T) => T.intersectionZ - v.intersectionZ));
            const p = [];
            for (let v = this._order.length - 1; v >= 0; v--) {
              const T = this._order[v];
              if (i(T))
                for (let S = u.length - 1; S >= 0; S--) {
                  const k = u[S].feature;
                  if (l[k.layer.id] < v) break;
                  p.push(k), u.pop()
                } else
                  for (const S of e) {
                    const k = S[T];
                    if (k)
                      for (const L of k) p.push(L.feature)
                  }
            }
            return p
          }
          queryRenderedFeatures(e, i, l) {
            i && i.filter && this._validate(s.B.filter, "queryRenderedFeatures.filter", i.filter, null, i);
            const u = {};
            if (i && i.layers) {
              if (!(Array.isArray(i.layers) || i.layers instanceof Set)) return this.fire(new s.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const k of i.layers) {
                const L = this._layers[k];
                if (!L) return this.fire(new s.k(new Error(`The layer '${k}' does not exist in the map's style and cannot be queried for features.`))), [];
                u[L.source] = !0
              }
            }
            const p = [];
            i.availableImages = this._availableImages;
            const v = this._serializedAllLayers(),
              T = i.layers instanceof Set ? i.layers : Array.isArray(i.layers) ? new Set(i.layers) : null,
              S = Object.assign(Object.assign({}, i), {
                layers: T,
                globalState: this._globalState
              });
            for (const k in this.tileManagers) i.layers && !u[k] || p.push(Ht(this.tileManagers[k], this._layers, v, e, S, l, this.map.terrain ? (L, V, B) => this.map.terrain.getElevation(L, V, B) : void 0));
            return this.placement && p.push((function(k, L, V, B, H, re, le) {
              const ue = {},
                de = re.queryRenderedSymbols(B),
                ve = [];
              for (const Ae of Object.keys(de).map(Number)) ve.push(le[Ae]);
              ve.sort(yr);
              for (const Ae of ve) {
                const _e = Ae.featureIndex.lookupSymbolFeatures(de[Ae.bucketInstanceId], L, Ae.bucketIndex, Ae.sourceLayerIndex, {
                  filterSpec: H.filter,
                  globalState: H.globalState
                }, H.layers, H.availableImages, k);
                for (const ke in _e) {
                  const Fe = ue[ke] = ue[ke] || [],
                    xe = _e[ke];
                  xe.sort(((Ve, lt) => {
                    const rt = Ae.featureSortOrder;
                    if (rt) {
                      const at = rt.indexOf(Ve.featureIndex);
                      return rt.indexOf(lt.featureIndex) - at
                    }
                    return lt.featureIndex - Ve.featureIndex
                  }));
                  for (const Ve of xe) Fe.push(Ve)
                }
              }
              return (function(Ae, _e, ke) {
                for (const Fe in Ae)
                  for (const xe of Ae[Fe]) Wt(xe, ke[_e[Fe].source]);
                return Ae
              })(ue, k, V)
            })(this._layers, v, this.tileManagers, e, S, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(p)
          }
          querySourceFeatures(e, i) {
            i != null && i.filter && this._validate(s.B.filter, "querySourceFeatures.filter", i.filter, null, i);
            const l = this.tileManagers[e];
            return l ? (function(u, p) {
              const v = u.getRenderableIds().map((k => u.getTileByID(k))),
                T = [],
                S = {};
              for (let k = 0; k < v.length; k++) {
                const L = v[k],
                  V = L.tileID.canonical.key;
                S[V] || (S[V] = !0, L.querySourceFeatures(T, p))
              }
              return T
            })(l, i ? Object.assign(Object.assign({}, i), {
              globalState: this._globalState
            }) : {
              globalState: this._globalState
            }) : []
          }
          getLight() {
            return this.light.getLight()
          }
          setLight(e, i = {}) {
            this._checkLoaded();
            const l = this.light.getLight();
            let u = !1;
            for (const v in e)
              if (!s.bK(e[v], l[v])) {
                u = !0;
                break
              } if (!u) return;
            const p = {
              now: ie(),
              transition: s.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.light.setLight(e, i), this.light.updateTransitions(p)
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type)
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
          }
          setSky(e, i = {}) {
            this._checkLoaded();
            const l = this.getSky();
            let u = !1;
            if (!e && !l) return;
            if (e && !l) u = !0;
            else if (!e && l) u = !0;
            else
              for (const v in e)
                if (!s.bK(e[v], l[v])) {
                  u = !0;
                  break
                } if (!u) return;
            const p = {
              now: ie(),
              transition: s.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.stylesheet.sky = e, this.sky.setSky(e, i), this.sky.updateTransitions(p)
          }
          _setProjectionInternal(e) {
            const i = (function(l, u) {
              const p = {
                constrain: u
              };
              if (Array.isArray(l)) {
                const v = new la({
                  type: l
                });
                return {
                  projection: v,
                  transform: new Ll(p),
                  cameraHelper: new $s(v)
                }
              }
              switch (l) {
                case "mercator":
                  return {
                    projection: new $n, transform: new Kn(p), cameraHelper: new Fi
                  };
                case "globe": {
                  const v = new la({
                    type: ["interpolate", ["linear"],
                      ["zoom"], 11, "vertical-perspective", 12, "mercator"
                    ]
                  });
                  return {
                    projection: v,
                    transform: new Ll(p),
                    cameraHelper: new $s(v)
                  }
                }
                case "vertical-perspective":
                  return {
                    projection: new Ra, transform: new El(p), cameraHelper: new Ua
                  };
                default:
                  return s.w(`Unknown projection name: ${l}. Falling back to mercator projection.`), {
                    projection: new $n,
                    transform: new Kn(p),
                    cameraHelper: new Fi
                  }
              }
            })(e, this.map.transformConstrain);
            this.projection = i.projection, this.map.migrateProjection(i.transform, i.cameraHelper);
            for (const l in this.tileManagers) this.tileManagers[l].reload()
          }
          _validate(e, i, l, u, p = {}) {
            return (!p || p.validate !== !1) && Ts(this, e.call(s.B, s.e({
              key: i,
              style: this.serialize(),
              value: l,
              styleSpec: s.t
            }, u)))
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), D().off(Le, this._rtlPluginLoaded);
            for (const i in this._layers) this._layers[i].setEventedParent(null);
            for (const i in this.tileManagers) {
              const l = this.tileManagers[i];
              l.setEventedParent(null), l.onRemove(this.map)
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e)
          }
          _clearSource(e) {
            this.tileManagers[e].clearTiles()
          }
          _reloadSource(e) {
            this.tileManagers[e].resume(), this.tileManagers[e].reload()
          }
          _updateSources(e) {
            for (const i in this.tileManagers) this.tileManagers[i].update(e, this.map.terrain)
          }
          _generateCollisionBoxes() {
            for (const e in this.tileManagers) this._reloadSource(e)
          }
          _updatePlacement(e, i, l, u, p = !1) {
            let v = !1,
              T = !1;
            const S = {};
            for (const k of this._order) {
              const L = this._layers[k];
              if (L.type !== "symbol") continue;
              if (!S[L.source]) {
                const B = this.tileManagers[L.source];
                S[L.source] = B.getRenderableIds(!0).map((H => B.getTileByID(H))).sort(((H, re) => re.tileID.overscaledZ - H.tileID.overscaledZ || (H.tileID.isLessThan(re.tileID) ? -1 : 1)))
              }
              const V = this.crossTileSymbolIndex.addLayer(L, S[L.source], e.center.lng);
              v = v || V
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((p = p || this._layerOrderChanged || l === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(ie(), e.zoom)) && (this.pauseablePlacement = new Er(e, this.map.terrain, this._order, p, i, l, u, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, S), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(ie()), T = !0), v && this.pauseablePlacement.placement.setStale()), T || v)
              for (const k of this._order) {
                const L = this._layers[k];
                L.type === "symbol" && this.placement.updateLayerOpacities(L, S[L.source])
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(ie())
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.tileManagers) this.tileManagers[e].releaseSymbolFadeTiles()
          }
          getImages(e, i) {
            return s._(this, void 0, void 0, (function*() {
              const l = yield this.imageManager.getImages(i.icons);
              this._updateTilesForChangedImages();
              const u = this.tileManagers[i.source];
              return u && u.setDependencies(i.tileID.key, i.type, i.icons), l
            }))
          }
          getGlyphs(e, i) {
            return s._(this, void 0, void 0, (function*() {
              const l = yield this.glyphManager.getGlyphs(i.stacks), u = this.tileManagers[i.source];
              return u && u.setDependencies(i.tileID.key, i.type, [""]), l
            }))
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null
          }
          setGlyphs(e, i = {}) {
            this._checkLoaded(), e && this._validate(s.B.glyphs, "glyphs", e, null, i) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e))
          }
          getDashes(e, i) {
            return s._(this, void 0, void 0, (function*() {
              const l = {};
              for (const [u, p] of Object.entries(i.dashes)) l[u] = this.lineAtlas.getDash(p.dasharray, p.round);
              return l
            }))
          }
          addSprite(e, i, l = {}, u) {
            this._checkLoaded();
            const p = [{
                id: e,
                url: i
              }],
              v = [...Be(this.stylesheet.sprite), ...p];
            this._validate(s.B.sprite, "sprite", v, null, l) || (this.stylesheet.sprite = v, this._loadSprite(p, !0, u))
          }
          removeSprite(e) {
            this._checkLoaded();
            const i = Be(this.stylesheet.sprite);
            if (i.find((l => l.id === e))) {
              if (this._spritesImagesIds[e])
                for (const l of this._spritesImagesIds[e]) this.imageManager.removeImage(l), this._changedImages[l] = !0;
              i.splice(i.findIndex((l => l.id === e)), 1), this.stylesheet.sprite = i.length > 0 ? i : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
                dataType: "style"
              }))
            } else this.fire(new s.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
          }
          getSprite() {
            return Be(this.stylesheet.sprite)
          }
          setSprite(e, i = {}, l) {
            this._checkLoaded(), e && this._validate(s.B.sprite, "sprite", e, null, i) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, l) : (this._unloadSprite(), l && l(null)))
          }
        }
        var Zc = s.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }, {
          name: "a_texture_pos",
          type: "Int16",
          components: 2
        }]);
        class to {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null
          }
          bind(e, i, l, u, p, v, T, S, k) {
            this.context = e;
            let L = this.boundPaintVertexBuffers.length !== u.length;
            for (let V = 0; !L && V < u.length; V++) this.boundPaintVertexBuffers[V] !== u[V] && (L = !0);
            !this.vao || this.boundProgram !== i || this.boundLayoutVertexBuffer !== l || L || this.boundIndexBuffer !== p || this.boundVertexOffset !== v || this.boundDynamicVertexBuffer !== T || this.boundDynamicVertexBuffer2 !== S || this.boundDynamicVertexBuffer3 !== k ? this.freshBind(i, l, u, p, v, T, S, k) : (e.bindVertexArray.set(this.vao), T && T.bind(), p && p.dynamicDraw && p.bind(), S && S.bind(), k && k.bind())
          }
          freshBind(e, i, l, u, p, v, T, S) {
            const k = e.numAttributes,
              L = this.context,
              V = L.gl;
            this.vao && this.destroy(), this.vao = L.createVertexArray(), L.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = i, this.boundPaintVertexBuffers = l, this.boundIndexBuffer = u, this.boundVertexOffset = p, this.boundDynamicVertexBuffer = v, this.boundDynamicVertexBuffer2 = T, this.boundDynamicVertexBuffer3 = S, i.enableAttributes(V, e);
            for (const B of l) B.enableAttributes(V, e);
            v && v.enableAttributes(V, e), T && T.enableAttributes(V, e), S && S.enableAttributes(V, e), i.bind(), i.setVertexAttribPointers(V, e, p);
            for (const B of l) B.bind(), B.setVertexAttribPointers(V, e, p);
            v && (v.bind(), v.setVertexAttribPointers(V, e, p)), u && u.bind(), T && (T.bind(), T.setVertexAttribPointers(V, e, p)), S && (S.bind(), S.setVertexAttribPointers(V, e, p)), L.currentNumAttributes = k
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null)
          }
        }
        const lf = (h, e, i, l, u) => ({
            u_texture: 0,
            u_ele_delta: h,
            u_fog_matrix: e,
            u_fog_color: i ? i.properties.get("fog-color") : s.bi.white,
            u_fog_ground_blend: i ? i.properties.get("fog-ground-blend") : 1,
            u_fog_ground_blend_opacity: u ? 0 : i ? i.calculateFogBlendOpacity(l) : 0,
            u_horizon_color: i ? i.properties.get("horizon-color") : s.bi.white,
            u_horizon_fog_blend: i ? i.properties.get("horizon-fog-blend") : 1,
            u_is_globe_mode: u ? 1 : 0
          }),
          Gc = {
            mainMatrix: "u_projection_matrix",
            tileMercatorCoords: "u_projection_tile_mercator_coords",
            clippingPlane: "u_projection_clipping_plane",
            projectionTransition: "u_projection_transition",
            fallbackMatrix: "u_projection_fallback_matrix"
          };

        function Eo(h) {
          const e = [];
          for (let i = 0; i < h.length; i++) {
            if (h[i] === null) continue;
            const l = h[i].split(" ");
            e.push(l.pop())
          }
          return e
        }
        class Ys {
          constructor(e, i, l, u, p, v, T, S, k = []) {
            const L = e.gl;
            this.program = L.createProgram();
            const V = Eo(i.staticAttributes),
              B = l ? l.getBinderAttributes() : [],
              H = V.concat(B),
              re = gr.prelude.staticUniforms ? Eo(gr.prelude.staticUniforms) : [],
              le = T.staticUniforms ? Eo(T.staticUniforms) : [],
              ue = i.staticUniforms ? Eo(i.staticUniforms) : [],
              de = l ? l.getBinderUniforms() : [],
              ve = re.concat(le).concat(ue).concat(de),
              Ae = [];
            for (const rt of ve) Ae.indexOf(rt) < 0 && Ae.push(rt);
            const _e = l ? l.defines() : [];
            Ui(L) && _e.unshift("#version 300 es"), p && _e.push("#define OVERDRAW_INSPECTOR;"), v && _e.push("#define TERRAIN3D;"), S && _e.push(S), k && _e.push(...k);
            let ke = _e.concat(gr.prelude.fragmentSource, T.fragmentSource, i.fragmentSource).join(`
`),
              Fe = _e.concat(gr.prelude.vertexSource, T.vertexSource, i.vertexSource).join(`
`);
            Ui(L) || (ke = (function(rt) {
              return rt.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
            })(ke), Fe = (function(rt) {
              return rt.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
            })(Fe));
            const xe = L.createShader(L.FRAGMENT_SHADER);
            if (L.isContextLost()) return void(this.failedToCreate = !0);
            if (L.shaderSource(xe, ke), L.compileShader(xe), !L.getShaderParameter(xe, L.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${L.getShaderInfoLog(xe)}`);
            L.attachShader(this.program, xe);
            const Ve = L.createShader(L.VERTEX_SHADER);
            if (L.isContextLost()) return void(this.failedToCreate = !0);
            if (L.shaderSource(Ve, Fe), L.compileShader(Ve), !L.getShaderParameter(Ve, L.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${L.getShaderInfoLog(Ve)}`);
            L.attachShader(this.program, Ve), this.attributes = {};
            const lt = {};
            this.numAttributes = H.length;
            for (let rt = 0; rt < this.numAttributes; rt++) H[rt] && (L.bindAttribLocation(this.program, rt, H[rt]), this.attributes[H[rt]] = rt);
            if (L.linkProgram(this.program), !L.getProgramParameter(this.program, L.LINK_STATUS)) throw new Error(`Program failed to link: ${L.getProgramInfoLog(this.program)}`);
            L.deleteShader(Ve), L.deleteShader(xe);
            for (let rt = 0; rt < Ae.length; rt++) {
              const at = Ae[rt];
              if (at && !lt[at]) {
                const ct = L.getUniformLocation(this.program, at);
                ct && (lt[at] = ct)
              }
            }
            this.fixedUniforms = u(e, lt), this.terrainUniforms = ((rt, at) => ({
              u_depth: new s.bT(rt, at.u_depth),
              u_terrain: new s.bT(rt, at.u_terrain),
              u_terrain_dim: new s.bj(rt, at.u_terrain_dim),
              u_terrain_matrix: new s.bV(rt, at.u_terrain_matrix),
              u_terrain_unpack: new s.bW(rt, at.u_terrain_unpack),
              u_terrain_exaggeration: new s.bj(rt, at.u_terrain_exaggeration)
            }))(e, lt), this.projectionUniforms = ((rt, at) => ({
              u_projection_matrix: new s.bV(rt, at.u_projection_matrix),
              u_projection_tile_mercator_coords: new s.bW(rt, at.u_projection_tile_mercator_coords),
              u_projection_clipping_plane: new s.bW(rt, at.u_projection_clipping_plane),
              u_projection_transition: new s.bj(rt, at.u_projection_transition),
              u_projection_fallback_matrix: new s.bV(rt, at.u_projection_fallback_matrix)
            }))(e, lt), this.binderUniforms = l ? l.getUniforms(e, lt) : []
          }
          draw(e, i, l, u, p, v, T, S, k, L, V, B, H, re, le, ue, de, ve, Ae) {
            const _e = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(l), e.setStencilMode(u), e.setColorMode(p), e.setCullFace(v), S) {
              e.activeTexture.set(_e.TEXTURE2), _e.bindTexture(_e.TEXTURE_2D, S.depthTexture), e.activeTexture.set(_e.TEXTURE3), _e.bindTexture(_e.TEXTURE_2D, S.texture);
              for (const Fe in this.terrainUniforms) this.terrainUniforms[Fe].set(S[Fe])
            }
            if (k)
              for (const Fe in k) this.projectionUniforms[Gc[Fe]].set(k[Fe]);
            if (T)
              for (const Fe in this.fixedUniforms) this.fixedUniforms[Fe].set(T[Fe]);
            ue && ue.setUniforms(e, this.binderUniforms, re, {
              zoom: le
            });
            let ke = 0;
            switch (i) {
              case _e.LINES:
                ke = 2;
                break;
              case _e.TRIANGLES:
                ke = 3;
                break;
              case _e.LINE_STRIP:
                ke = 1
            }
            for (const Fe of H.get()) {
              const xe = Fe.vaos || (Fe.vaos = {});
              (xe[L] || (xe[L] = new to)).bind(e, this, V, ue ? ue.getPaintVertexBuffers() : [], B, Fe.vertexOffset, de, ve, Ae), _e.drawElements(i, Fe.primitiveLength * ke, _e.UNSIGNED_SHORT, Fe.primitiveOffset * ke * 2)
            }
          }
        }

        function ad(h, e, i) {
          const l = 1 / s.aG(i, 1, e.transform.tileZoom),
            u = Math.pow(2, i.tileID.overscaledZ),
            p = i.tileSize * Math.pow(2, e.transform.tileZoom) / u,
            v = p * (i.tileID.canonical.x + i.tileID.wrap * u),
            T = p * i.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: i.imageAtlasTexture.size,
            u_scale: [l, h.fromScale, h.toScale],
            u_fade: h.t,
            u_pixel_coord_upper: [v >> 16, T >> 16],
            u_pixel_coord_lower: [65535 & v, 65535 & T]
          }
        }
        const Ks = (h, e, i, l) => {
            const u = h.style.light,
              p = u.properties.get("position"),
              v = [p.x, p.y, p.z],
              T = s.bZ();
            u.properties.get("anchor") === "viewport" && s.b_(T, h.transform.bearingInRadians), s.b$(v, v, T);
            const S = h.transform.transformLightDirection(v),
              k = u.properties.get("color");
            return {
              u_lightpos: v,
              u_lightpos_globe: S,
              u_lightintensity: u.properties.get("intensity"),
              u_lightcolor: [k.r, k.g, k.b],
              u_vertical_gradient: +e,
              u_opacity: i,
              u_fill_translate: l
            }
          },
          cf = (h, e, i, l, u, p, v) => s.e(Ks(h, e, i, l), ad(p, h, v), {
            u_height_factor: -Math.pow(2, u.overscaledZ) / v.tileSize / 8
          }),
          Ho = (h, e, i, l) => s.e(ad(e, h, i), {
            u_fill_translate: l
          }),
          uf = (h, e) => ({
            u_world: h,
            u_fill_translate: e
          }),
          od = (h, e, i, l, u) => s.e(Ho(h, e, i, u), {
            u_world: l
          }),
          hf = (h, e, i, l, u) => {
            const p = h.transform;
            let v, T, S = 0;
            if (i.paint.get("circle-pitch-alignment") === "map") {
              const k = s.aG(e, 1, p.zoom);
              v = !0, T = [k, k], S = k / (s.a3 * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * u
            } else v = !1, T = p.pixelsToGLUnits;
            return {
              u_camera_to_center_distance: p.cameraToCenterDistance,
              u_scale_with_map: +(i.paint.get("circle-pitch-scale") === "map"),
              u_pitch_with_map: +v,
              u_device_pixel_ratio: h.pixelRatio,
              u_extrude_scale: T,
              u_globe_extrude_scale: S,
              u_translate: l
            }
          },
          sd = h => ({
            u_pixel_extrude_scale: [1 / h.width, 1 / h.height]
          }),
          Hc = h => ({
            u_viewport_size: [h.width, h.height]
          }),
          Wc = (h, e = 1) => ({
            u_color: h,
            u_overlay: 0,
            u_overlay_scale: e
          }),
          $c = (h, e, i, l) => {
            const u = s.aG(h, 1, e) / (s.a3 * Math.pow(2, h.tileID.overscaledZ)) * 2 * Math.PI * l;
            return {
              u_extrude_scale: s.aG(h, 1, e),
              u_intensity: i,
              u_globe_extrude_scale: u
            }
          },
          Xc = (h, e, i, l) => {
            const u = s.M();
            s.c0(u, 0, h.width, h.height, 0, 0, 1);
            const p = h.context.gl;
            return {
              u_matrix: u,
              u_world: [p.drawingBufferWidth, p.drawingBufferHeight],
              u_image: i,
              u_color_ramp: l,
              u_opacity: e.paint.get("heatmap-opacity")
            }
          },
          ld = (h, e, i) => {
            const l = i.paint.get("hillshade-accent-color");
            let u;
            switch (i.paint.get("hillshade-method")) {
              case "basic":
                u = 4;
                break;
              case "combined":
                u = 1;
                break;
              case "igor":
                u = 2;
                break;
              case "multidirectional":
                u = 3;
                break;
              default:
                u = 0
            }
            const p = i.getIlluminationProperties();
            for (let v = 0; v < p.directionRadians.length; v++) i.paint.get("hillshade-illumination-anchor") === "viewport" && (p.directionRadians[v] += h.transform.bearingInRadians);
            return {
              u_image: 0,
              u_latrange: cd(0, e.tileID),
              u_exaggeration: i.paint.get("hillshade-exaggeration"),
              u_altitudes: p.altitudeRadians,
              u_azimuths: p.directionRadians,
              u_accent: l,
              u_method: u,
              u_highlights: p.highlightColor,
              u_shadows: p.shadowColor
            }
          },
          Wo = (h, e) => {
            const i = e.stride,
              l = s.M();
            return s.c0(l, 0, s.a3, -s.a3, 0, 0, 1), s.N(l, l, [0, -s.a3, 0]), {
              u_matrix: l,
              u_image: 1,
              u_dimension: [i, i],
              u_zoom: h.overscaledZ,
              u_unpack: e.getUnpackVector()
            }
          };

        function cd(h, e) {
          const i = Math.pow(2, e.canonical.z),
            l = e.canonical.y;
          return [new s.a5(0, l / i).toLngLat().lat, new s.a5(0, (l + 1) / i).toLngLat().lat]
        }
        const ud = (h, e, i = 0) => ({
            u_image: 0,
            u_unpack: e.getUnpackVector(),
            u_dimension: [e.stride, e.stride],
            u_elevation_stops: 1,
            u_color_stops: 4,
            u_color_ramp_size: i,
            u_opacity: h.paint.get("color-relief-opacity")
          }),
          Lo = (h, e, i, l) => {
            const u = h.transform;
            return {
              u_translation: Yc(h, e, i),
              u_ratio: l / s.aG(e, 1, u.zoom),
              u_device_pixel_ratio: h.pixelRatio,
              u_units_to_pixels: [1 / u.pixelsToGLUnits[0], 1 / u.pixelsToGLUnits[1]]
            }
          },
          df = (h, e, i, l, u) => s.e(Lo(h, e, i, l), {
            u_image: 0,
            u_image_height: u
          }),
          Dl = (h, e, i, l, u) => {
            const p = h.transform,
              v = Rl(e, p);
            return {
              u_translation: Yc(h, e, i),
              u_texsize: e.imageAtlasTexture.size,
              u_ratio: l / s.aG(e, 1, p.zoom),
              u_device_pixel_ratio: h.pixelRatio,
              u_image: 0,
              u_scale: [v, u.fromScale, u.toScale],
              u_fade: u.t,
              u_units_to_pixels: [1 / p.pixelsToGLUnits[0], 1 / p.pixelsToGLUnits[1]]
            }
          },
          pf = (h, e, i, l, u) => {
            const p = Rl(e, h.transform);
            return s.e(Lo(h, e, i, l), {
              u_tileratio: p,
              u_crossfade_from: u.fromScale,
              u_crossfade_to: u.toScale,
              u_image: 0,
              u_mix: u.t,
              u_lineatlas_width: h.lineAtlas.width,
              u_lineatlas_height: h.lineAtlas.height
            })
          },
          ff = (h, e, i, l, u, p) => {
            const v = Rl(e, h.transform);
            return s.e(Lo(h, e, i, l), {
              u_image: 0,
              u_image_height: p,
              u_tileratio: v,
              u_crossfade_from: u.fromScale,
              u_crossfade_to: u.toScale,
              u_image_dash: 1,
              u_mix: u.t,
              u_lineatlas_width: h.lineAtlas.width,
              u_lineatlas_height: h.lineAtlas.height
            })
          };

        function Rl(h, e) {
          return 1 / s.aG(h, 1, e.tileZoom)
        }

        function Yc(h, e, i) {
          return s.aH(h.transform, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"))
        }
        const hd = (h, e, i, l, u) => {
          return {
            u_tl_parent: h,
            u_scale_parent: e,
            u_buffer_scale: 1,
            u_fade_t: i.mix,
            u_opacity: i.opacity * l.paint.get("raster-opacity"),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: l.paint.get("raster-brightness-min"),
            u_brightness_high: l.paint.get("raster-brightness-max"),
            u_saturation_factor: (v = l.paint.get("raster-saturation"), v > 0 ? 1 - 1 / (1.001 - v) : -v),
            u_contrast_factor: (p = l.paint.get("raster-contrast"), p > 0 ? 1 / (1 - p) : 1 + p),
            u_spin_weights: Kc(l.paint.get("raster-hue-rotate")),
            u_coords_top: [u[0].x, u[0].y, u[1].x, u[1].y],
            u_coords_bottom: [u[3].x, u[3].y, u[2].x, u[2].y]
          };
          var p, v
        };

        function Kc(h) {
          h *= Math.PI / 180;
          const e = Math.sin(h),
            i = Math.cos(h);
          return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3]
        }
        const Jc = (h, e, i, l, u, p, v, T, S, k, L, V, B) => {
            const H = v.transform;
            return {
              u_is_size_zoom_constant: +(h === "constant" || h === "source"),
              u_is_size_feature_constant: +(h === "constant" || h === "camera"),
              u_size_t: e ? e.uSizeT : 0,
              u_size: e ? e.uSize : 0,
              u_camera_to_center_distance: H.cameraToCenterDistance,
              u_pitch: H.pitch / 360 * 2 * Math.PI,
              u_rotate_symbol: +i,
              u_aspect_ratio: H.width / H.height,
              u_fade_change: v.options.fadeDuration ? v.symbolFadeChange : 1,
              u_label_plane_matrix: T,
              u_coord_matrix: S,
              u_is_text: +L,
              u_pitch_with_map: +l,
              u_is_along_line: u,
              u_is_variable_anchor: p,
              u_texsize: V,
              u_texture: 0,
              u_translation: k,
              u_pitched_scale: B
            }
          },
          Js = (h, e, i, l, u, p, v, T, S, k, L, V, B, H) => {
            const re = v.transform;
            return s.e(Jc(h, e, i, l, u, p, v, T, S, k, L, V, H), {
              u_gamma_scale: l ? Math.cos(re.pitch * Math.PI / 180) * re.cameraToCenterDistance : 1,
              u_device_pixel_ratio: v.pixelRatio,
              u_is_halo: 1
            })
          },
          po = (h, e, i, l, u, p, v, T, S, k, L, V, B) => s.e(Js(h, e, i, l, u, p, v, T, S, k, !0, L, 0, B), {
            u_texsize_icon: V,
            u_texture_icon: 1
          }),
          Qc = (h, e) => ({
            u_opacity: h,
            u_color: e
          }),
          eu = (h, e, i, l, u) => s.e((function(p, v, T, S) {
            const k = T.imageManager.getPattern(p.from.toString()),
              L = T.imageManager.getPattern(p.to.toString()),
              {
                width: V,
                height: B
              } = T.imageManager.getPixelSize(),
              H = Math.pow(2, S.tileID.overscaledZ),
              re = S.tileSize * Math.pow(2, T.transform.tileZoom) / H,
              le = re * (S.tileID.canonical.x + S.tileID.wrap * H),
              ue = re * S.tileID.canonical.y;
            return {
              u_image: 0,
              u_pattern_tl_a: k.tl,
              u_pattern_br_a: k.br,
              u_pattern_tl_b: L.tl,
              u_pattern_br_b: L.br,
              u_texsize: [V, B],
              u_mix: v.t,
              u_pattern_size_a: k.displaySize,
              u_pattern_size_b: L.displaySize,
              u_scale_a: v.fromScale,
              u_scale_b: v.toScale,
              u_tile_units_to_pixels: 1 / s.aG(S, 1, T.transform.tileZoom),
              u_pixel_coord_upper: [le >> 16, ue >> 16],
              u_pixel_coord_lower: [65535 & le, 65535 & ue]
            }
          })(i, u, e, l), {
            u_opacity: h
          }),
          Fl = (h, e) => {},
          dd = {
            fillExtrusion: (h, e) => ({
              u_lightpos: new s.bX(h, e.u_lightpos),
              u_lightpos_globe: new s.bX(h, e.u_lightpos_globe),
              u_lightintensity: new s.bj(h, e.u_lightintensity),
              u_lightcolor: new s.bX(h, e.u_lightcolor),
              u_vertical_gradient: new s.bj(h, e.u_vertical_gradient),
              u_opacity: new s.bj(h, e.u_opacity),
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            fillExtrusionPattern: (h, e) => ({
              u_lightpos: new s.bX(h, e.u_lightpos),
              u_lightpos_globe: new s.bX(h, e.u_lightpos_globe),
              u_lightintensity: new s.bj(h, e.u_lightintensity),
              u_lightcolor: new s.bX(h, e.u_lightcolor),
              u_vertical_gradient: new s.bj(h, e.u_vertical_gradient),
              u_height_factor: new s.bj(h, e.u_height_factor),
              u_opacity: new s.bj(h, e.u_opacity),
              u_fill_translate: new s.bY(h, e.u_fill_translate),
              u_image: new s.bT(h, e.u_image),
              u_texsize: new s.bY(h, e.u_texsize),
              u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
              u_scale: new s.bX(h, e.u_scale),
              u_fade: new s.bj(h, e.u_fade)
            }),
            fill: (h, e) => ({
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            fillPattern: (h, e) => ({
              u_image: new s.bT(h, e.u_image),
              u_texsize: new s.bY(h, e.u_texsize),
              u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
              u_scale: new s.bX(h, e.u_scale),
              u_fade: new s.bj(h, e.u_fade),
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            fillOutline: (h, e) => ({
              u_world: new s.bY(h, e.u_world),
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            fillOutlinePattern: (h, e) => ({
              u_world: new s.bY(h, e.u_world),
              u_image: new s.bT(h, e.u_image),
              u_texsize: new s.bY(h, e.u_texsize),
              u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
              u_scale: new s.bX(h, e.u_scale),
              u_fade: new s.bj(h, e.u_fade),
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            circle: (h, e) => ({
              u_camera_to_center_distance: new s.bj(h, e.u_camera_to_center_distance),
              u_scale_with_map: new s.bT(h, e.u_scale_with_map),
              u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
              u_extrude_scale: new s.bY(h, e.u_extrude_scale),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_globe_extrude_scale: new s.bj(h, e.u_globe_extrude_scale),
              u_translate: new s.bY(h, e.u_translate)
            }),
            collisionBox: (h, e) => ({
              u_pixel_extrude_scale: new s.bY(h, e.u_pixel_extrude_scale)
            }),
            collisionCircle: (h, e) => ({
              u_viewport_size: new s.bY(h, e.u_viewport_size)
            }),
            debug: (h, e) => ({
              u_color: new s.bU(h, e.u_color),
              u_overlay: new s.bT(h, e.u_overlay),
              u_overlay_scale: new s.bj(h, e.u_overlay_scale)
            }),
            depth: Fl,
            clippingMask: Fl,
            heatmap: (h, e) => ({
              u_extrude_scale: new s.bj(h, e.u_extrude_scale),
              u_intensity: new s.bj(h, e.u_intensity),
              u_globe_extrude_scale: new s.bj(h, e.u_globe_extrude_scale)
            }),
            heatmapTexture: (h, e) => ({
              u_matrix: new s.bV(h, e.u_matrix),
              u_world: new s.bY(h, e.u_world),
              u_image: new s.bT(h, e.u_image),
              u_color_ramp: new s.bT(h, e.u_color_ramp),
              u_opacity: new s.bj(h, e.u_opacity)
            }),
            hillshade: (h, e) => ({
              u_image: new s.bT(h, e.u_image),
              u_latrange: new s.bY(h, e.u_latrange),
              u_exaggeration: new s.bj(h, e.u_exaggeration),
              u_altitudes: new s.c2(h, e.u_altitudes),
              u_azimuths: new s.c2(h, e.u_azimuths),
              u_accent: new s.bU(h, e.u_accent),
              u_method: new s.bT(h, e.u_method),
              u_shadows: new s.c1(h, e.u_shadows),
              u_highlights: new s.c1(h, e.u_highlights)
            }),
            hillshadePrepare: (h, e) => ({
              u_matrix: new s.bV(h, e.u_matrix),
              u_image: new s.bT(h, e.u_image),
              u_dimension: new s.bY(h, e.u_dimension),
              u_zoom: new s.bj(h, e.u_zoom),
              u_unpack: new s.bW(h, e.u_unpack)
            }),
            colorRelief: (h, e) => ({
              u_image: new s.bT(h, e.u_image),
              u_unpack: new s.bW(h, e.u_unpack),
              u_dimension: new s.bY(h, e.u_dimension),
              u_elevation_stops: new s.bT(h, e.u_elevation_stops),
              u_color_stops: new s.bT(h, e.u_color_stops),
              u_color_ramp_size: new s.bT(h, e.u_color_ramp_size),
              u_opacity: new s.bj(h, e.u_opacity)
            }),
            line: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels)
            }),
            lineGradient: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
              u_image: new s.bT(h, e.u_image),
              u_image_height: new s.bj(h, e.u_image_height)
            }),
            linePattern: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_texsize: new s.bY(h, e.u_texsize),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_image: new s.bT(h, e.u_image),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
              u_scale: new s.bX(h, e.u_scale),
              u_fade: new s.bj(h, e.u_fade)
            }),
            lineSDF: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
              u_image: new s.bT(h, e.u_image),
              u_mix: new s.bj(h, e.u_mix),
              u_tileratio: new s.bj(h, e.u_tileratio),
              u_crossfade_from: new s.bj(h, e.u_crossfade_from),
              u_crossfade_to: new s.bj(h, e.u_crossfade_to),
              u_lineatlas_width: new s.bj(h, e.u_lineatlas_width),
              u_lineatlas_height: new s.bj(h, e.u_lineatlas_height)
            }),
            lineGradientSDF: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
              u_image: new s.bT(h, e.u_image),
              u_image_height: new s.bj(h, e.u_image_height),
              u_tileratio: new s.bj(h, e.u_tileratio),
              u_crossfade_from: new s.bj(h, e.u_crossfade_from),
              u_crossfade_to: new s.bj(h, e.u_crossfade_to),
              u_image_dash: new s.bT(h, e.u_image_dash),
              u_mix: new s.bj(h, e.u_mix),
              u_lineatlas_width: new s.bj(h, e.u_lineatlas_width),
              u_lineatlas_height: new s.bj(h, e.u_lineatlas_height)
            }),
            raster: (h, e) => ({
              u_tl_parent: new s.bY(h, e.u_tl_parent),
              u_scale_parent: new s.bj(h, e.u_scale_parent),
              u_buffer_scale: new s.bj(h, e.u_buffer_scale),
              u_fade_t: new s.bj(h, e.u_fade_t),
              u_opacity: new s.bj(h, e.u_opacity),
              u_image0: new s.bT(h, e.u_image0),
              u_image1: new s.bT(h, e.u_image1),
              u_brightness_low: new s.bj(h, e.u_brightness_low),
              u_brightness_high: new s.bj(h, e.u_brightness_high),
              u_saturation_factor: new s.bj(h, e.u_saturation_factor),
              u_contrast_factor: new s.bj(h, e.u_contrast_factor),
              u_spin_weights: new s.bX(h, e.u_spin_weights),
              u_coords_top: new s.bW(h, e.u_coords_top),
              u_coords_bottom: new s.bW(h, e.u_coords_bottom)
            }),
            symbolIcon: (h, e) => ({
              u_is_size_zoom_constant: new s.bT(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bT(h, e.u_is_size_feature_constant),
              u_size_t: new s.bj(h, e.u_size_t),
              u_size: new s.bj(h, e.u_size),
              u_camera_to_center_distance: new s.bj(h, e.u_camera_to_center_distance),
              u_pitch: new s.bj(h, e.u_pitch),
              u_rotate_symbol: new s.bT(h, e.u_rotate_symbol),
              u_aspect_ratio: new s.bj(h, e.u_aspect_ratio),
              u_fade_change: new s.bj(h, e.u_fade_change),
              u_label_plane_matrix: new s.bV(h, e.u_label_plane_matrix),
              u_coord_matrix: new s.bV(h, e.u_coord_matrix),
              u_is_text: new s.bT(h, e.u_is_text),
              u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
              u_is_along_line: new s.bT(h, e.u_is_along_line),
              u_is_variable_anchor: new s.bT(h, e.u_is_variable_anchor),
              u_texsize: new s.bY(h, e.u_texsize),
              u_texture: new s.bT(h, e.u_texture),
              u_translation: new s.bY(h, e.u_translation),
              u_pitched_scale: new s.bj(h, e.u_pitched_scale)
            }),
            symbolSDF: (h, e) => ({
              u_is_size_zoom_constant: new s.bT(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bT(h, e.u_is_size_feature_constant),
              u_size_t: new s.bj(h, e.u_size_t),
              u_size: new s.bj(h, e.u_size),
              u_camera_to_center_distance: new s.bj(h, e.u_camera_to_center_distance),
              u_pitch: new s.bj(h, e.u_pitch),
              u_rotate_symbol: new s.bT(h, e.u_rotate_symbol),
              u_aspect_ratio: new s.bj(h, e.u_aspect_ratio),
              u_fade_change: new s.bj(h, e.u_fade_change),
              u_label_plane_matrix: new s.bV(h, e.u_label_plane_matrix),
              u_coord_matrix: new s.bV(h, e.u_coord_matrix),
              u_is_text: new s.bT(h, e.u_is_text),
              u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
              u_is_along_line: new s.bT(h, e.u_is_along_line),
              u_is_variable_anchor: new s.bT(h, e.u_is_variable_anchor),
              u_texsize: new s.bY(h, e.u_texsize),
              u_texture: new s.bT(h, e.u_texture),
              u_gamma_scale: new s.bj(h, e.u_gamma_scale),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_is_halo: new s.bT(h, e.u_is_halo),
              u_translation: new s.bY(h, e.u_translation),
              u_pitched_scale: new s.bj(h, e.u_pitched_scale)
            }),
            symbolTextAndIcon: (h, e) => ({
              u_is_size_zoom_constant: new s.bT(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bT(h, e.u_is_size_feature_constant),
              u_size_t: new s.bj(h, e.u_size_t),
              u_size: new s.bj(h, e.u_size),
              u_camera_to_center_distance: new s.bj(h, e.u_camera_to_center_distance),
              u_pitch: new s.bj(h, e.u_pitch),
              u_rotate_symbol: new s.bT(h, e.u_rotate_symbol),
              u_aspect_ratio: new s.bj(h, e.u_aspect_ratio),
              u_fade_change: new s.bj(h, e.u_fade_change),
              u_label_plane_matrix: new s.bV(h, e.u_label_plane_matrix),
              u_coord_matrix: new s.bV(h, e.u_coord_matrix),
              u_is_text: new s.bT(h, e.u_is_text),
              u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
              u_is_along_line: new s.bT(h, e.u_is_along_line),
              u_is_variable_anchor: new s.bT(h, e.u_is_variable_anchor),
              u_texsize: new s.bY(h, e.u_texsize),
              u_texsize_icon: new s.bY(h, e.u_texsize_icon),
              u_texture: new s.bT(h, e.u_texture),
              u_texture_icon: new s.bT(h, e.u_texture_icon),
              u_gamma_scale: new s.bj(h, e.u_gamma_scale),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_is_halo: new s.bT(h, e.u_is_halo),
              u_translation: new s.bY(h, e.u_translation),
              u_pitched_scale: new s.bj(h, e.u_pitched_scale)
            }),
            background: (h, e) => ({
              u_opacity: new s.bj(h, e.u_opacity),
              u_color: new s.bU(h, e.u_color)
            }),
            backgroundPattern: (h, e) => ({
              u_opacity: new s.bj(h, e.u_opacity),
              u_image: new s.bT(h, e.u_image),
              u_pattern_tl_a: new s.bY(h, e.u_pattern_tl_a),
              u_pattern_br_a: new s.bY(h, e.u_pattern_br_a),
              u_pattern_tl_b: new s.bY(h, e.u_pattern_tl_b),
              u_pattern_br_b: new s.bY(h, e.u_pattern_br_b),
              u_texsize: new s.bY(h, e.u_texsize),
              u_mix: new s.bj(h, e.u_mix),
              u_pattern_size_a: new s.bY(h, e.u_pattern_size_a),
              u_pattern_size_b: new s.bY(h, e.u_pattern_size_b),
              u_scale_a: new s.bj(h, e.u_scale_a),
              u_scale_b: new s.bj(h, e.u_scale_b),
              u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
              u_tile_units_to_pixels: new s.bj(h, e.u_tile_units_to_pixels)
            }),
            terrain: (h, e) => ({
              u_texture: new s.bT(h, e.u_texture),
              u_ele_delta: new s.bj(h, e.u_ele_delta),
              u_fog_matrix: new s.bV(h, e.u_fog_matrix),
              u_fog_color: new s.bU(h, e.u_fog_color),
              u_fog_ground_blend: new s.bj(h, e.u_fog_ground_blend),
              u_fog_ground_blend_opacity: new s.bj(h, e.u_fog_ground_blend_opacity),
              u_horizon_color: new s.bU(h, e.u_horizon_color),
              u_horizon_fog_blend: new s.bj(h, e.u_horizon_fog_blend),
              u_is_globe_mode: new s.bj(h, e.u_is_globe_mode)
            }),
            terrainDepth: (h, e) => ({
              u_ele_delta: new s.bj(h, e.u_ele_delta)
            }),
            terrainCoords: (h, e) => ({
              u_texture: new s.bT(h, e.u_texture),
              u_terrain_coords_id: new s.bj(h, e.u_terrain_coords_id),
              u_ele_delta: new s.bj(h, e.u_ele_delta)
            }),
            projectionErrorMeasurement: (h, e) => ({
              u_input: new s.bj(h, e.u_input),
              u_output_expected: new s.bj(h, e.u_output_expected)
            }),
            atmosphere: (h, e) => ({
              u_sun_pos: new s.bX(h, e.u_sun_pos),
              u_atmosphere_blend: new s.bj(h, e.u_atmosphere_blend),
              u_globe_position: new s.bX(h, e.u_globe_position),
              u_globe_radius: new s.bj(h, e.u_globe_radius),
              u_inv_proj_matrix: new s.bV(h, e.u_inv_proj_matrix)
            }),
            sky: (h, e) => ({
              u_sky_color: new s.bU(h, e.u_sky_color),
              u_horizon_color: new s.bU(h, e.u_horizon_color),
              u_horizon: new s.bY(h, e.u_horizon),
              u_horizon_normal: new s.bY(h, e.u_horizon_normal),
              u_sky_horizon_blend: new s.bj(h, e.u_sky_horizon_blend),
              u_sky_blend: new s.bj(h, e.u_sky_blend)
            })
          };
        class tu {
          constructor(e, i, l) {
            this.context = e;
            const u = e.gl;
            this.buffer = u.createBuffer(), this.dynamicDraw = !!l, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), u.bufferData(u.ELEMENT_ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? u.DYNAMIC_DRAW : u.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer)
          }
          updateData(e) {
            const i = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), i.bufferSubData(i.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        const $o = {
          Int8: "BYTE",
          Uint8: "UNSIGNED_BYTE",
          Int16: "SHORT",
          Uint16: "UNSIGNED_SHORT",
          Int32: "INT",
          Uint32: "UNSIGNED_INT",
          Float32: "FLOAT"
        };
        class ru {
          constructor(e, i, l, u) {
            this.length = i.length, this.attributes = l, this.itemSize = i.bytesPerElement, this.dynamicDraw = u, this.context = e;
            const p = e.gl;
            this.buffer = p.createBuffer(), e.bindVertexBuffer.set(this.buffer), p.bufferData(p.ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? p.DYNAMIC_DRAW : p.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer)
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const i = this.context.gl;
            this.bind(), i.bufferSubData(i.ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          enableAttributes(e, i) {
            for (let l = 0; l < this.attributes.length; l++) {
              const u = i.attributes[this.attributes[l].name];
              u !== void 0 && e.enableVertexAttribArray(u)
            }
          }
          setVertexAttribPointers(e, i, l) {
            for (let u = 0; u < this.attributes.length; u++) {
              const p = this.attributes[u],
                v = i.attributes[p.name];
              v !== void 0 && e.vertexAttribPointer(v, p.components, e[$o[p.type]], !1, this.itemSize, p.offset + this.itemSize * (l || 0))
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        class Jn {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
          }
          get() {
            return this.current
          }
          set(e) {}
          getDefault() {
            return this.default
          }
          setDefault() {
            this.set(this.default)
          }
        }
        class mf extends Jn {
          getDefault() {
            return s.bi.transparent
          }
          set(e) {
            const i = this.current;
            (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class gf extends Jn {
          getDefault() {
            return 1
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1)
          }
        }
        class _f extends Jn {
          getDefault() {
            return 0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1)
          }
        }
        class pd extends Jn {
          getDefault() {
            return [!0, !0, !0, !0]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class vf extends Jn {
          getDefault() {
            return !0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1)
          }
        }
        class fd extends Jn {
          getDefault() {
            return 255
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Bl extends Jn {
          getDefault() {
            return {
              func: this.gl.ALWAYS,
              ref: 0,
              mask: 255
            }
          }
          set(e) {
            const i = this.current;
            (e.func !== i.func || e.ref !== i.ref || e.mask !== i.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1)
          }
        }
        class Ol extends Jn {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1)
          }
        }
        class Nl extends Jn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST), this.current = e, this.dirty = !1
          }
        }
        class nu extends Jn {
          getDefault() {
            return [0, 1]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Xo extends Jn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST), this.current = e, this.dirty = !1
          }
        }
        class Qs extends Jn {
          getDefault() {
            return this.gl.LESS
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1)
          }
        }
        class Ss extends Jn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.BLEND) : i.disable(i.BLEND), this.current = e, this.dirty = !1
          }
        }
        class Ba extends Jn {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class md extends Jn {
          getDefault() {
            return s.bi.transparent
          }
          set(e) {
            const i = this.current;
            (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class gd extends Jn {
          getDefault() {
            return this.gl.FUNC_ADD
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1)
          }
        }
        class iu extends Jn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.CULL_FACE) : i.disable(i.CULL_FACE), this.current = e, this.dirty = !1
          }
        }
        class Yo extends Jn {
          getDefault() {
            return this.gl.BACK
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1)
          }
        }
        class jl extends Jn {
          getDefault() {
            return this.gl.CCW
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1)
          }
        }
        class ql extends Jn {
          getDefault() {
            return null
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1)
          }
        }
        class el extends Jn {
          getDefault() {
            return this.gl.TEXTURE0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1)
          }
        }
        class Vl extends Jn {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class _d extends Jn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindFramebuffer(i.FRAMEBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Ps extends Jn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindRenderbuffer(i.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Cs extends Jn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindTexture(i.TEXTURE_2D, e), this.current = e, this.dirty = !1
          }
        }
        class vd extends Jn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindBuffer(i.ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class au extends Jn {
          getDefault() {
            return null
          }
          set(e) {
            const i = this.gl;
            i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Nn extends Jn {
          getDefault() {
            return null
          }
          set(e) {
            var i;
            if (e === this.current && !this.dirty) return;
            const l = this.gl;
            Ui(l) ? l.bindVertexArray(e) : (i = l.getExtension("OES_vertex_array_object")) === null || i === void 0 || i.bindVertexArrayOES(e), this.current = e, this.dirty = !1
          }
        }
        class Ul extends Jn {
          getDefault() {
            return 4
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1
          }
        }
        class yf extends Jn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class yd extends Jn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class Ko extends Jn {
          constructor(e, i) {
            super(e), this.context = e, this.parent = i
          }
          getDefault() {
            return null
          }
        }
        class xf extends Ko {
          setDirty() {
            this.dirty = !0
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1
          }
        }
        class bf extends Ko {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class xd extends Ko {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        const bd = "Framebuffer is not complete";
        class ou {
          constructor(e, i, l, u, p) {
            this.context = e, this.width = i, this.height = l;
            const v = e.gl,
              T = this.framebuffer = v.createFramebuffer();
            if (this.colorAttachment = new xf(e, T), u) this.depthAttachment = p ? new xd(e, T) : new bf(e, T);
            else if (p) throw new Error("Stencil cannot be set without depth");
            if (v.checkFramebufferStatus(v.FRAMEBUFFER) !== v.FRAMEBUFFER_COMPLETE) throw new Error(bd)
          }
          destroy() {
            const e = this.context.gl,
              i = this.colorAttachment.get();
            if (i && e.deleteTexture(i), this.depthAttachment) {
              const l = this.depthAttachment.get();
              l && e.deleteRenderbuffer(l)
            }
            e.deleteFramebuffer(this.framebuffer)
          }
        }
        class Zl {
          constructor(e) {
            var i, l;
            if (this.gl = e, this.clearColor = new mf(this), this.clearDepth = new gf(this), this.clearStencil = new _f(this), this.colorMask = new pd(this), this.depthMask = new vf(this), this.stencilMask = new fd(this), this.stencilFunc = new Bl(this), this.stencilOp = new Ol(this), this.stencilTest = new Nl(this), this.depthRange = new nu(this), this.depthTest = new Xo(this), this.depthFunc = new Qs(this), this.blend = new Ss(this), this.blendFunc = new Ba(this), this.blendColor = new md(this), this.blendEquation = new gd(this), this.cullFace = new iu(this), this.cullFaceSide = new Yo(this), this.frontFace = new jl(this), this.program = new ql(this), this.activeTexture = new el(this), this.viewport = new Vl(this), this.bindFramebuffer = new _d(this), this.bindRenderbuffer = new Ps(this), this.bindTexture = new Cs(this), this.bindVertexBuffer = new vd(this), this.bindElementBuffer = new au(this), this.bindVertexArray = new Nn(this), this.pixelStoreUnpack = new Ul(this), this.pixelStoreUnpackPremultiplyAlpha = new yf(this), this.pixelStoreUnpackFlipY = new yd(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Ui(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const u = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (i = e.RGBA16F) !== null && i !== void 0 ? i : u == null ? void 0 : u.RGBA16F_EXT, this.RGB16F = (l = e.RGB16F) !== null && l !== void 0 ? l : u == null ? void 0 : u.RGB16F_EXT, e.getExtension("EXT_color_buffer_float")
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const u = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = u == null ? void 0 : u.HALF_FLOAT_OES
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
          }
          createIndexBuffer(e, i) {
            return new tu(this, e, i)
          }
          createVertexBuffer(e, i, l) {
            return new ru(this, e, i, l)
          }
          createRenderbuffer(e, i, l) {
            const u = this.gl,
              p = u.createRenderbuffer();
            return this.bindRenderbuffer.set(p), u.renderbufferStorage(u.RENDERBUFFER, e, i, l), this.bindRenderbuffer.set(null), p
          }
          createFramebuffer(e, i, l, u) {
            return new ou(this, e, i, l, u)
          }
          clear({
            color: e,
            depth: i,
            stencil: l
          }) {
            const u = this.gl;
            let p = 0;
            e && (p |= u.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), i !== void 0 && (p |= u.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i), this.depthMask.set(!0)), l !== void 0 && (p |= u.STENCIL_BUFFER_BIT, this.clearStencil.set(l), this.stencilMask.set(255)), u.clear(p)
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace))
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1)
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
              func: e.test.func,
              ref: e.ref,
              mask: e.test.mask
            })) : this.stencilTest.set(!1)
          }
          setColorMode(e) {
            s.bK(e.blendFunction, zn.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask)
          }
          createVertexArray() {
            var e;
            return Ui(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
          }
          deleteVertexArray(e) {
            var i;
            return Ui(this.gl) ? this.gl.deleteVertexArray(e) : (i = this.gl.getExtension("OES_vertex_array_object")) === null || i === void 0 ? void 0 : i.deleteVertexArrayOES(e)
          }
          unbindVAO() {
            this.bindVertexArray.set(null)
          }
        }
        let Jo;

        function tl(h, e, i, l, u) {
          const p = h.context,
            v = h.transform,
            T = p.gl,
            S = h.useProgram("collisionBox"),
            k = [];
          let L = 0,
            V = 0;
          for (let de = 0; de < l.length; de++) {
            const ve = l[de],
              Ae = e.getTile(ve).getBucket(i);
            if (!Ae) continue;
            const _e = u ? Ae.textCollisionBox : Ae.iconCollisionBox,
              ke = Ae.collisionCircleArray;
            ke.length > 0 && (k.push({
              circleArray: ke,
              circleOffset: V,
              coord: ve
            }), L += ke.length / 4, V = L), _e && S.draw(p, T.LINES, _n.disabled, En.disabled, h.colorModeForRenderPass(), Sn.disabled, sd(h.transform), h.style.map.terrain && h.style.map.terrain.getTerrainData(ve), v.getProjectionData({
              overscaledTileID: ve,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }), i.id, _e.layoutVertexBuffer, _e.indexBuffer, _e.segments, null, h.transform.zoom, null, null, _e.collisionVertexBuffer)
          }
          if (!u || !k.length) return;
          const B = h.useProgram("collisionCircle"),
            H = new s.c3;
          H.resize(4 * L), H._trim();
          let re = 0;
          for (const de of k)
            for (let ve = 0; ve < de.circleArray.length / 4; ve++) {
              const Ae = 4 * ve,
                _e = de.circleArray[Ae + 0],
                ke = de.circleArray[Ae + 1],
                Fe = de.circleArray[Ae + 2],
                xe = de.circleArray[Ae + 3];
              H.emplace(re++, _e, ke, Fe, xe, 0), H.emplace(re++, _e, ke, Fe, xe, 1), H.emplace(re++, _e, ke, Fe, xe, 2), H.emplace(re++, _e, ke, Fe, xe, 3)
            }(!Jo || Jo.length < 2 * L) && (Jo = (function(de) {
              const ve = 2 * de,
                Ae = new s.c5;
              Ae.resize(ve), Ae._trim();
              for (let _e = 0; _e < ve; _e++) {
                const ke = 6 * _e;
                Ae.uint16[ke + 0] = 4 * _e + 0, Ae.uint16[ke + 1] = 4 * _e + 1, Ae.uint16[ke + 2] = 4 * _e + 2, Ae.uint16[ke + 3] = 4 * _e + 2, Ae.uint16[ke + 4] = 4 * _e + 3, Ae.uint16[ke + 5] = 4 * _e + 0
              }
              return Ae
            })(L));
          const le = p.createIndexBuffer(Jo, !0),
            ue = p.createVertexBuffer(H, s.c4.members, !0);
          for (const de of k) {
            const ve = Hc(h.transform);
            B.draw(p, T.TRIANGLES, _n.disabled, En.disabled, h.colorModeForRenderPass(), Sn.disabled, ve, h.style.map.terrain && h.style.map.terrain.getTerrainData(de.coord), null, i.id, ue, le, s.aQ.simpleSegment(0, 2 * de.circleOffset, de.circleArray.length, de.circleArray.length / 2), null, h.transform.zoom, null, null, null)
          }
          ue.destroy(), le.destroy()
        }
        const su = s.am(new Float32Array(16));

        function wd(h, e, i, l, u, p) {
          const {
            horizontalAlign: v,
            verticalAlign: T
          } = s.aL(h);
          return new s.P((-(v - .5) * e / u + l[0]) * p, (-(T - .5) * i / u + l[1]) * p)
        }

        function Gl(h, e, i, l, u, p) {
          const v = e.tileAnchorPoint.add(new s.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let T = l.mult(p);
            i || (T = T.rotate(-u));
            const S = v.add(T);
            return ot(S.x, S.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
          }
          if (i) {
            const T = mn(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(h),
              S = Math.atan(T.y / T.x) + (T.x < 0 ? Math.PI : 0);
            return h.add(l.rotate(S))
          }
          return h.add(l)
        }

        function Hl(h, e, i, l, u, p, v, T, S, k, L, V) {
          const B = h.text.placedSymbolArray,
            H = h.text.dynamicLayoutVertexArray,
            re = h.icon.dynamicLayoutVertexArray,
            le = {};
          H.clear();
          for (let ue = 0; ue < B.length; ue++) {
            const de = B.get(ue),
              ve = de.hidden || !de.crossTileID || h.allowVerticalPlacement && !de.placedOrientation ? null : l[de.crossTileID];
            if (ve) {
              const Ae = new s.P(de.anchorX, de.anchorY),
                _e = {
                  getElevation: V,
                  width: u.width,
                  height: u.height,
                  pitchedLabelPlaneMatrix: p,
                  pitchWithMap: i,
                  transform: u,
                  tileAnchorPoint: Ae,
                  translation: k,
                  unwrappedTileID: L
                },
                ke = i ? hn(Ae.x, Ae.y, _e) : mn(Ae.x, Ae.y, _e),
                Fe = dr(u.cameraToCenterDistance, ke.signedDistanceFromCamera);
              let xe = s.at(h.textSizeData, T, de) * Fe / s.aF;
              i && (xe *= h.tilePixelRatio / v);
              const {
                width: Ve,
                height: lt,
                anchor: rt,
                textOffset: at,
                textBoxScale: ct
              } = ve, er = wd(rt, Ve, lt, at, ct, xe), rr = u.getPitchedTextCorrection(Ae.x + k[0], Ae.y + k[1], L), kt = Gl(ke.point, _e, e, er, -u.bearingInRadians, rr), Br = h.allowVerticalPlacement && de.placedOrientation === s.as.vertical ? Math.PI / 2 : 0;
              for (let Pn = 0; Pn < de.numGlyphs; Pn++) s.az(H, kt, Br);
              S && de.associatedIconIndex >= 0 && (le[de.associatedIconIndex] = {
                shiftedAnchor: kt,
                angle: Br
              })
            } else kr(de.numGlyphs, H)
          }
          if (S) {
            re.clear();
            const ue = h.icon.placedSymbolArray;
            for (let de = 0; de < ue.length; de++) {
              const ve = ue.get(de);
              if (ve.hidden) kr(ve.numGlyphs, re);
              else {
                const Ae = le[de];
                if (Ae)
                  for (let _e = 0; _e < ve.numGlyphs; _e++) s.az(re, Ae.shiftedAnchor, Ae.angle);
                else kr(ve.numGlyphs, re)
              }
            }
            h.icon.dynamicLayoutVertexBuffer.updateData(re)
          }
          h.text.dynamicLayoutVertexBuffer.updateData(H)
        }

        function Wl(h, e, i) {
          return i.iconsInText && e ? "symbolTextAndIcon" : h ? "symbolSDF" : "symbolIcon"
        }

        function Qo(h, e, i, l, u, p, v, T, S, k, L, V, B) {
          const H = h.context,
            re = H.gl,
            le = h.transform,
            ue = T === "map",
            de = S === "map",
            ve = T !== "viewport" && i.layout.get("symbol-placement") !== "point",
            Ae = ue && !de && !ve,
            _e = !i.layout.get("symbol-sort-key").isConstant();
          let ke = !1;
          const Fe = h.getDepthModeForSublayer(0, _n.ReadOnly),
            xe = i._unevaluatedLayout.hasValue("text-variable-anchor") || i._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
            Ve = [],
            lt = le.getCircleRadiusCorrection();
          for (const rt of l) {
            const at = e.getTile(rt),
              ct = at.getBucket(i);
            if (!ct) continue;
            const er = u ? ct.text : ct.icon;
            if (!er || !er.segments.get().length || !er.hasVisibleVertices) continue;
            const rr = er.programConfigurations.get(i.id),
              kt = u || ct.sdfIcons,
              Br = u ? ct.textSizeData : ct.iconSizeData,
              Pn = de || le.pitch !== 0,
              ei = h.useProgram(Wl(kt, u, ct), rr),
              An = s.ar(Br, le.zoom),
              oi = h.style.map.terrain && h.style.map.terrain.getTerrainData(rt);
            let _i, li, Ei, di, Zi = [0, 0],
              pi = null;
            if (u) li = at.glyphAtlasTexture, Ei = re.LINEAR, _i = at.glyphAtlasTexture.size, ct.iconsInText && (Zi = at.imageAtlasTexture.size, pi = at.imageAtlasTexture, di = Pn || h.options.rotating || h.options.zooming || Br.kind === "composite" || Br.kind === "camera" ? re.LINEAR : re.NEAREST);
            else {
              const Ai = i.layout.get("icon-size").constantOr(0) !== 1 || ct.iconsNeedLinear;
              li = at.imageAtlasTexture, Ei = kt || h.options.rotating || h.options.zooming || Ai || Pn ? re.LINEAR : re.NEAREST, _i = at.imageAtlasTexture.size
            }
            const Mi = s.aG(at, 1, h.transform.zoom),
              da = br(ue, h.transform, Mi),
              as = s.M();
            s.au(as, da);
            const yo = Rr(de, ue, h.transform, Mi),
              no = s.aH(le, at, p, v),
              os = le.getProjectionData({
                overscaledTileID: rt,
                applyGlobeMatrix: !B,
                applyTerrainMatrix: !0
              }),
              Ds = xe && ct.hasTextData(),
              ss = i.layout.get("icon-text-fit") !== "none" && Ds && ct.hasIconData();
            if (ve) {
              const Ai = h.style.map.terrain ? (Gi, ui) => h.style.map.terrain.getElevation(rt, Gi, ui) : null,
                Pi = i.layout.get("text-rotation-alignment") === "map";
              Tt(ct, h, u, da, as, de, k, Pi, rt.toUnwrapped(), le.width, le.height, no, Ai)
            }
            const ya = u && xe || ss,
              pa = ve || ya ? su : de ? da : h.transform.clipSpaceToPixelsMatrix,
              xo = kt && i.paint.get(u ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Do;
            Do = kt ? ct.iconsInText ? po(Br.kind, An, Ae, de, ve, ya, h, pa, yo, no, _i, Zi, lt) : Js(Br.kind, An, Ae, de, ve, ya, h, pa, yo, no, u, _i, 0, lt) : Jc(Br.kind, An, Ae, de, ve, ya, h, pa, yo, no, u, _i, lt);
            const dl = {
              program: ei,
              buffers: er,
              uniformValues: Do,
              projectionData: os,
              atlasTexture: li,
              atlasTextureIcon: pi,
              atlasInterpolation: Ei,
              atlasInterpolationIcon: di,
              isSDF: kt,
              hasHalo: xo
            };
            if (_e && ct.canOverlap) {
              ke = !0;
              const Ai = er.segments.get();
              for (const Pi of Ai) Ve.push({
                segments: new s.aQ([Pi]),
                sortKey: Pi.sortKey,
                state: dl,
                terrainData: oi
              })
            } else Ve.push({
              segments: er.segments,
              sortKey: 0,
              state: dl,
              terrainData: oi
            })
          }
          ke && Ve.sort(((rt, at) => rt.sortKey - at.sortKey));
          for (const rt of Ve) {
            const at = rt.state;
            if (H.activeTexture.set(re.TEXTURE0), at.atlasTexture.bind(at.atlasInterpolation, re.CLAMP_TO_EDGE), at.atlasTextureIcon && (H.activeTexture.set(re.TEXTURE1), at.atlasTextureIcon && at.atlasTextureIcon.bind(at.atlasInterpolationIcon, re.CLAMP_TO_EDGE)), at.isSDF) {
              const ct = at.uniformValues;
              at.hasHalo && (ct.u_is_halo = 1, $l(at.buffers, rt.segments, i, h, at.program, Fe, L, V, ct, at.projectionData, rt.terrainData)), ct.u_is_halo = 0
            }
            $l(at.buffers, rt.segments, i, h, at.program, Fe, L, V, at.uniformValues, at.projectionData, rt.terrainData)
          }
        }

        function $l(h, e, i, l, u, p, v, T, S, k, L) {
          const V = l.context;
          u.draw(V, V.gl.TRIANGLES, p, v, T, Sn.backCCW, S, L, k, i.id, h.layoutVertexBuffer, h.indexBuffer, e, i.paint, l.transform.zoom, h.programConfigurations.get(i.id), h.dynamicLayoutVertexBuffer, h.opacityVertexBuffer)
        }

        function wf(h, e, i, l, u) {
          const p = h.context,
            v = p.gl,
            T = En.disabled,
            S = new zn([v.ONE, v.ONE], s.bi.transparent, [!0, !0, !0, !0]),
            k = e.getBucket(i);
          if (!k) return;
          const L = l.key;
          let V = i.heatmapFbos.get(L);
          V || (V = Td(p, e.tileSize, e.tileSize), i.heatmapFbos.set(L, V)), p.bindFramebuffer.set(V.framebuffer), p.viewport.set([0, 0, e.tileSize, e.tileSize]), p.clear({
            color: s.bi.transparent
          });
          const B = k.programConfigurations.get(i.id),
            H = h.useProgram("heatmap", B, !u),
            re = h.transform.getProjectionData({
              overscaledTileID: e.tileID,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }),
            le = h.style.map.terrain.getTerrainData(l);
          H.draw(p, v.TRIANGLES, _n.disabled, T, S, Sn.disabled, $c(e, h.transform.zoom, i.paint.get("heatmap-intensity"), 1), le, re, i.id, k.layoutVertexBuffer, k.indexBuffer, k.segments, i.paint, h.transform.zoom, B)
        }

        function rl(h, e, i, l, u) {
          const p = h.context,
            v = p.gl,
            T = h.transform;
          p.setColorMode(h.colorModeForRenderPass());
          const S = lu(p, e),
            k = i.key,
            L = e.heatmapFbos.get(k);
          if (!L) return;
          p.activeTexture.set(v.TEXTURE0), v.bindTexture(v.TEXTURE_2D, L.colorAttachment.get()), p.activeTexture.set(v.TEXTURE1), S.bind(v.LINEAR, v.CLAMP_TO_EDGE);
          const V = T.getProjectionData({
            overscaledTileID: i,
            applyTerrainMatrix: u,
            applyGlobeMatrix: !l
          });
          h.useProgram("heatmapTexture").draw(p, v.TRIANGLES, _n.disabled, En.disabled, h.colorModeForRenderPass(), Sn.disabled, Xc(h, e, 0, 1), null, V, e.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments, e.paint, T.zoom), L.destroy(), e.heatmapFbos.delete(k)
        }

        function Td(h, e, i) {
          var l, u;
          const p = h.gl,
            v = p.createTexture();
          p.bindTexture(p.TEXTURE_2D, v), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.LINEAR), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.LINEAR);
          const T = (l = h.HALF_FLOAT) !== null && l !== void 0 ? l : p.UNSIGNED_BYTE,
            S = (u = h.RGBA16F) !== null && u !== void 0 ? u : p.RGBA;
          p.texImage2D(p.TEXTURE_2D, 0, S, e, i, 0, p.RGBA, T, null);
          const k = h.createFramebuffer(e, i, !1, !1);
          return k.colorAttachment.set(v), k
        }

        function lu(h, e) {
          return e.colorRampTexture || (e.colorRampTexture = new s.T(h, e.colorRamp, h.gl.RGBA)), e.colorRampTexture
        }

        function nl(h, e, i, l, u, p, v, T) {
          let S = 256;
          if (u.stepInterpolant) {
            const k = e.getSource().maxzoom,
              L = v.canonical.z === k ? Math.ceil(1 << h.transform.maxZoom - v.canonical.z) : 1;
            S = s.ai(s.c7(p.maxLineLength / s.a3 * 1024 * L), 256, i.maxTextureSize)
          }
          return T.gradient = s.c8({
            expression: u.gradientExpression(),
            evaluationKey: "lineProgress",
            resolution: S,
            image: T.gradient || void 0,
            clips: p.lineClipsArray
          }), T.texture ? T.texture.update(T.gradient) : T.texture = new s.T(i, T.gradient, l.RGBA), T.version = u.gradientVersion, T.texture
        }

        function cu(h, e, i, l, u) {
          h.activeTexture.set(e.TEXTURE0), i.imageAtlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE), l.updatePaintBuffers(u)
        }

        function Sd(h, e, i, l, u, p) {
          (u || h.lineAtlas.dirty) && (e.activeTexture.set(i.TEXTURE0), h.lineAtlas.bind(e)), l.updatePaintBuffers(p)
        }

        function Pd(h, e, i, l, u, p, v) {
          const T = p.gradients[u.id];
          let S = T.texture;
          u.gradientVersion !== T.version && (S = nl(h, e, i, l, u, p, v, T)), i.activeTexture.set(l.TEXTURE0), S.bind(u.stepInterpolant ? l.NEAREST : l.LINEAR, l.CLAMP_TO_EDGE)
        }

        function Xl(h, e, i, l, u, p, v, T, S) {
          const k = p.gradients[u.id];
          let L = k.texture;
          u.gradientVersion !== k.version && (L = nl(h, e, i, l, u, p, v, k)), i.activeTexture.set(l.TEXTURE0), L.bind(u.stepInterpolant ? l.NEAREST : l.LINEAR, l.CLAMP_TO_EDGE), i.activeTexture.set(l.TEXTURE1), h.lineAtlas.bind(i), T.updatePaintBuffers(S)
        }

        function Yl(h, e, i, l, u) {
          if (!i || !l || !l.imageAtlas) return;
          const p = l.imageAtlas.patternPositions;
          let v = p[i.to.toString()],
            T = p[i.from.toString()];
          if (!v && T && (v = T), !T && v && (T = v), !v || !T) {
            const S = u.getPaintProperty(e);
            v = p[S], T = p[S]
          }
          v && T && h.setConstantPatternPositions(v, T)
        }

        function Cd(h, e, i, l, u, p, v, T) {
          const S = h.context.gl,
            k = "fill-pattern",
            L = i.paint.get(k),
            V = L && L.constantOr(1),
            B = i.getCrossfadeParameters();
          let H, re, le, ue, de;
          const ve = h.transform,
            Ae = i.paint.get("fill-translate"),
            _e = i.paint.get("fill-translate-anchor");
          v ? (re = V && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", H = S.LINES) : (re = V ? "fillPattern" : "fill", H = S.TRIANGLES);
          const ke = L.constantOr(null);
          for (const Fe of l) {
            const xe = e.getTile(Fe);
            if (V && !xe.patternsLoaded()) continue;
            const Ve = xe.getBucket(i);
            if (!Ve) continue;
            const lt = Ve.programConfigurations.get(i.id),
              rt = h.useProgram(re, lt),
              at = h.style.map.terrain && h.style.map.terrain.getTerrainData(Fe);
            V && (h.context.activeTexture.set(S.TEXTURE0), xe.imageAtlasTexture.bind(S.LINEAR, S.CLAMP_TO_EDGE), lt.updatePaintBuffers(B)), Yl(lt, k, ke, xe, i);
            const ct = ve.getProjectionData({
                overscaledTileID: Fe,
                applyGlobeMatrix: !T,
                applyTerrainMatrix: !0
              }),
              er = s.aH(ve, xe, Ae, _e);
            if (v) {
              ue = Ve.indexBuffer2, de = Ve.segments2;
              const kt = [S.drawingBufferWidth, S.drawingBufferHeight];
              le = re === "fillOutlinePattern" && V ? od(h, B, xe, kt, er) : uf(kt, er)
            } else ue = Ve.indexBuffer, de = Ve.segments, le = V ? Ho(h, B, xe, er) : {
              u_fill_translate: er
            };
            const rr = h.stencilModeForClipping(Fe);
            rt.draw(h.context, H, u, rr, p, Sn.backCCW, le, at, ct, i.id, Ve.layoutVertexBuffer, ue, de, i.paint, h.transform.zoom, lt)
          }
        }

        function Kl(h, e, i, l, u, p, v, T) {
          const S = h.context,
            k = S.gl,
            L = "fill-extrusion-pattern",
            V = i.paint.get(L),
            B = V.constantOr(1),
            H = i.getCrossfadeParameters(),
            re = i.paint.get("fill-extrusion-opacity"),
            le = V.constantOr(null),
            ue = h.transform;
          for (const de of l) {
            const ve = e.getTile(de),
              Ae = ve.getBucket(i);
            if (!Ae) continue;
            const _e = h.style.map.terrain && h.style.map.terrain.getTerrainData(de),
              ke = Ae.programConfigurations.get(i.id),
              Fe = h.useProgram(B ? "fillExtrusionPattern" : "fillExtrusion", ke);
            B && (h.context.activeTexture.set(k.TEXTURE0), ve.imageAtlasTexture.bind(k.LINEAR, k.CLAMP_TO_EDGE), ke.updatePaintBuffers(H));
            const xe = ue.getProjectionData({
              overscaledTileID: de,
              applyGlobeMatrix: !T,
              applyTerrainMatrix: !0
            });
            Yl(ke, L, le, ve, i);
            const Ve = s.aH(ue, ve, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")),
              lt = i.paint.get("fill-extrusion-vertical-gradient"),
              rt = B ? cf(h, lt, re, Ve, de, H, ve) : Ks(h, lt, re, Ve);
            Fe.draw(S, S.gl.TRIANGLES, u, p, v, Sn.backCCW, rt, _e, xe, i.id, Ae.layoutVertexBuffer, Ae.indexBuffer, Ae.segments, i.paint, h.transform.zoom, ke, h.style.map.terrain && Ae.centroidVertexBuffer)
          }
        }

        function mi(h, e, i, l, u, p, v, T, S) {
          var k;
          const L = h.style.projection,
            V = h.context,
            B = h.transform,
            H = V.gl,
            re = [`#define NUM_ILLUMINATION_SOURCES ${i.paint.get("hillshade-highlight-color").values.length}`],
            le = h.useProgram("hillshade", null, !1, re),
            ue = !h.options.moving;
          for (const de of l) {
            const ve = e.getTile(de),
              Ae = ve.fbo;
            if (!Ae) continue;
            const _e = L.getMeshFromTileID(V, de.canonical, T, !0, "raster"),
              ke = (k = h.style.map.terrain) === null || k === void 0 ? void 0 : k.getTerrainData(de);
            V.activeTexture.set(H.TEXTURE0), H.bindTexture(H.TEXTURE_2D, Ae.colorAttachment.get());
            const Fe = B.getProjectionData({
              overscaledTileID: de,
              aligned: ue,
              applyGlobeMatrix: !S,
              applyTerrainMatrix: !0
            });
            le.draw(V, H.TRIANGLES, p, u[de.overscaledZ], v, Sn.backCCW, ld(h, ve, i), ke, Fe, i.id, _e.vertexBuffer, _e.indexBuffer, _e.segments)
          }
        }

        function fo(h, e, i, l, u, p, v, T, S) {
          var k;
          const L = h.style.projection,
            V = h.context,
            B = h.transform,
            H = V.gl,
            re = h.useProgram("colorRelief"),
            le = !h.options.moving;
          let ue = !0,
            de = 0;
          for (const ve of l) {
            const Ae = e.getTile(ve),
              _e = Ae.dem;
            if (ue) {
              const rt = H.getParameter(H.MAX_TEXTURE_SIZE),
                {
                  elevationTexture: at,
                  colorTexture: ct
                } = i.getColorRampTextures(V, rt, _e.getUnpackVector());
              V.activeTexture.set(H.TEXTURE1), at.bind(H.NEAREST, H.CLAMP_TO_EDGE), V.activeTexture.set(H.TEXTURE4), ct.bind(H.LINEAR, H.CLAMP_TO_EDGE), ue = !1, de = at.size[0]
            }
            if (!_e || !_e.data) continue;
            const ke = _e.stride,
              Fe = _e.getPixels();
            if (V.activeTexture.set(H.TEXTURE0), V.pixelStoreUnpackPremultiplyAlpha.set(!1), Ae.demTexture = Ae.demTexture || h.getTileTexture(ke), Ae.demTexture) {
              const rt = Ae.demTexture;
              rt.update(Fe, {
                premultiply: !1
              }), rt.bind(H.LINEAR, H.CLAMP_TO_EDGE)
            } else Ae.demTexture = new s.T(V, Fe, H.RGBA, {
              premultiply: !1
            }), Ae.demTexture.bind(H.LINEAR, H.CLAMP_TO_EDGE);
            const xe = L.getMeshFromTileID(V, ve.canonical, T, !0, "raster"),
              Ve = (k = h.style.map.terrain) === null || k === void 0 ? void 0 : k.getTerrainData(ve),
              lt = B.getProjectionData({
                overscaledTileID: ve,
                aligned: le,
                applyGlobeMatrix: !S,
                applyTerrainMatrix: !0
              });
            re.draw(V, H.TRIANGLES, p, u[ve.overscaledZ], v, Sn.backCCW, ud(i, Ae.dem, de), Ve, lt, i.id, xe.vertexBuffer, xe.indexBuffer, xe.segments)
          }
        }
        const _a = [new s.P(0, 0), new s.P(s.a3, 0), new s.P(s.a3, s.a3), new s.P(0, s.a3)];

        function Is(h, e, i, l, u, p, v, T, S = !1, k = !1) {
          const L = l[l.length - 1].overscaledZ,
            V = h.context,
            B = V.gl,
            H = h.useProgram("raster"),
            re = h.transform,
            le = h.style.projection,
            ue = h.colorModeForRenderPass(),
            de = !h.options.moving,
            ve = i.paint.get("raster-opacity"),
            Ae = i.paint.get("raster-resampling"),
            _e = i.paint.get("raster-fade-duration"),
            ke = !!h.style.map.terrain;
          for (const Fe of l) {
            const xe = h.getDepthModeForSublayer(Fe.overscaledZ - L, ve === 1 ? _n.ReadWrite : _n.ReadOnly, B.LESS),
              Ve = e.getTile(Fe),
              lt = Ae === "nearest" ? B.NEAREST : B.LINEAR;
            V.activeTexture.set(B.TEXTURE0), Ve.texture.bind(lt, B.CLAMP_TO_EDGE, B.LINEAR_MIPMAP_NEAREST), V.activeTexture.set(B.TEXTURE1);
            const {
              parentTile: rt,
              parentScaleBy: at,
              parentTopLeft: ct,
              fadeValues: er
            } = Jl(Ve, e, _e, ke);
            Ve.fadeOpacity = er.tileOpacity, rt ? (rt.fadeOpacity = er.parentTileOpacity, rt.texture.bind(lt, B.CLAMP_TO_EDGE, B.LINEAR_MIPMAP_NEAREST)) : Ve.texture.bind(lt, B.CLAMP_TO_EDGE, B.LINEAR_MIPMAP_NEAREST), Ve.texture.useMipmap && V.extTextureFilterAnisotropic && h.transform.pitch > 20 && B.texParameterf(B.TEXTURE_2D, V.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, V.extTextureFilterAnisotropicMax);
            const rr = h.style.map.terrain && h.style.map.terrain.getTerrainData(Fe),
              kt = re.getProjectionData({
                overscaledTileID: Fe,
                aligned: de,
                applyGlobeMatrix: !k,
                applyTerrainMatrix: !0
              }),
              Br = hd(ct, at, er.fadeMix, i, T),
              Pn = le.getMeshFromTileID(V, Fe.canonical, p, v, "raster");
            H.draw(V, B.TRIANGLES, xe, u ? u[Fe.overscaledZ] : En.disabled, ue, S ? Sn.frontCCW : Sn.backCCW, Br, rr, kt, i.id, Pn.vertexBuffer, Pn.indexBuffer, Pn.segments)
          }
        }

        function Jl(h, e, i, l) {
          const u = {
            parentTile: null,
            parentScaleBy: 1,
            parentTopLeft: [0, 0],
            fadeValues: {
              tileOpacity: 1,
              parentTileOpacity: 1,
              fadeMix: {
                opacity: 1,
                mix: 0
              }
            }
          };
          if (i === 0 || l) return u;
          if (h.fadingParentID) {
            const p = e.getLoadedTile(h.fadingParentID);
            if (!p) return u;
            const v = Math.pow(2, p.tileID.overscaledZ - h.tileID.overscaledZ),
              T = [h.tileID.canonical.x * v % 1, h.tileID.canonical.y * v % 1],
              S = (function(k, L, V) {
                const B = ie(),
                  H = (B - L.timeAdded) / V,
                  re = k.fadingDirection === X.Incoming,
                  le = s.ai((B - k.timeAdded) / V, 0, 1),
                  ue = s.ai(1 - H, 0, 1),
                  de = re ? le : ue;
                return {
                  tileOpacity: de,
                  parentTileOpacity: re ? ue : le,
                  fadeMix: {
                    opacity: 1,
                    mix: 1 - de
                  }
                }
              })(h, p, i);
            return {
              parentTile: p,
              parentScaleBy: v,
              parentTopLeft: T,
              fadeValues: S
            }
          }
          if (h.selfFading) {
            const p = (function(v, T) {
              const S = (ie() - v.timeAdded) / T,
                k = s.ai(S, 0, 1);
              return {
                tileOpacity: k,
                fadeMix: {
                  opacity: k,
                  mix: 0
                }
              }
            })(h, i);
            return {
              parentTile: null,
              parentScaleBy: 1,
              parentTopLeft: [0, 0],
              fadeValues: p
            }
          }
          return u
        }
        const Id = new s.bi(1, 0, 0, 1),
          Ms = new s.bi(0, 1, 0, 1),
          uu = new s.bi(0, 0, 1, 1),
          il = new s.bi(1, 0, 1, 1),
          hu = new s.bi(0, 1, 1, 1);

        function du(h, e, i, l) {
          al(h, 0, e + i / 2, h.transform.width, i, l)
        }

        function pu(h, e, i, l) {
          al(h, e - i / 2, 0, i, h.transform.height, l)
        }

        function al(h, e, i, l, u, p) {
          const v = h.context,
            T = v.gl;
          T.enable(T.SCISSOR_TEST), T.scissor(e * h.pixelRatio, i * h.pixelRatio, l * h.pixelRatio, u * h.pixelRatio), v.clear({
            color: p
          }), T.disable(T.SCISSOR_TEST)
        }

        function Md(h, e, i) {
          const l = h.context,
            u = l.gl,
            p = h.useProgram("debug"),
            v = _n.disabled,
            T = En.disabled,
            S = h.colorModeForRenderPass(),
            k = "$debug",
            L = h.style.map.terrain && h.style.map.terrain.getTerrainData(i);
          l.activeTexture.set(u.TEXTURE0);
          const V = e.getTileByID(i.key).latestRawTileData,
            B = Math.floor((V && V.byteLength || 0) / 1024),
            H = e.getTile(i).tileSize,
            re = 512 / Math.min(H, 512) * (i.overscaledZ / h.transform.zoom) * .5;
          let le = i.canonical.toString();
          i.overscaledZ !== i.canonical.z && (le += ` => ${i.overscaledZ}`), (function(de, ve) {
            de.initDebugOverlayCanvas();
            const Ae = de.debugOverlayCanvas,
              _e = de.context.gl,
              ke = de.debugOverlayCanvas.getContext("2d");
            ke.clearRect(0, 0, Ae.width, Ae.height), ke.shadowColor = "white", ke.shadowBlur = 2, ke.lineWidth = 1.5, ke.strokeStyle = "white", ke.textBaseline = "top", ke.font = "bold 36px Open Sans, sans-serif", ke.fillText(ve, 5, 5), ke.strokeText(ve, 5, 5), de.debugOverlayTexture.update(Ae), de.debugOverlayTexture.bind(_e.LINEAR, _e.CLAMP_TO_EDGE)
          })(h, `${le} ${B}kB`);
          const ue = h.transform.getProjectionData({
            overscaledTileID: i,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0
          });
          p.draw(l, u.TRIANGLES, v, T, zn.alphaBlended, Sn.disabled, Wc(s.bi.transparent, re), null, ue, k, h.debugBuffer, h.quadTriangleIndexBuffer, h.debugSegments), p.draw(l, u.LINE_STRIP, v, T, S, Sn.disabled, Wc(s.bi.red), L, ue, k, h.debugBuffer, h.tileBorderIndexBuffer, h.debugSegments)
        }

        function fu(h, e, i, l) {
          const {
            isRenderingGlobe: u
          } = l, p = h.context, v = p.gl, T = h.transform, S = h.colorModeForRenderPass(), k = h.getDepthModeFor3D(), L = h.useProgram("terrain");
          p.bindFramebuffer.set(null), p.viewport.set([0, 0, h.width, h.height]);
          for (const V of i) {
            const B = e.getTerrainMesh(V.tileID),
              H = h.renderToTexture.getTexture(V),
              re = e.getTerrainData(V.tileID);
            p.activeTexture.set(v.TEXTURE0), v.bindTexture(v.TEXTURE_2D, H.texture);
            const le = e.getMeshFrameDelta(T.zoom),
              ue = T.calculateFogMatrix(V.tileID.toUnwrapped()),
              de = lf(le, ue, h.style.sky, T.pitch, u),
              ve = T.getProjectionData({
                overscaledTileID: V.tileID,
                applyTerrainMatrix: !1,
                applyGlobeMatrix: !0
              });
            L.draw(p, v.TRIANGLES, k, En.disabled, S, Sn.backCCW, de, re, ve, "terrain", B.vertexBuffer, B.indexBuffer, B.segments)
          }
        }

        function zo(h, e) {
          if (!e.mesh) {
            const i = new s.aP;
            i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1);
            const l = new s.aR;
            l.emplaceBack(0, 1, 2), l.emplaceBack(0, 2, 3), e.mesh = new Fn(h.createVertexBuffer(i, xn.members), h.createIndexBuffer(l), s.aQ.simpleSegment(0, 0, i.length, l.length))
          }
          return e.mesh
        }
        class Ad {
          constructor(e, i) {
            this.context = new Zl(e), this.transform = i, this._tileTextures = {}, this.terrainFacilitator = {
              dirty: !0,
              matrix: s.am(new Float64Array(16)),
              renderTime: 0
            }, this.setup(), this.numSublayers = Kt.maxUnderzooming + Kt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new vr
          }
          resize(e, i, l) {
            if (this.width = Math.floor(e * l), this.height = Math.floor(i * l), this.pixelRatio = l, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const u of this.style._order) this.style._layers[u].resize()
          }
          setup() {
            const e = this.context,
              i = new s.aP;
            i.emplaceBack(0, 0), i.emplaceBack(s.a3, 0), i.emplaceBack(0, s.a3), i.emplaceBack(s.a3, s.a3), this.tileExtentBuffer = e.createVertexBuffer(i, xn.members), this.tileExtentSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const l = new s.aP;
            l.emplaceBack(0, 0), l.emplaceBack(s.a3, 0), l.emplaceBack(0, s.a3), l.emplaceBack(s.a3, s.a3), this.debugBuffer = e.createVertexBuffer(l, xn.members), this.debugSegments = s.aQ.simpleSegment(0, 0, 4, 5);
            const u = new s.ca;
            u.emplaceBack(0, 0, 0, 0), u.emplaceBack(s.a3, 0, s.a3, 0), u.emplaceBack(0, s.a3, 0, s.a3), u.emplaceBack(s.a3, s.a3, s.a3, s.a3), this.rasterBoundsBuffer = e.createVertexBuffer(u, Zc.members), this.rasterBoundsSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const p = new s.aP;
            p.emplaceBack(0, 0), p.emplaceBack(s.a3, 0), p.emplaceBack(0, s.a3), p.emplaceBack(s.a3, s.a3), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(p, xn.members), this.rasterBoundsSegmentsPosOnly = s.aQ.simpleSegment(0, 0, 4, 5);
            const v = new s.aP;
            v.emplaceBack(0, 0), v.emplaceBack(1, 0), v.emplaceBack(0, 1), v.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(v, xn.members), this.viewportSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const T = new s.cb;
            T.emplaceBack(0), T.emplaceBack(1), T.emplaceBack(3), T.emplaceBack(2), T.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(T);
            const S = new s.aR;
            S.emplaceBack(1, 0, 2), S.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(S);
            const k = this.context.gl;
            this.stencilClearMode = new En({
              func: k.ALWAYS,
              mask: 0
            }, 0, 255, k.ZERO, k.ZERO, k.ZERO), this.tileExtentMesh = new Fn(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments)
          }
          clearStencil() {
            const e = this.context,
              i = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const l = s.M();
            s.c0(l, 0, this.width, this.height, 0, 0, 1), s.O(l, l, [i.drawingBufferWidth, i.drawingBufferHeight, 0]);
            const u = {
              mainMatrix: l,
              tileMercatorCoords: [0, 0, 1, 1],
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: l
            };
            this.useProgram("clippingMask", null, !0).draw(e, i.TRIANGLES, _n.disabled, this.stencilClearMode, zn.disabled, Sn.disabled, null, null, u, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
          }
          _renderTileClippingMasks(e, i, l) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !i || !i.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + i.length > 256 && this.clearStencil();
            const u = this.context;
            u.setColorMode(zn.disabled), u.setDepthMode(_n.disabled);
            const p = {};
            for (const v of i) p[v.key] = this.nextStencilID++;
            this._renderTileMasks(p, i, l, !0), this._renderTileMasks(p, i, l, !1), this._tileClippingMaskIDs = p
          }
          _renderTileMasks(e, i, l, u) {
            const p = this.context,
              v = p.gl,
              T = this.style.projection,
              S = this.transform,
              k = this.useProgram("clippingMask");
            for (const L of i) {
              const V = e[L.key],
                B = this.style.map.terrain && this.style.map.terrain.getTerrainData(L),
                H = T.getMeshFromTileID(this.context, L.canonical, u, !0, "stencil"),
                re = S.getProjectionData({
                  overscaledTileID: L,
                  applyGlobeMatrix: !l,
                  applyTerrainMatrix: !0
                });
              k.draw(p, v.TRIANGLES, _n.disabled, new En({
                func: v.ALWAYS,
                mask: 0
              }, V, 255, v.KEEP, v.KEEP, v.REPLACE), zn.disabled, l ? Sn.disabled : Sn.backCCW, null, B, re, "$clipping", H.vertexBuffer, H.indexBuffer, H.segments)
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context,
              i = e.gl,
              l = this.style.projection,
              u = this.transform,
              p = this.useProgram("depth"),
              v = this.getDepthModeFor3D(),
              T = Et(u, {
                tileSize: u.tileSize
              });
            for (const S of T) {
              const k = this.style.map.terrain && this.style.map.terrain.getTerrainData(S),
                L = l.getMeshFromTileID(this.context, S.canonical, !0, !0, "raster"),
                V = u.getProjectionData({
                  overscaledTileID: S,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0
                });
              p.draw(e, i.TRIANGLES, v, En.disabled, zn.disabled, Sn.backCCW, null, k, V, "$clipping", L.vertexBuffer, L.indexBuffer, L.segments)
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++,
              i = this.context.gl;
            return new En({
              func: i.NOTEQUAL,
              mask: 255
            }, e, 255, i.KEEP, i.KEEP, i.REPLACE)
          }
          stencilModeForClipping(e) {
            const i = this.context.gl;
            return new En({
              func: i.EQUAL,
              mask: 255
            }, this._tileClippingMaskIDs[e.key], 0, i.KEEP, i.KEEP, i.REPLACE)
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const i = this.context.gl,
              l = e.sort(((v, T) => T.overscaledZ - v.overscaledZ)),
              u = l[l.length - 1].overscaledZ,
              p = l[0].overscaledZ - u + 1;
            if (p > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + p > 256 && this.clearStencil();
              const v = {};
              for (let T = 0; T < p; T++) v[T + u] = new En({
                func: i.GEQUAL,
                mask: 255
              }, T + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);
              return this.nextStencilID += p, [v, l]
            }
            return [{
              [u]: En.disabled
            }, l]
          }
          stencilConfigForOverlapTwoPass(e) {
            const i = this.context.gl,
              l = e.sort(((v, T) => T.overscaledZ - v.overscaledZ)),
              u = l[l.length - 1].overscaledZ,
              p = l[0].overscaledZ - u + 1;
            if (this.clearStencil(), p > 1) {
              const v = {},
                T = {};
              for (let S = 0; S < p; S++) v[S + u] = new En({
                func: i.GREATER,
                mask: 255
              }, p + 1 + S, 255, i.KEEP, i.KEEP, i.REPLACE), T[S + u] = new En({
                func: i.GREATER,
                mask: 255
              }, 1 + S, 255, i.KEEP, i.KEEP, i.REPLACE);
              return this.nextStencilID = 2 * p + 1, [v, T, l]
            }
            return this.nextStencilID = 3, [{
              [u]: new En({
                func: i.GREATER,
                mask: 255
              }, 2, 255, i.KEEP, i.KEEP, i.REPLACE)
            }, {
              [u]: new En({
                func: i.GREATER,
                mask: 255
              }, 1, 255, i.KEEP, i.KEEP, i.REPLACE)
            }, l]
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new zn([e.CONSTANT_COLOR, e.ONE], new s.bi(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? zn.unblended : zn.alphaBlended
          }
          getDepthModeForSublayer(e, i, l) {
            if (!this.opaquePassEnabledForLayer()) return _n.disabled;
            const u = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new _n(l || this.context.gl.LEQUAL, i, [u, u])
          }
          getDepthModeFor3D() {
            return new _n(this.context.gl.LEQUAL, _n.ReadWrite, this.depthRangeFor3D)
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff
          }
          render(e, i) {
            var l, u;
            this.style = e, this.options = i, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(ie()), this.imageManager.beginFrame();
            const p = this.style._order,
              v = this.style.tileManagers,
              T = {},
              S = {},
              k = {},
              L = {
                isRenderingToTexture: !1,
                isRenderingGlobe: ((l = e.projection) === null || l === void 0 ? void 0 : l.transitionState) > 0
              };
            for (const B in v) {
              const H = v[B];
              H.used && H.prepare(this.context), T[B] = H.getVisibleCoordinates(!1), S[B] = T[B].slice().reverse(), k[B] = H.getVisibleCoordinates(!0).reverse()
            }
            this.opaquePassCutoff = 1 / 0;
            for (let B = 0; B < p.length; B++)
              if (this.style._layers[p[B]].is3D()) {
                this.opaquePassCutoff = B;
                break
              } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const B of p) {
              const H = this.style._layers[B];
              if (!H.hasOffscreenPass() || H.isHidden(this.transform.zoom)) continue;
              const re = S[H.source];
              (H.type === "custom" || re.length) && this.renderLayer(this, v[H.source], H, re, L)
            }
            if ((u = this.style.projection) === null || u === void 0 || u.updateGPUdependent({
                context: this.context,
                useProgram: B => this.useProgram(B)
              }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({
                color: i.showOverdrawInspector ? s.bi.black : s.bi.transparent,
                depth: 1
              }), this.clearStencil(), this.style.sky && (function(B, H) {
                const re = B.context,
                  le = re.gl,
                  ue = ((Fe, xe, Ve) => {
                    const lt = Math.cos(xe.rollInRadians),
                      rt = Math.sin(xe.rollInRadians),
                      at = K(xe),
                      ct = xe.getProjectionData({
                        overscaledTileID: null,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                      }).projectionTransition;
                    return {
                      u_sky_color: Fe.properties.get("sky-color"),
                      u_horizon_color: Fe.properties.get("horizon-color"),
                      u_horizon: [(xe.width / 2 - at * rt) * Ve, (xe.height / 2 + at * lt) * Ve],
                      u_horizon_normal: [-rt, lt],
                      u_sky_horizon_blend: Fe.properties.get("sky-horizon-blend") * xe.height / 2 * Ve,
                      u_sky_blend: ct
                    }
                  })(H, B.style.map.transform, B.pixelRatio),
                  de = new _n(le.LEQUAL, _n.ReadWrite, [0, 1]),
                  ve = En.disabled,
                  Ae = B.colorModeForRenderPass(),
                  _e = B.useProgram("sky"),
                  ke = zo(re, H);
                _e.draw(re, le.TRIANGLES, de, ve, Ae, Sn.disabled, ue, null, void 0, "sky", ke.vertexBuffer, ke.indexBuffer, ke.segments)
              })(this, this.style.sky), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = p.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const B = this.style._layers[p[this.currentLayer]],
                  H = v[B.source],
                  re = T[B.source];
                this._renderTileClippingMasks(B, re, !1), this.renderLayer(this, H, B, re, L)
              }
            this.renderPass = "translucent";
            let V = !1;
            for (this.currentLayer = 0; this.currentLayer < p.length; this.currentLayer++) {
              const B = this.style._layers[p[this.currentLayer]],
                H = v[B.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(B, L)) continue;
              this.opaquePassEnabledForLayer() || V || (V = !0, L.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const re = (B.type === "symbol" ? k : S)[B.source];
              this._renderTileClippingMasks(B, T[B.source], !!this.renderToTexture), this.renderLayer(this, H, B, re, L)
            }
            if (L.isRenderingGlobe && (function(B, H, re) {
                const le = B.context,
                  ue = le.gl,
                  de = B.useProgram("atmosphere"),
                  ve = new _n(ue.LEQUAL, _n.ReadOnly, [0, 1]),
                  Ae = B.transform,
                  _e = (function(ct, er) {
                    const rr = ct.properties.get("position"),
                      kt = [-rr.x, -rr.y, -rr.z],
                      Br = s.am(new Float64Array(16));
                    return ct.properties.get("anchor") === "map" && (s.b9(Br, Br, er.rollInRadians), s.ba(Br, Br, -er.pitchInRadians), s.b9(Br, Br, er.bearingInRadians), s.ba(Br, Br, er.center.lat * Math.PI / 180), s.bC(Br, Br, -er.center.lng * Math.PI / 180)), s.c9(kt, kt, Br), kt
                  })(re, B.transform),
                  ke = Ae.getProjectionData({
                    overscaledTileID: null,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0
                  }),
                  Fe = H.properties.get("atmosphere-blend") * ke.projectionTransition;
                if (Fe === 0) return;
                const xe = Zo(Ae.worldSize, Ae.center.lat),
                  Ve = Ae.inverseProjectionMatrix,
                  lt = new Float64Array(4);
                lt[3] = 1, s.aA(lt, lt, Ae.modelViewProjectionMatrix), lt[0] /= lt[3], lt[1] /= lt[3], lt[2] /= lt[3], lt[3] = 1, s.aA(lt, lt, Ve), lt[0] /= lt[3], lt[1] /= lt[3], lt[2] /= lt[3], lt[3] = 1;
                const rt = ((ct, er, rr, kt, Br) => ({
                    u_sun_pos: ct,
                    u_atmosphere_blend: er,
                    u_globe_position: rr,
                    u_globe_radius: kt,
                    u_inv_proj_matrix: Br
                  }))(_e, Fe, [lt[0], lt[1], lt[2]], xe, Ve),
                  at = zo(le, H);
                de.draw(le, ue.TRIANGLES, ve, En.disabled, zn.alphaBlended, Sn.disabled, rt, null, null, "atmosphere", at.vertexBuffer, at.indexBuffer, at.segments)
              })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const B = (function(H, re) {
                let le = null;
                const ue = Object.values(H._layers).flatMap((_e => _e.source && !_e.isHidden(re) ? [H.tileManagers[_e.source]] : [])),
                  de = ue.filter((_e => _e.getSource().type === "vector")),
                  ve = ue.filter((_e => _e.getSource().type !== "vector")),
                  Ae = _e => {
                    (!le || le.getSource().maxzoom < _e.getSource().maxzoom) && (le = _e)
                  };
                return de.forEach((_e => Ae(_e))), le || ve.forEach((_e => Ae(_e))), le
              })(this.style, this.transform.zoom);
              B && (function(H, re, le) {
                for (let ue = 0; ue < le.length; ue++) Md(H, re, le[ue])
              })(this, B, B.getVisibleCoordinates())
            }
            this.options.showPadding && (function(B) {
              const H = B.transform.padding;
              du(B, B.transform.height - (H.top || 0), 3, Id), du(B, H.bottom || 0, 3, Ms), pu(B, H.left || 0, 3, uu), pu(B, B.transform.width - (H.right || 0), 3, il);
              const re = B.transform.centerPoint;
              (function(le, ue, de, ve) {
                al(le, ue - 1, de - 10, 2, 20, ve), al(le, ue - 10, de - 1, 20, 2, ve)
              })(B, re.x, B.transform.height - re.y, hu)
            })(this), this.context.setDefault()
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const i = this.terrainFacilitator.matrix,
              l = this.transform.modelViewProjectionMatrix;
            let u = this.terrainFacilitator.dirty;
            u || (u = e ? !s.cc(i, l) : !s.cd(i, l)), u || (u = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), u && (s.ce(i, l), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(p, v) {
              const T = p.context,
                S = T.gl,
                k = p.transform,
                L = zn.unblended,
                V = new _n(S.LEQUAL, _n.ReadWrite, [0, 1]),
                B = v.tileManager.getRenderableTiles(),
                H = p.useProgram("terrainDepth");
              T.bindFramebuffer.set(v.getFramebuffer("depth").framebuffer), T.viewport.set([0, 0, p.width / devicePixelRatio, p.height / devicePixelRatio]), T.clear({
                color: s.bi.transparent,
                depth: 1
              });
              for (const re of B) {
                const le = v.getTerrainMesh(re.tileID),
                  ue = v.getTerrainData(re.tileID),
                  de = k.getProjectionData({
                    overscaledTileID: re.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  }),
                  ve = {
                    u_ele_delta: v.getMeshFrameDelta(k.zoom)
                  };
                H.draw(T, S.TRIANGLES, V, En.disabled, L, Sn.backCCW, ve, ue, de, "terrain", le.vertexBuffer, le.indexBuffer, le.segments)
              }
              T.bindFramebuffer.set(null), T.viewport.set([0, 0, p.width, p.height])
            })(this, this.style.map.terrain), (function(p, v) {
              const T = p.context,
                S = T.gl,
                k = p.transform,
                L = zn.unblended,
                V = new _n(S.LEQUAL, _n.ReadWrite, [0, 1]),
                B = v.getCoordsTexture(),
                H = v.tileManager.getRenderableTiles(),
                re = p.useProgram("terrainCoords");
              T.bindFramebuffer.set(v.getFramebuffer("coords").framebuffer), T.viewport.set([0, 0, p.width / devicePixelRatio, p.height / devicePixelRatio]), T.clear({
                color: s.bi.transparent,
                depth: 1
              }), v.coordsIndex = [];
              for (const le of H) {
                const ue = v.getTerrainMesh(le.tileID),
                  de = v.getTerrainData(le.tileID);
                T.activeTexture.set(S.TEXTURE0), S.bindTexture(S.TEXTURE_2D, B.texture);
                const ve = {
                    u_terrain_coords_id: (255 - v.coordsIndex.length) / 255,
                    u_texture: 0,
                    u_ele_delta: v.getMeshFrameDelta(k.zoom)
                  },
                  Ae = k.getProjectionData({
                    overscaledTileID: le.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  });
                re.draw(T, S.TRIANGLES, V, En.disabled, L, Sn.backCCW, ve, de, Ae, "terrain", ue.vertexBuffer, ue.indexBuffer, ue.segments), v.coordsIndex.push(le.tileID.key)
              }
              T.bindFramebuffer.set(null), T.viewport.set([0, 0, p.width, p.height])
            })(this, this.style.map.terrain))
          }
          renderLayer(e, i, l, u, p) {
            l.isHidden(this.transform.zoom) || (l.type === "background" || l.type === "custom" || (u || []).length) && (this.id = l.id, s.cf(l) ? (function(v, T, S, k, L, V) {
              if (v.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: B
              } = V, H = En.disabled, re = v.colorModeForRenderPass();
              (S._unevaluatedLayout.hasValue("text-variable-anchor") || S._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(le, ue, de, ve, Ae, _e, ke, Fe, xe) {
                const Ve = ue.transform,
                  lt = ue.style.map.terrain,
                  rt = Ae === "map",
                  at = _e === "map";
                for (const ct of le) {
                  const er = ve.getTile(ct),
                    rr = er.getBucket(de);
                  if (!rr || !rr.text || !rr.text.segments.get().length) continue;
                  const kt = s.ar(rr.textSizeData, Ve.zoom),
                    Br = s.aG(er, 1, ue.transform.zoom),
                    Pn = br(rt, ue.transform, Br),
                    ei = de.layout.get("icon-text-fit") !== "none" && rr.hasIconData();
                  if (kt) {
                    const An = Math.pow(2, Ve.zoom - er.tileID.overscaledZ),
                      oi = lt ? (_i, li) => lt.getElevation(ct, _i, li) : null;
                    Hl(rr, rt, at, xe, Ve, Pn, An, kt, ei, s.aH(Ve, er, ke, Fe), ct.toUnwrapped(), oi)
                  }
                }
              })(k, v, S, T, S.layout.get("text-rotation-alignment"), S.layout.get("text-pitch-alignment"), S.paint.get("text-translate"), S.paint.get("text-translate-anchor"), L), S.paint.get("icon-opacity").constantOr(1) !== 0 && Qo(v, T, S, k, !1, S.paint.get("icon-translate"), S.paint.get("icon-translate-anchor"), S.layout.get("icon-rotation-alignment"), S.layout.get("icon-pitch-alignment"), S.layout.get("icon-keep-upright"), H, re, B), S.paint.get("text-opacity").constantOr(1) !== 0 && Qo(v, T, S, k, !0, S.paint.get("text-translate"), S.paint.get("text-translate-anchor"), S.layout.get("text-rotation-alignment"), S.layout.get("text-pitch-alignment"), S.layout.get("text-keep-upright"), H, re, B), T.map.showCollisionBoxes && (tl(v, T, S, k, !0), tl(v, T, S, k, !1))
            })(e, i, l, u, this.style.placement.variableOffsets, p) : s.cg(l) ? (function(v, T, S, k, L) {
              if (v.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: V
              } = L, B = S.paint.get("circle-opacity"), H = S.paint.get("circle-stroke-width"), re = S.paint.get("circle-stroke-opacity"), le = !S.layout.get("circle-sort-key").isConstant();
              if (B.constantOr(1) === 0 && (H.constantOr(1) === 0 || re.constantOr(1) === 0)) return;
              const ue = v.context,
                de = ue.gl,
                ve = v.transform,
                Ae = v.getDepthModeForSublayer(0, _n.ReadOnly),
                _e = En.disabled,
                ke = v.colorModeForRenderPass(),
                Fe = [],
                xe = ve.getCircleRadiusCorrection();
              for (let Ve = 0; Ve < k.length; Ve++) {
                const lt = k[Ve],
                  rt = T.getTile(lt),
                  at = rt.getBucket(S);
                if (!at) continue;
                const ct = S.paint.get("circle-translate"),
                  er = S.paint.get("circle-translate-anchor"),
                  rr = s.aH(ve, rt, ct, er),
                  kt = at.programConfigurations.get(S.id),
                  Br = v.useProgram("circle", kt),
                  Pn = at.layoutVertexBuffer,
                  ei = at.indexBuffer,
                  An = v.style.map.terrain && v.style.map.terrain.getTerrainData(lt),
                  oi = {
                    programConfiguration: kt,
                    program: Br,
                    layoutVertexBuffer: Pn,
                    indexBuffer: ei,
                    uniformValues: hf(v, rt, S, rr, xe),
                    terrainData: An,
                    projectionData: ve.getProjectionData({
                      overscaledTileID: lt,
                      applyGlobeMatrix: !V,
                      applyTerrainMatrix: !0
                    })
                  };
                if (le) {
                  const _i = at.segments.get();
                  for (const li of _i) Fe.push({
                    segments: new s.aQ([li]),
                    sortKey: li.sortKey,
                    state: oi
                  })
                } else Fe.push({
                  segments: at.segments,
                  sortKey: 0,
                  state: oi
                })
              }
              le && Fe.sort(((Ve, lt) => Ve.sortKey - lt.sortKey));
              for (const Ve of Fe) {
                const {
                  programConfiguration: lt,
                  program: rt,
                  layoutVertexBuffer: at,
                  indexBuffer: ct,
                  uniformValues: er,
                  terrainData: rr,
                  projectionData: kt
                } = Ve.state;
                rt.draw(ue, de.TRIANGLES, Ae, _e, ke, Sn.backCCW, er, rr, kt, S.id, at, ct, Ve.segments, S.paint, v.transform.zoom, lt)
              }
            })(e, i, l, u, p) : s.ch(l) ? (function(v, T, S, k, L) {
              if (S.paint.get("heatmap-opacity") === 0) return;
              const V = v.context,
                {
                  isRenderingToTexture: B,
                  isRenderingGlobe: H
                } = L;
              if (v.style.map.terrain) {
                for (const re of k) {
                  const le = T.getTile(re);
                  T.hasRenderableParent(re) || (v.renderPass === "offscreen" ? wf(v, le, S, re, H) : v.renderPass === "translucent" && rl(v, S, re, B, H))
                }
                V.viewport.set([0, 0, v.width, v.height])
              } else v.renderPass === "offscreen" ? (function(re, le, ue, de) {
                const ve = re.context,
                  Ae = ve.gl,
                  _e = re.transform,
                  ke = En.disabled,
                  Fe = new zn([Ae.ONE, Ae.ONE], s.bi.transparent, [!0, !0, !0, !0]);
                (function(xe, Ve, lt) {
                  const rt = xe.gl;
                  xe.activeTexture.set(rt.TEXTURE1), xe.viewport.set([0, 0, Ve.width / 4, Ve.height / 4]);
                  let at = lt.heatmapFbos.get(s.c6);
                  at ? (rt.bindTexture(rt.TEXTURE_2D, at.colorAttachment.get()), xe.bindFramebuffer.set(at.framebuffer)) : (at = Td(xe, Ve.width / 4, Ve.height / 4), lt.heatmapFbos.set(s.c6, at))
                })(ve, re, ue), ve.clear({
                  color: s.bi.transparent
                });
                for (let xe = 0; xe < de.length; xe++) {
                  const Ve = de[xe];
                  if (le.hasRenderableParent(Ve)) continue;
                  const lt = le.getTile(Ve),
                    rt = lt.getBucket(ue);
                  if (!rt) continue;
                  const at = rt.programConfigurations.get(ue.id),
                    ct = re.useProgram("heatmap", at),
                    er = _e.getProjectionData({
                      overscaledTileID: Ve,
                      applyGlobeMatrix: !0,
                      applyTerrainMatrix: !1
                    }),
                    rr = _e.getCircleRadiusCorrection();
                  ct.draw(ve, Ae.TRIANGLES, _n.disabled, ke, Fe, Sn.backCCW, $c(lt, _e.zoom, ue.paint.get("heatmap-intensity"), rr), null, er, ue.id, rt.layoutVertexBuffer, rt.indexBuffer, rt.segments, ue.paint, _e.zoom, at)
                }
                ve.viewport.set([0, 0, re.width, re.height])
              })(v, T, S, k) : v.renderPass === "translucent" && (function(re, le) {
                const ue = re.context,
                  de = ue.gl;
                ue.setColorMode(re.colorModeForRenderPass());
                const ve = le.heatmapFbos.get(s.c6);
                ve && (ue.activeTexture.set(de.TEXTURE0), de.bindTexture(de.TEXTURE_2D, ve.colorAttachment.get()), ue.activeTexture.set(de.TEXTURE1), lu(ue, le).bind(de.LINEAR, de.CLAMP_TO_EDGE), re.useProgram("heatmapTexture").draw(ue, de.TRIANGLES, _n.disabled, En.disabled, re.colorModeForRenderPass(), Sn.disabled, Xc(re, le, 0, 1), null, null, le.id, re.viewportBuffer, re.quadTriangleIndexBuffer, re.viewportSegments, le.paint, re.transform.zoom))
              })(v, S)
            })(e, i, l, u, p) : s.ci(l) ? (function(v, T, S, k, L) {
              if (v.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: V
              } = L, B = S.paint.get("line-opacity"), H = S.paint.get("line-width");
              if (B.constantOr(1) === 0 || H.constantOr(1) === 0) return;
              const re = v.getDepthModeForSublayer(0, _n.ReadOnly),
                le = v.colorModeForRenderPass(),
                ue = S.paint.get("line-dasharray"),
                de = ue.constantOr(1),
                ve = S.paint.get("line-pattern"),
                Ae = ve.constantOr(1),
                _e = S.paint.get("line-gradient"),
                ke = S.getCrossfadeParameters();
              let Fe;
              Fe = Ae ? "linePattern" : de && _e ? "lineGradientSDF" : de ? "lineSDF" : _e ? "lineGradient" : "line";
              const xe = v.context,
                Ve = xe.gl,
                lt = v.transform;
              let rt = !0;
              for (const at of k) {
                const ct = T.getTile(at);
                if (Ae && !ct.patternsLoaded()) continue;
                const er = ct.getBucket(S);
                if (!er) continue;
                const rr = er.programConfigurations.get(S.id),
                  kt = v.context.program.get(),
                  Br = v.useProgram(Fe, rr),
                  Pn = rt || Br.program !== kt,
                  ei = v.style.map.terrain && v.style.map.terrain.getTerrainData(at),
                  An = ve.constantOr(null),
                  oi = ue && ue.constantOr(null);
                if (An && ct.imageAtlas) {
                  const Zi = ct.imageAtlas,
                    pi = Zi.patternPositions[An.to.toString()],
                    Mi = Zi.patternPositions[An.from.toString()];
                  pi && Mi && rr.setConstantPatternPositions(pi, Mi)
                } else if (oi) {
                  const Zi = S.layout.get("line-cap") === "round",
                    pi = v.lineAtlas.getDash(oi.to, Zi),
                    Mi = v.lineAtlas.getDash(oi.from, Zi);
                  rr.setConstantDashPositions(pi, Mi)
                }
                const _i = lt.getProjectionData({
                    overscaledTileID: at,
                    applyGlobeMatrix: !V,
                    applyTerrainMatrix: !0
                  }),
                  li = lt.getPixelScale();
                let Ei;
                Ae ? (Ei = Dl(v, ct, S, li, ke), cu(xe, Ve, ct, rr, ke)) : de && _e ? (Ei = ff(v, ct, S, li, ke, er.lineClipsArray.length), Xl(v, T, xe, Ve, S, er, at, rr, ke)) : de ? (Ei = pf(v, ct, S, li, ke), Sd(v, xe, Ve, rr, Pn, ke)) : _e ? (Ei = df(v, ct, S, li, er.lineClipsArray.length), Pd(v, T, xe, Ve, S, er, at)) : Ei = Lo(v, ct, S, li);
                const di = v.stencilModeForClipping(at);
                Br.draw(xe, Ve.TRIANGLES, re, di, le, Sn.disabled, Ei, ei, _i, S.id, er.layoutVertexBuffer, er.indexBuffer, er.segments, S.paint, v.transform.zoom, rr, er.layoutVertexBuffer2), rt = !1
              }
            })(e, i, l, u, p) : s.cj(l) ? (function(v, T, S, k, L) {
              const V = S.paint.get("fill-color"),
                B = S.paint.get("fill-opacity");
              if (B.constantOr(1) === 0) return;
              const {
                isRenderingToTexture: H
              } = L, re = v.colorModeForRenderPass(), le = S.paint.get("fill-pattern"), ue = v.opaquePassEnabledForLayer() && !le.constantOr(1) && V.constantOr(s.bi.transparent).a === 1 && B.constantOr(0) === 1 ? "opaque" : "translucent";
              if (v.renderPass === ue) {
                const de = v.getDepthModeForSublayer(1, v.renderPass === "opaque" ? _n.ReadWrite : _n.ReadOnly);
                Cd(v, T, S, k, de, re, !1, H)
              }
              if (v.renderPass === "translucent" && S.paint.get("fill-antialias")) {
                const de = v.getDepthModeForSublayer(S.getPaintProperty("fill-outline-color") ? 2 : 0, _n.ReadOnly);
                Cd(v, T, S, k, de, re, !0, H)
              }
            })(e, i, l, u, p) : s.ck(l) ? (function(v, T, S, k, L) {
              const V = S.paint.get("fill-extrusion-opacity");
              if (V === 0) return;
              const {
                isRenderingToTexture: B
              } = L;
              if (v.renderPass === "translucent") {
                const H = new _n(v.context.gl.LEQUAL, _n.ReadWrite, v.depthRangeFor3D);
                if (V !== 1 || S.paint.get("fill-extrusion-pattern").constantOr(1)) Kl(v, T, S, k, H, En.disabled, zn.disabled, B), Kl(v, T, S, k, H, v.stencilModeFor3D(), v.colorModeForRenderPass(), B);
                else {
                  const re = v.colorModeForRenderPass();
                  Kl(v, T, S, k, H, En.disabled, re, B)
                }
              }
            })(e, i, l, u, p) : s.cl(l) ? (function(v, T, S, k, L) {
              if (v.renderPass !== "offscreen" && v.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: V
              } = L, B = v.context, H = v.style.projection.useSubdivision, re = v.getDepthModeForSublayer(0, _n.ReadOnly), le = v.colorModeForRenderPass();
              if (v.renderPass === "offscreen")(function(ue, de, ve, Ae, _e, ke, Fe) {
                const xe = ue.context,
                  Ve = xe.gl;
                for (const lt of ve) {
                  const rt = de.getTile(lt),
                    at = rt.dem;
                  if (!at || !at.data || !rt.needsHillshadePrepare) continue;
                  const ct = at.dim,
                    er = at.stride,
                    rr = at.getPixels();
                  if (xe.activeTexture.set(Ve.TEXTURE1), xe.pixelStoreUnpackPremultiplyAlpha.set(!1), rt.demTexture = rt.demTexture || ue.getTileTexture(er), rt.demTexture) {
                    const Br = rt.demTexture;
                    Br.update(rr, {
                      premultiply: !1
                    }), Br.bind(Ve.NEAREST, Ve.CLAMP_TO_EDGE)
                  } else rt.demTexture = new s.T(xe, rr, Ve.RGBA, {
                    premultiply: !1
                  }), rt.demTexture.bind(Ve.NEAREST, Ve.CLAMP_TO_EDGE);
                  xe.activeTexture.set(Ve.TEXTURE0);
                  let kt = rt.fbo;
                  if (!kt) {
                    const Br = new s.T(xe, {
                      width: ct,
                      height: ct,
                      data: null
                    }, Ve.RGBA);
                    Br.bind(Ve.LINEAR, Ve.CLAMP_TO_EDGE), kt = rt.fbo = xe.createFramebuffer(ct, ct, !0, !1), kt.colorAttachment.set(Br.texture)
                  }
                  xe.bindFramebuffer.set(kt.framebuffer), xe.viewport.set([0, 0, ct, ct]), ue.useProgram("hillshadePrepare").draw(xe, Ve.TRIANGLES, _e, ke, Fe, Sn.disabled, Wo(rt.tileID, at), null, null, Ae.id, ue.rasterBoundsBuffer, ue.quadTriangleIndexBuffer, ue.rasterBoundsSegments), rt.needsHillshadePrepare = !1
                }
              })(v, T, k, S, re, En.disabled, le), B.viewport.set([0, 0, v.width, v.height]);
              else if (v.renderPass === "translucent")
                if (H) {
                  const [ue, de, ve] = v.stencilConfigForOverlapTwoPass(k);
                  mi(v, T, S, ve, ue, re, le, !1, V), mi(v, T, S, ve, de, re, le, !0, V)
                } else {
                  const [ue, de] = v.getStencilConfigForOverlapAndUpdateStencilID(k);
                  mi(v, T, S, de, ue, re, le, !1, V)
                }
            })(e, i, l, u, p) : s.cm(l) ? (function(v, T, S, k, L) {
              if (v.renderPass !== "translucent" || !k.length) return;
              const {
                isRenderingToTexture: V
              } = L, B = v.style.projection.useSubdivision, H = v.getDepthModeForSublayer(0, _n.ReadOnly), re = v.colorModeForRenderPass();
              if (B) {
                const [le, ue, de] = v.stencilConfigForOverlapTwoPass(k);
                fo(v, T, S, de, le, H, re, !1, V), fo(v, T, S, de, ue, H, re, !0, V)
              } else {
                const [le, ue] = v.getStencilConfigForOverlapAndUpdateStencilID(k);
                fo(v, T, S, ue, le, H, re, !1, V)
              }
            })(e, i, l, u, p) : s.bN(l) ? (function(v, T, S, k, L) {
              if (v.renderPass !== "translucent" || S.paint.get("raster-opacity") === 0 || !k.length) return;
              const {
                isRenderingToTexture: V
              } = L, B = T.getSource(), H = v.style.projection.useSubdivision;
              if (B instanceof Tr) Is(v, T, S, k, null, !1, !1, B.tileCoords, B.flippedWindingOrder, V);
              else if (H) {
                const [re, le, ue] = v.stencilConfigForOverlapTwoPass(k);
                Is(v, T, S, ue, re, !1, !0, _a, !1, V), Is(v, T, S, ue, le, !0, !0, _a, !1, V)
              } else {
                const [re, le] = v.getStencilConfigForOverlapAndUpdateStencilID(k);
                Is(v, T, S, le, re, !1, !0, _a, !1, V)
              }
            })(e, i, l, u, p) : s.cn(l) ? (function(v, T, S, k, L) {
              const V = S.paint.get("background-color"),
                B = S.paint.get("background-opacity");
              if (B === 0) return;
              const {
                isRenderingToTexture: H
              } = L, re = v.context, le = re.gl, ue = v.style.projection, de = v.transform, ve = de.tileSize, Ae = S.paint.get("background-pattern");
              if (v.isPatternMissing(Ae)) return;
              const _e = !Ae && V.a === 1 && B === 1 && v.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (v.renderPass !== _e) return;
              const ke = En.disabled,
                Fe = v.getDepthModeForSublayer(0, _e === "opaque" ? _n.ReadWrite : _n.ReadOnly),
                xe = v.colorModeForRenderPass(),
                Ve = v.useProgram(Ae ? "backgroundPattern" : "background"),
                lt = k || Et(de, {
                  tileSize: ve,
                  terrain: v.style.map.terrain
                });
              Ae && (re.activeTexture.set(le.TEXTURE0), v.imageManager.bind(v.context));
              const rt = S.getCrossfadeParameters();
              for (const at of lt) {
                const ct = de.getProjectionData({
                    overscaledTileID: at,
                    applyGlobeMatrix: !H,
                    applyTerrainMatrix: !0
                  }),
                  er = Ae ? eu(B, v, Ae, {
                    tileID: at,
                    tileSize: ve
                  }, rt) : Qc(B, V),
                  rr = v.style.map.terrain && v.style.map.terrain.getTerrainData(at),
                  kt = ue.getMeshFromTileID(re, at.canonical, !1, !0, "raster");
                Ve.draw(re, le.TRIANGLES, Fe, ke, xe, Sn.backCCW, er, rr, ct, S.id, kt.vertexBuffer, kt.indexBuffer, kt.segments)
              }
            })(e, 0, l, u, p) : s.co(l) && (function(v, T, S, k) {
              const {
                isRenderingGlobe: L
              } = k, V = v.context, B = S.implementation, H = v.style.projection, re = v.transform, le = re.getProjectionDataForCustomLayer(L), ue = {
                farZ: re.farZ,
                nearZ: re.nearZ,
                fov: re.fov * Math.PI / 180,
                modelViewProjectionMatrix: re.modelViewProjectionMatrix,
                projectionMatrix: re.projectionMatrix,
                shaderData: {
                  variantName: H.shaderVariantName,
                  vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${H.shaderPreludeCode.vertexSource}`,
                  define: H.shaderDefine
                },
                defaultProjectionData: le
              }, de = B.renderingMode ? B.renderingMode : "2d";
              if (v.renderPass === "offscreen") {
                const ve = B.prerender;
                ve && (v.setCustomLayerDefaults(), V.setColorMode(v.colorModeForRenderPass()), ve.call(B, V.gl, ue), V.setDirty(), v.setBaseState())
              } else if (v.renderPass === "translucent") {
                v.setCustomLayerDefaults(), V.setColorMode(v.colorModeForRenderPass()), V.setStencilMode(En.disabled);
                const ve = de === "3d" ? v.getDepthModeFor3D() : v.getDepthModeForSublayer(0, _n.ReadOnly);
                V.setDepthMode(ve), B.render(V.gl, ue), V.setDirty(), v.setBaseState(), V.bindFramebuffer.set(null)
              }
            })(e, 0, l, p))
          }
          saveTileTexture(e) {
            const i = this._tileTextures[e.size[0]];
            i ? i.push(e) : this._tileTextures[e.size[0]] = [e]
          }
          getTileTexture(e) {
            const i = this._tileTextures[e];
            return i && i.length > 0 ? i.pop() : null
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const i = this.imageManager.getPattern(e.from.toString()),
              l = this.imageManager.getPattern(e.to.toString());
            return !i || !l
          }
          useProgram(e, i, l = !1, u = []) {
            this.cache = this.cache || {};
            const p = !!this.style.map.terrain,
              v = this.style.projection,
              T = l ? gr.projectionMercator : v.shaderPreludeCode,
              S = l ? In : v.shaderDefine,
              k = e + (i ? i.cacheKey : "") + `/${l?qn:v.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (p ? "/terrain" : "") + (u ? `/${u.join("/")}` : "");
            return this.cache[k] || (this.cache[k] = new Ys(this.context, gr[e], i, dd[e], this._showOverdrawInspector, p, T, S, u)), this.cache[k]
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD)
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new s.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA))
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy()
          }
          overLimit() {
            const {
              drawingBufferWidth: e,
              drawingBufferHeight: i
            } = this.context.gl;
            return this.width !== e || this.height !== i
          }
        }

        function mu(h, e) {
          let i, l = !1,
            u = null,
            p = null;
          const v = () => {
            u = null, l && (h.apply(p, i), u = setTimeout(v, e), l = !1)
          };
          return (...T) => (l = !0, p = this, i = T, u || v(), u)
        }
        class gu {
          constructor(e) {
            this._getCurrentHash = () => {
              const i = window.location.hash.replace("#", "");
              if (this._hashName) {
                let l;
                return i.split("&").map((u => u.split("="))).forEach((u => {
                  u[0] === this._hashName && (l = u)
                })), (l && l[1] || "").split("/")
              }
              return i.split("/")
            }, this._onHashChange = () => {
              const i = this._getCurrentHash();
              if (!this._isValidHash(i)) return !1;
              const l = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(i[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({
                center: [+i[2], +i[1]],
                zoom: +i[0],
                bearing: l,
                pitch: +(i[4] || 0)
              }), !0
            }, this._updateHashUnthrottled = () => {
              const i = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, i)
            }, this._removeHash = () => {
              const i = this._getCurrentHash();
              if (i.length === 0) return;
              const l = i.join("/");
              let u = l;
              u.split("&").length > 0 && (u = u.split("&")[0]), this._hashName && (u = `${this._hashName}=${l}`);
              let p = window.location.hash.replace(u, "");
              p.startsWith("#&") ? p = p.slice(0, 1) + p.slice(2) : p === "#" && (p = "");
              let v = window.location.href.replace(/(#.+)?$/, p);
              v = v.replace("&&", "&"), window.history.replaceState(window.history.state, null, v)
            }, this._updateHash = mu(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e)
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this
          }
          getHashString(e) {
            const i = this._map.getCenter(),
              l = Math.round(100 * this._map.getZoom()) / 100,
              u = Math.ceil((l * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
              p = Math.pow(10, u),
              v = Math.round(i.lng * p) / p,
              T = Math.round(i.lat * p) / p,
              S = this._map.getBearing(),
              k = this._map.getPitch();
            let L = "";
            if (L += e ? `/${v}/${T}/${l}` : `${l}/${T}/${v}`, (S || k) && (L += "/" + Math.round(10 * S) / 10), k && (L += `/${Math.round(k)}`), this._hashName) {
              const V = this._hashName;
              let B = !1;
              const H = window.location.hash.slice(1).split("&").map((re => {
                const le = re.split("=")[0];
                return le === V ? (B = !0, `${le}=${L}`) : re
              })).filter((re => re));
              return B || H.push(`${V}=${L}`), `#${H.join("&")}`
            }
            return `#${L}`
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new s.U(+e[2], +e[1])
            } catch {
              return !1
            }
            const i = +e[0],
              l = +(e[3] || 0),
              u = +(e[4] || 0);
            return i >= this._map.getMinZoom() && i <= this._map.getMaxZoom() && l >= -180 && l <= 180 && u >= this._map.getMinPitch() && u <= this._map.getMaxPitch()
          }
        }
        const As = {
            linearity: .3,
            easing: s.cp(0, 0, .3, 1)
          },
          kd = s.e({
            deceleration: 2500,
            maxSpeed: 1400
          }, As),
          Ed = s.e({
            deceleration: 20,
            maxSpeed: 1400
          }, As),
          Ld = s.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, As),
          zd = s.e({
            deceleration: 1e3,
            maxSpeed: 90
          }, As),
          Ql = s.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, As);
        class Dd {
          constructor(e) {
            this._map = e, this.clear()
          }
          clear() {
            this._inertiaBuffer = []
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({
              time: ie(),
              settings: e
            })
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer,
              i = ie();
            for (; e.length > 0 && i - e[0].time > 160;) e.shift()
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const i = {
              zoom: 0,
              bearing: 0,
              pitch: 0,
              roll: 0,
              pan: new s.P(0, 0),
              pinchAround: void 0,
              around: void 0
            };
            for (const {
                settings: p
              }
              of this._inertiaBuffer) i.zoom += p.zoomDelta || 0, i.bearing += p.bearingDelta || 0, i.pitch += p.pitchDelta || 0, i.roll += p.rollDelta || 0, p.panDelta && i.pan._add(p.panDelta), p.around && (i.around = p.around), p.pinchAround && (i.pinchAround = p.pinchAround);
            const l = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
              u = {};
            if (i.pan.mag()) {
              const p = ua(i.pan.mag(), l, s.e({}, kd, e || {})),
                v = i.pan.mult(p.amount / i.pan.mag()),
                T = this._map.cameraHelper.handlePanInertia(v, this._map.transform);
              u.center = T.easingCenter, u.offset = T.easingOffset, ra(u, p)
            }
            if (i.zoom) {
              const p = ua(i.zoom, l, Ed);
              u.zoom = this._map.transform.zoom + p.amount, ra(u, p)
            }
            if (i.bearing) {
              const p = ua(i.bearing, l, Ld);
              u.bearing = this._map.transform.bearing + s.ai(p.amount, -179, 179), ra(u, p)
            }
            if (i.pitch) {
              const p = ua(i.pitch, l, zd);
              u.pitch = this._map.transform.pitch + p.amount, ra(u, p)
            }
            if (i.roll) {
              const p = ua(i.roll, l, Ql);
              u.roll = this._map.transform.roll + s.ai(p.amount, -179, 179), ra(u, p)
            }
            if (u.zoom || u.bearing) {
              const p = i.pinchAround === void 0 ? i.around : i.pinchAround;
              u.around = p ? this._map.unproject(p) : this._map.getCenter()
            }
            return this.clear(), s.e(u, {
              noMoveStart: !0
            })
          }
        }

        function ra(h, e) {
          (!h.duration || h.duration < e.duration) && (h.duration = e.duration, h.easing = e.easing)
        }

        function ua(h, e, i) {
          const {
            maxSpeed: l,
            linearity: u,
            deceleration: p
          } = i, v = s.ai(h * u / (e / 1e3), -l, l), T = Math.abs(v) / (p * u);
          return {
            easing: i.easing,
            duration: 1e3 * T,
            amount: v * (T / 2)
          }
        }
        class va extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, i, l, u = {}) {
            l = l instanceof MouseEvent ? l : new MouseEvent(e, l);
            const p = $.mousePos(i.getCanvas(), l),
              v = i.unproject(p);
            super(e, s.e({
              point: p,
              lngLat: v,
              originalEvent: l
            }, u)), this._defaultPrevented = !1, this.target = i
          }
        }
        class ha extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, i, l) {
            const u = e === "touchend" ? l.changedTouches : l.touches,
              p = $.touchPos(i.getCanvasContainer(), u),
              v = p.map((S => i.unproject(S))),
              T = p.reduce(((S, k, L, V) => S.add(k.div(V.length))), new s.P(0, 0));
            super(e, {
              points: p,
              point: T,
              lngLats: v,
              lngLat: i.unproject(T),
              originalEvent: l
            }), this._defaultPrevented = !1
          }
        }
        class Rd extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, i, l) {
            super(e, {
              originalEvent: l
            }), this._defaultPrevented = !1
          }
        }
        class ks {
          constructor(e, i) {
            this._map = e, this._clickTolerance = i.clickTolerance
          }
          reset() {
            delete this._mousedownPos
          }
          wheel(e) {
            return this._firePreventable(new Rd(e.type, this._map, e))
          }
          mousedown(e, i) {
            return this._mousedownPos = i, this._firePreventable(new va(e.type, this._map, e))
          }
          mouseup(e) {
            this._map.fire(new va(e.type, this._map, e))
          }
          click(e, i) {
            this._mousedownPos && this._mousedownPos.dist(i) >= this._clickTolerance || this._map.fire(new va(e.type, this._map, e))
          }
          dblclick(e) {
            return this._firePreventable(new va(e.type, this._map, e))
          }
          mouseover(e) {
            this._map.fire(new va(e.type, this._map, e))
          }
          mouseout(e) {
            this._map.fire(new va(e.type, this._map, e))
          }
          touchstart(e) {
            return this._firePreventable(new ha(e.type, this._map, e))
          }
          touchmove(e) {
            this._map.fire(new ha(e.type, this._map, e))
          }
          touchend(e) {
            this._map.fire(new ha(e.type, this._map, e))
          }
          touchcancel(e) {
            this._map.fire(new ha(e.type, this._map, e))
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {}
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class Tf {
          constructor(e) {
            this._map = e
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent
          }
          mousemove(e) {
            this._map.fire(new va(e.type, this._map, e))
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new va("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new va(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault()
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class ol {
          constructor(e) {
            this._map = e
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat
            }
          }
          get zoom() {
            return this.transform.zoom
          }
          get pitch() {
            return this.transform.pitch
          }
          get bearing() {
            return this.transform.bearing
          }
          unproject(e) {
            return this.transform.screenPointToLocation(s.P.convert(e), this._map.terrain)
          }
        }
        class Fd {
          constructor(e, i) {
            this._map = e, this._tr = new ol(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = i.clickTolerance || 1
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
          enable() {
            this.isEnabled() || (this._enabled = !0)
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          mousedown(e, i) {
            this.isEnabled() && e.shiftKey && e.button === 0 && ($.disableDrag(), this._startPos = this._lastPos = i, this._active = !0)
          }
          mousemoveWindow(e, i) {
            if (!this._active) return;
            const l = i;
            if (this._lastPos.equals(l) || !this._box && l.dist(this._startPos) < this._clickTolerance) return;
            const u = this._startPos;
            this._lastPos = l, this._box || (this._box = $.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const p = Math.min(u.x, l.x),
              v = Math.max(u.x, l.x),
              T = Math.min(u.y, l.y),
              S = Math.max(u.y, l.y);
            $.setTransform(this._box, `translate(${p}px,${T}px)`), this._box.style.width = v - p + "px", this._box.style.height = S - T + "px"
          }
          mouseupWindow(e, i) {
            if (!this._active || e.button !== 0) return;
            const l = this._startPos,
              u = i;
            if (this.reset(), $.suppressClick(), l.x !== u.x || l.y !== u.y) return this._map.fire(new s.l("boxzoomend", {
              originalEvent: e
            })), {
              cameraAnimation: p => p.fitScreenCoordinates(l, u, this._tr.bearing, {
                linear: !0
              })
            };
            this._fireEvent("boxzoomcancel", e)
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e))
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && ($.remove(this._box), this._box = null), $.enableDrag(), delete this._startPos, delete this._lastPos
          }
          _fireEvent(e, i) {
            return this._map.fire(new s.l(e, {
              originalEvent: i
            }))
          }
        }

        function _u(h, e) {
          if (h.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${h.length}, points ${e.length}`);
          const i = {};
          for (let l = 0; l < h.length; l++) i[h[l].identifier] = e[l];
          return i
        }
        class Bd {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1
          }
          touchstart(e, i, l) {
            (this.centroid || l.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), l.length === this.numTouches && (this.centroid = (function(u) {
              const p = new s.P(0, 0);
              for (const v of u) p._add(v);
              return p.div(u.length)
            })(i), this.touches = _u(l, i)))
          }
          touchmove(e, i, l) {
            if (this.aborted || !this.centroid) return;
            const u = _u(l, i);
            for (const p in this.touches) {
              const v = u[p];
              (!v || v.dist(this.touches[p]) > 30) && (this.aborted = !0)
            }
          }
          touchend(e, i, l) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), l.length === 0) {
              const u = !this.aborted && this.centroid;
              if (this.reset(), u) return u
            }
          }
        }
        class es {
          constructor(e) {
            this.singleTap = new Bd(e), this.numTaps = e.numTaps, this.reset()
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset()
          }
          touchstart(e, i, l) {
            this.singleTap.touchstart(e, i, l)
          }
          touchmove(e, i, l) {
            this.singleTap.touchmove(e, i, l)
          }
          touchend(e, i, l) {
            const u = this.singleTap.touchend(e, i, l);
            if (u) {
              const p = e.timeStamp - this.lastTime < 500,
                v = !this.lastTap || this.lastTap.dist(u) < 30;
              if (p && v || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = u, this.count === this.numTaps) return this.reset(), u
            }
          }
        }
        class mo {
          constructor(e) {
            this._tr = new ol(e), this._zoomIn = new es({
              numTouches: 1,
              numTaps: 2
            }), this._zoomOut = new es({
              numTouches: 2,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
          }
          touchstart(e, i, l) {
            this._zoomIn.touchstart(e, i, l), this._zoomOut.touchstart(e, i, l)
          }
          touchmove(e, i, l) {
            this._zoomIn.touchmove(e, i, l), this._zoomOut.touchmove(e, i, l)
          }
          touchend(e, i, l) {
            const u = this._zoomIn.touchend(e, i, l),
              p = this._zoomOut.touchend(e, i, l),
              v = this._tr;
            return u ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: T => T.easeTo({
                duration: 300,
                zoom: v.zoom + 1,
                around: v.unproject(u)
              }, {
                originalEvent: e
              })
            }) : p ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: T => T.easeTo({
                duration: 300,
                zoom: v.zoom - 1,
                around: v.unproject(p)
              }, {
                originalEvent: e
              })
            }) : void 0
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Cr {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset()
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e)
          }
          _move(...e) {
            const i = this._moveFunction(...e);
            if (i.bearingDelta || i.pitchDelta || i.rollDelta || i.around || i.panDelta) return this._active = !0, i
          }
          dragStart(e, i) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(i) ? i[0] : i, this._activateOnStart && this._lastPoint && (this._active = !0))
          }
          dragMove(e, i) {
            if (!this.isEnabled()) return;
            const l = this._lastPoint;
            if (!l) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const u = Array.isArray(i) ? i[0] : i;
            return !this._moved && u.dist(l) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = u, this._move(l, u))
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && $.suppressClick(), this.reset(e))
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          getClickTolerance() {
            return this._clickTolerance
          }
        }
        const Od = 0,
          vu = 2,
          Nd = {
            [Od]: 1,
            [vu]: 2
          };
        class go {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent
          }
          startMove(e) {
            const i = $.mouseButton(e);
            this._eventButton = i
          }
          endMove(e) {
            delete this._eventButton
          }
          isValidStartEvent(e) {
            return this._correctEvent(e)
          }
          isValidMoveEvent(e) {
            return !(function(i, l) {
              const u = Nd[l];
              return i.buttons === void 0 || (i.buttons & u) !== u
            })(e, this._eventButton)
          }
          isValidEndEvent(e) {
            return $.mouseButton(e) === this._eventButton
          }
        }
        class sl {
          constructor() {
            this._firstTouch = void 0
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier
          }
          endMove(e) {
            delete this._firstTouch
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e)
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
        }
        class yu {
          constructor(e = new go({
            checkCorrectEvent: () => !0
          }), i = new sl) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = i
          }
          _executeRelevantHandler(e, i, l) {
            return e instanceof MouseEvent ? i(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? l(e) : void 0
          }
          startMove(e) {
            this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.startMove(i)), (i => this.oneFingerTouchMoveStateManager.startMove(i)))
          }
          endMove(e) {
            this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.endMove(i)), (i => this.oneFingerTouchMoveStateManager.endMove(i)))
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.isValidStartEvent(i)), (i => this.oneFingerTouchMoveStateManager.isValidStartEvent(i)))
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.isValidMoveEvent(i)), (i => this.oneFingerTouchMoveStateManager.isValidMoveEvent(i)))
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.isValidEndEvent(i)), (i => this.oneFingerTouchMoveStateManager.isValidEndEvent(i)))
          }
        }
        const Dn = h => {
          h.mousedown = h.dragStart, h.mousemoveWindow = h.dragMove, h.mouseup = h.dragEnd, h.contextmenu = e => {
            e.preventDefault()
          }
        };
        class xu {
          constructor(e, i) {
            this._clickTolerance = e.clickTolerance || 1, this._map = i, this.reset()
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new s.P(0, 0)
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
          }
          touchstart(e, i, l) {
            return this._calculateTransform(e, i, l)
          }
          touchmove(e, i, l) {
            if (this._active) {
              if (!this._shouldBePrevented(l.length)) return e.preventDefault(), this._calculateTransform(e, i, l);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
            }
          }
          touchend(e, i, l) {
            this._calculateTransform(e, i, l), this._active && this._shouldBePrevented(l.length) && this.reset()
          }
          touchcancel() {
            this.reset()
          }
          _calculateTransform(e, i, l) {
            l.length > 0 && (this._active = !0);
            const u = _u(l, i),
              p = new s.P(0, 0),
              v = new s.P(0, 0);
            let T = 0;
            for (const k in u) {
              const L = u[k],
                V = this._touches[k];
              V && (p._add(L), v._add(L.sub(V)), T++, u[k] = L)
            }
            if (this._touches = u, this._shouldBePrevented(T) || !v.mag()) return;
            const S = v.div(T);
            return this._sum._add(S), this._sum.mag() < this._clickTolerance ? void 0 : {
              around: p.div(T),
              panDelta: S
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class bu {
          constructor() {
            this.reset()
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches
          }
          touchstart(e, i, l) {
            this._firstTwoTouches || l.length < 2 || (this._firstTwoTouches = [l[0].identifier, l[1].identifier], this._start([i[0], i[1]]))
          }
          touchmove(e, i, l) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [u, p] = this._firstTwoTouches, v = Es(l, i, u), T = Es(l, i, p);
            if (!v || !T) return;
            const S = this._aroundCenter ? null : v.add(T).div(2);
            return this._move([v, T], S, e)
          }
          touchend(e, i, l) {
            if (!this._firstTwoTouches) return;
            const [u, p] = this._firstTwoTouches, v = Es(l, i, u), T = Es(l, i, p);
            v && T || (this._active && $.suppressClick(), this.reset())
          }
          touchcancel() {
            this.reset()
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center"
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
        }

        function Es(h, e, i) {
          for (let l = 0; l < h.length; l++)
            if (h[l].identifier === i) return e[l]
        }

        function jd(h, e) {
          return Math.log(h / e) / Math.LN2
        }
        class qd extends bu {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1])
          }
          _move(e, i) {
            const l = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(jd(this._distance, this._startDistance)) < .1)) return this._active = !0, {
              zoomDelta: jd(this._distance, l),
              pinchAround: i
            }
          }
        }

        function wu(h, e) {
          return 180 * h.angleWith(e) / Math.PI
        }
        class ec extends bu {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1])
          }
          _move(e, i, l) {
            const u = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
              bearingDelta: wu(this._vector, u),
              pinchAround: i
            }
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const i = 25 / (Math.PI * this._minDiameter) * 360,
              l = wu(e, this._startVector);
            return Math.abs(l) < i
          }
        }

        function tc(h) {
          return Math.abs(h.y) > Math.abs(h.x)
        }
        class Vd extends bu {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints
          }
          touchstart(e, i, l) {
            super.touchstart(e, i, l), this._currentTouchCount = l.length
          }
          _start(e) {
            this._lastPoints = e, tc(e[0].sub(e[1])) && (this._valid = !1)
          }
          _move(e, i, l) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const u = e[0].sub(this._lastPoints[0]),
              p = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(u, p, l.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, {
              pitchDelta: (u.y + p.y) / 2 * -.5
            }) : void 0
          }
          gestureBeginsVertically(e, i, l) {
            if (this._valid !== void 0) return this._valid;
            const u = e.mag() >= 2,
              p = i.mag() >= 2;
            if (!u && !p) return;
            if (!u || !p) return this._firstMove === void 0 && (this._firstMove = l), l - this._firstMove < 100 && void 0;
            const v = e.y > 0 == i.y > 0;
            return tc(e) && tc(i) && v
          }
        }
        const Ud = {
          panStep: 100,
          bearingStep: 15,
          pitchStep: 10
        };
        class Zd {
          constructor(e) {
            this._tr = new ol(e);
            const i = Ud;
            this._panStep = i.panStep, this._bearingStep = i.bearingStep, this._pitchStep = i.pitchStep, this._rotationDisabled = !1
          }
          reset() {
            this._active = !1
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let i = 0,
              l = 0,
              u = 0,
              p = 0,
              v = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                i = 1;
                break;
              case 189:
              case 109:
              case 173:
                i = -1;
                break;
              case 37:
                e.shiftKey ? l = -1 : (e.preventDefault(), p = -1);
                break;
              case 39:
                e.shiftKey ? l = 1 : (e.preventDefault(), p = 1);
                break;
              case 38:
                e.shiftKey ? u = 1 : (e.preventDefault(), v = -1);
                break;
              case 40:
                e.shiftKey ? u = -1 : (e.preventDefault(), v = 1);
                break;
              default:
                return
            }
            return this._rotationDisabled && (l = 0, u = 0), {
              cameraAnimation: T => {
                const S = this._tr;
                T.easeTo({
                  duration: 300,
                  easeId: "keyboardHandler",
                  easing: Sf,
                  zoom: i ? Math.round(S.zoom) + i * (e.shiftKey ? 2 : 1) : S.zoom,
                  bearing: S.bearing + l * this._bearingStep,
                  pitch: S.pitch + u * this._pitchStep,
                  offset: [-p * this._panStep, -v * this._panStep],
                  center: S.center
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          disableRotation() {
            this._rotationDisabled = !0
          }
          enableRotation() {
            this._rotationDisabled = !1
          }
        }

        function Sf(h) {
          return h * (2 - h)
        }
        const _o = 4.000244140625,
          ai = 1 / 450;
        class Gd {
          constructor(e, i) {
            this._onTimeout = l => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(l)
            }, this._map = e, this._tr = new ol(e), this._triggerRenderFrame = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = ai
          }
          setZoomRate(e) {
            this._defaultZoomRate = e
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0
          }
          isZooming() {
            return !!this._zooming
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center")
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let i = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const l = ie(),
              u = l - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = l, i !== 0 && i % _o == 0 ? this._type = "wheel" : i !== 0 && Math.abs(i) < 4 ? this._type = "trackpad" : u > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(u * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), e.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = e, this._delta -= i, this._active || this._start(e)), e.preventDefault()
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const i = $.mousePos(this._map.getCanvas(), e),
              l = this._tr;
            this._aroundPoint = this._aroundCenter ? l.transform.locationToScreenPoint(s.U.convert(l.center)) : i, this._frameId || (this._frameId = !0, this._triggerRenderFrame())
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const T = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += T), typeof this._targetZoom == "number" && (this._targetZoom += T)
            }
            if (this._delta !== 0) {
              const T = this._type === "wheel" && Math.abs(this._delta) > _o ? this._wheelZoomRate : this._defaultZoomRate;
              let S = 2 / (1 + Math.exp(-Math.abs(this._delta * T)));
              this._delta < 0 && S !== 0 && (S = 1 / S);
              const k = typeof this._targetZoom != "number" ? e.scale : s.al(this._targetZoom);
              this._targetZoom = e.constrain(e.getCameraLngLat(), s.ao(k * S)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0
            }
            const i = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom,
              l = this._startZoom,
              u = this._easing;
            let p, v = !1;
            if (this._type === "wheel" && l && u) {
              const T = ie() - this._lastWheelEventTime,
                S = Math.min((T + 5) / 200, 1),
                k = u(S);
              p = s.F.number(l, i, k), S < 1 ? this._frameId || (this._frameId = !0) : v = !0
            } else p = i, v = !0;
            return this._active = !0, v && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout
            }), 200)), this._lastExpectedZoom = p, {
              noInertia: !0,
              needsRenderFrame: !v,
              zoomDelta: p - e.zoom,
              around: this._aroundPoint,
              originalEvent: this._lastWheelEvent
            }
          }
          _smoothOutEasing(e) {
            let i = s.cr;
            if (this._prevEase) {
              const l = this._prevEase,
                u = (ie() - l.start) / l.duration,
                p = l.easing(u + .01) - l.easing(u),
                v = .27 / Math.sqrt(p * p + 1e-4) * .01,
                T = Math.sqrt(.0729 - v * v);
              i = s.cp(v, T, .25, 1)
            }
            return this._prevEase = {
              start: ie(),
              duration: e,
              easing: i
            }, i
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout)
          }
        }
        class ll {
          constructor(e, i) {
            this._clickZoom = e, this._tapZoom = i
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable()
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable()
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive()
          }
        }
        class Tu {
          constructor(e) {
            this._tr = new ol(e), this.reset()
          }
          reset() {
            this._active = !1
          }
          dblclick(e, i) {
            return e.preventDefault(), {
              cameraAnimation: l => {
                l.easeTo({
                  duration: 300,
                  zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                  around: this._tr.unproject(i)
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Hd {
          constructor() {
            this._tap = new es({
              numTouches: 1,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset()
          }
          touchstart(e, i, l) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const u = i[0],
                  p = e.timeStamp - this._tapTime < 500,
                  v = this._tapPoint.dist(u) < 30;
                p && v ? l.length > 0 && (this._swipePoint = u, this._swipeTouch = l[0].identifier) : this.reset()
              } else this._tap.touchstart(e, i, l)
          }
          touchmove(e, i, l) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (l[0].identifier !== this._swipeTouch) return;
                const u = i[0],
                  p = u.y - this._swipePoint.y;
                return this._swipePoint = u, e.preventDefault(), this._active = !0, {
                  zoomDelta: p / 128
                }
              }
            } else this._tap.touchmove(e, i, l)
          }
          touchend(e, i, l) {
            if (this._tapTime) this._swipePoint && l.length === 0 && this.reset();
            else {
              const u = this._tap.touchend(e, i, l);
              u && (this._tapTime = e.timeStamp, this._tapPoint = u)
            }
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Su {
          constructor(e, i, l) {
            this._el = e, this._mousePan = i, this._touchPan = l
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan")
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan")
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled()
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive()
          }
        }
        class Pu {
          constructor(e, i, l, u) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = i, this._mousePitch = l, this._mouseRoll = u
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable()
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable()
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
          }
        }
        class Wd {
          constructor(e, i, l, u) {
            this._el = e, this._touchZoom = i, this._touchRotate = l, this._tapDragZoom = u, this._rotationDisabled = !1, this._enabled = !0
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate")
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate")
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable()
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
          }
        }
        class Za {
          constructor(e, i) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = i, this._enabled = !1
          }
          isActive() {
            return !1
          }
          reset() {}
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = $.create("div", "maplibregl-cooperative-gesture-screen", e);
            let i = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (i = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const l = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"),
              u = document.createElement("div");
            u.className = "maplibregl-desktop-message", u.textContent = i, this._container.appendChild(u);
            const p = document.createElement("div");
            p.className = "maplibregl-mobile-message", p.textContent = l, this._container.appendChild(p), this._container.setAttribute("aria-hidden", "true")
          }
          _destroyUI() {
            this._container && ($.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container
          }
          enable() {
            this._setupUI(), this._enabled = !0
          }
          disable() {
            this._enabled = !1, this._destroyUI()
          }
          isEnabled() {
            return this._enabled
          }
          isBypassed(e) {
            return e[this._bypassKey]
          }
          notifyGestureBlocked(e, i) {
            this._enabled && (this._map.fire(new s.l("cooperativegestureprevented", {
              gestureType: e,
              originalEvent: i
            })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show")
            }), 100))
          }
        }
        const ts = h => h.zoom || h.drag || h.roll || h.pitch || h.rotate;
        class Hr extends s.l {}

        function an(h) {
          return h.panDelta && h.panDelta.mag() || h.zoomDelta || h.bearingDelta || h.pitchDelta || h.rollDelta
        }
        class cl {
          constructor(e, i) {
            this.handleWindowEvent = u => {
              this.handleEvent(u, `${u.type}Window`)
            }, this.handleEvent = (u, p) => {
              if (u.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const v = u.type === "renderFrame" ? void 0 : u,
                T = {
                  needsRenderFrame: !1
                },
                S = {},
                k = {};
              for (const {
                  handlerName: B,
                  handler: H,
                  allowed: re
                }
                of this._handlers) {
                if (!H.isEnabled()) continue;
                let le;
                if (this._blockedByActive(k, re, B)) H.reset();
                else if (H[p || u.type]) {
                  if (s.cs(u, p || u.type)) {
                    const ue = $.mousePos(this._map.getCanvas(), u);
                    le = H[p || u.type](u, ue)
                  } else if (s.ct(u, p || u.type)) {
                    const ue = this._getMapTouches(u.touches),
                      de = $.touchPos(this._map.getCanvas(), ue);
                    le = H[p || u.type](u, de, ue)
                  } else s.cu(p || u.type) || (le = H[p || u.type](u));
                  this.mergeHandlerResult(T, S, le, B, v), le && le.needsRenderFrame && this._triggerRenderFrame()
                }(le || H.isActive()) && (k[B] = H)
              }
              const L = {};
              for (const B in this._previousActiveHandlers) k[B] || (L[B] = v);
              this._previousActiveHandlers = k, (Object.keys(L).length || an(T)) && (this._changes.push([T, S, L]), this._triggerRenderFrame()), (Object.keys(k).length || an(T)) && this._map._stop(!0), this._updatingCamera = !1;
              const {
                cameraAnimation: V
              } = T;
              V && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], V(this._map))
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Dd(e), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i);
            const l = this._el;
            this._listeners = [
              [l, "touchstart", {
                passive: !0
              }],
              [l, "touchmove", {
                passive: !1
              }],
              [l, "touchend", void 0],
              [l, "touchcancel", void 0],
              [l, "mousedown", void 0],
              [l, "mousemove", void 0],
              [l, "mouseup", void 0],
              [document, "mousemove", {
                capture: !0
              }],
              [document, "mouseup", void 0],
              [l, "mouseover", void 0],
              [l, "mouseout", void 0],
              [l, "dblclick", void 0],
              [l, "click", void 0],
              [l, "keydown", {
                capture: !1
              }],
              [l, "keyup", void 0],
              [l, "wheel", {
                passive: !1
              }],
              [l, "contextmenu", void 0],
              [window, "blur", void 0]
            ];
            for (const [u, p, v] of this._listeners) $.addEventListener(u, p, u === document ? this.handleWindowEvent : this.handleEvent, v)
          }
          destroy() {
            for (const [e, i, l] of this._listeners) $.removeEventListener(e, i, e === document ? this.handleWindowEvent : this.handleEvent, l)
          }
          _addDefaultHandlers(e) {
            const i = this._map,
              l = i.getCanvasContainer();
            this._add("mapEvent", new ks(i, e));
            const u = i.boxZoom = new Fd(i, e);
            this._add("boxZoom", u), e.interactive && e.boxZoom && u.enable();
            const p = i.cooperativeGestures = new Za(i, e.cooperativeGestures);
            this._add("cooperativeGestures", p), e.cooperativeGestures && p.enable();
            const v = new mo(i),
              T = new Tu(i);
            i.doubleClickZoom = new ll(T, v), this._add("tapZoom", v), this._add("clickZoom", T), e.interactive && e.doubleClickZoom && i.doubleClickZoom.enable();
            const S = new Hd;
            this._add("tapDragZoom", S);
            const k = i.touchPitch = new Vd(i);
            this._add("touchPitch", k), e.interactive && e.touchPitch && i.touchPitch.enable(e.touchPitch);
            const L = () => i.project(i.getCenter()),
              V = (function({
                enable: _e,
                clickTolerance: ke,
                aroundCenter: Fe = !0,
                minPixelCenterThreshold: xe = 100,
                rotateDegreesPerPixelMoved: Ve = .8
              }, lt) {
                const rt = new go({
                  checkCorrectEvent: at => $.mouseButton(at) === 0 && at.ctrlKey || $.mouseButton(at) === 2 && !at.ctrlKey
                });
                return new Cr({
                  clickTolerance: ke,
                  move: (at, ct) => {
                    const er = lt();
                    if (Fe && Math.abs(er.y - at.y) > xe) return {
                      bearingDelta: s.cq(new s.P(at.x, ct.y), ct, er)
                    };
                    let rr = (ct.x - at.x) * Ve;
                    return Fe && ct.y < er.y && (rr = -rr), {
                      bearingDelta: rr
                    }
                  },
                  moveStateManager: rt,
                  enable: _e,
                  assignEvents: Dn
                })
              })(e, L),
              B = (function({
                enable: _e,
                clickTolerance: ke,
                pitchDegreesPerPixelMoved: Fe = -.5
              }) {
                const xe = new go({
                  checkCorrectEvent: Ve => $.mouseButton(Ve) === 0 && Ve.ctrlKey || $.mouseButton(Ve) === 2
                });
                return new Cr({
                  clickTolerance: ke,
                  move: (Ve, lt) => ({
                    pitchDelta: (lt.y - Ve.y) * Fe
                  }),
                  moveStateManager: xe,
                  enable: _e,
                  assignEvents: Dn
                })
              })(e),
              H = (function({
                enable: _e,
                clickTolerance: ke,
                rollDegreesPerPixelMoved: Fe = .3
              }, xe) {
                const Ve = new go({
                  checkCorrectEvent: lt => $.mouseButton(lt) === 2 && lt.ctrlKey
                });
                return new Cr({
                  clickTolerance: ke,
                  move: (lt, rt) => {
                    const at = xe();
                    let ct = (rt.x - lt.x) * Fe;
                    return rt.y < at.y && (ct = -ct), {
                      rollDelta: ct
                    }
                  },
                  moveStateManager: Ve,
                  enable: _e,
                  assignEvents: Dn
                })
              })(e, L);
            i.dragRotate = new Pu(e, V, B, H), this._add("mouseRotate", V, ["mousePitch"]), this._add("mousePitch", B, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", H, ["mousePitch"]), e.interactive && e.dragRotate && i.dragRotate.enable();
            const re = (function({
                enable: _e,
                clickTolerance: ke
              }) {
                const Fe = new go({
                  checkCorrectEvent: xe => $.mouseButton(xe) === 0 && !xe.ctrlKey
                });
                return new Cr({
                  clickTolerance: ke,
                  move: (xe, Ve) => ({
                    around: Ve,
                    panDelta: Ve.sub(xe)
                  }),
                  activateOnStart: !0,
                  moveStateManager: Fe,
                  enable: _e,
                  assignEvents: Dn
                })
              })(e),
              le = new xu(e, i);
            i.dragPan = new Su(l, re, le), this._add("mousePan", re), this._add("touchPan", le, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && i.dragPan.enable(e.dragPan);
            const ue = new ec,
              de = new qd;
            i.touchZoomRotate = new Wd(l, de, ue, S), this._add("touchRotate", ue, ["touchPan", "touchZoom"]), this._add("touchZoom", de, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && i.touchZoomRotate.enable(e.touchZoomRotate), this._add("blockableMapEvent", new Tf(i));
            const ve = i.scrollZoom = new Gd(i, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", ve, ["mousePan"]), e.interactive && e.scrollZoom && i.scrollZoom.enable(e.scrollZoom);
            const Ae = i.keyboard = new Zd(i);
            this._add("keyboard", Ae), e.interactive && e.keyboard && i.keyboard.enable()
          }
          _add(e, i, l) {
            this._handlers.push({
              handlerName: e,
              handler: i,
              allowed: l
            }), this._handlersById[e] = i
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const {
                  handler: i
                }
                of this._handlers) i.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = []
            }
          }
          isActive() {
            for (const {
                handler: e
              }
              of this._handlers)
              if (e.isActive()) return !0;
            return !1
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
          }
          isRotating() {
            return !!this._eventsInProgress.rotate
          }
          isMoving() {
            return !!ts(this._eventsInProgress) || this.isZooming()
          }
          _blockedByActive(e, i, l) {
            for (const u in e)
              if (u !== l && (!i || i.indexOf(u) < 0)) return !0;
            return !1
          }
          _getMapTouches(e) {
            const i = [];
            for (const l of e) this._el.contains(l.target) && i.push(l);
            return i
          }
          mergeHandlerResult(e, i, l, u, p) {
            if (!l) return;
            s.e(e, l);
            const v = {
              handlerName: u,
              originalEvent: l.originalEvent || p
            };
            l.zoomDelta !== void 0 && (i.zoom = v), l.panDelta !== void 0 && (i.drag = v), l.rollDelta !== void 0 && (i.roll = v), l.pitchDelta !== void 0 && (i.pitch = v), l.bearingDelta !== void 0 && (i.rotate = v)
          }
          _applyChanges() {
            const e = {},
              i = {},
              l = {};
            for (const [u, p, v] of this._changes) u.panDelta && (e.panDelta = (e.panDelta || new s.P(0, 0))._add(u.panDelta)), u.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + u.zoomDelta), u.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + u.bearingDelta), u.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + u.pitchDelta), u.rollDelta && (e.rollDelta = (e.rollDelta || 0) + u.rollDelta), u.around !== void 0 && (e.around = u.around), u.pinchAround !== void 0 && (e.pinchAround = u.pinchAround), u.noInertia && (e.noInertia = u.noInertia), s.e(i, p), s.e(l, v);
            this._updateMapTransform(e, i, l), this._changes = []
          }
          _updateMapTransform(e, i, l) {
            const u = this._map,
              p = u._getTransformForUpdate(),
              v = u.terrain;
            if (!(an(e) || v && this._terrainMovement)) return this._fireEvents(i, l, !0);
            u._stop(!0);
            let {
              panDelta: T,
              zoomDelta: S,
              bearingDelta: k,
              pitchDelta: L,
              rollDelta: V,
              around: B,
              pinchAround: H
            } = e;
            H !== void 0 && (B = H), B = B || u.transform.centerPoint, v && !p.isPointOnMapSurface(B) && (B = p.centerPoint);
            const re = {
              panDelta: T,
              zoomDelta: S,
              rollDelta: V,
              pitchDelta: L,
              bearingDelta: k,
              around: B
            };
            this._map.cameraHelper.useGlobeControls && !p.isPointOnMapSurface(B) && (B = p.centerPoint);
            const le = B.distSqr(p.centerPoint) < .01 ? p.center : p.screenPointToLocation(T ? B.sub(T) : B);
            this._handleMapControls({
              terrain: v,
              tr: p,
              deltasForHelper: re,
              preZoomAroundLoc: le,
              combinedEventsInProgress: i,
              panDelta: T
            }), u._applyUpdatedTransform(p), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(i, l, !0)
          }
          _handleMapControls({
            terrain: e,
            tr: i,
            deltasForHelper: l,
            preZoomAroundLoc: u,
            combinedEventsInProgress: p,
            panDelta: v
          }) {
            const T = this._map.cameraHelper;
            if (T.handleMapControlsRollPitchBearingZoom(l, i), e) return T.useGlobeControls ? (this._terrainMovement || !p.drag && !p.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void T.handleMapControlsPan(l, i, u)) : this._terrainMovement || !p.drag && !p.zoom ? void(p.drag && this._terrainMovement && v ? i.setCenter(i.screenPointToLocation(i.centerPoint.sub(v))) : T.handleMapControlsPan(l, i, u)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void T.handleMapControlsPan(l, i, u));
            T.handleMapControlsPan(l, i, u)
          }
          _fireEvents(e, i, l) {
            const u = ts(this._eventsInProgress),
              p = ts(e),
              v = {};
            for (const V in e) {
              const {
                originalEvent: B
              } = e[V];
              this._eventsInProgress[V] || (v[`${V}start`] = B), this._eventsInProgress[V] = e[V]
            }!u && p && this._fireEvent("movestart", p.originalEvent);
            for (const V in v) this._fireEvent(V, v[V]);
            p && this._fireEvent("move", p.originalEvent);
            for (const V in e) {
              const {
                originalEvent: B
              } = e[V];
              this._fireEvent(V, B)
            }
            const T = {};
            let S;
            for (const V in this._eventsInProgress) {
              const {
                handlerName: B,
                originalEvent: H
              } = this._eventsInProgress[V];
              this._handlersById[B].isActive() || (delete this._eventsInProgress[V], S = i[B] || H, T[`${V}end`] = S)
            }
            for (const V in T) this._fireEvent(V, T[V]);
            const k = ts(this._eventsInProgress),
              L = (u || p) && !k;
            if (L && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const V = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && V.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(V)
            }
            if (l && L) {
              this._updatingCamera = !0;
              const V = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                B = H => H !== 0 && -this._bearingSnap < H && H < this._bearingSnap;
              !V || !V.essential && ae.prefersReducedMotion ? (this._map.fire(new s.l("moveend", {
                originalEvent: S
              })), B(this._map.getBearing()) && this._map.resetNorth()) : (B(V.bearing || this._map.getBearing()) && (V.bearing = 0), V.freezeElevation = !0, this._map.easeTo(V, {
                originalEvent: S
              })), this._updatingCamera = !1
            }
          }
          _fireEvent(e, i) {
            this._map.fire(new s.l(e, i ? {
              originalEvent: i
            } : {}))
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e => {
              delete this._frameId, this.handleEvent(new Hr("renderFrame", {
                timeStamp: e
              })), this._applyChanges()
            }))
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame())
          }
        }
        class $d extends s.E {
          constructor(e, i, l) {
            super(), this._renderFrameCallback = () => {
              const u = Math.min((ie() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(u)), u < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = l.bearingSnap, this.cameraHelper = i, this.on("moveend", (() => {
              delete this._requestedCameraState
            }))
          }
          migrateProjection(e, i) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = i
          }
          getCenter() {
            return new s.U(this.transform.center.lng, this.transform.center.lat)
          }
          setCenter(e, i) {
            return this.jumpTo({
              center: e
            }, i)
          }
          getCenterElevation() {
            return this.transform.elevation
          }
          setCenterElevation(e, i) {
            return this.jumpTo({
              elevation: e
            }, i), this
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e
          }
          panBy(e, i, l) {
            return e = s.P.convert(e).mult(-1), this.panTo(this.transform.center, s.e({
              offset: e
            }, i), l)
          }
          panTo(e, i, l) {
            return this.easeTo(s.e({
              center: e
            }, i), l)
          }
          getZoom() {
            return this.transform.zoom
          }
          setZoom(e, i) {
            return this.jumpTo({
              zoom: e
            }, i), this
          }
          zoomTo(e, i, l) {
            return this.easeTo(s.e({
              zoom: e
            }, i), l)
          }
          zoomIn(e, i) {
            return this.zoomTo(this.getZoom() + 1, e, i), this
          }
          zoomOut(e, i) {
            return this.zoomTo(this.getZoom() - 1, e, i), this
          }
          getVerticalFieldOfView() {
            return this.transform.fov
          }
          setVerticalFieldOfView(e, i) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new s.l("movestart", i)).fire(new s.l("move", i)).fire(new s.l("moveend", i))), this
          }
          getBearing() {
            return this.transform.bearing
          }
          setBearing(e, i) {
            return this.jumpTo({
              bearing: e
            }, i), this
          }
          getPadding() {
            return this.transform.padding
          }
          setPadding(e, i) {
            return this.jumpTo({
              padding: e
            }, i), this
          }
          rotateTo(e, i, l) {
            return this.easeTo(s.e({
              bearing: e
            }, i), l)
          }
          resetNorth(e, i) {
            return this.rotateTo(0, s.e({
              duration: 1e3
            }, e), i), this
          }
          resetNorthPitch(e, i) {
            return this.easeTo(s.e({
              bearing: 0,
              pitch: 0,
              roll: 0,
              duration: 1e3
            }, e), i), this
          }
          snapToNorth(e, i) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, i) : this
          }
          getPitch() {
            return this.transform.pitch
          }
          setPitch(e, i) {
            return this.jumpTo({
              pitch: e
            }, i), this
          }
          getRoll() {
            return this.transform.roll
          }
          setRoll(e, i) {
            return this.jumpTo({
              roll: e
            }, i), this
          }
          cameraForBounds(e, i) {
            e = jt.convert(e).adjustAntiMeridian();
            const l = i && i.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), l, i)
          }
          _cameraForBoxAndBearing(e, i, l, u) {
            const p = {
              top: 0,
              bottom: 0,
              right: 0,
              left: 0
            };
            if (typeof(u = s.e({
                padding: p,
                offset: [0, 0],
                maxZoom: this.transform.maxZoom
              }, u)).padding == "number") {
              const k = u.padding;
              u.padding = {
                top: k,
                bottom: k,
                right: k,
                left: k
              }
            }
            const v = s.e(p, u.padding);
            u.padding = v;
            const T = this.transform,
              S = new jt(e, i);
            return this.cameraHelper.cameraForBoxAndBearing(u, v, S, l, T)
          }
          fitBounds(e, i, l) {
            return this._fitInternal(this.cameraForBounds(e, i), i, l)
          }
          fitScreenCoordinates(e, i, l, u, p) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(s.P.convert(e)), this.transform.screenPointToLocation(s.P.convert(i)), l, u), u, p)
          }
          _fitInternal(e, i, l) {
            return e ? (delete(i = s.e(e, i)).padding, i.linear ? this.easeTo(i, l) : this.flyTo(i, l)) : this
          }
          jumpTo(e, i) {
            this.stop();
            const l = this._getTransformForUpdate();
            let u = !1,
              p = !1,
              v = !1;
            const T = l.zoom;
            this.cameraHelper.handleJumpToCenterZoom(l, e);
            const S = l.zoom !== T;
            return "elevation" in e && l.elevation !== +e.elevation && l.setElevation(+e.elevation), "bearing" in e && l.bearing !== +e.bearing && (u = !0, l.setBearing(+e.bearing)), "pitch" in e && l.pitch !== +e.pitch && (p = !0, l.setPitch(+e.pitch)), "roll" in e && l.roll !== +e.roll && (v = !0, l.setRoll(+e.roll)), e.padding == null || l.isPaddingEqual(e.padding) || l.setPadding(e.padding), this._applyUpdatedTransform(l), this.fire(new s.l("movestart", i)).fire(new s.l("move", i)), S && this.fire(new s.l("zoomstart", i)).fire(new s.l("zoom", i)).fire(new s.l("zoomend", i)), u && this.fire(new s.l("rotatestart", i)).fire(new s.l("rotate", i)).fire(new s.l("rotateend", i)), p && this.fire(new s.l("pitchstart", i)).fire(new s.l("pitch", i)).fire(new s.l("pitchend", i)), v && this.fire(new s.l("rollstart", i)).fire(new s.l("roll", i)).fire(new s.l("rollend", i)), this.fire(new s.l("moveend", i))
          }
          calculateCameraOptionsFromTo(e, i, l, u = 0) {
            const p = s.a5.fromLngLat(e, i),
              v = s.a5.fromLngLat(l, u),
              T = v.x - p.x,
              S = v.y - p.y,
              k = v.z - p.z,
              L = Math.hypot(T, S, k);
            if (L === 0) throw new Error("Can't calculate camera options with same From and To");
            const V = Math.hypot(T, S),
              B = s.ao(this.transform.cameraToCenterDistance / L / this.transform.tileSize),
              H = 180 * Math.atan2(T, -S) / Math.PI;
            let re = 180 * Math.acos(V / L) / Math.PI;
            return re = k < 0 ? 90 - re : 90 + re, {
              center: v.toLngLat(),
              elevation: u,
              zoom: B,
              pitch: re,
              bearing: H
            }
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, i, l, u, p) {
            const v = this.transform.calculateCenterFromCameraLngLatAlt(e, i, l, u);
            return {
              center: v.center,
              elevation: v.elevation,
              zoom: v.zoom,
              bearing: l,
              pitch: u,
              roll: p
            }
          }
          easeTo(e, i) {
            this._stop(!1, e.easeId), ((e = s.e({
              offset: [0, 0],
              duration: 500,
              easing: s.cr
            }, e)).animate === !1 || !e.essential && ae.prefersReducedMotion) && (e.duration = 0);
            const l = this._getTransformForUpdate(),
              u = this.getBearing(),
              p = l.pitch,
              v = l.roll,
              T = "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
              S = "pitch" in e ? +e.pitch : p,
              k = "roll" in e ? this._normalizeBearing(e.roll, v) : v,
              L = "padding" in e ? e.padding : l.padding,
              V = s.P.convert(e.offset);
            let B, H;
            e.around && (B = s.U.convert(e.around), H = l.locationToScreenPoint(B));
            const re = {
                moving: this._moving,
                zooming: this._zooming,
                rotating: this._rotating,
                pitching: this._pitching,
                rolling: this._rolling
              },
              le = this.cameraHelper.handleEaseTo(l, {
                bearing: T,
                pitch: S,
                roll: k,
                padding: L,
                around: B,
                aroundPoint: H,
                offsetAsPoint: V,
                offset: e.offset,
                zoom: e.zoom,
                center: e.center
              });
            return this._rotating = this._rotating || u !== T, this._pitching = this._pitching || S !== p, this._rolling = this._rolling || k !== v, this._padding = !l.isPaddingEqual(L), this._zooming = this._zooming || le.isZooming, this._easeId = e.easeId, this._prepareEase(i, e.noMoveStart, re), this.terrain && this._prepareElevation(le.elevationCenter), this._ease((ue => {
              le.easeFunc(ue), this.terrain && !e.freezeElevation && this._updateElevation(ue), this._applyUpdatedTransform(l), this._fireMoveEvents(i)
            }), (ue => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i, ue)
            }), e), this
          }
          _prepareEase(e, i, l = {}) {
            this._moving = !0, i || l.moving || this.fire(new s.l("movestart", e)), this._zooming && !l.zooming && this.fire(new s.l("zoomstart", e)), this._rotating && !l.rotating && this.fire(new s.l("rotatestart", e)), this._pitching && !l.pitching && this.fire(new s.l("pitchstart", e)), this._rolling && !l.rolling && this.fire(new s.l("rollstart", e))
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const i = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && i !== this._elevationTarget) {
              const l = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (l - (i - (l * e + this._elevationStart)) / (1 - e)), this._elevationTarget = i
            }
            this.transform.setElevation(s.F.number(this._elevationStart, this._elevationTarget, e))
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const i = e.getCameraLngLat(),
              l = e.getCameraAltitude(),
              u = this.terrain ? this.terrain.getElevationForLngLatZoom(i, e.zoom) : 0;
            if (l < u) {
              const p = this.calculateCameraOptionsFromTo(i, u, e.center, e.elevation);
              return {
                pitch: p.pitch,
                zoom: p.zoom
              }
            }
            return {}
          }
          _applyUpdatedTransform(e) {
            const i = [];
            if (i.push((u => this._elevateCameraIfInsideTerrain(u))), this.transformCameraUpdate && i.push((u => this.transformCameraUpdate(u))), !i.length) return;
            const l = e.clone();
            for (const u of i) {
              const p = l.clone(),
                {
                  center: v,
                  zoom: T,
                  roll: S,
                  pitch: k,
                  bearing: L,
                  elevation: V
                } = u(p);
              v && p.setCenter(v), V !== void 0 && p.setElevation(V), T !== void 0 && p.setZoom(T), S !== void 0 && p.setRoll(S), k !== void 0 && p.setPitch(k), L !== void 0 && p.setBearing(L), l.apply(p)
            }
            this.transform.apply(l)
          }
          _fireMoveEvents(e) {
            this.fire(new s.l("move", e)), this._zooming && this.fire(new s.l("zoom", e)), this._rotating && this.fire(new s.l("rotate", e)), this._pitching && this.fire(new s.l("pitch", e)), this._rolling && this.fire(new s.l("roll", e))
          }
          _afterEase(e, i) {
            if (this._easeId && i && this._easeId === i) return;
            delete this._easeId;
            const l = this._zooming,
              u = this._rotating,
              p = this._pitching,
              v = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, l && this.fire(new s.l("zoomend", e)), u && this.fire(new s.l("rotateend", e)), p && this.fire(new s.l("pitchend", e)), v && this.fire(new s.l("rollend", e)), this.fire(new s.l("moveend", e))
          }
          flyTo(e, i) {
            if (!e.essential && ae.prefersReducedMotion) {
              const ct = s.S(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(ct, i)
            }
            this.stop(), e = s.e({
              offset: [0, 0],
              speed: 1.2,
              curve: 1.42,
              easing: s.cr
            }, e);
            const l = this._getTransformForUpdate(),
              u = l.bearing,
              p = l.pitch,
              v = l.roll,
              T = l.padding,
              S = "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
              k = "pitch" in e ? +e.pitch : p,
              L = "roll" in e ? this._normalizeBearing(e.roll, v) : v,
              V = "padding" in e ? e.padding : l.padding,
              B = s.P.convert(e.offset);
            let H = l.centerPoint.add(B);
            const re = l.screenPointToLocation(H),
              le = this.cameraHelper.handleFlyTo(l, {
                bearing: S,
                pitch: k,
                roll: L,
                padding: V,
                locationAtOffset: re,
                offsetAsPoint: B,
                center: e.center,
                minZoom: e.minZoom,
                zoom: e.zoom
              });
            let ue = e.curve;
            const de = Math.max(l.width, l.height),
              ve = de / le.scaleOfZoom,
              Ae = le.pixelPathLength;
            typeof le.scaleOfMinZoom == "number" && (ue = Math.sqrt(de / le.scaleOfMinZoom / Ae * 2));
            const _e = ue * ue;

            function ke(ct) {
              const er = (ve * ve - de * de + (ct ? -1 : 1) * _e * _e * Ae * Ae) / (2 * (ct ? ve : de) * _e * Ae);
              return Math.log(Math.sqrt(er * er + 1) - er)
            }

            function Fe(ct) {
              return (Math.exp(ct) - Math.exp(-ct)) / 2
            }

            function xe(ct) {
              return (Math.exp(ct) + Math.exp(-ct)) / 2
            }
            const Ve = ke(!1);
            let lt = function(ct) {
                return xe(Ve) / xe(Ve + ue * ct)
              },
              rt = function(ct) {
                return de * ((xe(Ve) * (Fe(er = Ve + ue * ct) / xe(er)) - Fe(Ve)) / _e) / Ae;
                var er
              },
              at = (ke(!0) - Ve) / ue;
            if (Math.abs(Ae) < 2e-6 || !isFinite(at)) {
              if (Math.abs(de - ve) < 1e-6) return this.easeTo(e, i);
              const ct = ve < de ? -1 : 1;
              at = Math.abs(Math.log(ve / de)) / ue, rt = () => 0, lt = er => Math.exp(ct * ue * er)
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * at / ("screenSpeed" in e ? +e.screenSpeed / ue : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = u !== S, this._pitching = k !== p, this._rolling = L !== v, this._padding = !l.isPaddingEqual(V), this._prepareEase(i, !1), this.terrain && this._prepareElevation(le.targetCenter), this._ease((ct => {
              const er = ct * at,
                rr = 1 / lt(er),
                kt = rt(er);
              this._rotating && l.setBearing(s.F.number(u, S, ct)), this._pitching && l.setPitch(s.F.number(p, k, ct)), this._rolling && l.setRoll(s.F.number(v, L, ct)), this._padding && (l.interpolatePadding(T, V, ct), H = l.centerPoint.add(B)), le.easeFunc(ct, rr, kt, H), this.terrain && !e.freezeElevation && this._updateElevation(ct), this._applyUpdatedTransform(l), this._fireMoveEvents(i)
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i)
            }), e), this
          }
          isEasing() {
            return !!this._easeFrameId
          }
          stop() {
            return this._stop()
          }
          _stop(e, i) {
            var l;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const u = this._onEaseEnd;
              delete this._onEaseEnd, u.call(this, i)
            }
            return e || (l = this.handlers) === null || l === void 0 || l.stop(!1), this
          }
          _ease(e, i, l) {
            l.animate === !1 || l.duration === 0 ? (e(1), i()) : (this._easeStart = ie(), this._easeOptions = l, this._onEaseFrame = e, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
          }
          _normalizeBearing(e, i) {
            e = s.V(e, -180, 180);
            const l = Math.abs(e - i);
            return Math.abs(e - 360 - i) < l && (e -= 360), Math.abs(e + 360 - i) < l && (e += 360), e
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(s.U.convert(e), this.transform.tileZoom) : null
          }
        }
        const ul = {
          compact: !0,
          customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
        };
        class na {
          constructor(e = ul) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")))
            }, this._updateData = i => {
              !i || i.sourceDataType !== "metadata" && i.sourceDataType !== "visibility" && i.dataType !== "style" && i.type !== "terrain" || this._updateAttributions()
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-right"
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = $.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = $.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = $.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container
          }
          onRemove() {
            $.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0
          }
          _setElementTitle(e, i) {
            const l = this._map._getUIString(`AttributionControl.${i}`);
            e.title = l, e.setAttribute("aria-label", l)
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((u => typeof u != "string" ? "" : u))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const u = this._map.style.stylesheet;
              this.styleOwner = u.owner, this.styleId = u.id
            }
            const i = this._map.style.tileManagers;
            for (const u in i) {
              const p = i[u];
              if (p.used || p.usedForTerrain) {
                const v = p.getSource();
                v.attribution && e.indexOf(v.attribution) < 0 && e.push(v.attribution)
              }
            }
            e = e.filter((u => String(u).trim())), e.sort(((u, p) => u.length - p.length)), e = e.filter(((u, p) => {
              for (let v = p + 1; v < e.length; v++)
                if (e[v].indexOf(u) >= 0) return !1;
              return !0
            }));
            const l = e.join(" | ");
            l !== this._attribHTML && (this._attribHTML = l, e.length ? (this._innerContainer.innerHTML = $.sanitize(l), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null)
          }
        }
        class Cu {
          constructor(e = {}) {
            this._updateCompact = () => {
              const i = this._container.children;
              if (i.length) {
                const l = i[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && l.classList.add("maplibregl-compact") : l.classList.remove("maplibregl-compact")
              }
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = $.create("div", "maplibregl-ctrl");
            const i = $.create("a", "maplibregl-ctrl-logo");
            return i.target = "_blank", i.rel = "noopener nofollow", i.href = "https://maplibre.org/", i.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), i.setAttribute("rel", "noopener nofollow"), this._container.appendChild(i), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
          }
          onRemove() {
            $.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0
          }
        }
        class Ga {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
          }
          add(e) {
            const i = ++this._id;
            return this._queue.push({
              callback: e,
              id: i,
              cancelled: !1
            }), i
          }
          remove(e) {
            const i = this._currentlyRunning,
              l = i ? this._queue.concat(i) : this._queue;
            for (const u of l)
              if (u.id === e) return void(u.cancelled = !0)
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const i = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const l of i)
              if (!l.cancelled && (l.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = []
          }
        }
        var Xd = s.aN([{
          name: "a_pos3d",
          type: "Int16",
          components: 3
        }]);
        class Pf extends s.E {
          constructor(e) {
            super(), this._lastTilesetChange = ie(), this.tileManager = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize
          }
          destruct() {
            this.tileManager.usedForTerrain = !1, this.tileManager.tileSize = null
          }
          getSource() {
            return this.tileManager._source
          }
          update(e, i) {
            this.tileManager.update(e, i), this._renderableTilesKeys = [];
            const l = {};
            for (const u of Et(e, {
                tileSize: this.tileSize,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                reparseOverscaled: !1,
                terrain: i,
                calculateTileZoom: this.tileManager._source.calculateTileZoom
              })) l[u.key] = !0, this._renderableTilesKeys.push(u.key), this._tiles[u.key] || (u.terrainRttPosMatrix32f = new Float64Array(16), s.c0(u.terrainRttPosMatrix32f, 0, s.a3, s.a3, 0, 0, 1), this._tiles[u.key] = new ee(u, this.tileSize), this._lastTilesetChange = ie());
            for (const u in this._tiles) l[u] || delete this._tiles[u]
          }
          freeRtt(e) {
            for (const i in this._tiles) {
              const l = this._tiles[i];
              (!e || l.tileID.equals(e) || l.tileID.isChildOf(e) || e.isChildOf(l.tileID)) && (l.rtt = [])
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e => this.getTileByID(e)))
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          getTerrainCoords(e, i) {
            return i ? this._getTerrainCoordsForTileRanges(e, i) : this._getTerrainCoordsForRegularTile(e)
          }
          _getTerrainCoordsForRegularTile(e) {
            const i = {};
            for (const l of this._renderableTilesKeys) {
              const u = this._tiles[l].tileID,
                p = e.clone(),
                v = s.bd();
              if (u.canonical.equals(e.canonical)) s.c0(v, 0, s.a3, s.a3, 0, 0, 1);
              else if (u.canonical.isChildOf(e.canonical)) {
                const T = u.canonical.z - e.canonical.z,
                  S = u.canonical.x - (u.canonical.x >> T << T),
                  k = u.canonical.y - (u.canonical.y >> T << T),
                  L = s.a3 >> T;
                s.c0(v, 0, L, L, 0, 0, 1), s.N(v, v, [-S * L, -k * L, 0])
              } else {
                if (!e.canonical.isChildOf(u.canonical)) continue;
                {
                  const T = e.canonical.z - u.canonical.z,
                    S = e.canonical.x - (e.canonical.x >> T << T),
                    k = e.canonical.y - (e.canonical.y >> T << T),
                    L = s.a3 >> T;
                  s.c0(v, 0, s.a3, s.a3, 0, 0, 1), s.N(v, v, [S * L, k * L, 0]), s.O(v, v, [1 / 2 ** T, 1 / 2 ** T, 0])
                }
              }
              p.terrainRttPosMatrix32f = new Float32Array(v), i[l] = p
            }
            return i
          }
          _getTerrainCoordsForTileRanges(e, i) {
            const l = {};
            for (const u of this._renderableTilesKeys) {
              const p = this._tiles[u].tileID;
              if (!this._isWithinTileRanges(p, i)) continue;
              const v = e.clone(),
                T = s.bd();
              if (p.canonical.z === e.canonical.z) {
                const S = e.canonical.x - p.canonical.x,
                  k = e.canonical.y - p.canonical.y;
                s.c0(T, 0, s.a3, s.a3, 0, 0, 1), s.N(T, T, [S * s.a3, k * s.a3, 0])
              } else if (p.canonical.z > e.canonical.z) {
                const S = p.canonical.z - e.canonical.z,
                  k = p.canonical.x - (p.canonical.x >> S << S),
                  L = p.canonical.y - (p.canonical.y >> S << S),
                  V = e.canonical.x - (p.canonical.x >> S),
                  B = e.canonical.y - (p.canonical.y >> S),
                  H = s.a3 >> S;
                s.c0(T, 0, H, H, 0, 0, 1), s.N(T, T, [-k * H + V * s.a3, -L * H + B * s.a3, 0])
              } else {
                const S = e.canonical.z - p.canonical.z,
                  k = e.canonical.x - (e.canonical.x >> S << S),
                  L = e.canonical.y - (e.canonical.y >> S << S),
                  V = (e.canonical.x >> S) - p.canonical.x,
                  B = (e.canonical.y >> S) - p.canonical.y,
                  H = s.a3 << S;
                s.c0(T, 0, H, H, 0, 0, 1), s.N(T, T, [k * s.a3 + V * H, L * s.a3 + B * H, 0])
              }
              v.terrainRttPosMatrix32f = new Float32Array(T), l[u] = v
            }
            return l
          }
          getSourceTile(e, i) {
            const l = this.tileManager._source;
            let u = e.overscaledZ - this.deltaZoom;
            if (u > l.maxzoom && (u = l.maxzoom), u < l.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(u).key);
            let p = this.tileManager.getTileByID(this._sourceTileCache[e.key]);
            if ((!p || !p.dem) && i)
              for (; u >= l.minzoom && (!p || !p.dem);) p = this.tileManager.getTileByID(e.scaledTo(u--).key);
            return p
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e
          }
          _isWithinTileRanges(e, i) {
            return i[e.canonical.z] && e.canonical.x >= i[e.canonical.z].minTileX && e.canonical.x <= i[e.canonical.z].maxTileX && e.canonical.y >= i[e.canonical.z].minTileY && e.canonical.y <= i[e.canonical.z].maxTileY
          }
        }
        class Cf {
          constructor(e, i, l) {
            this._meshCache = {}, this.painter = e, this.tileManager = new Pf(i), this.options = l, this.exaggeration = typeof l.exaggeration == "number" ? l.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024
          }
          getDEMElevation(e, i, l, u = s.a3) {
            var p;
            if (!(i >= 0 && i < u && l >= 0 && l < u)) return 0;
            const v = this.getTerrainData(e),
              T = (p = v.tile) === null || p === void 0 ? void 0 : p.dem;
            if (!T) return 0;
            const S = s.cv([], [i / u * s.a3, l / u * s.a3], v.u_terrain_matrix),
              k = [S[0] * T.dim, S[1] * T.dim],
              L = Math.floor(k[0]),
              V = Math.floor(k[1]),
              B = k[0] - L,
              H = k[1] - V;
            return T.get(L, V) * (1 - B) * (1 - H) + T.get(L + 1, V) * B * (1 - H) + T.get(L, V + 1) * (1 - B) * H + T.get(L + 1, V + 1) * B * H
          }
          getElevationForLngLatZoom(e, i) {
            if (!s.cw(i, e.wrap())) return 0;
            const {
              tileID: l,
              mercatorX: u,
              mercatorY: p
            } = this._getOverscaledTileIDFromLngLatZoom(e, i);
            return this.getElevation(l, u % s.a3, p % s.a3, s.a3)
          }
          getElevation(e, i, l, u = s.a3) {
            return this.getDEMElevation(e, i, l, u) * this.exaggeration
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const u = this.painter.context,
                p = new s.R({
                  width: 1,
                  height: 1
                }, new Uint8Array(4));
              this._emptyDepthTexture = new s.T(u, p, u.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new s.T(u, new s.R({
                width: 1,
                height: 1
              }), u.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = s.am([])
            }
            const i = this.tileManager.getSourceTile(e, !0);
            if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) {
              const u = this.painter.context;
              i.demTexture = this.painter.getTileTexture(i.dem.stride), i.demTexture ? i.demTexture.update(i.dem.getPixels(), {
                premultiply: !1
              }) : i.demTexture = new s.T(u, i.dem.getPixels(), u.gl.RGBA, {
                premultiply: !1
              }), i.demTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), i.needsTerrainPrepare = !1
            }
            const l = i && i + i.tileID.key + e.key;
            if (l && !this._demMatrixCache[l]) {
              const u = this.tileManager.getSource().maxzoom;
              let p = e.canonical.z - i.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= u ? p = e.canonical.z - u : s.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const v = e.canonical.x - (e.canonical.x >> p << p),
                T = e.canonical.y - (e.canonical.y >> p << p),
                S = s.cx(new Float64Array(16), [1 / (s.a3 << p), 1 / (s.a3 << p), 0]);
              s.N(S, S, [v * s.a3, T * s.a3, 0]), this._demMatrixCache[e.key] = {
                matrix: S,
                coord: e
              }
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: i && i.dem && i.dem.dim || 1,
              u_terrain_matrix: l ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
              u_terrain_unpack: i && i.dem && i.dem.getUnpackVector() || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: (i && i.demTexture || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
              tile: i
            }
          }
          getFramebuffer(e) {
            const i = this.painter,
              l = i.width / devicePixelRatio,
              u = i.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === l && this._fbo.height === u || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new s.T(i.context, {
              width: l,
              height: u,
              data: null
            }, i.context.gl.RGBA, {
              premultiply: !1
            }), this._fboCoordsTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new s.T(i.context, {
              width: l,
              height: u,
              data: null
            }, i.context.gl.RGBA, {
              premultiply: !1
            }), this._fboDepthTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = i.context.createFramebuffer(l, u, !0, !1), this._fbo.depthAttachment.set(i.context.createRenderbuffer(i.context.gl.DEPTH_COMPONENT16, l, u))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const i = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let p = 0, v = 0; p < this._coordsTextureSize; p++)
              for (let T = 0; T < this._coordsTextureSize; T++, v += 4) i[v + 0] = 255 & T, i[v + 1] = 255 & p, i[v + 2] = T >> 8 << 4 | p >> 8, i[v + 3] = 0;
            const l = new s.R({
                width: this._coordsTextureSize,
                height: this._coordsTextureSize
              }, new Uint8Array(i.buffer)),
              u = new s.T(e, l, e.gl.RGBA, {
                premultiply: !1
              });
            return u.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = u, u
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const i = new Uint8Array(4),
              l = this.painter.context,
              u = l.gl,
              p = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio),
              v = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio),
              T = Math.round(this.painter.height / devicePixelRatio);
            l.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), u.readPixels(p, T - v - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, i), l.bindFramebuffer.set(null);
            const S = i[0] + (i[2] >> 4 << 8),
              k = i[1] + ((15 & i[2]) << 8),
              L = this.coordsIndex[255 - i[3]],
              V = L && this.tileManager.getTileByID(L);
            if (!V) return null;
            const B = this._coordsTextureSize,
              H = (1 << V.tileID.canonical.z) * B;
            return new s.a5((V.tileID.canonical.x * B + S) / H + V.tileID.wrap, (V.tileID.canonical.y * B + k) / H, this.getElevation(V.tileID, S, k, B))
          }
          depthAtPoint(e) {
            const i = new Uint8Array(4),
              l = this.painter.context,
              u = l.gl;
            return l.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), u.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, i), l.bindFramebuffer.set(null), (i[0] / 16777216 + i[1] / 65536 + i[2] / 256 + i[3]) / 256
          }
          getTerrainMesh(e) {
            var i;
            const l = ((i = this.painter.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0,
              u = l && e.canonical.y === 0,
              p = l && e.canonical.y === (1 << e.canonical.z) - 1,
              v = `m_${u?"n":""}_${p?"s":""}`;
            if (this._meshCache[v]) return this._meshCache[v];
            const T = this.painter.context,
              S = new s.cy,
              k = new s.aR,
              L = this.meshSize,
              V = s.a3 / L,
              B = L * L;
            for (let xe = 0; xe <= L; xe++)
              for (let Ve = 0; Ve <= L; Ve++) S.emplaceBack(Ve * V, xe * V, 0);
            for (let xe = 0; xe < B; xe += L + 1)
              for (let Ve = 0; Ve < L; Ve++) k.emplaceBack(Ve + xe, L + Ve + xe + 1, L + Ve + xe + 2), k.emplaceBack(Ve + xe, L + Ve + xe + 2, Ve + xe + 1);
            const H = S.length,
              re = H + (L + 1),
              le = (L + 1) * L,
              ue = u ? s.bk : 0,
              de = u ? 0 : 1,
              ve = p ? s.bl : s.a3,
              Ae = p ? 0 : 1;
            for (let xe = 0; xe <= L; xe++) S.emplaceBack(xe * V, ue, de);
            for (let xe = 0; xe <= L; xe++) S.emplaceBack(xe * V, ve, Ae);
            for (let xe = 0; xe < L; xe++) k.emplaceBack(le + xe, re + xe, re + xe + 1), k.emplaceBack(le + xe, re + xe + 1, le + xe + 1), k.emplaceBack(0 + xe, H + xe + 1, H + xe), k.emplaceBack(0 + xe, 0 + xe + 1, H + xe + 1);
            const _e = S.length,
              ke = _e + 2 * (L + 1);
            for (const xe of [0, 1])
              for (let Ve = 0; Ve <= L; Ve++)
                for (const lt of [0, 1]) S.emplaceBack(xe * s.a3, Ve * V, lt);
            for (let xe = 0; xe < 2 * L; xe += 2) k.emplaceBack(_e + xe, _e + xe + 1, _e + xe + 3), k.emplaceBack(_e + xe, _e + xe + 3, _e + xe + 2), k.emplaceBack(ke + xe, ke + xe + 3, ke + xe + 1), k.emplaceBack(ke + xe, ke + xe + 2, ke + xe + 3);
            const Fe = new Fn(T.createVertexBuffer(S, Xd.members), T.createIndexBuffer(k), s.aQ.simpleSegment(0, 0, S.length, k.length));
            return this._meshCache[v] = Fe, Fe
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * s.bx / Math.pow(2, Math.max(e, 0)) / 5
          }
          getMinTileElevationForLngLatZoom(e, i) {
            var l;
            const {
              tileID: u
            } = this._getOverscaledTileIDFromLngLatZoom(e, i);
            return (l = this.getMinMaxElevation(u).minElevation) !== null && l !== void 0 ? l : 0
          }
          getMinMaxElevation(e) {
            const i = this.getTerrainData(e).tile,
              l = {
                minElevation: null,
                maxElevation: null
              };
            return i && i.dem && (l.minElevation = i.dem.min * this.exaggeration, l.maxElevation = i.dem.max * this.exaggeration), l
          }
          _getOverscaledTileIDFromLngLatZoom(e, i) {
            const l = s.a5.fromLngLat(e.wrap()),
              u = (1 << i) * s.a3,
              p = l.x * u,
              v = l.y * u,
              T = Math.floor(p / s.a3),
              S = Math.floor(v / s.a3);
            return {
              tileID: new s.a0(i, 0, i, T, S),
              mercatorX: p,
              mercatorY: v
            }
          }
        }
        class If {
          constructor(e, i, l) {
            this._context = e, this._size = i, this._tileSize = l, this._objects = [], this._recentlyUsed = [], this._stamp = 0
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy()
          }
          _createObject(e) {
            const i = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0),
              l = new s.T(this._context, {
                width: this._tileSize,
                height: this._tileSize,
                data: null
              }, this._context.gl.RGBA);
            return l.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), i.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), i.colorAttachment.set(l.texture), {
              id: e,
              fbo: i,
              texture: l,
              stamp: -1,
              inUse: !1
            }
          }
          getObjectForId(e) {
            return this._objects[e]
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((i => e.id !== i)), this._recentlyUsed.push(e.id)
          }
          stampObject(e) {
            e.stamp = ++this._stamp
          }
          getOrCreateFreeObject() {
            for (const i of this._recentlyUsed)
              if (!this._objects[i].inUse) return this._objects[i];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e
          }
          freeObject(e) {
            e.inUse = !1
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e)
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((e => !e.inUse)) === !1
          }
        }
        const ro = {
          background: !0,
          fill: !0,
          line: !0,
          raster: !0,
          hillshade: !0,
          "color-relief": !0
        };
        class gi {
          constructor(e, i) {
            this.painter = e, this.terrain = i, this.pool = new If(e.context, 30, i.tileManager.tileSize * i.qualityFactor)
          }
          destruct() {
            this.pool.destruct()
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
          }
          prepareForRender(e, i) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e._order.filter((l => !e._layers[l].isHidden(i))), this._coordsAscending = {};
            for (const l in e.tileManagers) {
              this._coordsAscending[l] = {};
              const u = e.tileManagers[l].getVisibleCoordinates(),
                p = e.tileManagers[l].getSource(),
                v = p instanceof Tr ? p.terrainTileRanges : null;
              for (const T of u) {
                const S = this.terrain.tileManager.getTerrainCoords(T, v);
                for (const k in S) this._coordsAscending[l][k] || (this._coordsAscending[l][k] = []), this._coordsAscending[l][k].push(S[k])
              }
            }
            this._coordsAscendingStr = {};
            for (const l of e._order) {
              const u = e._layers[l],
                p = u.source;
              if (ro[u.type] && !this._coordsAscendingStr[p]) {
                this._coordsAscendingStr[p] = {};
                for (const v in this._coordsAscending[p]) this._coordsAscendingStr[p][v] = this._coordsAscending[p][v].map((T => T.key)).sort().join()
              }
            }
            for (const l of this._renderableTiles)
              for (const u in this._coordsAscendingStr) {
                const p = this._coordsAscendingStr[u][l.tileID.key];
                p && p !== l.rttCoords[u] && (l.rtt = [])
              }
          }
          renderLayer(e, i) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const l = Object.assign(Object.assign({}, i), {
                isRenderingToTexture: !0
              }),
              u = e.type,
              p = this.painter,
              v = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (ro[u] && (this._prevType && ro[this._prevType] || this._stacks.push([]), this._prevType = u, this._stacks[this._stacks.length - 1].push(e.id), !v)) return !0;
            if (ro[this._prevType] || ro[u] && v) {
              this._prevType = u;
              const T = this._stacks.length - 1,
                S = this._stacks[T] || [];
              for (const k of this._renderableTiles) {
                if (this.pool.isFull() && (fu(this.painter, this.terrain, this._rttTiles, l), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(k), k.rtt[T]) {
                  const V = this.pool.getObjectForId(k.rtt[T].id);
                  if (V.stamp === k.rtt[T].stamp) {
                    this.pool.useObject(V);
                    continue
                  }
                }
                const L = this.pool.getOrCreateFreeObject();
                this.pool.useObject(L), this.pool.stampObject(L), k.rtt[T] = {
                  id: L.id,
                  stamp: L.stamp
                }, p.context.bindFramebuffer.set(L.fbo.framebuffer), p.context.clear({
                  color: s.bi.transparent,
                  stencil: 0
                }), p.currentStencilSource = void 0;
                for (let V = 0; V < S.length; V++) {
                  const B = p.style._layers[S[V]],
                    H = B.source ? this._coordsAscending[B.source][k.tileID.key] : [k.tileID];
                  p.context.viewport.set([0, 0, L.fbo.width, L.fbo.height]), p._renderTileClippingMasks(B, H, !0), p.renderLayer(p, p.style.tileManagers[B.source], B, H, l), B.source && (k.rttCoords[B.source] = this._coordsAscendingStr[B.source][k.tileID.key])
                }
              }
              return fu(this.painter, this.terrain, this._rttTiles, l), this._rttTiles = [], this.pool.freeAllObjects(), ro[u]
            }
            return !1
          }
        }
        const Si = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "MapLibre logo",
            "Map.Title": "Map",
            "Marker.Title": "Map marker",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "Popup.Close": "Close popup",
            "ScaleControl.Feet": "ft",
            "ScaleControl.Meters": "m",
            "ScaleControl.Kilometers": "km",
            "ScaleControl.Miles": "mi",
            "ScaleControl.NauticalMiles": "nm",
            "GlobeControl.Enable": "Enable globe",
            "GlobeControl.Disable": "Disable globe",
            "TerrainControl.Enable": "Enable terrain",
            "TerrainControl.Disable": "Disable terrain",
            "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
            "CooperativeGesturesHandler.MacHelpText": "Use ‚åò + scroll to zoom the map",
            "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
          },
          Yd = F,
          Ls = {
            hash: !1,
            interactive: !0,
            bearingSnap: 7,
            attributionControl: ul,
            maplibreLogo: !1,
            refreshExpiredTiles: !0,
            canvasContextAttributes: {
              antialias: !1,
              preserveDrawingBuffer: !1,
              powerPreference: "high-performance",
              failIfMajorPerformanceCaveat: !1,
              desynchronized: !1,
              contextType: void 0
            },
            scrollZoom: !0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            trackResize: !0,
            center: [0, 0],
            elevation: 0,
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            renderWorldCopies: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: s.a.MAX_TILE_CACHE_ZOOM_LEVELS,
            transformRequest: null,
            transformCameraUpdate: null,
            transformConstrain: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            clickTolerance: 3,
            localIdeographFontFamily: "sans-serif",
            pitchWithRotate: !0,
            rollEnabled: !1,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096],
            cancelPendingTileRequestsWhileZooming: !0,
            centerClampedToGround: !0
          },
          rc = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1,
            visualizeRoll: !0
          };
        class Iu {
          constructor(e, i, l = !1) {
            this.mousedown = p => {
              this.startMove(p, $.mousePos(this.element, p)), $.addEventListener(window, "mousemove", this.mousemove), $.addEventListener(window, "mouseup", this.mouseup)
            }, this.mousemove = p => {
              this.move(p, $.mousePos(this.element, p))
            }, this.mouseup = p => {
              this._rotatePitchHandler.dragEnd(p), this.offTemp()
            }, this.touchstart = p => {
              p.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = $.touchPos(this.element, p.targetTouches)[0], this.startMove(p, this._startPos), $.addEventListener(window, "touchmove", this.touchmove, {
                passive: !1
              }), $.addEventListener(window, "touchend", this.touchend))
            }, this.touchmove = p => {
              p.targetTouches.length !== 1 ? this.reset() : (this._lastPos = $.touchPos(this.element, p.targetTouches)[0], this.move(p, this._lastPos))
            }, this.touchend = p => {
              p.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this._clickTolerance = 10, this.element = i;
            const u = new yu;
            this._rotatePitchHandler = new Cr({
              clickTolerance: 3,
              move: (p, v) => {
                const T = i.getBoundingClientRect(),
                  S = new s.P((T.bottom - T.top) / 2, (T.right - T.left) / 2);
                return {
                  bearingDelta: s.cq(new s.P(p.x, v.y), v, S),
                  pitchDelta: l ? -.5 * (v.y - p.y) : void 0
                }
              },
              moveStateManager: u,
              enable: !0,
              assignEvents: () => {}
            }), this.map = e, $.addEventListener(i, "mousedown", this.mousedown), $.addEventListener(i, "touchstart", this.touchstart, {
              passive: !1
            }), $.addEventListener(i, "touchcancel", this.reset)
          }
          startMove(e, i) {
            this._rotatePitchHandler.dragStart(e, i), $.disableDrag()
          }
          move(e, i) {
            const l = this.map,
              {
                bearingDelta: u,
                pitchDelta: p
              } = this._rotatePitchHandler.dragMove(e, i) || {};
            u && l.setBearing(l.getBearing() + u), p && l.setPitch(l.getPitch() + p)
          }
          off() {
            const e = this.element;
            $.removeEventListener(e, "mousedown", this.mousedown), $.removeEventListener(e, "touchstart", this.touchstart, {
              passive: !1
            }), $.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), $.removeEventListener(window, "touchend", this.touchend), $.removeEventListener(e, "touchcancel", this.reset), this.offTemp()
          }
          offTemp() {
            $.enableDrag(), $.removeEventListener(window, "mousemove", this.mousemove), $.removeEventListener(window, "mouseup", this.mouseup), $.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), $.removeEventListener(window, "touchend", this.touchend)
          }
        }
        let vo;

        function nc(h, e, i, l = !1) {
          if (l || !i.getCoveringTilesDetailsProvider().allowWorldCopies()) return h == null ? void 0 : h.wrap();
          const u = new s.U(h.lng, h.lat);
          if (h = new s.U(h.lng, h.lat), e) {
            const p = new s.U(h.lng - 360, h.lat),
              v = new s.U(h.lng + 360, h.lat),
              T = i.locationToScreenPoint(h).distSqr(e);
            i.locationToScreenPoint(p).distSqr(e) < T ? h = p : i.locationToScreenPoint(v).distSqr(e) < T && (h = v)
          }
          for (; Math.abs(h.lng - i.center.lng) > 180;) {
            const p = i.locationToScreenPoint(h);
            if (p.x >= 0 && p.y >= 0 && p.x <= i.width && p.y <= i.height) break;
            h.lng > i.center.lng ? h.lng -= 360 : h.lng += 360
          }
          return h.lng !== u.lng && i.isPointOnMapSurface(i.locationToScreenPoint(h)) ? h : u
        }
        const rs = {
          center: "translate(-50%,-50%)",
          top: "translate(-50%,0)",
          "top-left": "translate(0,0)",
          "top-right": "translate(-100%,0)",
          bottom: "translate(-50%,-100%)",
          "bottom-left": "translate(0,-100%)",
          "bottom-right": "translate(-100%,-100%)",
          left: "translate(0,-50%)",
          right: "translate(-100%,-50%)"
        };

        function ic(h, e, i) {
          const l = h.classList;
          for (const u in rs) l.remove(`maplibregl-${i}-anchor-${u}`);
          l.add(`maplibregl-${i}-anchor-${e}`)
        }
        class hl extends s.E {
          constructor(e) {
            if (super(), this._onKeyPress = i => {
                const l = i.code,
                  u = i.charCode || i.keyCode;
                l !== "Space" && l !== "Enter" && u !== 32 && u !== 13 || this.togglePopup()
              }, this._onMapClick = i => {
                const l = i.originalEvent.target,
                  u = this._element;
                this._popup && (l === u || u.contains(l)) && this.togglePopup()
              }, this._update = i => {
                if (!this._map) return;
                const l = this._map.loaded() && !this._map.isMoving();
                ((i == null ? void 0 : i.type) === "terrain" || (i == null ? void 0 : i.type) === "render" && !l) && this._map.once("render", this._update), this._lngLat = nc(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                let u = "";
                this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? u = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (u = `rotateZ(${this._rotation-this._map.getBearing()}deg)`);
                let p = "";
                this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? p = "rotateX(0deg)" : this._pitchAlignment === "map" && (p = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || i && i.type !== "moveend" || (this._pos = this._pos.round()), $.setTransform(this._element, `${rs[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${p} ${u}`), ae.frameAsync(new AbortController).then((() => {
                  this._updateOpacity(i && i.type === "moveend")
                })).catch((() => {}))
              }, this._onMove = i => {
                if (!this._isDragging) {
                  const l = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = i.point.dist(this._pointerdownPos) >= l
                }
                this._isDragging && (this._pos = i.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.l("dragstart"))), this.fire(new s.l("drag")))
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new s.l("dragend")), this._state = "inactive"
              }, this._addDragHandler = i => {
                this._element.contains(i.originalEvent.target) && (i.preventDefault(), this._positionDelta = i.point.sub(this._pos).add(this._offset), this._pointerdownPos = i.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp))
              }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = s.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = $.create("div");
              const i = $.createNS("http://www.w3.org/2000/svg", "svg"),
                l = 41,
                u = 27;
              i.setAttributeNS(null, "display", "block"), i.setAttributeNS(null, "height", `${l}px`), i.setAttributeNS(null, "width", `${u}px`), i.setAttributeNS(null, "viewBox", `0 0 ${u} ${l}`);
              const p = $.createNS("http://www.w3.org/2000/svg", "g");
              p.setAttributeNS(null, "stroke", "none"), p.setAttributeNS(null, "stroke-width", "1"), p.setAttributeNS(null, "fill", "none"), p.setAttributeNS(null, "fill-rule", "evenodd");
              const v = $.createNS("http://www.w3.org/2000/svg", "g");
              v.setAttributeNS(null, "fill-rule", "nonzero");
              const T = $.createNS("http://www.w3.org/2000/svg", "g");
              T.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), T.setAttributeNS(null, "fill", "#000000");
              const S = [{
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "9.5",
                ry: "4.77275007"
              }, {
                rx: "8.5",
                ry: "4.29549936"
              }, {
                rx: "7.5",
                ry: "3.81822308"
              }, {
                rx: "6.5",
                ry: "3.34094679"
              }, {
                rx: "5.5",
                ry: "2.86367051"
              }, {
                rx: "4.5",
                ry: "2.38636864"
              }];
              for (const de of S) {
                const ve = $.createNS("http://www.w3.org/2000/svg", "ellipse");
                ve.setAttributeNS(null, "opacity", "0.04"), ve.setAttributeNS(null, "cx", "10.5"), ve.setAttributeNS(null, "cy", "5.80029008"), ve.setAttributeNS(null, "rx", de.rx), ve.setAttributeNS(null, "ry", de.ry), T.appendChild(ve)
              }
              const k = $.createNS("http://www.w3.org/2000/svg", "g");
              k.setAttributeNS(null, "fill", this._color);
              const L = $.createNS("http://www.w3.org/2000/svg", "path");
              L.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), k.appendChild(L);
              const V = $.createNS("http://www.w3.org/2000/svg", "g");
              V.setAttributeNS(null, "opacity", "0.25"), V.setAttributeNS(null, "fill", "#000000");
              const B = $.createNS("http://www.w3.org/2000/svg", "path");
              B.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), V.appendChild(B);
              const H = $.createNS("http://www.w3.org/2000/svg", "g");
              H.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), H.setAttributeNS(null, "fill", "#FFFFFF");
              const re = $.createNS("http://www.w3.org/2000/svg", "g");
              re.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const le = $.createNS("http://www.w3.org/2000/svg", "circle");
              le.setAttributeNS(null, "fill", "#000000"), le.setAttributeNS(null, "opacity", "0.25"), le.setAttributeNS(null, "cx", "5.5"), le.setAttributeNS(null, "cy", "5.5"), le.setAttributeNS(null, "r", "5.4999962");
              const ue = $.createNS("http://www.w3.org/2000/svg", "circle");
              ue.setAttributeNS(null, "fill", "#FFFFFF"), ue.setAttributeNS(null, "cx", "5.5"), ue.setAttributeNS(null, "cy", "5.5"), ue.setAttributeNS(null, "r", "5.4999962"), re.appendChild(le), re.appendChild(ue), v.appendChild(T), v.appendChild(k), v.appendChild(V), v.appendChild(H), v.appendChild(re), i.appendChild(v), i.setAttributeNS(null, "height", l * this._scale + "px"), i.setAttributeNS(null, "width", u * this._scale + "px"), this._element.appendChild(i), this._offset = s.P.convert(e && e.offset || [0, -14])
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (i => {
                i.preventDefault()
              })), this._element.addEventListener("mousedown", (i => {
                i.preventDefault()
              })), ic(this._element, this._anchor, "marker"), e && e.className)
              for (const i of e.className.split(" ")) this._element.classList.add(i);
            this._popup = null
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), $.remove(this._element), this._popup && this._popup.remove(), this
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(e) {
            return this._lngLat = s.U.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this
          }
          getElement() {
            return this._element
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const u = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? {
                  top: [0, 0],
                  "top-left": [0, 0],
                  "top-right": [0, 0],
                  bottom: [0, -38.1],
                  "bottom-left": [u, -1 * (38.1 - 13.5 + u)],
                  "bottom-right": [-u, -1 * (38.1 - 13.5 + u)],
                  left: [13.5, -1 * (38.1 - 13.5)],
                  right: [-13.5, -1 * (38.1 - 13.5)]
                } : this._offset
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress)
            }
            return this
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this
          }
          getPopup() {
            return this._popup
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this
          }
          _updateOpacity(e = !1) {
            var i, l;
            const u = (i = this._map) === null || i === void 0 ? void 0 : i.terrain,
              p = this._map.transform.isLocationOccluded(this._lngLat);
            if (!u || p) {
              const H = p ? this._opacityWhenCovered : this._opacity;
              return void(this._element.style.opacity !== H && (this._element.style.opacity = H))
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null
              }), 100)
            }
            const v = this._map,
              T = v.terrain.depthAtPoint(this._pos),
              S = v.terrain.getElevationForLngLatZoom(this._lngLat, v.transform.tileZoom);
            if (v.transform.lngLatToCameraDepth(this._lngLat, S) - T < .006) return void(this._element.style.opacity = this._opacity);
            const k = -this._offset.y / v.transform.pixelsPerMeter,
              L = Math.sin(v.getPitch() * Math.PI / 180) * k,
              V = v.terrain.depthAtPoint(new s.P(this._pos.x, this._pos.y - this._offset.y)),
              B = v.transform.lngLatToCameraDepth(this._lngLat, S + L) - V > .006;
            !((l = this._popup) === null || l === void 0) && l.isOpen() && B && this._popup.remove(), this._element.style.opacity = B ? this._opacityWhenCovered : this._opacity
          }
          getOffset() {
            return this._offset
          }
          setOffset(e) {
            return this._offset = s.P.convert(e), this._update(), this
          }
          addClassName(e) {
            this._element.classList.add(e)
          }
          removeClassName(e) {
            this._element.classList.remove(e)
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e)
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this
          }
          isDraggable() {
            return this._draggable
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this
          }
          getRotation() {
            return this._rotation
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this
          }
          getRotationAlignment() {
            return this._rotationAlignment
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this
          }
          getPitchAlignment() {
            return this._pitchAlignment
          }
          setOpacity(e, i) {
            return (this._opacity === void 0 || e === void 0 && i === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), i !== void 0 && (this._opacityWhenCovered = i), this._map && this._updateOpacity(!0), this
          }
        }
        const Mu = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3
          },
          fitBoundsOptions: {
            maxZoom: 15
          },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0
        };
        let zs = 0,
          ns = !1;
        const Au = {
          maxWidth: 100,
          unit: "metric"
        };

        function ac(h, e, i) {
          const l = i && i.maxWidth || 100,
            u = h._container.clientHeight / 2,
            p = h._container.clientWidth / 2,
            v = h.unproject([p - l / 2, u]),
            T = h.unproject([p + l / 2, u]),
            S = Math.round(h.project(T).x - h.project(v).x),
            k = Math.min(l, S, h._container.clientWidth),
            L = v.distanceTo(T);
          if (i && i.unit === "imperial") {
            const V = 3.2808 * L;
            V > 5280 ? is(e, k, V / 5280, h._getUIString("ScaleControl.Miles")) : is(e, k, V, h._getUIString("ScaleControl.Feet"))
          } else i && i.unit === "nautical" ? is(e, k, L / 1852, h._getUIString("ScaleControl.NauticalMiles")) : L >= 1e3 ? is(e, k, L / 1e3, h._getUIString("ScaleControl.Kilometers")) : is(e, k, L, h._getUIString("ScaleControl.Meters"))
        }

        function is(h, e, i, l) {
          const u = (function(p) {
            const v = Math.pow(10, `${Math.floor(p)}`.length - 1);
            let T = p / v;
            return T = T >= 10 ? 10 : T >= 5 ? 5 : T >= 3 ? 3 : T >= 2 ? 2 : T >= 1 ? 1 : (function(S) {
              const k = Math.pow(10, Math.ceil(-Math.log(S) / Math.LN10));
              return Math.round(S * k) / k
            })(T), v * T
          })(i);
          h.style.width = e * (u / i) + "px", h.innerHTML = `${u}&nbsp;${l}`
        }
        const ku = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            subpixelPositioning: !1,
            locationOccludedOpacity: void 0
          },
          oc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

        function sc(h) {
          if (h) {
            if (typeof h == "number") {
              const e = Math.round(Math.abs(h) / Math.SQRT2);
              return {
                center: new s.P(0, 0),
                top: new s.P(0, h),
                "top-left": new s.P(e, e),
                "top-right": new s.P(-e, e),
                bottom: new s.P(0, -h),
                "bottom-left": new s.P(e, -e),
                "bottom-right": new s.P(-e, -e),
                left: new s.P(h, 0),
                right: new s.P(-h, 0)
              }
            }
            if (h instanceof s.P || Array.isArray(h)) {
              const e = s.P.convert(h);
              return {
                center: e,
                top: e,
                "top-left": e,
                "top-right": e,
                bottom: e,
                "bottom-left": e,
                "bottom-right": e,
                left: e,
                right: e
              }
            }
            return {
              center: s.P.convert(h.center || [0, 0]),
              top: s.P.convert(h.top || [0, 0]),
              "top-left": s.P.convert(h["top-left"] || [0, 0]),
              "top-right": s.P.convert(h["top-right"] || [0, 0]),
              bottom: s.P.convert(h.bottom || [0, 0]),
              "bottom-left": s.P.convert(h["bottom-left"] || [0, 0]),
              "bottom-right": s.P.convert(h["bottom-right"] || [0, 0]),
              left: s.P.convert(h.left || [0, 0]),
              right: s.P.convert(h.right || [0, 0])
            }
          }
          return sc(new s.P(0, 0))
        }
        const Eu = F;
        b.AJAXError = s.cC, b.Event = s.l, b.Evented = s.E, b.LngLat = s.U, b.MercatorCoordinate = s.a5, b.Point = s.P, b.addProtocol = s.cD, b.config = s.a, b.removeProtocol = s.cE, b.AttributionControl = na, b.BoxZoomHandler = Fd, b.CanvasSource = xr, b.CooperativeGesturesHandler = Za, b.DoubleClickZoomHandler = ll, b.DragPanHandler = Su, b.DragRotateHandler = Pu, b.EdgeInsets = Mn, b.FullscreenControl = class extends s.E {
          constructor(h = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let i = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = i == null ? void 0 : i.shadowRoot) === null || e === void 0) && e.fullscreenElement;) i = i.shadowRoot.fullscreenElement;
              i === this._container !== this._fullscreen && this._handleFullscreenChange()
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
            }, this._fullscreen = !1, h && h.container && (h.container instanceof HTMLElement ? this._container = h.container : s.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange")
          }
          onAdd(h) {
            return this._map = h, this._container || (this._container = this._map.getContainer()), this._controlContainer = $.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer
          }
          onRemove() {
            $.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _setupUI() {
            const h = this._fullscreenButton = $.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            $.create("span", "maplibregl-ctrl-icon", h).setAttribute("aria-hidden", "true"), h.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _updateTitle() {
            const h = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", h), this._fullscreenButton.title = h
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
          }
          _isFullscreen() {
            return this._fullscreen
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new s.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new s.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize()
          }
        }, b.GeoJSONSource = Jr, b.GeolocateControl = class extends s.E {
          constructor(h) {
            super(), this._onSuccess = e => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new s.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`)
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new s.l("geolocate", e)), this._finish()
              }
            }, this._updateCamera = e => {
              const i = new s.U(e.coords.longitude, e.coords.latitude),
                l = e.coords.accuracy,
                u = this._map.getBearing(),
                p = s.e({
                  bearing: u
                }, this.options.fitBoundsOptions),
                v = jt.fromLngLat(i, l);
              this._map.fitBounds(v, p, {
                geolocateSource: !0
              })
            }, this._updateMarker = e => {
              if (e) {
                const i = new s.U(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded()
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded()
            }, this._onError = e => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), this._geolocationWatchID !== void 0 && this._clearWatch()
                } else {
                  if (e.code === 3 && ns) return;
                  this._setErrorState()
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new s.l("error", e)), this._finish()
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e => e.preventDefault())), this._geolocateButton = $.create("button", "maplibregl-ctrl-geolocate", this._container), $.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0)
            }, this._finishSetupUI = e => {
              if (this._map) {
                if (e === !1) {
                  s.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i)
                } else {
                  const i = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i)
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = $.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new hl({
                  element: this._dotElement
                }), this._circleElement = $.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new hl({
                  element: this._circleElement,
                  pitchAlignment: "map"
                }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (i => {
                  const l = (i == null ? void 0 : i[0]) instanceof ResizeObserverEntry;
                  i.geolocateSource || this._watchState !== "ACTIVE_LOCK" || l || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new s.l("trackuserlocationend")), this.fire(new s.l("userlocationlostfocus")))
                }))
              }
            }, this.options = s.e({}, Mu, h)
          }
          onAdd(h) {
            return this._map = h, this._container = $.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return s._(this, arguments, void 0, (function*(e = !1) {
                if (vo !== void 0 && !e) return vo;
                if (window.navigator.permissions === void 0) return vo = !!window.navigator.geolocation, vo;
                try {
                  vo = (yield window.navigator.permissions.query({
                    name: "geolocation"
                  })).state !== "denied"
                } catch {
                  vo = !!window.navigator.geolocation
                }
                return vo
              }))
            })().then((e => this._finishSetupUI(e))), this._container
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), $.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, zs = 0, ns = !1
          }
          _isOutOfMapMaxBounds(h) {
            const e = this._map.getMaxBounds(),
              i = h.coords;
            return e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth())
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`)
            }
          }
          _updateCircleRadiusIfNeeded() {
            const h = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && h)) return;
            const e = this._map.project(h),
              i = this._map.unproject([e.x + 100, e.y]),
              l = h.distanceTo(i) / 100,
              u = 2 * this._accuracy / l;
            this._circleElement.style.width = `${u.toFixed(2)}px`, this._circleElement.style.height = `${u.toFixed(2)}px`
          }
          trigger() {
            if (!this._setup) return s.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new s.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  zs--, ns = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new s.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.l("trackuserlocationstart")), this.fire(new s.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let h;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), zs++, zs > 1 ? (h = {
                  maximumAge: 6e5,
                  timeout: 0
                }, ns = !0) : (h = this.options.positionOptions, ns = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, h)
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
          }
        }, b.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var h;
              const e = (h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type;
              this._map.setProjection(e !== "mercator" && e ? {
                type: "mercator"
              } : {
                type: "globe"
              }), this._updateGlobeIcon()
            }, this._updateGlobeIcon = () => {
              var h;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
            }
          }
          onAdd(h) {
            return this._map = h, this._container = $.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = $.create("button", "maplibregl-ctrl-globe", this._container), $.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container
          }
          onRemove() {
            $.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0
          }
        }, b.Hash = gu, b.ImageSource = Tr, b.KeyboardHandler = Zd, b.LngLatBounds = jt, b.LogoControl = Cu, b.Map = class extends $d {
          constructor(h) {
            var e, i;
            s.cz.mark(s.cA.create);
            const l = Object.assign(Object.assign(Object.assign({}, Ls), h), {
              canvasContextAttributes: Object.assign(Object.assign({}, Ls.canvasContextAttributes), h.canvasContextAttributes)
            });
            if (l.minZoom != null && l.maxZoom != null && l.minZoom > l.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (l.minPitch != null && l.maxPitch != null && l.minPitch > l.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (l.minPitch != null && l.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (l.maxPitch != null && l.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const u = new Kn,
              p = new Fi;
            if (l.minZoom !== void 0 && u.setMinZoom(l.minZoom), l.maxZoom !== void 0 && u.setMaxZoom(l.maxZoom), l.minPitch !== void 0 && u.setMinPitch(l.minPitch), l.maxPitch !== void 0 && u.setMaxPitch(l.maxPitch), l.renderWorldCopies !== void 0 && u.setRenderWorldCopies(l.renderWorldCopies), l.transformConstrain !== null && u.setConstrain(l.transformConstrain), super(u, p, {
                bearingSnap: l.bearingSnap
              }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Ga, this._controls = [], this._mapId = s.ab(), this._contextLost = T => {
                T.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new s.l("webglcontextlost", {
                  originalEvent: T
                }))
              }, this._contextRestored = T => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new s.l("webglcontextrestored", {
                  originalEvent: T
                }))
              }, this._onMapScroll = T => {
                if (T.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
              }, this._onWindowOnline = () => {
                this._update()
              }, this._interactive = l.interactive, this._maxTileCacheSize = l.maxTileCacheSize, this._maxTileCacheZoomLevels = l.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, l.canvasContextAttributes), this._trackResize = l.trackResize === !0, this._bearingSnap = l.bearingSnap, this._centerClampedToGround = l.centerClampedToGround, this._refreshExpiredTiles = l.refreshExpiredTiles === !0, this._fadeDuration = l.fadeDuration, this._crossSourceCollisions = l.crossSourceCollisions === !0, this._collectResourceTiming = l.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Si), l.locale), this._clickTolerance = l.clickTolerance, this._overridePixelRatio = l.pixelRatio, this._maxCanvasSize = l.maxCanvasSize, this.transformCameraUpdate = l.transformCameraUpdate, this.transformConstrain = l.transformConstrain, this.cancelPendingTileRequestsWhileZooming = l.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Ye.addThrottleControl((() => this.isMoving())), this._requestManager = new qe(l.transformRequest), typeof l.container == "string") {
              if (this._container = document.getElementById(l.container), !this._container) throw new Error(`Container '${l.container}' not found.`)
            } else {
              if (!(l.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = l.container
            }
            if (l.maxBounds && this.setMaxBounds(l.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
                this.painter.terrainFacilitator.dirty = !0, this._update(!0)
              })), this.once("idle", (() => {
                this._idleTriggered = !0
              })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let T = !1;
              const S = mu((k => {
                this._trackResize && !this._removed && (this.resize(k), this.redraw())
              }), 50);
              this._resizeObserver = new ResizeObserver((k => {
                T ? S(k) : T = !0
              })), this._resizeObserver.observe(this._container)
            }
            this.handlers = new cl(this, l), this._hash = l.hash && new gu(typeof l.hash == "string" && l.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
              center: l.center,
              elevation: l.elevation,
              zoom: l.zoom,
              bearing: l.bearing,
              pitch: l.pitch,
              roll: l.roll
            }), l.bounds && (this.resize(), this.fitBounds(l.bounds, s.e({}, l.fitBoundsOptions, {
              duration: 0
            }))));
            const v = typeof l.style == "string" || ((i = (e = l.style) === null || e === void 0 ? void 0 : e.projection) === null || i === void 0 ? void 0 : i.type) !== "globe";
            this.resize(null, v), this._localIdeographFontFamily = l.localIdeographFontFamily, this._validateStyle = l.validateStyle, l.style && this.setStyle(l.style, {
              localIdeographFontFamily: l.localIdeographFontFamily
            }), l.attributionControl && this.addControl(new na(typeof l.attributionControl == "boolean" ? void 0 : l.attributionControl)), l.maplibreLogo && this.addControl(new Cu, l.logoPosition), this.on("style.load", (() => {
              if (v || this._resizeTransform(), this.transform.unmodified) {
                const T = s.S(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(T)
              }
            })), this.on("data", (T => {
              this._update(T.dataType === "style"), this.fire(new s.l(`${T.dataType}data`, T))
            })), this.on("dataloading", (T => {
              this.fire(new s.l(`${T.dataType}dataloading`, T))
            })), this.on("dataabort", (T => {
              this.fire(new s.l("sourcedataabort", T))
            }))
          }
          _getMapId() {
            return this._mapId
          }
          setGlobalStateProperty(h, e) {
            return this.style.setGlobalStateProperty(h, e), this._update(!0)
          }
          getGlobalState() {
            return this.style.getGlobalState()
          }
          addControl(h, e) {
            if (e === void 0 && (e = h.getDefaultPosition ? h.getDefaultPosition() : "top-right"), !h || !h.onAdd) return this.fire(new s.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i = h.onAdd(this);
            this._controls.push(h);
            const l = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? l.insertBefore(i, l.firstChild) : l.appendChild(i), this
          }
          removeControl(h) {
            if (!h || !h.onRemove) return this.fire(new s.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(h);
            return e > -1 && this._controls.splice(e, 1), h.onRemove(this), this
          }
          hasControl(h) {
            return this._controls.indexOf(h) > -1
          }
          coveringTiles(h) {
            return Et(this.transform, h)
          }
          calculateCameraOptionsFromTo(h, e, i, l) {
            return l == null && this.terrain && (l = this.terrain.getElevationForLngLatZoom(i, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(h, e, i, l)
          }
          resize(h, e = !0) {
            const [i, l] = this._containerDimensions(), u = this._getClampedPixelRatio(i, l);
            if (this._resizeCanvas(i, l, u), this.painter.resize(i, l, u), this.painter.overLimit()) {
              const v = this.painter.context.gl;
              this._maxCanvasSize = [v.drawingBufferWidth, v.drawingBufferHeight];
              const T = this._getClampedPixelRatio(i, l);
              this._resizeCanvas(i, l, T), this.painter.resize(i, l, T)
            }
            this._resizeTransform(e);
            const p = !this._moving;
            return p && (this.stop(), this.fire(new s.l("movestart", h)).fire(new s.l("move", h))), this.fire(new s.l("resize", h)), p && this.fire(new s.l("moveend", h)), this
          }
          _resizeTransform(h = !0) {
            var e;
            const [i, l] = this._containerDimensions();
            this.transform.resize(i, l, h), (e = this._requestedCameraState) === null || e === void 0 || e.resize(i, l, h)
          }
          _getClampedPixelRatio(h, e) {
            const {
              0: i,
              1: l
            } = this._maxCanvasSize, u = this.getPixelRatio(), p = h * u, v = e * u;
            return Math.min(p > i ? i / p : 1, v > l ? l / v : 1) * u
          }
          getPixelRatio() {
            var h;
            return (h = this._overridePixelRatio) !== null && h !== void 0 ? h : devicePixelRatio
          }
          setPixelRatio(h) {
            this._overridePixelRatio = h, this.resize()
          }
          getBounds() {
            return this.transform.getBounds()
          }
          getMaxBounds() {
            return this.transform.getMaxBounds()
          }
          setMaxBounds(h) {
            return this.transform.setMaxBounds(jt.convert(h)), this._update()
          }
          setMinZoom(h) {
            if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom) return this.transform.setMinZoom(h), this._update(), this.getZoom() < h && this.setZoom(h), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
          }
          getMinZoom() {
            return this.transform.minZoom
          }
          setMaxZoom(h) {
            if ((h = h ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(h), this._update(), this.getZoom() > h && this.setZoom(h), this;
            throw new Error("maxZoom must be greater than the current minZoom")
          }
          getMaxZoom() {
            return this.transform.maxZoom
          }
          setMinPitch(h) {
            if ((h = h ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (h >= 0 && h <= this.transform.maxPitch) return this.transform.setMinPitch(h), this._update(), this.getPitch() < h && this.setPitch(h), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
          }
          getMinPitch() {
            return this.transform.minPitch
          }
          setMaxPitch(h) {
            if ((h = h ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (h >= this.transform.minPitch) return this.transform.setMaxPitch(h), this._update(), this.getPitch() > h && this.setPitch(h), this;
            throw new Error("maxPitch must be greater than the current minPitch")
          }
          getMaxPitch() {
            return this.transform.maxPitch
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies
          }
          setRenderWorldCopies(h) {
            return this.transform.setRenderWorldCopies(h), this._update()
          }
          setTransformConstrain(h) {
            return this.transform.setConstrain(h), this._update()
          }
          project(h) {
            return this.transform.locationToScreenPoint(s.U.convert(h), this.style && this.terrain)
          }
          unproject(h) {
            return this.transform.screenPointToLocation(s.P.convert(h), this.terrain)
          }
          isMoving() {
            var h;
            return this._moving || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isMoving())
          }
          isZooming() {
            var h;
            return this._zooming || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isZooming())
          }
          isRotating() {
            var h;
            return this._rotating || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isRotating())
          }
          _createDelegatedListener(h, e, i) {
            if (h === "mouseenter" || h === "mouseover") {
              let l = !1;
              return {
                layers: e,
                listener: i,
                delegates: {
                  mousemove: p => {
                    const v = e.filter((S => this.getLayer(S))),
                      T = v.length !== 0 ? this.queryRenderedFeatures(p.point, {
                        layers: v
                      }) : [];
                    T.length ? l || (l = !0, i.call(this, new va(h, this, p.originalEvent, {
                      features: T
                    }))) : l = !1
                  },
                  mouseout: () => {
                    l = !1
                  }
                }
              }
            }
            if (h === "mouseleave" || h === "mouseout") {
              let l = !1;
              return {
                layers: e,
                listener: i,
                delegates: {
                  mousemove: v => {
                    const T = e.filter((S => this.getLayer(S)));
                    (T.length !== 0 ? this.queryRenderedFeatures(v.point, {
                      layers: T
                    }) : []).length ? l = !0 : l && (l = !1, i.call(this, new va(h, this, v.originalEvent)))
                  },
                  mouseout: v => {
                    l && (l = !1, i.call(this, new va(h, this, v.originalEvent)))
                  }
                }
              }
            } {
              const l = u => {
                const p = e.filter((T => this.getLayer(T))),
                  v = p.length !== 0 ? this.queryRenderedFeatures(u.point, {
                    layers: p
                  }) : [];
                v.length && (u.features = v, i.call(this, u), delete u.features)
              };
              return {
                layers: e,
                listener: i,
                delegates: {
                  [h]: l
                }
              }
            }
          }
          _saveDelegatedListener(h, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[h] = this._delegatedListeners[h] || [], this._delegatedListeners[h].push(e)
          }
          _removeDelegatedListener(h, e, i) {
            if (!this._delegatedListeners || !this._delegatedListeners[h]) return;
            const l = this._delegatedListeners[h];
            for (let u = 0; u < l.length; u++) {
              const p = l[u];
              if (p.listener === i && p.layers.length === e.length && p.layers.every((v => e.includes(v)))) {
                for (const v in p.delegates) this.off(v, p.delegates[v]);
                return void l.splice(u, 1)
              }
            }
          }
          on(h, e, i) {
            if (i === void 0) return super.on(h, e);
            const l = typeof e == "string" ? [e] : e,
              u = this._createDelegatedListener(h, l, i);
            this._saveDelegatedListener(h, u);
            for (const p in u.delegates) this.on(p, u.delegates[p]);
            return {
              unsubscribe: () => {
                this._removeDelegatedListener(h, l, i)
              }
            }
          }
          once(h, e, i) {
            if (i === void 0) return super.once(h, e);
            const l = typeof e == "string" ? [e] : e,
              u = this._createDelegatedListener(h, l, i);
            for (const p in u.delegates) {
              const v = u.delegates[p];
              u.delegates[p] = (...T) => {
                this._removeDelegatedListener(h, l, i), v(...T)
              }
            }
            this._saveDelegatedListener(h, u);
            for (const p in u.delegates) this.once(p, u.delegates[p]);
            return this
          }
          off(h, e, i) {
            return i === void 0 ? super.off(h, e) : (this._removeDelegatedListener(h, typeof e == "string" ? [e] : e, i), this)
          }
          queryRenderedFeatures(h, e) {
            if (!this.style) return [];
            let i;
            const l = h instanceof s.P || Array.isArray(h),
              u = l ? h : [
                [0, 0],
                [this.transform.width, this.transform.height]
              ];
            if (e = e || (l ? {} : h) || {}, u instanceof s.P || typeof u[0] == "number") i = [s.P.convert(u)];
            else {
              const p = s.P.convert(u[0]),
                v = s.P.convert(u[1]);
              i = [p, new s.P(v.x, p.y), v, new s.P(p.x, v.y), p]
            }
            return this.style.queryRenderedFeatures(i, e, this.transform)
          }
          querySourceFeatures(h, e) {
            return this.style.querySourceFeatures(h, e)
          }
          setStyle(h, e) {
            return (e = s.e({}, {
              localIdeographFontFamily: this._localIdeographFontFamily,
              validate: this._validateStyle
            }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && h ? (this._diffStyle(h, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(h, e))
          }
          setTransformRequest(h) {
            return this._requestManager.setTransformRequest(h), this
          }
          _getUIString(h) {
            const e = this._locale[h];
            if (e == null) throw new Error(`Missing UI string '${h}'`);
            return e
          }
          _updateStyle(h, e) {
            var i, l;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(h, e)));
            const u = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!h)), h ? (this.style = new Xs(this, e || {}), this.style.setEventedParent(this, {
              style: this.style
            }), typeof h == "string" ? this.style.loadURL(h, e, u) : this.style.loadJSON(h, e, u), this) : ((l = (i = this.style) === null || i === void 0 ? void 0 : i.projection) === null || l === void 0 || l.destroy(), delete this.style, this)
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Xs(this, {}), this.style.setEventedParent(this, {
              style: this.style
            }), this.style.loadEmpty())
          }
          _diffStyle(h, e) {
            if (typeof h == "string") {
              const i = this._requestManager.transformRequest(h, "Style");
              s.j(i, new AbortController).then((l => {
                this._updateDiff(l.data, e)
              })).catch((l => {
                l && this.fire(new s.k(l))
              }))
            } else typeof h == "object" && this._updateDiff(h, e)
          }
          _updateDiff(h, e) {
            try {
              this.style.setState(h, e) && this._update(!0)
            } catch (i) {
              s.w(`Unable to perform style diff: ${i.message||i.error||i}.  Rebuilding the style from scratch.`), this._updateStyle(h, e)
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize()
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : s.w("There is no style added to the map.")
          }
          addSource(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(h, e), this._update(!0)
          }
          isSourceLoaded(h) {
            const e = this.style && this.style.tileManagers[h];
            if (e !== void 0) return e.loaded();
            this.fire(new s.k(new Error(`There is no tile manager with ID '${h}'`)))
          }
          setTerrain(h) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), h) {
              const e = this.style.tileManagers[h.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${h.source}`);
              this.terrain === null && e.reload();
              for (const i in this.style._layers) {
                const l = this.style._layers[i];
                l.type === "hillshade" && l.source === h.source && s.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), l.type === "color-relief" && l.source === h.source && s.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
              }
              this.terrain = new Cf(this.painter, e, h), this.painter.renderToTexture = new gi(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = i => {
                var l;
                i.dataType === "style" ? this.terrain.tileManager.freeRtt() : i.dataType === "source" && i.tile && (i.sourceId !== h.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((l = i.source) === null || l === void 0 ? void 0 : l.type) === "image" ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(i.tile.tileID))
              }, this.style.on("data", this._terrainDataCallback)
            } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new s.l("terrain", {
              terrain: h
            })), this
          }
          getTerrain() {
            var h, e;
            return (e = (h = this.terrain) === null || h === void 0 ? void 0 : h.options) !== null && e !== void 0 ? e : null
          }
          areTilesLoaded() {
            const h = this.style && this.style.tileManagers;
            for (const e in h) {
              const i = h[e]._tiles;
              for (const l in i) {
                const u = i[l];
                if (u.state !== "loaded" && u.state !== "errored") return !1
              }
            }
            return !0
          }
          removeSource(h) {
            return this.style.removeSource(h), this._update(!0)
          }
          getSource(h) {
            return this.style.getSource(h)
          }
          setSourceTileLodParams(h, e, i) {
            if (i) {
              const l = this.getSource(i);
              if (!l) throw new Error(`There is no source with ID "${i}", cannot set LOD parameters`);
              l.calculateTileZoom = Re(Math.max(1, h), Math.max(1, e))
            } else
              for (const l in this.style.tileManagers) this.style.tileManagers[l].getSource().calculateTileZoom = Re(Math.max(1, h), Math.max(1, e));
            return this._update(!0), this
          }
          refreshTiles(h, e) {
            const i = this.style.tileManagers[h];
            if (!i) throw new Error(`There is no tile manager with ID "${h}", cannot refresh tile`);
            e === void 0 ? i.reload(!0) : i.refreshTiles(e.map((l => new s.a8(l.z, l.x, l.y))))
          }
          addImage(h, e, i = {}) {
            const {
              pixelRatio: l = 1,
              sdf: u = !1,
              stretchX: p,
              stretchY: v,
              content: T,
              textFitWidth: S,
              textFitHeight: k
            } = i;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || s.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const {
                  width: L,
                  height: V,
                  data: B
                } = e, H = e;
                return this.style.addImage(h, {
                  data: new s.R({
                    width: L,
                    height: V
                  }, new Uint8Array(B)),
                  pixelRatio: l,
                  stretchX: p,
                  stretchY: v,
                  content: T,
                  textFitWidth: S,
                  textFitHeight: k,
                  sdf: u,
                  version: 0,
                  userImage: H
                }), H.onAdd && H.onAdd(this, h), this
              }
            } {
              const {
                width: L,
                height: V,
                data: B
              } = ae.getImageData(e);
              this.style.addImage(h, {
                data: new s.R({
                  width: L,
                  height: V
                }, B),
                pixelRatio: l,
                stretchX: p,
                stretchY: v,
                content: T,
                textFitWidth: S,
                textFitHeight: k,
                sdf: u,
                version: 0
              })
            }
          }
          updateImage(h, e) {
            const i = this.style.getImage(h);
            if (!i) return this.fire(new s.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const l = e instanceof HTMLImageElement || s.b(e) ? ae.getImageData(e) : e,
              {
                width: u,
                height: p,
                data: v
              } = l;
            if (u === void 0 || p === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (u !== i.data.width || p !== i.data.height) return this.fire(new s.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const T = !(e instanceof HTMLImageElement || s.b(e));
            return i.data.replace(v, T), this.style.updateImage(h, i), this
          }
          getImage(h) {
            return this.style.getImage(h)
          }
          hasImage(h) {
            return h ? !!this.style.getImage(h) : (this.fire(new s.k(new Error("Missing required image id"))), !1)
          }
          removeImage(h) {
            this.style.removeImage(h)
          }
          loadImage(h) {
            return Ye.getImage(this._requestManager.transformRequest(h, "Image"), new AbortController)
          }
          listImages() {
            return this.style.listImages()
          }
          addLayer(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(h, e), this._update(!0)
          }
          moveLayer(h, e) {
            return this.style.moveLayer(h, e), this._update(!0)
          }
          removeLayer(h) {
            return this.style.removeLayer(h), this._update(!0)
          }
          getLayer(h) {
            return this.style.getLayer(h)
          }
          getLayersOrder() {
            return this.style.getLayersOrder()
          }
          setLayerZoomRange(h, e, i) {
            return this.style.setLayerZoomRange(h, e, i), this._update(!0)
          }
          setFilter(h, e, i = {}) {
            return this.style.setFilter(h, e, i), this._update(!0)
          }
          getFilter(h) {
            return this.style.getFilter(h)
          }
          setPaintProperty(h, e, i, l = {}) {
            return this.style.setPaintProperty(h, e, i, l), this._update(!0)
          }
          getPaintProperty(h, e) {
            return this.style.getPaintProperty(h, e)
          }
          setLayoutProperty(h, e, i, l = {}) {
            return this.style.setLayoutProperty(h, e, i, l), this._update(!0)
          }
          getLayoutProperty(h, e) {
            return this.style.getLayoutProperty(h, e)
          }
          setGlyphs(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(h, e), this._update(!0)
          }
          getGlyphs() {
            return this.style.getGlyphsUrl()
          }
          addSprite(h, e, i = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(h, e, i, (l => {
              l || this._update(!0)
            })), this
          }
          removeSprite(h) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(h), this._update(!0)
          }
          getSprite() {
            return this.style.getSprite()
          }
          setSprite(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(h, e, (i => {
              i || this._update(!0)
            })), this
          }
          setLight(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(h, e), this._update(!0)
          }
          getLight() {
            return this.style.getLight()
          }
          setSky(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(h, e), this._update(!0)
          }
          getSky() {
            return this.style.getSky()
          }
          setFeatureState(h, e) {
            return this.style.setFeatureState(h, e), this._update()
          }
          removeFeatureState(h, e) {
            return this.style.removeFeatureState(h, e), this._update()
          }
          getFeatureState(h) {
            return this.style.getFeatureState(h)
          }
          getContainer() {
            return this._container
          }
          getCanvasContainer() {
            return this._canvasContainer
          }
          getCanvas() {
            return this._canvas
          }
          _containerDimensions() {
            let h = 0,
              e = 0;
            return this._container && (h = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [h, e]
          }
          _setupContainer() {
            const h = this._container;
            h.classList.add("maplibregl-map");
            const e = this._canvasContainer = $.create("div", "maplibregl-canvas-container", h);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = $.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const i = this._containerDimensions(),
              l = this._getClampedPixelRatio(i[0], i[1]);
            this._resizeCanvas(i[0], i[1], l);
            const u = this._controlContainer = $.create("div", "maplibregl-control-container", h),
              p = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((v => {
              p[v] = $.create("div", `maplibregl-ctrl-${v} `, u)
            })), this._container.addEventListener("scroll", this._onMapScroll, !1)
          }
          _resizeCanvas(h, e, i) {
            this._canvas.width = Math.floor(i * h), this._canvas.height = Math.floor(i * e), this._canvas.style.width = `${h}px`, this._canvas.style.height = `${e}px`
          }
          _setupPainter() {
            const h = Object.assign(Object.assign({}, this._canvasContextAttributes), {
              alpha: !0,
              depth: !0,
              stencil: !0,
              premultipliedAlpha: !0
            });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", (l => {
              e = {
                requestedAttributes: h
              }, l && (e.statusMessage = l.statusMessage, e.type = l.type)
            }), {
              once: !0
            });
            let i = null;
            if (i = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, h) : this._canvas.getContext("webgl2", h) || this._canvas.getContext("webgl", h), !i) {
              const l = "Failed to initialize WebGL";
              throw e ? (e.message = l, new Error(JSON.stringify(e))) : new Error(l)
            }
            this.painter = new Ad(i, this.transform), Se.testSupport(i)
          }
          migrateProjection(h, e) {
            super.migrateProjection(h, e), this.painter.transform = h, this.fire(new s.l("projectiontransition", {
              newProjection: this.style.projection.name
            }))
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
          }
          _update(h) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || h, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
          }
          _requestRenderFrame(h) {
            return this._update(), this._renderTaskQueue.add(h)
          }
          _cancelRenderFrame(h) {
            this._renderTaskQueue.remove(h)
          }
          _render(h) {
            var e, i, l, u, p;
            const v = this._idleTriggered ? this._fadeDuration : 0,
              T = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(h), this._removed) return;
            let S = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const V = this.transform.zoom,
                B = ie();
              this.style.zoomHistory.update(V, B);
              const H = new s.G(V, {
                  now: B,
                  fadeDuration: v,
                  zoomHistory: this.style.zoomHistory,
                  transition: this.style.getTransition()
                }),
                re = H.crossFadingFactor();
              re === 1 && re === this._crossFadingFactor || (S = !0, this._crossFadingFactor = re), this.style.update(H)
            }
            const k = ((i = this.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0 !== T;
            (l = this.style.projection) === null || l === void 0 || l.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((u = this.style.projection) === null || u === void 0 ? void 0 : u.transitionState, (p = this.style.projection) === null || p === void 0 ? void 0 : p.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || k) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, v, this._crossSourceCollisions, k), this.painter.render(this.style, {
              showTileBoundaries: this.showTileBoundaries,
              showOverdrawInspector: this._showOverdrawInspector,
              rotating: this.isRotating(),
              zooming: this.isZooming(),
              moving: this.isMoving(),
              fadeDuration: v,
              showPadding: this.showPadding
            }), this.fire(new s.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, s.cz.mark(s.cA.load), this.fire(new s.l("load"))), this.style && (this.style.hasTransitions() || S) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const L = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return L || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new s.l("idle")), !this._loaded || this._fullyLoaded || L || (this._fullyLoaded = !0, s.cz.mark(s.cA.fullLoad)), this
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this
          }
          remove() {
            var h;
            this._hash && this._hash.remove();
            for (const i of this._controls) i.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Ye.removeThrottleControl(this._imageQueueHandle), (h = this._resizeObserver) === null || h === void 0 || h.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), $.remove(this._canvasContainer), $.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), s.cz.clearMetrics(), this._removed = !0, this.fire(new s.l("remove"))
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController, ae.frame(this._frameRequest, (h => {
              s.cz.frame(h), this._frameRequest = null;
              try {
                this._render(h)
              } catch (e) {
                if (!s.cB(e) && !(function(i) {
                    return i.message === bd
                  })(e)) throw e
              }
            }), (() => {})))
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries
          }
          set showTileBoundaries(h) {
            this._showTileBoundaries !== h && (this._showTileBoundaries = h, this._update())
          }
          get showPadding() {
            return !!this._showPadding
          }
          set showPadding(h) {
            this._showPadding !== h && (this._showPadding = h, this._update())
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes
          }
          set showCollisionBoxes(h) {
            this._showCollisionBoxes !== h && (this._showCollisionBoxes = h, h ? this.style._generateCollisionBoxes() : this._update())
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector
          }
          set showOverdrawInspector(h) {
            this._showOverdrawInspector !== h && (this._showOverdrawInspector = h, this._update())
          }
          get repaint() {
            return !!this._repaint
          }
          set repaint(h) {
            this._repaint !== h && (this._repaint = h, this.triggerRepaint())
          }
          get vertices() {
            return !!this._vertices
          }
          set vertices(h) {
            this._vertices = h, this._update()
          }
          get version() {
            return Yd
          }
          getCameraTargetElevation() {
            return this.transform.elevation
          }
          getProjection() {
            return this.style.getProjection()
          }
          setProjection(h) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(h), this._update(!0)
          }
        }, b.MapMouseEvent = va, b.MapTouchEvent = ha, b.MapWheelEvent = Rd, b.Marker = hl, b.NavigationControl = class {
          constructor(h) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(),
                i = e === this._map.getMaxZoom(),
                l = e === this._map.getMinZoom();
              this._zoomInButton.disabled = i, this._zoomOutButton.disabled = l, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", l.toString())
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing-this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
            }, this._setButtonTitle = (e, i) => {
              const l = this._map._getUIString(`NavigationControl.${i}`);
              e.title = l, e.setAttribute("aria-label", l)
            }, this.options = s.e({}, rc, h), this._container = $.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e => this._map.zoomIn({}, {
              originalEvent: e
            }))), $.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e => this._map.zoomOut({}, {
              originalEvent: e
            }))), $.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                originalEvent: e
              }) : this._map.resetNorth({}, {
                originalEvent: e
              })
            })), this._compassIcon = $.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"))
          }
          onAdd(h) {
            return this._map = h, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Iu(this._map, this._compass, this.options.visualizePitch)), this._container
          }
          onRemove() {
            $.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map
          }
          _createButton(h, e) {
            const i = $.create("button", h, this._container);
            return i.type = "button", i.addEventListener("click", e), i
          }
        }, b.Popup = class extends s.E {
          constructor(h) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
            }, this.remove = () => (this._content && $.remove(this._content), this._container && ($.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new s.l("close"))), this), this._onMouseUp = e => {
              this._update(e.point)
            }, this._onMouseMove = e => {
              this._update(e.point)
            }, this._onDrag = e => {
              this._update(e.point)
            }, this._update = e => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = $.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = $.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const v of this.options.className.split(" ")) this._container.classList.add(v);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = nc(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const i = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let l = this.options.anchor;
              const u = sc(this.options.offset);
              if (!l) {
                const v = this._container.offsetWidth,
                  T = this._container.offsetHeight;
                let S;
                S = i.y + u.bottom.y < T ? ["top"] : i.y > this._map.transform.height - T ? ["bottom"] : [], i.x < v / 2 ? S.push("left") : i.x > this._map.transform.width - v / 2 && S.push("right"), l = S.length === 0 ? "bottom" : S.join("-")
              }
              let p = i.add(u[l]);
              this.options.subpixelPositioning || (p = p.round()), $.setTransform(this._container, `${rs[l]} translate(${p.x}px,${p.y}px)`), ic(this._container, l, "popup"), this._updateOpacity()
            }, this._onClose = () => {
              this.remove()
            }, this.options = s.e(Object.create(ku), h)
          }
          addTo(h) {
            return this._map && this.remove(), this._map = h, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new s.l("open")), this
          }
          isOpen() {
            return !!this._map
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(h) {
            return this._lngLat = s.U.convert(h), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this
          }
          getElement() {
            return this._container
          }
          setText(h) {
            return this.setDOMContent(document.createTextNode(h))
          }
          setHTML(h) {
            const e = document.createDocumentFragment(),
              i = document.createElement("body");
            let l;
            for (i.innerHTML = h; l = i.firstChild, l;) e.appendChild(l);
            return this.setDOMContent(e)
          }
          getMaxWidth() {
            var h;
            return (h = this._container) === null || h === void 0 ? void 0 : h.style.maxWidth
          }
          setMaxWidth(h) {
            return this.options.maxWidth = h, this._update(), this
          }
          setDOMContent(h) {
            if (this._content)
              for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = $.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(h), this._createCloseButton(), this._update(), this._focusFirstElement(), this
          }
          addClassName(h) {
            return this._container && this._container.classList.add(h), this
          }
          removeClassName(h) {
            return this._container && this._container.classList.remove(h), this
          }
          setOffset(h) {
            return this.options.offset = h, this._update(), this
          }
          toggleClassName(h) {
            if (this._container) return this._container.classList.toggle(h)
          }
          setSubpixelPositioning(h) {
            this.options.subpixelPositioning = h
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = $.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose))
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const h = this._container.querySelector(oc);
            h && h.focus()
          }
        }, b.RasterDEMTileSource = Yt, b.RasterTileSource = Gt, b.ScaleControl = class {
          constructor(h) {
            this._onMove = () => {
              ac(this._map, this._container, this.options)
            }, this.setUnit = e => {
              this.options.unit = e, ac(this._map, this._container, this.options)
            }, this.options = Object.assign(Object.assign({}, Au), h)
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(h) {
            return this._map = h, this._container = $.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", h.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container
          }
          onRemove() {
            $.remove(this._container), this._map.off("move", this._onMove), this._map = void 0
          }
        }, b.ScrollZoomHandler = Gd, b.Style = Xs, b.TerrainControl = class {
          constructor(h) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon()
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
            }, this.options = h
          }
          onAdd(h) {
            return this._map = h, this._container = $.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = $.create("button", "maplibregl-ctrl-terrain", this._container), $.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container
          }
          onRemove() {
            $.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0
          }
        }, b.TwoFingersTouchPitchHandler = Vd, b.TwoFingersTouchRotateHandler = ec, b.TwoFingersTouchZoomHandler = qd, b.TwoFingersTouchZoomRotateHandler = Wd, b.VectorTileSource = Lt, b.VideoSource = Ar, b.addSourceType = (h, e) => s._(void 0, void 0, void 0, (function*() {
          if (Yr(h)) throw new Error(`A source type called "${h}" already exists.`);
          ((i, l) => {
            qt[i] = l
          })(h, e)
        })), b.clearPrewarmedResources = function() {
          const h = tr;
          h && (h.isPreloaded() && h.numActive() === 1 ? (h.release(Pt), tr = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
        }, b.createTileMesh = wi, b.getMaxParallelImageRequests = function() {
          return s.a.MAX_PARALLEL_IMAGE_REQUESTS
        }, b.getRTLTextPluginStatus = function() {
          return D().getRTLTextPluginStatus()
        }, b.getVersion = function() {
          return Eu
        }, b.getWorkerCount = function() {
          return yt.workerCount
        }, b.getWorkerUrl = function() {
          return s.a.WORKER_URL
        }, b.importScriptInWorkers = function(h) {
          return Bt().broadcast("IS", h)
        }, b.isTimeFrozen = function() {
          return fe.isFrozen()
        }, b.now = ie, b.prewarm = function() {
          ht().acquire(Pt)
        }, b.restoreNow = function() {
          fe.restoreNow()
        }, b.setMaxParallelImageRequests = function(h) {
          s.a.MAX_PARALLEL_IMAGE_REQUESTS = h
        }, b.setNow = function(h) {
          fe.setNow(h)
        }, b.setRTLTextPlugin = function(h, e) {
          return D().setRTLTextPlugin(h, e)
        }, b.setWorkerCount = function(h) {
          yt.workerCount = h
        }, b.setWorkerUrl = function(h) {
          s.a.WORKER_URL = h
        }
      }));
      var z = d;
      return z
    }))
  })(Ip)), Ip.exports
}
var Q6 = J6();
const yp = ay(Q6);
class Yv {
  constructor(a) {
    Nr(this, "gm");
    Nr(this, "markers", new Map);
    Nr(this, "canvases", new Map);
    Nr(this, "canvasSize");
    Nr(this, "canvasOpacity", .8);
    this.input = a, this.gm = new Oa(this.input.tileSize);
    const d = sy(a.img);
    this.canvasSize = Math.ceil(2e3 / d)
  }
  place([a, d]) {
    const x = this.gm.latLonToPixelsFloor(a, d, this.input.zoom),
      A = this.getMarkerId(x),
      z = this.gm.latLonToPixelBoundsLatLon(a, d, this.input.zoom),
      b = this.input.map;
    if (this.input.markerFn && !this.markers.has(A)) {
      const te = this.input.markerFn();
      te.setLngLat({
        lat: z.min[0],
        lng: (z.max[1] + z.min[1]) / 2
      }).addTo(b), this.markers.set(A, te)
    }
    const {
      key: s,
      pos: F,
      innerPos: q
    } = this.getCanvasPos(x);
    let J = this.canvases.get(s);
    if (!J) {
      const te = this.canvasSize,
        ae = F.x * te,
        fe = F.y * te,
        ie = ae + te - 1,
        $ = fe + te - 1,
        Se = this.gm.pixelsToLatLon(ae, $ + 1, this.input.zoom),
        Me = this.gm.pixelsToLatLon(ie + 1, fe, this.input.zoom);
      J = new eA({
        id: `${this.input.id}-${s}`,
        img: this.input.img,
        canvasSize: this.canvasSize,
        coordinates: Ag({
          min: Se,
          max: Me
        }),
        layerPaint: {
          "raster-resampling": "nearest",
          "raster-opacity": this.canvasOpacity
        }
      }), J.addTo(this.input.map), this.canvases.set(s, J)
    }
    J.place(q.x, q.y)
  }
  clear() {
    const a = this.input.map;
    for (const d of this.canvases.values()) d.removeFrom(a), d.removeDOM();
    this.canvases.clear();
    for (const d of this.markers.values()) d.remove();
    this.markers.clear()
  }
  clearAndPlace(a) {
    this.clear(), this.place(a)
  }
  remove([a, d]) {
    let x = !1;
    const A = this.gm.latLonToPixelsFloor(a, d, this.input.zoom),
      {
        key: z,
        innerPos: b
      } = this.getCanvasPos(A),
      s = this.canvases.get(z);
    s && (x = s.remove(b.x, b.y), s.annotationsCount() === 0 && (this.canvases.delete(z), s.removeFrom(this.input.map), s.removeDOM()));
    const F = this.getMarkerId(A),
      q = this.markers.get(F);
    return q == null || q.remove(), this.markers.delete(F), x
  }
  setCanvasOpacity(a) {
    this.canvasOpacity = a;
    for (const d of this.canvases.values()) d.setOpacity(a)
  }
  getMarkerId([a, d]) {
    return `${this.input.id}:${a},${d}`
  }
  getCanvasPos([a, d]) {
    const x = {
        x: Math.floor(a / this.canvasSize),
        y: Math.floor(d / this.canvasSize)
      },
      A = {
        x: a % this.canvasSize,
        y: d % this.canvasSize
      },
      z = `${x.x},${x.y}`;
    return {
      pos: x,
      innerPos: A,
      key: z
    }
  }
}
class eA {
  constructor(a) {
    Nr(this, "annotations", new Set);
    Nr(this, "canvas");
    Nr(this, "imgSize");
    Nr(this, "maps", new Set);
    Nr(this, "pendingRepaint", !1);
    this.input = a, this.imgSize = sy(a.img), this.canvas = document.createElement("canvas"), this.canvas.width = this.input.canvasSize * this.imgSize, this.canvas.height = this.input.canvasSize * this.imgSize
  }
  place(a, d) {
    const x = this.getPixelKey(a, d);
    if (this.annotations.has(x)) return !1;
    const A = this.canvas.getContext("2d");
    if (A) {
      const z = a * this.imgSize,
        b = d * this.imgSize;
      A.drawImage(this.input.img, z, b)
    }
    return this.annotations.add(x), this.triggerRepaint(), !0
  }
  remove(a, d) {
    const x = this.getPixelKey(a, d);
    if (!this.annotations.has(x)) return !1;
    const A = this.canvas.getContext("2d");
    if (A) {
      const z = a * this.imgSize,
        b = d * this.imgSize;
      A.clearRect(z, b, this.imgSize, this.imgSize)
    }
    return this.annotations.delete(x), this.triggerRepaint(), !0
  }
  addTo(a) {
    const d = this.input.id;
    a.getSource(d) || a.addSource(d, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates,
      animate: !1
    }), a.getLayer(d) || a.addLayer({
      id: d,
      type: "raster",
      source: d,
      paint: this.input.layerPaint
    }), this.maps.add(a)
  }
  removeFrom(a) {
    const {
      id: d
    } = this.input;
    a.getLayer(d) && a.removeLayer(d), a.getSource(d) && a.removeSource(d), this.maps.delete(a)
  }
  removeDOM() {
    this.canvas.remove()
  }
  annotationsCount() {
    return this.annotations.size
  }
  setOpacity(a) {
    for (const d of this.maps.values()) d.setPaintProperty(this.input.id, "raster-opacity", a)
  }
  getPixelKey(a, d) {
    return `${a},${d}`
  }
  triggerRepaint() {
    this.pendingRepaint || (this.pendingRepaint = !0, requestAnimationFrame(() => {
      for (const a of this.maps.values()) {
        const d = a.getSource(this.input.id);
        d.play(), a.once("render", () => {
          d.pause(), this.pendingRepaint = !1
        })
      }
    }))
  }
}

function sy(m) {
  return Math.max(m.naturalWidth, m.naturalHeight)
}

function tA() {
  return window.matchMedia("(display-mode: standalone)").matches || "standalone" in window.navigator && window.navigator.standalone === !0
}

function rA(m) {
  const a = {
      opaque: !0
    },
    d = m.searchParams.get("lat"),
    x = m.searchParams.get("lng");
  d && x && (a.pos = {
    lat: parseFloat(d),
    lng: parseFloat(x)
  });
  const A = m.searchParams.get("zoom");
  A && (a.zoom = parseFloat(A));
  const z = m.searchParams.get("season");
  z && (a.season = parseInt(z));
  const b = m.searchParams.get("opaque");
  return b && (a.opaque = b !== "0"), m.searchParams.get("select") && (a.select = !0), m.searchParams.get("twitch-migration") && (a.twitchMigration = !0), a.newUser = !!m.searchParams.get("new-user"), a.discordLinked = !!m.searchParams.get("discord-linked"), a.alliance = !!m.searchParams.get("alliance"), a
}

function nA(m, a) {
  return m = new URL(m), a.pos !== void 0 && (m.searchParams.set("lat", a.pos.lat.toString()), m.searchParams.set("lng", a.pos.lng.toString())), a.zoom !== void 0 && m.searchParams.set("zoom", a.zoom.toString()), a.season !== void 0 && m.searchParams.set("season", a.season.toString()), a.opaque !== void 0 && m.searchParams.set("opaque", a.opaque ? "1" : "0"), a.newUser !== void 0 && m.searchParams.set("new-user", a.newUser ? "1" : "0"), a.alliance !== void 0 && m.searchParams.set("alliance", a.alliance ? "1" : "0"), a.select && m.searchParams.set("alliance", "1"), m
}
var zm = function() {
  return zm = Object.assign || function(a) {
    for (var d, x = 1, A = arguments.length; x < A; x++) {
      d = arguments[x];
      for (var z in d) Object.prototype.hasOwnProperty.call(d, z) && (a[z] = d[z])
    }
    return a
  }, zm.apply(this, arguments)
};

function Vo(m, a, d, x) {
  function A(z) {
    return z instanceof d ? z : new d(function(b) {
      b(z)
    })
  }
  return new(d || (d = Promise))(function(z, b) {
    function s(J) {
      try {
        q(x.next(J))
      } catch (te) {
        b(te)
      }
    }

    function F(J) {
      try {
        q(x.throw(J))
      } catch (te) {
        b(te)
      }
    }

    function q(J) {
      J.done ? z(J.value) : A(J.value).then(s, F)
    }
    q((x = x.apply(m, a || [])).next())
  })
}

function Uo(m, a) {
  var d = {
      label: 0,
      sent: function() {
        if (z[0] & 1) throw z[1];
        return z[1]
      },
      trys: [],
      ops: []
    },
    x, A, z, b = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return b.next = s(0), b.throw = s(1), b.return = s(2), typeof Symbol == "function" && (b[Symbol.iterator] = function() {
    return this
  }), b;

  function s(q) {
    return function(J) {
      return F([q, J])
    }
  }

  function F(q) {
    if (x) throw new TypeError("Generator is already executing.");
    for (; b && (b = 0, q[0] && (d = 0)), d;) try {
      if (x = 1, A && (z = q[0] & 2 ? A.return : q[0] ? A.throw || ((z = A.return) && z.call(A), 0) : A.next) && !(z = z.call(A, q[1])).done) return z;
      switch (A = 0, z && (q = [q[0] & 2, z.value]), q[0]) {
        case 0:
        case 1:
          z = q;
          break;
        case 4:
          return d.label++, {
            value: q[1],
            done: !1
          };
        case 5:
          d.label++, A = q[1], q = [0];
          continue;
        case 7:
          q = d.ops.pop(), d.trys.pop();
          continue;
        default:
          if (z = d.trys, !(z = z.length > 0 && z[z.length - 1]) && (q[0] === 6 || q[0] === 2)) {
            d = 0;
            continue
          }
          if (q[0] === 3 && (!z || q[1] > z[0] && q[1] < z[3])) {
            d.label = q[1];
            break
          }
          if (q[0] === 6 && d.label < z[1]) {
            d.label = z[1], z = q;
            break
          }
          if (z && d.label < z[2]) {
            d.label = z[2], d.ops.push(q);
            break
          }
          z[2] && d.ops.pop(), d.trys.pop();
          continue
      }
      q = a.call(m, d)
    } catch (J) {
      q = [6, J], A = 0
    } finally {
      x = z = 0
    }
    if (q[0] & 5) throw q[1];
    return {
      value: q[0] ? q[1] : void 0,
      done: !0
    }
  }
}

function ly(m, a, d) {
  if (d || arguments.length === 2)
    for (var x = 0, A = a.length, z; x < A; x++)(z || !(x in a)) && (z || (z = Array.prototype.slice.call(a, 0, x)), z[x] = a[x]);
  return m.concat(z || Array.prototype.slice.call(a))
}
var cy = "4.6.2";

function Op(m, a) {
  return new Promise(function(d) {
    return setTimeout(d, m, a)
  })
}

function iA() {
  return new Promise(function(m) {
    var a = new MessageChannel;
    a.port1.onmessage = function() {
      return m()
    }, a.port2.postMessage(null)
  })
}

function aA(m, a) {
  a === void 0 && (a = 1 / 0);
  var d = window.requestIdleCallback;
  return d ? new Promise(function(x) {
    return d.call(window, function() {
      return x()
    }, {
      timeout: a
    })
  }) : Op(Math.min(m, a))
}

function uy(m) {
  return !!m && typeof m.then == "function"
}

function Kv(m, a) {
  try {
    var d = m();
    uy(d) ? d.then(function(x) {
      return a(!0, x)
    }, function(x) {
      return a(!1, x)
    }) : a(!0, d)
  } catch (x) {
    a(!1, x)
  }
}

function Jv(m, a, d) {
  return d === void 0 && (d = 16), Vo(this, void 0, void 0, function() {
    var x, A, z, b;
    return Uo(this, function(s) {
      switch (s.label) {
        case 0:
          x = Array(m.length), A = Date.now(), z = 0, s.label = 1;
        case 1:
          return z < m.length ? (x[z] = a(m[z], z), b = Date.now(), b >= A + d ? (A = b, [4, iA()]) : [3, 3]) : [3, 4];
        case 2:
          s.sent(), s.label = 3;
        case 3:
          return ++z, [3, 1];
        case 4:
          return [2, x]
      }
    })
  })
}

function oh(m) {
  return m.then(void 0, function() {}), m
}

function oA(m, a) {
  for (var d = 0, x = m.length; d < x; ++d)
    if (m[d] === a) return !0;
  return !1
}

function sA(m, a) {
  return !oA(m, a)
}

function Eg(m) {
  return parseInt(m)
}

function Co(m) {
  return parseFloat(m)
}

function fs(m, a) {
  return typeof m == "number" && isNaN(m) ? a : m
}

function Da(m) {
  return m.reduce(function(a, d) {
    return a + (d ? 1 : 0)
  }, 0)
}

function hy(m, a) {
  if (a === void 0 && (a = 1), Math.abs(a) >= 1) return Math.round(m / a) * a;
  var d = 1 / a;
  return Math.round(m * d) / d
}

function lA(m) {
  for (var a, d, x = "Unexpected syntax '".concat(m, "'"), A = /^\s*([a-z-]*)(.*)$/i.exec(m), z = A[1] || void 0, b = {}, s = /([.:#][\w-]+|\[.+?\])/gi, F = function(ae, fe) {
      b[ae] = b[ae] || [], b[ae].push(fe)
    };;) {
    var q = s.exec(A[2]);
    if (!q) break;
    var J = q[0];
    switch (J[0]) {
      case ".":
        F("class", J.slice(1));
        break;
      case "#":
        F("id", J.slice(1));
        break;
      case "[": {
        var te = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(J);
        if (te) F(te[1], (d = (a = te[4]) !== null && a !== void 0 ? a : te[5]) !== null && d !== void 0 ? d : "");
        else throw new Error(x);
        break
      }
      default:
        throw new Error(x)
    }
  }
  return [z, b]
}

function cA(m) {
  for (var a = new Uint8Array(m.length), d = 0; d < m.length; d++) {
    var x = m.charCodeAt(d);
    if (x > 127) return new TextEncoder().encode(m);
    a[d] = x
  }
  return a
}

function Ns(m, a) {
  var d = m[0] >>> 16,
    x = m[0] & 65535,
    A = m[1] >>> 16,
    z = m[1] & 65535,
    b = a[0] >>> 16,
    s = a[0] & 65535,
    F = a[1] >>> 16,
    q = a[1] & 65535,
    J = 0,
    te = 0,
    ae = 0,
    fe = 0;
  fe += z + q, ae += fe >>> 16, fe &= 65535, ae += A + F, te += ae >>> 16, ae &= 65535, te += x + s, J += te >>> 16, te &= 65535, J += d + b, J &= 65535, m[0] = J << 16 | te, m[1] = ae << 16 | fe
}

function io(m, a) {
  var d = m[0] >>> 16,
    x = m[0] & 65535,
    A = m[1] >>> 16,
    z = m[1] & 65535,
    b = a[0] >>> 16,
    s = a[0] & 65535,
    F = a[1] >>> 16,
    q = a[1] & 65535,
    J = 0,
    te = 0,
    ae = 0,
    fe = 0;
  fe += z * q, ae += fe >>> 16, fe &= 65535, ae += A * q, te += ae >>> 16, ae &= 65535, ae += z * F, te += ae >>> 16, ae &= 65535, te += x * q, J += te >>> 16, te &= 65535, te += A * F, J += te >>> 16, te &= 65535, te += z * s, J += te >>> 16, te &= 65535, J += d * q + x * F + A * s + z * b, J &= 65535, m[0] = J << 16 | te, m[1] = ae << 16 | fe
}

function Cc(m, a) {
  var d = m[0];
  a %= 64, a === 32 ? (m[0] = m[1], m[1] = d) : a < 32 ? (m[0] = d << a | m[1] >>> 32 - a, m[1] = m[1] << a | d >>> 32 - a) : (a -= 32, m[0] = m[1] << a | d >>> 32 - a, m[1] = d << a | m[1] >>> 32 - a)
}

function Ka(m, a) {
  a %= 64, a !== 0 && (a < 32 ? (m[0] = m[1] >>> 32 - a, m[1] = m[1] << a) : (m[0] = m[1] << a - 32, m[1] = 0))
}

function Ci(m, a) {
  m[0] ^= a[0], m[1] ^= a[1]
}
var uA = [4283543511, 3981806797],
  hA = [3301882366, 444984403];

function Qv(m) {
  var a = [0, m[0] >>> 1];
  Ci(m, a), io(m, uA), a[1] = m[0] >>> 1, Ci(m, a), io(m, hA), a[1] = m[0] >>> 1, Ci(m, a)
}
var xp = [2277735313, 289559509],
  bp = [1291169091, 658871167],
  e0 = [0, 5],
  dA = [0, 1390208809],
  pA = [0, 944331445];

function fA(m, a) {
  var d = cA(m);
  a = a || 0;
  var x = [0, d.length],
    A = x[1] % 16,
    z = x[1] - A,
    b = [0, a],
    s = [0, a],
    F = [0, 0],
    q = [0, 0],
    J;
  for (J = 0; J < z; J = J + 16) F[0] = d[J + 4] | d[J + 5] << 8 | d[J + 6] << 16 | d[J + 7] << 24, F[1] = d[J] | d[J + 1] << 8 | d[J + 2] << 16 | d[J + 3] << 24, q[0] = d[J + 12] | d[J + 13] << 8 | d[J + 14] << 16 | d[J + 15] << 24, q[1] = d[J + 8] | d[J + 9] << 8 | d[J + 10] << 16 | d[J + 11] << 24, io(F, xp), Cc(F, 31), io(F, bp), Ci(b, F), Cc(b, 27), Ns(b, s), io(b, e0), Ns(b, dA), io(q, bp), Cc(q, 33), io(q, xp), Ci(s, q), Cc(s, 31), Ns(s, b), io(s, e0), Ns(s, pA);
  F[0] = 0, F[1] = 0, q[0] = 0, q[1] = 0;
  var te = [0, 0];
  switch (A) {
    case 15:
      te[1] = d[J + 14], Ka(te, 48), Ci(q, te);
    case 14:
      te[1] = d[J + 13], Ka(te, 40), Ci(q, te);
    case 13:
      te[1] = d[J + 12], Ka(te, 32), Ci(q, te);
    case 12:
      te[1] = d[J + 11], Ka(te, 24), Ci(q, te);
    case 11:
      te[1] = d[J + 10], Ka(te, 16), Ci(q, te);
    case 10:
      te[1] = d[J + 9], Ka(te, 8), Ci(q, te);
    case 9:
      te[1] = d[J + 8], Ci(q, te), io(q, bp), Cc(q, 33), io(q, xp), Ci(s, q);
    case 8:
      te[1] = d[J + 7], Ka(te, 56), Ci(F, te);
    case 7:
      te[1] = d[J + 6], Ka(te, 48), Ci(F, te);
    case 6:
      te[1] = d[J + 5], Ka(te, 40), Ci(F, te);
    case 5:
      te[1] = d[J + 4], Ka(te, 32), Ci(F, te);
    case 4:
      te[1] = d[J + 3], Ka(te, 24), Ci(F, te);
    case 3:
      te[1] = d[J + 2], Ka(te, 16), Ci(F, te);
    case 2:
      te[1] = d[J + 1], Ka(te, 8), Ci(F, te);
    case 1:
      te[1] = d[J], Ci(F, te), io(F, xp), Cc(F, 31), io(F, bp), Ci(b, F)
  }
  return Ci(b, x), Ci(s, x), Ns(b, s), Ns(s, b), Qv(b), Qv(s), Ns(b, s), Ns(s, b), ("00000000" + (b[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (b[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[1] >>> 0).toString(16)).slice(-8)
}

function mA(m) {
  var a;
  return zm({
    name: m.name,
    message: m.message,
    stack: (a = m.stack) === null || a === void 0 ? void 0 : a.split(`
`)
  }, m)
}

function gA(m) {
  return /^function\s.*?\{\s*\[native code]\s*}$/.test(String(m))
}

function _A(m) {
  return typeof m != "function"
}

function vA(m, a) {
  var d = oh(new Promise(function(x) {
    var A = Date.now();
    Kv(m.bind(null, a), function() {
      for (var z = [], b = 0; b < arguments.length; b++) z[b] = arguments[b];
      var s = Date.now() - A;
      if (!z[0]) return x(function() {
        return {
          error: z[1],
          duration: s
        }
      });
      var F = z[1];
      if (_A(F)) return x(function() {
        return {
          value: F,
          duration: s
        }
      });
      x(function() {
        return new Promise(function(q) {
          var J = Date.now();
          Kv(F, function() {
            for (var te = [], ae = 0; ae < arguments.length; ae++) te[ae] = arguments[ae];
            var fe = s + Date.now() - J;
            if (!te[0]) return q({
              error: te[1],
              duration: fe
            });
            q({
              value: te[1],
              duration: fe
            })
          })
        })
      })
    })
  }));
  return function() {
    return d.then(function(A) {
      return A()
    })
  }
}

function yA(m, a, d, x) {
  var A = Object.keys(m).filter(function(b) {
      return sA(d, b)
    }),
    z = oh(Jv(A, function(b) {
      return vA(m[b], a)
    }, x));
  return function() {
    return Vo(this, void 0, void 0, function() {
      var s, F, q, J, te;
      return Uo(this, function(ae) {
        switch (ae.label) {
          case 0:
            return [4, z];
          case 1:
            return s = ae.sent(), [4, Jv(s, function(fe) {
              return oh(fe())
            }, x)];
          case 2:
            return F = ae.sent(), [4, Promise.all(F)];
          case 3:
            for (q = ae.sent(), J = {}, te = 0; te < A.length; ++te) J[A[te]] = q[te];
            return [2, J]
        }
      })
    })
  }
}

function dy() {
  var m = window,
    a = navigator;
  return Da(["MSCSSMatrix" in m, "msSetImmediate" in m, "msIndexedDB" in m, "msMaxTouchPoints" in a, "msPointerEnabled" in a]) >= 4
}

function xA() {
  var m = window,
    a = navigator;
  return Da(["msWriteProfilerMark" in m, "MSStream" in m, "msLaunchUri" in a, "msSaveBlob" in a]) >= 3 && !dy()
}

function Kh() {
  var m = window,
    a = navigator;
  return Da(["webkitPersistentStorage" in a, "webkitTemporaryStorage" in a, (a.vendor || "").indexOf("Google") === 0, "webkitResolveLocalFileSystemURL" in m, "BatteryManager" in m, "webkitMediaStream" in m, "webkitSpeechGrammar" in m]) >= 5
}

function ko() {
  var m = window,
    a = navigator;
  return Da(["ApplePayError" in m, "CSSPrimitiveValue" in m, "Counter" in m, a.vendor.indexOf("Apple") === 0, "RGBColor" in m, "WebKitMediaKeys" in m]) >= 4
}

function Lg() {
  var m = window,
    a = m.HTMLElement,
    d = m.Document;
  return Da(["safari" in m, !("ongestureend" in m), !("TouchEvent" in m), !("orientation" in m), a && !("autocapitalize" in a.prototype), d && "pointerLockElement" in d.prototype]) >= 4
}

function Jh() {
  var m = window;
  return gA(m.print) && String(m.browser) === "[object WebPageNamespace]"
}

function py() {
  var m, a, d = window;
  return Da(["buildID" in navigator, "MozAppearance" in ((a = (m = document.documentElement) === null || m === void 0 ? void 0 : m.style) !== null && a !== void 0 ? a : {}), "onmozfullscreenchange" in d, "mozInnerScreenX" in d, "CSSMozDocumentRule" in d, "CanvasCaptureMediaStream" in d]) >= 4
}

function bA() {
  var m = window;
  return Da([!("MediaSettingsRange" in m), "RTCEncodedAudioFrame" in m, "" + m.Intl == "[object Intl]", "" + m.Reflect == "[object Reflect]"]) >= 3
}

function wA() {
  var m = window,
    a = m.URLPattern;
  return Da(["union" in Set.prototype, "Iterator" in m, a && "hasRegExpGroups" in a.prototype, "RGB8" in WebGLRenderingContext.prototype]) >= 3
}

function TA() {
  var m = window;
  return Da(["DOMRectList" in m, "RTCPeerConnectionIceEvent" in m, "SVGGeometryElement" in m, "ontransitioncancel" in m]) >= 3
}

function Qh() {
  var m = window,
    a = navigator,
    d = m.CSS,
    x = m.HTMLButtonElement;
  return Da([!("getStorageUpdates" in a), x && "popover" in x.prototype, "CSSCounterStyleRule" in m, d.supports("font-size-adjust: ex-height 0.5"), d.supports("text-transform: full-width")]) >= 4
}

function SA() {
  if (navigator.platform === "iPad") return !0;
  var m = screen,
    a = m.width / m.height;
  return Da(["MediaSource" in window, !!Element.prototype.webkitRequestFullscreen, a > .65 && a < 1.53]) >= 2
}

function PA() {
  var m = document;
  return m.fullscreenElement || m.msFullscreenElement || m.mozFullScreenElement || m.webkitFullscreenElement || null
}

function CA() {
  var m = document;
  return (m.exitFullscreen || m.msExitFullscreen || m.mozCancelFullScreen || m.webkitExitFullscreen).call(m)
}

function zg() {
  var m = Kh(),
    a = py(),
    d = window,
    x = navigator,
    A = "connection";
  return m ? Da([!("SharedWorker" in d), x[A] && "ontypechange" in x[A], !("sinkId" in new Audio)]) >= 2 : a ? Da(["onorientationchange" in d, "orientation" in d, /android/i.test(x.appVersion)]) >= 2 : !1
}

function IA() {
  var m = navigator,
    a = window,
    d = Audio.prototype,
    x = a.visualViewport;
  return Da(["srLatency" in d, "srChannelCount" in d, "devicePosture" in m, x && "segments" in x, "getTextInformation" in Image.prototype]) >= 3
}

function MA() {
  return EA() ? -4 : AA()
}

function AA() {
  var m = window,
    a = m.OfflineAudioContext || m.webkitOfflineAudioContext;
  if (!a) return -2;
  if (kA()) return -1;
  var d = 4500,
    x = 5e3,
    A = new a(1, x, 44100),
    z = A.createOscillator();
  z.type = "triangle", z.frequency.value = 1e4;
  var b = A.createDynamicsCompressor();
  b.threshold.value = -50, b.knee.value = 40, b.ratio.value = 12, b.attack.value = 0, b.release.value = .25, z.connect(b), b.connect(A.destination), z.start(0);
  var s = LA(A),
    F = s[0],
    q = s[1],
    J = oh(F.then(function(te) {
      return zA(te.getChannelData(0).subarray(d))
    }, function(te) {
      if (te.name === "timeout" || te.name === "suspended") return -3;
      throw te
    }));
  return function() {
    return q(), J
  }
}

function kA() {
  return ko() && !Lg() && !TA()
}

function EA() {
  return ko() && Qh() && Jh() || Kh() && IA() && wA()
}

function LA(m) {
  var a = 3,
    d = 500,
    x = 500,
    A = 5e3,
    z = function() {},
    b = new Promise(function(s, F) {
      var q = !1,
        J = 0,
        te = 0;
      m.oncomplete = function(ie) {
        return s(ie.renderedBuffer)
      };
      var ae = function() {
          setTimeout(function() {
            return F(t0("timeout"))
          }, Math.min(x, te + A - Date.now()))
        },
        fe = function() {
          try {
            var ie = m.startRendering();
            switch (uy(ie) && oh(ie), m.state) {
              case "running":
                te = Date.now(), q && ae();
                break;
              case "suspended":
                document.hidden || J++, q && J >= a ? F(t0("suspended")) : setTimeout(fe, d);
                break
            }
          } catch ($) {
            F($)
          }
        };
      fe(), z = function() {
        q || (q = !0, te > 0 && ae())
      }
    });
  return [b, z]
}

function zA(m) {
  for (var a = 0, d = 0; d < m.length; ++d) a += Math.abs(m[d]);
  return a
}

function t0(m) {
  var a = new Error(m);
  return a.name = m, a
}

function fy(m, a, d) {
  var x, A, z;
  return d === void 0 && (d = 50), Vo(this, void 0, void 0, function() {
    var b, s;
    return Uo(this, function(F) {
      switch (F.label) {
        case 0:
          b = document, F.label = 1;
        case 1:
          return b.body ? [3, 3] : [4, Op(d)];
        case 2:
          return F.sent(), [3, 1];
        case 3:
          s = b.createElement("iframe"), F.label = 4;
        case 4:
          return F.trys.push([4, , 10, 11]), [4, new Promise(function(q, J) {
            var te = !1,
              ae = function() {
                te = !0, q()
              },
              fe = function(Se) {
                te = !0, J(Se)
              };
            s.onload = ae, s.onerror = fe;
            var ie = s.style;
            ie.setProperty("display", "block", "important"), ie.position = "absolute", ie.top = "0", ie.left = "0", ie.visibility = "hidden", a && "srcdoc" in s ? s.srcdoc = a : s.src = "about:blank", b.body.appendChild(s);
            var $ = function() {
              var Se, Me;
              te || (((Me = (Se = s.contentWindow) === null || Se === void 0 ? void 0 : Se.document) === null || Me === void 0 ? void 0 : Me.readyState) === "complete" ? ae() : setTimeout($, 10))
            };
            $()
          })];
        case 5:
          F.sent(), F.label = 6;
        case 6:
          return !((A = (x = s.contentWindow) === null || x === void 0 ? void 0 : x.document) === null || A === void 0) && A.body ? [3, 8] : [4, Op(d)];
        case 7:
          return F.sent(), [3, 6];
        case 8:
          return [4, m(s, s.contentWindow)];
        case 9:
          return [2, F.sent()];
        case 10:
          return (z = s.parentNode) === null || z === void 0 || z.removeChild(s), [7];
        case 11:
          return [2]
      }
    })
  })
}

function DA(m) {
  for (var a = lA(m), d = a[0], x = a[1], A = document.createElement(d ?? "div"), z = 0, b = Object.keys(x); z < b.length; z++) {
    var s = b[z],
      F = x[s].join(" ");
    s === "style" ? RA(A.style, F) : A.setAttribute(s, F)
  }
  return A
}

function RA(m, a) {
  for (var d = 0, x = a.split(";"); d < x.length; d++) {
    var A = x[d],
      z = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(A);
    if (z) {
      var b = z[1],
        s = z[2],
        F = z[4];
      m.setProperty(b, s, F || "")
    }
  }
}

function FA() {
  for (var m = window;;) {
    var a = m.parent;
    if (!a || a === m) return !1;
    try {
      if (a.location.origin !== m.location.origin) return !0
    } catch (d) {
      if (d instanceof Error && d.name === "SecurityError") return !0;
      throw d
    }
    m = a
  }
}
var BA = "mmMwWLliI0O&1",
  OA = "48px",
  Ic = ["monospace", "sans-serif", "serif"],
  r0 = ["sans-serif-thin", "ARNO PRO", "Agency FB", "Arabic Typesetting", "Arial Unicode MS", "AvantGarde Bk BT", "BankGothic Md BT", "Batang", "Bitstream Vera Sans Mono", "Calibri", "Century", "Century Gothic", "Clarendon", "EUROSTILE", "Franklin Gothic", "Futura Bk BT", "Futura Md BT", "GOTHAM", "Gill Sans", "HELV", "Haettenschweiler", "Helvetica Neue", "Humanst521 BT", "Leelawadee", "Letter Gothic", "Levenim MT", "Lucida Bright", "Lucida Sans", "Menlo", "MS Mincho", "MS Outlook", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MYRIAD PRO", "Marlett", "Meiryo UI", "Microsoft Uighur", "Minion Pro", "Monotype Corsiva", "PMingLiU", "Pristina", "SCRIPTINA", "Segoe UI Light", "Serifa", "SimHei", "Small Fonts", "Staccato222 BT", "TRAJAN PRO", "Univers CE 55 Medium", "Vrinda", "ZWAdobeF"];

function NA() {
  var m = this;
  return fy(function(a, d) {
    var x = d.document;
    return Vo(m, void 0, void 0, function() {
      var A, z, b, s, F, q, J, te, ae, fe, ie, $;
      return Uo(this, function(Se) {
        for (A = x.body, A.style.fontSize = OA, z = x.createElement("div"), z.style.setProperty("visibility", "hidden", "important"), b = {}, s = {}, F = function(Me) {
            var Pe = x.createElement("span"),
              Ie = Pe.style;
            return Ie.position = "absolute", Ie.top = "0", Ie.left = "0", Ie.fontFamily = Me, Pe.textContent = BA, z.appendChild(Pe), Pe
          }, q = function(Me, Pe) {
            return F("'".concat(Me, "',").concat(Pe))
          }, J = function() {
            return Ic.map(F)
          }, te = function() {
            for (var Me = {}, Pe = function(Ye) {
                Me[Ye] = Ic.map(function(qe) {
                  return q(Ye, qe)
                })
              }, Ie = 0, Ce = r0; Ie < Ce.length; Ie++) {
              var je = Ce[Ie];
              Pe(je)
            }
            return Me
          }, ae = function(Me) {
            return Ic.some(function(Pe, Ie) {
              return Me[Ie].offsetWidth !== b[Pe] || Me[Ie].offsetHeight !== s[Pe]
            })
          }, fe = J(), ie = te(), A.appendChild(z), $ = 0; $ < Ic.length; $++) b[Ic[$]] = fe[$].offsetWidth, s[Ic[$]] = fe[$].offsetHeight;
        return [2, r0.filter(function(Me) {
          return ae(ie[Me])
        })]
      })
    })
  })
}

function jA() {
  var m = navigator.plugins;
  if (m) {
    for (var a = [], d = 0; d < m.length; ++d) {
      var x = m[d];
      if (x) {
        for (var A = [], z = 0; z < x.length; ++z) {
          var b = x[z];
          A.push({
            type: b.type,
            suffixes: b.suffixes
          })
        }
        a.push({
          name: x.name,
          description: x.description,
          mimeTypes: A
        })
      }
    }
    return a
  }
}

function qA() {
  return VA(XA())
}

function VA(m) {
  var a, d = !1,
    x, A, z = UA(),
    b = z[0],
    s = z[1];
  return ZA(b, s) ? (d = GA(s), m ? x = A = "skipped" : (a = HA(b, s), x = a[0], A = a[1])) : x = A = "unsupported", {
    winding: d,
    geometry: x,
    text: A
  }
}

function UA() {
  var m = document.createElement("canvas");
  return m.width = 1, m.height = 1, [m, m.getContext("2d")]
}

function ZA(m, a) {
  return !!(a && m.toDataURL)
}

function GA(m) {
  return m.rect(0, 0, 10, 10), m.rect(2, 2, 6, 6), !m.isPointInPath(5, 5, "evenodd")
}

function HA(m, a) {
  WA(m, a);
  var d = gm(m),
    x = gm(m);
  if (d !== x) return ["unstable", "unstable"];
  $A(m, a);
  var A = gm(m);
  return [A, d]
}

function WA(m, a) {
  m.width = 240, m.height = 60, a.textBaseline = "alphabetic", a.fillStyle = "#f60", a.fillRect(100, 1, 62, 20), a.fillStyle = "#069", a.font = '11pt "Times New Roman"';
  var d = "Cwm fjordbank gly ".concat("üòÉ");
  a.fillText(d, 2, 15), a.fillStyle = "rgba(102, 204, 0, 0.2)", a.font = "18pt Arial", a.fillText(d, 4, 45)
}

function $A(m, a) {
  m.width = 122, m.height = 110, a.globalCompositeOperation = "multiply";
  for (var d = 0, x = [
      ["#f2f", 40, 40],
      ["#2ff", 80, 40],
      ["#ff2", 60, 80]
    ]; d < x.length; d++) {
    var A = x[d],
      z = A[0],
      b = A[1],
      s = A[2];
    a.fillStyle = z, a.beginPath(), a.arc(b, s, 40, 0, Math.PI * 2, !0), a.closePath(), a.fill()
  }
  a.fillStyle = "#f9c", a.arc(60, 60, 60, 0, Math.PI * 2, !0), a.arc(60, 60, 20, 0, Math.PI * 2, !0), a.fill("evenodd")
}

function gm(m) {
  return m.toDataURL()
}

function XA() {
  return ko() && Qh() && Jh()
}

function YA() {
  var m = navigator,
    a = 0,
    d;
  m.maxTouchPoints !== void 0 ? a = Eg(m.maxTouchPoints) : m.msMaxTouchPoints !== void 0 && (a = m.msMaxTouchPoints);
  try {
    document.createEvent("TouchEvent"), d = !0
  } catch {
    d = !1
  }
  var x = "ontouchstart" in window;
  return {
    maxTouchPoints: a,
    touchEvent: d,
    touchStart: x
  }
}

function KA() {
  return navigator.oscpu
}

function JA() {
  var m = navigator,
    a = [],
    d = m.language || m.userLanguage || m.browserLanguage || m.systemLanguage;
  if (d !== void 0 && a.push([d]), Array.isArray(m.languages)) Kh() && bA() || a.push(m.languages);
  else if (typeof m.languages == "string") {
    var x = m.languages;
    x && a.push(x.split(","))
  }
  return a
}

function QA() {
  return window.screen.colorDepth
}

function ek() {
  return fs(Co(navigator.deviceMemory), void 0)
}

function tk() {
  if (!(ko() && Qh() && Jh())) return rk()
}

function rk() {
  var m = screen,
    a = function(x) {
      return fs(Eg(x), null)
    },
    d = [a(m.width), a(m.height)];
  return d.sort().reverse(), d
}
var nk = 2500,
  ik = 10,
  Mp, _m;

function ak() {
  if (_m === void 0) {
    var m = function() {
      var a = Dm();
      Rm(a) ? _m = setTimeout(m, nk) : (Mp = a, _m = void 0)
    };
    m()
  }
}

function ok() {
  var m = this;
  return ak(),
    function() {
      return Vo(m, void 0, void 0, function() {
        var a;
        return Uo(this, function(d) {
          switch (d.label) {
            case 0:
              return a = Dm(), Rm(a) ? Mp ? [2, ly([], Mp, !0)] : PA() ? [4, CA()] : [3, 2] : [3, 2];
            case 1:
              d.sent(), a = Dm(), d.label = 2;
            case 2:
              return Rm(a) || (Mp = a), [2, a]
          }
        })
      })
    }
}

function sk() {
  var m = this;
  if (ko() && Qh() && Jh()) return function() {
    return Promise.resolve(void 0)
  };
  var a = ok();
  return function() {
    return Vo(m, void 0, void 0, function() {
      var d, x;
      return Uo(this, function(A) {
        switch (A.label) {
          case 0:
            return [4, a()];
          case 1:
            return d = A.sent(), x = function(z) {
              return z === null ? null : hy(z, ik)
            }, [2, [x(d[0]), x(d[1]), x(d[2]), x(d[3])]]
        }
      })
    })
  }
}

function Dm() {
  var m = screen;
  return [fs(Co(m.availTop), null), fs(Co(m.width) - Co(m.availWidth) - fs(Co(m.availLeft), 0), null), fs(Co(m.height) - Co(m.availHeight) - fs(Co(m.availTop), 0), null), fs(Co(m.availLeft), null)]
}

function Rm(m) {
  for (var a = 0; a < 4; ++a)
    if (m[a]) return !1;
  return !0
}

function lk() {
  return fs(Eg(navigator.hardwareConcurrency), void 0)
}

function ck() {
  var m, a = (m = window.Intl) === null || m === void 0 ? void 0 : m.DateTimeFormat;
  if (a) {
    var d = new a().resolvedOptions().timeZone;
    if (d) return d
  }
  var x = -uk();
  return "UTC".concat(x >= 0 ? "+" : "").concat(x)
}

function uk() {
  var m = new Date().getFullYear();
  return Math.max(Co(new Date(m, 0, 1).getTimezoneOffset()), Co(new Date(m, 6, 1).getTimezoneOffset()))
}

function hk() {
  try {
    return !!window.sessionStorage
  } catch {
    return !0
  }
}

function dk() {
  try {
    return !!window.localStorage
  } catch {
    return !0
  }
}

function pk() {
  if (!(dy() || xA())) try {
    return !!window.indexedDB
  } catch {
    return !0
  }
}

function fk() {
  return !!window.openDatabase
}

function mk() {
  return navigator.cpuClass
}

function gk() {
  var m = navigator.platform;
  return m === "MacIntel" && ko() && !Lg() ? SA() ? "iPad" : "iPhone" : m
}

function _k() {
  return navigator.vendor || ""
}

function vk() {
  for (var m = [], a = 0, d = ["chrome", "safari", "__crWeb", "__gCrWeb", "yandex", "__yb", "__ybro", "__firefox__", "__edgeTrackingPreventionStatistics", "webkit", "oprt", "samsungAr", "ucweb", "UCShellJava", "puffinDevice"]; a < d.length; a++) {
    var x = d[a],
      A = window[x];
    A && typeof A == "object" && m.push(x)
  }
  return m.sort()
}

function yk() {
  var m = document;
  try {
    m.cookie = "cookietest=1; SameSite=Strict;";
    var a = m.cookie.indexOf("cookietest=") !== -1;
    return m.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", a
  } catch {
    return !1
  }
}

function xk() {
  var m = atob;
  return {
    abpIndo: ["#Iklan-Melayang", "#Kolom-Iklan-728", "#SidebarIklan-wrapper", '[title="ALIENBOLA" i]', m("I0JveC1CYW5uZXItYWRz")],
    abpvn: [".quangcao", "#mobileCatfish", m("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
    adBlockFinland: [".mainostila", m("LnNwb25zb3JpdA=="), ".ylamainos", m("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"), m("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")],
    adBlockPersian: ["#navbar_notice_50", ".kadr", 'TABLE[width="140px"]', "#divAgahi", m("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")],
    adBlockWarningRemoval: ["#adblock-honeypot", ".adblocker-root", ".wp_adblock_detect", m("LmhlYWRlci1ibG9ja2VkLWFk"), m("I2FkX2Jsb2NrZXI=")],
    adGuardAnnoyances: [".hs-sosyal", "#cookieconsentdiv", 'div[class^="app_gdpr"]', ".as-oil", '[data-cypress="soft-push-notification-modal"]'],
    adGuardBase: [".BetterJsPopOverlay", m("I2FkXzMwMFgyNTA="), m("I2Jhbm5lcmZsb2F0MjI="), m("I2NhbXBhaWduLWJhbm5lcg=="), m("I0FkLUNvbnRlbnQ=")],
    adGuardChinese: [m("LlppX2FkX2FfSA=="), m("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"), "#widget-quan", m("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"), m("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")],
    adGuardFrench: ["#pavePub", m("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"), ".mobile_adhesion", ".widgetadv", m("LmFkc19iYW4=")],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: ["#kauli_yad_1", m("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="), m("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="), m("LmFkZ29vZ2xl"), m("Ll9faXNib29zdFJldHVybkFk")],
    adGuardMobile: [m("YW1wLWF1dG8tYWRz"), m("LmFtcF9hZA=="), 'amp-embed[type="24smi"]', "#mgid_iframe1", m("I2FkX2ludmlld19hcmVh")],
    adGuardRussian: [m("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="), m("LnJlY2xhbWE="), 'div[id^="smi2adblock"]', m("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"), "#psyduckpockeball"],
    adGuardSocial: [m("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="), m("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="), ".etsy-tweet", "#inlineShare", ".popup-social"],
    adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
    adGuardTrackingProtection: ["#qoo-counter", m("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="), m("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="), m("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="), "#top100counter"],
    adGuardTurkish: ["#backkapat", m("I3Jla2xhbWk="), m("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="), m("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"), m("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")],
    bulgarian: [m("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
    easyList: [".yb-floorad", m("LndpZGdldF9wb19hZHNfd2lkZ2V0"), m("LnRyYWZmaWNqdW5reS1hZA=="), ".textad_headline", m("LnNwb25zb3JlZC10ZXh0LWxpbmtz")],
    easyListChina: [m("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="), m("LmZyb250cGFnZUFkdk0="), "#taotaole", "#aafoot.top_box", ".cfa_popup"],
    easyListCookie: [".ezmob-footer", ".cc-CookieWarning", "[data-cookie-number]", m("LmF3LWNvb2tpZS1iYW5uZXI="), ".sygnal24-gdpr-modal-wrap"],
    easyListCzechSlovak: ["#onlajny-stickers", m("I3Jla2xhbW5pLWJveA=="), m("LnJla2xhbWEtbWVnYWJvYXJk"), ".sklik", m("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")],
    easyListDutch: [m("I2FkdmVydGVudGll"), m("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="), ".adstekst", m("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="), "#semilo-lrectangle"],
    easyListGermany: ["#SSpotIMPopSlider", m("LnNwb25zb3JsaW5rZ3J1ZW4="), m("I3dlcmJ1bmdza3k="), m("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"), m("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")],
    easyListItaly: [m("LmJveF9hZHZfYW5udW5jaQ=="), ".sb-box-pubbliredazionale", m("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"), m("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"), m("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")],
    easyListLithuania: [m("LnJla2xhbW9zX3RhcnBhcw=="), m("LnJla2xhbW9zX251b3JvZG9z"), m("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"), m("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"), m("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")],
    estonian: [m("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [".open.pushModal", "#issuem-leaky-paywall-articles-zero-remaining-nag", "#sovrn_container", 'div[class$="-hide"][zoompage-fontsize][style="display: block;"]', ".BlockNag__Card"],
    fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
    frellwitSwedish: [m("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="), m("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="), "article.category-samarbete", m("ZGl2LmhvbGlkQWRz"), "ul.adsmodern"],
    greekAdBlock: [m("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"), m("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="), m("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"), "DIV.agores300", "TABLE.advright"],
    hungarian: ["#cemp_doboz", ".optimonk-iframe-container", m("LmFkX19tYWlu"), m("W2NsYXNzKj0iR29vZ2xlQWRzIl0="), "#hirdetesek_box"],
    iDontCareAboutCookies: ['.alert-info[data-block-track*="CookieNotice"]', ".ModuleTemplateCookieIndicator", ".o--cookies--container", "#cookies-policy-sticky", "#stickyCookieBar"],
    icelandicAbp: [m("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
    latvian: [m("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="), m("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")],
    listKr: [m("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="), m("I2xpdmVyZUFkV3JhcHBlcg=="), m("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="), m("aW5zLmZhc3R2aWV3LWFk"), ".revenue_unit_item.dable"],
    listeAr: [m("LmdlbWluaUxCMUFk"), ".right-and-left-sponsers", m("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="), m("YVtocmVmKj0iYm9vcmFxLm9yZyJd"), m("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")],
    listeFr: [m("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="), m("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="), m("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="), ".site-pub-interstitiel", 'div[id^="crt-"][data-criteo-id]'],
    officialPolish: ["#ceneo-placeholder-ceneo-12", m("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"), m("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="), m("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="), m("ZGl2I3NrYXBpZWNfYWQ=")],
    ro: [m("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"), m("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"), m("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="), m("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"), 'a[href^="/url/"]'],
    ruAd: [m("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"), m("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="), m("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="), "#pgeldiz", ".yandex-rtb-block"],
    thaiAds: ["a[href*=macau-uta-popup]", m("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="), m("LmFkczMwMHM="), ".bumq", ".img-kosana"],
    webAnnoyancesUltralist: ["#mod-social-share-2", "#social-tools", m("LmN0cGwtZnVsbGJhbm5lcg=="), ".zergnet-recommend", ".yt.btn-link.btn-md.btn"]
  }
}

function bk(m) {
  var a = m === void 0 ? {} : m,
    d = a.debug;
  return Vo(this, void 0, void 0, function() {
    var x, A, z, b, s, F;
    return Uo(this, function(q) {
      switch (q.label) {
        case 0:
          return wk() ? (x = xk(), A = Object.keys(x), z = (F = []).concat.apply(F, A.map(function(J) {
            return x[J]
          })), [4, Tk(z)]) : [2, void 0];
        case 1:
          return b = q.sent(), d && Sk(x, b), s = A.filter(function(J) {
            var te = x[J],
              ae = Da(te.map(function(fe) {
                return b[fe]
              }));
            return ae > te.length * .6
          }), s.sort(), [2, s]
      }
    })
  })
}

function wk() {
  return ko() || zg()
}

function Tk(m) {
  var a;
  return Vo(this, void 0, void 0, function() {
    var d, x, A, z, F, b, s, F;
    return Uo(this, function(q) {
      switch (q.label) {
        case 0:
          for (d = document, x = d.createElement("div"), A = new Array(m.length), z = {}, n0(x), F = 0; F < m.length; ++F) b = DA(m[F]), b.tagName === "DIALOG" && b.show(), s = d.createElement("div"), n0(s), s.appendChild(b), x.appendChild(s), A[F] = b;
          q.label = 1;
        case 1:
          return d.body ? [3, 3] : [4, Op(50)];
        case 2:
          return q.sent(), [3, 1];
        case 3:
          d.body.appendChild(x);
          try {
            for (F = 0; F < m.length; ++F) A[F].offsetParent || (z[m[F]] = !0)
          } finally {
            (a = x.parentNode) === null || a === void 0 || a.removeChild(x)
          }
          return [2, z]
      }
    })
  })
}

function n0(m) {
  m.style.setProperty("visibility", "hidden", "important"), m.style.setProperty("display", "block", "important")
}

function Sk(m, a) {
  for (var d = "DOM blockers debug:\n```", x = 0, A = Object.keys(m); x < A.length; x++) {
    var z = A[x];
    d += `
`.concat(z, ":");
    for (var b = 0, s = m[z]; b < s.length; b++) {
      var F = s[b];
      d += `
  `.concat(a[F] ? "üö´" : "‚û°Ô∏è", " ").concat(F)
    }
  }
  console.log("".concat(d, "\n```"))
}

function Pk() {
  for (var m = 0, a = ["rec2020", "p3", "srgb"]; m < a.length; m++) {
    var d = a[m];
    if (matchMedia("(color-gamut: ".concat(d, ")")).matches) return d
  }
}

function Ck() {
  if (i0("inverted")) return !0;
  if (i0("none")) return !1
}

function i0(m) {
  return matchMedia("(inverted-colors: ".concat(m, ")")).matches
}

function Ik() {
  if (a0("active")) return !0;
  if (a0("none")) return !1
}

function a0(m) {
  return matchMedia("(forced-colors: ".concat(m, ")")).matches
}
var Mk = 100;

function Ak() {
  if (matchMedia("(min-monochrome: 0)").matches) {
    for (var m = 0; m <= Mk; ++m)
      if (matchMedia("(max-monochrome: ".concat(m, ")")).matches) return m;
    throw new Error("Too high value")
  }
}

function kk() {
  if (Mc("no-preference")) return 0;
  if (Mc("high") || Mc("more")) return 1;
  if (Mc("low") || Mc("less")) return -1;
  if (Mc("forced")) return 10
}

function Mc(m) {
  return matchMedia("(prefers-contrast: ".concat(m, ")")).matches
}

function Ek() {
  if (o0("reduce")) return !0;
  if (o0("no-preference")) return !1
}

function o0(m) {
  return matchMedia("(prefers-reduced-motion: ".concat(m, ")")).matches
}

function Lk() {
  if (s0("reduce")) return !0;
  if (s0("no-preference")) return !1
}

function s0(m) {
  return matchMedia("(prefers-reduced-transparency: ".concat(m, ")")).matches
}

function zk() {
  if (l0("high")) return !0;
  if (l0("standard")) return !1
}

function l0(m) {
  return matchMedia("(dynamic-range: ".concat(m, ")")).matches
}
var si = Math,
  Ma = function() {
    return 0
  };

function Dk() {
  var m = si.acos || Ma,
    a = si.acosh || Ma,
    d = si.asin || Ma,
    x = si.asinh || Ma,
    A = si.atanh || Ma,
    z = si.atan || Ma,
    b = si.sin || Ma,
    s = si.sinh || Ma,
    F = si.cos || Ma,
    q = si.cosh || Ma,
    J = si.tan || Ma,
    te = si.tanh || Ma,
    ae = si.exp || Ma,
    fe = si.expm1 || Ma,
    ie = si.log1p || Ma,
    $ = function(Be) {
      return si.pow(si.PI, Be)
    },
    Se = function(Be) {
      return si.log(Be + si.sqrt(Be * Be - 1))
    },
    Me = function(Be) {
      return si.log(Be + si.sqrt(Be * Be + 1))
    },
    Pe = function(Be) {
      return si.log((1 + Be) / (1 - Be)) / 2
    },
    Ie = function(Be) {
      return si.exp(Be) - 1 / si.exp(Be) / 2
    },
    Ce = function(Be) {
      return (si.exp(Be) + 1 / si.exp(Be)) / 2
    },
    je = function(Be) {
      return si.exp(Be) - 1
    },
    Ye = function(Be) {
      return (si.exp(2 * Be) - 1) / (si.exp(2 * Be) + 1)
    },
    qe = function(Be) {
      return si.log(1 + Be)
    };
  return {
    acos: m(.12312423423423424),
    acosh: a(1e308),
    acoshPf: Se(1e154),
    asin: d(.12312423423423424),
    asinh: x(1),
    asinhPf: Me(1),
    atanh: A(.5),
    atanhPf: Pe(.5),
    atan: z(.5),
    sin: b(-1e300),
    sinh: s(1),
    sinhPf: Ie(1),
    cos: F(10.000000000123),
    cosh: q(1),
    coshPf: Ce(1),
    tan: J(-1e300),
    tanh: te(1),
    tanhPf: Ye(1),
    exp: ae(1),
    expm1: fe(1),
    expm1Pf: je(1),
    log1p: ie(10),
    log1pPf: qe(10),
    powPI: $(-100)
  }
}
var Rk = "mmMwWLliI0fiflO&1",
  vm = {
    default: [],
    apple: [{
      font: "-apple-system-body"
    }],
    serif: [{
      fontFamily: "serif"
    }],
    sans: [{
      fontFamily: "sans-serif"
    }],
    mono: [{
      fontFamily: "monospace"
    }],
    min: [{
      fontSize: "1px"
    }],
    system: [{
      fontFamily: "system-ui"
    }]
  };

function Fk() {
  return Bk(function(m, a) {
    for (var d = {}, x = {}, A = 0, z = Object.keys(vm); A < z.length; A++) {
      var b = z[A],
        s = vm[b],
        F = s[0],
        q = F === void 0 ? {} : F,
        J = s[1],
        te = J === void 0 ? Rk : J,
        ae = m.createElement("span");
      ae.textContent = te, ae.style.whiteSpace = "nowrap";
      for (var fe = 0, ie = Object.keys(q); fe < ie.length; fe++) {
        var $ = ie[fe],
          Se = q[$];
        Se !== void 0 && (ae.style[$] = Se)
      }
      d[b] = ae, a.append(m.createElement("br"), ae)
    }
    for (var Me = 0, Pe = Object.keys(vm); Me < Pe.length; Me++) {
      var b = Pe[Me];
      x[b] = d[b].getBoundingClientRect().width
    }
    return x
  })
}

function Bk(m, a) {
  return a === void 0 && (a = 4e3), fy(function(d, x) {
    var A = x.document,
      z = A.body,
      b = z.style;
    b.width = "".concat(a, "px"), b.webkitTextSizeAdjust = b.textSizeAdjust = "none", Kh() ? z.style.zoom = "".concat(1 / x.devicePixelRatio) : ko() && (z.style.zoom = "reset");
    var s = A.createElement("div");
    return s.textContent = ly([], Array(a / 20 << 0), !0).map(function() {
      return "word"
    }).join(" "), z.appendChild(s), m(A, z)
  }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
}

function Ok() {
  return navigator.pdfViewerEnabled
}

function Nk() {
  var m = new Float32Array(1),
    a = new Uint8Array(m.buffer);
  return m[0] = 1 / 0, m[0] = m[0] - m[0], a[3]
}

function jk() {
  var m = window.ApplePaySession;
  if (typeof(m == null ? void 0 : m.canMakePayments) != "function") return -1;
  if (qk()) return -3;
  try {
    return m.canMakePayments() ? 1 : 0
  } catch (a) {
    return Vk(a)
  }
}
var qk = FA;

function Vk(m) {
  if (m instanceof Error && m.name === "InvalidAccessError" && /\bfrom\b.*\binsecure\b/i.test(m.message)) return -2;
  throw m
}

function Uk() {
  var m, a = document.createElement("a"),
    d = (m = a.attributionSourceId) !== null && m !== void 0 ? m : a.attributionsourceid;
  return d === void 0 ? void 0 : String(d)
}
var my = -1,
  gy = -2,
  Zk = new Set([10752, 2849, 2884, 2885, 2886, 2928, 2929, 2930, 2931, 2932, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2978, 3024, 3042, 3088, 3089, 3106, 3107, 32773, 32777, 32777, 32823, 32824, 32936, 32937, 32938, 32939, 32968, 32969, 32970, 32971, 3317, 33170, 3333, 3379, 3386, 33901, 33902, 34016, 34024, 34076, 3408, 3410, 3411, 3412, 3413, 3414, 3415, 34467, 34816, 34817, 34818, 34819, 34877, 34921, 34930, 35660, 35661, 35724, 35738, 35739, 36003, 36004, 36005, 36347, 36348, 36349, 37440, 37441, 37443, 7936, 7937, 7938]),
  Gk = new Set([34047, 35723, 36063, 34852, 34853, 34854, 34229, 36392, 36795, 38449]),
  Hk = ["FRAGMENT_SHADER", "VERTEX_SHADER"],
  Wk = ["LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT", "LOW_INT", "MEDIUM_INT", "HIGH_INT"],
  _y = "WEBGL_debug_renderer_info",
  $k = "WEBGL_polygon_mode";

function Xk(m) {
  var a, d, x, A, z, b, s = m.cache,
    F = vy(s);
  if (!F) return my;
  if (!xy(F)) return gy;
  var q = yy() ? null : F.getExtension(_y);
  return {
    version: ((a = F.getParameter(F.VERSION)) === null || a === void 0 ? void 0 : a.toString()) || "",
    vendor: ((d = F.getParameter(F.VENDOR)) === null || d === void 0 ? void 0 : d.toString()) || "",
    vendorUnmasked: q ? (x = F.getParameter(q.UNMASKED_VENDOR_WEBGL)) === null || x === void 0 ? void 0 : x.toString() : "",
    renderer: ((A = F.getParameter(F.RENDERER)) === null || A === void 0 ? void 0 : A.toString()) || "",
    rendererUnmasked: q ? (z = F.getParameter(q.UNMASKED_RENDERER_WEBGL)) === null || z === void 0 ? void 0 : z.toString() : "",
    shadingLanguageVersion: ((b = F.getParameter(F.SHADING_LANGUAGE_VERSION)) === null || b === void 0 ? void 0 : b.toString()) || ""
  }
}

function Yk(m) {
  var a = m.cache,
    d = vy(a);
  if (!d) return my;
  if (!xy(d)) return gy;
  var x = d.getSupportedExtensions(),
    A = d.getContextAttributes(),
    z = [],
    b = [],
    s = [],
    F = [],
    q = [];
  if (A)
    for (var J = 0, te = Object.keys(A); J < te.length; J++) {
      var ae = te[J];
      b.push("".concat(ae, "=").concat(A[ae]))
    }
  for (var fe = c0(d), ie = 0, $ = fe; ie < $.length; ie++) {
    var Se = $[ie],
      Me = d[Se];
    s.push("".concat(Se, "=").concat(Me).concat(Zk.has(Me) ? "=".concat(d.getParameter(Me)) : ""))
  }
  if (x)
    for (var Pe = 0, Ie = x; Pe < Ie.length; Pe++) {
      var Ce = Ie[Pe];
      if (!(Ce === _y && yy() || Ce === $k && Qk())) {
        var je = d.getExtension(Ce);
        if (!je) {
          z.push(Ce);
          continue
        }
        for (var Ye = 0, qe = c0(je); Ye < qe.length; Ye++) {
          var Se = qe[Ye],
            Me = je[Se];
          F.push("".concat(Se, "=").concat(Me).concat(Gk.has(Me) ? "=".concat(d.getParameter(Me)) : ""))
        }
      }
    }
  for (var Be = 0, He = Hk; Be < He.length; Be++)
    for (var we = He[Be], it = 0, mt = Wk; it < mt.length; it++) {
      var Ge = mt[it],
        Xe = Kk(d, we, Ge);
      q.push("".concat(we, ".").concat(Ge, "=").concat(Xe.join(",")))
    }
  return F.sort(), s.sort(), {
    contextAttributes: b,
    parameters: s,
    shaderPrecisions: q,
    extensions: x,
    extensionParameters: F,
    unsupportedExtensions: z
  }
}

function vy(m) {
  if (m.webgl) return m.webgl.context;
  var a = document.createElement("canvas"),
    d;
  a.addEventListener("webglCreateContextError", function() {
    return d = void 0
  });
  for (var x = 0, A = ["webgl", "experimental-webgl"]; x < A.length; x++) {
    var z = A[x];
    try {
      d = a.getContext(z)
    } catch {}
    if (d) break
  }
  return m.webgl = {
    context: d
  }, d
}

function Kk(m, a, d) {
  var x = m.getShaderPrecisionFormat(m[a], m[d]);
  return x ? [x.rangeMin, x.rangeMax, x.precision] : []
}

function c0(m) {
  var a = Object.keys(m.__proto__);
  return a.filter(Jk)
}

function Jk(m) {
  return typeof m == "string" && !m.match(/[^A-Z0-9_x]/)
}

function yy() {
  return py()
}

function Qk() {
  return Kh() || ko()
}

function xy(m) {
  return typeof m.getParameter == "function"
}

function eE() {
  var m = zg() || ko();
  if (!m) return -2;
  if (!window.AudioContext) return -1;
  var a = new AudioContext().baseLatency;
  return a == null ? -1 : isFinite(a) ? a : -3
}

function tE() {
  if (!window.Intl) return -1;
  var m = window.Intl.DateTimeFormat;
  if (!m) return -2;
  var a = m().resolvedOptions().locale;
  return !a && a !== "" ? -3 : a
}
var rE = {
  fonts: NA,
  domBlockers: bk,
  fontPreferences: Fk,
  audio: MA,
  screenFrame: sk,
  canvas: qA,
  osCpu: KA,
  languages: JA,
  colorDepth: QA,
  deviceMemory: ek,
  screenResolution: tk,
  hardwareConcurrency: lk,
  timezone: ck,
  sessionStorage: hk,
  localStorage: dk,
  indexedDB: pk,
  openDatabase: fk,
  cpuClass: mk,
  platform: gk,
  plugins: jA,
  touchSupport: YA,
  vendor: _k,
  vendorFlavors: vk,
  cookiesEnabled: yk,
  colorGamut: Pk,
  invertedColors: Ck,
  forcedColors: Ik,
  monochrome: Ak,
  contrast: kk,
  reducedMotion: Ek,
  reducedTransparency: Lk,
  hdr: zk,
  math: Dk,
  pdfViewerEnabled: Ok,
  architecture: Nk,
  applePay: jk,
  privateClickMeasurement: Uk,
  audioBaseLatency: eE,
  dateTimeLocale: tE,
  webGlBasics: Xk,
  webGlExtensions: Yk
};

function nE(m) {
  return yA(rE, m, [])
}
var iE = "$ if upgrade to Pro: https://fpjs.dev/pro";

function aE(m) {
  var a = oE(m),
    d = sE(a);
  return {
    score: a,
    comment: iE.replace(/\$/g, "".concat(d))
  }
}

function oE(m) {
  if (zg()) return .4;
  if (ko()) return Lg() && !(Qh() && Jh()) ? .5 : .3;
  var a = "value" in m.platform ? m.platform.value : "";
  return /^Win/.test(a) ? .6 : /^Mac/.test(a) ? .5 : .7
}

function sE(m) {
  return hy(.99 + .01 * m, 1e-4)
}

function lE(m) {
  for (var a = "", d = 0, x = Object.keys(m).sort(); d < x.length; d++) {
    var A = x[d],
      z = m[A],
      b = "error" in z ? "error" : JSON.stringify(z.value);
    a += "".concat(a ? "|" : "").concat(A.replace(/([:|\\])/g, "\\$1"), ":").concat(b)
  }
  return a
}

function by(m) {
  return JSON.stringify(m, function(a, d) {
    return d instanceof Error ? mA(d) : d
  }, 2)
}

function wy(m) {
  return fA(lE(m))
}

function cE(m) {
  var a, d = aE(m);
  return {
    get visitorId() {
      return a === void 0 && (a = wy(this.components)), a
    },
    set visitorId(x) {
      a = x
    },
    confidence: d,
    components: m,
    version: cy
  }
}

function uE(m) {
  return m === void 0 && (m = 50), aA(m, m * 2)
}

function hE(m, a) {
  var d = Date.now();
  return {
    get: function(x) {
      return Vo(this, void 0, void 0, function() {
        var A, z, b;
        return Uo(this, function(s) {
          switch (s.label) {
            case 0:
              return A = Date.now(), [4, m()];
            case 1:
              return z = s.sent(), b = cE(z), (a || x != null && x.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(b.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(A - d, `
visitorId: `).concat(b.visitorId, `
components: `).concat(by(z), "\n```")), [2, b]
          }
        })
      })
    }
  }
}

function dE() {
  if (!(window.__fpjs_d_m || Math.random() >= .001)) try {
    var m = new XMLHttpRequest;
    m.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(cy, "/npm-monitoring"), !0), m.send()
  } catch (a) {
    console.error(a)
  }
}

function pE(m) {
  var a;
  return m === void 0 && (m = {}), Vo(this, void 0, void 0, function() {
    var d, x, A;
    return Uo(this, function(z) {
      switch (z.label) {
        case 0:
          return (!((a = m.monitoring) !== null && a !== void 0) || a) && dE(), d = m.delayFallback, x = m.debug, [4, uE(d)];
        case 1:
          return z.sent(), A = nE({
            cache: {},
            debug: x
          }), [2, hE(A, x)]
      }
    })
  })
}
var fE = {
  load: pE,
  hashComponents: wy,
  componentsToDebugString: by
};
let ym = null;
async function mE() {
  return ym || (ym = fE.load()), ym
}
async function Dg() {
  return (await (await mE()).get()).visitorId
}
var gE = jr('<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>');

function Il(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = gE();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var _E = jr('<svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"></path></svg>');

function ws(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = _E();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}

function Ap(m) {
  const a = document.createElement("img");
  return a.src = m, new Promise((d, x) => {
    a.addEventListener("load", () => {
      d(a)
    }), a.addEventListener("error", A => {
      x(A)
    })
  })
}

function Ty(m) {
  const a = document.createElement("canvas");
  a.width = m.naturalWidth, a.height = m.naturalHeight;
  const d = a.getContext("2d");
  return d == null || d.drawImage(m, 0, 0), a
}
var vE = me('<button type="button"></button>'),
  yE = me('<div class="overlay pointer-events-auto svelte-rxq6cp"><canvas></canvas> <div class="overlay-border svelte-rxq6cp"></div> <!></div>'),
  xE = me('<div><!> <p class="text-base font-medium">Drop an image or click the button below to select a file</p> <input type="file" accept="image/*" class="hidden" id="auto-paint-file"/> <label for="auto-paint-file" class="btn btn-primary btn-sm">Upload image</label></div>'),
  bE = me("<option> </option>"),
  wE = me('<span class="loading loading-spinner loading-sm"></span> Processing', 1),
  TE = me('<button class="btn btn-primary"><!></button>'),
  SE = me('<span class="loading loading-spinner loading-sm"></span> Sending', 1),
  PE = me('<button class="btn btn-primary"><!></button>'),
  CE = me('<div class="rounded-box bg-success/10 text-success px-3 py-2 text-sm"> </div>'),
  IE = me('<div class="mt-4 grid gap-4 md:grid-cols-2"><div class="space-y-2"><div class="rounded-box bg-base-200/60 p-3 text-sm"><p class="font-semibold"> </p> <p class="text-base-content/70"> </p></div> <div class="flex items-center gap-2"><label class="text-base-content/70 text-sm">Opacity</label> <input type="range" min="20" max="100"/></div> <div class="space-y-1"><label class="flex items-center gap-2 text-sm font-medium"><input type="checkbox" class="checkbox checkbox-primary checkbox-sm"/> <span>Dithering (Floyd-Steinberg)</span></label> <p class="text-base-content/70 text-xs">Makes color transitions smoother.</p></div> <div class="space-y-1"><label class="flex flex-col gap-1 text-sm font-medium">Color metric <select class="select select-bordered select-sm w-full max-w-xs"></select></label></div></div> <div class="space-y-2 text-sm"><p class="text-base-content/70">1. Set image position by draging it.<br/> 2. Click on <strong>Generate Preview</strong> to convert the colors.<br/> 3. Confirm to paint the canvas.</p> <div class="flex flex-wrap gap-2"><button class="btn btn-sm btn-outline">Change image</button></div></div></div> <div class="mt-4 flex flex-wrap items-center gap-3"><!> <button class="btn btn-ghost">Cancelar</button> <!></div>', 1),
  ME = me(`<div class="pointer-events-none absolute inset-0 z-40 select-none"><!></div> <div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-2xl sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 border-t p-4 shadow-xl"><div class="flex items-center justify-between gap-2"><div><h2 class="flex items-center gap-2 text-lg font-semibold"><!> Auto Painter</h2> <p class="text-base-content/70 text-sm">Drag the image to the desired position. Use the anchors to change it's size.</p></div> <button class="btn btn-circle btn-sm" title="Fechar"><!></button></div> <!></div></div>`, 1);

function AE(m, a) {
  Wr(a, !1);
  const d = 2e3,
    x = 256,
    A = "admin-auto-painter-opacity",
    z = "admin-auto-painter-dithering";
  let b = At(a, "map", 8),
    s = At(a, "tileSize", 8),
    F = At(a, "tileZoom", 8),
    q = At(a, "season", 8),
    J = At(a, "refreshPixelArt", 8),
    te = At(a, "onclose", 8),
    ae = ma(new Oa(s())),
    fe = ma("upload"),
    ie = ma(!1),
    $ = ma(!1),
    Se = ma(!1),
    Me = ma(null),
    Pe = ma(""),
    Ie = ma(null),
    Ce = ma(null),
    je = ma(null),
    Ye = ma({
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }),
    qe = [],
    Be = ma(null),
    He = ma(null),
    we = ma(1),
    it = ma(!1),
    mt = ma("lab");
  const Ge = [{
    value: "lab",
    label: "Perceptual (CIELAB ŒîE94)"
  }, {
    value: "compuphase",
    label: "Weighted RGB (CompuPhase)"
  }];
  let Xe = ma(!1),
    vt = null;
  const Ut = ["nw", "n", "ne", "e", "se", "s", "sw", "w"],
    _t = new Set(["nw", "ne", "se", "sw"]);

  function wt(K) {
    return _t.has(K)
  }

  function Je(K, he, Q) {
    return Math.min(Math.max(K, he), Q)
  }

  function zt(K) {
    const he = Math.max(K.north, K.south),
      Q = Math.min(K.north, K.south),
      ze = Math.min(K.west, K.east),
      $e = Math.max(K.west, K.east);
    return {
      north: Je(he, -85, 85),
      south: Je(Q, -85, 85),
      west: Je(ze, -180, 180),
      east: Je($e, -180, 180)
    }
  }

  function bt(K) {
    Y(Ie, zt(K)), Y(ie, !1), Y(Be, null), qe = [], Y(Ye, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }), Rt(), Pt(), Lt()
  }

  function Rt() {
    if (!_(Ie)) {
      Y(je, null);
      return
    }
    const [K, he] = _(ae).latLonToPixels(_(Ie).north, _(Ie).west, F()), [Q, ze] = _(ae).latLonToPixels(_(Ie).south, _(Ie).east, F()), $e = Math.min(K, Q), Re = Math.max(K, Q), ft = Math.min(he, ze), Mt = Math.max(he, ze), Et = Math.max(1, Math.ceil(Re - $e)), dt = Math.max(1, Math.ceil(Mt - ft));
    Y(je, {
      px0: $e,
      py0: ft,
      width: Et,
      height: dt
    })
  }

  function Pt() {
    if (!_(Ie)) {
      Y(Ce, null);
      return
    }
    const K = b().project({
        lat: _(Ie).north,
        lng: _(Ie).west
      }),
      he = b().project({
        lat: _(Ie).south,
        lng: _(Ie).east
      }),
      Q = Math.min(K.x, he.x),
      ze = Math.min(K.y, he.y),
      $e = Math.abs(he.x - K.x),
      Re = Math.abs(he.y - K.y);
    Y(Ce, {
      left: Q,
      top: ze,
      width: $e,
      height: Re
    })
  }

  function yt() {
    Y(fe, "upload"), Y(Me, null), Y(Pe, ""), Y(Ie, null), Y(je, null), Y(Ce, null), Y(ie, !1), qe = [], Y(Be, null), Y(Ye, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    })
  }

  function sr() {
    if (!_(Me)) return;
    const K = b().getCenter(),
      [he, Q] = _(ae).latLonToPixels(K.lat, K.lng, F()),
      ze = Math.min(1, x / _(Me).width),
      $e = Math.max(8, Math.round(_(Me).width * ze)),
      Re = Math.max(8, Math.round(_(Me).height * ze)),
      ft = he - $e / 2,
      Mt = he + $e / 2,
      Et = Q - Re / 2,
      dt = Q + Re / 2,
      [Kt, Qt] = _(ae).pixelsToLatLon(ft, Et, F()),
      [Sr, Ft] = _(ae).pixelsToLatLon(Mt, dt, F());
    bt({
      north: Kt,
      south: Sr,
      west: Qt,
      east: Ft
    }), Lt()
  }
  async function tr(K) {
    try {
      yt();
      const he = URL.createObjectURL(K),
        Q = await Ap(he);
      URL.revokeObjectURL(he), Y(Me, Ty(Q)), Y(Pe, K.name), Y(fe, "place"), sr()
    } catch (he) {
      console.error(he), Xt.error("Failed to load image. Try again.")
    }
  }

  function tt(K) {
    var ze;
    const he = K.target,
      Q = (ze = he.files) == null ? void 0 : ze[0];
    Q && tr(Q), he.value = ""
  }

  function ht(K) {
    K.preventDefault(), Y(Xe, !0)
  }

  function It(K) {
    K.preventDefault(), Y(Xe, !1)
  }

  function Bt(K) {
    var Q, ze;
    K.preventDefault(), Y(Xe, !1);
    const he = (ze = (Q = K.dataTransfer) == null ? void 0 : Q.files) == null ? void 0 : ze[0];
    he && tr(he)
  }

  function Nt(K) {
    const he = b().getCanvas().getBoundingClientRect(),
      Q = [K.clientX - he.left, K.clientY - he.top],
      ze = b().unproject(Q);
    return {
      lat: ze.lat,
      lon: ze.lng
    }
  }

  function Ht(K, he, Q) {
    if (!_(Me)) return he;
    const ze = _(Me).width / Math.max(_(Me).height, 1);
    if (!isFinite(ze) || ze <= 0) return he;
    const $e = K.includes("n") ? Q.south : Q.north,
      Re = K.includes("w") ? Q.east : Q.west,
      ft = K.includes("n") ? he.north : he.south,
      Mt = K.includes("w") ? he.west : he.east,
      [Et, dt] = _(ae).latLonToPixels($e, Re, F()),
      [Kt, Qt] = _(ae).latLonToPixels(ft, Mt, F());
    let Sr = Kt - Et,
      Ft = Qt - dt,
      Ze = Math.sign(Sr) || (K.includes("w") ? -1 : 1),
      Pr = Math.sign(Ft) || (K.includes("n") ? -1 : 1),
      br = Math.abs(Sr),
      Rr = Math.abs(Ft);
    if (br === 0 && Rr === 0) return he;
    const Dr = Rr * ze,
      ot = br / ze;
    Dr > br ? br = Dr : Rr = ot;
    const dr = Et + Ze * br,
      st = dt + Pr * Rr,
      [Tt, nr] = _(ae).pixelsToLatLon(dr, st, F());
    return K.includes("n") ? he.north = Tt : he.south = Tt, K.includes("w") ? he.west = nr : he.east = nr, he
  }

  function yr(K) {
    if (!_(Ie)) return;
    K.preventDefault();
    const {
      lat: he,
      lon: Q
    } = Nt(K);
    vt = {
      type: "move",
      startLat: he,
      startLon: Q,
      startBounds: {
        ..._(Ie)
      }
    }, Zt()
  }

  function Wt(K, he) {
    _(Ie) && (K.preventDefault(), K.stopPropagation(), vt = {
      type: "resize",
      handle: he,
      startBounds: {
        ..._(Ie)
      }
    }, Zt())
  }

  function Zt() {
    b().dragPan.disable(), window.addEventListener("pointermove", Jt), window.addEventListener("pointerup", jt)
  }

  function jt() {
    window.removeEventListener("pointermove", Jt), window.removeEventListener("pointerup", jt), b().dragPan.enable(), vt = null
  }

  function Jt(K) {
    if (!vt || !vt.startBounds) return;
    const {
      startBounds: he
    } = vt;
    if (vt.type === "move") {
      const {
        lat: ft,
        lon: Mt
      } = Nt(K), Et = ft - vt.startLat, dt = Mt - vt.startLon;
      bt({
        north: he.north + Et,
        south: he.south + Et,
        west: he.west + dt,
        east: he.east + dt
      });
      return
    }
    const {
      handle: Q
    } = vt, {
      lat: ze,
      lon: $e
    } = Nt(K);
    let Re = {
      ...he
    };
    Q.includes("n") && (Re.north = ze), Q.includes("s") && (Re.south = ze), Q.includes("w") && (Re.west = $e), Q.includes("e") && (Re.east = $e), wt(Q) && (Re = Ht(Q, Re, he)), bt(Re)
  }

  function Lt() {
    if (!_(He) || !_(je) || !_(Me) || _(ie)) return;
    Gt().drawImage(_(Me), 0, 0, _(je).width, _(je).height)
  }

  function Gt() {
    if (!_(He) || !_(je)) throw new Error("Canvas not ready");
    Bv(He, _(He).width = _(je).width), Bv(He, _(He).height = _(je).height);
    const K = _(He).getContext("2d", {
      willReadFrequently: !0
    });
    if (!K) throw new Error("Canvas context not available");
    return K.imageSmoothingEnabled = !1, K.clearRect(0, 0, _(He).width, _(He).height), K
  }

  function Yt() {
    if (!_(He) || !_(je) || !_(Be) || !_(ie)) return;
    Gt().putImageData(_(Be), 0, 0)
  }
  async function Lr() {
    if (!(!_(je) || !_(Me))) {
      if (_(je).width > d || _(je).height > d) {
        Xt.error(`The selected area is too big (${_(je).width}√ó${_(je).height}).`);
        return
      }
      Y($, !0);
      try {
        const K = Ir();
        if (!K || K.pixels.length === 0) {
          Xt.error("Faile to convert into valid game_pixels");
          return
        }
        Y(Be, K.imageData), qe = K.pixels, Y(Ye, K.stats), Y(ie, !0), Yt()
      } catch (K) {
        console.error(K), Xt.error("Failed to generate preview.")
      } finally {
        Y($, !1)
      }
    }
  }

  function Ir() {
    if (!_(je) || !_(Me)) return;
    const K = document.createElement("canvas");
    K.width = _(je).width, K.height = _(je).height;
    const he = K.getContext("2d", {
      willReadFrequently: !0
    });
    if (!he) throw new Error("Context is null.");
    he.imageSmoothingEnabled = !1, he.drawImage(_(Me), 0, 0, _(je).width, _(je).height);
    const Q = _(je).width,
      ze = _(je).height,
      $e = he.getImageData(0, 0, Q, ze),
      Re = $e.data,
      ft = [],
      Mt = new Set,
      Et = _(it);
    let dt = null,
      Kt = null;
    if (Et) {
      const Qt = Q * 3;
      dt = new Float32Array(Qt), Kt = new Float32Array(Qt)
    }
    for (let Qt = 0; Qt < ze; Qt++) {
      if (Et && dt && Kt) {
        const Sr = dt;
        dt = Kt, Kt = Sr, Kt.fill(0)
      }
      for (let Sr = 0; Sr < Q; Sr++) {
        const Ft = (Qt * Q + Sr) * 4;
        if (Re[Ft + 3] < 16) {
          Re[Ft + 3] = 0;
          continue
        }
        let Pr = Re[Ft],
          br = Re[Ft + 1],
          Rr = Re[Ft + 2];
        if (Et && dt) {
          const Fr = Sr * 3;
          Pr = Je(Math.round(Pr + dt[Fr]), 0, 255), br = Je(Math.round(br + dt[Fr + 1]), 0, 255), Rr = Je(Math.round(Rr + dt[Fr + 2]), 0, 255)
        }
        const Dr = R0({
            r: Pr,
            g: br,
            b: Rr
          }, _(mt)),
          ot = gg(Dr);
        if (Re[Ft] = ot.r, Re[Ft + 1] = ot.g, Re[Ft + 2] = ot.b, Re[Ft + 3] = ot.a, Et && dt && Kt) {
          const Fr = Pr - ot.r,
            Xr = br - ot.g,
            mn = Rr - ot.b,
            sn = (hn, dn, nn) => {
              hn[dn] += Fr * nn, hn[dn + 1] += Xr * nn, hn[dn + 2] += mn * nn
            };
          if (Sr + 1 < Q) {
            const hn = (Sr + 1) * 3;
            sn(dt, hn, 7 / 16)
          }
          if (Qt + 1 < ze) {
            if (Sr > 0) {
              const dn = (Sr - 1) * 3;
              sn(Kt, dn, 3 / 16)
            }
            const hn = Sr * 3;
            if (sn(Kt, hn, 5 / 16), Sr + 1 < Q) {
              const dn = (Sr + 1) * 3;
              sn(Kt, dn, 1 / 16)
            }
          }
        }
        const dr = _(je).px0 + Sr + .5,
          st = _(je).py0 + Qt + .5,
          {
            tile: Tt,
            pixel: nr
          } = _(ae).pixelsToTileLocal(dr, st),
          Ur = {
            tile: [Tt[0], Tt[1]],
            pixel: [nr[0], nr[1]],
            season: q(),
            colorIdx: Dr,
            color: ot
          },
          Ot = `${Tt[0]}:${Tt[1]}`;
        Mt.add(Ot), ft.push(Ur)
      }
    }
    return {
      pixels: ft,
      imageData: $e,
      stats: {
        pixels: ft.length,
        width: Q,
        height: ze,
        tiles: Mt.size
      }
    }
  }
  async function Jr() {
    if (!(!_(ie) || qe.length === 0)) {
      Y(Se, !0);
      try {
        xi.droppletAndPlop.play();
        const K = await Dg(),
          he = qe.map(({
            color: Q,
            ...ze
          }) => ze);
        await fn.adminAutoPainterPaint(he, K), await pg(qe), J()(), Dt.refresh(), Xt.success("Art painted successfully."), Tr()
      } catch (K) {
        console.error(K), Xt.error(K.message ?? "Failed to paint art.")
      } finally {
        Y(Se, !1)
      }
    }
  }

  function Tr() {
    yt(), te()()
  }

  function Ar() {
    Y(ie, !1), Y(Be, null), qe = [], Y(Ye, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }), Lt()
  }
  ri(() => {
    const K = () => Pt();
    return b().on("move", K), b().on("zoom", K), b().on("resize", K), () => {
      b().off("move", K), b().off("zoom", K), b().off("resize", K)
    }
  }), rb(() => {
    yt()
  }), pm(() => db(s()), () => {
    Y(ae, new Oa(s()))
  }), pm(() => (_(He), _(je), _(Me), _(ie), _(fe)), () => {
    _(He) && _(je) && _(Me) && !_(ie) && _(fe) === "place" && Lt()
  }), pm(() => (_(He), _(je), _(Be), _(ie)), () => {
    _(He) && _(je) && _(Be) && _(ie) && Yt()
  }), hb(), mg();
  var xr = ME();
  Ln("keydown", Zs, K => {
    K.key === "Escape" && Tr()
  }), Ln("dragover", Zs, c2(ht)), Ln("drop", Zs, Bt), Ln("dragleave", Zs, It);
  var qt = xt(xr),
    Yr = I(qt);
  {
    var Le = K => {
      var he = yE(),
        Q = I(he);
      let ze;
      lo(Q, ft => Y(He, ft), () => _(He));
      var $e = O(Q, 2),
        Re = O($e, 2);
      fi(Re, 1, () => Ut, ft => ft, (ft, Mt) => {
        var Et = vE();
        Ue(dt => {
          qr(Et, 1, `handle handle-${_(Mt)}`, "svelte-rxq6cp"), cr(Et, "aria-label", dt)
        }, [() => (_(Mt), Aa(() => `Redimensionar (${_(Mt).toUpperCase()})`))]), Ln("pointerdown", Et, dt => Wt(dt, _(Mt))), Z(ft, Et)
      }), C(he), Ue(() => {
        bs(he, (_(Ce), _(we), Aa(() => `left:${_(Ce).left}px;top:${_(Ce).top}px;width:${_(Ce).width}px;height:${_(Ce).height}px;opacity:${_(we)};`))), ze = qr(Q, 1, "h-full w-full svelte-rxq6cp", null, ze, {
          pixelated: _(ie)
        })
      }), Ln("pointerdown", Q, yr), Ln("pointerdown", $e, yr), Z(K, he)
    };
    Ee(Yr, K => {
      _(Ie) && _(Ce) && K(Le)
    })
  }
  C(qt);
  var j = O(qt, 2),
    E = I(j),
    D = I(E),
    N = I(D),
    X = I(N),
    ee = I(X);
  Il(ee, {
    class: "size-5"
  }), wn(), C(X), wn(2), C(N);
  var pe = O(N, 2),
    be = I(pe);
  ws(be, {
    class: "size-4"
  }), C(pe), C(D);
  var ye = O(D, 2);
  {
    var Oe = K => {
        var he = xE(),
          Q = I(he);
        zb(Q, {
          class: "text-base-content/70 size-10"
        });
        var ze = O(Q, 4);
        wn(2), C(he), Ue(() => qr(he, 1, `rounded-box mt-4 flex flex-col items-center justify-center gap-3 border border-dashed p-6 text-center transition ${_(Xe)?"border-primary bg-primary/10":"border-base-300"}`, "svelte-rxq6cp")), Ln("change", ze, tt), Z(K, he)
      },
      oe = K => {
        var he = or(),
          Q = xt(he);
        {
          var ze = $e => {
            var Re = IE(),
              ft = xt(Re),
              Mt = I(ft),
              Et = I(Mt),
              dt = I(Et),
              Kt = I(dt, !0);
            C(dt);
            var Qt = O(dt, 2),
              Sr = I(Qt);
            C(Qt), C(Et);
            var Ft = O(Et, 2),
              Ze = I(Ft);
            cr(Ze, "for", A);
            var Pr = O(Ze, 2);
            za(Pr), cr(Pr, "id", A), C(Ft);
            var br = O(Ft, 2),
              Rr = I(br);
            cr(Rr, "for", z);
            var Dr = I(Rr);
            za(Dr), cr(Dr, "id", z), wn(2), C(Rr), wn(2), C(br);
            var ot = O(br, 2),
              dr = I(ot),
              st = O(I(dr));
            Ue(() => {
              _(mt), pb(() => {
                _(ie)
              })
            }), fi(st, 5, () => Ge, $h, (nn, Ke) => {
              var St = bE(),
                kr = I(St, !0);
              C(St);
              var wr = {};
              Ue(() => {
                ce(kr, (_(Ke), Aa(() => _(Ke).label))), wr !== (wr = (_(Ke), Aa(() => _(Ke).value))) && (St.value = (St.__value = (_(Ke), Aa(() => _(Ke).value))) ?? "")
              }), Z(nn, St)
            }), C(st), C(dr), C(ot), C(Mt);
            var Tt = O(Mt, 2),
              nr = O(I(Tt), 2),
              Ur = I(nr);
            C(nr), C(Tt), C(ft);
            var Ot = O(ft, 2),
              Fr = I(Ot);
            {
              var Xr = nn => {
                  var Ke = TE(),
                    St = I(Ke);
                  {
                    var kr = mr => {
                        var Mr = wE();
                        wn(), Z(mr, Mr)
                      },
                      wr = mr => {
                        var Mr = qi("Generate Preview");
                        Z(mr, Mr)
                      };
                    Ee(St, mr => {
                      _($) ? mr(kr) : mr(wr, !1)
                    })
                  }
                  C(Ke), Ue(() => Ke.disabled = _($)), Ln("click", Ke, Lr), Z(nn, Ke)
                },
                mn = nn => {
                  var Ke = PE(),
                    St = I(Ke);
                  {
                    var kr = mr => {
                        var Mr = SE();
                        wn(), Z(mr, Mr)
                      },
                      wr = mr => {
                        var Mr = qi("Confirm painting");
                        Z(mr, Mr)
                      };
                    Ee(St, mr => {
                      _(Se) ? mr(kr) : mr(wr, !1)
                    })
                  }
                  C(Ke), Ue(() => Ke.disabled = _(Se)), Ln("click", Ke, Jr), Z(nn, Ke)
                };
              Ee(Fr, nn => {
                _(ie) ? nn(mn, !1) : nn(Xr)
              })
            }
            var sn = O(Fr, 2),
              hn = O(sn, 2);
            {
              var dn = nn => {
                var Ke = CE(),
                  St = I(Ke);
                C(Ke), Ue(kr => ce(St, `Ready to paint ${kr??""} pixels.`), [() => (_(Ye), Aa(() => _(Ye).pixels.toLocaleString()))]), Z(nn, Ke)
              };
              Ee(hn, nn => {
                _(ie) && nn(dn)
              })
            }
            C(Ot), Ue(() => {
              ce(Kt, _(Pe)), ce(Sr, `Target size: ${_(je),Aa(()=>_(je).width)??""} √ó ${_(je),Aa(()=>_(je).height)??""} pixels`), dg(Pr, _(we) * 100)
            }), Ln("input", Pr, nn => {
              const Ke = nn.target;
              Y(we, Number(Ke.value) / 100)
            }), E0(Dr, () => _(it), nn => Y(it, nn)), Ln("change", Dr, () => {
              _(ie) && Ar()
            }), yb(st, () => _(mt), nn => Y(mt, nn)), Ln("change", st, () => {
              _(ie) && Ar()
            }), Ln("click", Ur, () => Y(fe, "upload")), Ln("click", sn, Tr), Z($e, Re)
          };
          Ee(Q, $e => {
            _(Ie) && _(je) && $e(ze)
          }, !0)
        }
        Z(K, he)
      };
    Ee(ye, K => {
      _(fe) === "upload" ? K(Oe) : K(oe, !1)
    })
  }
  C(E), C(j), Ln("click", pe, Tr), Z(m, xr), $r()
}
const kp = zi({
  shouldReload: !0
});
var kE = me('<dialog class="modal"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function EE(m, a) {
  Wr(a, !0);
  let d = At(a, "ref", 15),
    x = et(!1),
    A = et(zi(a.description)),
    z = et(void 0);
  ri(() => {
    const Pe = Ie => {
      var Ce;
      Ie.key === "Escape" && ((Ce = d()) == null || Ce.close())
    };
    return document.addEventListener("keydown", Pe), () => document.removeEventListener("keydown", Pe)
  });
  var b = kE(),
    s = I(b),
    F = I(s),
    q = I(F, !0);
  C(F);
  var J = O(F, 2),
    te = I(J),
    ae = I(te);
  {
    let Pe = ut(() => $0());
    F0(ae, {
      class: "h-24 rounded-lg",
      get placeholder() {
        return _(Pe)
      },
      max: 512,
      get value() {
        return _(A)
      },
      set value(Ie) {
        Y(A, Ie, !0)
      },
      get validate() {
        return _(z)
      },
      set validate(Ie) {
        Y(z, Ie, !0)
      }
    })
  }
  C(te);
  var fe = O(te, 2),
    ie = I(fe);
  ie.__click = () => {
    var Pe;
    (Pe = d()) == null || Pe.close()
  };
  var $ = I(ie, !0);
  C(ie);
  var Se = O(ie, 2),
    Me = I(Se, !0);
  C(Se), C(fe), C(J), C(s), wn(2), C(b), lo(b, Pe => d(Pe), () => d()), Ue((Pe, Ie, Ce) => {
    ce(q, Pe), ie.disabled = _(x), ce($, Ie), Se.disabled = _(x), ce(Me, Ce)
  }, [() => Nb(), () => Yh(), () => US()]), Ln("submit", J, async () => {
    var Pe, Ie, Ce;
    try {
      if (!((Pe = _(z)) != null && Pe())) return;
      Y(x, !0), a.description !== _(A) && await fn.updateAllianceDescription(_(A)), await ((Ie = a.onsuccess) == null ? void 0 : Ie.call(a, _(A))), (Ce = d()) == null || Ce.close()
    } catch (je) {
      Xt.error(je.message)
    } finally {
      Y(x, !1)
    }
  }), Z(m, b), $r()
}
ni(["click"]);
var LE = me('<span class="loading loading-spinner loading-md center-absolute absolute"></span>'),
  zE = me('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function DE(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15),
    x = et(""),
    A = et(!1);
  const z = ut(() => Ni.url.origin + `/join?id=${_(x)}`);
  tn(() => {
    d() && fn.getAllianceInvites().then(Ye => {
      Y(x, Ye[0], !0)
    }).catch(Ye => {
      Xt.error(Ye.message)
    })
  }), ri(() => {
    const Ye = qe => {
      qe.key === "Escape" && d(!1)
    };
    return document.addEventListener("keydown", Ye), () => document.removeEventListener("keydown", Ye)
  });
  var b = zE(),
    s = I(b),
    F = O(I(s), 2),
    q = I(F, !0);
  C(F);
  var J = O(F, 2),
    te = I(J, !0);
  C(J);
  var ae = O(J, 2),
    fe = I(ae);
  let ie;
  var $ = I(fe);
  za($);
  var Se = O($, 2),
    Me = I(Se);
  let Pe;
  Me.__click = () => {
    navigator.clipboard.writeText(_(z).toString()), Y(A, !0), setTimeout(() => {
      Y(A, !1)
    }, 1e3)
  };
  var Ie = I(Me, !0);
  C(Me), C(Se), C(fe);
  var Ce = O(fe, 2);
  {
    var je = Ye => {
      var qe = LE();
      Z(Ye, qe)
    };
    Ee(Ce, Ye => {
      _(x) || Ye(je)
    })
  }
  C(ae), C(s), wn(2), C(b), Di(b, () => Ye => {
    tn(() => {
      d() ? Ye.show() : Ye.close()
    })
  }), Ue((Ye, qe, Be, He) => {
    ce(q, Ye), ce(te, qe), ie = qr(fe, 1, "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5", null, ie, {
      invisible: !_(x)
    }), dg($, Be), Pe = qr(Me, 1, "btn btn-primary", null, Pe, {
      "btn-success": _(A)
    }), ce(Ie, He)
  }, [() => ZT(), () => WT(), () => _(z).toString(), () => _(A) ? Pg() : Am()]), Ln("close", b, () => d(!1)), Z(m, b), $r()
}
ni(["click"]);
var RE = jr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>');

function Fm(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = RE();
  _r(x, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    ...d
  })), Z(m, x)
}
var FE = me('<span class="text-success">(Verified)</span>'),
  BE = me('<a target="_blank" rel="noreferer" aria-label="Discord"><!></a>'),
  OE = me("<button><!></button>"),
  NE = me('<span class="tooltip h-4"><div class="tooltip-content"><span> </span> <!></div> <!></span>');

function ed(m, a) {
  Wr(a, !0);
  const d = !!a.id;
  var x = NE(),
    A = I(x),
    z = I(A),
    b = I(z);
  C(z);
  var s = O(z, 2);
  {
    var F = ae => {
      var fe = FE();
      Z(ae, fe)
    };
    Ee(s, ae => {
      d && ae(F)
    })
  }
  C(A);
  var q = O(A, 2);
  {
    var J = ae => {
        var fe = BE(),
          ie = I(fe);
        Fm(ie, {
          class: "size-4 opacity-70"
        }), C(fe), Ue($ => cr(fe, "href", $), [() => `https://discord.com/users/${encodeURIComponent(a.id)}`]), Z(ae, fe)
      },
      te = ae => {
        var fe = OE();
        fe.__click = async () => {
          await navigator.clipboard.writeText(a.username), Xt.info($P())
        };
        var ie = I(fe);
        Fm(ie, {
          class: "size-4 opacity-70"
        }), C(fe), Z(ae, fe)
      };
    Ee(q, ae => {
      d ? ae(J) : ae(te, !1)
    })
  }
  C(x), Ue(() => ce(b, `Discord: ${a.username??""}`)), Z(m, x), $r()
}
ni(["click"]);
var jE = me('<input type="radio" class="tab max-[380px]:px-3"/>'),
  qE = me('<div class="tabs tabs-border w-max font-medium"></div>');

function Rg(m, a) {
  Wr(a, !0);
  const d = [];
  let x = At(a, "value", 15, "today"),
    A = [{
      value: "today",
      label: nf()
    }, {
      value: "week",
      label: sS()
    }, {
      value: "month",
      label: uS()
    }, {
      value: "all-time",
      label: pS()
    }];
  var z = qE();
  fi(z, 21, () => A, b => b.value, (b, s) => {
    var F = jE();
    za(F);
    var q;
    Ue(() => {
      cr(F, "aria-label", _(s).label), q !== (q = _(s).value) && (F.value = (F.__value = _(s).value) ?? "")
    }), fg(d, [], F, () => (_(s).value, x()), x), Z(b, F)
  }), C(z), Z(m, z), $r()
}
const VE = typeof window < "u" ? window : void 0;

function UE(m) {
  let a = m.activeElement;
  for (; a != null && a.shadowRoot;) {
    const d = a.shadowRoot.activeElement;
    if (d === a) break;
    a = d
  }
  return a
}
var Dc, ph, C0;
let ZE = (C0 = class {
  constructor(a = {}) {
    Zr(this, Dc);
    Zr(this, ph);
    const {
      window: d = VE,
      document: x = d == null ? void 0 : d.document
    } = a;
    d !== void 0 && (oa(this, Dc, x), oa(this, ph, M0(A => {
      const z = nh(d, "focusin", A),
        b = nh(d, "focusout", A);
      return () => {
        z(), b()
      }
    })))
  }
  get current() {
    var a;
    return (a = Qe(this, ph)) == null || a.call(this), Qe(this, Dc) ? UE(Qe(this, Dc)) : null
  }
}, Dc = new WeakMap, ph = new WeakMap, C0);
new ZE;

function GE(m) {
  return typeof m == "function"
}

function HE(m, a) {
  if (GE(m)) {
    const x = m();
    return x === void 0 ? a : x
  }
  return m === void 0 ? a : m
}

function WE(m, a) {
  let d = et(null);
  const x = ut(() => HE(a, 250));

  function A(...z) {
    if (_(d)) _(d).timeout && clearTimeout(_(d).timeout);
    else {
      let b, s;
      const F = new Promise((q, J) => {
        b = q, s = J
      });
      Y(d, {
        timeout: null,
        runner: null,
        promise: F,
        resolve: b,
        reject: s
      }, !0)
    }
    return _(d).runner = async () => {
      if (!_(d)) return;
      const b = _(d);
      Y(d, null);
      try {
        b.resolve(await m.apply(this, z))
      } catch (s) {
        b.reject(s)
      }
    }, _(d).timeout = setTimeout(_(d).runner, _(x)), _(d).promise
  }
  return A.cancel = async () => {
    (!_(d) || _(d).timeout === null) && (await new Promise(z => setTimeout(z, 0)), !_(d) || _(d).timeout === null) || (clearTimeout(_(d).timeout), _(d).reject("Cancelled"), Y(d, null))
  }, A.runScheduledNow = async () => {
    var z, b;
    (!_(d) || !_(d).timeout) && (await new Promise(s => setTimeout(s, 0)), !_(d) || !_(d).timeout) || (clearTimeout(_(d).timeout), _(d).timeout = null, await ((b = (z = _(d)).runner) == null ? void 0 : b.call(z)))
  }, Object.defineProperty(A, "pending", {
    enumerable: !0,
    get() {
      var z;
      return !!((z = _(d)) != null && z.timeout)
    }
  }), A
}

function $E(m, a) {
  switch (m) {
    case "post":
      tn(a);
      break;
    case "pre":
      ug(a);
      break
  }
}

function Sy(m, a, d, x = {}) {
  const {
    lazy: A = !1
  } = x;
  let z = !A,
    b = Array.isArray(m) ? [] : void 0;
  $E(a, () => {
    const s = Array.isArray(m) ? m.map(q => q()) : m();
    if (!z) {
      z = !0, b = s;
      return
    }
    const F = Aa(() => d(s, b));
    return b = s, F
  })
}

function Gs(m, a, d) {
  Sy(m, "post", a, d)
}

function XE(m, a, d) {
  Sy(m, "pre", a, d)
}
Gs.pre = XE;

function YE() {}
var Sl, qs;
class KE {
  constructor(a, d = 250) {
    Zr(this, Sl, et());
    Zr(this, qs);
    Y(Qe(this, Sl), a(), !0), this.cancel = this.cancel.bind(this), this.setImmediately = this.setImmediately.bind(this), this.updateImmediately = this.updateImmediately.bind(this), oa(this, qs, WE(() => {
      Y(Qe(this, Sl), a(), !0)
    }, d)), Gs(a, () => {
      Qe(this, qs).call(this).catch(YE)
    })
  }
  get current() {
    return _(Qe(this, Sl))
  }
  get pending() {
    return Qe(this, qs).pending
  }
  cancel() {
    Qe(this, qs).cancel()
  }
  updateImmediately() {
    return Qe(this, qs).runScheduledNow()
  }
  setImmediately(a) {
    this.cancel(), Y(Qe(this, Sl), a, !0)
  }
}
Sl = new WeakMap, qs = new WeakMap;
var JE = me('<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>'),
  QE = me('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  e8 = me('<span class="font-flag tooltip ml-0.5"> </span>'),
  t8 = me("<button><!></button>"),
  r8 = me('<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>'),
  n8 = me('<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>'),
  i8 = me('<div><!> <div class="mt-4"><!></div></div>');

function a8(m, a) {
  Wr(a, !0);
  let d = At(a, "reload", 15),
    x = et(!0),
    A = et([]),
    z = et(0),
    b = et("today"),
    s = {};
  d(F);

  function F() {
    const $ = _(b);
    fn.allianceLeaderboard($).then(Se => {
      Y(A, Se), s = {
        [$]: Se
      }, Y(x, !1)
    }).catch(Se => {
      Xt.error(Se.message)
    })
  }
  Gs(() => [_(b)], () => {
    const $ = _(b),
      Se = s[$];
    if (Se) {
      Y(A, Se), Y(x, !1);
      return
    }
    Y(x, !0), fn.allianceLeaderboard($).then(Me => {
      Y(A, Me), s[$] = Me, Y(x, !1)
    }).catch(Me => {
      Xt.error(Me.message)
    })
  });
  var q = i8(),
    J = I(q);
  Rg(J, {
    get value() {
      return _(b)
    },
    set value($) {
      Y(b, $, !0)
    }
  });
  var te = O(J, 2),
    ae = I(te);
  {
    var fe = $ => {
        var Se = JE();
        Z($, Se)
      },
      ie = $ => {
        var Se = or(),
          Me = xt(Se);
        {
          var Pe = Ce => {
              var je = QE(),
                Ye = I(je),
                qe = O(Ye);
              {
                var Be = we => {
                    var it = qi();
                    Ue(mt => ce(it, mt), [() => nf().toLowerCase()]), Z(we, it)
                  },
                  He = we => {
                    var it = or(),
                      mt = xt(it);
                    {
                      var Ge = vt => {
                          var Ut = qi();
                          Ue(_t => ce(Ut, _t), [() => Ig()]), Z(vt, Ut)
                        },
                        Xe = vt => {
                          var Ut = or(),
                            _t = xt(Ut);
                          {
                            var wt = Je => {
                              var zt = qi();
                              Ue(bt => ce(zt, bt), [() => Mg()]), Z(Je, zt)
                            };
                            Ee(_t, Je => {
                              _(b) === "month" && Je(wt)
                            }, !0)
                          }
                          Z(vt, Ut)
                        };
                      Ee(mt, vt => {
                        _(b) === "week" ? vt(Ge) : vt(Xe, !1)
                      }, !0)
                    }
                    Z(we, it)
                  };
                Ee(qe, we => {
                  _(b) === "today" ? we(Be) : we(He, !1)
                })
              }
              C(je), Ue(we => ce(Ye, `${we??""} `), [() => Cg()]), Z(Ce, je)
            },
            Ie = Ce => {
              var je = n8(),
                Ye = I(je),
                qe = I(Ye),
                Be = O(I(qe)),
                He = I(Be, !0);
              C(Be);
              var we = O(Be),
                it = I(we, !0);
              C(we), C(qe), C(Ye);
              var mt = O(Ye);
              fi(mt, 31, () => _(A), Ge => Ge.userId, (Ge, Xe, vt) => {
                const Ut = ut(() => {
                  var jt;
                  return ((jt = Dt.data) == null ? void 0 : jt.id) === _(Xe).userId
                });
                var _t = r8();
                let wt;
                var Je = I(_t),
                  zt = I(Je, !0);
                C(Je);
                var bt = O(Je),
                  Rt = I(bt),
                  Pt = I(Rt);
                Mo(Pt, {
                  class: "size-10 border",
                  get userId() {
                    return _(Xe).userId
                  },
                  get pictureUrl() {
                    return _(Xe).picture
                  }
                });
                var yt = O(Pt, 2),
                  sr = I(yt),
                  tr = O(sr),
                  tt = I(tr);
                C(tr), C(yt);
                var ht = O(yt, 2);
                {
                  var It = jt => {
                    const Jt = ut(() => qo(_(Xe).equippedFlag));
                    var Lt = e8(),
                      Gt = I(Lt, !0);
                    C(Lt), Ue(() => {
                      cr(Lt, "data-tip", _(Jt).name), ce(Gt, _(Jt).flag)
                    }), Z(jt, Lt)
                  };
                  Ee(ht, jt => {
                    _(Xe).equippedFlag && jt(It)
                  })
                }
                var Bt = O(ht, 2);
                {
                  var Nt = jt => {
                    ed(jt, {
                      get username() {
                        return _(Xe).discord
                      },
                      get id() {
                        return _(Xe).discordId
                      }
                    })
                  };
                  Ee(Bt, jt => {
                    _(Xe).discord && jt(Nt)
                  })
                }
                C(Rt), C(bt);
                var Ht = O(bt),
                  yr = I(Ht),
                  Wt = O(yr);
                {
                  var Zt = jt => {
                    var Jt = t8();
                    let Lt;
                    Jt.__click = () => {
                      a.onlastpixelclick({
                        lat: _(Xe).lastLatitude ?? 0,
                        lng: _(Xe).lastLongitude ?? 0
                      })
                    };
                    var Gt = I(Jt);
                    Qp(Gt, {
                      class: "size-4"
                    }), C(Jt), Ue(Yt => {
                      Lt = qr(Jt, 1, "btn btn-sm btn-ghost absolute -right-2 top-1/2 !-translate-y-1/2 sm:right-4", null, Lt, {
                        tooltip: _(z) > 640
                      }), cr(Jt, "data-tip", Yt)
                    }, [() => Xb()]), Z(jt, Jt)
                  };
                  Ee(Wt, jt => {
                    _(Xe).lastLatitude && _(Xe).lastLongitude && jt(Zt)
                  })
                }
                C(Ht), C(_t), Ue((jt, Jt) => {
                  var Lt;
                  wt = qr(_t, 1, "", null, wt, {
                    "bg-base-200": _(Ut)
                  }), ce(zt, _(vt) + 1), qr(yt, 1, `font-semibold ${jt??""} flex gap-1`), ce(sr, `${(_(Ut)?((Lt=Dt.data)==null?void 0:Lt.name)??_(Xe).name:_(Xe).name)??""} `), ce(tt, `#${_(Xe).userId??""}`), ce(yr, `${Jt??""} `)
                }, [() => ea(_(Xe).userId), () => _(Xe).pixelsPainted.toLocaleString("en-US")]), wl(_t, () => Tl, () => ({
                  duration: 200
                })), Z(Ge, _t)
              }), C(mt), C(je), Ue((Ge, Xe) => {
                ce(He, Ge), ce(it, Xe)
              }, [() => xg(), () => _g()]), Z(Ce, je)
            };
          Ee(Me, Ce => {
            _(A).length === 0 ? Ce(Pe) : Ce(Ie, !1)
          }, !0)
        }
        Z($, Se)
      };
    Ee(ae, $ => {
      _(x) ? $(fe) : $(ie, !1)
    })
  }
  C(te), C(q), ef("innerWidth", $ => Y(z, $, !0)), Z(m, q), $r()
}
ni(["click"]);
var o8 = jr('<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>');

function Fg(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = o8();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var s8 = me('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>'),
  l8 = me('<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>', 1),
  c8 = me('<li><button class="btn btn-ghost text-base-content/80"> </button></li>'),
  u8 = me('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>'),
  h8 = me('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  d8 = me('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>'),
  p8 = me('<div class="text-base-content/80 mt-4 flex justify-center"> </div>'),
  f8 = me('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  m8 = me('<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>');

function g8(m, a) {
  Wr(a, !0);
  let d = zi({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    }),
    x = zi({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    });
  var A = m8(),
    z = I(A),
    b = I(z);
  b.__click = () => a.onclickback();
  var s = I(b);
  j0(s, {
    class: "size-5"
  }), C(b);
  var F = O(b, 2),
    q = I(F, !0);
  C(F), C(z);
  var J = O(z, 2),
    te = I(J);
  za(te);
  var ae = O(te, 2),
    fe = I(ae),
    ie = I(fe);
  fi(ie, 21, () => d.data, He => He.id, (He, we, it) => {
    const mt = ut(() => {
      var It;
      return ((It = Dt.data) == null ? void 0 : It.id) === _(we).id
    });
    var Ge = u8(),
      Xe = I(Ge),
      vt = I(Xe),
      Ut = I(vt);
    Mo(Ut, {
      class: "size-10 border",
      get userId() {
        return _(we).id
      },
      get pictureUrl() {
        return _(we).picture
      }
    });
    var _t = O(Ut, 2),
      wt = I(_t);
    C(_t);
    var Je = O(_t, 2);
    {
      var zt = It => {
        var Bt = s8();
        Z(It, Bt)
      };
      Ee(Je, It => {
        _(we).role === "admin" && It(zt)
      })
    }
    C(vt), C(Xe);
    var bt = O(Xe),
      Rt = I(bt),
      Pt = I(Rt),
      yt = I(Pt);
    Fg(yt, {
      class: "size-4"
    }), C(Pt);
    var sr = O(Pt, 2),
      tr = I(sr);
    {
      var tt = It => {
          var Bt = l8(),
            Nt = xt(Bt),
            Ht = I(Nt);
          Ht.__click = async () => {
            try {
              _(we).loading = !0, await fn.giveAllianceAdmin(_(we).id), _(we).role = "admin"
            } catch {
              Xt.error(vC())
            } finally {
              _(we).loading = !1
            }
          };
          var yr = I(Ht, !0);
          C(Ht), C(Nt);
          var Wt = O(Nt, 2),
            Zt = I(Wt);
          Zt.__click = async () => {
            try {
              _(we).loading = !0, await fn.banAllianceUser(_(we).id), d.data = d.data.filter(Jt => Jt.id !== _(we).id)
            } catch {
              Xt.error(HS())
            } finally {
              _(we).loading = !1
            }
          };
          var jt = I(Zt, !0);
          C(Zt), C(Wt), Ue((Jt, Lt) => {
            Ht.disabled = _(we).loading, ce(yr, Jt), Zt.disabled = _(we).loading, ce(jt, Lt)
          }, [() => AS(), () => X0()]), Z(It, Bt)
        },
        ht = It => {
          var Bt = c8(),
            Nt = I(Bt);
          Nt.disabled = !0;
          var Ht = I(Nt, !0);
          C(Nt), C(Bt), Ue(yr => ce(Ht, yr), [() => DS()]), Z(It, Bt)
        };
      Ee(tr, It => {
        _(we).role === "member" ? It(tt) : It(ht, !1)
      })
    }
    C(sr), C(Rt), C(bt), C(Ge), Ue(It => {
      var Bt;
      qr(_t, 1, `font-semibold ${It??""}`), ce(wt, `${(_(mt)?((Bt=Dt.data)==null?void 0:Bt.name)??_(we).name:_(we).name)??""} #${_(we).id??""}`)
    }, [() => ea(_(we).id)]), Z(He, Ge)
  }), C(ie), C(fe);
  var $ = O(fe, 2);
  {
    var Se = He => {
      var we = or(),
        it = xt(we);
      ih(it, () => d.page, mt => {
        var Ge = h8();
        Di(Ge, () => Xe => {
          const vt = new IntersectionObserver(Ut => {
            Ut[0].isIntersecting && !d.loading && (d.loading = !0, fn.getAllianceMembers(d.page).then(_t => {
              d.data = [...d.data, ..._t.data], d.hasNextPage = _t.hasNext, d.page++
            }).catch(_t => {
              Xt.error(_t.message)
            }).finally(() => {
              d.loading = !1
            }))
          });
          return vt.observe(Xe), () => {
            vt.disconnect()
          }
        }), Z(mt, Ge)
      }), Z(He, we)
    };
    Ee($, He => {
      d.hasNextPage && He(Se)
    })
  }
  C(ae);
  var Me = O(ae, 2),
    Pe = O(Me, 2),
    Ie = I(Pe),
    Ce = I(Ie);
  fi(Ce, 21, () => x.data, He => He.id, (He, we, it) => {
    var mt = d8(),
      Ge = I(mt),
      Xe = I(Ge),
      vt = I(Xe);
    Mo(vt, {
      class: "size-10 border",
      get userId() {
        return _(we).id
      },
      get pictureUrl() {
        return _(we).picture
      }
    });
    var Ut = O(vt, 2),
      _t = I(Ut);
    C(Ut), C(Xe), C(Ge);
    var wt = O(Ge),
      Je = I(wt);
    Je.__click = () => {
      fn.unbanAllianceUser(_(we).id).then(() => {
        x.data = x.data.filter(bt => bt.id !== _(we).id)
      }).catch(bt => Xt.error(bt.message)).finally(() => {
        _(we).loading = !1
      })
    };
    var zt = I(Je, !0);
    C(Je), C(wt), C(mt), Ue((bt, Rt) => {
      qr(Ut, 1, `font-semibold ${bt??""}`), ce(_t, `${_(we).name??""} #${_(we).id??""}`), Je.disabled = _(we).loading, ce(zt, Rt)
    }, [() => ea(_(we).id), () => BS()]), Z(He, mt)
  }), C(Ce), C(Ie);
  var je = O(Ie, 2);
  {
    var Ye = He => {
      var we = p8(),
        it = I(we, !0);
      C(we), Ue(mt => ce(it, mt), [() => jS()]), Z(He, we)
    };
    Ee(je, He => {
      !x.hasNextPage && x.data.length === 0 && He(Ye)
    })
  }
  var qe = O(je, 2);
  {
    var Be = He => {
      var we = or(),
        it = xt(we);
      ih(it, () => x.page, mt => {
        var Ge = f8();
        Di(Ge, () => Xe => {
          const vt = new IntersectionObserver(Ut => {
            Ut[0].isIntersecting && !x.loading && (x.loading = !0, fn.getAllianceBannedMembers(x.page).then(_t => {
              x.data = [...x.data, ..._t.data], x.hasNextPage = _t.hasNext, x.page++
            }).catch(_t => {
              Xt.error(_t.message)
            }).finally(() => {
              x.loading = !1
            }))
          });
          return vt.observe(Xe), () => {
            vt.disconnect()
          }
        }), Z(mt, Ge)
      }), Z(He, we)
    };
    Ee(qe, He => {
      x.hasNextPage && He(Be)
    })
  }
  C(Pe), C(J), C(A), Ue((He, we, it) => {
    ce(q, He), cr(te, "aria-label", we), cr(Me, "aria-label", it)
  }, [() => N0(), () => XS(), () => vg()]), Z(m, A), $r()
}
ni(["click"]);
var _8 = me('<span class="label"> </span>'),
  v8 = me('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>'),
  y8 = me('<p class="text-error ml-3 text-sm"> </p>'),
  x8 = me('<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>');

function Bm(m, a) {
  Wr(a, !0);
  let d = At(a, "value", 15),
    x = At(a, "validate", 15),
    A = et("");
  const z = ut(() => {
    var Me;
    return ((Me = d()) == null ? void 0 : Me.length) ?? 0
  });
  x(b);

  function b() {
    return a.min !== void 0 && _(z) < a.min ? (Y(A, _(z) === 0 ? "Required" : `Min. characters: ${a.min}`, !0), !1) : a.max !== void 0 && _(z) > a.max ? (Y(A, `Max. characters: ${a.max}`), !1) : !0
  }
  tn(() => {
    var Me;
    a.max !== void 0 && _(z) > a.max && d((Me = d()) == null ? void 0 : Me.substring(0, a.max))
  });
  var s = x8(),
    F = I(s);
  let q;
  var J = I(F);
  {
    var te = Me => {
      var Pe = _8(),
        Ie = I(Pe, !0);
      C(Pe), Ue(() => ce(Ie, a.label)), Z(Me, Pe)
    };
    Ee(J, Me => {
      a.label && Me(te)
    })
  }
  var ae = O(J, 2);
  za(ae);
  var fe = O(ae, 2);
  {
    var ie = Me => {
      var Pe = v8(),
        Ie = I(Pe, !0);
      C(Pe), Ue(() => ce(Ie, a.max - _(z))), Z(Me, Pe)
    };
    Ee(fe, Me => {
      a.max !== void 0 && Me(ie)
    })
  }
  C(F);
  var $ = O(F, 2);
  {
    var Se = Me => {
      var Pe = y8(),
        Ie = I(Pe, !0);
      C(Pe), Ue(() => ce(Ie, _(A))), Z(Me, Pe)
    };
    Ee($, Me => {
      _(A) && Me(Se)
    })
  }
  C(s), Ue(() => {
    q = qr(F, 1, "input w-full", null, q, {
      "input-error": !!_(A)
    }), cr(ae, "placeholder", a.placeholder), cr(ae, "maxlength", a.max)
  }), Xh(ae, d), Z(m, s), $r()
}
var b8 = me('<dialog class="modal"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function w8(m, a) {
  Wr(a, !0);
  let d = At(a, "ref", 15),
    x = et(!1),
    A = et(""),
    z = et(void 0);
  ri(() => {
    const Pe = Ie => {
      var Ce;
      Ie.key === "Escape" && ((Ce = d()) == null || Ce.close())
    };
    return document.addEventListener("keydown", Pe), () => document.removeEventListener("keydown", Pe)
  });
  var b = b8(),
    s = I(b),
    F = I(s),
    q = I(F, !0);
  C(F);
  var J = O(F, 2),
    te = I(J),
    ae = I(te);
  {
    let Pe = ut(() => Em()),
      Ie = ut(() => TS());
    Bm(ae, {
      get label() {
        return _(Pe)
      },
      get placeholder() {
        return _(Ie)
      },
      min: 1,
      max: 16,
      get value() {
        return _(A)
      },
      set value(Ce) {
        Y(A, Ce, !0)
      },
      get validate() {
        return _(z)
      },
      set validate(Ce) {
        Y(z, Ce, !0)
      }
    })
  }
  C(te);
  var fe = O(te, 2),
    ie = I(fe);
  ie.__click = () => {
    var Pe;
    (Pe = d()) == null || Pe.close()
  };
  var $ = I(ie, !0);
  C(ie);
  var Se = O(ie, 2),
    Me = I(Se, !0);
  C(Se), C(fe), C(J), C(s), wn(2), C(b), lo(b, Pe => d(Pe), () => d()), Ue((Pe, Ie, Ce) => {
    ce(q, Pe), ie.disabled = _(x), ce($, Ie), Se.disabled = _(x), ce(Me, Ce)
  }, [() => xS(), () => Yh(), () => CS()]), Ln("submit", J, async () => {
    var Pe, Ie;
    try {
      if (!((Pe = _(z)) != null && Pe())) return;
      Y(x, !0);
      const {
        id: Ce
      } = await fn.createAlliance(_(A));
      await a.onsuccess(Ce), (Ie = d()) == null || Ie.close()
    } catch (Ce) {
      Xt.error(Ce.message)
    } finally {
      Y(x, !1)
    }
  }), Z(m, b), $r()
}
ni(["click"]);
var T8 = jr('<svg><path d="M160-160v-100.77l527.23-527.77q6.15-5.48 13.57-8.47 7.43-2.99 15.49-2.99t15.62 2.54q7.55 2.54 13.94 9.15l42.69 42.93q6.61 6.38 9.04 14 2.42 7.63 2.42 15.25 0 8.13-2.74 15.56-2.74 7.42-8.72 13.57L260.77-160H160Zm540.15-496.46L760-715.54 715.54-760l-59.08 59.85 43.69 43.69Z"></path></svg>'),
  S8 = jr('<svg><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"></path></svg>');

function Om(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = or(),
    A = xt(x);
  {
    var z = s => {
        var F = T8();
        _r(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...d
        })), Z(s, F)
      },
      b = s => {
        var F = S8();
        _r(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...d
        })), Z(s, F)
      };
    Ee(A, s => {
      a.filled ? s(z) : s(b, !1)
    })
  }
  Z(m, x)
}
var P8 = jr('<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');

function C8(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = P8();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var I8 = jr('<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>');

function M8(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = I8();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var A8 = jr('<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>');

function k8(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = A8();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var E8 = jr('<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>');

function af(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = E8();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}

function L8(m, a = "_blank") {
  return m.replaceAll(/https?:\/\/[^\s]+/g, d => `<a href="${d}"${a?` target="${a}"`:""}>${d}</a>`)
}
var z8 = me('<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>'),
  D8 = me('<div class="tooltip"><button class="btn"><!></button></div>'),
  R8 = me('<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>'),
  F8 = me('<section class="text-base-content/80 highlight-link"><!> <!></section>'),
  B8 = me('<span class="font-semibold"> </span>'),
  O8 = me('<button class="text-primary font-semibold underline"> </button>'),
  N8 = me('<span class="text-primary underline"> </span>'),
  j8 = me('<span class="text-primary underline"> </span>'),
  q8 = me('<button class="text-base-content/80 p-1"><!></button>'),
  V8 = me('<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>'),
  U8 = me('<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>', 1),
  Z8 = me('<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>', 1),
  G8 = me('<div class="h-full"><!></div>');

function H8(m, a) {
  Wr(a, !0);
  let d = et(void 0),
    x = et(!0),
    A = et(void 0),
    z = et(!1),
    b = et(void 0),
    s = et(!1),
    F = et(!1),
    q = et(() => {});
  Gs(() => a.open, () => {
    a.open && kp.shouldReload && J()
  }), ri(() => {
    const $ = setInterval(() => {
      kp.shouldReload = !0
    }, 1e4);
    return () => {
      clearTimeout($)
    }
  });
  async function J() {
    try {
      Y(d, await fn.getAlliance(), !0), _(d) && _(q)(), Y(x, !1), kp.shouldReload = !1
    } catch ($) {
      Xt.error($.message)
    }
  }
  var te = G8(),
    ae = I(te);
  {
    var fe = $ => {
        var Se = z8();
        Z($, Se)
      },
      ie = $ => {
        var Se = or(),
          Me = xt(Se);
        {
          var Pe = Ce => {
              g8(Ce, {
                onclickback: () => Y(F, !1)
              })
            },
            Ie = Ce => {
              var je = or(),
                Ye = xt(je);
              {
                var qe = He => {
                    var we = U8(),
                      it = xt(we),
                      mt = I(it),
                      Ge = I(mt, !0);
                    C(mt);
                    var Xe = O(mt, 2),
                      vt = I(Xe),
                      Ut = I(vt),
                      _t = I(Ut);
                    Fg(_t, {
                      class: "size-4"
                    }), C(Ut);
                    var wt = O(Ut, 2),
                      Je = I(wt),
                      zt = I(Je);
                    zt.__click = async () => {
                      try {
                        Y(z, !0), await fn.leaveAlliance(), Y(x, !0), await J()
                      } catch (Le) {
                        Xt.error(Le.message)
                      } finally {
                        Y(z, !1)
                      }
                    };
                    var bt = I(zt, !0);
                    C(zt), C(Je), C(wt), C(vt);
                    var Rt = O(vt, 2);
                    {
                      var Pt = Le => {
                        var j = D8(),
                          E = I(j);
                        E.__click = () => {
                          Y(s, !0)
                        };
                        var D = I(E);
                        k8(D, {
                          class: "size-4"
                        }), C(E), C(j), Ue(N => cr(j, "data-tip", N), [() => eS()]), Z(Le, j)
                      };
                      Ee(Rt, Le => {
                        _(d).role == "admin" && Le(Pt)
                      })
                    }
                    C(Xe), C(it);
                    var yt = O(it, 2);
                    {
                      var sr = Le => {
                        var j = F8(),
                          E = I(j);
                        Jp(E, () => L8(_(d).description || $0()));
                        var D = O(E, 2);
                        {
                          var N = X => {
                            var ee = R8();
                            ee.__click = () => {
                              var be;
                              (be = _(b)) == null || be.show()
                            };
                            var pe = I(ee);
                            Om(pe, {
                              class: "size-4"
                            }), C(ee), Z(X, ee)
                          };
                          Ee(D, X => {
                            _(d).role === "admin" && X(N)
                          })
                        }
                        C(j), Z(Le, j)
                      };
                      Ee(yt, Le => {
                        (_(d).description || _(d).role === "admin") && Le(sr)
                      })
                    }
                    var tr = O(yt, 2),
                      tt = I(tr),
                      ht = I(tt);
                    Il(ht, {
                      class: "inline size-4"
                    });
                    var It = O(ht, 2),
                      Bt = I(It),
                      Nt = O(Bt),
                      Ht = I(Nt, !0);
                    C(Nt), C(It), C(tt);
                    var yr = O(tt, 2),
                      Wt = I(yr);
                    af(Wt, {
                      class: "inline size-4"
                    });
                    var Zt = O(Wt, 2),
                      jt = I(Zt),
                      Jt = O(jt);
                    {
                      var Lt = Le => {
                          var j = B8(),
                            E = I(j, !0);
                          C(j), Ue(D => ce(E, D), [() => _(d).members.toLocaleString("en-US")]), Z(Le, j)
                        },
                        Gt = Le => {
                          var j = O8();
                          j.__click = () => Y(F, !0);
                          var E = I(j, !0);
                          C(j), Ue(D => ce(E, D), [() => _(d).members.toLocaleString("en-US")]), Z(Le, j)
                        };
                      Ee(Jt, Le => {
                        _(d).role === "member" ? Le(Lt) : Le(Gt, !1)
                      })
                    }
                    C(Zt), C(yr);
                    var Yt = O(yr, 2);
                    {
                      var Lr = Le => {
                        var j = V8(),
                          E = I(j);
                        C8(E, {
                          class: "inline size-4"
                        });
                        var D = O(E, 2),
                          N = I(D),
                          X = O(N);
                        X.__click = () => {
                          var oe;
                          (oe = _(d)) != null && oe.hq ? a.onhqclick({
                            lat: _(d).hq.latitude,
                            lng: _(d).hq.longitude
                          }) : a.onhqchange()
                        };
                        var ee = I(X);
                        {
                          var pe = oe => {
                              var K = N8(),
                                he = I(K);
                              C(K), Ue((Q, ze) => ce(he, `${Q??""}, ${ze??""}`), [() => _(d).hq.latitude.toFixed(3), () => _(d).hq.longitude.toFixed(3)]), Z(oe, K)
                            },
                            be = oe => {
                              var K = j8(),
                                he = I(K, !0);
                              C(K), Ue(Q => ce(he, Q), [() => AT()]), Z(oe, K)
                            };
                          Ee(ee, oe => {
                            _(d).hq ? oe(pe) : oe(be, !1)
                          })
                        }
                        C(X), C(D);
                        var ye = O(D, 2);
                        {
                          var Oe = oe => {
                            var K = q8();
                            K.__click = function(...Q) {
                              var ze;
                              (ze = a.onhqchange) == null || ze.apply(this, Q)
                            };
                            var he = I(K);
                            Om(he, {
                              class: "text-base-content/50 size-4"
                            }), C(K), Z(oe, K)
                          };
                          Ee(ye, oe => {
                            _(d).role === "admin" && oe(Oe)
                          })
                        }
                        C(j), Ue(oe => ce(N, `${oe??""}: `), [() => CT()]), Z(Le, j)
                      };
                      Ee(Yt, Le => {
                        (_(d).hq || _(d).role === "admin") && Le(Lr)
                      })
                    }
                    C(tr);
                    var Ir = O(tr, 2),
                      Jr = I(Ir),
                      Tr = I(Jr, !0);
                    C(Jr);
                    var Ar = O(Jr, 2),
                      xr = I(Ar);
                    a8(xr, {
                      get allianceId() {
                        return _(d).id
                      },
                      get onlastpixelclick() {
                        return a.onlastpixelclick
                      },
                      get reload() {
                        return _(q)
                      },
                      set reload(Le) {
                        Y(q, Le, !0)
                      }
                    }), C(Ar), C(Ir);
                    var qt = O(Ir, 2);
                    EE(qt, {
                      get description() {
                        return _(d).description
                      },
                      onsuccess: async Le => {
                        _(d) && (_(d).description = Le)
                      },
                      get ref() {
                        return _(b)
                      },
                      set ref(Le) {
                        Y(b, Le, !0)
                      }
                    });
                    var Yr = O(qt, 2);
                    DE(Yr, {
                      get open() {
                        return _(s)
                      },
                      set open(Le) {
                        Y(s, Le, !0)
                      }
                    }), Ue((Le, j, E, D, N) => {
                      ce(Ge, _(d).name), zt.disabled = _(z), ce(bt, Le), ce(Bt, `${j??""}: `), ce(Ht, E), ce(jt, `${D??""}: `), ce(Tr, N)
                    }, [() => TT(), () => _g(), () => _(d).pixelsPainted.toLocaleString("en-US"), () => N0(), () => Tg()]), Z(He, we)
                  },
                  Be = He => {
                    var we = Z8(),
                      it = xt(we),
                      mt = I(it),
                      Ge = I(mt);
                    C(mt);
                    var Xe = O(mt, 2),
                      vt = I(Xe);
                    M8(vt, {
                      class: "size-5"
                    });
                    var Ut = O(vt, 1, !0);
                    C(Xe);
                    var _t = O(Xe, 2),
                      wt = I(_t),
                      Je = I(wt, !0);
                    C(wt), C(_t);
                    var zt = O(_t, 2);
                    zt.__click = () => {
                      var yt;
                      (yt = _(A)) == null || yt.show()
                    };
                    var bt = I(zt);
                    L0(bt, {
                      class: "size-6"
                    });
                    var Rt = O(bt);
                    C(zt), C(it);
                    var Pt = O(it, 2);
                    w8(Pt, {
                      onsuccess: J,
                      get ref() {
                        return _(A)
                      },
                      set ref(yt) {
                        Y(A, yt, !0)
                      }
                    }), Ue((yt, sr, tr, tt) => {
                      ce(Ge, `${yt??""}:`), ce(Ut, sr), ce(Je, tr), ce(Rt, ` ${tt??""}`)
                    }, [() => LT(), () => RT(), () => OT(), () => qT()]), Z(He, we)
                  };
                Ee(Ye, He => {
                  _(d) ? He(qe) : He(Be, !1)
                }, !0)
              }
              Z(Ce, je)
            };
          Ee(Me, Ce => {
            _(F) ? Ce(Pe) : Ce(Ie, !1)
          }, !0)
        }
        Z($, Se)
      };
    Ee(ae, $ => {
      _(x) ? $(fe) : $(ie, !1)
    })
  }
  C(te), Z(m, te), $r()
}
ni(["click"]);
var W8 = jr('<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>');

function of(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = W8();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var $8 = me('<dialog class="modal"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function X8(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15);
  ri(() => {
    const te = ae => {
      ae.key === "Escape" && d(!1)
    };
    return document.addEventListener("keydown", te), () => document.removeEventListener("keydown", te)
  });
  var x = $8(),
    A = I(x),
    z = O(I(A), 2),
    b = I(z);
  of(b, {
    class: "size-5 max-sm:size-6"
  });
  var s = O(b, 2),
    F = I(s, !0);
  C(s), C(z);
  var q = O(z, 2),
    J = I(q);
  H8(J, {
    get open() {
      return d()
    },
    get onhqchange() {
      return a.onhqchange
    },
    get onhqclick() {
      return a.onhqclick
    },
    get onlastpixelclick() {
      return a.onlastpixelclick
    }
  }), C(q), C(A), wn(2), C(x), Di(x, () => te => {
    tn(() => {
      d() ? (te.show(), Ni.url.searchParams.get("alliance") && (Ni.url.searchParams.delete("alliance"), Rp(Ni.url.toString()))) : te.close()
    })
  }), Ue(te => ce(F, te), [() => tf()]), Ln("close", x, () => d(!1)), ba(2, q, () => so, () => ({
    duration: 300
  })), Z(m, x), $r()
}

function Y8(m, a, d) {
  return new Promise((x, A) => {
    m.once("render", () => {
      const z = m.getCanvas().toDataURL(),
        b = document.createElement("img");
      b.src = z, b.onload = () => {
        const s = document.createElement("canvas");
        s.width = b.width, s.height = b.height;
        const F = s.getContext("2d");
        if (F) {
          F.drawImage(b, 0, 0);
          const [q, J, te, ae] = F.getImageData(a, d, 1, 1).data;
          x([q, J, te, ae])
        } else A(new Error("Could not get 2d context from canvas"));
        b.remove(), s.remove()
      }
    }), m.triggerRepaint()
  })
}

function Bg(m, a) {
  return new Promise((d, x) => {
    m.once("render", () => {
      const A = m.getCanvas();
      let z = A;
      if (a != null && a.maxWidth || a != null && a.maxHeight) {
        const b = A.width,
          s = A.height,
          F = (a == null ? void 0 : a.maxWidth) ?? b,
          q = (a == null ? void 0 : a.maxHeight) ?? s;
        z = document.createElement("canvas");
        const J = Math.min(F / b, q / s);
        z.width = Math.floor(b * J), z.height = Math.floor(s * J);
        const te = z.getContext("2d");
        te && te.drawImage(A, 0, 0, z.width, z.height)
      }
      try {
        z.toBlob(b => {
          b && d(b)
        }, (a == null ? void 0 : a.type) ?? "image/png", (a == null ? void 0 : a.quality) ?? 1)
      } catch (b) {
        x(b)
      } finally {
        z !== A && z.remove()
      }
    })
  })
}
var K8 = jr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>');

function J8(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = K8();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var Q8 = jr('<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>');

function Py(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = Q8();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
const Ec = {
  hour: 3600 * 1e3,
  min: 60 * 1e3,
  sec: 1e3
};

function Np(m) {
  const a = Math.floor(m / Ec.hour);
  m -= a * Ec.hour;
  const d = Math.floor(m / Ec.min);
  m -= d * Ec.min;
  const A = Math.floor(m / Ec.sec).toString().padStart(2, "0");
  return a > 0 ? `${a}:${d.toString().padStart(2,"0")}:${A}` : `${d}:${A}`
}

function eL(m) {
  const a = m.getFullYear(),
    d = String(m.getMonth() + 1).padStart(2, "0"),
    x = String(m.getDate()).padStart(2, "0"),
    A = String(m.getHours()).padStart(2, "0"),
    z = String(m.getMinutes()).padStart(2, "0"),
    b = String(m.getSeconds()).padStart(2, "0");
  return `${a}-${d}-${x} ${A}:${z}:${b}`
}
var tL = me('<div class="text-base-content/80 mt-2 text-xs"><span class="font-semibold"> </span> </div>'),
  rL = me('<img class="border-base-content/20 border" alt="Screenshot"/>'),
  nL = me('<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>'),
  iL = me('<div><h3 class="mb-1 mt-4 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>'),
  aL = me('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function oL(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15),
    x = et(!1);
  ri(() => {
    const Ye = qe => {
      qe.key === "Escape" && d(!1)
    };
    return document.addEventListener("keydown", Ye), () => document.removeEventListener("keydown", Ye)
  });
  let A = et(null),
    z = et("");
  const b = ut(() => {
    const Ye = new URL(a.url.toString()),
      qe = Ye.searchParams.get("lat"),
      Be = Ye.searchParams.get("lng");
    if (qe && Be) return {
      lat: parseFloat(qe),
      lng: parseFloat(Be)
    }
  });
  tn(() => {
    d() ? (a.hideHover(), setTimeout(async () => {
      Bg(a.map).then(Ye => {
        Y(A, Ye, !0), Y(z, URL.createObjectURL(_(A)), !0)
      }).finally(() => {
        a.showHover()
      })
    }, 500)) : _(z) && (URL.revokeObjectURL(_(z)), Y(A, null), Y(z, ""))
  });
  var s = aL(),
    F = I(s),
    q = O(I(F), 2),
    J = I(q);
  Py(J, {
    class: "size-5"
  });
  var te = O(J);
  C(q);
  var ae = O(q, 2),
    fe = I(ae);
  za(fe);
  var ie = O(fe, 2),
    $ = I(ie);
  let Se;
  $.__click = () => {
    navigator.clipboard.writeText(a.url.toString()), Y(x, !0), setTimeout(() => {
      Y(x, !1)
    }, 1e3)
  };
  var Me = I($, !0);
  C($), C(ie), C(ae);
  var Pe = O(ae, 2);
  {
    var Ie = Ye => {
      var qe = tL(),
        Be = I(qe),
        He = I(Be);
      C(Be);
      var we = O(Be);
      C(qe), Ue(it => {
        ce(He, `${it??""}:`), ce(we, ` ${_(b).lat??""}, ${_(b).lng??""}`)
      }, [() => ny()]), Z(Ye, qe)
    };
    Ee(Pe, Ye => {
      _(b) && Ye(Ie)
    })
  }
  var Ce = O(Pe, 2);
  {
    var je = Ye => {
      const qe = ut(() => {
        var Rt;
        return (Rt = a.map) == null ? void 0 : Rt.getCanvas()
      });
      var Be = iL(),
        He = I(Be),
        we = I(He);
      J8(we, {
        class: "inline size-5"
      });
      var it = O(we);
      C(He);
      var mt = O(He, 2);
      {
        var Ge = Rt => {
            var Pt = rL();
            Ue(() => {
              cr(Pt, "src", _(z)), cr(Pt, "width", _(qe).width), cr(Pt, "height", _(qe).height)
            }), Z(Rt, Pt)
          },
          Xe = Rt => {
            var Pt = nL();
            Ue(() => bs(Pt, `aspect-ratio: ${_(qe).width/_(qe).height}`)), Z(Rt, Pt)
          };
        Ee(mt, Rt => {
          _(z) ? Rt(Ge) : Rt(Xe, !1)
        })
      }
      var vt = O(mt, 2),
        Ut = I(vt);
      Ut.__click = async () => {
        _(A) && (await navigator.clipboard.write([new ClipboardItem({
          "image/png": _(A)
        })]), Xt.info(SI()))
      };
      var _t = I(Ut);
      bg(_t, {
        class: "size-5"
      });
      var wt = O(_t);
      C(Ut);
      var Je = O(Ut, 2),
        zt = I(Je);
      yg(zt, {
        class: "size-5"
      });
      var bt = O(zt);
      C(Je), C(vt), C(Be), Ue((Rt, Pt, yt, sr) => {
        ce(it, ` ${Rt??""}`), ce(wt, ` ${Pt??""}`), cr(Je, "href", _(z)), cr(Je, "download", `wplace_${yt??""}.png`), ce(bt, ` ${sr??""}`)
      }, [() => vI(), () => Am(), () => eL(new Date).replaceAll(" ", "_").replaceAll(":", "-"), () => bI()]), ba(2, Be, () => so, () => ({
        duration: 300
      })), Z(Ye, Be)
    };
    Ee(Ce, Ye => {
      d() && Ye(je)
    })
  }
  C(F), wn(2), C(s), Di(s, () => Ye => {
    tn(() => {
      d() ? Ye.show() : Ye.close()
    })
  }), Ue((Ye, qe, Be) => {
    ce(te, ` ${Ye??""}`), dg(fe, qe), Se = qr($, 1, "btn btn-primary", null, Se, {
      "btn-success": _(x)
    }), ce(Me, Be)
  }, [() => zP(), () => a.url.toString(), () => _(x) ? Pg() : Am()]), Ln("close", s, () => d(!1)), Z(m, s), $r()
}
ni(["click"]);
var sL = jr('<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>');

function lL(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = sL();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var cL = me('<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>'),
  uL = me('<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p> <p class="text-base-content/80 mt-0.5 text-sm"> <a class="link" href="/terms/code-of-conduct" target="_blank"> </a>.</p></div></div>');

function Og(m, a) {
  Wr(a, !1);
  const d = [n3(), e3(), o3(), c3(), d3(), m3(), v3()];
  mg();
  var x = uL(),
    A = I(x),
    z = I(A);
  lL(z, {
    class: "size-5"
  });
  var b = O(z, 2),
    s = I(b),
    F = O(s),
    q = I(F, !0);
  C(F), C(b), C(A);
  var J = O(A, 2),
    te = I(J);
  fi(te, 5, () => d, $h, (Pe, Ie) => {
    var Ce = cL(),
      je = I(Ce, !0);
    C(Ce), Ue(() => ce(je, _(Ie))), Z(Pe, Ce)
  }), C(te);
  var ae = O(te, 2),
    fe = I(ae, !0);
  C(ae);
  var ie = O(ae, 2),
    $ = I(ie),
    Se = O($),
    Me = I(Se, !0);
  C(Se), wn(), C(ie), C(J), C(x), Ue((Pe, Ie, Ce, je, Ye) => {
    ce(s, `${Pe??""} `), ce(q, Ie), ce(fe, Ce), ce($, `${je??""} `), ce(Me, Ye)
  }, [() => $5(), () => K5(), () => b3(), () => J4(), () => tM()]), Z(m, x), $r()
}
var hL = me('<dialog class="modal"><div class="modal-box sm:max-h-11/12"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <div class="flex h-full flex-col gap-6"><h2 class="text-xl font-semibold">üìë Updated rules</h2> <section><!></section> <button class="btn btn-primary">Close</button></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function dL(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15);
  ri(() => {
    const q = J => {
      J.key === "Escape" && d(!1)
    };
    return document.addEventListener("keydown", q), () => document.removeEventListener("keydown", q)
  });
  var x = hL(),
    A = I(x),
    z = O(I(A), 2),
    b = O(I(z), 2),
    s = I(b);
  Og(s, {}), C(b);
  var F = O(b, 2);
  F.__click = () => {
    d(!1)
  }, C(z), C(A), wn(2), C(x), Di(x, () => q => {
    tn(() => {
      d() ? q.show() : q.close()
    })
  }), Ln("close", x, () => d(!1)), Z(m, x), $r()
}
ni(["click"]);
var pL = me('<dialog class="modal"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>');

function fL(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15);
  ri(() => {
    const $ = Se => {
      Se.key === "Escape" && d(!1)
    };
    return document.addEventListener("keydown", $), () => document.removeEventListener("keydown", $)
  });
  var x = pL(),
    A = I(x),
    z = I(A),
    b = I(z),
    s = I(b),
    F = I(s, !0);
  C(s);
  var q = O(s, 2);
  wg(q, {
    hasText: !0,
    size: "medium"
  }), C(b), C(z);
  var J = O(z, 2),
    te = I(J);
  Og(te, {}), C(J);
  var ae = O(J, 2),
    fe = I(ae);
  fe.__click = () => {
    Ni.url.searchParams.delete("new-user"), Rp(Ni.url.toString())
  };
  var ie = I(fe, !0);
  C(fe), C(ae), C(A), C(x), Di(x, () => $ => {
    tn(() => {
      d() ? $.show() : $.close()
    })
  }), Ue(($, Se) => {
    ce(F, $), ce(ie, Se)
  }, [() => G5(), () => S3()]), Ln("close", x, () => d(!1)), Z(m, x), $r()
}
ni(["click"]);

function mL() {
  const m = navigator.userAgent,
    a = navigator.vendor;
  return /Chrome/.test(m) && /Google Inc/.test(a) ? "Chrome" : /Safari/.test(m) && /Apple Computer/.test(a) ? "Safari" : /Firefox/.test(m) ? "Firefox" : /Edge/.test(m) ? "Edge" : /Opera|OPR/.test(m) ? "Opera" : "Unknown"
}
var gL = jr('<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>');

function _L(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = gL();
  _r(x, () => ({
    viewBox: "0 0 512 512",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...d
  })), Z(m, x)
}
var vL = jr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z"></path></svg>');

function Nm(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = vL();
  _r(x, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var yL = jr('<svg><path d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>');

function xL(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = yL();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    preserveAspectRatio: "xMidYMid",
    viewBox: "0 0 260 260",
    ...d
  })), Z(m, x)
}
var bL = jr('<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>');

function jp(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = bL();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var wL = jr(`<svg><path d="M12.75 2c.39 0 .708.316.75.704a5.735 5.735 0 0 0 
  4.112 4.751c.257.077.523.127.801.149.394.028.713.35.713.744v2.289a.75.75 
  0 0 1-.826.746 8.89 8.89 0 0 1-3.546-1.239v6.43a5.465 5.465 0 
  1 1-5.465-5.465c.388 0 .765.042 1.128.122a.75.75 0 0 
  1 .593.732v2.289a.75.75 0 0 1-.979.715 1.549 1.549 0 0 
  0-.482-.077 1.962 1.962 0 1 0 1.962 1.962V2.75a.75.75 0 0 1 
  .75-.75h1.239Z"></path></svg>`);

function TL(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = wL();
  _r(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "Tiktok",
    ...d
  })), Z(m, x)
}
var SL = jr(`<svg><path d="M23.498 6.186a2.986 2.986 0 0 0-2.103-2.115C19.505 
    3.5 12 3.5 12 3.5s-7.505 0-9.395.571a2.986 2.986 0 0 0-2.103 
    2.115C0 8.082 0 12 0 12s0 3.918.502 5.814a2.986 2.986 0 0 0 
    2.103 2.115C4.495 20.5 12 20.5 12 20.5s7.505 0 9.395-.571a2.986 
    2.986 0 0 0 2.103-2.115C24 15.918 24 12 24 12s0-3.918-.502-5.814zM9.75 
    15.021v-6.042L15.5 12l-5.75 3.021z"></path></svg>`);

function PL(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = SL();
  _r(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "YouTube",
    ...d
  })), Z(m, x)
}
var CL = me(' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>', 1),
  IL = me('<span class="link cursor-auto">chrome://settings/system</span>.', 1),
  ML = me('<span class="link cursor-auto">edge://settings/system/manageSystem</span>.', 1),
  AL = me(' <kbd class="kbd kbd-sm"> </kbd> <!>', 1),
  kL = me('<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a href="https://discord.gg/wplacelive" target="_blank" class="text-nowrap"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank" class="text-nowrap"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank" class="text-nowrap"><!> <span class="link">Instagram</span></a> <span class="mx-0.5">|</span> <a href="https://www.youtube.com/@WplaceLive" target="_blank" class="text-nowrap"><!> <span class="link">Youtube</span></a> <span class="mx-0.5">|</span> <a href="https://www.tiktok.com/@wplace5" target="_blank" class="text-nowrap"><!> <span class="link">Tiktok</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm max-sm:pb-4"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span> ¬∑ <a class="link" target="_blank"> </a> ¬∑ <a class="link" target="_blank"> </a> ¬∑ <a class="link" target="_blank"> </a> ¬∑ <a class="link" href="https://forms.gle/tpDWwewuK5i9C52s8" target="_blank"> </a> ¬∑ <a class="link" href="https://forms.gle/EVG7A1ZoSyJWAjX96" target="_blank"> </a> ¬∑ <a class="link" href="https://forms.gle/uinGA5Gj4SpPYa2R6" target="_blank"> </a></section></div>'),
  EL = me('<dialog class="modal"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function LL(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15);
  ri(() => {
    const te = ae => {
      ae.key === "Escape" && d(!1)
    };
    return document.addEventListener("keydown", te), () => document.removeEventListener("keydown", te)
  });
  const x = mL();
  var A = EL(),
    z = I(A),
    b = O(I(z), 2);
  {
    var s = te => {
      var ae = kL(),
        fe = I(ae),
        ie = I(fe);
      wg(ie, {
        hasText: !0,
        size: "medium"
      });
      var $ = O(ie, 2),
        Se = I($),
        Me = O(Se, 4);
      wn(), C($);
      var Pe = O($, 2),
        Ie = I(Pe),
        Ce = I(Ie),
        je = I(Ce);
      Nm(je, {
        class: "text-base-content mr-0.5 inline size-4"
      }), wn(2), C(Ce);
      var Ye = O(Ce, 4),
        qe = I(Ye);
      _L(qe, {
        class: "size-4.5 mr-0.5 inline"
      }), wn(2), C(Ye);
      var Be = O(Ye, 4),
        He = I(Be);
      xL(He, {
        class: "mr-0.5 inline size-3.5"
      }), wn(2), C(Be);
      var we = O(Be, 4),
        it = I(we);
      PL(it, {
        class: "mr-0.5 inline size-3.5"
      }), wn(2), C(we);
      var mt = O(we, 4),
        Ge = I(mt);
      TL(Ge, {
        class: "mr-0.5 inline size-3.5"
      }), wn(2), C(mt), C(Ie), C(Pe), C(fe);
      var Xe = O(fe, 2),
        vt = I(Xe),
        Ut = I(vt, !0);
      C(vt);
      var _t = O(vt, 2);
      C(Xe);
      var wt = O(Xe, 2),
        Je = I(wt),
        zt = I(Je, !0);
      C(Je);
      var bt = O(Je, 2),
        Rt = I(bt),
        Pt = O(Rt),
        yt = I(Pt);
      jp(yt, {
        class: "size-5"
      }), C(Pt);
      var sr = O(Pt);
      C(bt);
      var tr = O(bt, 2),
        tt = I(tr),
        ht = O(tt),
        It = I(ht, !0);
      C(ht);
      var Bt = O(ht);
      C(tr), C(wt);
      var Nt = O(wt, 2),
        Ht = I(Nt),
        yr = I(Ht, !0);
      C(Ht);
      var Wt = O(Ht, 2),
        Zt = I(Wt);
      {
        var jt = N => {
            var X = CL(),
              ee = xt(X);
            wn(), Ue(pe => ce(ee, `${pe??""}: `), [() => NI()]), Z(N, X)
          },
          Jt = N => {
            var X = AL(),
              ee = xt(X),
              pe = O(ee),
              be = I(pe, !0);
            C(pe);
            var ye = O(pe),
              Oe = O(ye);
            {
              var oe = he => {
                  var Q = IL();
                  wn(), Z(he, Q)
                },
                K = he => {
                  var Q = or(),
                    ze = xt(Q);
                  {
                    var $e = Re => {
                      var ft = ML();
                      wn(), Z(Re, ft)
                    };
                    Ee(ze, Re => {
                      x === "Edge" && Re($e)
                    }, !0)
                  }
                  Z(he, Q)
                };
              Ee(Oe, he => {
                x === "Chrome" ? he(oe) : he(K, !1)
              })
            }
            Ue((he, Q, ze) => {
              ce(ee, `${he??""} `), ce(be, Q), ce(ye, ` ${ze??""} `)
            }, [() => kI(), () => zI(), () => FI()]), Z(N, X)
          };
        Ee(Zt, N => {
          x !== "Chrome" && x !== "Edge" ? N(jt) : N(Jt, !1)
        })
      }
      C(Wt), C(Nt);
      var Lt = O(Nt, 2),
        Gt = I(Lt);
      Og(Gt, {}), C(Lt);
      var Yt = O(Lt, 4),
        Lr = O(I(Yt), 2),
        Ir = I(Lr, !0);
      C(Lr);
      var Jr = O(Lr, 2),
        Tr = I(Jr, !0);
      C(Jr);
      var Ar = O(Jr, 2),
        xr = I(Ar, !0);
      C(Ar);
      var qt = O(Ar, 2),
        Yr = I(qt, !0);
      C(qt);
      var Le = O(qt, 2),
        j = I(Le, !0);
      C(Le);
      var E = O(Le, 2),
        D = I(E, !0);
      C(E), C(Yt), C(ae), Ue((N, X, ee, pe, be, ye, Oe, oe, K, he, Q, ze, $e, Re, ft, Mt, Et, dt) => {
        ce(Se, `${N??""} `), ce(Me, ` ¬©
						${X??""} `), ce(Ut, ee), cr(_t, "src", ka.language === "pt" ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9" : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"), ce(zt, pe), ce(Rt, `${be??""} `), ce(sr, ` ${ye??""}`), ce(tt, `${Oe??""} `), ce(It, oe), ce(Bt, ` ${K??""}`), ce(yr, he), cr(Lr, "href", Q), ce(Ir, ze), cr(Jr, "href", `${Ni.url.origin??""}/terms/privacy`), ce(Tr, $e), cr(Ar, "href", Re), ce(xr, ft), ce(Yr, Mt), ce(j, Et), ce(D, dt)
      }, [() => K2(), () => ew(), () => nw(), () => ow(), () => cw(), () => dw(), () => mw(), () => vw(), () => bw(), () => II(), Qb, () => GI(), () => $I(), q0, () => J0(), () => ty(), () => H4(), () => X4()]), ba(2, ae, () => so, () => ({
        duration: 300
      })), Z(te, ae)
    };
    Ee(b, te => {
      d() && te(s)
    })
  }
  C(z);
  var F = O(z, 2),
    q = I(F),
    J = I(q, !0);
  C(q), C(F), C(A), Di(A, () => te => {
    tn(() => {
      d() ? te.show() : te.close()
    })
  }), Ue(te => ce(J, te), [() => xs()]), Ln("close", A, () => d(!1)), Z(m, A), $r()
}

function td(m) {
  return m !== null && typeof m == "object"
}
const zL = ["string", "number", "bigint", "boolean"];

function jm(m) {
  return m == null || zL.includes(typeof m) ? !0 : Array.isArray(m) ? m.every(a => jm(a)) : typeof m == "object" ? Object.getPrototypeOf(m) === Object.prototype : !1
}
const qp = Symbol("box"),
  Cy = Symbol("is-writable");

function pn(m, a) {
  const d = ut(m);
  return a ? {
    [qp]: !0,
    [Cy]: !0,
    get current() {
      return _(d)
    },
    set current(x) {
      a(x)
    }
  } : {
    [qp]: !0,
    get current() {
      return m()
    }
  }
}

function DL(m) {
  return td(m) && qp in m
}

function u0(m) {
  let a = et(zi(m));
  return {
    [qp]: !0,
    [Cy]: !0,
    get current() {
      return _(a)
    },
    set current(d) {
      Y(a, d, !0)
    }
  }
}

function RL(...m) {
  return function(a) {
    var d;
    for (const x of m)
      if (x) {
        if (a.defaultPrevented) return;
        typeof x == "function" ? x.call(this, a) : (d = x.current) == null || d.call(this, a)
      }
  }
}
var h0 = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
  FL = /\n/g,
  BL = /^\s*/,
  OL = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
  NL = /^:\s*/,
  jL = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
  qL = /^[;\s]*/,
  VL = /^\s+|\s+$/g,
  UL = `
`,
  d0 = "/",
  p0 = "*",
  xl = "",
  ZL = "comment",
  GL = "declaration";

function HL(m, a) {
  if (typeof m != "string") throw new TypeError("First argument must be a string");
  if (!m) return [];
  a = a || {};
  var d = 1,
    x = 1;

  function A(ie) {
    var $ = ie.match(FL);
    $ && (d += $.length);
    var Se = ie.lastIndexOf(UL);
    x = ~Se ? ie.length - Se : x + ie.length
  }

  function z() {
    var ie = {
      line: d,
      column: x
    };
    return function($) {
      return $.position = new b(ie), q(), $
    }
  }

  function b(ie) {
    this.start = ie, this.end = {
      line: d,
      column: x
    }, this.source = a.source
  }
  b.prototype.content = m;

  function s(ie) {
    var $ = new Error(a.source + ":" + d + ":" + x + ": " + ie);
    if ($.reason = ie, $.filename = a.source, $.line = d, $.column = x, $.source = m, !a.silent) throw $
  }

  function F(ie) {
    var $ = ie.exec(m);
    if ($) {
      var Se = $[0];
      return A(Se), m = m.slice(Se.length), $
    }
  }

  function q() {
    F(BL)
  }

  function J(ie) {
    var $;
    for (ie = ie || []; $ = te();) $ !== !1 && ie.push($);
    return ie
  }

  function te() {
    var ie = z();
    if (!(d0 != m.charAt(0) || p0 != m.charAt(1))) {
      for (var $ = 2; xl != m.charAt($) && (p0 != m.charAt($) || d0 != m.charAt($ + 1));) ++$;
      if ($ += 2, xl === m.charAt($ - 1)) return s("End of comment missing");
      var Se = m.slice(2, $ - 2);
      return x += 2, A(Se), m = m.slice($), x += 2, ie({
        type: ZL,
        comment: Se
      })
    }
  }

  function ae() {
    var ie = z(),
      $ = F(OL);
    if ($) {
      if (te(), !F(NL)) return s("property missing ':'");
      var Se = F(jL),
        Me = ie({
          type: GL,
          property: f0($[0].replace(h0, xl)),
          value: Se ? f0(Se[0].replace(h0, xl)) : xl
        });
      return F(qL), Me
    }
  }

  function fe() {
    var ie = [];
    J(ie);
    for (var $; $ = ae();) $ !== !1 && (ie.push($), J(ie));
    return ie
  }
  return q(), fe()
}

function f0(m) {
  return m ? m.replace(VL, xl) : xl
}

function WL(m, a) {
  let d = null;
  if (!m || typeof m != "string") return d;
  const x = HL(m),
    A = typeof a == "function";
  return x.forEach(z => {
    if (z.type !== "declaration") return;
    const {
      property: b,
      value: s
    } = z;
    A ? a(b, s, z) : s && (d = d || {}, d[b] = s)
  }), d
}
const $L = /\d/,
  XL = ["-", "_", "/", "."];

function YL(m = "") {
  if (!$L.test(m)) return m !== m.toLowerCase()
}

function KL(m) {
  const a = [];
  let d = "",
    x, A;
  for (const z of m) {
    const b = XL.includes(z);
    if (b === !0) {
      a.push(d), d = "", x = void 0;
      continue
    }
    const s = YL(z);
    if (A === !1) {
      if (x === !1 && s === !0) {
        a.push(d), d = z, x = s;
        continue
      }
      if (x === !0 && s === !1 && d.length > 1) {
        const F = d.at(-1);
        a.push(d.slice(0, Math.max(0, d.length - 1))), d = F + z, x = s;
        continue
      }
    }
    d += z, x = s, A = b
  }
  return a.push(d), a
}

function Iy(m) {
  return m ? KL(m).map(a => QL(a)).join("") : ""
}

function JL(m) {
  return ez(Iy(m || ""))
}

function QL(m) {
  return m ? m[0].toUpperCase() + m.slice(1) : ""
}

function ez(m) {
  return m ? m[0].toLowerCase() + m.slice(1) : ""
}

function wp(m) {
  if (!m) return {};
  const a = {};

  function d(x, A) {
    if (x.startsWith("-moz-") || x.startsWith("-webkit-") || x.startsWith("-ms-") || x.startsWith("-o-")) {
      a[Iy(x)] = A;
      return
    }
    if (x.startsWith("--")) {
      a[x] = A;
      return
    }
    a[JL(x)] = A
  }
  return WL(m, d), a
}

function tz(...m) {
  return (...a) => {
    for (const d of m) typeof d == "function" && d(...a)
  }
}

function rz(m, a) {
  const d = RegExp(m, "g");
  return x => {
    if (typeof x != "string") throw new TypeError(`expected an argument of type string, but got ${typeof x}`);
    return x.match(d) ? x.replace(d, a) : x
  }
}
const nz = rz(/[A-Z]/, m => `-${m.toLowerCase()}`);

function iz(m) {
  if (!m || typeof m != "object" || Array.isArray(m)) throw new TypeError(`expected an argument of type object, but got ${typeof m}`);
  return Object.keys(m).map(a => `${nz(a)}: ${m[a]};`).join(`
`)
}

function My(m = {}) {
  return iz(m).replace(`
`, " ")
}
const az = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"],
  oz = new Set(az);

function sz(m) {
  return oz.has(m)
}

function Qa(...m) {
  const a = {
    ...m[0]
  };
  for (let d = 1; d < m.length; d++) {
    const x = m[d];
    if (x) {
      for (const A of Object.keys(x)) {
        const z = a[A],
          b = x[A],
          s = typeof z == "function",
          F = typeof b == "function";
        if (s && sz(A)) {
          const q = z,
            J = b;
          a[A] = RL(q, J)
        } else if (s && F) a[A] = tz(z, b);
        else if (A === "class") {
          const q = jm(z),
            J = jm(b);
          q && J ? a[A] = rh(z, b) : q ? a[A] = rh(z) : J && (a[A] = rh(b))
        } else if (A === "style") {
          const q = typeof z == "object",
            J = typeof b == "object",
            te = typeof z == "string",
            ae = typeof b == "string";
          if (q && J) a[A] = {
            ...z,
            ...b
          };
          else if (q && ae) {
            const fe = wp(b);
            a[A] = {
              ...z,
              ...fe
            }
          } else if (te && J) {
            const fe = wp(z);
            a[A] = {
              ...fe,
              ...b
            }
          } else if (te && ae) {
            const fe = wp(z),
              ie = wp(b);
            a[A] = {
              ...fe,
              ...ie
            }
          } else q ? a[A] = z : J ? a[A] = b : te ? a[A] = z : ae && (a[A] = b)
        } else a[A] = b !== void 0 ? b : z
      }
      for (const A of Object.getOwnPropertySymbols(x)) {
        const z = a[A],
          b = x[A];
        a[A] = b !== void 0 ? b : z
      }
    }
  }
  return typeof a.style == "object" && (a.style = My(a.style).replaceAll(`
`, " ")), a.hidden === !1 && (a.hidden = void 0, delete a.hidden), a.disabled === !1 && (a.disabled = void 0, delete a.disabled), a
}
const Ay = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
My(Ay);
const lz = typeof window < "u" ? window : void 0;

function cz(m) {
  let a = m.activeElement;
  for (; a != null && a.shadowRoot;) {
    const d = a.shadowRoot.activeElement;
    if (d === a) break;
    a = d
  }
  return a
}
var Rc, fh;
class uz {
  constructor(a = {}) {
    Zr(this, Rc);
    Zr(this, fh);
    const {
      window: d = lz,
      document: x = d == null ? void 0 : d.document
    } = a;
    d !== void 0 && (oa(this, Rc, x), oa(this, fh, M0(A => {
      const z = nh(d, "focusin", A),
        b = nh(d, "focusout", A);
      return () => {
        z(), b()
      }
    })))
  }
  get current() {
    var a;
    return (a = Qe(this, fh)) == null || a.call(this), Qe(this, Rc) ? cz(Qe(this, Rc)) : null
  }
}
Rc = new WeakMap, fh = new WeakMap;
new uz;
var mh, gs;
class Ng {
  constructor(a) {
    Zr(this, mh);
    Zr(this, gs);
    oa(this, mh, a), oa(this, gs, Symbol(a))
  }
  get key() {
    return Qe(this, gs)
  }
  exists() {
    return fb(Qe(this, gs))
  }
  get() {
    const a = Ov(Qe(this, gs));
    if (a === void 0) throw new Error(`Context "${Qe(this,mh)}" not found`);
    return a
  }
  getOr(a) {
    const d = Ov(Qe(this, gs));
    return d === void 0 ? a : d
  }
  set(a) {
    return mb(Qe(this, gs), a)
  }
}
mh = new WeakMap, gs = new WeakMap;

function hz(m, a) {
  switch (m) {
    case "post":
      tn(a);
      break;
    case "pre":
      ug(a);
      break
  }
}

function ky(m, a, d, x = {}) {
  const {
    lazy: A = !1
  } = x;
  let z = !A,
    b = Array.isArray(m) ? [] : void 0;
  hz(a, () => {
    const s = Array.isArray(m) ? m.map(q => q()) : m();
    if (!z) {
      z = !0, b = s;
      return
    }
    const F = Aa(() => d(s, b));
    return b = s, F
  })
}

function Pl(m, a, d) {
  ky(m, "post", a, d)
}

function dz(m, a, d) {
  ky(m, "pre", a, d)
}
Pl.pre = dz;
var gh, Up;
class pz {
  constructor(a, d) {
    Zr(this, gh, () => {});
    Zr(this, Up, ut(() => Qe(this, gh).call(this)));
    let x;
    d !== void 0 && (x = d), oa(this, gh, () => {
      try {
        return x
      } finally {
        x = a()
      }
    })
  }
  get current() {
    return _(Qe(this, Up))
  }
}
gh = new WeakMap, Up = new WeakMap;

function fz(m, a) {
  return setTimeout(a, m)
}

function Ac(m) {
  hg().then(m)
}
const mz = 1,
  gz = 9,
  _z = 11;

function vz(m) {
  return td(m) && m.nodeType === mz && typeof m.nodeName == "string"
}

function Ey(m) {
  return td(m) && m.nodeType === gz
}

function yz(m) {
  var a;
  return td(m) && ((a = m.constructor) == null ? void 0 : a.name) === "VisualViewport"
}

function xz(m) {
  return td(m) && m.nodeType !== void 0
}

function bz(m) {
  return xz(m) && m.nodeType === _z && "host" in m
}

function wz(m) {
  return Ey(m) ? m : yz(m) ? m.document : (m == null ? void 0 : m.ownerDocument) ?? document
}

function Ly(m) {
  var a;
  return bz(m) ? Ly(m.host) : Ey(m) ? m.defaultView ?? window : vz(m) ? ((a = m.ownerDocument) == null ? void 0 : a.defaultView) ?? window : window
}

function Tz(m) {
  let a = m.activeElement;
  for (; a != null && a.shadowRoot;) {
    const d = a.shadowRoot.activeElement;
    if (d === a) break;
    a = d
  }
  return a
}
var _h;
class Sz {
  constructor(a) {
    Nr(this, "element");
    Zr(this, _h, ut(() => this.element.current ? this.element.current.getRootNode() ?? document : document));
    Nr(this, "getDocument", () => wz(this.root));
    Nr(this, "getWindow", () => this.getDocument().defaultView ?? window);
    Nr(this, "getActiveElement", () => Tz(this.root));
    Nr(this, "isActiveElement", a => a === this.getActiveElement());
    Nr(this, "querySelector", a => this.root ? this.root.querySelector(a) : null);
    Nr(this, "querySelectorAll", a => this.root ? this.root.querySelectorAll(a) : []);
    Nr(this, "setTimeout", (a, d) => this.getWindow().setTimeout(a, d));
    Nr(this, "clearTimeout", a => this.getWindow().clearTimeout(a));
    typeof a == "function" ? this.element = pn(a) : this.element = a
  }
  get root() {
    return _(Qe(this, _h))
  }
  set root(a) {
    Y(Qe(this, _h), a)
  }
  getElementById(a) {
    return this.root.getElementById(a)
  }
}
_h = new WeakMap;

function co(m, a) {
  return {
    [l2()]: d => DL(m) ? (m.current = d, Aa(() => a == null ? void 0 : a(d)), () => {
      "isConnected" in d && d.isConnected || (m.current = null, a == null || a(null))
    }) : (m(d), Aa(() => a == null ? void 0 : a(d)), () => {
      "isConnected" in d && d.isConnected || (m(null), a == null || a(null))
    })
  }
}

function qm(m) {
  return m ? "true" : "false"
}

function m0(m) {
  return m ? "" : void 0
}

function Pz(m) {
  return m ? !0 : void 0
}
var Fc, vh;
class Cz {
  constructor(a) {
    Zr(this, Fc);
    Zr(this, vh);
    Nr(this, "attrs");
    oa(this, Fc, a.getVariant ? a.getVariant() : null), oa(this, vh, Qe(this, Fc) ? `data-${Qe(this,Fc)}-` : `data-${a.component}-`), this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(a.parts.map(d => [d, this.getAttr(d)]))
  }
  getAttr(a, d) {
    return d ? `data-${d}-${a}` : `${Qe(this,vh)}${a}`
  }
  selector(a, d) {
    return `[${this.getAttr(a,d)}]`
  }
}
Fc = new WeakMap, vh = new WeakMap;

function zy(m) {
  const a = new Cz(m);
  return {
    ...a.attrs,
    selector: a.selector,
    getAttr: a.getAttr
  }
}
const Iz = "ArrowDown",
  Mz = "ArrowLeft",
  Az = "ArrowRight",
  kz = "ArrowUp",
  Ez = "End",
  Lz = "Enter",
  zz = "Home",
  Dz = "p",
  Rz = "n",
  Fz = "j",
  Bz = "k",
  Oz = "h",
  Nz = "l";

function sh() {}

function uo(m, a) {
  return `bits-${m}`
}

function jz(m) {
  if (!m) return null;
  for (const a of m.childNodes)
    if (a.nodeType !== Node.COMMENT_NODE) return a;
  return null
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = {
  current: 0
});

function qz(m = "bits") {
  return globalThis.bitsIdCounter.current++, `${m}-${globalThis.bitsIdCounter.current}`
}

function Vz(m, a) {
  let d = m.nextElementSibling;
  for (; d;) {
    if (d.matches(a)) return d;
    d = d.nextElementSibling
  }
}

function Uz(m, a) {
  let d = m.previousElementSibling;
  for (; d;) {
    if (d.matches(a)) return d;
    d = d.previousElementSibling
  }
}

function Dy(m) {
  if (typeof CSS < "u" && typeof CSS.escape == "function") return CSS.escape(m);
  const a = m.length;
  let d = -1,
    x, A = "";
  const z = m.charCodeAt(0);
  if (a === 1 && z === 45) return "\\" + m;
  for (; ++d < a;) {
    if (x = m.charCodeAt(d), x === 0) {
      A += "ÔøΩ";
      continue
    }
    if (x >= 1 && x <= 31 || x === 127 || d === 0 && x >= 48 && x <= 57 || d === 1 && x >= 48 && x <= 57 && z === 45) {
      A += "\\" + x.toString(16) + " ";
      continue
    }
    if (x >= 128 || x === 45 || x === 95 || x >= 48 && x <= 57 || x >= 65 && x <= 90 || x >= 97 && x <= 122) {
      A += m.charAt(d);
      continue
    }
    A += "\\" + m.charAt(d)
  }
  return A
}
const bl = "data-value",
  Na = zy({
    component: "command",
    parts: ["root", "list", "input", "separator", "loading", "empty", "group", "group-items", "group-heading", "item", "viewport", "input-label"]
  }),
  kc = Na.selector("group"),
  xm = Na.selector("group-items"),
  g0 = Na.selector("group-heading"),
  Ry = Na.selector("item"),
  bm = `${Na.selector("item")}:not([aria-disabled="true"])`,
  Ml = new Ng("Command.Root"),
  Zz = new Ng("Command.List"),
  lh = new Ng("Command.Group"),
  _0 = {
    search: "",
    value: "",
    filtered: {
      count: 0,
      items: new Map,
      groups: new Set
    }
  };
var Bc, Oc, yh, xh, bh, wh, Th, Sh, Vr, Fy, Ep, Um, Lp, zp, Dp, js, By, Oy, Zm, Ju, Gm, Hm, Ny, Qu, Wm, $m, jy, eh, th, Ph;
const Zg = class Zg {
  constructor(a) {
    Zr(this, Vr);
    Nr(this, "opts");
    Nr(this, "attachment");
    Zr(this, Bc, !1);
    Zr(this, Oc, !0);
    Nr(this, "sortAfterTick", !1);
    Nr(this, "sortAndFilterAfterTick", !1);
    Nr(this, "allItems", new Set);
    Nr(this, "allGroups", new Map);
    Nr(this, "allIds", new Map);
    Zr(this, yh, et(0));
    Zr(this, xh, et(null));
    Zr(this, bh, et(null));
    Zr(this, wh, et(null));
    Zr(this, Th, et(_0));
    Zr(this, Sh, et(zi(_0)));
    Zr(this, Ph, ut(() => ({
      id: this.opts.id.current,
      role: "application",
      [Na.root]: "",
      tabindex: -1,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = a, this.attachment = co(this.opts.ref);
    const d = {
      ...this._commandState,
      value: this.opts.value.current ?? ""
    };
    this._commandState = d, this.commandState = d, this.onkeydown = this.onkeydown.bind(this)
  }
  static create(a) {
    return Ml.set(new Zg(a))
  }
  get key() {
    return _(Qe(this, yh))
  }
  set key(a) {
    Y(Qe(this, yh), a, !0)
  }
  get viewportNode() {
    return _(Qe(this, xh))
  }
  set viewportNode(a) {
    Y(Qe(this, xh), a, !0)
  }
  get inputNode() {
    return _(Qe(this, bh))
  }
  set inputNode(a) {
    Y(Qe(this, bh), a, !0)
  }
  get labelNode() {
    return _(Qe(this, wh))
  }
  set labelNode(a) {
    Y(Qe(this, wh), a, !0)
  }
  get commandState() {
    return _(Qe(this, Th))
  }
  set commandState(a) {
    Y(Qe(this, Th), a)
  }
  get _commandState() {
    return _(Qe(this, Sh))
  }
  set _commandState(a) {
    Y(Qe(this, Sh), a, !0)
  }
  setState(a, d, x) {
    Object.is(this._commandState[a], d) || (this._commandState[a] = d, a === "search" ? (en(this, Vr, Dp).call(this), en(this, Vr, Lp).call(this)) : a === "value" && (x || en(this, Vr, By).call(this)), en(this, Vr, Ep).call(this))
  }
  setValue(a, d) {
    a !== this.opts.value.current && a === "" && Ac(() => {
      this.key++
    }), this.setState("value", a, d), this.opts.value.current = a
  }
  getValidItems() {
    const a = this.opts.ref.current;
    return a ? Array.from(a.querySelectorAll(bm)).filter(x => !!x) : []
  }
  getVisibleItems() {
    const a = this.opts.ref.current;
    return a ? Array.from(a.querySelectorAll(Ry)).filter(x => !!x) : []
  }
  get itemsGrid() {
    var s, F, q, J;
    if (!this.isGrid) return [];
    const a = this.opts.columns.current ?? 1,
      d = this.getVisibleItems(),
      x = [
        []
      ];
    let A = (s = d[0]) == null ? void 0 : s.getAttribute("data-group"),
      z = 0,
      b = 0;
    for (let te = 0; te < d.length; te++) {
      const ae = d[te],
        fe = ae == null ? void 0 : ae.getAttribute("data-group");
      A !== fe ? (A = fe, z = 1, b++, x.push([{
        index: te,
        firstRowOfGroup: !0,
        ref: ae
      }])) : (z++, z > a && (b++, z = 1, x.push([])), (J = x[b]) == null || J.push({
        index: te,
        firstRowOfGroup: ((q = (F = x[b]) == null ? void 0 : F[0]) == null ? void 0 : q.firstRowOfGroup) ?? te === 0,
        ref: ae
      }))
    }
    return x
  }
  updateSelectedToIndex(a) {
    const d = this.getValidItems()[a];
    d && this.setValue(d.getAttribute(bl) ?? "")
  }
  updateSelectedByItem(a) {
    const d = en(this, Vr, js).call(this),
      x = this.getValidItems(),
      A = x.findIndex(b => b === d);
    let z = x[A + a];
    this.opts.loop.current && (z = A + a < 0 ? x[x.length - 1] : A + a === x.length ? x[0] : x[A + a]), z && this.setValue(z.getAttribute(bl) ?? "")
  }
  updateSelectedByGroup(a) {
    const d = en(this, Vr, js).call(this);
    let x = d == null ? void 0 : d.closest(kc),
      A;
    for (; x && !A;) x = a > 0 ? Vz(x, kc) : Uz(x, kc), A = x == null ? void 0 : x.querySelector(bm);
    A ? this.setValue(A.getAttribute(bl) ?? "") : this.updateSelectedByItem(a)
  }
  registerValue(a, d) {
    var x;
    return a && a === ((x = this.allIds.get(a)) == null ? void 0 : x.value) || this.allIds.set(a, {
      value: a,
      keywords: d
    }), this._commandState.filtered.items.set(a, en(this, Vr, Um).call(this, a, d)), this.sortAfterTick || (this.sortAfterTick = !0, Ac(() => {
      en(this, Vr, Lp).call(this), this.sortAfterTick = !1
    })), () => {
      this.allIds.delete(a)
    }
  }
  registerItem(a, d) {
    return this.allItems.add(a), d && (this.allGroups.has(d) ? this.allGroups.get(d).add(a) : this.allGroups.set(d, new Set([a]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, Ac(() => {
      en(this, Vr, Dp).call(this), en(this, Vr, Lp).call(this), this.sortAndFilterAfterTick = !1
    })), en(this, Vr, Ep).call(this), () => {
      const x = en(this, Vr, js).call(this);
      this.allItems.delete(a), this.commandState.filtered.items.delete(a), en(this, Vr, Dp).call(this), (x == null ? void 0 : x.getAttribute("id")) === a && en(this, Vr, zp).call(this), en(this, Vr, Ep).call(this)
    }
  }
  registerGroup(a) {
    return this.allGroups.has(a) || this.allGroups.set(a, new Set), () => {
      this.allIds.delete(a), this.allGroups.delete(a)
    }
  }
  get isGrid() {
    return this.opts.columns.current !== null
  }
  onkeydown(a) {
    const d = this.opts.vimBindings.current && a.ctrlKey;
    switch (a.key) {
      case Rz:
      case Fz: {
        d && (this.isGrid ? en(this, Vr, Gm).call(this, a) : en(this, Vr, Ju).call(this, a));
        break
      }
      case Nz: {
        d && this.isGrid && en(this, Vr, Ju).call(this, a);
        break
      }
      case Iz:
        this.isGrid ? en(this, Vr, Gm).call(this, a) : en(this, Vr, Ju).call(this, a);
        break;
      case Az:
        if (!this.isGrid) break;
        en(this, Vr, Ju).call(this, a);
        break;
      case Dz:
      case Bz: {
        d && (this.isGrid ? en(this, Vr, $m).call(this, a) : en(this, Vr, th).call(this, a));
        break
      }
      case Oz: {
        d && this.isGrid && en(this, Vr, th).call(this, a);
        break
      }
      case kz:
        this.isGrid ? en(this, Vr, $m).call(this, a) : en(this, Vr, th).call(this, a);
        break;
      case Mz:
        if (!this.isGrid) break;
        en(this, Vr, th).call(this, a);
        break;
      case zz:
        a.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case Ez:
        a.preventDefault(), en(this, Vr, Zm).call(this);
        break;
      case Lz:
        if (!a.isComposing && a.keyCode !== 229) {
          a.preventDefault();
          const x = en(this, Vr, js).call(this);
          x && (x == null || x.click())
        }
    }
  }
  get props() {
    return _(Qe(this, Ph))
  }
  set props(a) {
    Y(Qe(this, Ph), a)
  }
};
Bc = new WeakMap, Oc = new WeakMap, yh = new WeakMap, xh = new WeakMap, bh = new WeakMap, wh = new WeakMap, Th = new WeakMap, Sh = new WeakMap, Vr = new WeakSet, Fy = function() {
  return s2(this._commandState)
}, Ep = function() {
  Qe(this, Bc) || (oa(this, Bc, !0), Ac(() => {
    var x, A;
    oa(this, Bc, !1);
    const a = en(this, Vr, Fy).call(this);
    !Object.is(this.commandState, a) && (this.commandState = a, (A = (x = this.opts.onStateChange) == null ? void 0 : x.current) == null || A.call(x, a))
  }))
}, Um = function(a, d) {
  const x = this.opts.filter.current ?? Uy;
  return a ? x(a, this._commandState.search, d) : 0
}, Lp = function() {
  var b;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    (!this._commandState.value || !Qe(this, Oc)) && en(this, Vr, zp).call(this);
    return
  }
  const a = this._commandState.filtered.items,
    d = [];
  for (const s of this._commandState.filtered.groups) {
    const F = this.allGroups.get(s);
    let q = 0;
    if (!F) {
      d.push([s, q]);
      continue
    }
    for (const J of F) {
      const te = a.get(J);
      q = Math.max(te ?? 0, q)
    }
    d.push([s, q])
  }
  const x = this.viewportNode,
    A = this.getValidItems().sort((s, F) => {
      const q = s.getAttribute("data-value"),
        J = F.getAttribute("data-value"),
        te = a.get(q) ?? 0;
      return (a.get(J) ?? 0) - te
    });
  for (const s of A) {
    const F = s.closest(xm);
    if (F) {
      const q = s.parentElement === F ? s : s.closest(`${xm} > *`);
      q && F.appendChild(q)
    } else {
      const q = s.parentElement === x ? s : s.closest(`${xm} > *`);
      q && (x == null || x.appendChild(q))
    }
  }
  const z = d.sort((s, F) => F[1] - s[1]);
  for (const s of z) {
    const F = x == null ? void 0 : x.querySelector(`${kc}[${bl}="${Dy(s[0])}"]`);
    (b = F == null ? void 0 : F.parentElement) == null || b.appendChild(F)
  }
  en(this, Vr, zp).call(this)
}, zp = function() {
  Ac(() => {
    const a = this.getValidItems().find(A => A.getAttribute("aria-disabled") !== "true"),
      d = a == null ? void 0 : a.getAttribute(bl),
      x = Qe(this, Oc) && this.opts.disableInitialScroll.current;
    this.setValue(d ?? "", x), oa(this, Oc, !1)
  })
}, Dp = function() {
  var d, x;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    this._commandState.filtered.count = this.allItems.size;
    return
  }
  this._commandState.filtered.groups = new Set;
  let a = 0;
  for (const A of this.allItems) {
    const z = ((d = this.allIds.get(A)) == null ? void 0 : d.value) ?? "",
      b = ((x = this.allIds.get(A)) == null ? void 0 : x.keywords) ?? [],
      s = en(this, Vr, Um).call(this, z, b);
    this._commandState.filtered.items.set(A, s), s > 0 && a++
  }
  for (const [A, z] of this.allGroups)
    for (const b of z) {
      const s = this._commandState.filtered.items.get(b);
      if (s && s > 0) {
        this._commandState.filtered.groups.add(A);
        break
      }
    }
  this._commandState.filtered.count = a
}, js = function() {
  const a = this.opts.ref.current;
  if (!a) return;
  const d = a.querySelector(`${bm}[data-selected]`);
  if (d) return d
}, By = function() {
  Ac(() => {
    var x, A, z, b, s;
    const a = en(this, Vr, js).call(this);
    if (!a) return;
    const d = (x = a.parentElement) == null ? void 0 : x.parentElement;
    if (d) {
      if (this.isGrid) {
        const F = en(this, Vr, Oy).call(this, a);
        if (a.scrollIntoView({
            block: "nearest"
          }), F) {
          const q = (A = a == null ? void 0 : a.closest(kc)) == null ? void 0 : A.querySelector(g0);
          q == null || q.scrollIntoView({
            block: "nearest"
          });
          return
        }
      } else {
        const F = jz(d);
        if (F && ((z = F.dataset) == null ? void 0 : z.value) === ((b = a.dataset) == null ? void 0 : b.value)) {
          const q = (s = a == null ? void 0 : a.closest(kc)) == null ? void 0 : s.querySelector(g0);
          q == null || q.scrollIntoView({
            block: "nearest"
          });
          return
        }
      }
      a.scrollIntoView({
        block: "nearest"
      })
    }
  })
}, Oy = function(a) {
  const d = this.itemsGrid;
  if (d.length === 0) return !1;
  for (let x = 0; x < d.length; x++) {
    const A = d[x];
    if (A !== void 0)
      for (let z = 0; z < A.length; z++) {
        const b = A[z];
        if (!(b === void 0 || b.ref !== a)) return b.firstRowOfGroup
      }
  }
  return !1
}, Zm = function() {
  return this.updateSelectedToIndex(this.getValidItems().length - 1)
}, Ju = function(a) {
  a.preventDefault(), a.metaKey ? en(this, Vr, Zm).call(this) : a.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1)
}, Gm = function(a) {
  this.opts.columns.current !== null && (a.preventDefault(), a.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(en(this, Vr, Ny).call(this, a)))
}, Hm = function(a, d) {
  if (d.length === 0) return null;
  for (let x = 0; x < d.length; x++) {
    const A = d[x];
    if (A !== void 0)
      for (let z = 0; z < A.length; z++) {
        const b = A[z];
        if (!(b === void 0 || b.ref !== a)) return {
          columnIndex: z,
          rowIndex: x
        }
      }
  }
  return null
}, Ny = function(a) {
  const d = this.itemsGrid,
    x = en(this, Vr, js).call(this);
  if (!x) return 0;
  const A = en(this, Vr, Hm).call(this, x, d);
  if (!A) return 0;
  let z = null;
  const b = a.altKey ? 1 : 0;
  if (a.altKey && A.rowIndex === d.length - 2 && !this.opts.loop.current) z = en(this, Vr, Qu).call(this, {
    start: d.length - 1,
    end: d.length,
    expectedColumnIndex: A.columnIndex,
    grid: d
  });
  else if (A.rowIndex === d.length - 1) {
    if (!this.opts.loop.current) return 0;
    z = en(this, Vr, Qu).call(this, {
      start: 0 + b,
      end: A.rowIndex,
      expectedColumnIndex: A.columnIndex,
      grid: d
    })
  } else z = en(this, Vr, Qu).call(this, {
    start: A.rowIndex + 1 + b,
    end: d.length,
    expectedColumnIndex: A.columnIndex,
    grid: d
  }), z === null && this.opts.loop.current && (z = en(this, Vr, Qu).call(this, {
    start: 0,
    end: A.rowIndex,
    expectedColumnIndex: A.columnIndex,
    grid: d
  }));
  return en(this, Vr, Wm).call(this, x, z)
}, Qu = function({
  start: a,
  end: d,
  grid: x,
  expectedColumnIndex: A
}) {
  var b;
  let z = null;
  for (let s = a; s < d; s++) {
    const F = x[s];
    if (z = ((b = F[A]) == null ? void 0 : b.ref) ?? null, z !== null && Tp(z)) {
      z = null;
      continue
    }
    if (z === null)
      for (let q = F.length - 1; q >= 0; q--) {
        const J = F[F.length - 1];
        if (!(J === void 0 || Tp(J.ref))) {
          z = J.ref;
          break
        }
      }
    break
  }
  return z
}, Wm = function(a, d) {
  if (d === null) return 0;
  const x = this.getValidItems(),
    A = x.findIndex(b => b === a);
  return x.findIndex(b => b === d) - A
}, $m = function(a) {
  this.opts.columns.current !== null && (a.preventDefault(), a.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(en(this, Vr, jy).call(this, a)))
}, jy = function(a) {
  const d = this.itemsGrid,
    x = en(this, Vr, js).call(this);
  if (x === void 0) return 0;
  const A = en(this, Vr, Hm).call(this, x, d);
  if (A === null) return 0;
  let z = null;
  const b = a.altKey ? 1 : 0;
  if (a.altKey && A.rowIndex === 1 && this.opts.loop.current === !1) z = en(this, Vr, eh).call(this, {
    start: 0,
    end: 0,
    expectedColumnIndex: A.columnIndex,
    grid: d
  });
  else if (A.rowIndex === 0) {
    if (this.opts.loop.current === !1) return 0;
    z = en(this, Vr, eh).call(this, {
      start: d.length - 1 - b,
      end: A.rowIndex + 1,
      expectedColumnIndex: A.columnIndex,
      grid: d
    })
  } else z = en(this, Vr, eh).call(this, {
    start: A.rowIndex - 1 - b,
    end: 0,
    expectedColumnIndex: A.columnIndex,
    grid: d
  }), z === null && this.opts.loop.current && (z = en(this, Vr, eh).call(this, {
    start: d.length - 1,
    end: A.rowIndex + 1,
    expectedColumnIndex: A.columnIndex,
    grid: d
  }));
  return en(this, Vr, Wm).call(this, x, z)
}, eh = function({
  start: a,
  end: d,
  grid: x,
  expectedColumnIndex: A
}) {
  var b;
  let z = null;
  for (let s = a; s >= d; s--) {
    const F = x[s];
    if (F !== void 0) {
      if (z = ((b = F[A]) == null ? void 0 : b.ref) ?? null, z !== null && Tp(z)) {
        z = null;
        continue
      }
      if (z === null)
        for (let q = F.length - 1; q >= 0; q--) {
          const J = F[F.length - 1];
          if (!(J === void 0 || Tp(J.ref))) {
            z = J.ref;
            break
          }
        }
      break
    }
  }
  return z
}, th = function(a) {
  a.preventDefault(), a.metaKey ? this.updateSelectedToIndex(0) : a.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1)
}, Ph = new WeakMap;
let Vm = Zg;

function Tp(m) {
  return m.getAttribute("aria-disabled") === "true"
}
var Ch, Ih, Mh;
const Gg = class Gg {
  constructor(a, d) {
    Nr(this, "opts");
    Nr(this, "root");
    Nr(this, "attachment");
    Zr(this, Ch, ut(() => this.root._commandState.filtered.count === 0 && Qe(this, Ih) === !1 || this.opts.forceMount.current));
    Zr(this, Ih, !0);
    Zr(this, Mh, ut(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [Na.empty]: "",
      ...this.attachment
    })));
    this.opts = a, this.root = d, this.attachment = co(this.opts.ref), ug(() => {
      oa(this, Ih, !1)
    })
  }
  static create(a) {
    return new Gg(a, Ml.get())
  }
  get shouldRender() {
    return _(Qe(this, Ch))
  }
  set shouldRender(a) {
    Y(Qe(this, Ch), a)
  }
  get props() {
    return _(Qe(this, Mh))
  }
  set props(a) {
    Y(Qe(this, Mh), a)
  }
};
Ch = new WeakMap, Ih = new WeakMap, Mh = new WeakMap;
let Xm = Gg;
var Ah, kh, Eh, Lh;
const Hg = class Hg {
  constructor(a, d) {
    Nr(this, "opts");
    Nr(this, "root");
    Nr(this, "attachment");
    Zr(this, Ah, ut(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue)));
    Zr(this, kh, et(null));
    Zr(this, Eh, et(""));
    Zr(this, Lh, ut(() => ({
      id: this.opts.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : !0,
      "data-value": this.trueValue,
      [Na.group]: "",
      ...this.attachment
    })));
    this.opts = a, this.root = d, this.attachment = co(this.opts.ref), this.trueValue = a.value.current ?? a.id.current, Pl(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), tn(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)))
  }
  static create(a) {
    return lh.set(new Hg(a, Ml.get()))
  }
  get shouldRender() {
    return _(Qe(this, Ah))
  }
  set shouldRender(a) {
    Y(Qe(this, Ah), a)
  }
  get headingNode() {
    return _(Qe(this, kh))
  }
  set headingNode(a) {
    Y(Qe(this, kh), a, !0)
  }
  get trueValue() {
    return _(Qe(this, Eh))
  }
  set trueValue(a) {
    Y(Qe(this, Eh), a, !0)
  }
  get props() {
    return _(Qe(this, Lh))
  }
  set props(a) {
    Y(Qe(this, Lh), a)
  }
};
Ah = new WeakMap, kh = new WeakMap, Eh = new WeakMap, Lh = new WeakMap;
let Ym = Hg;
var zh;
const Wg = class Wg {
  constructor(a, d) {
    Nr(this, "opts");
    Nr(this, "group");
    Nr(this, "attachment");
    Zr(this, zh, ut(() => ({
      id: this.opts.id.current,
      [Na["group-heading"]]: "",
      ...this.attachment
    })));
    this.opts = a, this.group = d, this.attachment = co(this.opts.ref, x => this.group.headingNode = x)
  }
  static create(a) {
    return new Wg(a, lh.get())
  }
  get props() {
    return _(Qe(this, zh))
  }
  set props(a) {
    Y(Qe(this, zh), a)
  }
};
zh = new WeakMap;
let Km = Wg;
var Dh;
const $g = class $g {
  constructor(a, d) {
    Nr(this, "opts");
    Nr(this, "group");
    Nr(this, "attachment");
    Zr(this, Dh, ut(() => {
      var a;
      return {
        id: this.opts.id.current,
        role: "group",
        [Na["group-items"]]: "",
        "aria-labelledby": ((a = this.group.headingNode) == null ? void 0 : a.id) ?? void 0,
        ...this.attachment
      }
    }));
    this.opts = a, this.group = d, this.attachment = co(this.opts.ref)
  }
  static create(a) {
    return new $g(a, lh.get())
  }
  get props() {
    return _(Qe(this, Dh))
  }
  set props(a) {
    Y(Qe(this, Dh), a)
  }
};
Dh = new WeakMap;
let Jm = $g;
var Zp, Rh;
const Xg = class Xg {
  constructor(a, d) {
    Nr(this, "opts");
    Nr(this, "root");
    Nr(this, "attachment");
    Zr(this, Zp, ut(() => {
      var d;
      const a = (d = this.root.viewportNode) == null ? void 0 : d.querySelector(`${Ry}[${bl}="${Dy(this.root.opts.value.current)}"]`);
      if (a != null) return a.getAttribute("id") ?? void 0
    }));
    Zr(this, Rh, ut(() => {
      var a, d;
      return {
        id: this.opts.id.current,
        type: "text",
        [Na.input]: "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": qm(!0),
        "aria-controls": ((a = this.root.viewportNode) == null ? void 0 : a.id) ?? void 0,
        "aria-labelledby": ((d = this.root.labelNode) == null ? void 0 : d.id) ?? void 0,
        "aria-activedescendant": _(Qe(this, Zp)),
        ...this.attachment
      }
    }));
    this.opts = a, this.root = d, this.attachment = co(this.opts.ref, x => this.root.inputNode = x), Pl(() => this.opts.ref.current, () => {
      const x = this.opts.ref.current;
      x && this.opts.autofocus.current && fz(10, () => x.focus())
    }), Pl(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current)
    })
  }
  static create(a) {
    return new Xg(a, Ml.get())
  }
  get props() {
    return _(Qe(this, Rh))
  }
  set props(a) {
    Y(Qe(this, Rh), a)
  }
};
Zp = new WeakMap, Rh = new WeakMap;
let Qm = Xg;
var Vs, Gp, Fh, Bh, Oh, Cl, qy, tg, Nh;
const Yg = class Yg {
  constructor(a, d) {
    Zr(this, Cl);
    Nr(this, "opts");
    Nr(this, "root");
    Nr(this, "attachment");
    Zr(this, Vs, null);
    Zr(this, Gp, ut(() => {
      var a;
      return this.opts.forceMount.current || ((a = Qe(this, Vs)) == null ? void 0 : a.opts.forceMount.current) === !0
    }));
    Zr(this, Fh, ut(() => {
      if (this.opts.ref.current, _(Qe(this, Gp)) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search) return !0;
      const a = this.root.commandState.filtered.items.get(this.trueValue);
      return a === void 0 ? !1 : a > 0
    }));
    Zr(this, Bh, ut(() => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
    Zr(this, Oh, et(""));
    Zr(this, Nh, ut(() => {
      var a;
      return {
        id: this.opts.id.current,
        "aria-disabled": qm(this.opts.disabled.current),
        "aria-selected": qm(this.isSelected),
        "data-disabled": m0(this.opts.disabled.current),
        "data-selected": m0(this.isSelected),
        "data-value": this.trueValue,
        "data-group": (a = Qe(this, Vs)) == null ? void 0 : a.trueValue,
        [Na.item]: "",
        role: "option",
        onpointermove: this.onpointermove,
        onclick: this.onclick,
        ...this.attachment
      }
    }));
    this.opts = a, this.root = d, oa(this, Vs, lh.getOr(null)), this.trueValue = a.value.current, this.attachment = co(this.opts.ref), Pl([() => this.trueValue, () => {
      var x;
      return (x = Qe(this, Vs)) == null ? void 0 : x.trueValue
    }, () => this.opts.forceMount.current], () => {
      var x;
      if (!(this.opts.forceMount.current || !this.trueValue)) return this.root.registerItem(this.trueValue, (x = Qe(this, Vs)) == null ? void 0 : x.trueValue)
    }), Pl([() => this.opts.value.current, () => this.opts.ref.current], () => {
      var x, A;
      this.opts.value.current ? this.trueValue = this.opts.value.current : (x = this.opts.ref.current) != null && x.textContent && (this.trueValue = this.opts.ref.current.textContent.trim()), this.trueValue && (this.root.registerValue(this.trueValue, a.keywords.current.map(z => z.trim())), (A = this.opts.ref.current) == null || A.setAttribute(bl, this.trueValue))
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this)
  }
  static create(a) {
    const d = lh.getOr(null);
    return new Yg({
      ...a,
      group: d
    }, Ml.get())
  }
  get shouldRender() {
    return _(Qe(this, Fh))
  }
  set shouldRender(a) {
    Y(Qe(this, Fh), a)
  }
  get isSelected() {
    return _(Qe(this, Bh))
  }
  set isSelected(a) {
    Y(Qe(this, Bh), a)
  }
  get trueValue() {
    return _(Qe(this, Oh))
  }
  set trueValue(a) {
    Y(Qe(this, Oh), a, !0)
  }
  onpointermove(a) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || en(this, Cl, tg).call(this)
  }
  onclick(a) {
    this.opts.disabled.current || en(this, Cl, qy).call(this)
  }
  get props() {
    return _(Qe(this, Nh))
  }
  set props(a) {
    Y(Qe(this, Nh), a)
  }
};
Vs = new WeakMap, Gp = new WeakMap, Fh = new WeakMap, Bh = new WeakMap, Oh = new WeakMap, Cl = new WeakSet, qy = function() {
  var a;
  this.opts.disabled.current || (en(this, Cl, tg).call(this), (a = this.opts.onSelect) == null || a.current())
}, tg = function() {
  this.opts.disabled.current || this.root.setValue(this.trueValue, !0)
}, Nh = new WeakMap;
let eg = Yg;
var jh;
const Kg = class Kg {
  constructor(a, d) {
    Nr(this, "opts");
    Nr(this, "root");
    Nr(this, "attachment");
    Zr(this, jh, ut(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-label": this.opts.ariaLabel.current,
      [Na.list]: "",
      ...this.attachment
    })));
    this.opts = a, this.root = d, this.attachment = co(this.opts.ref)
  }
  static create(a) {
    return Zz.set(new Kg(a, Ml.get()))
  }
  get props() {
    return _(Qe(this, jh))
  }
  set props(a) {
    Y(Qe(this, jh), a)
  }
};
jh = new WeakMap;
let rg = Kg;
var qh;
const Jg = class Jg {
  constructor(a, d) {
    Nr(this, "opts");
    Nr(this, "root");
    Nr(this, "attachment");
    Zr(this, qh, ut(() => {
      var a;
      return {
        id: this.opts.id.current,
        [Na["input-label"]]: "",
        for: (a = this.opts.for) == null ? void 0 : a.current,
        style: Ay,
        ...this.attachment
      }
    }));
    this.opts = a, this.root = d, this.attachment = co(this.opts.ref, x => this.root.labelNode = x)
  }
  static create(a) {
    return new Jg(a, Ml.get())
  }
  get props() {
    return _(Qe(this, qh))
  }
  set props(a) {
    Y(Qe(this, qh), a)
  }
};
qh = new WeakMap;
let ng = Jg;
var Gz = me("<label><!></label>");

function Hz(m, a) {
  const d = Ao();
  Wr(a, !0);
  let x = At(a, "id", 19, () => uo(d)),
    A = At(a, "ref", 15, null),
    z = fr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
  const b = ng.create({
      id: pn(() => x()),
      ref: pn(() => A(), J => A(J))
    }),
    s = ut(() => Qa(z, b.props));
  var F = Gz();
  _r(F, () => ({
    ..._(s)
  }));
  var q = I(F);
  bi(q, () => a.children ?? wa), C(F), Z(m, F), $r()
}
var Wz = me("<!> <!>", 1),
  $z = me("<div><!> <!></div>");

function Xz(m, a) {
  const d = Ao();
  Wr(a, !0);
  const x = Ge => {
    Hz(Ge, {
      children: (Xe, vt) => {
        wn();
        var Ut = qi();
        Ue(() => ce(Ut, ae())), Z(Xe, Ut)
      },
      $$slots: {
        default: !0
      }
    })
  };
  let A = At(a, "id", 19, () => uo(d)),
    z = At(a, "ref", 15, null),
    b = At(a, "value", 15, ""),
    s = At(a, "onValueChange", 3, sh),
    F = At(a, "onStateChange", 3, sh),
    q = At(a, "loop", 3, !1),
    J = At(a, "shouldFilter", 3, !0),
    te = At(a, "filter", 3, Uy),
    ae = At(a, "label", 3, ""),
    fe = At(a, "vimBindings", 3, !0),
    ie = At(a, "disablePointerSelection", 3, !1),
    $ = At(a, "disableInitialScroll", 3, !1),
    Se = At(a, "columns", 3, null),
    Me = fr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "onValueChange", "onStateChange", "loop", "shouldFilter", "filter", "label", "vimBindings", "disablePointerSelection", "disableInitialScroll", "columns", "children", "child"]);
  const Pe = Vm.create({
      id: pn(() => A()),
      ref: pn(() => z(), Ge => z(Ge)),
      filter: pn(() => te()),
      shouldFilter: pn(() => J()),
      loop: pn(() => q()),
      value: pn(() => b(), Ge => {
        b() !== Ge && (b(Ge), s()(Ge))
      }),
      vimBindings: pn(() => fe()),
      disablePointerSelection: pn(() => ie()),
      disableInitialScroll: pn(() => $()),
      onStateChange: pn(() => F()),
      columns: pn(() => Se())
    }),
    Ie = Ge => Pe.updateSelectedToIndex(Ge),
    Ce = Ge => Pe.updateSelectedByGroup(Ge),
    je = Ge => Pe.updateSelectedByItem(Ge),
    Ye = () => Pe.getValidItems(),
    qe = ut(() => Qa(Me, Pe.props));
  var Be = {
      updateSelectedToIndex: Ie,
      updateSelectedByGroup: Ce,
      updateSelectedByItem: je,
      getValidItems: Ye
    },
    He = or(),
    we = xt(He);
  {
    var it = Ge => {
        var Xe = Wz(),
          vt = xt(Xe);
        x(vt);
        var Ut = O(vt, 2);
        bi(Ut, () => a.child, () => ({
          props: _(qe)
        })), Z(Ge, Xe)
      },
      mt = Ge => {
        var Xe = $z();
        _r(Xe, () => ({
          ..._(qe)
        }));
        var vt = I(Xe);
        x(vt);
        var Ut = O(vt, 2);
        bi(Ut, () => a.children ?? wa), C(Xe), Z(Ge, Xe)
      };
    Ee(we, Ge => {
      a.child ? Ge(it) : Ge(mt, !1)
    })
  }
  return Z(m, He), $r(Be)
}
var Yz = me("<div><!></div>");

function Kz(m, a) {
  const d = Ao();
  Wr(a, !0);
  let x = At(a, "id", 19, () => uo(d)),
    A = At(a, "ref", 15, null),
    z = At(a, "forceMount", 3, !1),
    b = fr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child", "forceMount"]);
  const s = Xm.create({
      id: pn(() => x()),
      ref: pn(() => A(), ae => A(ae)),
      forceMount: pn(() => z())
    }),
    F = ut(() => Qa(s.props, b));
  var q = or(),
    J = xt(q);
  {
    var te = ae => {
      var fe = or(),
        ie = xt(fe);
      {
        var $ = Me => {
            var Pe = or(),
              Ie = xt(Pe);
            bi(Ie, () => a.child, () => ({
              props: _(F)
            })), Z(Me, Pe)
          },
          Se = Me => {
            var Pe = Yz();
            _r(Pe, () => ({
              ..._(F)
            }));
            var Ie = I(Pe);
            bi(Ie, () => a.children ?? wa), C(Pe), Z(Me, Pe)
          };
        Ee(ie, Me => {
          a.child ? Me($) : Me(Se, !1)
        })
      }
      Z(ae, fe)
    };
    Ee(J, ae => {
      s.shouldRender && ae(te)
    })
  }
  Z(m, q), $r()
}
var Jz = me("<div><!></div>");

function Qz(m, a) {
  const d = Ao();
  Wr(a, !0);
  let x = At(a, "id", 19, () => uo(d)),
    A = At(a, "ref", 15, null),
    z = At(a, "value", 3, ""),
    b = At(a, "forceMount", 3, !1),
    s = fr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "forceMount", "children", "child"]);
  const F = Ym.create({
      id: pn(() => x()),
      ref: pn(() => A(), ie => A(ie)),
      forceMount: pn(() => b()),
      value: pn(() => z())
    }),
    q = ut(() => Qa(s, F.props));
  var J = or(),
    te = xt(J);
  {
    var ae = ie => {
        var $ = or(),
          Se = xt($);
        bi(Se, () => a.child, () => ({
          props: _(q)
        })), Z(ie, $)
      },
      fe = ie => {
        var $ = Jz();
        _r($, () => ({
          ..._(q)
        }));
        var Se = I($);
        bi(Se, () => a.children ?? wa), C($), Z(ie, $)
      };
    Ee(te, ie => {
      a.child ? ie(ae) : ie(fe, !1)
    })
  }
  Z(m, J), $r()
}
var eD = me("<div><!></div>");

function tD(m, a) {
  const d = Ao();
  Wr(a, !0);
  let x = At(a, "id", 19, () => uo(d)),
    A = At(a, "ref", 15, null),
    z = fr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const b = Km.create({
      id: pn(() => x()),
      ref: pn(() => A(), ae => A(ae))
    }),
    s = ut(() => Qa(z, b.props));
  var F = or(),
    q = xt(F);
  {
    var J = ae => {
        var fe = or(),
          ie = xt(fe);
        bi(ie, () => a.child, () => ({
          props: _(s)
        })), Z(ae, fe)
      },
      te = ae => {
        var fe = eD();
        _r(fe, () => ({
          ..._(s)
        }));
        var ie = I(fe);
        bi(ie, () => a.children ?? wa), C(fe), Z(ae, fe)
      };
    Ee(q, ae => {
      a.child ? ae(J) : ae(te, !1)
    })
  }
  Z(m, F), $r()
}
var rD = me("<div><!></div>"),
  nD = me('<div style="display: contents;"><!></div>');

function iD(m, a) {
  const d = Ao();
  Wr(a, !0);
  let x = At(a, "id", 19, () => uo(d)),
    A = At(a, "ref", 15, null),
    z = fr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const b = Jm.create({
      id: pn(() => x()),
      ref: pn(() => A(), ae => A(ae))
    }),
    s = ut(() => Qa(z, b.props));
  var F = nD(),
    q = I(F);
  {
    var J = ae => {
        var fe = or(),
          ie = xt(fe);
        bi(ie, () => a.child, () => ({
          props: _(s)
        })), Z(ae, fe)
      },
      te = ae => {
        var fe = rD();
        _r(fe, () => ({
          ..._(s)
        }));
        var ie = I(fe);
        bi(ie, () => a.children ?? wa), C(fe), Z(ae, fe)
      };
    Ee(q, ae => {
      a.child ? ae(J) : ae(te, !1)
    })
  }
  C(F), Z(m, F), $r()
}
var aD = me("<input/>");

function oD(m, a) {
  const d = Ao();
  Wr(a, !0);
  let x = At(a, "value", 15, ""),
    A = At(a, "autofocus", 3, !1),
    z = At(a, "id", 19, () => uo(d)),
    b = At(a, "ref", 15, null),
    s = fr(a, ["$$slots", "$$events", "$$legacy", "value", "autofocus", "id", "ref", "child"]);
  const F = Qm.create({
      id: pn(() => z()),
      ref: pn(() => b(), ie => b(ie)),
      value: pn(() => x(), ie => {
        x(ie)
      }),
      autofocus: pn(() => A() ?? !1)
    }),
    q = ut(() => Qa(s, F.props));
  var J = or(),
    te = xt(J);
  {
    var ae = ie => {
        var $ = or(),
          Se = xt($);
        bi(Se, () => a.child, () => ({
          props: _(q)
        })), Z(ie, $)
      },
      fe = ie => {
        var $ = aD();
        _r($, () => ({
          ..._(q)
        }), void 0, void 0, void 0, void 0, !0), Xh($, x), Z(ie, $)
      };
    Ee(te, ie => {
      a.child ? ie(ae) : ie(fe, !1)
    })
  }
  Z(m, J), $r()
}
var sD = me("<div><!></div>"),
  lD = me('<div style="display: contents;" data-item-wrapper=""><!></div>');

function cD(m, a) {
  const d = Ao();
  Wr(a, !0);
  let x = At(a, "id", 19, () => uo(d)),
    A = At(a, "ref", 15, null),
    z = At(a, "value", 3, ""),
    b = At(a, "disabled", 3, !1),
    s = At(a, "onSelect", 3, sh),
    F = At(a, "forceMount", 3, !1),
    q = At(a, "keywords", 19, () => []),
    J = fr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "disabled", "children", "child", "onSelect", "forceMount", "keywords"]);
  const te = eg.create({
      id: pn(() => x()),
      ref: pn(() => A(), $ => A($)),
      value: pn(() => z()),
      disabled: pn(() => b()),
      onSelect: pn(() => s()),
      forceMount: pn(() => F()),
      keywords: pn(() => q())
    }),
    ae = ut(() => Qa(J, te.props));
  var fe = or(),
    ie = xt(fe);
  ih(ie, () => te.root.key, $ => {
    var Se = lD(),
      Me = I(Se);
    {
      var Pe = Ie => {
        var Ce = or(),
          je = xt(Ce);
        {
          var Ye = Be => {
              var He = or(),
                we = xt(He);
              bi(we, () => a.child, () => ({
                props: _(ae)
              })), Z(Be, He)
            },
            qe = Be => {
              var He = sD();
              _r(He, () => ({
                ..._(ae)
              }));
              var we = I(He);
              bi(we, () => a.children ?? wa), C(He), Z(Be, He)
            };
          Ee(je, Be => {
            a.child ? Be(Ye) : Be(qe, !1)
          })
        }
        Z(Ie, Ce)
      };
      Ee(Me, Ie => {
        te.shouldRender && Ie(Pe)
      })
    }
    C(Se), Ue(() => cr(Se, "data-value", te.trueValue)), Z($, Se)
  }), Z(m, fe), $r()
}
var uD = me("<div><!></div>");

function hD(m, a) {
  const d = Ao();
  Wr(a, !0);
  let x = At(a, "id", 19, () => uo(d)),
    A = At(a, "ref", 15, null),
    z = fr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "aria-label"]);
  const b = rg.create({
      id: pn(() => x()),
      ref: pn(() => A(), J => A(J)),
      ariaLabel: pn(() => a["aria-label"] ?? "Suggestions...")
    }),
    s = ut(() => Qa(z, b.props));
  var F = or(),
    q = xt(F);
  ih(q, () => b.root._commandState.search === "", J => {
    var te = or(),
      ae = xt(te);
    {
      var fe = $ => {
          var Se = or(),
            Me = xt(Se);
          bi(Me, () => a.child, () => ({
            props: _(s)
          })), Z($, Se)
        },
        ie = $ => {
          var Se = uD();
          _r(Se, () => ({
            ..._(s)
          }));
          var Me = I(Se);
          bi(Me, () => a.children ?? wa), C(Se), Z($, Se)
        };
      Ee(ae, $ => {
        a.child ? $(fe) : $(ie, !1)
      })
    }
    Z(J, te)
  }), Z(m, F), $r()
}
const v0 = 1,
  dD = .9,
  pD = .8,
  fD = .17,
  wm = .1,
  Tm = .999,
  mD = .9999,
  gD = .99,
  _D = /[\\/_+.#"@[({&]/,
  vD = /[\\/_+.#"@[({&]/g,
  yD = /[\s-]/,
  Vy = /[\s-]/g;

function ig(m, a, d, x, A, z, b) {
  if (z === a.length) return A === m.length ? v0 : gD;
  const s = `${A},${z}`;
  if (b[s] !== void 0) return b[s];
  const F = x.charAt(z);
  let q = d.indexOf(F, A),
    J = 0,
    te, ae, fe, ie;
  for (; q >= 0;) te = ig(m, a, d, x, q + 1, z + 1, b), te > J && (q === A ? te *= v0 : _D.test(m.charAt(q - 1)) ? (te *= pD, fe = m.slice(A, q - 1).match(vD), fe && A > 0 && (te *= Tm ** fe.length)) : yD.test(m.charAt(q - 1)) ? (te *= dD, ie = m.slice(A, q - 1).match(Vy), ie && A > 0 && (te *= Tm ** ie.length)) : (te *= fD, A > 0 && (te *= Tm ** (q - A))), m.charAt(q) !== a.charAt(z) && (te *= mD)), (te < wm && d.charAt(q - 1) === x.charAt(z + 1) || x.charAt(z + 1) === x.charAt(z) && d.charAt(q - 1) !== x.charAt(z)) && (ae = ig(m, a, d, x, q + 1, z + 2, b), ae * wm > te && (te = ae * wm)), te > J && (J = te), q = d.indexOf(F, q + 1);
  return b[s] = J, J
}

function y0(m) {
  return m.toLowerCase().replace(Vy, " ")
}

function Uy(m, a, d) {
  return m = d && d.length > 0 ? `${`${m} ${d==null?void 0:d.join(" ")}`}` : m, ig(m, a, y0(m), y0(a), 0, 0, {})
}
const xD = 18,
  Zy = 40,
  bD = `${Zy}px`,
  wD = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");

function TD({
  containerRef: m,
  inputRef: a,
  pushPasswordManagerStrategy: d,
  isFocused: x,
  domContext: A
}) {
  let z = et(!1),
    b = et(!1),
    s = et(!1);

  function F() {
    const J = d.current;
    return J === "none" ? !1 : J === "increase-width" && _(z) && _(b)
  }

  function q() {
    const J = m.current,
      te = a.current;
    if (!J || !te || _(s) || d.current === "none") return;
    const ae = J,
      fe = ae.getBoundingClientRect().left + ae.offsetWidth,
      ie = ae.getBoundingClientRect().top + ae.offsetHeight / 2,
      $ = fe - xD,
      Se = ie;
    A.querySelectorAll(wD).length === 0 && A.getDocument().elementFromPoint($, Se) === J || (Y(z, !0), Y(s, !0))
  }
  return tn(() => {
    const J = m.current;
    if (!J || d.current === "none") return;

    function te() {
      const ie = Ly(J).innerWidth - J.getBoundingClientRect().right;
      Y(b, ie >= Zy)
    }
    te();
    const ae = setInterval(te, 1e3);
    return () => {
      clearInterval(ae)
    }
  }), tn(() => {
    const J = x.current || A.getActiveElement() === a.current;
    if (d.current === "none" || !J) return;
    const te = setTimeout(q, 0),
      ae = setTimeout(q, 2e3),
      fe = setTimeout(q, 5e3),
      ie = setTimeout(() => {
        Y(s, !0)
      }, 6e3);
    return () => {
      clearTimeout(te), clearTimeout(ae), clearTimeout(fe), clearTimeout(ie)
    }
  }), {
    get hasPwmBadge() {
      return _(z)
    },
    get willPushPwmBadge() {
      return F()
    },
    PWM_BADGE_SPACE_WIDTH: bD
  }
}
const Gy = zy({
    component: "pin-input",
    parts: ["root", "cell"]
  }),
  SD = ["Backspace", "Delete", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End", "Escape", "Enter", "Tab", "Shift", "Control", "Meta"];
var ao, Nc, _s, Ja, oo, jc, jo, vs, Us, qc, Hp, Vh, Uh, Wp, $p, Hy, Zh, Gh, Xp, Hh;
const Qg = class Qg {
  constructor(a) {
    Zr(this, $p);
    Nr(this, "opts");
    Nr(this, "attachment");
    Zr(this, ao, u0(null));
    Zr(this, Nc, et(!1));
    Nr(this, "inputAttachment", co(Qe(this, ao)));
    Zr(this, _s, u0(!1));
    Zr(this, Ja, et(null));
    Zr(this, oo, et(null));
    Zr(this, jc, new pz(() => this.opts.value.current ?? ""));
    Zr(this, jo, ut(() => typeof this.opts.pattern.current == "string" ? new RegExp(this.opts.pattern.current) : this.opts.pattern.current));
    Zr(this, vs, et(zi({
      prev: [null, null, "none"],
      willSyntheticBlur: !1
    })));
    Zr(this, Us);
    Zr(this, qc);
    Nr(this, "domContext");
    Nr(this, "onkeydown", a => {
      const d = a.key;
      SD.includes(d) || a.ctrlKey || a.metaKey || d && _(Qe(this, jo)) && !_(Qe(this, jo)).test(d) && a.preventDefault()
    });
    Zr(this, Hp, ut(() => ({
      position: "relative",
      cursor: this.opts.disabled.current ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })));
    Zr(this, Vh, ut(() => ({
      id: this.opts.id.current,
      [Gy.root]: "",
      style: _(Qe(this, Hp)),
      ...this.attachment
    })));
    Zr(this, Uh, ut(() => ({
      style: {
        position: "absolute",
        inset: 0,
        pointerEvents: "none"
      }
    })));
    Zr(this, Wp, ut(() => ({
      position: "absolute",
      inset: 0,
      width: Qe(this, Us).willPushPwmBadge ? `calc(100% + ${Qe(this,Us).PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: Qe(this, Us).willPushPwmBadge ? `inset(0 ${Qe(this,Us).PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: this.opts.textAlign.current,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--bits-pin-input-root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })));
    Zr(this, Zh, () => {
      var $;
      const a = Qe(this, ao).current,
        d = this.opts.ref.current;
      if (!a || !d) return;
      if (this.domContext.getActiveElement() !== a) {
        Y(Qe(this, Ja), null), Y(Qe(this, oo), null);
        return
      }
      const x = a.selectionStart,
        A = a.selectionEnd,
        z = a.selectionDirection ?? "none",
        b = a.maxLength,
        s = a.value,
        F = _(Qe(this, vs)).prev;
      let q = -1,
        J = -1,
        te;
      if (s.length !== 0 && x !== null && A !== null) {
        const Se = x === A,
          Me = x === s.length && s.length < b;
        if (Se && !Me) {
          const Pe = x;
          if (Pe === 0) q = 0, J = 1, te = "forward";
          else if (Pe === b) q = Pe - 1, J = Pe, te = "backward";
          else if (b > 1 && s.length > 1) {
            let Ie = 0;
            if (F[0] !== null && F[1] !== null) {
              te = Pe < F[0] ? "backward" : "forward";
              const Ce = F[0] === F[1] && F[0] < b;
              te === "backward" && !Ce && (Ie = -1)
            }
            q = Ie - Pe, J = Ie + Pe + 1
          }
        }
        q !== -1 && J !== -1 && q !== J && (($ = Qe(this, ao).current) == null || $.setSelectionRange(q, J, te))
      }
      const ae = q !== -1 ? q : x,
        fe = J !== -1 ? J : A,
        ie = te ?? z;
      Y(Qe(this, Ja), ae, !0), Y(Qe(this, oo), fe, !0), _(Qe(this, vs)).prev = [ae, fe, ie]
    });
    Nr(this, "oninput", a => {
      const d = a.currentTarget.value.slice(0, this.opts.maxLength.current);
      if (d.length > 0 && _(Qe(this, jo)) && !_(Qe(this, jo)).test(d)) {
        a.preventDefault();
        return
      }
      typeof Qe(this, jc).current == "string" && d.length < Qe(this, jc).current.length && this.domContext.getDocument().dispatchEvent(new Event("selectionchange")), this.opts.value.current = d
    });
    Nr(this, "onfocus", a => {
      const d = Qe(this, ao).current;
      if (d) {
        const x = Math.min(d.value.length, this.opts.maxLength.current - 1),
          A = d.value.length;
        d.setSelectionRange(x, A), Y(Qe(this, Ja), x, !0), Y(Qe(this, oo), A, !0)
      }
      Qe(this, _s).current = !0
    });
    Nr(this, "onpaste", a => {
      var J, te, ae, fe;
      const d = Qe(this, ao).current;
      if (!d) return;
      const x = ie => {
          const $ = d.selectionStart === null ? void 0 : d.selectionStart,
            Se = d.selectionEnd === null ? void 0 : d.selectionEnd,
            Me = $ !== Se,
            Pe = this.opts.value.current;
          return (Me ? Pe.slice(0, $) + ie + Pe.slice(Se) : Pe.slice(0, $) + ie + Pe.slice($)).slice(0, this.opts.maxLength.current)
        },
        A = ie => ie.length > 0 && _(Qe(this, jo)) && !_(Qe(this, jo)).test(ie);
      if (!((J = this.opts.pasteTransformer) != null && J.current) && (!Qe(this, qc).isIOS || !a.clipboardData || !d)) {
        const ie = x((te = a.clipboardData) == null ? void 0 : te.getData("text/plain"));
        A(ie) && a.preventDefault();
        return
      }
      const z = ((ae = a.clipboardData) == null ? void 0 : ae.getData("text/plain")) ?? "",
        b = (fe = this.opts.pasteTransformer) != null && fe.current ? this.opts.pasteTransformer.current(z) : z;
      a.preventDefault();
      const s = x(b);
      if (A(s)) return;
      d.value = s, this.opts.value.current = s;
      const F = Math.min(s.length, this.opts.maxLength.current - 1),
        q = s.length;
      d.setSelectionRange(F, q), Y(Qe(this, Ja), F, !0), Y(Qe(this, oo), q, !0)
    });
    Nr(this, "onmouseover", a => {
      Y(Qe(this, Nc), !0)
    });
    Nr(this, "onmouseleave", a => {
      Y(Qe(this, Nc), !1)
    });
    Nr(this, "onblur", a => {
      if (_(Qe(this, vs)).willSyntheticBlur) {
        _(Qe(this, vs)).willSyntheticBlur = !1;
        return
      }
      Qe(this, _s).current = !1
    });
    Zr(this, Gh, ut(() => {
      var a;
      return {
        id: this.opts.inputId.current,
        style: _(Qe(this, Wp)),
        autocomplete: this.opts.autocomplete.current || "one-time-code",
        "data-pin-input-input": "",
        "data-pin-input-input-mss": _(Qe(this, Ja)),
        "data-pin-input-input-mse": _(Qe(this, oo)),
        inputmode: this.opts.inputmode.current,
        pattern: (a = _(Qe(this, jo))) == null ? void 0 : a.source,
        maxlength: this.opts.maxLength.current,
        value: this.opts.value.current,
        disabled: Pz(this.opts.disabled.current),
        onpaste: this.onpaste,
        oninput: this.oninput,
        onkeydown: this.onkeydown,
        onmouseover: this.onmouseover,
        onmouseleave: this.onmouseleave,
        onfocus: this.onfocus,
        onblur: this.onblur,
        ...this.inputAttachment
      }
    }));
    Zr(this, Xp, ut(() => Array.from({
      length: this.opts.maxLength.current
    }).map((a, d) => {
      const x = Qe(this, _s).current && _(Qe(this, Ja)) !== null && _(Qe(this, oo)) !== null && (_(Qe(this, Ja)) === _(Qe(this, oo)) && d === _(Qe(this, Ja)) || d >= _(Qe(this, Ja)) && d < _(Qe(this, oo))),
        A = this.opts.value.current[d] !== void 0 ? this.opts.value.current[d] : null;
      return {
        char: A,
        isActive: x,
        hasFakeCaret: x && A === null
      }
    })));
    Zr(this, Hh, ut(() => ({
      cells: _(Qe(this, Xp)),
      isFocused: Qe(this, _s).current,
      isHovering: _(Qe(this, Nc))
    })));
    var d;
    this.opts = a, this.attachment = co(this.opts.ref), this.domContext = new Sz(a.ref), oa(this, qc, {
      value: this.opts.value,
      isIOS: typeof window < "u" && ((d = window == null ? void 0 : window.CSS) == null ? void 0 : d.supports("-webkit-touch-callout", "none"))
    }), oa(this, Us, TD({
      containerRef: this.opts.ref,
      inputRef: Qe(this, ao),
      isFocused: Qe(this, _s),
      pushPasswordManagerStrategy: this.opts.pushPasswordManagerStrategy,
      domContext: this.domContext
    })), ri(() => {
      const x = Qe(this, ao).current,
        A = this.opts.ref.current;
      if (!x || !A) return;
      Qe(this, qc).value.current !== x.value && (this.opts.value.current = x.value), _(Qe(this, vs)).prev = [x.selectionStart, x.selectionEnd, x.selectionDirection ?? "none"];
      const z = nh(this.domContext.getDocument(), "selectionchange", Qe(this, Zh), {
        capture: !0
      });
      Qe(this, Zh).call(this), this.domContext.getActiveElement() === x && (Qe(this, _s).current = !0), this.domContext.getElementById("pin-input-style") || en(this, $p, Hy).call(this);
      const b = () => {
        A && A.style.setProperty("--bits-pin-input-root-height", `${x.clientHeight}px`)
      };
      b();
      const s = new ResizeObserver(b);
      return s.observe(x), () => {
        z(), s.disconnect()
      }
    }), Pl([() => this.opts.value.current, () => Qe(this, ao).current], () => {
      PD(() => {
        const x = Qe(this, ao).current;
        if (!x) return;
        x.dispatchEvent(new Event("input"));
        const A = x.selectionStart,
          z = x.selectionEnd,
          b = x.selectionDirection ?? "none";
        A !== null && z !== null && (Y(Qe(this, Ja), A, !0), Y(Qe(this, oo), z, !0), _(Qe(this, vs)).prev = [A, z, b])
      }, this.domContext)
    }), tn(() => {
      const x = this.opts.value.current,
        A = Qe(this, jc).current,
        z = this.opts.maxLength.current,
        b = this.opts.onComplete.current;
      A !== void 0 && x !== A && A.length < z && x.length === z && b(x)
    })
  }
  static create(a) {
    return new Qg(a)
  }
  get rootProps() {
    return _(Qe(this, Vh))
  }
  set rootProps(a) {
    Y(Qe(this, Vh), a)
  }
  get inputWrapperProps() {
    return _(Qe(this, Uh))
  }
  set inputWrapperProps(a) {
    Y(Qe(this, Uh), a)
  }
  get inputProps() {
    return _(Qe(this, Gh))
  }
  set inputProps(a) {
    Y(Qe(this, Gh), a)
  }
  get snippetProps() {
    return _(Qe(this, Hh))
  }
  set snippetProps(a) {
    Y(Qe(this, Hh), a)
  }
};
ao = new WeakMap, Nc = new WeakMap, _s = new WeakMap, Ja = new WeakMap, oo = new WeakMap, jc = new WeakMap, jo = new WeakMap, vs = new WeakMap, Us = new WeakMap, qc = new WeakMap, Hp = new WeakMap, Vh = new WeakMap, Uh = new WeakMap, Wp = new WeakMap, $p = new WeakSet, Hy = function() {
  const a = this.domContext.getDocument(),
    d = a.createElement("style");
  if (d.id = "pin-input-style", a.head.appendChild(d), d.sheet) {
    const x = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
    Yu(d.sheet, "[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }"), Yu(d.sheet, `[data-pin-input-input]:autofill { ${x} }`), Yu(d.sheet, `[data-pin-input-input]:-webkit-autofill { ${x} }`), Yu(d.sheet, "@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), Yu(d.sheet, "[data-pin-input-input] + * { pointer-events: all !important; }")
  }
}, Zh = new WeakMap, Gh = new WeakMap, Xp = new WeakMap, Hh = new WeakMap;
let ag = Qg;
var Wh;
const e_ = class e_ {
  constructor(a) {
    Nr(this, "opts");
    Nr(this, "attachment");
    Zr(this, Wh, ut(() => ({
      id: this.opts.id.current,
      [Gy.cell]: "",
      "data-active": this.opts.cell.current.isActive ? "" : void 0,
      "data-inactive": this.opts.cell.current.isActive ? void 0 : "",
      ...this.attachment
    })));
    this.opts = a, this.attachment = co(this.opts.ref)
  }
  static create(a) {
    return new e_(a)
  }
  get props() {
    return _(Qe(this, Wh))
  }
  set props(a) {
    Y(Qe(this, Wh), a)
  }
};
Wh = new WeakMap;
let og = e_;

function PD(m, a) {
  const d = a.setTimeout(m, 0),
    x = a.setTimeout(m, 10),
    A = a.setTimeout(m, 50);
  return [d, x, A]
}

function Yu(m, a) {
  try {
    m.insertRule(a)
  } catch {
    console.error("pin input could not insert CSS rule:", a)
  }
}
var CD = me("<div><!> <div><input/></div></div>");

function ID(m, a) {
  const d = Ao();
  Wr(a, !0);
  let x = At(a, "id", 19, () => uo(d)),
    A = At(a, "inputId", 19, () => `${uo(d)}-input`),
    z = At(a, "ref", 15, null),
    b = At(a, "maxlength", 3, 6),
    s = At(a, "textalign", 3, "left"),
    F = At(a, "inputmode", 3, "numeric"),
    q = At(a, "onComplete", 3, sh),
    J = At(a, "pushPasswordManagerStrategy", 3, "increase-width"),
    te = At(a, "class", 3, ""),
    ae = At(a, "autocomplete", 3, "one-time-code"),
    fe = At(a, "disabled", 3, !1),
    ie = At(a, "value", 15, ""),
    $ = At(a, "onValueChange", 3, sh),
    Se = fr(a, ["$$slots", "$$events", "$$legacy", "id", "inputId", "ref", "maxlength", "textalign", "pattern", "inputmode", "onComplete", "pushPasswordManagerStrategy", "class", "children", "autocomplete", "disabled", "value", "onValueChange", "pasteTransformer"]);
  const Me = ag.create({
      id: pn(() => x()),
      ref: pn(() => z(), He => z(He)),
      inputId: pn(() => A()),
      autocomplete: pn(() => ae()),
      maxLength: pn(() => b()),
      textAlign: pn(() => s()),
      disabled: pn(() => fe()),
      inputmode: pn(() => F()),
      pattern: pn(() => a.pattern),
      onComplete: pn(() => q()),
      value: pn(() => ie(), He => {
        ie(He), $()(He)
      }),
      pushPasswordManagerStrategy: pn(() => J()),
      pasteTransformer: pn(() => a.pasteTransformer)
    }),
    Pe = ut(() => Qa(Se, Me.inputProps)),
    Ie = ut(() => Qa(Me.rootProps, {
      class: te()
    })),
    Ce = ut(() => Qa(Me.inputWrapperProps, {}));
  var je = CD();
  _r(je, () => ({
    ..._(Ie)
  }));
  var Ye = I(je);
  bi(Ye, () => a.children ?? wa, () => Me.snippetProps);
  var qe = O(Ye, 2);
  _r(qe, () => ({
    ..._(Ce)
  }));
  var Be = I(qe);
  _r(Be, () => ({
    ..._(Pe)
  }), void 0, void 0, void 0, void 0, !0), C(qe), C(je), Z(m, je), $r()
}
var MD = me("<div><!></div>");

function AD(m, a) {
  const d = Ao();
  Wr(a, !0);
  let x = At(a, "id", 19, () => uo(d)),
    A = At(a, "ref", 15, null),
    z = fr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "cell", "child", "children"]);
  const b = og.create({
      id: pn(() => x()),
      ref: pn(() => A(), ae => A(ae)),
      cell: pn(() => a.cell)
    }),
    s = ut(() => Qa(z, b.props));
  var F = or(),
    q = xt(F);
  {
    var J = ae => {
        var fe = or(),
          ie = xt(fe);
        bi(ie, () => a.child, () => ({
          props: _(s)
        })), Z(ae, fe)
      },
      te = ae => {
        var fe = MD();
        _r(fe, () => ({
          ..._(s)
        }));
        var ie = I(fe);
        bi(ie, () => a.children ?? wa), C(fe), Z(ae, fe)
      };
    Ee(q, ae => {
      a.child ? ae(J) : ae(te, !1)
    })
  }
  Z(m, F), $r()
}

function Vc(...m) {
  return O0(rh(m))
}

function kD(m, a) {
  Wr(a, !0);
  let d = At(a, "ref", 15, null),
    x = At(a, "value", 15, ""),
    A = fr(a, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
  var z = or(),
    b = xt(z);
  {
    let s = ut(() => Vc("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", a.class));
    ji(b, () => Xz, (F, q) => {
      q(F, Hs({
        "data-slot": "command",
        get class() {
          return _(s)
        }
      }, () => A, {
        get value() {
          return x()
        },
        set value(J) {
          x(J)
        },
        get ref() {
          return d()
        },
        set ref(J) {
          d(J)
        }
      }))
    })
  }
  Z(m, z), $r()
}

function ED(m, a) {
  Wr(a, !0);
  let d = At(a, "ref", 15, null),
    x = fr(a, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var A = or(),
    z = xt(A);
  {
    let b = ut(() => Vc("py-6 text-center text-sm", a.class));
    ji(z, () => Kz, (s, F) => {
      F(s, Hs({
        "data-slot": "command-empty",
        get class() {
          return _(b)
        }
      }, () => x, {
        get ref() {
          return d()
        },
        set ref(q) {
          d(q)
        }
      }))
    })
  }
  Z(m, A), $r()
}
var LD = me("<!> <!>", 1);

function zD(m, a) {
  Wr(a, !0);
  let d = At(a, "ref", 15, null),
    x = fr(a, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "heading", "value"]);
  var A = or(),
    z = xt(A);
  {
    let b = ut(() => Vc("text-foreground overflow-hidden p-1", a.class)),
      s = ut(() => a.value ?? a.heading ?? `----${qz()}`);
    ji(z, () => Qz, (F, q) => {
      q(F, Hs({
        "data-slot": "command-group",
        get class() {
          return _(b)
        },
        get value() {
          return _(s)
        }
      }, () => x, {
        get ref() {
          return d()
        },
        set ref(J) {
          d(J)
        },
        children: (J, te) => {
          var ae = LD(),
            fe = xt(ae);
          {
            var ie = Se => {
              var Me = or(),
                Pe = xt(Me);
              ji(Pe, () => tD, (Ie, Ce) => {
                Ce(Ie, {
                  class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                  children: (je, Ye) => {
                    wn();
                    var qe = qi();
                    Ue(() => ce(qe, a.heading)), Z(je, qe)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), Z(Se, Me)
            };
            Ee(fe, Se => {
              a.heading && Se(ie)
            })
          }
          var $ = O(fe, 2);
          ji($, () => iD, (Se, Me) => {
            Me(Se, {
              get children() {
                return a.children
              }
            })
          }), Z(J, ae)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  Z(m, A), $r()
}

function DD(m, a) {
  Wr(a, !0);
  let d = At(a, "ref", 15, null),
    x = fr(a, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var A = or(),
    z = xt(A);
  {
    let b = ut(() => Vc("aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", a.class));
    ji(z, () => cD, (s, F) => {
      F(s, Hs({
        "data-slot": "command-item",
        get class() {
          return _(b)
        }
      }, () => x, {
        get ref() {
          return d()
        },
        set ref(q) {
          d(q)
        }
      }))
    })
  }
  Z(m, A), $r()
}
var RD = jr('<svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"></path></svg>');

function FD(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = RD();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var BD = me('<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>');

function OD(m, a) {
  Wr(a, !0);
  let d = At(a, "ref", 15, null),
    x = At(a, "value", 15, ""),
    A = fr(a, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var z = BD(),
    b = I(z);
  FD(b, {
    class: "size-5 opacity-50"
  });
  var s = O(b, 2);
  {
    let F = ut(() => Vc("placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", a.class));
    ji(s, () => oD, (q, J) => {
      J(q, Hs({
        "data-slot": "command-input",
        get class() {
          return _(F)
        }
      }, () => A, {
        get ref() {
          return d()
        },
        set ref(te) {
          d(te)
        },
        get value() {
          return x()
        },
        set value(te) {
          x(te)
        }
      }))
    })
  }
  C(z), Z(m, z), $r()
}

function ND(m, a) {
  Wr(a, !0);
  let d = At(a, "ref", 15, null),
    x = fr(a, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var A = or(),
    z = xt(A);
  {
    let b = ut(() => Vc("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", a.class));
    ji(z, () => hD, (s, F) => {
      F(s, Hs({
        "data-slot": "command-list",
        get class() {
          return _(b)
        }
      }, () => x, {
        get ref() {
          return d()
        },
        set ref(q) {
          d(q)
        }
      }))
    })
  }
  Z(m, A), $r()
}
var jD = jr('<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>');

function qD(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = jD();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var VD = me("<span> </span> <!>", 1),
  UD = me('<span class="font-flag ml-0.5"> </span> ', 1),
  ZD = me('<span class="flex gap-1.5"><span class="font-flag"> </span> </span>'),
  GD = me("<!> <!>", 1),
  HD = me("<!> <!>", 1),
  WD = me('<button class="btn btn-xs btn-circle btn-ghost"><!></button>'),
  $D = me('<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>');

function x0(m, a) {
  Wr(a, !0);
  let d = At(a, "countryId", 15, 0),
    x = At(a, "dropdownDirection", 3, "right"),
    A = et(null),
    z = et(null),
    b = et("");

  function s() {
    hg().then(() => {
      var Ie;
      (Ie = document.activeElement) == null || Ie.blur(), Y(b, "")
    })
  }
  var F = $D(),
    q = I(F),
    J = I(q),
    te = I(J);
  {
    var ae = Ie => {
        var Ce = VD(),
          je = xt(Ce),
          Ye = I(je, !0);
        C(je);
        var qe = O(je, 2);
        qD(qe, {
          class: "size-3.5"
        }), Ue(Be => ce(Ye, Be), [() => Sg()]), Z(Ie, Ce)
      },
      fe = Ie => {
        const Ce = ut(() => qo(d()));
        var je = UD(),
          Ye = xt(je),
          qe = I(Ye, !0);
        C(Ye);
        var Be = O(Ye);
        Ue(() => {
          ce(qe, _(Ce).flag), ce(Be, ` ${_(Ce).name??""}`)
        }), Z(Ie, je)
      };
    Ee(te, Ie => {
      d() === 0 ? Ie(ae) : Ie(fe, !1)
    })
  }
  C(J);
  var ie = O(J, 2);
  let $;
  var Se = I(ie);
  ji(Se, () => kD, (Ie, Ce) => {
    Ce(Ie, {
      children: (je, Ye) => {
        var qe = HD(),
          Be = xt(qe);
        ji(Be, () => OD, (we, it) => {
          it(we, {
            placeholder: "Country",
            get ref() {
              return _(A)
            },
            set ref(mt) {
              Y(A, mt)
            },
            get value() {
              return _(b)
            },
            set value(mt) {
              Y(b, mt, !0)
            }
          })
        });
        var He = O(Be, 2);
        ji(He, () => ND, (we, it) => {
          it(we, {
            children: (mt, Ge) => {
              var Xe = GD(),
                vt = xt(Xe);
              ji(vt, () => ED, (_t, wt) => {
                wt(_t, {
                  children: (Je, zt) => {
                    wn();
                    var bt = qi();
                    Ue(Rt => ce(bt, Rt), [() => V5()]), Z(Je, bt)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              });
              var Ut = O(vt, 2);
              ji(Ut, () => zD, (_t, wt) => {
                wt(_t, {
                  children: (Je, zt) => {
                    var bt = or(),
                      Rt = xt(bt);
                    fi(Rt, 17, () => La.countries, Pt => Pt.id, (Pt, yt) => {
                      var sr = or(),
                        tr = xt(sr);
                      ji(tr, () => DD, (tt, ht) => {
                        ht(tt, {
                          get value() {
                            return _(yt).name
                          },
                          onSelect: () => {
                            d(_(yt).id), s()
                          },
                          children: (It, Bt) => {
                            var Nt = ZD(),
                              Ht = I(Nt),
                              yr = I(Ht, !0);
                            C(Ht);
                            var Wt = O(Ht);
                            C(Nt), Ue(() => {
                              ce(yr, _(yt).flag), ce(Wt, ` ${_(yt).name??""}`)
                            }), Z(It, Nt)
                          },
                          $$slots: {
                            default: !0
                          }
                        })
                      }), Z(Pt, sr)
                    }), Z(Je, bt)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), Z(mt, Xe)
            },
            $$slots: {
              default: !0
            }
          })
        }), Z(je, qe)
      },
      $$slots: {
        default: !0
      }
    })
  }), C(ie), C(q);
  var Me = O(q, 2);
  {
    var Pe = Ie => {
      var Ce = WD();
      Ce.__click = () => {
        d(0)
      };
      var je = I(Ce);
      ws(je, {
        class: "size-3.5"
      }), C(Ce), Z(Ie, Ce)
    };
    Ee(Me, Ie => {
      d() != 0 && Ie(Pe)
    })
  }
  C(F), lo(F, Ie => Y(z, Ie), () => _(z)), Ue(() => $ = qr(ie, 1, "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm", null, $, {
    "right-1": x() === "left"
  })), Ln("focus", J, () => {
    _(A).focus()
  }), Z(m, F), $r()
}
ni(["click"]);
var XD = jr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>');

function YD(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = XD();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var KD = jr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>'),
  JD = jr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function ch(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = or(),
    A = xt(x);
  {
    var z = s => {
        var F = KD();
        _r(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...d
        })), Z(s, F)
      },
      b = s => {
        var F = JD();
        _r(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...d
        })), Z(s, F)
      };
    Ee(A, s => {
      a.filled ? s(z) : s(b, !1)
    })
  }
  Z(m, x)
}
var QD = me('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  eR = me('<div class="mb-2"><!></div>'),
  tR = me('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  rR = me('<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>'),
  nR = me('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>'),
  iR = me('<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  aR = me('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>'),
  oR = me('<span class="font-flag tooltip ml-0.5"> </span>'),
  sR = me("<span> </span>"),
  lR = me('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  cR = me('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  uR = me('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  hR = me('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  dR = me('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  pR = me('<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>', 1);

function fR(m, a) {
  Wr(a, !0);
  const d = [];
  let x = et(1e3);
  const A = ut(() => _(x) <= 640);
  let z = et("today"),
    b = {
      regions: {
        label: JS(),
        icon: Qp
      },
      countries: {
        label: tP(),
        icon: YD
      },
      players: {
        label: Y0(),
        icon: af
      },
      alliances: {
        label: K0(),
        icon: of
      }
    },
    s = et("regions"),
    F = et(0),
    q = zi({
      players: {},
      alliances: {},
      regions: {},
      countries: {}
    }),
    J = ut(() => {
      var qe, Be, He;
      return _(s) === "regions" ? (Be = (qe = q[_(s)][_(F)]) == null ? void 0 : qe[_(z)]) == null ? void 0 : Be.entries : (He = q[_(s)][_(z)]) == null ? void 0 : He.entries
    });
  const te = 5 * 1e3;
  tn(() => {
    var we;
    if (!a.open) return;
    const qe = _(z),
      Be = _(s),
      He = _(F);
    Be === "players" && (!q[Be][qe] || Date.now() - q[Be][qe].time > te) ? fn.leaderboardPlayers(qe).then(it => {
      q[Be][qe] = {
        time: Date.now(),
        entries: it
      }
    }).catch(it => Xt.error(it.message)) : Be === "alliances" && (!q[Be][qe] || Date.now() - q[Be][qe].time > te) ? fn.leaderboardAlliances(qe).then(it => {
      q[Be][qe] = {
        time: Date.now(),
        entries: it
      }
    }).catch(it => Xt.error(it.message)) : Be === "countries" && (!q[Be][qe] || Date.now() - q[Be][qe].time > te) ? fn.leaderboardCountries(qe).then(it => {
      q[Be][qe] = {
        time: Date.now(),
        entries: it
      }
    }).catch(it => Xt.error(it.message)) : Be === "regions" && (!((we = q[Be][He]) != null && we[qe]) || Date.now() - q[Be][He][qe].time > te) && fn.leaderboardRegions(qe, He).then(it => {
      q[Be][He] || (q[Be][He] = {}), q[Be][He][qe] = {
        time: Date.now(),
        entries: it
      }
    }).catch(it => Xt.error(it.message))
  });
  var ae = pR(),
    fe = xt(ae);
  fi(fe, 21, () => Object.entries(b), ([qe, {
    label: Be,
    icon: He
  }]) => qe, (qe, Be) => {
    var He = ut(() => I0(_(Be), 2));
    let we = () => _(He)[0],
      it = () => _(He)[1].label,
      mt = () => _(He)[1].icon;
    const Ge = ut(mt);
    var Xe = QD(),
      vt = I(Xe);
    za(vt);
    var Ut, _t = O(vt, 2);
    ji(_t, () => _(Ge), (Je, zt) => {
      zt(Je, {
        get this() {
          return mt()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var wt = O(_t);
    C(Xe), Ue(() => {
      cr(vt, "aria-label", it()), Ut !== (Ut = we()) && (vt.value = (vt.__value = we()) ?? ""), ce(wt, ` ${it()??""}`)
    }), fg(d, [], vt, () => (we(), _(s)), Je => Y(s, Je)), Z(qe, Xe)
  }), C(fe);
  var ie = O(fe, 2),
    $ = I(ie);
  Rg($, {
    get value() {
      return _(z)
    },
    set value(qe) {
      Y(z, qe, !0)
    }
  });
  var Se = O($, 2);
  {
    var Me = qe => {
      x0(qe, {
        dropdownDirection: "left",
        get countryId() {
          return _(F)
        },
        set countryId(Be) {
          Y(F, Be, !0)
        }
      })
    };
    Ee(Se, qe => {
      _(s) === "regions" && !_(A) && qe(Me)
    })
  }
  C(ie);
  var Pe = O(ie, 2);
  {
    var Ie = qe => {
      var Be = eR(),
        He = I(Be);
      x0(He, {
        get countryId() {
          return _(F)
        },
        set countryId(we) {
          Y(F, we, !0)
        }
      }), C(Be), Z(qe, Be)
    };
    Ee(Pe, qe => {
      _(s) === "regions" && _(A) && qe(Ie)
    })
  }
  var Ce = O(Pe, 2);
  {
    var je = qe => {
        var Be = tR(),
          He = I(Be),
          we = O(He);
        {
          var it = Ge => {
              var Xe = qi();
              Ue(vt => ce(Xe, vt), [() => nf().toLowerCase()]), Z(Ge, Xe)
            },
            mt = Ge => {
              var Xe = or(),
                vt = xt(Xe);
              {
                var Ut = wt => {
                    var Je = qi();
                    Ue(zt => ce(Je, zt), [() => Ig()]), Z(wt, Je)
                  },
                  _t = wt => {
                    var Je = or(),
                      zt = xt(Je);
                    {
                      var bt = Rt => {
                        var Pt = qi();
                        Ue(yt => ce(Pt, yt), [() => Mg()]), Z(Rt, Pt)
                      };
                      Ee(zt, Rt => {
                        _(z) === "month" && Rt(bt)
                      }, !0)
                    }
                    Z(wt, Je)
                  };
                Ee(vt, wt => {
                  _(z) === "week" ? wt(Ut) : wt(_t, !1)
                }, !0)
              }
              Z(Ge, Xe)
            };
          Ee(we, Ge => {
            _(z) === "today" ? Ge(it) : Ge(mt, !1)
          })
        }
        C(Be), Ue(Ge => ce(He, `${Ge??""} `), [() => Cg()]), Z(qe, Be)
      },
      Ye = qe => {
        var Be = or(),
          He = xt(Be);
        {
          var we = mt => {
              var Ge = or(),
                Xe = xt(Ge);
              {
                var vt = _t => {
                    const wt = ut(() => _(J));
                    var Je = nR(),
                      zt = I(Je),
                      bt = I(zt),
                      Rt = O(I(bt)),
                      Pt = I(Rt, !0);
                    C(Rt);
                    var yt = O(Rt),
                      sr = I(yt),
                      tr = O(sr, 2),
                      tt = O(tr),
                      ht = I(tt);
                    ch(ht, {
                      class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                    }), C(tt), C(yt), wn(), C(bt), C(zt);
                    var It = O(zt);
                    fi(It, 31, () => _(wt), Bt => Bt.id, (Bt, Nt, Ht) => {
                      const yr = ut(() => qo(_(Nt).countryId));
                      var Wt = rR(),
                        Zt = I(Wt),
                        jt = I(Zt, !0);
                      C(Zt);
                      var Jt = O(Zt),
                        Lt = I(Jt),
                        Gt = I(Lt, !0);
                      C(Lt);
                      var Yt = O(Lt, 2),
                        Lr = I(Yt),
                        Ir = O(Lr),
                        Jr = I(Ir);
                      C(Ir), C(Yt), C(Jt);
                      var Tr = O(Jt),
                        Ar = I(Tr, !0);
                      C(Tr);
                      var xr = O(Tr),
                        qt = I(xr);
                      qt.__click = () => {
                        a.onvisitclick({
                          lat: _(Nt).lastLatitude,
                          lng: _(Nt).lastLongitude
                        })
                      };
                      var Yr = I(qt, !0);
                      C(qt), C(xr), C(Wt), Ue((Le, j, E) => {
                        ce(jt, _(Ht) + 1), cr(Lt, "data-tip", _(yr).name), ce(Gt, _(yr).flag), qr(Yt, 1, `font-semibold ${Le??""}`), ce(Lr, `${_(Nt).name??""} `), ce(Jr, `#${_(Nt).number??""}`), ce(Ar, j), ce(Yr, E)
                      }, [() => ea(_(Nt).cityId), () => _(Nt).pixelsPainted.toLocaleString("en-US"), () => Yb()]), wl(Wt, () => Tl, () => ({
                        duration: 200
                      })), Z(Bt, Wt)
                    }), C(It), C(Je), Ue((Bt, Nt, Ht, yr) => {
                      ce(Pt, Bt), ce(sr, `${Nt??""} `), ce(tr, `${Ht??""} `), cr(tt, "data-tip", yr)
                    }, [() => lP(), () => Lc(), () => zc().toLowerCase(), () => mP()]), Z(_t, Je)
                  },
                  Ut = _t => {
                    var wt = or(),
                      Je = xt(wt);
                    {
                      var zt = Rt => {
                          var Pt = aR(),
                            yt = I(Pt),
                            sr = I(yt),
                            tr = O(I(sr)),
                            tt = I(tr, !0);
                          C(tr);
                          var ht = O(tr),
                            It = I(ht),
                            Bt = O(It, 2),
                            Nt = O(Bt),
                            Ht = I(Nt);
                          ch(Ht, {
                            class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                          }), C(Nt), C(ht), C(sr), C(yt);
                          var yr = O(yt);
                          fi(yr, 31, () => _(J), Wt => Wt.id, (Wt, Zt, jt) => {
                            const Jt = ut(() => qo(_(Zt).id) ?? {
                              name: `Pais ID: ${_(Zt).id}`,
                              flag: "üè≥Ô∏è",
                              code: "XX"
                            });
                            var Lt = iR(),
                              Gt = I(Lt),
                              Yt = I(Gt, !0);
                            C(Gt);
                            var Lr = O(Gt),
                              Ir = I(Lr),
                              Jr = I(Ir, !0);
                            C(Ir);
                            var Tr = O(Ir, 2),
                              Ar = I(Tr, !0);
                            C(Tr), C(Lr);
                            var xr = O(Lr),
                              qt = I(xr, !0);
                            C(xr), C(Lt), Ue((Yr, Le) => {
                              ce(Yt, _(jt) + 1), cr(Ir, "data-tip", _(Jt).name), ce(Jr, _(Jt).flag), qr(Tr, 1, `font-semibold ${Yr??""}`), ce(Ar, _(Jt).name), ce(qt, Le)
                            }, [() => ea(_(Zt).id), () => _(Zt).pixelsPainted.toLocaleString("en-US")]), wl(Lt, () => Tl, () => ({
                              duration: 200
                            })), Z(Wt, Lt)
                          }), C(yr), C(Pt), Ue((Wt, Zt, jt, Jt) => {
                            ce(tt, Wt), ce(It, `${Zt??""} `), ce(Bt, `${jt??""} `), cr(Nt, "data-tip", Jt)
                          }, [() => Sg(), () => Lc(), () => zc().toLowerCase(), () => GP()]), Z(Rt, Pt)
                        },
                        bt = Rt => {
                          var Pt = or(),
                            yt = xt(Pt);
                          {
                            var sr = tt => {
                                const ht = ut(() => _(J));
                                var It = cR(),
                                  Bt = I(It),
                                  Nt = I(Bt),
                                  Ht = O(I(Nt)),
                                  yr = I(Ht, !0);
                                C(Ht);
                                var Wt = O(Ht),
                                  Zt = I(Wt),
                                  jt = O(Zt, 2, !0);
                                C(Wt), C(Nt), C(Bt);
                                var Jt = O(Bt);
                                fi(Jt, 31, () => _(ht), Lt => Lt.id, (Lt, Gt, Yt) => {
                                  const Lr = ut(() => {
                                    var he;
                                    return ((he = Dt.data) == null ? void 0 : he.id) === _(Gt).id
                                  });
                                  var Ir = lR();
                                  let Jr;
                                  var Tr = I(Ir),
                                    Ar = I(Tr, !0);
                                  C(Tr);
                                  var xr = O(Tr),
                                    qt = I(xr),
                                    Yr = I(qt);
                                  Mo(Yr, {
                                    class: "size-8 border sm:size-10",
                                    get userId() {
                                      return _(Gt).id
                                    },
                                    get pictureUrl() {
                                      return _(Gt).picture
                                    }
                                  });
                                  var Le = O(Yr, 2),
                                    j = I(Le),
                                    E = I(j),
                                    D = O(E),
                                    N = I(D);
                                  C(D), C(j);
                                  var X = O(j, 2);
                                  {
                                    var ee = he => {
                                      const Q = ut(() => qo(_(Gt).equippedFlag));
                                      var ze = or(),
                                        $e = xt(ze);
                                      {
                                        var Re = ft => {
                                          var Mt = oR(),
                                            Et = I(Mt, !0);
                                          C(Mt), Ue(() => {
                                            cr(Mt, "data-tip", _(Q).name), ce(Et, _(Q).flag)
                                          }), Z(ft, Mt)
                                        };
                                        Ee($e, ft => {
                                          _(Q) && ft(Re)
                                        })
                                      }
                                      Z(he, ze)
                                    };
                                    Ee(X, he => {
                                      _(Gt).equippedFlag && he(ee)
                                    })
                                  }
                                  var pe = O(X, 2);
                                  {
                                    var be = he => {
                                      ed(he, {
                                        get username() {
                                          return _(Gt).discord
                                        },
                                        get id() {
                                          return _(Gt).discordId
                                        }
                                      })
                                    };
                                    Ee(pe, he => {
                                      _(Gt).discord && he(be)
                                    })
                                  }
                                  var ye = O(pe, 2);
                                  {
                                    var Oe = he => {
                                      var Q = sR(),
                                        ze = I(Q, !0);
                                      C(Q), Ue(($e, Re) => {
                                        qr(Q, 1, `badge badge-sm ml-0.5 border-0 ${$e??""} ${Re??""}`), ce(ze, _(Gt).allianceName)
                                      }, [() => Kp(_(Gt).allianceId), () => ea(_(Gt).allianceId)]), Z(he, Q)
                                    };
                                    Ee(ye, he => {
                                      "allianceName" in _(Gt) && _(Gt).allianceName && he(Oe)
                                    })
                                  }
                                  C(Le), C(qt), C(xr);
                                  var oe = O(xr),
                                    K = I(oe, !0);
                                  C(oe), C(Ir), Ue((he, Q) => {
                                    Jr = qr(Ir, 1, "", null, Jr, {
                                      "bg-base-200": _(Lr)
                                    }), ce(Ar, _(Yt) + 1), qr(j, 1, `font-semibold max-sm:ml-2 ${he??""} flex gap-1`), ce(E, `${_(Gt).name??""} `), ce(N, `#${_(Gt).id??""}`), ce(K, Q)
                                  }, [() => ea(_(Gt).id), () => _(Gt).pixelsPainted.toLocaleString("en-US")]), wl(Ir, () => Tl, () => ({
                                    duration: 200
                                  })), Z(Lt, Ir)
                                }), C(Jt), C(It), Ue((Lt, Gt, Yt) => {
                                  ce(yr, Lt), ce(Zt, `${Gt??""} `), ce(jt, Yt)
                                }, [() => xg(), () => Lc(), () => zc().toLowerCase()]), Z(tt, It)
                              },
                              tr = tt => {
                                var ht = or(),
                                  It = xt(ht);
                                {
                                  var Bt = Nt => {
                                    var Ht = hR(),
                                      yr = I(Ht),
                                      Wt = I(yr),
                                      Zt = O(I(Wt)),
                                      jt = I(Zt, !0);
                                    C(Zt);
                                    var Jt = O(Zt),
                                      Lt = I(Jt),
                                      Gt = O(Lt, 2, !0);
                                    C(Jt), C(Wt), C(yr);
                                    var Yt = O(yr);
                                    fi(Yt, 31, () => _(J), Lr => Lr.id, (Lr, Ir, Jr) => {
                                      const Tr = ut(() => {
                                        var X;
                                        return ((X = Dt.data) == null ? void 0 : X.allianceId) === _(Ir).id
                                      });
                                      var Ar = uR();
                                      let xr;
                                      var qt = I(Ar),
                                        Yr = I(qt, !0);
                                      C(qt);
                                      var Le = O(qt),
                                        j = I(Le),
                                        E = I(j, !0);
                                      C(j), C(Le);
                                      var D = O(Le),
                                        N = I(D, !0);
                                      C(D), C(Ar), Ue((X, ee) => {
                                        xr = qr(Ar, 1, "", null, xr, {
                                          "bg-base-200": _(Tr)
                                        }), ce(Yr, _(Jr) + 1), qr(j, 1, `font-semibold ${X??""}`), ce(E, _(Ir).name), ce(N, ee)
                                      }, [() => ea(_(Ir).id), () => _(Ir).pixelsPainted.toLocaleString("en-US")]), wl(Ar, () => Tl, () => ({
                                        duration: 200
                                      })), Z(Lr, Ar)
                                    }), C(Yt), C(Ht), Ue((Lr, Ir, Jr) => {
                                      ce(jt, Lr), ce(Lt, `${Ir??""} `), ce(Gt, Jr)
                                    }, [() => tf(), () => Lc(), () => zc().toLowerCase()]), Z(Nt, Ht)
                                  };
                                  Ee(It, Nt => {
                                    _(s) === "alliances" && Nt(Bt)
                                  }, !0)
                                }
                                Z(tt, ht)
                              };
                            Ee(yt, tt => {
                              _(s) === "players" ? tt(sr) : tt(tr, !1)
                            }, !0)
                          }
                          Z(Rt, Pt)
                        };
                      Ee(Je, Rt => {
                        _(s) === "countries" ? Rt(zt) : Rt(bt, !1)
                      }, !0)
                    }
                    Z(_t, wt)
                  };
                Ee(Xe, _t => {
                  _(s) === "regions" ? _t(vt) : _t(Ut, !1)
                })
              }
              Z(mt, Ge)
            },
            it = mt => {
              var Ge = dR();
              Z(mt, Ge)
            };
          Ee(He, mt => {
            _(J) ? mt(we) : mt(it, !1)
          }, !0)
        }
        Z(qe, Be)
      };
    Ee(Ce, qe => {
      _(J) && _(J).length === 0 ? qe(je) : qe(Ye, !1)
    })
  }
  ef("innerWidth", qe => Y(x, qe, !0)), Z(m, ae), $r()
}
ni(["click"]);
var mR = jr('<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>');

function Wy(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = mR();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var gR = me('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function _R(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15);
  ri(() => {
    const te = ae => {
      ae.key === "Escape" && d(!1)
    };
    return document.addEventListener("keydown", te), () => document.removeEventListener("keydown", te)
  });
  var x = gR(),
    A = I(x),
    z = O(I(A), 2),
    b = I(z);
  Wy(b, {
    class: "size-6"
  });
  var s = O(b, 2),
    F = I(s, !0);
  C(s), C(z);
  var q = O(z, 2),
    J = I(q);
  fR(J, {
    get onvisitclick() {
      return a.onvisitclick
    },
    get open() {
      return d()
    }
  }), C(q), C(A), wn(2), C(x), Di(x, () => te => {
    tn(() => {
      d() ? te.show() : te.close()
    })
  }), Ue(te => ce(F, te), [() => Tg()]), Ln("close", x, () => d(!1)), Z(m, x), $r()
}
var vR = me("<div><!></div>"),
  yR = me('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function xR(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15);
  ri(() => {
    const s = F => {
      F.key === "Escape" && d(!1)
    };
    return document.addEventListener("keydown", s), () => document.removeEventListener("keydown", s)
  });
  var x = yR(),
    A = I(x),
    z = O(I(A), 2);
  {
    var b = s => {
      var F = vR(),
        q = I(F);
      e2(q, {}), C(F), ba(2, F, () => so, () => ({
        duration: 300
      })), Z(s, F)
    };
    Ee(z, s => {
      d() && s(b)
    })
  }
  C(A), wn(2), C(x), Di(x, () => s => {
    tn(() => {
      d() ? s.show() : s.close()
    })
  }), Ln("close", x, () => d(!1)), Z(m, x), $r()
}
var bR = me("<p>You don't have charges to paint. <br/> </p>");

function wR(m, a) {
  Wr(a, !1), mg();
  var d = bR(),
    x = O(I(d), 2);
  C(d), Ue(A => ce(x, ` Next charge in ${A??""}`), [() => Np(Dt.cooldown ?? 0)]), Z(m, d), $r()
}
var TR = me('<form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form>'),
  SR = me('<form method="dialog" class="modal-backdrop"><button> </button></form>'),
  PR = me("<dialog><div><!> <!></div> <!></dialog>");

function jg(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15),
    x = At(a, "hasBackdrop", 3, !0),
    A = At(a, "hasCloseButton", 3, !0);
  var z = PR(),
    b = I(z),
    s = I(b);
  {
    var F = ae => {
      var fe = TR();
      Z(ae, fe)
    };
    Ee(s, ae => {
      A() && ae(F)
    })
  }
  var q = O(s, 2);
  bi(q, () => a.children ?? wa), C(b);
  var J = O(b, 2);
  {
    var te = ae => {
      var fe = SR(),
        ie = I(fe),
        $ = I(ie, !0);
      C(ie), C(fe), Ue(Se => ce($, Se), [() => xs()]), Z(ae, fe)
    };
    Ee(J, ae => {
      x() && ae(te)
    })
  }
  C(z), Di(z, () => ae => {
    tn(() => {
      d() ? ae.show() : ae.close()
    })
  }), Ue(() => {
    qr(z, 1, `modal ${a.dialogClass??""}`), qr(b, 1, `modal-box ${a.modalBoxClass??""}`)
  }), Ln("close", z, () => d(!1)), Z(m, z), $r()
}
var CR = me('<div class="flex h-full flex-col gap-4"><span class="text-xl font-semibold"> </span> <span><!></span> <button class="btn btn-primary mx-auto w-max px-10"> </button></div>');

function IR(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15),
    x = At(a, "buttonText", 3, "OK");
  jg(m, {
    dialogClass: "!bg-black/80",
    modalBoxClass: "max-h-11/12",
    get open() {
      return d()
    },
    set open(A) {
      d(A)
    },
    children: (A, z) => {
      var b = CR(),
        s = I(b),
        F = I(s, !0);
      C(s);
      var q = O(s, 2),
        J = I(q);
      bi(J, () => a.message), C(q);
      var te = O(q, 2);
      te.__click = () => {
        d(!1)
      };
      var ae = I(te, !0);
      C(te), C(b), Ue(() => {
        ce(F, a.title), ce(ae, x())
      }), Z(A, b)
    },
    $$slots: {
      default: !0
    }
  }), $r()
}
ni(["click"]);

function MR(m) {
  const a = new Date;
  return m.getDate() === a.getDate() && m.getMonth() === a.getMonth() && m.getFullYear() === a.getFullYear() ? m.toLocaleTimeString(void 0, {
    timeStyle: "short"
  }) : m.toLocaleDateString(void 0, {
    dateStyle: "medium"
  })
}
var AR = me('<span class="size-2 rounded-full bg-red-400"></span>'),
  kR = me('<button class="hover:bg-base-content/10 flex gap-3 px-6 py-3"><div class="bg-primary/30 flex size-10 min-h-10 min-w-10 items-center justify-center rounded-full"><!></div> <div class="grow text-sm"><div class="flex items-baseline justify-between"><h3 class="font-semibold"> </h3> <div class="text-base-content/80 flex items-center gap-1.5 text-xs"><span> </span> <!></div></div> <p class="mt-0.5 text-left"> </p></div></button>');

function ER(m, a) {
  Wr(a, !0);
  let d = At(a, "read", 15);
  var x = kR();
  x.__click = () => {
    d(!0), a.onclick()
  };
  var A = I(x),
    z = I(A);
  bi(z, () => a.icon), C(A);
  var b = O(A, 2),
    s = I(b),
    F = I(s),
    q = I(F, !0);
  C(F);
  var J = O(F, 2),
    te = I(J),
    ae = I(te, !0);
  C(te);
  var fe = O(te, 2);
  {
    var ie = Me => {
      var Pe = AR();
      Z(Me, Pe)
    };
    Ee(fe, Me => {
      d() || Me(ie)
    })
  }
  C(J), C(s);
  var $ = O(s, 2),
    Se = I($, !0);
  C($), C(b), C(x), Ue(Me => {
    ce(q, a.title), ce(ae, Me), ce(Se, a.message)
  }, [() => MR(a.createdAt)]), Z(m, x), $r()
}
ni(["click"]);
var LR = jr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h168q13-36 43.5-58t68.5-22q38 0 68.5 22t43.5 58h168q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm80-80h280v-80H280v80Zm0-160h400v-80H280v80Zm0-160h400v-80H280v80Zm200-190q13 0 21.5-8.5T510-820q0-13-8.5-21.5T480-850q-13 0-21.5 8.5T450-820q0 13 8.5 21.5T480-790ZM200-200v-560 560Z"></path></svg>');

function zR(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = LR();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var DR = me('<button class="btn btn-sm btn-ghost"> </button>'),
  RR = me('<p class="text-base-content/80 mt-4 text-center text-sm"> </p>'),
  FR = me("<!> <!>", 1),
  BR = me('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  OR = me('<div class="flex items-center justify-between gap-2 px-6"><h3 class="text-xl font-bold"> </h3> <!></div> <section class="mt-4"><!> <!></section>', 1),
  NR = me("<p> </p>"),
  jR = me("<!> <!>", 1);

function qR(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15),
    x = et(!1),
    A = et(void 0),
    z = et(void 0),
    b = et(!1);
  var s = jR(),
    F = xt(s);
  jg(F, {
    modalBoxClass: "h-11/12 max-h-11/12 px-0",
    get open() {
      return d()
    },
    set open(J) {
      d(J)
    },
    children: (J, te) => {
      var ae = OR(),
        fe = xt(ae),
        ie = I(fe),
        $ = I(ie, !0);
      C(ie);
      var Se = O(ie, 2);
      {
        var Me = qe => {
          var Be = DR();
          Be.__click = async () => {
            if (fn.postNotificationMarkReadAll(), Dt.notificiationCount = 0, _(A))
              for (const we of _(A)) we.read = !0
          };
          var He = I(Be, !0);
          C(Be), Ue(we => ce(He, we), [() => JM()]), Z(qe, Be)
        };
        Ee(Se, qe => {
          Dt.notificiationCount !== 0 && qe(Me)
        })
      }
      C(fe);
      var Pe = O(fe, 2),
        Ie = I(Pe);
      {
        var Ce = qe => {
          var Be = FR(),
            He = xt(Be);
          fi(He, 17, () => _(A), mt => mt.id, (mt, Ge, Xe) => {
            var vt = or(),
              Ut = xt(vt);
            {
              var _t = wt => {
                {
                  const Je = Pt => {
                    zR(Pt, {
                      class: "size-5"
                    })
                  };
                  let zt = ut(() => Hv()),
                    bt = ut(() => Wv()),
                    Rt = ut(() => new Date(_(Ge).createdAt));
                  ER(wt, {
                    get title() {
                      return _(zt)
                    },
                    get message() {
                      return _(bt)
                    },
                    get createdAt() {
                      return _(Rt)
                    },
                    onclick: () => {
                      Y(b, !0)
                    },
                    get read() {
                      return _(Ge).read
                    },
                    set read(Pt) {
                      _(Ge).read = Pt
                    },
                    icon: Je,
                    $$slots: {
                      icon: !0
                    }
                  })
                }
              };
              Ee(Ut, wt => {
                _(Ge).type === "report_feedback" && wt(_t)
              })
            }
            Z(mt, vt)
          });
          var we = O(He, 2);
          {
            var it = mt => {
              var Ge = RR(),
                Xe = I(Ge, !0);
              C(Ge), Ue(vt => ce(Xe, vt), [() => VM()]), Z(mt, Ge)
            };
            Ee(we, mt => {
              _(A).length === 0 && !_(x) && mt(it)
            })
          }
          Z(qe, Be)
        };
        Ee(Ie, qe => {
          _(A) && qe(Ce)
        })
      }
      var je = O(Ie, 2);
      {
        var Ye = qe => {
          var Be = BR();
          Di(Be, () => He => {
            const we = new IntersectionObserver(it => {
              it[0].isIntersecting && !_(x) && (Y(x, !0), fn.getNotificationPage(_(z)).then(mt => {
                Y(A, [..._(A) ?? [], ...mt.notifications], !0), Y(z, mt.nextCursor, !0);
                const Ge = mt.notifications.filter(Xe => !Xe.read).map(Xe => Xe.id);
                Ge.length > 0 && (fn.postNotificationMarkRead(Ge), Dt.notificiationCount && (Dt.notificiationCount = Math.max(0, Ge.length - Ge.length)))
              }).catch(mt => {
                Xt.error(mt.message)
              }).finally(() => {
                Y(x, !1)
              }))
            });
            return we.observe(He), () => {
              we.disconnect()
            }
          }), Z(qe, Be)
        };
        Ee(je, qe => {
          d() && (_(A) === void 0 || _(z) !== void 0) && qe(Ye)
        })
      }
      C(Pe), Ue(qe => ce($, qe), [() => ry()]), Z(J, ae)
    },
    $$slots: {
      default: !0
    }
  });
  var q = O(F, 2);
  {
    const J = ae => {
      var fe = NR(),
        ie = I(fe);
      C(fe), Ue(($, Se) => ce(ie, `${$??""} ${Se??""}`), [() => Wv(), () => XM()]), Z(ae, fe)
    };
    let te = ut(() => Hv());
    IR(q, {
      get title() {
        return _(te)
      },
      get open() {
        return _(b)
      },
      set open(ae) {
        Y(b, ae, !0)
      },
      message: J,
      $$slots: {
        message: !0
      }
    })
  }
  Z(m, s), $r()
}
ni(["click"]);
var VR = me("<canvas></canvas>");

function $y(m, a) {
  Wr(a, !0);
  let d = At(a, "width", 15, 0),
    x = fr(a, ["$$slots", "$$events", "$$legacy", "value", "fontSize", "color", "weight", "mono", "width"]),
    A = ut(() => Math.ceil(a.fontSize)),
    z = et(null);
  const b = window.devicePixelRatio ?? 1,
    s = '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
    F = '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  tn(() => {
    const J = _(z).getContext("2d");
    J.textBaseline = "top", J.font = `${a.weight??"normal"} ${a.fontSize}px ${a.mono?F:s}`, J.fillStyle = a.color ?? "#394e6a", J.setTransform(b, 0, 0, b, 0, 0), J.clearRect(0, 0, d(), _(A)), J.fillText(a.value, 0, 0);
    const te = J.measureText(a.value);
    d(Math.ceil(te.actualBoundingBoxRight)), Y(A, te.actualBoundingBoxDescent)
  });
  var q = VR();
  _r(q, () => ({
    width: d() * b,
    height: _(A) * b,
    style: `width: ${d()??""}px; height: ${_(A)??""}px`,
    ...x
  })), lo(q, J => Y(z, J), () => _(z)), Z(m, q), $r()
}
var UR = me('<span class="w-7 text-xs"> </span>'),
  ZR = me('<span class="flex items-center gap-1 sm:mt-[1px]"><span><!></span> <!></span>'),
  GR = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  HR = me('<button><!> <div class="flex items-center gap-2"> <!></div> <!></button>');

function Xy(m, a) {
  Wr(a, !0);
  let d = fr(a, ["$$slots", "$$events", "$$legacy", "loading", "charges"]),
    x = et(0);
  var A = HR();
  _r(A, () => ({
    ...d,
    class: `btn btn-primary btn-lg sm:btn-xl relative ${a.class??""}`
  }));
  var z = I(A);
  Il(z, {
    class: "size-6"
  });
  var b = O(z, 2),
    s = I(b),
    F = O(s);
  {
    var q = ae => {
      const fe = ut(() => `${Math.floor(a.charges)}/${Dt.data.charges.max}`);
      var ie = ZR(),
        $ = I(ie),
        Se = I($);
      {
        let Ie = ut(() => a.disabled ? "#394e6a33" : "#ffffff");
        $y(Se, {
          weight: 600,
          fontSize: 16,
          get value() {
            return _(fe)
          },
          get color() {
            return _(Ie)
          },
          get width() {
            return _(x)
          },
          set width(Ce) {
            Y(x, Ce, !0)
          }
        })
      }
      C($);
      var Me = O($, 2);
      {
        var Pe = Ie => {
          var Ce = UR(),
            je = I(Ce);
          C(Ce), Ue(Ye => ce(je, `(${Ye??""})`), [() => Np(Dt.cooldown)]), Z(Ie, Ce)
        };
        Ee(Me, Ie => {
          a.charges < Dt.data.charges.max && Dt.cooldown !== void 0 && Ie(Pe)
        })
      }
      C(ie), Ue(Ie => bs($, `width: ${Ie??""}px`), [() => (Math.floor(_(x) / 5) + 1) * 5]), Z(ae, ie)
    };
    Ee(F, ae => {
      a.charges !== void 0 && Dt.data && ae(q)
    })
  }
  C(b);
  var J = O(b, 2);
  {
    var te = ae => {
      var fe = GR();
      Z(ae, fe)
    };
    Ee(J, ae => {
      a.loading && ae(te)
    })
  }
  C(A), Ue(ae => ce(s, `${ae??""} `), [() => W0()]), Z(m, A), $r()
}
const WR = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII=",
  $R = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC",
  XR = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC",
  YR = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
class KR {
  constructor(a) {
    Nr(this, "gm");
    Nr(this, "opacity", 1);
    Nr(this, "id", `paint-preview-${Math.random()}`);
    Nr(this, "tiles", new Map);
    this.input = a, this.gm = new Oa(this.input.tileSize)
  }
  place([a, d], x) {
    const {
      tile: A,
      pixel: z
    } = this.gm.latLonToTileAndPixel(a, d, this.input.tileZoom), b = this.getTileKey(A[0], A[1]);
    let s = this.tiles.get(b);
    if (!s) {
      const F = this.gm.tileBoundsLatLon(A[0], A[1], this.input.tileZoom),
        q = Ag(F, !0),
        J = new JR({
          coordinates: q,
          id: `${this.id}-${b}`,
          layerPaint: {
            "raster-opacity": this.opacity,
            "raster-resampling": "nearest"
          },
          tileSize: this.input.tileSize,
          beforeLayerId: this.input.beforeLayerId
        });
      J.addTo(this.input.map), this.tiles.set(b, J), s = J
    }
    s.place(z[0], this.input.tileSize - z[1] - 1, x)
  }
  clear() {
    const a = this.input.map;
    for (const d of this.tiles.values()) d.removeFrom(a), d.removeDOM();
    this.tiles.clear()
  }
  clearAndPlace(a, d) {
    this.clear(), this.place(a, d)
  }
  remove([a, d]) {
    const {
      tile: x,
      pixel: A
    } = this.gm.latLonToTileAndPixel(a, d, this.input.tileZoom), z = this.getTileKey(x[0], x[1]), b = this.tiles.get(z);
    b && b.remove(A[0], this.input.tileSize - A[1] - 1)
  }
  setCanvasOpacity(a) {
    this.opacity = a;
    for (const d of this.tiles.values()) d.setOpacity(a)
  }
  getTileKey(a, d) {
    return `${a},${d}`
  }
}
class JR {
  constructor(a) {
    Nr(this, "canvas");
    Nr(this, "maps", new Set);
    this.input = a;
    const d = this.input.tileSize;
    this.canvas = document.createElement("canvas"), this.canvas.width = d, this.canvas.height = d
  }
  place(a, d, x) {
    var b;
    const A = ((b = La.colors) == null ? void 0 : b[x]) ?? La.colors[0],
      z = this.canvas.getContext("2d");
    if (z) {
      const s = z.createImageData(1, 1),
        [F, q, J] = A.rgb,
        te = x === 0 ? 0 : 255;
      s.data[0] = F, s.data[1] = q, s.data[2] = J, s.data[3] = te, z.putImageData(s, a, d)
    }
  }
  remove(a, d) {
    const x = this.canvas.getContext("2d");
    x && x.clearRect(a, d, 1, 1)
  }
  addTo(a) {
    const d = this.input.id;
    a.getSource(d) || a.addSource(d, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), a.getLayer(d) || (a.addLayer({
      id: d,
      type: "raster",
      source: d,
      paint: this.input.layerPaint
    }), this.input.beforeLayerId && a.moveLayer(d, this.input.beforeLayerId)), this.maps.add(a)
  }
  removeFrom(a) {
    const {
      id: d
    } = this.input;
    a.getLayer(d) && a.removeLayer(d), a.getSource(d) && a.removeSource(d), this.maps.delete(a)
  }
  removeDOM() {
    this.canvas.remove()
  }
  setOpacity(a) {
    for (const d of this.maps.values()) d.setPaintProperty(this.input.id, "raster-opacity", a)
  }
}
var QR = jr('<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>');

function e7(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = QR();
  _r(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...d
  })), Z(m, x)
}
var t7 = jr('<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>');

function r7(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = t7();
  _r(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...d
  })), Z(m, x)
}
var n7 = me("<div><!></div>");

function yl(m, a) {
  Wr(a, !0);
  var d = n7(),
    x = I(d);
  bi(x, () => a.children ?? wa), C(d), Ue(() => qr(d, 1, `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${a.class??""}`)), Z(m, d), $r()
}
var i7 = me('<div class="confetti svelte-av71ki"></div>'),
  a7 = me("<div></div>");

function qg(m, a) {
  Wr(a, !0);
  const d = At(a, "size", 3, 10),
    x = At(a, "x", 19, () => [-.5, .5]),
    A = At(a, "y", 19, () => [.25, 1]),
    z = At(a, "duration", 3, 2e3),
    b = At(a, "infinite", 3, !1),
    s = At(a, "delay", 19, () => [0, 50]),
    F = At(a, "colorRange", 19, () => [0, 360]),
    q = At(a, "colorArray", 19, () => []),
    J = At(a, "amount", 3, 50),
    te = At(a, "iterationCount", 3, 1),
    ae = At(a, "fallDistance", 3, "100px"),
    fe = At(a, "rounded", 3, !1),
    ie = At(a, "cone", 3, !1),
    $ = At(a, "noGravity", 3, !1),
    Se = At(a, "xSpread", 3, .15),
    Me = At(a, "destroyOnComplete", 3, !0),
    Pe = At(a, "disableForReducedMotion", 3, !1);
  let Ie = et(!1);
  ri(() => {
    !Me() || b() || typeof te() == "string" || setTimeout(() => Y(Ie, !0), (z() + s()[1]) * te())
  });

  function Ce(He, we) {
    return Math.random() * (we - He) + He
  }

  function je() {
    return q().length ? q()[Math.round(Math.random() * (q().length - 1))] : `hsl(${Math.round(Ce(F()[0],F()[1]))}, 75%, 50%)`
  }
  var Ye = or(),
    qe = xt(Ye);
  {
    var Be = He => {
      var we = a7();
      let it;
      fi(we, 21, () => ({
        length: J()
      }), $h, (mt, Ge) => {
        var Xe = i7();
        Ue((vt, Ut, _t, wt, Je, zt, bt, Rt, Pt, yt, sr) => bs(Xe, `
        --color: ${vt??""};
        --skew: ${Ut??""}deg,${_t??""}deg;
        --rotation-xyz: ${wt??""}, ${Je??""}, ${zt??""};
        --rotation-deg: ${bt??""}deg;
        --translate-y-multiplier: ${Rt??""};
        --translate-x-multiplier: ${Pt??""};
        --scale: ${yt??""};
        --transition-delay: ${sr??""}ms;
        --transition-duration: ${b()?`calc(${z()}ms * var(--scale))`:`${z()}ms`};`), [je, () => Ce(-45, 45), () => Ce(-45, 45), () => Ce(-10, 10), () => Ce(-10, 10), () => Ce(-10, 10), () => Ce(0, 360), () => Ce(A()[0], A()[1]), () => Ce(x()[0], x()[1]), () => .1 * Ce(2, 10), () => Ce(s()[0], s()[1])]), Z(mt, Xe)
      }), C(we), Ue(() => {
        it = qr(we, 1, "confetti-holder svelte-av71ki", null, it, {
          rounded: fe(),
          cone: ie(),
          "no-gravity": $(),
          "reduced-motion": Pe()
        }), bs(we, `
    --fall-distance: ${ae()??""};
    --size: ${d()??""}px;
    --x-spread: ${1-Se()};
    --transition-iteration-count: ${(b()?"infinite":te())??""};`)
      }), Z(He, we)
    };
    Ee(qe, He => {
      _(Ie) || He(Be)
    })
  }
  Z(m, Ye), $r()
}
var o7 = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  s7 = me('<!> <span class="text-sm">Droplets</span>', 1),
  l7 = me('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1),
  c7 = me('<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>'),
  u7 = me('<dialog class="modal !bg-black/80"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function h7(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15);
  const x = ut(() => La.colors[a.colorIdx]),
    A = ut(() => {
      var fe;
      return ((fe = Dt.data) == null ? void 0 : fe.droplets) ?? 0
    });
  let z = et(!1);
  const b = ut(() => (_(z), Dt.hasColor(a.colorIdx)));
  ri(() => {
    const fe = ie => {
      ie.key === "Escape" && d(!1)
    };
    return document.addEventListener("keydown", fe), () => document.removeEventListener("keydown", fe)
  });
  const s = 100,
    F = La.products[s];
  var q = u7(),
    J = I(q),
    te = O(I(J), 2);
  {
    var ae = fe => {
      var ie = c7(),
        $ = I(ie),
        Se = I($),
        Me = I(Se);
      jp(Me, {
        class: "size-6"
      });
      var Pe = O(Me, 4),
        Ie = I(Pe);
      z0(Ie, {
        get value() {
          return _(A)
        }
      }), C(Pe), C(Se), wn(2), C($);
      var Ce = O($, 2),
        je = I(Ce),
        Ye = I(je);
      C(je);
      var qe = O(je, 2),
        Be = I(qe, !0);
      C(qe);
      var He = O(qe, 2),
        we = I(He);
      let it;
      var mt = I(we);
      mt.__click = async () => {
        try {
          Y(z, !0), await fn.purchase({
            id: s,
            amount: 1,
            variant: a.colorIdx
          }), await Dt.refresh(), xi.notification1.play()
        } catch (Je) {
          Xt.error(Je.message)
        } finally {
          Y(z, !1)
        }
      };
      var Ge = I(mt);
      {
        var Xe = Je => {
          var zt = o7();
          Z(Je, zt)
        };
        Ee(Ge, Je => {
          _(z) && Je(Xe)
        })
      }
      var vt = O(Ge, 2);
      {
        var Ut = Je => {
            var zt = s7(),
              bt = xt(zt);
            Yp(bt, {
              class: "size-5"
            });
            var Rt = O(bt);
            wn(), Ue(Pt => ce(Rt, ` ${Pt??""} `), [() => F.price.toLocaleString("en-US")]), Z(Je, zt)
          },
          _t = Je => {
            var zt = l7(),
              bt = xt(zt);
            jp(bt, {
              class: "size-5"
            });
            var Rt = O(bt, 2),
              Pt = I(Rt);
            qg(Pt, {}), C(Rt), Z(Je, zt)
          };
        Ee(vt, Je => {
          _(b) ? Je(_t, !1) : Je(Ut)
        })
      }
      C(mt), C(we);
      var wt = O(we, 2);
      wt.__click = () => d(!1), C(He), C(Ce), C(ie), Ue(Je => {
        bs(Ye, `background: rgb(${_(x).rgb[0]} ${_(x).rgb[1]} ${_(x).rgb[2]})`), cr(Ye, "aria-label", _(x).name), ce(Be, _(x).name), cr(we, "data-tip", Je), it = qr(we, 1, "", null, it, {
          tooltip: !_(b) && _(A) < F.price
        }), mt.disabled = _(A) < F.price || _(z) || _(b)
      }, [() => rf()]), Z(fe, ie)
    };
    Ee(te, fe => {
      Dt.data && fe(ae)
    })
  }
  C(J), wn(2), C(q), Di(q, () => fe => {
    tn(() => {
      d() ? fe.show() : fe.close()
    })
  }), Ln("close", q, () => d(!1)), Z(m, q), $r()
}
ni(["click"]);
var d7 = jr('<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>');

function uh(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = d7();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var p7 = jr('<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>');

function b0(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = p7();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var f7 = jr('<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>');

function Yy(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = f7();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var m7 = jr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>'),
  g7 = jr('<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>');

function Ky(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = or(),
    A = xt(x);
  {
    var z = s => {
        var F = m7();
        _r(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...d
        })), Z(s, F)
      },
      b = s => {
        var F = g7();
        _r(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...d
        })), Z(s, F)
      };
    Ee(A, s => {
      a.filled ? s(z) : s(b, !1)
    })
  }
  Z(m, x)
}
var _7 = jr('<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>');

function sg(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = _7();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var v7 = jr('<svg><path d="M396-200q-97 0-166.5-63T160-420q0-94 69.5-157T396-640h252L544-744l56-56 200 200-200 200-56-56 104-104H396q-63 0-109.5 40T240-420q0 60 46.5 100T396-280h284v80H396Z"></path></svg>');

function y7(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = v7();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var x7 = jr('<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>');

function Jy(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = x7();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var b7 = jr('<svg><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"></path></svg>');

function w7(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = b7();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var T7 = jr('<svg><path d="m356-160-56-56 180-180 180 180-56 56-124-124-124 124Zm124-404L300-744l56-56 124 124 124-124 56 56-180 180Z"></path></svg>');

function S7(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = T7();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var P7 = jr('<svg><path d="M480-120 300-300l58-58 122 122 122-122 58 58-180 180ZM358-598l-58-58 180-180 180 180-58 58-122-122-122 122Z"></path></svg>');

function C7(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = P7();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var I7 = me("<!> ", 1),
  M7 = me("<!> ", 1),
  A7 = me("<!> ", 1),
  k7 = me('<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ', 1),
  E7 = me("<!> ", 1),
  L7 = me("<!> <!>", 1),
  z7 = me('<div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button><!></button></div>'),
  D7 = me('<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>', 1),
  R7 = me("<div><button><!></button></div>"),
  F7 = me('<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1.5"><h2 class="sm:min-w-38 select-none text-xl"> <!></h2> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip max-sm:hidden"><button title="Toggle art opacity"><!></button></div> <!> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">Ctrl+Z</kbd></div> <button title="Undo"><!></button></div> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">Ctrl+Y</kbd></div> <button title="Redo"><!></button></div></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>', 1);

function B7(m, a) {
  var dn, nn;
  Wr(a, !0);
  let d = At(a, "screenLocked", 15),
    x = At(a, "opaquePixelArt", 15);
  const A = ut(() => new Oa(a.tileSize));
  let z = et(1),
    b = et("pencil");
  const s = new Map,
    F = new Map;
  let q = et(0),
    J = et(!1),
    te = et(!0),
    ae = ut(() => Dt.charges ?? 0),
    fe = ut(() => _(ae) - _(q)),
    ie = et(!1),
    $ = !1,
    Se = et(!1),
    Me = et(zi([]));
  const Pe = ut(() => _(b) === "pencil"),
    Ie = ut(() => _(b) === "eraser"),
    Ce = ut(() => _(b) === "colorpicker"),
    je = ut(() => _(b) === "cleararea"),
    Ye = ut(() => {
      var Ke, St;
      return Ea((St = (Ke = Dt) == null ? void 0 : Ke.data) == null ? void 0 : St.role, ["admin", "global_moderator", "moderator"])
    });
  let qe = et(!1),
    Be = et(0),
    He = et(void 0),
    we = et(void 0);
  const it = [1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42, 12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49, 23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52, 61, 62, 63, 58, 59, 60, 0].map(Ke => ({
      ...La.colors[Ke],
      idx: Ke
    })),
    mt = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0].map(Ke => ({
      ...La.colors[Ke],
      idx: Ke
    }));
  let Ge = et(!1);
  const Xe = ut(() => _(Ge) ? it : mt),
    vt = "show-all-colors";
  ri(() => {
    Y(Ge, localStorage.getItem(vt) === "true")
  }), tn(() => {
    localStorage.setItem(vt, _(Ge) ? "true" : "false")
  });
  const Ut = "selected-color";
  ri(() => {
    const Ke = Number(localStorage.getItem(Ut));
    !isNaN(Ke) && Ke < La.colors.length && Ke > 0 && Y(z, Ke, !0)
  }), tn(() => {
    localStorage.setItem(Ut, _(z).toString())
  });
  const _t = new KR({
    map: a.map,
    tileSize: a.tileSize,
    tileZoom: a.tileZoom,
    beforeLayerId: a.hoverLayerId
  });
  tn(() => {
    const Ke = x() ? 1 : 0;
    _t.setCanvasOpacity(Ke)
  }), tn(() => {
    x() ? Im() : yt([...s.values()])
  });
  let wt = !1;
  ri(() => {
    ps(a.map.getCenter(), a.map.getZoom());
    const Ke = a.map.on("click", cn => {
      var Xn;
      a.zoom < a.tileZoom + 2 && ((Xn = Dt.data) == null ? void 0 : Xn.role) === "user" && a.map.easeTo({
        center: cn.lngLat,
        zoom: 17
      });
      const kn = [cn.lngLat.lat, cn.lngLat.lng];
      if (_(Pe)) zt([kn], _(z)), Zt.finishAction();
      else if (_(Ie)) bt([kn]), Zt.finishAction();
      else if (_(Ce)) Rt(kn, cn.point);
      else if (_(je) && (_(Me).push(kn), zt([kn], 0), _(Me).length >= 2)) {
        const [Ri, Ii] = _(Me), [Vi, pt] = _(A).latLonToPixelsFloor(Ri[0], Ri[1], a.tileZoom), [$t, Or] = _(A).latLonToPixelsFloor(Ii[0], Ii[1], a.tileZoom), on = Math.min(Vi, $t), Er = Math.max(Vi, $t), Hn = Math.min(pt, Or), jn = Math.max(pt, Or), Cn = [];
        for (let Yn = Hn; Yn <= jn; Yn++) {
          const vr = _(A).pixelsToLatLon(on + .5, Yn + .5, a.tileZoom),
            ar = _(A).pixelsToLatLon(Er + .5, Yn + .5, a.tileZoom),
            gr = St({
              lat: vr[0],
              lng: vr[1]
            }, {
              lat: ar[0],
              lng: ar[1]
            }).slice(0, _(fe) - Cn.length);
          if (Cn.push(...gr), Cn.length >= _(fe)) break
        }
        zt(Cn, 0), Y(Me, [], !0), Y(b, "pencil"), Zt.finishAction()
      }
      Y(ie, !0)
    });

    function St(cn, kn) {
      const Xn = _(A).latLonToPixels(cn.lat, cn.lng, a.tileZoom),
        Ri = kn ? _(A).latLonToPixels(kn.lat, kn.lng, a.tileZoom) : Xn;
      return Db(Xn, Ri).map(Vi => _(A).pixelsToLatLon(Vi[0] + .5, Vi[1] + .5, a.tileZoom))
    }

    function kr(cn, kn) {
      const Xn = St(cn, kn);
      _(Pe) ? zt(Xn, _(z)) : _(Ie) && bt(Xn), Y(ie, !0)
    }
    let wr;

    function mr(cn) {
      const kn = a.map.unproject([cn.clientX, cn.clientY]);
      if (_(Se)) {
        const Xn = St(kn, wr);
        bt(Xn)
      }(wt || $) && kr(kn, wr), wr = kn
    }
    window.addEventListener("mousemove", mr);
    let Mr = !1;
    const gn = a.map.on("touchstart", cn => {
        if (cn.points.length == 2) {
          d(!1), ht(), Mr = !0, setTimeout(() => Mr = !1, 150);
          return
        }
        d() && setTimeout(() => {
          !Mr && kr(cn.lngLat)
        }, 150), wr = cn.lngLat
      }),
      Rn = a.map.on("touchend", () => {
        Zt.finishAction()
      }),
      ln = a.map.on("touchmove", cn => {
        d() && kr(cn.lngLat, wr), wr = cn.lngLat
      }),
      Gn = cn => {
        cn.code === "Space" && (wt || wr && kr(wr), wt = !0, cn.preventDefault())
      };
    document.addEventListener("keydown", Gn);
    const On = cn => {
      cn.code === "Space" && (wt = !1, Je = !1, Zt.finishAction(), _(q) === 0 && _(Ie) && Y(b, "pencil"))
    };
    document.addEventListener("keyup", On);

    function Wn(cn) {
      if (cn.button === 2) {
        Y(Se, !0);
        const Xn = a.map.unproject([cn.clientX, cn.clientY]);
        bt([
          [Xn.lat, Xn.lng]
        ])
      }
    }
    document.addEventListener("mousedown", Wn);

    function ti(cn) {
      cn.button === 2 && Y(Se, !1)
    }
    document.addEventListener("mouseup", ti);
    const Zn = cn => {
      switch (cn.code) {
        case "KeyE":
          _(q) > 0 && (_(Ie) ? Y(b, "pencil") : Y(b, "eraser"));
          return;
        case "KeyI":
          Y(b, "colorpicker");
          return;
        case "KeyC":
          _(Ye) && Y(b, "cleararea");
          return
      }
    };
    return document.addEventListener("keypress", Zn), () => {
      ln.unsubscribe(), gn.unsubscribe(), Rn.unsubscribe(), Ke.unsubscribe(), document.removeEventListener("mousemove", mr), document.removeEventListener("keydown", Gn), document.removeEventListener("keyup", On), document.removeEventListener("keypress", Zn), document.removeEventListener("mousedown", Wn), document.removeEventListener("mouseup", ti), sr()
    }
  });
  let Je = !1;

  function zt(Ke, St, kr = !0) {
    let wr = !1;
    const mr = St === 0;
    for (let Mr of Ke) {
      const [gn, Rn] = Mr, ln = gg(St), {
        tile: Gn,
        pixel: On
      } = _(A).latLonToTileAndPixel(gn, Rn, a.tileZoom), Wn = {
        color: ln,
        tile: Gn,
        pixel: On,
        season: a.season,
        colorIdx: St
      }, ti = mm(Wn), Zn = s.get(ti), cn = _(ae) - s.size;
      if (!Zn && cn < 1) {
        if (Je && (wt || d())) continue;
        Je = !0, Xt.info(KP());
        continue
      }
      if (!(Zn && Zn.colorIdx === St) && (xi.plop.play(), wr || a.hidePixelHover(), s.set(ti, Wn), _t.place(Mr, St), a.crosshair.place(Mr), wr = !0, mr && F.set(ti, Wn), kr)) {
        const kn = {
            type: "paint",
            latLons: [Mr],
            colorIdx: St
          },
          Xn = Zn ? {
            type: "paint",
            latLons: [Mr],
            colorIdx: Zn.colorIdx
          } : {
            type: "erase",
            latLons: [Mr]
          };
        Zt.saveAction(kn, Xn)
      }
    }
    Y(q, s.size, !0), wr && !x() ? yt([...s.values()]) : wr && x() && mr && yt([...F.values()])
  }

  function bt(Ke, St = !0) {
    let kr = !1,
      wr = !1;
    for (let mr of Ke) {
      const [Mr, gn] = mr, {
        tile: Rn,
        pixel: ln
      } = _(A).latLonToTileAndPixel(Mr, gn, a.tileZoom), Gn = mm({
        tile: Rn,
        pixel: ln,
        season: a.season
      }), On = s.get(Gn);
      On && (xi.plop.play(), a.hidePixelHover(), s.delete(Gn), F.delete(Gn), _t.remove([Mr, gn]), a.crosshair.remove(mr), kr = !0, On.colorIdx === 0 && (wr = !0), St && Zt.saveAction({
        type: "erase",
        latLons: [mr]
      }, {
        type: "paint",
        latLons: [mr],
        colorIdx: On.colorIdx
      })), s.size === 0 && !(wt || $ || d()) && Y(b, "pencil")
    }
    Y(q, s.size, !0), kr && !x() ? yt([...s.values()]) : kr && x() && wr && yt([...F.values()])
  }

  function Rt(Ke, St) {
    const {
      tile: kr,
      pixel: wr
    } = _(A).latLonToTileAndPixel(Ke[0], Ke[1], a.tileZoom), mr = mm({
      tile: kr,
      pixel: wr,
      season: a.season
    }), Mr = s.get(mr);
    if (Mr) {
      It(Mr.colorIdx), requestAnimationFrame(() => {
        var Gn;
        (Gn = document.getElementById(`color-${Mr.colorIdx}`)) == null || Gn.focus()
      });
      return
    }
    const gn = window.devicePixelRatio,
      Rn = Math.floor(St.x * gn),
      ln = Math.floor(St.y * gn);
    a.hidePixelHover(), Y8(a.map, Rn, ln).then(([Gn, On, Wn]) => {
      const ti = R0({
        r: Gn,
        g: On,
        b: Wn
      });
      It(ti), requestAnimationFrame(() => {
        var Zn;
        (Zn = document.getElementById(`color-${ti}`)) == null || Zn.focus()
      })
    })
  }
  Gs(() => _(z), () => {
    a.clickedLatLon && !_(ie) && (_(z) === void 0 && Y(z, 1), zt([a.clickedLatLon], _(z)))
  }), tn(() => {
    const Ke = _(te) ? .8 : 0;
    a.crosshair.setCanvasOpacity(Ke)
  });
  let Pt = et(16.5);
  tn(() => {
    if (_(He) && _(we) && a.clickedLatLon) {
      const Ke = a.map.getZoom();
      if (Ke < _(Pt)) {
        const [St, kr] = a.clickedLatLon, wr = _(A).latLonToPixelBoundsLatLon(St, kr, a.tileZoom), mr = kg(wr), Mr = _(He) - _(we).clientHeight, gn = _(He) / 2 - Mr / 2;
        a.map.flyTo({
          center: {
            lat: mr[0],
            lng: mr[1]
          },
          zoom: 17.5,
          offset: Ke > 11 ? [0, -gn] : [0, 0]
        })
      }
      Y(Pt, a.tileZoom, !0)
    }
  }), ri(() => {
    const Ke = () => {
      !document.hidden && (x() ? yt([...F.values()]) : yt([...s.values()]))
    };
    return document.addEventListener("visibilitychange", Ke), () => document.removeEventListener("visibilitychange", Ke)
  }), tn(() => {
    switch (_(b)) {
      case "pencil":
        a.map.getCanvas().style.cursor = `url('${XR}') 8 8, default`, a.map.setPaintProperty(a.hoverLayerId, "raster-opacity", .4);
        return;
      case "colorpicker":
        a.map.getCanvas().style.cursor = `url('${WR}') 0 16, default`, a.map.setPaintProperty(a.hoverLayerId, "raster-opacity", 0);
        return;
      case "eraser":
        a.map.getCanvas().style.cursor = `url('${$R}') 2 14, default`, a.map.setPaintProperty(a.hoverLayerId, "raster-opacity", .4);
        return
    }
  }), tn(() => {
    d() ? tt() : ht()
  });
  async function yt(Ke) {
    await Lb(Ke), a.refreshPixelArt()
  }
  async function sr() {
    await Im(), _t.clear(), a.refreshPixelArt(), a.crosshair.clear()
  }
  async function tr() {
    await sr(), ht(), a.map.getCanvas().style.cursor = "default", a.map.setPaintProperty(a.hoverLayerId, "raster-opacity", .4), Zt.clear(), a.onclose()
  }

  function tt() {
    a.map.dragPan.disable(), a.map.touchZoomRotate.disable(), document.documentElement.style.overscrollBehavior = "none"
  }

  function ht() {
    a.map.dragPan.enable(), a.map.touchZoomRotate.enable(), document.documentElement.style.overscrollBehavior = ""
  }

  function It(Ke) {
    return Ke >= 32 && Y(Ge, !0), Dt.hasColor(Ke) ? (xi.smallDropplet.play(), Y(z, Ke, !0), Y(b, "pencil"), !0) : (xi.smallDropplet.play(), Y(qe, !0), Y(Be, Ke, !0), !1)
  }
  xb(Ke => {
    Ke.type === "leave" && _(q) > 0 && Ke.cancel()
  });
  const Bt = "show-paint-more-than-one-pixel-msg";
  let Nt = et(!1);
  ri(() => {
    var Ke;
    Y(Nt, !localStorage.getItem(Bt) && (((Ke = Dt.data) == null ? void 0 : Ke.pixelsPainted) ?? 0) < 100, !0)
  }), tn(() => {
    _(q) > 1 && (Y(Nt, !1), localStorage.setItem(Bt, "false"))
  });
  const Ht = "lp";
  ri(() => {
    var St;
    const Ke = localStorage.getItem(Ht);
    if (Ke) try {
      const kr = JSON.parse(atob(Ke)),
        wr = (kr == null ? void 0 : kr.time) ?? 0,
        mr = 60 * 1e3;
      (kr == null ? void 0 : kr.userId) !== ((St = Dt.data) == null ? void 0 : St.id) && Date.now() - wr < 30 * mr && !u2 && (Xt.error(eC()), tr())
    } catch (kr) {
      console.error(kr)
    }
  });

  function yr() {
    var St;
    const Ke = btoa(JSON.stringify({
      userId: (St = Dt.data) == null ? void 0 : St.id,
      time: Date.now()
    }));
    localStorage.setItem(Ht, Ke)
  }
  class Wt {
    constructor() {
      Nr(this, "history", []);
      Nr(this, "actionInProgress", !1);
      Nr(this, "historyIdx", -1);
      Zr(this, dn, et(!1));
      Zr(this, nn, et(!1))
    }
    get canUndo() {
      return _(Qe(this, dn))
    }
    set canUndo(St) {
      Y(Qe(this, dn), St, !0)
    }
    get canRedo() {
      return _(Qe(this, nn))
    }
    set canRedo(St) {
      Y(Qe(this, nn), St, !0)
    }
    undo() {
      if (this.historyIdx < 0) return;
      const St = this.history[this.historyIdx],
        kr = this.mergeActions(St.undo);
      for (const wr of kr) this.applyAction(wr);
      this.historyIdx--, this.refreshCanUndoRedo()
    }
    redo() {
      if (this.historyIdx >= this.history.length - 1) return;
      this.historyIdx++;
      const St = this.history[this.historyIdx],
        kr = this.mergeActions(St.redo);
      for (const wr of kr) this.applyAction(wr);
      this.refreshCanUndoRedo()
    }
    saveAction(St, kr) {
      this.actionInProgress || (this.historyIdx < this.history.length - 1 && (this.history = this.history.slice(0, this.historyIdx + 1)), this.actionInProgress = !0, this.historyIdx++, this.history.push({
        redo: [],
        undo: []
      }));
      const wr = this.history[this.historyIdx];
      wr.redo.push(St), wr.undo.push(kr)
    }
    finishAction() {
      this.actionInProgress = !1, this.refreshCanUndoRedo()
    }
    clear() {
      this.history = [], this.actionInProgress = !1, this.historyIdx = -1, this.refreshCanUndoRedo()
    }
    mergeActions(St) {
      const kr = {
          type: "erase",
          latLons: []
        },
        wr = new Map;
      for (const Mr of St)
        if (Mr.type === "erase") kr.latLons.push(...Mr.latLons);
        else {
          const gn = wr.get(Mr.colorIdx);
          gn ? gn.latLons.push(...Mr.latLons) : wr.set(Mr.colorIdx, {
            type: "paint",
            colorIdx: Mr.colorIdx,
            latLons: [...Mr.latLons]
          })
        } const mr = [];
      if (kr.latLons.length > 0 && mr.push(kr), wr.size > 0)
        for (const Mr of wr.values()) mr.push(Mr);
      return mr
    }
    applyAction(St) {
      switch (St.type) {
        case "paint":
          zt(St.latLons, St.colorIdx, !1);
          break;
        case "erase":
          bt(St.latLons, !1);
          break
      }
    }
    refreshCanUndoRedo() {
      this.canUndo = this.historyIdx >= 0, this.canRedo = this.historyIdx < this.history.length - 1
    }
  }
  dn = new WeakMap, nn = new WeakMap;
  const Zt = new Wt;
  var jt = F7();
  Ln("keypress", Zs, Ke => {
    switch (console.log(Ke), Ke.code) {
      case "KeyZ":
        (Ke.ctrlKey || Ke.metaKey) && (Ke.shiftKey ? Zt.redo() : Zt.undo());
        break;
      case "KeyY":
        (Ke.ctrlKey || Ke.metaKey) && Zt.redo()
    }
  });
  var Jt = xt(jt),
    Lt = I(Jt);
  {
    var Gt = Ke => {
        yl(Ke, {
          children: (St, kr) => {
            var wr = I7(),
              mr = xt(wr);
            Yy(mr, {
              class: "inline size-5"
            });
            var Mr = O(mr);
            Ue(gn => ce(Mr, ` ${gn??""}`), [() => E3()]), Z(St, wr)
          },
          $$slots: {
            default: !0
          }
        })
      },
      Yt = Ke => {
        var St = or(),
          kr = xt(St);
        {
          var wr = Mr => {
              yl(Mr, {
                class: "not-touchscreen:hidden",
                children: (gn, Rn) => {
                  var ln = M7(),
                    Gn = xt(ln);
                  Mm(Gn, {
                    class: "inline size-5"
                  });
                  var On = O(Gn);
                  Ue(Wn => ce(On, ` ${Wn??""}`), [() => D3()]), Z(gn, ln)
                },
                $$slots: {
                  default: !0
                }
              })
            },
            mr = Mr => {
              var gn = or(),
                Rn = xt(gn);
              {
                var ln = On => {
                    yl(On, {
                      class: "not-touchscreen:hidden",
                      children: (Wn, ti) => {
                        var Zn = A7(),
                          cn = xt(Zn);
                        b0(cn, {
                          class: "inline size-5"
                        });
                        var kn = O(cn, 1, !0);
                        Ue(Xn => ce(kn, Xn), [() => B3()]), Z(Wn, Zn)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  },
                  Gn = On => {
                    var Wn = or(),
                      ti = xt(Wn);
                    {
                      var Zn = kn => {
                          yl(kn, {
                            class: "touchscreen:hidden",
                            children: (Xn, Ri) => {
                              var Ii = k7(),
                                Vi = xt(Ii);
                              Jy(Vi, {
                                class: "inline size-5"
                              });
                              var pt = O(Vi),
                                $t = I(pt, !0);
                              C(pt);
                              var Or = O(pt, 2),
                                on = I(Or),
                                Er = O(on),
                                Hn = I(Er, !0);
                              C(Er), C(Or);
                              var jn = O(Or);
                              Ue((Cn, Yn, vr, ar) => {
                                ce($t, Cn), ce(on, `${Yn??""} `), ce(Hn, vr), ce(jn, ` ${ar??""}`)
                              }, [() => j3(), () => H3(), () => U3(), () => X3()]), Z(Xn, Ii)
                            },
                            $$slots: {
                              default: !0
                            }
                          })
                        },
                        cn = kn => {
                          var Xn = or(),
                            Ri = xt(Xn);
                          {
                            var Ii = pt => {
                                yl(pt, {
                                  class: "bg-warning text-warning-content animate-bounce",
                                  children: ($t, Or) => {
                                    var on = E7(),
                                      Er = xt(on);
                                    Il(Er, {
                                      class: "inline size-5"
                                    });
                                    var Hn = O(Er);
                                    Ue(jn => ce(Hn, ` ${jn??""}`), [() => J3()]), Z($t, on)
                                  },
                                  $$slots: {
                                    default: !0
                                  }
                                })
                              },
                              Vi = pt => {
                                var $t = or(),
                                  Or = xt($t);
                                {
                                  var on = Er => {
                                    yl(Er, {
                                      class: "bg-warning text-warning-content animate-bounce",
                                      children: (Hn, jn) => {
                                        var Cn = L7(),
                                          Yn = xt(Cn);
                                        uh(Yn, {
                                          class: "inline size-5"
                                        });
                                        var vr = O(Yn, 2);
                                        {
                                          var ar = zr => {
                                              var Fn = qi();
                                              Ue(xn => ce(Fn, xn), [() => Q0()]), Z(zr, Fn)
                                            },
                                            gr = zr => {
                                              var Fn = or(),
                                                xn = xt(Fn);
                                              {
                                                var In = qn => {
                                                  var $n = qi();
                                                  Ue(Mn => ce($n, Mn), [() => ey()]), Z(qn, $n)
                                                };
                                                Ee(xn, qn => {
                                                  _(Me).length === 1 && qn(In)
                                                }, !0)
                                              }
                                              Z(zr, Fn)
                                            };
                                          Ee(vr, zr => {
                                            _(Me).length === 0 ? zr(ar) : zr(gr, !1)
                                          })
                                        }
                                        Z(Hn, Cn)
                                      },
                                      $$slots: {
                                        default: !0
                                      }
                                    })
                                  };
                                  Ee(Or, Er => {
                                    _(je) && Er(on)
                                  }, !0)
                                }
                                Z(pt, $t)
                              };
                            Ee(Ri, pt => {
                              _(Nt) ? pt(Ii) : pt(Vi, !1)
                            }, !0)
                          }
                          Z(kn, Xn)
                        };
                      Ee(ti, kn => {
                        _(Pe) && _(q) === 0 ? kn(Zn) : kn(cn, !1)
                      }, !0)
                    }
                    Z(On, Wn)
                  };
                Ee(Rn, On => {
                  _(Ce) ? On(ln) : On(Gn, !1)
                }, !0)
              }
              Z(Mr, gn)
            };
          Ee(kr, Mr => {
            _(Ie) ? Mr(wr) : Mr(mr, !1)
          }, !0)
        }
        Z(Ke, St)
      };
    Ee(Lt, Ke => {
      _(Ie) && _(q) === 0 ? Ke(Gt) : Ke(Yt, !1)
    })
  }
  var Lr = O(Lt, 2),
    Ir = I(Lr);
  Ir.__click = () => Y(te, !_(te));
  var Jr = I(Ir);
  {
    var Tr = Ke => {
        e7(Ke, {
          class: "size-4"
        })
      },
      Ar = Ke => {
        r7(Ke, {
          class: "size-4"
        })
      };
    Ee(Jr, Ke => {
      _(te) ? Ke(Tr) : Ke(Ar, !1)
    })
  }
  C(Ir);
  var xr = O(Ir, 2),
    qt = I(xr),
    Yr = I(qt),
    Le = O(Yr);
  $y(Le, {
    class: "inline",
    fontSize: 14,
    get value() {
      return `(${_(q)??""})`
    },
    mono: !0
  }), C(qt);
  var j = O(qt, 2),
    E = I(j),
    D = I(E);
  wn(), C(E);
  var N = O(E, 2);
  N.__click = () => {
    Y(b, "colorpicker")
  };
  var X = I(N);
  b0(X, {
    class: "size-4.5"
  }), C(N), C(j);
  var ee = O(j, 2),
    pe = I(ee);
  let be;
  pe.__click = () => {
    x(!x())
  };
  var ye = I(pe);
  {
    let Ke = ut(() => !x());
    Ky(ye, {
      class: "size-4.5",
      get filled() {
        return _(Ke)
      }
    })
  }
  C(pe), C(ee);
  var Oe = O(ee, 2);
  {
    var oe = Ke => {
      var St = z7(),
        kr = I(St),
        wr = I(kr);
      wn(), C(kr);
      var mr = O(kr, 2);
      mr.__click = () => {
        Y(b, "cleararea")
      };
      var Mr = I(mr);
      uh(Mr, {
        class: "size-4.5"
      }), C(mr), C(St), Ue(gn => {
        ce(wr, `${gn??""} `), qr(mr, 1, ys({
          "btn btn-circle btn-sm": !0,
          "btn-ghost": !_(je),
          "btn-primary": _(je)
        }))
      }, [() => QI()]), Z(Ke, St)
    };
    Ee(Oe, Ke => {
      _(Ye) && Ke(oe)
    })
  }
  var K = O(Oe, 2),
    he = I(K),
    Q = I(he);
  wn(), C(he);
  var ze = O(he, 2);
  let $e;
  ze.__click = () => {
    Zt.undo()
  };
  var Re = I(ze);
  w7(Re, {
    class: "size-4.5"
  }), C(ze), C(K);
  var ft = O(K, 2),
    Mt = I(ft),
    Et = I(Mt);
  wn(), C(Mt);
  var dt = O(Mt, 2);
  let Kt;
  dt.__click = () => {
    Zt.redo()
  };
  var Qt = I(dt);
  y7(Qt, {
    class: "size-4.5"
  }), C(dt), C(ft), C(xr);
  var Sr = O(xr, 2);
  Sr.__click = () => {
    xi.smallPlop.play(), tr()
  };
  var Ft = I(Sr);
  ws(Ft, {
    class: "size-4"
  }), C(Sr), C(Lr);
  var Ze = O(Lr, 2),
    Pr = I(Ze);
  fi(Pr, 23, () => _(Xe), Ke => Ke.idx, (Ke, St, kr) => {
    const wr = ut(() => {
        const [Wn, ti, Zn] = _(St).rgb;
        return {
          r: Wn,
          g: ti,
          b: Zn
        }
      }),
      mr = ut(() => _(z) === _(St).idx && _(Pe)),
      Mr = ut(() => _(St).idx === 0),
      gn = ut(() => Dt.hasColor(_(St).idx));
    var Rn = R7(),
      ln = I(Rn);
    ln.__click = () => {
      It(_(St).idx)
    };
    var Gn = I(ln);
    {
      var On = Wn => {
        var ti = D7(),
          Zn = xt(ti);
        sg(Zn, {
          class: "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6"
        });
        var cn = O(Zn, 2),
          kn = I(cn);
        sg(kn, {
          class: "text-base-content/80 size-4"
        }), C(cn), Z(Wn, ti)
      };
      Ee(Gn, Wn => {
        _(gn) || Wn(On)
      })
    }
    C(ln), C(Rn), Ue(() => {
      qr(Rn, 1, ys({
        tooltip: !0,
        "max-sm:h-6": _(Ge),
        "max-sm:before:translate-x-1/4": _(kr) % 8 === 0 && _(St).name.length > 7,
        "max-sm:before:-translate-x-1/4": (_(kr) - 7) % 8 === 0 && _(St).name.length > 7,
        "max-xl:before:translate-x-1/4": _(kr) % 16 === 0 && _(St).name.length > 7,
        "max-xl:before:-translate-x-1/4": (_(kr) - 15) % 16 === 0 && _(St).name.length > 7,
        "xl:before:translate-x-1/4": _(Ge) && _(kr) % 32 === 0 && _(St).name.length > 7,
        "xl:before:-translate-x-1/4": _(Ge) && (_(kr) - 31) % 32 === 0 && _(St).name.length > 7
      })), cr(Rn, "data-tip", _(St).name), qr(ln, 1, ys({
        "btn relative aspect-square w-full rounded-xl": !0,
        "border-primary ring-primary ring-2": _(mr),
        "border-base-300": !_(mr) && _(Mr),
        "border-base-content/20": !_(mr) && !_(Mr),
        "max-sm:h-6 max-sm:rounded-md": _(Ge)
      })), bs(ln, _(Mr) ? `background-image: url(${YR}); background-size: cover; image-rendering: pixelated;` : `background: rgb(${_(wr).r} ${_(wr).g} ${_(wr).b})`), cr(ln, "aria-label", _(St).name), cr(ln, "id", `color-${_(St).idx??""}`)
    }), Ln("focus", ln, () => {
      _(gn) && (Y(z, _(St).idx, !0), Y(b, "pencil"))
    }), Z(Ke, Rn)
  }), C(Pr), C(Ze);
  var br = O(Ze, 2),
    Rr = I(br);
  Rr.__click = () => {
    Y(Ge, !_(Ge))
  };
  var Dr = I(Rr);
  {
    var ot = Ke => {
        S7(Ke, {
          class: "size-5"
        })
      },
      dr = Ke => {
        C7(Ke, {
          class: "size-5"
        })
      };
    Ee(Dr, Ke => {
      _(Ge) ? Ke(ot) : Ke(dr, !1)
    })
  }
  C(Rr);
  var st = O(Rr, 2),
    Tt = I(st);
  {
    let Ke = ut(() => _(q) > 100 ? "animate-pulse" : ""),
      St = ut(() => _(q) === 0 || _(J) || _(fe) < 0);
    Xy(Tt, {
      get class() {
        return _(Ke)
      },
      get charges() {
        return _(fe)
      },
      get disabled() {
        return _(St)
      },
      get loading() {
        return _(J)
      },
      onclick: async () => {
        xi.droppletAndPlop.play();
        const kr = [...s.values()];
        Y(J, !0);
        try {
          const wr = await Dg();
          await fn.paint(kr, wr), await pg(kr), yr(), Dt.refresh(), kp.shouldReload = !0, await tr()
        } catch (wr) {
          Xt.error(`${wr.message}`, {
            duration: 7e3
          })
        } finally {
          Y(J, !1)
        }
      }
    })
  }
  C(st);
  var nr = O(st, 2),
    Ur = I(nr),
    Ot = I(Ur),
    Fr = I(Ot);
  wn(), C(Ot);
  var Xr = O(Ot, 2);
  let mn;
  Xr.__click = () => {
    Y(b, _(b) === "eraser" ? "pencil" : "eraser", !0)
  };
  var sn = I(Xr);
  Mm(sn, {
    class: "size-5",
    get filled() {
      return _(Ie)
    }
  }), C(Xr), C(Ur), C(nr), C(br), C(Jt), lo(Jt, Ke => Y(we, Ke), () => _(we));
  var hn = O(Jt, 2);
  h7(hn, {
    get colorIdx() {
      return _(Be)
    },
    get open() {
      return _(qe)
    },
    set open(Ke) {
      Y(qe, Ke, !0)
    }
  }), Ue((Ke, St, kr, wr, mr, Mr) => {
    ce(Yr, `${Ke??""} `), ce(D, `${St??""} `), qr(N, 1, ys({
      "btn btn-circle btn-sm": !0,
      "btn-ghost": !_(Ce),
      "btn-primary": _(Ce)
    })), cr(ee, "data-tip", kr), be = qr(pe, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, be, {
      "text-primary": !x()
    }), ce(Q, `${wr??""} `), $e = qr(ze, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, $e, {
      "opacity-50": !Zt.canUndo
    }), ze.disabled = !Zt.canUndo, ce(Et, `${mr??""} `), Kt = qr(dt, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, Kt, {
      "opacity-50": !Zt.canRedo
    }), dt.disabled = !Zt.canRedo, qr(Pr, 1, ys({
      "md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
      "xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": _(Ge),
      "gap-1": !_(Ge)
    })), ce(Fr, `${Mr??""} `), mn = qr(Xr, 1, "btn btn-lg btn-square sm:btn-xl shadow-md", null, mn, {
      "btn-primary": _(Ie)
    }), Xr.disabled = _(q) === 0
  }, [() => tT(), () => iT(), () => H0(), () => N6(), () => V6(), () => Rb()]), ef("innerHeight", Ke => Y(He, Ke, !0)), Z(m, jt), $r()
}
ni(["click"]);

function Vg(...m) {
  return O0(rh(m))
}
var O7 = me("<div><!></div>");

function N7(m, a) {
  Wr(a, !0);
  let d = At(a, "ref", 15, null),
    x = fr(a, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]);
  var A = O7();
  _r(A, b => ({
    class: b,
    ...x
  }), [() => Vg("flex items-center", a.class)]);
  var z = I(A);
  bi(z, () => a.children ?? wa), C(A), lo(A, b => d(b), () => d()), Z(m, A), $r()
}
var j7 = me('<div class="pointer-events-none absolute inset-0 flex items-center justify-center"><div class="animate-caret-blink bg-base-content/80 h-4 w-px duration-1000"></div></div>'),
  q7 = me(" <!>", 1);

function V7(m, a) {
  Wr(a, !0);
  let d = At(a, "ref", 15, null),
    x = fr(a, ["$$slots", "$$events", "$$legacy", "ref", "cell", "class"]);
  var A = or(),
    z = xt(A);
  {
    let b = ut(() => Vg("border-input relative flex size-12 items-center justify-center border-y border-r text-xl transition-all first:rounded-l-md first:border-l last:rounded-r-md", a.cell.isActive && "ring-base-content/40 z-10 ring-2", a.class));
    ji(z, () => AD, (s, F) => {
      F(s, Hs({
        get cell() {
          return a.cell
        },
        get class() {
          return _(b)
        }
      }, () => x, {
        get ref() {
          return d()
        },
        set ref(q) {
          d(q)
        },
        children: (q, J) => {
          wn();
          var te = q7(),
            ae = xt(te),
            fe = O(ae);
          {
            var ie = $ => {
              var Se = j7();
              Z($, Se)
            };
            Ee(fe, $ => {
              a.cell.hasFakeCaret && $(ie)
            })
          }
          Ue(() => ce(ae, `${a.cell.char??""} `)), Z(q, te)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  Z(m, A), $r()
}

function U7(m, a) {
  Wr(a, !0);
  let d = At(a, "ref", 15, null),
    x = At(a, "value", 15, ""),
    A = fr(a, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var z = or(),
    b = xt(z);
  {
    let s = ut(() => Vg("flex items-center gap-2 has-[:disabled]:opacity-50 [&_input]:disabled:cursor-not-allowed", a.class));
    ji(b, () => ID, (F, q) => {
      q(F, Hs({
        get class() {
          return _(s)
        }
      }, () => A, {
        get ref() {
          return d()
        },
        set ref(J) {
          d(J)
        },
        get value() {
          return x()
        },
        set value(J) {
          x(J)
        }
      }))
    })
  }
  Z(m, z), $r()
}
var Sm = {
    exports: {}
  },
  w0;

function Z7() {
  return w0 || (w0 = 1, (function(m) {
    (function(a) {
      m.exports ? m.exports = a() : window.intlTelInput = a()
    })(() => {
      var a = (() => {
        var d = Object.defineProperty,
          x = Object.getOwnPropertyDescriptor,
          A = Object.getOwnPropertyNames,
          z = Object.prototype.hasOwnProperty,
          b = (Le, j) => {
            for (var E in j) d(Le, E, {
              get: j[E],
              enumerable: !0
            })
          },
          s = (Le, j, E, D) => {
            if (j && typeof j == "object" || typeof j == "function")
              for (let N of A(j)) !z.call(Le, N) && N !== E && d(Le, N, {
                get: () => j[N],
                enumerable: !(D = x(j, N)) || D.enumerable
              });
            return Le
          },
          F = Le => s(d({}, "__esModule", {
            value: !0
          }), Le),
          q = {};
        b(q, {
          Iti: () => Tr,
          default: () => Yr
        });
        var J = [
            ["af", "93", 0, null, "0"],
            ["ax", "358", 1, ["18", "4"], "0"],
            ["al", "355", 0, null, "0"],
            ["dz", "213", 0, null, "0"],
            ["as", "1", 5, ["684"], "1"],
            ["ad", "376"],
            ["ao", "244"],
            ["ai", "1", 6, ["264"], "1"],
            ["ag", "1", 7, ["268"], "1"],
            ["ar", "54", 0, null, "0"],
            ["am", "374", 0, null, "0"],
            ["aw", "297"],
            ["ac", "247"],
            ["au", "61", 0, ["4"], "0"],
            ["at", "43", 0, null, "0"],
            ["az", "994", 0, null, "0"],
            ["bs", "1", 8, ["242"], "1"],
            ["bh", "973"],
            ["bd", "880", 0, null, "0"],
            ["bb", "1", 9, ["246"], "1"],
            ["by", "375", 0, null, "8"],
            ["be", "32", 0, null, "0"],
            ["bz", "501"],
            ["bj", "229"],
            ["bm", "1", 10, ["441"], "1"],
            ["bt", "975"],
            ["bo", "591", 0, null, "0"],
            ["ba", "387", 0, null, "0"],
            ["bw", "267"],
            ["br", "55", 0, null, "0"],
            ["io", "246"],
            ["vg", "1", 11, ["284"], "1"],
            ["bn", "673"],
            ["bg", "359", 0, null, "0"],
            ["bf", "226"],
            ["bi", "257"],
            ["kh", "855", 0, null, "0"],
            ["cm", "237"],
            ["ca", "1", 1, ["204", "226", "236", "249", "250", "257", "263", "289", "306", "343", "354", "365", "367", "368", "382", "403", "416", "418", "428", "431", "437", "438", "450", "468", "474", "506", "514", "519", "548", "579", "581", "584", "587", "604", "613", "639", "647", "672", "683", "705", "709", "742", "753", "778", "780", "782", "807", "819", "825", "867", "873", "879", "902", "905", "942"], "1"],
            ["cv", "238"],
            ["bq", "599", 1, ["3", "4", "7"]],
            ["ky", "1", 12, ["345"], "1"],
            ["cf", "236"],
            ["td", "235"],
            ["cl", "56"],
            ["cn", "86", 0, null, "0"],
            ["cx", "61", 2, ["4", "89164"], "0"],
            ["cc", "61", 1, ["4", "89162"], "0"],
            ["co", "57", 0, null, "0"],
            ["km", "269"],
            ["cg", "242"],
            ["cd", "243", 0, null, "0"],
            ["ck", "682"],
            ["cr", "506"],
            ["ci", "225"],
            ["hr", "385", 0, null, "0"],
            ["cu", "53", 0, null, "0"],
            ["cw", "599", 0],
            ["cy", "357"],
            ["cz", "420"],
            ["dk", "45"],
            ["dj", "253"],
            ["dm", "1", 13, ["767"], "1"],
            ["do", "1", 2, ["809", "829", "849"], "1"],
            ["ec", "593", 0, null, "0"],
            ["eg", "20", 0, null, "0"],
            ["sv", "503"],
            ["gq", "240"],
            ["er", "291", 0, null, "0"],
            ["ee", "372"],
            ["sz", "268"],
            ["et", "251", 0, null, "0"],
            ["fk", "500"],
            ["fo", "298"],
            ["fj", "679"],
            ["fi", "358", 0, ["4"], "0"],
            ["fr", "33", 0, null, "0"],
            ["gf", "594", 0, null, "0"],
            ["pf", "689"],
            ["ga", "241"],
            ["gm", "220"],
            ["ge", "995", 0, null, "0"],
            ["de", "49", 0, null, "0"],
            ["gh", "233", 0, null, "0"],
            ["gi", "350"],
            ["gr", "30"],
            ["gl", "299"],
            ["gd", "1", 14, ["473"], "1"],
            ["gp", "590", 0, null, "0"],
            ["gu", "1", 15, ["671"], "1"],
            ["gt", "502"],
            ["gg", "44", 1, ["1481", "7781", "7839", "7911"], "0"],
            ["gn", "224"],
            ["gw", "245"],
            ["gy", "592"],
            ["ht", "509"],
            ["hn", "504"],
            ["hk", "852"],
            ["hu", "36", 0, null, "06"],
            ["is", "354"],
            ["in", "91", 0, null, "0"],
            ["id", "62", 0, null, "0"],
            ["ir", "98", 0, null, "0"],
            ["iq", "964", 0, null, "0"],
            ["ie", "353", 0, null, "0"],
            ["im", "44", 2, ["1624", "74576", "7524", "7624", "7924"], "0"],
            ["il", "972", 0, null, "0"],
            ["it", "39", 0, ["3"]],
            ["jm", "1", 4, ["658", "876"], "1"],
            ["jp", "81", 0, null, "0"],
            ["je", "44", 3, ["1534", "7509", "7700", "7797", "7829", "7937"], "0"],
            ["jo", "962", 0, null, "0"],
            ["kz", "7", 1, ["33", "7"], "8"],
            ["ke", "254", 0, null, "0"],
            ["ki", "686", 0, null, "0"],
            ["xk", "383", 0, null, "0"],
            ["kw", "965"],
            ["kg", "996", 0, null, "0"],
            ["la", "856", 0, null, "0"],
            ["lv", "371"],
            ["lb", "961", 0, null, "0"],
            ["ls", "266"],
            ["lr", "231", 0, null, "0"],
            ["ly", "218", 0, null, "0"],
            ["li", "423", 0, null, "0"],
            ["lt", "370", 0, null, "0"],
            ["lu", "352"],
            ["mo", "853"],
            ["mg", "261", 0, null, "0"],
            ["mw", "265", 0, null, "0"],
            ["my", "60", 0, null, "0"],
            ["mv", "960"],
            ["ml", "223"],
            ["mt", "356"],
            ["mh", "692", 0, null, "1"],
            ["mq", "596", 0, null, "0"],
            ["mr", "222"],
            ["mu", "230"],
            ["yt", "262", 1, ["269", "639"], "0"],
            ["mx", "52"],
            ["fm", "691"],
            ["md", "373", 0, null, "0"],
            ["mc", "377", 0, null, "0"],
            ["mn", "976", 0, null, "0"],
            ["me", "382", 0, null, "0"],
            ["ms", "1", 16, ["664"], "1"],
            ["ma", "212", 0, ["6", "7"], "0"],
            ["mz", "258"],
            ["mm", "95", 0, null, "0"],
            ["na", "264", 0, null, "0"],
            ["nr", "674"],
            ["np", "977", 0, null, "0"],
            ["nl", "31", 0, null, "0"],
            ["nc", "687"],
            ["nz", "64", 0, null, "0"],
            ["ni", "505"],
            ["ne", "227"],
            ["ng", "234", 0, null, "0"],
            ["nu", "683"],
            ["nf", "672"],
            ["kp", "850", 0, null, "0"],
            ["mk", "389", 0, null, "0"],
            ["mp", "1", 17, ["670"], "1"],
            ["no", "47", 0, ["4", "9"]],
            ["om", "968"],
            ["pk", "92", 0, null, "0"],
            ["pw", "680"],
            ["ps", "970", 0, null, "0"],
            ["pa", "507"],
            ["pg", "675"],
            ["py", "595", 0, null, "0"],
            ["pe", "51", 0, null, "0"],
            ["ph", "63", 0, null, "0"],
            ["pl", "48"],
            ["pt", "351"],
            ["pr", "1", 3, ["787", "939"], "1"],
            ["qa", "974"],
            ["re", "262", 0, null, "0"],
            ["ro", "40", 0, null, "0"],
            ["ru", "7", 0, ["33"], "8"],
            ["rw", "250", 0, null, "0"],
            ["ws", "685"],
            ["sm", "378"],
            ["st", "239"],
            ["sa", "966", 0, null, "0"],
            ["sn", "221"],
            ["rs", "381", 0, null, "0"],
            ["sc", "248"],
            ["sl", "232", 0, null, "0"],
            ["sg", "65"],
            ["sx", "1", 21, ["721"], "1"],
            ["sk", "421", 0, null, "0"],
            ["si", "386", 0, null, "0"],
            ["sb", "677"],
            ["so", "252", 0, null, "0"],
            ["za", "27", 0, null, "0"],
            ["kr", "82", 0, null, "0"],
            ["ss", "211", 0, null, "0"],
            ["es", "34"],
            ["lk", "94", 0, null, "0"],
            ["bl", "590", 1, null, "0"],
            ["sh", "290"],
            ["kn", "1", 18, ["869"], "1"],
            ["lc", "1", 19, ["758"], "1"],
            ["mf", "590", 2, null, "0"],
            ["pm", "508", 0, null, "0"],
            ["vc", "1", 20, ["784"], "1"],
            ["sd", "249", 0, null, "0"],
            ["sr", "597"],
            ["sj", "47", 1, ["4", "79", "9"]],
            ["se", "46", 0, null, "0"],
            ["ch", "41", 0, null, "0"],
            ["sy", "963", 0, null, "0"],
            ["tw", "886", 0, null, "0"],
            ["tj", "992"],
            ["tz", "255", 0, null, "0"],
            ["th", "66", 0, null, "0"],
            ["tl", "670"],
            ["tg", "228"],
            ["tk", "690"],
            ["to", "676"],
            ["tt", "1", 22, ["868"], "1"],
            ["tn", "216"],
            ["tr", "90", 0, null, "0"],
            ["tm", "993", 0, null, "8"],
            ["tc", "1", 23, ["649"], "1"],
            ["tv", "688"],
            ["vi", "1", 24, ["340"], "1"],
            ["ug", "256", 0, null, "0"],
            ["ua", "380", 0, null, "0"],
            ["ae", "971", 0, null, "0"],
            ["gb", "44", 0, null, "0"],
            ["us", "1", 0, null, "1"],
            ["uy", "598", 0, null, "0"],
            ["uz", "998"],
            ["vu", "678"],
            ["va", "39", 1, ["06698", "3"]],
            ["ve", "58", 0, null, "0"],
            ["vn", "84", 0, null, "0"],
            ["wf", "681"],
            ["eh", "212", 1, ["5288", "5289", "6", "7"], "0"],
            ["ye", "967", 0, null, "0"],
            ["zm", "260", 0, null, "0"],
            ["zw", "263", 0, null, "0"]
          ],
          te = [];
        for (const Le of J) te.push({
          name: "",
          iso2: Le[0],
          dialCode: Le[1],
          priority: Le[2] || 0,
          areaCodes: Le[3] || null,
          nodeById: {},
          nationalPrefix: Le[4] || null,
          normalisedName: "",
          initials: "",
          dialCodePlus: ""
        });
        var ae = te,
          fe = {
            ad: "Andorra",
            ae: "United Arab Emirates",
            af: "Afghanistan",
            ag: "Antigua & Barbuda",
            ai: "Anguilla",
            al: "Albania",
            am: "Armenia",
            ao: "Angola",
            ar: "Argentina",
            as: "American Samoa",
            at: "Austria",
            au: "Australia",
            aw: "Aruba",
            ax: "√Öland Islands",
            az: "Azerbaijan",
            ba: "Bosnia & Herzegovina",
            bb: "Barbados",
            bd: "Bangladesh",
            be: "Belgium",
            bf: "Burkina Faso",
            bg: "Bulgaria",
            bh: "Bahrain",
            bi: "Burundi",
            bj: "Benin",
            bl: "St. Barth√©lemy",
            bm: "Bermuda",
            bn: "Brunei",
            bo: "Bolivia",
            bq: "Caribbean Netherlands",
            br: "Brazil",
            bs: "Bahamas",
            bt: "Bhutan",
            bw: "Botswana",
            by: "Belarus",
            bz: "Belize",
            ca: "Canada",
            cc: "Cocos (Keeling) Islands",
            cd: "Congo - Kinshasa",
            cf: "Central African Republic",
            cg: "Congo - Brazzaville",
            ch: "Switzerland",
            ci: "C√¥te d‚ÄôIvoire",
            ck: "Cook Islands",
            cl: "Chile",
            cm: "Cameroon",
            cn: "China",
            co: "Colombia",
            cr: "Costa Rica",
            cu: "Cuba",
            cv: "Cape Verde",
            cw: "Cura√ßao",
            cx: "Christmas Island",
            cy: "Cyprus",
            cz: "Czechia",
            de: "Germany",
            dj: "Djibouti",
            dk: "Denmark",
            dm: "Dominica",
            do: "Dominican Republic",
            dz: "Algeria",
            ec: "Ecuador",
            ee: "Estonia",
            eg: "Egypt",
            eh: "Western Sahara",
            er: "Eritrea",
            es: "Spain",
            et: "Ethiopia",
            fi: "Finland",
            fj: "Fiji",
            fk: "Falkland Islands",
            fm: "Micronesia",
            fo: "Faroe Islands",
            fr: "France",
            ga: "Gabon",
            gb: "United Kingdom",
            gd: "Grenada",
            ge: "Georgia",
            gf: "French Guiana",
            gg: "Guernsey",
            gh: "Ghana",
            gi: "Gibraltar",
            gl: "Greenland",
            gm: "Gambia",
            gn: "Guinea",
            gp: "Guadeloupe",
            gq: "Equatorial Guinea",
            gr: "Greece",
            gt: "Guatemala",
            gu: "Guam",
            gw: "Guinea-Bissau",
            gy: "Guyana",
            hk: "Hong Kong SAR China",
            hn: "Honduras",
            hr: "Croatia",
            ht: "Haiti",
            hu: "Hungary",
            id: "Indonesia",
            ie: "Ireland",
            il: "Israel",
            im: "Isle of Man",
            in: "India",
            io: "British Indian Ocean Territory",
            iq: "Iraq",
            ir: "Iran",
            is: "Iceland",
            it: "Italy",
            je: "Jersey",
            jm: "Jamaica",
            jo: "Jordan",
            jp: "Japan",
            ke: "Kenya",
            kg: "Kyrgyzstan",
            kh: "Cambodia",
            ki: "Kiribati",
            km: "Comoros",
            kn: "St. Kitts & Nevis",
            kp: "North Korea",
            kr: "South Korea",
            kw: "Kuwait",
            ky: "Cayman Islands",
            kz: "Kazakhstan",
            la: "Laos",
            lb: "Lebanon",
            lc: "St. Lucia",
            li: "Liechtenstein",
            lk: "Sri Lanka",
            lr: "Liberia",
            ls: "Lesotho",
            lt: "Lithuania",
            lu: "Luxembourg",
            lv: "Latvia",
            ly: "Libya",
            ma: "Morocco",
            mc: "Monaco",
            md: "Moldova",
            me: "Montenegro",
            mf: "St. Martin",
            mg: "Madagascar",
            mh: "Marshall Islands",
            mk: "North Macedonia",
            ml: "Mali",
            mm: "Myanmar (Burma)",
            mn: "Mongolia",
            mo: "Macao SAR China",
            mp: "Northern Mariana Islands",
            mq: "Martinique",
            mr: "Mauritania",
            ms: "Montserrat",
            mt: "Malta",
            mu: "Mauritius",
            mv: "Maldives",
            mw: "Malawi",
            mx: "Mexico",
            my: "Malaysia",
            mz: "Mozambique",
            na: "Namibia",
            nc: "New Caledonia",
            ne: "Niger",
            nf: "Norfolk Island",
            ng: "Nigeria",
            ni: "Nicaragua",
            nl: "Netherlands",
            no: "Norway",
            np: "Nepal",
            nr: "Nauru",
            nu: "Niue",
            nz: "New Zealand",
            om: "Oman",
            pa: "Panama",
            pe: "Peru",
            pf: "French Polynesia",
            pg: "Papua New Guinea",
            ph: "Philippines",
            pk: "Pakistan",
            pl: "Poland",
            pm: "St. Pierre & Miquelon",
            pr: "Puerto Rico",
            ps: "Palestinian Territories",
            pt: "Portugal",
            pw: "Palau",
            py: "Paraguay",
            qa: "Qatar",
            re: "R√©union",
            ro: "Romania",
            rs: "Serbia",
            ru: "Russia",
            rw: "Rwanda",
            sa: "Saudi Arabia",
            sb: "Solomon Islands",
            sc: "Seychelles",
            sd: "Sudan",
            se: "Sweden",
            sg: "Singapore",
            sh: "St. Helena",
            si: "Slovenia",
            sj: "Svalbard & Jan Mayen",
            sk: "Slovakia",
            sl: "Sierra Leone",
            sm: "San Marino",
            sn: "Senegal",
            so: "Somalia",
            sr: "Suriname",
            ss: "South Sudan",
            st: "S√£o Tom√© & Pr√≠ncipe",
            sv: "El Salvador",
            sx: "Sint Maarten",
            sy: "Syria",
            sz: "Eswatini",
            tc: "Turks & Caicos Islands",
            td: "Chad",
            tg: "Togo",
            th: "Thailand",
            tj: "Tajikistan",
            tk: "Tokelau",
            tl: "Timor-Leste",
            tm: "Turkmenistan",
            tn: "Tunisia",
            to: "Tonga",
            tr: "Turkey",
            tt: "Trinidad & Tobago",
            tv: "Tuvalu",
            tw: "Taiwan",
            tz: "Tanzania",
            ua: "Ukraine",
            ug: "Uganda",
            us: "United States",
            uy: "Uruguay",
            uz: "Uzbekistan",
            va: "Vatican City",
            vc: "St. Vincent & Grenadines",
            ve: "Venezuela",
            vg: "British Virgin Islands",
            vi: "U.S. Virgin Islands",
            vn: "Vietnam",
            vu: "Vanuatu",
            wf: "Wallis & Futuna",
            ws: "Samoa",
            ye: "Yemen",
            yt: "Mayotte",
            za: "South Africa",
            zm: "Zambia",
            zw: "Zimbabwe"
          },
          ie = fe,
          $ = {
            selectedCountryAriaLabel: "Change country, selected ${countryName} (${dialCode})",
            noCountrySelected: "Select country",
            countryListAriaLabel: "List of countries",
            searchPlaceholder: "Search",
            clearSearchAriaLabel: "Clear search",
            zeroSearchResults: "No results found",
            oneSearchResult: "1 result found",
            multipleSearchResults: "${count} results found",
            ac: "Ascension Island",
            xk: "Kosovo"
          },
          Se = $,
          Me = {
            ...ie,
            ...Se
          },
          Pe = Me,
          Ie = {
            OPEN_COUNTRY_DROPDOWN: "open:countrydropdown",
            CLOSE_COUNTRY_DROPDOWN: "close:countrydropdown",
            COUNTRY_CHANGE: "countrychange",
            INPUT: "input"
          },
          Ce = {
            HIDE: "iti__hide",
            V_HIDE: "iti__v-hide",
            ARROW_UP: "iti__arrow--up",
            GLOBE: "iti__globe",
            FLAG: "iti__flag",
            COUNTRY_ITEM: "iti__country",
            HIGHLIGHT: "iti__highlight"
          },
          je = {
            ARROW_UP: "ArrowUp",
            ARROW_DOWN: "ArrowDown",
            SPACE: " ",
            ENTER: "Enter",
            ESC: "Escape",
            TAB: "Tab"
          },
          Ye = {
            PASTE: "insertFromPaste",
            DELETE_FWD: "deleteContentForward"
          },
          qe = {
            ALPHA_UNICODE: new RegExp("\\p{L}", "u"),
            NON_PLUS_NUMERIC: /[^+0-9]/,
            NON_PLUS_NUMERIC_GLOBAL: /[^+0-9]/g,
            HIDDEN_SEARCH_CHAR: /^[a-zA-Z√Ä-√ø–∞-—è–ê-–Ø ]$/
          },
          Be = {
            HIDDEN_SEARCH_RESET_MS: 1e3
          },
          He = {
            UNKNOWN_NUMBER_TYPE: -99,
            UNKNOWN_VALIDATION_ERROR: -99
          },
          we = {
            SANE_SELECTED_WITH_DIAL_WIDTH: 78,
            SANE_SELECTED_NO_DIAL_WIDTH: 42,
            INPUT_PADDING_EXTRA_LEFT: 6
          },
          it = {
            NANP: "1"
          },
          mt = {
            DIAL_CODE: "44",
            MOBILE_PREFIX: "7",
            MOBILE_CORE_LENGTH: 10
          },
          Ge = {
            ISO2: "us"
          },
          Xe = {
            AGGRESSIVE: "aggressive",
            POLITE: "polite"
          },
          vt = {
            AUTO: "auto"
          },
          Ut = {
            COUNTRY_CODE: "countryCode",
            DIAL_CODE: "dialCode"
          },
          _t = {
            EXPANDED: "aria-expanded",
            LABEL: "aria-label",
            SELECTED: "aria-selected",
            ACTIVE_DESCENDANT: "aria-activedescendant",
            HASPOPUP: "aria-haspopup",
            CONTROLS: "aria-controls",
            HIDDEN: "aria-hidden",
            AUTOCOMPLETE: "aria-autocomplete",
            MODAL: "aria-modal"
          },
          wt = Le => typeof window < "u" && typeof window.matchMedia == "function" && window.matchMedia(Le).matches,
          Je = () => {
            if (typeof navigator < "u" && typeof window < "u") {
              const Le = /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                j = wt("(max-width: 500px)"),
                E = wt("(max-height: 600px)"),
                D = wt("(pointer: coarse)");
              return Le || j || D && E
            }
            return !1
          },
          zt = {
            allowPhonewords: !1,
            allowDropdown: !0,
            autoPlaceholder: Xe.POLITE,
            containerClass: "",
            countryOrder: null,
            countrySearch: !0,
            customPlaceholder: null,
            dropdownContainer: null,
            excludeCountries: [],
            fixDropdownWidth: !0,
            formatAsYouType: !0,
            formatOnDisplay: !0,
            geoIpLookup: null,
            hiddenInput: null,
            i18n: {},
            initialCountry: "",
            loadUtils: null,
            nationalMode: !0,
            onlyCountries: [],
            placeholderNumberType: "MOBILE",
            showFlags: !0,
            separateDialCode: !1,
            strictMode: !1,
            useFullscreenPopup: Je(),
            validationNumberTypes: ["MOBILE"]
          },
          bt = (Le, j) => {
            Le.useFullscreenPopup && (Le.fixDropdownWidth = !1), Le.onlyCountries.length === 1 && (Le.initialCountry = Le.onlyCountries[0]), Le.separateDialCode && (Le.nationalMode = !1), Le.allowDropdown && !Le.showFlags && !Le.separateDialCode && (Le.nationalMode = !1), Le.useFullscreenPopup && !Le.dropdownContainer && (Le.dropdownContainer = document.body), Le.i18n = {
              ...j,
              ...Le.i18n
            }
          },
          Rt = Le => Le.replace(/\D/g, ""),
          Pt = (Le = "") => Le.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase(),
          yt = (Le, j) => {
            const E = Pt(j),
              D = [],
              N = [],
              X = [],
              ee = [],
              pe = [],
              be = [];
            for (const Oe of Le) Oe.iso2 === E ? D.push(Oe) : Oe.normalisedName.startsWith(E) ? N.push(Oe) : Oe.normalisedName.includes(E) ? X.push(Oe) : E === Oe.dialCode || E === Oe.dialCodePlus ? ee.push(Oe) : Oe.dialCodePlus.includes(E) ? pe.push(Oe) : Oe.initials.includes(E) && be.push(Oe);
            const ye = (Oe, oe) => Oe.priority - oe.priority;
            return [...D.sort(ye), ...N.sort(ye), ...X.sort(ye), ...ee.sort(ye), ...pe.sort(ye), ...be.sort(ye)]
          },
          sr = (Le, j) => {
            const E = j.toLowerCase();
            for (const D of Le)
              if (D.name.toLowerCase().startsWith(E)) return D;
            return null
          },
          tr = Le => Object.keys(Le).filter(j => !!Le[j]).join(" "),
          tt = (Le, j, E) => {
            const D = document.createElement(Le);
            return j && Object.entries(j).forEach(([N, X]) => D.setAttribute(N, X)), E && E.appendChild(D), D
          },
          ht = () => `
  <svg class="iti__search-icon-svg" width="14" height="14" viewBox="0 0 24 24" focusable="false" ${_t.HIDDEN}="true">
    <circle cx="11" cy="11" r="7" />
    <line x1="21" y1="21" x2="16.65" y2="16.65" />
  </svg>`,
          It = Le => {
            const j = `iti-${Le}-clear-mask`;
            return `
    <svg class="iti__search-clear-svg" width="12" height="12" viewBox="0 0 16 16" ${_t.HIDDEN}="true" focusable="false">
      <mask id="${j}" maskUnits="userSpaceOnUse">
        <rect width="16" height="16" fill="white" />
        <path d="M5.2 5.2 L10.8 10.8 M10.8 5.2 L5.2 10.8" stroke="black" stroke-linecap="round" class="iti__search-clear-x" />
      </mask>
      <circle cx="8" cy="8" r="8" class="iti__search-clear-bg" mask="url(#${j})" />
    </svg>`
          },
          Bt = class {
            constructor(Le, j, E) {
              this.highlightedItem = null, Le.dataset.intlTelInputId = E.toString(), this.telInput = Le, this.options = j, this.id = E, this.hadInitialPlaceholder = !!Le.getAttribute("placeholder"), this.isRTL = !!this.telInput.closest("[dir=rtl]"), this.options.separateDialCode && (this.originalPaddingLeft = this.telInput.style.paddingLeft)
            }
            generateMarkup(Le) {
              this.countries = Le, this._prepareTelInput();
              const j = this._createWrapperAndInsert();
              this._maybeBuildCountryContainer(j), j.appendChild(this.telInput), this._maybeUpdateInputPaddingAndReveal(), this._maybeBuildHiddenInputs(j)
            }
            _prepareTelInput() {
              var Le;
              this.telInput.classList.add("iti__tel-input"), !this.telInput.hasAttribute("autocomplete") && !((Le = this.telInput.form) != null && Le.hasAttribute("autocomplete")) && this.telInput.setAttribute("autocomplete", "off")
            }
            _createWrapperAndInsert() {
              const {
                allowDropdown: Le,
                showFlags: j,
                containerClass: E,
                useFullscreenPopup: D
              } = this.options, N = tr({
                iti: !0,
                "iti--allow-dropdown": Le,
                "iti--show-flags": j,
                "iti--inline-dropdown": !D,
                [E]: !!E
              }), X = tt("div", {
                class: N
              });
              return this.isRTL && X.setAttribute("dir", "ltr"), this.telInput.before(X), X
            }
            _maybeBuildCountryContainer(Le) {
              const {
                allowDropdown: j,
                separateDialCode: E,
                showFlags: D
              } = this.options;
              if (j || D || E) {
                this.countryContainer = tt("div", {
                  class: `iti__country-container ${Ce.V_HIDE}`
                }, Le), j ? (this.selectedCountry = tt("button", {
                  type: "button",
                  class: "iti__selected-country",
                  [_t.EXPANDED]: "false",
                  [_t.LABEL]: this.options.i18n.noCountrySelected,
                  [_t.HASPOPUP]: "dialog",
                  [_t.CONTROLS]: `iti-${this.id}__dropdown-content`
                }, this.countryContainer), this.telInput.disabled && this.selectedCountry.setAttribute("disabled", "true")) : this.selectedCountry = tt("div", {
                  class: "iti__selected-country"
                }, this.countryContainer);
                const N = tt("div", {
                  class: "iti__selected-country-primary"
                }, this.selectedCountry);
                this.selectedCountryInner = tt("div", {
                  class: Ce.FLAG
                }, N), j && (this.dropdownArrow = tt("div", {
                  class: "iti__arrow",
                  [_t.HIDDEN]: "true"
                }, N)), E && (this.selectedDialCode = tt("div", {
                  class: "iti__selected-dial-code"
                }, this.selectedCountry)), j && this._buildDropdownContent()
              }
            }
            _buildDropdownContent() {
              const {
                fixDropdownWidth: Le,
                useFullscreenPopup: j,
                countrySearch: E,
                i18n: D,
                dropdownContainer: N,
                containerClass: X
              } = this.options, ee = Le ? "" : "iti--flexible-dropdown-width";
              if (this.dropdownContent = tt("div", {
                  id: `iti-${this.id}__dropdown-content`,
                  class: `iti__dropdown-content ${Ce.HIDE} ${ee}`,
                  role: "dialog",
                  [_t.MODAL]: "true"
                }), this.isRTL && this.dropdownContent.setAttribute("dir", "rtl"), E && this._buildSearchUI(), this.countryList = tt("ul", {
                  class: "iti__country-list",
                  id: `iti-${this.id}__country-listbox`,
                  role: "listbox",
                  [_t.LABEL]: D.countryListAriaLabel
                }, this.dropdownContent), this._appendListItems(), E && this.updateSearchResultsA11yText(), N) {
                const pe = tr({
                  iti: !0,
                  "iti--container": !0,
                  "iti--fullscreen-popup": j,
                  "iti--inline-dropdown": !j,
                  [X]: !!X
                });
                this.dropdown = tt("div", {
                  class: pe
                }), this.dropdown.appendChild(this.dropdownContent)
              } else this.countryContainer.appendChild(this.dropdownContent)
            }
            _buildSearchUI() {
              const {
                i18n: Le
              } = this.options, j = tt("div", {
                class: "iti__search-input-wrapper"
              }, this.dropdownContent);
              this.searchIcon = tt("span", {
                class: "iti__search-icon",
                [_t.HIDDEN]: "true"
              }, j), this.searchIcon.innerHTML = ht(), this.searchInput = tt("input", {
                id: `iti-${this.id}__search-input`,
                type: "search",
                class: "iti__search-input",
                placeholder: Le.searchPlaceholder,
                role: "combobox",
                [_t.EXPANDED]: "true",
                [_t.LABEL]: Le.searchPlaceholder,
                [_t.CONTROLS]: `iti-${this.id}__country-listbox`,
                [_t.AUTOCOMPLETE]: "list",
                autocomplete: "off"
              }, j), this.searchClearButton = tt("button", {
                type: "button",
                class: `iti__search-clear ${Ce.HIDE}`,
                [_t.LABEL]: Le.clearSearchAriaLabel,
                tabindex: "-1"
              }, j), this.searchClearButton.innerHTML = It(this.id), this.searchResultsA11yText = tt("span", {
                class: "iti__a11y-text"
              }, this.dropdownContent), this.searchNoResults = tt("div", {
                class: `iti__no-results ${Ce.HIDE}`,
                [_t.HIDDEN]: "true"
              }, this.dropdownContent), this.searchNoResults.textContent = Le.zeroSearchResults
            }
            _maybeUpdateInputPaddingAndReveal() {
              this.countryContainer && (this.updateInputPadding(), this.countryContainer.classList.remove(Ce.V_HIDE))
            }
            _maybeBuildHiddenInputs(Le) {
              var E, D;
              const {
                hiddenInput: j
              } = this.options;
              if (j) {
                const N = this.telInput.getAttribute("name") || "",
                  X = j(N);
                if (X.phone) {
                  const ee = (E = this.telInput.form) == null ? void 0 : E.querySelector(`input[name="${X.phone}"]`);
                  ee ? this.hiddenInput = ee : (this.hiddenInput = tt("input", {
                    type: "hidden",
                    name: X.phone
                  }), Le.appendChild(this.hiddenInput))
                }
                if (X.country) {
                  const ee = (D = this.telInput.form) == null ? void 0 : D.querySelector(`input[name="${X.country}"]`);
                  ee ? this.hiddenInputCountry = ee : (this.hiddenInputCountry = tt("input", {
                    type: "hidden",
                    name: X.country
                  }), Le.appendChild(this.hiddenInputCountry))
                }
              }
            }
            _appendListItems() {
              const Le = document.createDocumentFragment();
              for (let j = 0; j < this.countries.length; j++) {
                const E = this.countries[j],
                  D = tr({
                    [Ce.COUNTRY_ITEM]: !0,
                    [Ce.HIGHLIGHT]: j === 0
                  }),
                  N = tt("li", {
                    id: `iti-${this.id}__item-${E.iso2}`,
                    class: D,
                    tabindex: "-1",
                    role: "option",
                    [_t.SELECTED]: "false"
                  });
                N.dataset.dialCode = E.dialCode, N.dataset.countryCode = E.iso2, E.nodeById[this.id] = N, this.options.showFlags && tt("div", {
                  class: `${Ce.FLAG} iti__${E.iso2}`
                }, N);
                const X = tt("span", {
                  class: "iti__country-name"
                }, N);
                X.textContent = E.name;
                const ee = tt("span", {
                  class: "iti__dial-code"
                }, N);
                this.isRTL && ee.setAttribute("dir", "ltr"), ee.textContent = `+${E.dialCode}`, Le.appendChild(N)
              }
              this.countryList.appendChild(Le)
            }
            updateInputPadding() {
              if (this.selectedCountry) {
                const Le = this.options.separateDialCode ? we.SANE_SELECTED_WITH_DIAL_WIDTH : we.SANE_SELECTED_NO_DIAL_WIDTH,
                  E = (this.selectedCountry.offsetWidth || this._getHiddenSelectedCountryWidth() || Le) + we.INPUT_PADDING_EXTRA_LEFT;
                this.telInput.style.paddingLeft = `${E}px`
              }
            }
            _getHiddenSelectedCountryWidth() {
              if (this.telInput.parentNode) {
                let Le;
                try {
                  Le = window.top.document.body
                } catch {
                  Le = document.body
                }
                const j = this.telInput.parentNode.cloneNode(!1);
                j.style.visibility = "hidden", Le.appendChild(j);
                const E = this.countryContainer.cloneNode();
                j.appendChild(E);
                const D = this.selectedCountry.cloneNode(!0);
                E.appendChild(D);
                const N = D.offsetWidth;
                return Le.removeChild(j), N
              }
              return 0
            }
            updateSearchResultsA11yText() {
              const {
                i18n: Le
              } = this.options, j = this.countryList.childElementCount;
              let E;
              j === 0 ? E = Le.zeroSearchResults : Le.searchResultsText ? E = Le.searchResultsText(j) : j === 1 ? E = Le.oneSearchResult : E = Le.multipleSearchResults.replace("${count}", j.toString()), this.searchResultsA11yText.textContent = E
            }
            scrollTo(Le) {
              const j = this.countryList,
                E = document.documentElement.scrollTop,
                D = j.offsetHeight,
                N = j.getBoundingClientRect().top + E,
                X = N + D,
                ee = Le.offsetHeight,
                pe = Le.getBoundingClientRect().top + E,
                be = pe + ee,
                ye = pe - N + j.scrollTop;
              if (pe < N) j.scrollTop = ye;
              else if (be > X) {
                const Oe = D - ee;
                j.scrollTop = ye - Oe
              }
            }
            highlightListItem(Le, j) {
              const E = this.highlightedItem;
              if (E && (E.classList.remove(Ce.HIGHLIGHT), E.setAttribute(_t.SELECTED, "false")), this.highlightedItem = Le, this.highlightedItem && (this.highlightedItem.classList.add(Ce.HIGHLIGHT), this.highlightedItem.setAttribute(_t.SELECTED, "true"), this.options.countrySearch)) {
                const D = this.highlightedItem.getAttribute("id") || "";
                this.searchInput.setAttribute(_t.ACTIVE_DESCENDANT, D)
              }
              j && this.highlightedItem.focus()
            }
            filterCountries(Le) {
              this.countryList.innerHTML = "";
              let j = !0;
              for (const E of Le) {
                const D = E.nodeById[this.id];
                D && (this.countryList.appendChild(D), j && (this.highlightListItem(D, !1), j = !1))
              }
              j ? (this.highlightListItem(null, !1), this.searchNoResults && this.searchNoResults.classList.remove(Ce.HIDE)) : this.searchNoResults && this.searchNoResults.classList.add(Ce.HIDE), this.countryList.scrollTop = 0, this.updateSearchResultsA11yText()
            }
            destroy() {
              this.telInput.iti = void 0, delete this.telInput.dataset.intlTelInputId, this.options.separateDialCode && (this.telInput.style.paddingLeft = this.originalPaddingLeft);
              const Le = this.telInput.parentNode;
              Le.before(this.telInput), Le.remove(), this.telInput = null, this.countryContainer = null, this.selectedCountry = null, this.selectedCountryInner = null, this.selectedDialCode = null, this.dropdownArrow = null, this.dropdownContent = null, this.searchInput = null, this.searchIcon = null, this.searchClearButton = null, this.searchNoResults = null, this.searchResultsA11yText = null, this.countryList = null, this.dropdown = null, this.hiddenInput = null, this.hiddenInputCountry = null, this.highlightedItem = null;
              for (const j of this.countries) delete j.nodeById[this.id];
              this.countries = null
            }
          },
          Nt = Le => {
            const {
              onlyCountries: j,
              excludeCountries: E
            } = Le;
            if (j.length) {
              const D = j.map(N => N.toLowerCase());
              return ae.filter(N => D.includes(N.iso2))
            } else if (E.length) {
              const D = E.map(N => N.toLowerCase());
              return ae.filter(N => !D.includes(N.iso2))
            }
            return ae
          },
          Ht = (Le, j) => {
            for (const E of Le) {
              const D = E.iso2.toLowerCase();
              j.i18n[D] && (E.name = j.i18n[D])
            }
          },
          yr = (Le, j) => {
            const E = new Set;
            let D = 0;
            const N = {},
              X = (ee, pe, be) => {
                if (!ee || !pe) return;
                pe.length > D && (D = pe.length), N.hasOwnProperty(pe) || (N[pe] = []);
                const ye = N[pe];
                if (ye.includes(ee)) return;
                const Oe = be !== void 0 ? be : ye.length;
                ye[Oe] = ee
              };
            for (const ee of Le) {
              E.has(ee.dialCode) || E.add(ee.dialCode);
              for (let pe = 1; pe < ee.dialCode.length; pe++) {
                const be = ee.dialCode.substring(0, pe);
                X(ee.iso2, be)
              }
              X(ee.iso2, ee.dialCode, ee.priority)
            }(j.onlyCountries.length || j.excludeCountries.length) && E.forEach(ee => {
              N[ee] = N[ee].filter(Boolean)
            });
            for (const ee of Le)
              if (ee.areaCodes) {
                const pe = N[ee.dialCode][0];
                for (const be of ee.areaCodes) {
                  for (let ye = 1; ye < be.length; ye++) {
                    const Oe = be.substring(0, ye),
                      oe = ee.dialCode + Oe;
                    X(pe, oe), X(ee.iso2, oe)
                  }
                  X(ee.iso2, ee.dialCode + be)
                }
              } return {
              dialCodes: E,
              dialCodeMaxLen: D,
              dialCodeToIso2Map: N
            }
          },
          Wt = (Le, j) => {
            j.countryOrder && (j.countryOrder = j.countryOrder.map(E => E.toLowerCase())), Le.sort((E, D) => {
              const {
                countryOrder: N
              } = j;
              if (N) {
                const X = N.indexOf(E.iso2),
                  ee = N.indexOf(D.iso2),
                  pe = X > -1,
                  be = ee > -1;
                if (pe || be) return pe && be ? X - ee : pe ? -1 : 1
              }
              return E.name.localeCompare(D.name)
            })
          },
          Zt = Le => {
            for (const j of Le) j.normalisedName = Pt(j.name), j.initials = j.normalisedName.split(/[^a-z]/).map(E => E[0]).join(""), j.dialCodePlus = `+${j.dialCode}`
          },
          jt = (Le, j, E, D) => {
            let N = Le;
            if (E && j) {
              j = `+${D.dialCode}`;
              const X = N[j.length] === " " || N[j.length] === "-" ? j.length + 1 : j.length;
              N = N.substring(X)
            }
            return N
          },
          Jt = (Le, j, E, D, N) => {
            const X = E ? E.formatNumberAsYouType(Le, D.iso2) : Le,
              {
                dialCode: ee
              } = D;
            return N && j.charAt(0) !== "+" && X.includes(`+${ee}`) ? (X.split(`+${ee}`)[1] || "").trim() : X
          },
          Lt = (Le, j, E, D) => {
            if (E === 0 && !D) return 0;
            let N = 0;
            for (let X = 0; X < j.length; X++) {
              if (/[+0-9]/.test(j[X]) && N++, N === Le && !D) return X + 1;
              if (D && N === Le + 1) return X
            }
            return j.length
          },
          Gt = ["800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889"],
          Yt = Le => {
            const j = Rt(Le);
            if (j.startsWith(it.NANP) && j.length >= 4) {
              const E = j.substring(1, 4);
              return Gt.includes(E)
            }
            return !1
          };
        for (const Le of ae) Le.name = Pe[Le.iso2];
        var Lr = 0,
          Ir = new Set(ae.map(Le => Le.iso2)),
          Jr = Le => Ir.has(Le),
          Tr = class Qy {
            constructor(j, E = {}) {
              this.id = Lr++, this.options = {
                ...zt,
                ...E
              }, bt(this.options, Pe), this.ui = new Bt(j, this.options, this.id), this.isAndroid = Qy._getIsAndroid(), this.promise = this._createInitPromises(), this.countries = Nt(this.options);
              const {
                dialCodes: D,
                dialCodeMaxLen: N,
                dialCodeToIso2Map: X
              } = yr(this.countries, this.options);
              this.dialCodes = D, this.dialCodeMaxLen = N, this.dialCodeToIso2Map = X, this.countryByIso2 = new Map(this.countries.map(ee => [ee.iso2, ee])), this._init()
            }
            static _getIsAndroid() {
              return typeof navigator < "u" ? /Android/i.test(navigator.userAgent) : !1
            }
            _createInitPromises() {
              const j = new Promise((D, N) => {
                  this.resolveAutoCountryPromise = D, this.rejectAutoCountryPromise = N
                }),
                E = new Promise((D, N) => {
                  this.resolveUtilsScriptPromise = D, this.rejectUtilsScriptPromise = N
                });
              return Promise.all([j, E])
            }
            _init() {
              this.selectedCountryData = {}, this.abortController = new AbortController, this._processCountryData(), this.ui.generateMarkup(this.countries), this._setInitialState(), this._initListeners(), this._initRequests()
            }
            _processCountryData() {
              Ht(this.countries, this.options), Wt(this.countries, this.options), Zt(this.countries)
            }
            _setInitialState(j = !1) {
              const E = this.ui.telInput.getAttribute("value"),
                D = this.ui.telInput.value,
                X = E && E.startsWith("+") && (!D || !D.startsWith("+")) ? E : D,
                ee = this._getDialCode(X),
                pe = Yt(X),
                {
                  initialCountry: be,
                  geoIpLookup: ye
                } = this.options,
                Oe = be === vt.AUTO && ye;
              if (ee && !pe) this._updateCountryFromNumber(X);
              else if (!Oe || j) {
                const oe = be ? be.toLowerCase() : "";
                Jr(oe) ? this._setCountry(oe) : ee && pe ? this._setCountry(Ge.ISO2) : this._setCountry("")
              }
              X && this._updateValFromNumber(X)
            }
            _initListeners() {
              this._initTelInputListeners(), this.options.allowDropdown && this._initDropdownListeners(), (this.ui.hiddenInput || this.ui.hiddenInputCountry) && this.ui.telInput.form && this._initHiddenInputListener()
            }
            _initHiddenInputListener() {
              var E;
              const j = () => {
                this.ui.hiddenInput && (this.ui.hiddenInput.value = this.getNumber()), this.ui.hiddenInputCountry && (this.ui.hiddenInputCountry.value = this.selectedCountryData.iso2 || "")
              };
              (E = this.ui.telInput.form) == null || E.addEventListener("submit", j, {
                signal: this.abortController.signal
              })
            }
            _initDropdownListeners() {
              const j = this.abortController.signal,
                E = ee => {
                  this.ui.dropdownContent.classList.contains(Ce.HIDE) ? this.ui.telInput.focus() : ee.preventDefault()
                },
                D = this.ui.telInput.closest("label");
              D && D.addEventListener("click", E, {
                signal: j
              });
              const N = () => {
                this.ui.dropdownContent.classList.contains(Ce.HIDE) && !this.ui.telInput.disabled && !this.ui.telInput.readOnly && this._openDropdown()
              };
              this.ui.selectedCountry.addEventListener("click", N, {
                signal: j
              });
              const X = ee => {
                this.ui.dropdownContent.classList.contains(Ce.HIDE) && [je.ARROW_UP, je.ARROW_DOWN, je.SPACE, je.ENTER].includes(ee.key) && (ee.preventDefault(), ee.stopPropagation(), this._openDropdown()), ee.key === je.TAB && this._closeDropdown()
              };
              this.ui.countryContainer.addEventListener("keydown", X, {
                signal: j
              })
            }
            _initRequests() {
              const {
                loadUtils: j,
                initialCountry: E,
                geoIpLookup: D
              } = this.options;
              if (j && !qt.utils) {
                const X = () => {
                  var ee;
                  (ee = qt.attachUtils(j)) == null || ee.catch(() => {})
                };
                if (qt.documentReady()) X();
                else {
                  const ee = () => {
                    X()
                  };
                  window.addEventListener("load", ee, {
                    signal: this.abortController.signal
                  })
                }
              } else this.resolveUtilsScriptPromise();
              E === vt.AUTO && D && !this.selectedCountryData.iso2 ? this._loadAutoCountry() : this.resolveAutoCountryPromise()
            }
            _loadAutoCountry() {
              qt.autoCountry ? this.handleAutoCountry() : qt.startedLoadingAutoCountry || (qt.startedLoadingAutoCountry = !0, typeof this.options.geoIpLookup == "function" && this.options.geoIpLookup((j = "") => {
                const E = j.toLowerCase();
                Jr(E) ? (qt.autoCountry = E, setTimeout(() => xr("handleAutoCountry"))) : (this._setInitialState(!0), xr("rejectAutoCountryPromise"))
              }, () => {
                this._setInitialState(!0), xr("rejectAutoCountryPromise")
              }))
            }
            _openDropdownWithPlus() {
              this._openDropdown(), this.ui.searchInput.value = "+", this._filterCountriesByQuery("")
            }
            _initTelInputListeners() {
              this._bindInputListener(), this._maybeBindKeydownListener(), this._maybeBindPasteListener()
            }
            _bindInputListener() {
              const {
                strictMode: j,
                formatAsYouType: E,
                separateDialCode: D,
                allowDropdown: N,
                countrySearch: X
              } = this.options;
              let ee = !1;
              qe.ALPHA_UNICODE.test(this.ui.telInput.value) && (ee = !0);
              const pe = be => {
                if (this.isAndroid && (be == null ? void 0 : be.data) === "+" && D && N && X) {
                  const K = this.ui.telInput.selectionStart || 0,
                    he = this.ui.telInput.value.substring(0, K - 1),
                    Q = this.ui.telInput.value.substring(K);
                  this.ui.telInput.value = he + Q, this._openDropdownWithPlus();
                  return
                }
                this._updateCountryFromNumber(this.ui.telInput.value) && this._triggerCountryChange();
                const ye = (be == null ? void 0 : be.data) && qe.NON_PLUS_NUMERIC.test(be.data),
                  Oe = (be == null ? void 0 : be.inputType) === Ye.PASTE && this.ui.telInput.value;
                ye || Oe && !j ? ee = !0 : qe.NON_PLUS_NUMERIC.test(this.ui.telInput.value) || (ee = !1);
                const oe = (be == null ? void 0 : be.detail) && be.detail.isSetNumber;
                if (E && !ee && !oe) {
                  const K = this.ui.telInput.selectionStart || 0,
                    Q = this.ui.telInput.value.substring(0, K).replace(qe.NON_PLUS_NUMERIC_GLOBAL, "").length,
                    ze = (be == null ? void 0 : be.inputType) === Ye.DELETE_FWD,
                    $e = this._getFullNumber(),
                    Re = Jt($e, this.ui.telInput.value, qt.utils, this.selectedCountryData, this.options.separateDialCode),
                    ft = Lt(Q, Re, K, ze);
                  this.ui.telInput.value = Re, this.ui.telInput.setSelectionRange(ft, ft)
                }
              };
              this.ui.telInput.addEventListener("input", pe, {
                signal: this.abortController.signal
              })
            }
            _maybeBindKeydownListener() {
              const {
                strictMode: j,
                separateDialCode: E,
                allowDropdown: D,
                countrySearch: N
              } = this.options;
              if (j || E) {
                const X = ee => {
                  if (ee.key && ee.key.length === 1 && !ee.altKey && !ee.ctrlKey && !ee.metaKey) {
                    if (E && D && N && ee.key === "+") {
                      ee.preventDefault(), this._openDropdownWithPlus();
                      return
                    }
                    if (j) {
                      const pe = this.ui.telInput.value,
                        ye = !pe.startsWith("+") && this.ui.telInput.selectionStart === 0 && ee.key === "+",
                        Oe = /^[0-9]$/.test(ee.key),
                        oe = E ? Oe : ye || Oe,
                        K = pe.slice(0, this.ui.telInput.selectionStart) + ee.key + pe.slice(this.ui.telInput.selectionEnd),
                        he = this._getFullNumber(K),
                        Q = qt.utils.getCoreNumber(he, this.selectedCountryData.iso2),
                        ze = this.maxCoreNumberLength && Q.length > this.maxCoreNumberLength,
                        Re = this._getNewCountryFromNumber(he) !== null;
                      (!oe || ze && !Re && !ye) && ee.preventDefault()
                    }
                  }
                };
                this.ui.telInput.addEventListener("keydown", X, {
                  signal: this.abortController.signal
                })
              }
            }
            _maybeBindPasteListener() {
              if (this.options.strictMode) {
                const j = E => {
                  E.preventDefault();
                  const D = this.ui.telInput,
                    N = D.selectionStart,
                    X = D.selectionEnd,
                    ee = D.value.slice(0, N),
                    pe = D.value.slice(X),
                    be = this.selectedCountryData.iso2,
                    ye = E.clipboardData.getData("text"),
                    Oe = N === 0 && X > 0,
                    oe = !D.value.startsWith("+") || Oe,
                    K = ye.replace(qe.NON_PLUS_NUMERIC_GLOBAL, ""),
                    he = K.startsWith("+"),
                    Q = K.replace(/\+/g, ""),
                    ze = he && oe ? `+${Q}` : Q;
                  let $e = ee + ze + pe,
                    Re = qt.utils.getCoreNumber($e, be);
                  for (; Re.length === 0 && $e.length > 0;) $e = $e.slice(0, -1), Re = qt.utils.getCoreNumber($e, be);
                  if (!Re) return;
                  if (this.maxCoreNumberLength && Re.length > this.maxCoreNumberLength)
                    if (D.selectionEnd === D.value.length) {
                      const Mt = Re.length - this.maxCoreNumberLength;
                      $e = $e.slice(0, $e.length - Mt)
                    } else return;
                  D.value = $e;
                  const ft = N + ze.length;
                  D.setSelectionRange(ft, ft), D.dispatchEvent(new InputEvent("input", {
                    bubbles: !0
                  }))
                };
                this.ui.telInput.addEventListener("paste", j, {
                  signal: this.abortController.signal
                })
              }
            }
            _cap(j) {
              const E = Number(this.ui.telInput.getAttribute("maxlength"));
              return E && j.length > E ? j.substring(0, E) : j
            }
            _trigger(j, E = {}) {
              const D = new CustomEvent(j, {
                bubbles: !0,
                cancelable: !0,
                detail: E
              });
              this.ui.telInput.dispatchEvent(D)
            }
            _openDropdown() {
              const {
                fixDropdownWidth: j,
                countrySearch: E
              } = this.options;
              if (this.dropdownAbortController = new AbortController, j && (this.ui.dropdownContent.style.width = `${this.ui.telInput.offsetWidth}px`), this.ui.dropdownContent.classList.remove(Ce.HIDE), this.ui.selectedCountry.setAttribute(_t.EXPANDED, "true"), this._setDropdownPosition(), E) {
                const D = this.ui.countryList.firstElementChild;
                D && (this.ui.highlightListItem(D, !1), this.ui.countryList.scrollTop = 0), this.ui.searchInput.focus()
              }
              this._bindDropdownListeners(), this.ui.dropdownArrow.classList.add(Ce.ARROW_UP), this._trigger(Ie.OPEN_COUNTRY_DROPDOWN)
            }
            _setDropdownPosition() {
              if (this.options.dropdownContainer && this.options.dropdownContainer.appendChild(this.ui.dropdown), !this.options.useFullscreenPopup) {
                const j = this.ui.telInput.getBoundingClientRect(),
                  E = this.ui.telInput.offsetHeight;
                if (this.options.dropdownContainer) {
                  this.ui.dropdown.style.top = `${j.top+E}px`, this.ui.dropdown.style.left = `${j.left}px`;
                  const D = () => this._closeDropdown();
                  window.addEventListener("scroll", D, {
                    signal: this.dropdownAbortController.signal
                  })
                }
              }
            }
            _bindDropdownListeners() {
              const j = this.dropdownAbortController.signal;
              this._bindDropdownMouseoverListener(j), this._bindDropdownCountryClickListener(j), this._bindDropdownClickOffListener(j), this._bindDropdownKeydownListener(j), this.options.countrySearch && this._bindDropdownSearchListeners(j)
            }
            _bindDropdownMouseoverListener(j) {
              const E = D => {
                var X;
                const N = (X = D.target) == null ? void 0 : X.closest(`.${Ce.COUNTRY_ITEM}`);
                N && this.ui.highlightListItem(N, !1)
              };
              this.ui.countryList.addEventListener("mouseover", E, {
                signal: j
              })
            }
            _bindDropdownCountryClickListener(j) {
              const E = D => {
                var X;
                const N = (X = D.target) == null ? void 0 : X.closest(`.${Ce.COUNTRY_ITEM}`);
                N && this._selectListItem(N)
              };
              this.ui.countryList.addEventListener("click", E, {
                signal: j
              })
            }
            _bindDropdownClickOffListener(j) {
              const E = D => {
                !!D.target.closest(`#iti-${this.id}__dropdown-content`) || this._closeDropdown()
              };
              setTimeout(() => {
                document.documentElement.addEventListener("click", E, {
                  signal: j
                })
              }, 0)
            }
            _bindDropdownKeydownListener(j) {
              let E = "",
                D = null;
              const N = X => {
                [je.ARROW_UP, je.ARROW_DOWN, je.ENTER, je.ESC].includes(X.key) && (X.preventDefault(), X.stopPropagation(), X.key === je.ARROW_UP || X.key === je.ARROW_DOWN ? this._handleUpDownKey(X.key) : X.key === je.ENTER ? this._handleEnterKey() : X.key === je.ESC && this._closeDropdown()), !this.options.countrySearch && qe.HIDDEN_SEARCH_CHAR.test(X.key) && (X.stopPropagation(), D && clearTimeout(D), E += X.key.toLowerCase(), this._searchForCountry(E), D = setTimeout(() => {
                  E = ""
                }, Be.HIDDEN_SEARCH_RESET_MS))
              };
              document.addEventListener("keydown", N, {
                signal: j
              })
            }
            _bindDropdownSearchListeners(j) {
              const E = () => {
                const ee = this.ui.searchInput.value.trim();
                this._filterCountriesByQuery(ee), this.ui.searchInput.value ? this.ui.searchClearButton.classList.remove(Ce.HIDE) : this.ui.searchClearButton.classList.add(Ce.HIDE)
              };
              let D = null;
              const N = () => {
                D && clearTimeout(D), D = setTimeout(() => {
                  E(), D = null
                }, 100)
              };
              this.ui.searchInput.addEventListener("input", N, {
                signal: j
              });
              const X = () => {
                this.ui.searchInput.value = "", this.ui.searchInput.focus(), E()
              };
              this.ui.searchClearButton.addEventListener("click", X, {
                signal: j
              })
            }
            _searchForCountry(j) {
              const E = sr(this.countries, j);
              if (E) {
                const D = E.nodeById[this.id];
                this.ui.highlightListItem(D, !1), this.ui.scrollTo(D)
              }
            }
            _filterCountriesByQuery(j) {
              let E;
              j === "" ? E = this.countries : E = yt(this.countries, j), this.ui.filterCountries(E)
            }
            _handleUpDownKey(j) {
              var D, N;
              let E = j === je.ARROW_UP ? (D = this.ui.highlightedItem) == null ? void 0 : D.previousElementSibling : (N = this.ui.highlightedItem) == null ? void 0 : N.nextElementSibling;
              !E && this.ui.countryList.childElementCount > 1 && (E = j === je.ARROW_UP ? this.ui.countryList.lastElementChild : this.ui.countryList.firstElementChild), E && (this.ui.scrollTo(E), this.ui.highlightListItem(E, !1))
            }
            _handleEnterKey() {
              this.ui.highlightedItem && this._selectListItem(this.ui.highlightedItem)
            }
            _updateValFromNumber(j) {
              let E = j;
              if (this.options.formatOnDisplay && qt.utils && this.selectedCountryData) {
                const D = this.options.nationalMode || !E.startsWith("+") && !this.options.separateDialCode,
                  {
                    NATIONAL: N,
                    INTERNATIONAL: X
                  } = qt.utils.numberFormat,
                  ee = D ? N : X;
                E = qt.utils.formatNumber(E, this.selectedCountryData.iso2, ee)
              }
              E = this._beforeSetNumber(E), this.ui.telInput.value = E
            }
            _updateCountryFromNumber(j) {
              const E = this._getNewCountryFromNumber(j);
              return E !== null ? this._setCountry(E) : !1
            }
            _ensureHasDialCode(j) {
              const {
                dialCode: E,
                nationalPrefix: D
              } = this.selectedCountryData;
              if (j.startsWith("+") || !E) return j;
              const ee = D && j.startsWith(D) && !this.options.separateDialCode ? j.substring(1) : j;
              return `+${E}${ee}`
            }
            _getNewCountryFromNumber(j) {
              const E = j.indexOf("+");
              let D = E ? j.substring(E) : j;
              const N = this.selectedCountryData.iso2,
                X = this.selectedCountryData.dialCode;
              D = this._ensureHasDialCode(D);
              const ee = this._getDialCode(D, !0),
                pe = Rt(D);
              if (ee) {
                const be = Rt(ee),
                  ye = this.dialCodeToIso2Map[be];
                if (ye.length === 1) return ye[0] === N ? null : ye[0];
                if (!N && this.defaultCountry && ye.includes(this.defaultCountry)) return this.defaultCountry;
                if (X === it.NANP && Yt(pe)) return null;
                const {
                  areaCodes: oe,
                  priority: K
                } = this.selectedCountryData;
                if (oe) {
                  const Re = oe.map(ft => `${X}${ft}`);
                  for (const ft of Re)
                    if (pe.startsWith(ft)) return null
                }
                const Q = oe && !(K === 0) && pe.length > be.length,
                  ze = N && ye.includes(N) && !Q,
                  $e = N === ye[0];
                if (!ze && !$e) return ye[0]
              } else if (D.startsWith("+") && pe.length) {
                const be = this.selectedCountryData.dialCode || "";
                return be && be.startsWith(pe) ? null : ""
              } else if ((!D || D === "+") && !N) return this.defaultCountry;
              return null
            }
            _setCountry(j) {
              const {
                separateDialCode: E,
                showFlags: D,
                i18n: N
              } = this.options, X = this.selectedCountryData.iso2 || "";
              if (this.selectedCountryData = j ? this.countryByIso2.get(j) : {}, this.selectedCountryData.iso2 && (this.defaultCountry = this.selectedCountryData.iso2), this.ui.selectedCountry) {
                const ee = j && D ? `${Ce.FLAG} iti__${j}` : `${Ce.FLAG} ${Ce.GLOBE}`;
                let pe, be;
                if (j) {
                  const {
                    name: ye,
                    dialCode: Oe
                  } = this.selectedCountryData;
                  be = ye, pe = N.selectedCountryAriaLabel.replace("${countryName}", ye).replace("${dialCode}", `+${Oe}`)
                } else be = N.noCountrySelected, pe = N.noCountrySelected;
                this.ui.selectedCountryInner.className = ee, this.ui.selectedCountry.setAttribute("title", be), this.ui.selectedCountry.setAttribute(_t.LABEL, pe)
              }
              if (E) {
                const ee = this.selectedCountryData.dialCode ? `+${this.selectedCountryData.dialCode}` : "";
                this.ui.selectedDialCode.textContent = ee, this.ui.updateInputPadding()
              }
              return this._updatePlaceholder(), this._updateMaxLength(), X !== j
            }
            _updateMaxLength() {
              const {
                strictMode: j,
                placeholderNumberType: E,
                validationNumberTypes: D
              } = this.options, {
                iso2: N
              } = this.selectedCountryData;
              if (j && qt.utils)
                if (N) {
                  const X = qt.utils.numberType[E];
                  let ee = qt.utils.getExampleNumber(N, !1, X, !0),
                    pe = ee;
                  for (; qt.utils.isPossibleNumber(ee, N, D);) pe = ee, ee += "0";
                  const be = qt.utils.getCoreNumber(pe, N);
                  this.maxCoreNumberLength = be.length, N === "by" && (this.maxCoreNumberLength = be.length + 1)
                } else this.maxCoreNumberLength = null
            }
            _updatePlaceholder() {
              const {
                autoPlaceholder: j,
                placeholderNumberType: E,
                nationalMode: D,
                customPlaceholder: N
              } = this.options, X = j === Xe.AGGRESSIVE || !this.ui.hadInitialPlaceholder && j === Xe.POLITE;
              if (qt.utils && X) {
                const ee = qt.utils.numberType[E];
                let pe = this.selectedCountryData.iso2 ? qt.utils.getExampleNumber(this.selectedCountryData.iso2, D, ee) : "";
                pe = this._beforeSetNumber(pe), typeof N == "function" && (pe = N(pe, this.selectedCountryData)), this.ui.telInput.setAttribute("placeholder", pe)
              }
            }
            _selectListItem(j) {
              const E = j.dataset[Ut.COUNTRY_CODE],
                D = this._setCountry(E);
              this._closeDropdown();
              const N = j.dataset[Ut.DIAL_CODE];
              this._updateDialCode(N), this.options.formatOnDisplay && this._updateValFromNumber(this.ui.telInput.value), this.ui.telInput.focus(), D && this._triggerCountryChange()
            }
            _closeDropdown() {
              this.ui.dropdownContent.classList.contains(Ce.HIDE) || (this.ui.dropdownContent.classList.add(Ce.HIDE), this.ui.selectedCountry.setAttribute(_t.EXPANDED, "false"), this.ui.highlightedItem && this.ui.highlightedItem.setAttribute(_t.SELECTED, "false"), this.options.countrySearch && this.ui.searchInput.removeAttribute(_t.ACTIVE_DESCENDANT), this.ui.dropdownArrow.classList.remove(Ce.ARROW_UP), this.dropdownAbortController.abort(), this.dropdownAbortController = null, this.options.dropdownContainer && this.ui.dropdown.remove(), this._trigger(Ie.CLOSE_COUNTRY_DROPDOWN))
            }
            _updateDialCode(j) {
              const E = this.ui.telInput.value,
                D = `+${j}`;
              let N;
              if (E.startsWith("+")) {
                const X = this._getDialCode(E);
                X ? N = E.replace(X, D) : N = D, this.ui.telInput.value = N
              }
            }
            _getDialCode(j, E) {
              let D = "";
              if (j.startsWith("+")) {
                let N = "",
                  X = !1;
                for (let ee = 0; ee < j.length; ee++) {
                  const pe = j.charAt(ee);
                  if (/[0-9]/.test(pe)) {
                    if (N += pe, !!!this.dialCodeToIso2Map[N]) break;
                    if (this.dialCodes.has(N)) {
                      if (D = j.substring(0, ee + 1), X = !0, !E) break
                    } else E && X && (D = j.substring(0, ee + 1));
                    if (N.length === this.dialCodeMaxLen) break
                  }
                }
              }
              return D
            }
            _getFullNumber(j) {
              const E = j || this.ui.telInput.value.trim(),
                {
                  dialCode: D
                } = this.selectedCountryData;
              let N;
              const X = Rt(E);
              return this.options.separateDialCode && !E.startsWith("+") && D && X ? N = `+${D}` : N = "", N + E
            }
            _beforeSetNumber(j) {
              const E = this._getDialCode(j),
                D = jt(j, E, this.options.separateDialCode, this.selectedCountryData);
              return this._cap(D)
            }
            _triggerCountryChange() {
              this._trigger(Ie.COUNTRY_CHANGE)
            }
            handleAutoCountry() {
              this.options.initialCountry === vt.AUTO && qt.autoCountry && (this.defaultCountry = qt.autoCountry, this.selectedCountryData.iso2 || this.ui.selectedCountryInner.classList.contains(Ce.GLOBE) || this.setCountry(this.defaultCountry), this.resolveAutoCountryPromise())
            }
            handleUtils() {
              qt.utils && (this.ui.telInput.value && this._updateValFromNumber(this.ui.telInput.value), this.selectedCountryData.iso2 && (this._updatePlaceholder(), this._updateMaxLength())), this.resolveUtilsScriptPromise()
            }
            destroy() {
              this.ui.telInput && (this.options.allowDropdown && this._closeDropdown(), this.abortController.abort(), this.abortController = null, this.ui.destroy(), qt.instances instanceof Map ? qt.instances.delete(this.id) : delete qt.instances[this.id])
            }
            getExtension() {
              return qt.utils ? qt.utils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2) : ""
            }
            getNumber(j) {
              if (qt.utils) {
                const {
                  iso2: E
                } = this.selectedCountryData;
                return qt.utils.formatNumber(this._getFullNumber(), E, j)
              }
              return ""
            }
            getNumberType() {
              return qt.utils ? qt.utils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2) : He.UNKNOWN_NUMBER_TYPE
            }
            getSelectedCountryData() {
              return this.selectedCountryData
            }
            getValidationError() {
              if (qt.utils) {
                const {
                  iso2: j
                } = this.selectedCountryData;
                return qt.utils.getValidationError(this._getFullNumber(), j)
              }
              return He.UNKNOWN_VALIDATION_ERROR
            }
            isValidNumber() {
              const {
                dialCode: j,
                iso2: E
              } = this.selectedCountryData;
              if (j === mt.DIAL_CODE && qt.utils) {
                const D = this._getFullNumber(),
                  N = qt.utils.getCoreNumber(D, E);
                if (N[0] === mt.MOBILE_PREFIX && N.length !== mt.MOBILE_CORE_LENGTH) return !1
              }
              return this._validateNumber(!1)
            }
            isValidNumberPrecise() {
              return this._validateNumber(!0)
            }
            _utilsIsPossibleNumber(j) {
              return qt.utils ? qt.utils.isPossibleNumber(j, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
            }
            _validateNumber(j) {
              if (!qt.utils) return null;
              if (!this.selectedCountryData.iso2) return !1;
              const E = ee => j ? this._utilsIsValidNumber(ee) : this._utilsIsPossibleNumber(ee),
                D = this._getFullNumber(),
                N = D.search(qe.ALPHA_UNICODE);
              if (N > -1 && !this.options.allowPhonewords) {
                const ee = D.substring(0, N),
                  pe = E(ee),
                  be = E(D);
                return pe && be
              }
              return E(D)
            }
            _utilsIsValidNumber(j) {
              return qt.utils ? qt.utils.isValidNumber(j, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
            }
            setCountry(j) {
              const E = j == null ? void 0 : j.toLowerCase();
              if (!Jr(E)) throw new Error(`Invalid country code: '${E}'`);
              const D = this.selectedCountryData.iso2;
              (j && E !== D || !j && D) && (this._setCountry(E), this._updateDialCode(this.selectedCountryData.dialCode), this.options.formatOnDisplay && this._updateValFromNumber(this.ui.telInput.value), this._triggerCountryChange())
            }
            setNumber(j) {
              const E = this._updateCountryFromNumber(j);
              this._updateValFromNumber(j), E && this._triggerCountryChange(), this._trigger(Ie.INPUT, {
                isSetNumber: !0
              })
            }
            setPlaceholderNumberType(j) {
              this.options.placeholderNumberType = j, this._updatePlaceholder()
            }
            setDisabled(j) {
              this.ui.telInput.disabled = j, j ? this.ui.selectedCountry.setAttribute("disabled", "true") : this.ui.selectedCountry.removeAttribute("disabled")
            }
          },
          Ar = Le => {
            if (!qt.utils && !qt.startedLoadingUtilsScript) {
              let j;
              if (typeof Le == "function") try {
                j = Promise.resolve(Le())
              } catch (E) {
                return Promise.reject(E)
              } else return Promise.reject(new TypeError(`The argument passed to attachUtils must be a function that returns a promise for the utilities module, not ${typeof Le}`));
              return qt.startedLoadingUtilsScript = !0, j.then(E => {
                const D = E == null ? void 0 : E.default;
                if (!D || typeof D != "object") throw new TypeError("The loader function passed to attachUtils did not resolve to a module object with utils as its default export.");
                return qt.utils = D, xr("handleUtils"), !0
              }).catch(E => {
                throw xr("rejectUtilsScriptPromise", E), E
              })
            }
            return null
          },
          xr = (Le, ...j) => {
            Object.values(qt.instances).forEach(E => {
              const D = E[Le];
              typeof D == "function" && D.apply(E, j)
            })
          },
          qt = Object.assign((Le, j) => {
            const E = new Tr(Le, j);
            return qt.instances[E.id] = E, Le.iti = E, E
          }, {
            defaults: zt,
            documentReady: () => document.readyState === "complete",
            getCountryData: () => ae,
            getInstance: Le => {
              const j = Le.dataset.intlTelInputId;
              return j ? qt.instances[j] : null
            },
            instances: {},
            attachUtils: Ar,
            startedLoadingUtilsScript: !1,
            startedLoadingAutoCountry: !1,
            version: "25.12.5"
          }),
          Yr = qt;
        return F(q)
      })();
      return a.default
    })
  })(Sm)), Sm.exports
}
var G7 = Z7();
const H7 = ay(G7);
var W7 = me('<div><span class="loading loading-spinner loading-xl"></span></div>'),
  $7 = me('<span class="w-8"> </span>'),
  X7 = me('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="text-base-content/80 mt-0.5 text-sm"> </p></div> <form class="mt-8 flex w-full flex-col gap-3"><input class="input pl-12! w-full" type="tel" id="phone"/> <button class="btn btn-primary w-full"> <!></button></form>', 1),
  Y7 = me('<span class="w-8"> </span>'),
  K7 = me('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="mt-0.5 text-sm"> </p></div> <div class="mt-4"><!></div> <div class="mt-3 flex flex-col items-center gap-1"><button class="btn btn-ghost w-max"> <!></button> <button class="text-primary cursor-pointer text-xs"> </button></div>', 1),
  J7 = me('<div class="flex h-full w-full flex-col items-center justify-center"><!></div>');

function Q7(m, a) {
  Wr(a, !0);
  let d = et(!0),
    x = et(""),
    A = et(0),
    z = et(!1);
  const b = ut(() => _(A) > 0 || _(z));
  let s = et(!1),
    F = et(""),
    q = et(void 0);
  const J = ut(() => {
    var Se;
    return `phone:${(Se=Dt.data)==null?void 0:Se.id}`
  });
  tn(() => {
    const Se = localStorage.getItem(_(J));
    Se && Y(x, Se, !0)
  }), ri(() => {
    fn.getOtpCooldown().then(Pe => {
      Y(A, Pe.cooldownMs, !0)
    }).catch(Pe => {
      Xt.error(Pe.message)
    }).finally(() => {
      Y(d, !1)
    });
    const Se = 1e3,
      Me = setInterval(() => {
        Y(A, Math.max(0, _(A) - Se), !0)
      }, Se);
    return () => {
      clearInterval(Me)
    }
  });
  async function te(Se) {
    try {
      Y(z, !0);
      const Me = await fn.sendOtp(Se);
      Xt.info(`${nC()} ${Me.phone}`), Y(x, Me.phone, !0), Y(A, Me.cooldownMs, !0), localStorage.setItem(_(J), _(x))
    } catch (Me) {
      Xt.error(Me.message)
    } finally {
      Y(z, !1)
    }
  }
  tn(() => {
    _(F).length === 6 && (Y(s, !0), (async () => {
      try {
        await fn.verifyOtp(_(F)), await Dt.refresh(), Xt.success(oC()), localStorage.removeItem(_(J)), a.onsuccess(_(x))
      } catch (Se) {
        Xt.error(Se.message)
      } finally {
        Y(F, ""), Y(s, !1)
      }
    })())
  });
  var ae = J7(),
    fe = I(ae);
  {
    var ie = Se => {
        var Me = W7();
        Z(Se, Me)
      },
      $ = Se => {
        var Me = or(),
          Pe = xt(Me);
        {
          var Ie = je => {
              var Ye = X7(),
                qe = xt(Ye),
                Be = I(qe),
                He = I(Be, !0);
              C(Be);
              var we = O(Be, 2),
                it = I(we, !0);
              C(we), C(qe);
              var mt = O(qe, 2),
                Ge = I(mt);
              Di(Ge, () => wt => (Y(q, H7(wt, {
                strictMode: !0,
                initialCountry: "br",
                loadUtils: () => t2(() => import("../chunks/Ce74ojkT.js"), [], import.meta.url),
                containerClass: "w-full",
                dropdownContainer: document.body
              })), () => {
                var Je;
                (Je = _(q)) == null || Je.destroy()
              }));
              var Xe = O(Ge, 2),
                vt = I(Xe),
                Ut = O(vt);
              {
                var _t = wt => {
                  var Je = $7(),
                    zt = I(Je);
                  C(Je), Ue(bt => ce(zt, `(${bt??""})`), [() => Np(_(A))]), Z(wt, Je)
                };
                Ee(Ut, wt => {
                  _(A) > 0 && wt(_t)
                })
              }
              C(Xe), C(mt), Ue((wt, Je, zt) => {
                ce(He, wt), ce(it, Je), Xe.disabled = _(b), ce(vt, `${zt??""} `)
              }, [() => $C(), () => KC(), () => eI()]), Ln("submit", mt, async () => {
                var Je;
                if (_(b)) return;
                if (!((Je = _(q)) != null && Je.isValidNumber())) {
                  Xt.error(cC());
                  return
                }
                const wt = _(q).getNumber();
                await te(wt)
              }), Z(je, Ye)
            },
            Ce = je => {
              var Ye = K7(),
                qe = xt(Ye),
                Be = I(qe),
                He = I(Be, !0);
              C(Be);
              var we = O(Be, 2),
                it = I(we);
              C(we), C(qe);
              var mt = O(qe, 2),
                Ge = I(mt);
              {
                const bt = (Rt, Pt) => {
                  let yt = () => Pt == null ? void 0 : Pt().cells;
                  var sr = or(),
                    tr = xt(sr);
                  ji(tr, () => N7, (tt, ht) => {
                    ht(tt, {
                      class: "border-primary",
                      children: (It, Bt) => {
                        var Nt = or(),
                          Ht = xt(Nt);
                        fi(Ht, 16, yt, yr => yr, (yr, Wt) => {
                          var Zt = or(),
                            jt = xt(Zt);
                          ji(jt, () => V7, (Jt, Lt) => {
                            Lt(Jt, {
                              get cell() {
                                return Wt
                              },
                              class: "border-base-content/20 size-11 sm:size-12"
                            })
                          }), Z(yr, Zt)
                        }), Z(It, Nt)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  }), Z(Rt, sr)
                };
                ji(Ge, () => U7, (Rt, Pt) => {
                  Pt(Rt, {
                    maxlength: 6,
                    class: "mx-auto w-max",
                    get disabled() {
                      return _(s)
                    },
                    get value() {
                      return _(F)
                    },
                    set value(yt) {
                      Y(F, yt, !0)
                    },
                    children: bt,
                    $$slots: {
                      default: !0
                    }
                  })
                })
              }
              C(mt);
              var Xe = O(mt, 2),
                vt = I(Xe);
              vt.__click = async () => {
                await te(_(x))
              };
              var Ut = I(vt),
                _t = O(Ut);
              {
                var wt = bt => {
                  var Rt = Y7(),
                    Pt = I(Rt);
                  C(Rt), Ue(yt => ce(Pt, `(${yt??""})`), [() => Np(_(A))]), Z(bt, Rt)
                };
                Ee(_t, bt => {
                  _(A) > 0 && bt(wt)
                })
              }
              C(vt);
              var Je = O(vt, 2);
              Je.__click = () => {
                Y(x, "")
              };
              var zt = I(Je, !0);
              C(Je), C(Xe), Ue((bt, Rt, Pt, yt) => {
                ce(He, bt), ce(it, `${Rt??""} ${_(x)??""}`), vt.disabled = _(b), ce(Ut, `${Pt??""} `), ce(zt, yt)
              }, [() => nI(), () => oI(), () => cI(), () => dI()]), Z(je, Ye)
            };
          Ee(Pe, je => {
            _(x) ? je(Ce, !1) : je(Ie)
          }, !0)
        }
        Z(Se, Me)
      };
    Ee(fe, Se => {
      _(d) ? Se(ie) : Se($, !1)
    })
  }
  C(ae), Z(m, ae), $r()
}
ni(["click"]);
var e9 = me('<dialog class="modal"><div class="modal-box h-72 max-w-sm"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <!></div></dialog>');

function t9(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15);
  var x = e9(),
    A = I(x),
    z = O(I(A), 2);
  {
    var b = s => {
      Q7(s, {
        onsuccess: () => d(!1)
      })
    };
    Ee(z, s => {
      d() && s(b)
    })
  }
  C(A), C(x), Di(x, () => s => {
    tn(() => {
      d() ? s.show() : s.close()
    })
  }), Ln("close", x, () => d(!1)), Z(m, x), $r()
}
var r9 = me('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><p class="whitespace-pre-wrap"><!></p> <div class="mt-4"><!></div> <div class="mt-2 flex justify-end gap-2"><button class="btn btn-soft tooltip" type="button"> </button> <div class="tooltip tooltip-top"><div class="tooltip-content translate-x-[-30%] p-2"> </div> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog>');

function n9(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15),
    x = et(!1),
    A = et(""),
    z = et(0),
    b = et(!1);
  tn(() => {
    d() && (async () => {
      try {
        Y(x, !0);
        const Be = await fn.getUserLastAppeal();
        if (Be === null) {
          Y(b, !1), Y(z, 0);
          return
        }
        const He = new Date(Be),
          we = 1440 * 60 * 1e3;
        Date.now() - He.getTime() < 90 * we ? (Y(b, !0), Y(z, Math.ceil((He.getTime() + 90 * we - Date.now()) / we), !0)) : Y(z, 0)
      } catch (Be) {
        Xt.error(Be.message)
      } finally {
        Y(x, !1)
      }
    })()
  });
  var s = r9(),
    F = I(s),
    q = O(I(F), 2),
    J = I(q, !0);
  C(q);
  var te = O(q, 2),
    ae = I(te),
    fe = I(ae);
  Jp(fe, () => gM()), C(ae);
  var ie = O(ae, 2),
    $ = I(ie);
  {
    let Be = ut(() => yM()),
      He = ut(() => wM()),
      we = ut(() => _(x) || _(b));
    F0($, {
      get label() {
        return _(Be)
      },
      get placeholder() {
        return _(He)
      },
      min: 1,
      max: 2056,
      class: "h-32",
      get disabled() {
        return _(we)
      },
      get value() {
        return _(A)
      },
      set value(it) {
        Y(A, it, !0)
      }
    })
  }
  C(ie);
  var Se = O(ie, 2),
    Me = I(Se);
  Me.__click = () => {
    d(!1)
  };
  var Pe = I(Me, !0);
  C(Me);
  var Ie = O(Me, 2),
    Ce = I(Ie),
    je = I(Ce, !0);
  C(Ce);
  var Ye = O(Ce, 2),
    qe = I(Ye, !0);
  C(Ye), C(Ie), C(Se), C(te), C(F), C(s), Di(s, () => Be => {
    tn(() => {
      d() ? Be.show() : Be.close()
    })
  }), Ue((Be, He, we, it) => {
    ce(J, Be), Me.disabled = _(x), ce(Pe, He), ce(je, we), Ye.disabled = _(x) || _(b) || _(A).length <= 1, ce(qe, it)
  }, [() => a.userData.banned ? ty() : pM(), () => xs(), () => _(b) ? DM({
    days: _(z)
  }) : "", () => PM()]), Ln("close", s, () => d(!1)), Ln("submit", te, async () => {
    try {
      Y(x, !0), await fn.submitBanAppeal(_(A)), Xt.success(MM()), d(!1)
    } catch (Be) {
      Xt.error(Be.message, {
        duration: 5e3
      })
    } finally {
      Y(x, !1)
    }
  }), Z(m, s), $r()
}
ni(["click"]);
var i9 = me("<span> </span>");

function T0(m, a) {
  Wr(a, !0);
  var d = i9(),
    x = I(d, !0);
  C(d), Ue(() => {
    qr(d, 1, `size-4 items-center justify-center rounded-full bg-red-500 font-semibold text-red-50 ${a.count<10?"text-xs":"text-[10px]"} ${a.class??""}`), ce(x, a.count < 10 ? a.count : "9+")
  }), Z(m, d), $r()
}
var a9 = me('<p class="text-error mt-1 text-sm"> </p>'),
  o9 = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  s9 = me('<dialog class="modal !bg-black/80"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <div class="flex items-center gap-2"><!> <h3 class="text-lg font-bold"> </h3></div> <p class="mt-4"><b> </b> </p> <p class="mt-2"> </p> <div class="rounded-box border-base-content/20 border-1 mt-6 w-full py-1.5 text-center"> </div> <input class="input input-bordered mt-2 w-full" type="text"/> <!> <div class="mt-6 flex justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-error relative"> <!></button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function l9(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15),
    x = et(""),
    A = et(null),
    z = et(!1),
    b = ut(() => {
      var wt;
      return ((wt = Dt.data) == null ? void 0 : wt.name) ?? ""
    });
  tn(() => {
    d() || (Y(x, ""), Y(A, null))
  });
  var s = s9(),
    F = I(s),
    q = O(I(F), 2),
    J = I(q);
  jb(J, {
    class: "text-error size-5"
  });
  var te = O(J, 2),
    ae = I(te, !0);
  C(te), C(q);
  var fe = O(q, 2),
    ie = I(fe),
    $ = I(ie, !0);
  C(ie);
  var Se = O(ie);
  C(fe);
  var Me = O(fe, 2),
    Pe = I(Me);
  C(Me);
  var Ie = O(Me, 2),
    Ce = I(Ie, !0);
  C(Ie);
  var je = O(Ie, 2);
  za(je);
  var Ye = O(je, 2);
  {
    var qe = wt => {
      var Je = a9(),
        zt = I(Je, !0);
      C(Je), Ue(() => ce(zt, _(A))), Z(wt, Je)
    };
    Ee(Ye, wt => {
      _(A) && wt(qe)
    })
  }
  var Be = O(Ye, 2),
    He = I(Be);
  He.__click = () => {
    d(!1)
  };
  var we = I(He, !0);
  C(He);
  var it = O(He, 2);
  it.__click = async () => {
    if (_(x) !== _(b)) {
      Y(A, wb(), !0);
      return
    }
    try {
      Y(z, !0), await fn.deleteMe(_(b)), Xt.warning(FC()), await Dt.logout(), d(!1)
    } catch (wt) {
      Xt.error(wt.message)
    } finally {
      Y(z, !1)
    }
  };
  var mt = I(it),
    Ge = O(mt);
  {
    var Xe = wt => {
      var Je = o9();
      Z(wt, Je)
    };
    Ee(Ge, wt => {
      _(z) && wt(Xe)
    })
  }
  C(it), C(Be), C(F);
  var vt = O(F, 2),
    Ut = I(vt),
    _t = I(Ut, !0);
  C(Ut), C(vt), C(s), Di(s, () => wt => {
    tn(() => {
      d() ? wt.show() : wt.close()
    })
  }), Ue((wt, Je, zt, bt, Rt, Pt, yt, sr, tr) => {
    ce(ae, wt), ce($, Je), ce(Se, ` ${zt??""}`), ce(Pe, `${bt??""} ${Rt??""}`), ce(Ce, _(b)), cr(je, "placeholder", Pt), ce(we, yt), it.disabled = _(z), ce(mt, `${sr??""} `), ce(_t, tr)
  }, [() => km(), () => y5(), () => w5(), () => L4(), () => R4(), () => O4(), () => Yh(), () => km(), () => xs()]), Ln("close", s, () => d(!1)), Xh(je, () => _(x), wt => Y(x, wt)), Z(m, s), $r()
}
ni(["click"]);
var c9 = me('<p class="text-base-content/80 text-sm"> </p>'),
  u9 = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  h9 = me('<h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <!> <div class="mt-4 flex justify-end gap-2"><form method="dialog"><button class="btn btn-soft"> </button></form> <button> <!></button></div>', 1);

function d9(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15),
    x = At(a, "type", 3, "confirmation"),
    A = At(a, "buttonText", 19, () => V0()),
    z = et(!1);
  jg(m, {
    dialogClass: "!bg-black/80",
    get open() {
      return d()
    },
    set open(b) {
      d(b)
    },
    children: (b, s) => {
      var F = h9(),
        q = xt(F),
        J = I(q, !0);
      C(q);
      var te = O(q, 2),
        ae = I(te, !0);
      C(te);
      var fe = O(te, 2);
      {
        var ie = Be => {
          var He = c9(),
            we = I(He, !0);
          C(He), Ue(() => ce(we, a.subDescription)), Z(Be, He)
        };
        Ee(fe, Be => {
          a.subDescription && Be(ie)
        })
      }
      var $ = O(fe, 2),
        Se = I($),
        Me = I(Se),
        Pe = I(Me, !0);
      C(Me), C(Se);
      var Ie = O(Se, 2);
      let Ce;
      Ie.__click = async () => {
        try {
          Y(z, !0), d(await a.onConfirm())
        } finally {
          Y(z, !1)
        }
      };
      var je = I(Ie),
        Ye = O(je);
      {
        var qe = Be => {
          var He = u9();
          Z(Be, He)
        };
        Ee(Ye, Be => {
          _(z) && Be(qe)
        })
      }
      C(Ie), C($), Ue(Be => {
        ce(J, a.title), ce(ae, a.description), ce(Pe, Be), Ce = qr(Ie, 1, "btn relative", null, Ce, {
          "btn-error": x() === "warning",
          "btn-primary": x() === "confirmation"
        }), Ie.disabled = _(z), ce(je, `${A()??""} `)
      }, [() => Yh()]), Z(b, F)
    },
    $$slots: {
      default: !0
    }
  }), $r()
}
ni(["click"]);

function p9(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15);
  {
    let x = ut(() => B0()),
      A = ut(() => C4()),
      z = ut(() => q4());
    d9(m, {
      type: "warning",
      get title() {
        return _(x)
      },
      get description() {
        return _(A)
      },
      get subDescription() {
        return _(z)
      },
      onConfirm: async () => {
        try {
          return await fn.deleteSessions(), Xt.success(qb()), await Dt.logout(), !0
        } catch {
          return Xt.error(Vb()), !1
        }
      },
      get open() {
        return d()
      },
      set open(b) {
        d(b)
      }
    })
  }
  $r()
}
var f9 = me('<span class="center-absolute loading loading-spinner absolute"></span>'),
  m9 = me('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  g9 = me('<span class="center-absolute loading loading-spinner absolute"></span>'),
  _9 = me('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  v9 = me('<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>'),
  y9 = me('<a class="btn border-0 bg-[#5865F2] text-white"><!> </a>'),
  x9 = me('<button class="btn btn-error btn-soft"><!> </button>'),
  b9 = me('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative w-max"><!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <!></div> <div class="tooltip flex w-full flex-col gap-3 max-sm:overflow-x-hidden"><!> <!> <label class="label text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="col mt-4 flex flex-wrap justify-between gap-2"><div class="dropdown dropdown-top max-sm:dropdown-top col ml-1 mt-4 flex gap-2"><button tabindex="0" class="btn btn-sm btn-soft"> </button> <ul class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 font-medium shadow-sm"><li><button type="button" class="text-error py-2"> </button></li> <li><button type="button" class="text-error py-2"> </button></li></ul></div> <div class="col mt-4 flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <!> <!>', 1);

function w9(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15),
    x = et(zi(a.userData.name)),
    A = et(zi(a.userData.discord)),
    z = et(zi(a.userData.showLastPixel)),
    b = et(!1),
    s = et(void 0),
    F = et(!1),
    q = et(!1);
  const J = Tb("2025-09_discord_linking");
  let te = et(!!a.userData.discordId),
    ae = et(void 0),
    fe = et(void 0);
  tn(() => {
    Y(x, a.userData.name, !0), Y(z, a.userData.showLastPixel, !0)
  }), tn(() => {
    d() && !_(s) && fn.getMyProfilePictures().then(Yt => {
      Y(s, Yt, !0)
    }).catch(Yt => {
      Xt.error(Yt.message)
    })
  });
  let ie = et(!1);
  async function $(Yt) {
    try {
      Y(ie, !0), await fn.changeProfilePicture(Yt), await Dt.refresh()
    } finally {
      Y(ie, !1)
    }
  }
  var Se = b9(),
    Me = xt(Se),
    Pe = I(Me),
    Ie = O(I(Pe), 2),
    Ce = I(Ie, !0);
  C(Ie);
  var je = O(Ie, 2),
    Ye = I(je),
    qe = I(Ye),
    Be = I(qe),
    He = I(Be);
  Mo(He, {
    class: "size-30",
    get userId() {
      return a.userData.id
    },
    get pictureUrl() {
      return a.userData.picture
    }
  });
  var we = O(He, 2),
    it = I(we);
  L0(it, {
    class: "size-5"
  }), C(we), C(Be);
  var mt = O(Be, 2);
  {
    var Ge = Yt => {
      var Lr = v9(),
        Ir = I(Lr),
        Jr = I(Ir, !0);
      C(Ir);
      var Tr = O(Ir, 2),
        Ar = I(Tr);
      {
        var xr = Yr => {
          var Le = m9();
          Le.__click = () => {
            $()
          };
          var j = I(Le);
          Mo(j, {
            class: "size-10 border",
            get userId() {
              return a.userData.id
            }
          });
          var E = O(j, 2);
          {
            var D = N => {
              var X = f9();
              Z(N, X)
            };
            Ee(E, N => {
              _(ie) && N(D)
            })
          }
          C(Le), Ue(() => Le.disabled = _(ie)), Z(Yr, Le)
        };
        Ee(Ar, Yr => {
          a.userData.picture && Yr(xr)
        })
      }
      var qt = O(Ar, 2);
      fi(qt, 17, () => _(s), Yr => Yr.id, (Yr, Le) => {
        var j = or(),
          E = xt(j);
        {
          var D = N => {
            var X = _9();
            X.__click = () => {
              $(_(Le).id)
            };
            var ee = I(X);
            Mo(ee, {
              class: "size-10 border",
              get userId() {
                return a.userData.id
              },
              get pictureUrl() {
                return _(Le).url
              }
            });
            var pe = O(ee, 2);
            {
              var be = ye => {
                var Oe = g9();
                Z(ye, Oe)
              };
              Ee(pe, ye => {
                _(ie) && ye(be)
              })
            }
            C(X), Ue(() => X.disabled = _(ie)), Z(N, X)
          };
          Ee(E, N => {
            a.userData.picture !== _(Le).url && N(D)
          })
        }
        Z(Yr, j)
      }), C(Tr), C(Lr), Ue(Yr => ce(Jr, Yr), [() => h5()]), Z(Yt, Lr)
    };
    Ee(mt, Yt => {
      var Lr;
      (Lr = _(s)) != null && Lr.length && Yt(Ge)
    })
  }
  C(qe);
  var Xe = O(qe, 2),
    vt = I(Xe);
  {
    let Yt = ut(() => Em()),
      Lr = ut(() => Em());
    Bm(vt, {
      get label() {
        return _(Yt)
      },
      get placeholder() {
        return _(Lr)
      },
      min: 1,
      max: 16,
      get value() {
        return _(x)
      },
      set value(Ir) {
        Y(x, Ir, !0)
      },
      get validate() {
        return _(ae)
      },
      set validate(Ir) {
        Y(ae, Ir, !0)
      }
    })
  }
  var Ut = O(vt, 2);
  {
    var _t = Yt => {
        var Lr = or(),
          Ir = xt(Lr);
        {
          var Jr = Ar => {
              var xr = y9(),
                qt = I(xr);
              Nm(qt, {
                class: "size-4.5"
              });
              var Yr = O(qt);
              C(xr), Ue((Le, j) => {
                cr(xr, "href", Le), ce(Yr, ` ${j??""}`)
              }, [() => Sb("/discord/authorize"), () => kC()]), Z(Ar, xr)
            },
            Tr = Ar => {
              var xr = x9();
              xr.__click = async () => {
                try {
                  Y(b, !0), await fn.unlinkDiscord(), Dt.refresh(), Xt.success(IC()), Y(te, !1)
                } catch (Le) {
                  Xt.error(Le.message, {
                    duration: 5e3
                  })
                } finally {
                  Y(b, !1)
                }
              };
              var qt = I(xr);
              Nm(qt, {
                class: "size-4.5"
              });
              var Yr = O(qt);
              C(xr), Ue(Le => {
                xr.disabled = _(b), ce(Yr, ` ${Le??""}`)
              }, [() => {
                var Le;
                return zC({
                  username: ((Le = a.userData) == null ? void 0 : Le.discord) ?? ""
                })
              }]), Z(Ar, xr)
            };
          Ee(Ir, Ar => {
            _(te) ? Ar(Tr, !1) : Ar(Jr)
          })
        }
        Z(Yt, Lr)
      },
      wt = Yt => {
        {
          let Lr = ut(() => dT());
          Bm(Yt, {
            label: "Discord",
            get placeholder() {
              return _(Lr)
            },
            max: 32,
            get value() {
              return _(A)
            },
            set value(Ir) {
              Y(A, Ir, !0)
            },
            get validate() {
              return _(fe)
            },
            set validate(Ir) {
              Y(fe, Ir, !0)
            }
          })
        }
      };
    Ee(Ut, Yt => {
      J ? Yt(_t) : Yt(wt, !1)
    })
  }
  var Je = O(Ut, 2),
    zt = I(Je);
  za(zt);
  var bt = O(zt);
  C(Je), C(Xe), C(Ye);
  var Rt = O(Ye, 2),
    Pt = I(Rt),
    yt = I(Pt),
    sr = I(yt, !0);
  C(yt);
  var tr = O(yt, 2),
    tt = I(tr),
    ht = I(tt);
  ht.__click = () => {
    Y(q, !0)
  };
  var It = I(ht, !0);
  C(ht), C(tt);
  var Bt = O(tt, 2),
    Nt = I(Bt);
  Nt.__click = () => {
    Y(F, !0)
  };
  var Ht = I(Nt, !0);
  C(Nt), C(Bt), C(tr), C(Pt);
  var yr = O(Pt, 2),
    Wt = I(yr);
  Wt.__click = () => {
    d(!1)
  };
  var Zt = I(Wt, !0);
  C(Wt);
  var jt = O(Wt, 2),
    Jt = I(jt, !0);
  C(jt), C(yr), C(Rt), C(je), C(Pe), C(Me), Di(Me, () => Yt => {
    tn(() => {
      d() ? Yt.show() : Yt.close()
    })
  });
  var Lt = O(Me, 2);
  l9(Lt, {
    get open() {
      return _(F)
    },
    set open(Yt) {
      Y(F, Yt, !0)
    }
  });
  var Gt = O(Lt, 2);
  p9(Gt, {
    get open() {
      return _(q)
    },
    set open(Yt) {
      Y(q, Yt, !0)
    }
  }), Ue((Yt, Lr, Ir, Jr, Tr, Ar, xr, qt, Yr) => {
    ce(Ce, Yt), cr(we, "data-tip", Lr), cr(Xe, "data-tip", Ir), ce(bt, ` ${Jr??""}`), ce(sr, Tr), ce(It, Ar), ce(Ht, xr), Wt.disabled = _(b), ce(Zt, qt), jt.disabled = _(b), ce(Jt, Yr)
  }, [() => mI(), () => Fb(), () => sM(), () => f5(), () => A4(), () => B0(), () => km(), () => xs(), () => Kb()]), Ln("close", Me, () => d(!1)), Ln("submit", je, async () => {
    var Yt;
    try {
      if (!((Yt = _(ae)) != null && Yt())) return;
      Y(b, !0), await fn.updateMe({
        name: _(x),
        showLastPixel: _(z)
      }), Dt.refresh(), Xt.success(bC()), d(!1)
    } catch (Lr) {
      Xt.error(Lr.message, {
        duration: 5e3
      })
    } finally {
      Y(b, !1)
    }
  }), E0(zt, () => _(z), Yt => Y(z, Yt)), Z(m, Se), $r()
}
ni(["click"]);
var T9 = jr('<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>');

function S9(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = T9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var P9 = jr('<svg><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Zm-10-270Z"></path></svg>');

function C9(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = P9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var I9 = jr('<svg><path d="M480-360q50 0 85-35t35-85q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 50 35 85t85 35Zm0 80q-83 0-141.5-58.5T280-480q0-83 58.5-141.5T480-680q83 0 141.5 58.5T680-480q0 83-58.5 141.5T480-280ZM200-440H40v-80h160v80Zm720 0H760v-80h160v80ZM440-760v-160h80v160h-80Zm0 720v-160h80v160h-80ZM256-650l-101-97 57-59 96 100-52 56Zm492 496-97-101 53-55 101 97-57 59Zm-98-550 97-101 59 57-100 96-56-52ZM154-212l101-97 55 53-97 101-59-57Zm326-268Z"></path></svg>');

function M9(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = I9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var A9 = jr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>');

function S0(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = A9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var k9 = jr('<svg><path d="M160-200v-80h80v-280q0-83 50-147.5T420-792v-28q0-25 17.5-42.5T480-880q25 0 42.5 17.5T540-820v28q80 20 130 84.5T720-560v280h80v80H160Zm320-300Zm0 420q-33 0-56.5-23.5T400-160h160q0 33-23.5 56.5T480-80ZM320-280h320v-280q0-66-47-113t-113-47q-66 0-113 47t-47 113v280Z"></path></svg>');

function E9(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = k9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var L9 = jr('<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>');

function z9(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = L9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var D9 = jr('<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>');

function R9(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = D9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    viewBox: "0 0 216 216",
    ...d
  }), void 0, void 0, void 0, "svelte-14mu38d"), Z(m, x)
}
var F9 = jr('<svg><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240ZM330-120 120-330v-300l210-210h300l210 210v300L630-120H330Zm34-80h232l164-164v-232L596-760H364L200-596v232l164 164Zm116-280Z"></path></svg>');

function lg(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = F9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var B9 = jr('<svg><path d="M480-440q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0-80q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0 440q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-400Zm0-315-240 90v189q0 54 15 105t41 96q42-21 88-33t96-12q50 0 96 12t88 33q26-45 41-96t15-105v-189l-240-90Zm0 515q-36 0-70 8t-65 22q29 30 63 52t72 34q38-12 72-34t63-52q-31-14-65-22t-70-8Z"></path></svg>');

function Pm(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = B9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var O9 = jr('<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>');

function N9(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = O9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var j9 = jr('<svg><path fill="#fff" d="m2200 1300-400 400h-400l-350 350v-350H600V200h1600z"></path><g fill="#9146ff"><path d="M500 0 0 500v1800h600v500l500-500h400l900-900V0H500zm1700 1300-400 400h-400l-350 350v-350H600V200h1600v1100z"></path><path d="M1700 550h200v600h-200zm-550 0h200v600h-200z"></path></g></svg>');

function q9(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = j9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xml:space": "preserve",
    viewBox: "0 0 2400 2800",
    ...d
  })), Z(m, x)
}
var V9 = jr('<svg><path d="M480-320q75 0 127.5-52.5T660-500q0-75-52.5-127.5T480-680q-75 0-127.5 52.5T300-500q0 75 52.5 127.5T480-320Zm0-72q-45 0-76.5-31.5T372-500q0-45 31.5-76.5T480-608q45 0 76.5 31.5T588-500q0 45-31.5 76.5T480-392Zm0 192q-146 0-266-81.5T40-500q54-137 174-218.5T480-800q146 0 266 81.5T920-500q-54 137-174 218.5T480-200Zm0-300Zm0 220q113 0 207.5-59.5T832-500q-50-101-144.5-160.5T480-720q-113 0-207.5 59.5T128-500q50 101 144.5 160.5T480-280Z"></path></svg>');

function U9(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = V9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var Z9 = jr('<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>');

function e1(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = Z9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var G9 = jr('<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>');

function H9(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = G9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var W9 = jr('<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>');

function $9(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = W9();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var X9 = me('<span class="tooltip font-flag ml-0.5"> </span>'),
  Y9 = me('<div class="mt-1"><!></div>'),
  K9 = me('<p class="w-full"> <!></p>'),
  J9 = me('<p class="w-full"><!></p>'),
  Q9 = me('<div class=" flex items-center gap-[8px]"><!> <!> <button class="btn btn-error btn-sm"><!> </button></div>'),
  eF = me('<span class="center-absolute loading loading-spinner loading-xs absolute"></span>'),
  tF = me("<li><button><!> </button></li>"),
  rF = me('<div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div>'),
  nF = me('<button class="btn btn-sm btn-circle tooltip" data-tip="Toggle pixel arts"><!></button>'),
  iF = me('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>'),
  aF = me('<a class="btn w-full" target="_blank"><!> </a>'),
  oF = me('<a class="btn w-full" target="_blank"><!> </a>'),
  sF = me('<a class="btn w-full" target="_blank"><!> </a>'),
  lF = me('<form class="w-full" method="POST"><button class="btn w-full"><!> </button></form> <a class="btn w-full" target="_blank"><!> </a>', 1),
  cF = me('<div class="dropdown"><div tabindex="0" role="button"><!> <!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="-1"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><!> <div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle tooltip"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 w-max rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div> <!> <!> <button class="btn btn-sm btn-circle tooltip relative before:-left-1/2"><!> <!></button></div></div>  <!> <!> <!> <!> <a class="btn w-full" href="https://www.twitch.tv/directory/category/wplace" target="_blank"><!> </a> <a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> Discord</a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> Reddit</a> <!> <button class="btn"><!> </button></section></div></div> <!>', 1);

function uF(m, a) {
  Wr(a, !0);
  let d = et(!1),
    x = et(!1),
    A = et(!0);

  function z() {
    var fe;
    (fe = document.activeElement) == null || fe.blur()
  }
  const b = [{
    label: "üá∫üá∏ English",
    key: "en"
  }, {
    label: "üáßüá∑ Portugu√™s",
    key: "pt"
  }];
  let s = et(""),
    F = et(void 0);
  const q = ut(() => !!a.user.timeoutUntil);
  var J = or(),
    te = xt(J);
  {
    var ae = fe => {
      var ie = cF(),
        $ = xt(ie),
        Se = I($);
      let Me;
      var Pe = I(Se);
      D0(Pe, {
        get userId() {
          return a.user.data.id
        },
        get level() {
          return a.user.data.level
        },
        get pictureUrl() {
          return a.user.data.picture
        }
      });
      var Ie = O(Pe, 2);
      {
        var Ce = st => {
          T0(st, {
            class: "absolute -right-0.5 -top-0.5",
            get count() {
              return a.user.notificiationCount
            }
          })
        };
        Ee(Ie, st => {
          a.user.notificiationCount && st(Ce)
        })
      }
      C(Se);
      var je = O(Se, 2),
        Ye = I(je);
      Ye.__click = z;
      var qe = I(Ye);
      ws(qe, {
        class: "size-5"
      }), C(Ye);
      var Be = O(Ye, 2),
        He = I(Be),
        we = I(He);
      Mo(we, {
        get userId() {
          return a.user.data.id
        },
        get pictureUrl() {
          return a.user.data.picture
        },
        get isSuspended() {
          return _(q)
        }
      });
      var it = O(we, 2);
      it.__click = () => {
        Y(d, !0)
      };
      var mt = I(it);
      Om(mt, {
        class: "size-4"
      }), C(it), C(He);
      var Ge = O(He, 2),
        Xe = I(Ge),
        vt = I(Xe),
        Ut = I(vt, !0);
      C(vt);
      var _t = O(vt, 2),
        wt = I(_t);
      C(_t);
      var Je = O(_t, 2);
      {
        var zt = st => {
          const Tt = ut(() => qo(a.user.data.equippedFlag));
          var nr = X9(),
            Ur = I(nr, !0);
          C(nr), Ue(() => {
            cr(nr, "data-tip", _(Tt).name), ce(Ur, _(Tt).flag)
          }), Z(st, nr)
        };
        Ee(Je, st => {
          a.user.data.equippedFlag && st(zt)
        })
      }
      var bt = O(Je, 2);
      {
        var Rt = st => {
          var Tt = Y9(),
            nr = I(Tt);
          ed(nr, {
            get username() {
              return a.user.data.discord
            },
            get id() {
              return a.user.data.discordId
            }
          }), C(Tt), Z(st, Tt)
        };
        Ee(bt, st => {
          a.user.data.discord && st(Rt)
        })
      }
      C(Xe);
      var Pt = O(Xe, 2),
        yt = I(Pt);
      Il(yt, {
        class: "inline size-4"
      });
      var sr = O(yt, 2),
        tr = I(sr),
        tt = O(tr),
        ht = I(tt, !0);
      C(tt), C(sr), C(Pt);
      var It = O(Pt, 2),
        Bt = I(It);
      S9(Bt, {
        class: "inline size-4"
      });
      var Nt = O(Bt, 2),
        Ht = I(Nt),
        yr = I(Ht);
      C(Ht);
      var Wt = O(Ht),
        Zt = O(Wt),
        jt = I(Zt);
      ch(jt, {
        class: "mb-0.5 inline size-4 opacity-50"
      }), C(Zt), C(Nt), C(It), C(Ge), C(Be);
      var Jt = O(Be, 2),
        Lt = I(Jt);
      {
        var Gt = st => {
          var Tt = Q9(),
            nr = I(Tt);
          lg(nr, {
            class: "size-6 text-red-500"
          });
          var Ur = O(nr, 2);
          {
            var Ot = hn => {
                var dn = K9(),
                  nn = I(dn),
                  Ke = O(nn);
                {
                  var St = wr => {
                      var mr = qi();
                      Ue(Mr => ce(mr, `(${Mr??""})`), [() => Gv({
                        reason: Ib()
                      })]), Z(wr, mr)
                    },
                    kr = wr => {
                      var mr = or(),
                        Mr = xt(mr);
                      {
                        var gn = Rn => {
                          var ln = qi();
                          Ue(Gn => ce(ln, `(${Gn??""})`), [() => Gv({
                            reason: Mb()
                          })]), Z(Rn, ln)
                        };
                        Ee(Mr, Rn => {
                          a.user.data.suspensionReason === "multi-accounting" && Rn(gn)
                        }, !0)
                      }
                      Z(wr, mr)
                    };
                  Ee(Ke, wr => {
                    a.user.data.suspensionReason === "bot" ? wr(St) : wr(kr, !1)
                  })
                }
                C(dn), Ue(wr => ce(nn, `${wr??""} `), [() => Pb()]), Z(hn, dn)
              },
              Fr = hn => {
                var dn = or(),
                  nn = xt(dn);
                {
                  var Ke = St => {
                    var kr = J9(),
                      wr = I(kr);
                    Jp(wr, () => Cb({
                      until: `<span class="text-secondary font-medium text-nowrap">${a.user.timeoutUntil.toLocaleString()}</span>`
                    })), C(kr), Z(St, kr)
                  };
                  Ee(nn, St => {
                    a.user.timeoutUntil && St(Ke)
                  }, !0)
                }
                Z(hn, dn)
              };
            Ee(Ur, hn => {
              a.user.data.timeoutUntil && new Date(a.user.data.timeoutUntil).getTime() >= Date.now() + 31536e6 ? hn(Ot) : hn(Fr, !1)
            })
          }
          var Xr = O(Ur, 2);
          Xr.__click = hn => {
            var dn;
            (dn = a.onbanappeal) == null || dn.call(a)
          };
          var mn = I(Xr);
          lg(mn, {
            class: "size-5 text-red-500"
          });
          var sn = O(mn, 1, !0);
          C(Xr), C(Tt), Ue(hn => ce(sn, hn), [() => BM()]), Z(st, Tt)
        };
        Ee(Lt, st => {
          _(q) && st(Gt)
        })
      }
      var Yt = O(Lt, 2),
        Lr = I(Yt),
        Ir = I(Lr, !0);
      C(Lr);
      var Jr = O(Lr, 2),
        Tr = I(Jr),
        Ar = I(Tr),
        xr = I(Ar);
      N9(xr, {
        class: "size-4"
      }), C(Ar);
      var qt = O(Ar, 2);
      fi(qt, 21, () => b, $h, (st, Tt) => {
        const nr = ut(() => _(s) === _(Tt).key);
        var Ur = tF(),
          Ot = I(Ur);
        let Fr;
        Ot.__click = () => {
          localStorage.setItem(Ob, _(Tt).key), Y(s, _(Tt).key, !0), location.reload()
        };
        var Xr = I(Ot);
        {
          var mn = hn => {
            var dn = eF();
            Z(hn, dn)
          };
          Ee(Xr, hn => {
            _(nr) && hn(mn)
          })
        }
        var sn = O(Xr);
        C(Ot), C(Ur), Ue(() => {
          Fr = qr(Ot, 1, "font-flag relative font-medium", null, Fr, {
            "bg-base-200": _(nr)
          }), ce(sn, ` ${_(Tt).label??""}`)
        }), Z(st, Ur)
      }), C(qt), C(Tr);
      var Yr = O(Tr, 2),
        Le = I(Yr);
      Le.__click = () => {
        ka.muted = !ka.muted
      };
      var j = I(Le);
      {
        var E = st => {
            H9(st, {
              class: "size-4"
            })
          },
          D = st => {
            $9(st, {
              class: "size-4"
            })
          };
        Ee(j, st => {
          ka.muted ? st(E) : st(D, !1)
        })
      }
      C(Le), C(Yr);
      var N = O(Yr, 2);
      {
        var X = st => {
          var Tt = rF(),
            nr = I(Tt);
          nr.__click = () => {
            ka.theme = ka.theme === "dark" ? "custom-winter" : "dark"
          };
          var Ur = I(nr);
          {
            var Ot = Xr => {
                M9(Xr, {
                  class: "size-4"
                })
              },
              Fr = Xr => {
                C9(Xr, {
                  class: "size-4"
                })
              };
            Ee(Ur, Xr => {
              ka.theme === "dark" ? Xr(Ot) : Xr(Fr, !1)
            })
          }
          C(nr), C(Tt), Ue(Xr => cr(Tt, "data-tip", Xr), [() => ka.theme === "dark" ? T4() : x4()]), Z(st, Tt)
        };
        Ee(N, st => {
          var Tt, nr;
          Ea((nr = (Tt = a.user) == null ? void 0 : Tt.data) == null ? void 0 : nr.role, ["admin", "moderator", "global_moderator"]) && st(X)
        })
      }
      var ee = O(N, 2);
      {
        var pe = st => {
          var Tt = nF();
          Tt.__click = () => {
            var Fr;
            Y(A, !_(A)), (Fr = a.ontogglepixelarts) == null || Fr.call(a, _(A))
          };
          var nr = I(Tt);
          {
            var Ur = Fr => {
                U9(Fr, {
                  class: "size-4"
                })
              },
              Ot = Fr => {
                e1(Fr, {
                  class: "size-4"
                })
              };
            Ee(nr, Fr => {
              _(A) ? Fr(Ot, !1) : Fr(Ur)
            })
          }
          C(Tt), Z(st, Tt)
        };
        Ee(ee, st => {
          var Tt, nr;
          Ea((nr = (Tt = a.user) == null ? void 0 : Tt.data) == null ? void 0 : nr.role, ["admin"]) && st(pe)
        })
      }
      var be = O(ee, 2);
      be.__click = function(...st) {
        var Tt;
        (Tt = a.onnotificationclick) == null || Tt.apply(this, st)
      };
      var ye = I(be);
      E9(ye, {
        class: "size-4"
      });
      var Oe = O(ye, 2);
      {
        var oe = st => {
          T0(st, {
            class: "absolute -right-1 -top-1",
            get count() {
              return a.user.notificiationCount
            }
          })
        };
        Ee(Oe, st => {
          a.user.notificiationCount && st(oe)
        })
      }
      C(be), C(Jr), C(Yt);
      var K = O(Yt, 2);
      {
        var he = st => {
          var Tt = iF();
          Tt.__click = async () => {
            var Ot;
            try {
              const Fr = await ((Ot = _(F)) == null ? void 0 : Ot.prompt());
              (Fr == null ? void 0 : Fr.outcome) === "accepted" && Y(F, void 0)
            } catch (Fr) {
              Xt.error(Qw({
                error: Fr.message
              }))
            }
          };
          var nr = I(Tt);
          yg(nr, {
            class: "size-5"
          });
          var Ur = O(nr);
          C(Tt), Ue(Ot => ce(Ur, ` ${Ot??""}`), [() => r5()]), Z(st, Tt)
        };
        Ee(K, st => {
          _(F) && st(he)
        })
      }
      var Q = O(K, 2);
      {
        var ze = st => {
          var Tt = aF(),
            nr = I(Tt);
          Pm(nr, {
            class: "size-5"
          });
          var Ur = O(nr);
          C(Tt), Ue(Ot => {
            cr(Tt, "href", `${Ni.url.origin??""}/admin/dashboard`), ce(Ur, ` ${Ot??""}`)
          }, [() => o4()]), Z(st, Tt)
        };
        Ee(Q, st => {
          var Tt, nr;
          Ea((nr = (Tt = a.user) == null ? void 0 : Tt.data) == null ? void 0 : nr.role, ["admin"]) && st(ze)
        })
      }
      var $e = O(Q, 2);
      {
        var Re = st => {
          var Tt = oF(),
            nr = I(Tt);
          Pm(nr, {
            class: "size-5"
          });
          var Ur = O(nr);
          C(Tt), Ue(Ot => {
            cr(Tt, "href", `${Ni.url.origin??""}/moderation`), ce(Ur, ` ${Ot??""}`)
          }, [() => VI()]), Z(st, Tt)
        };
        Ee($e, st => {
          var Tt;
          Ea((Tt = a.user.data) == null ? void 0 : Tt.role, ["admin", "moderator", "global_moderator"]) && st(Re)
        })
      }
      var ft = O($e, 2);
      {
        var Mt = st => {
          var Tt = sF(),
            nr = I(Tt);
          Pm(nr, {
            class: "size-5"
          });
          var Ur = O(nr);
          C(Tt), Ue(Ot => {
            cr(Tt, "href", `${Ni.url.origin??""}/appeal`), ce(Ur, ` ${Ot??""}`)
          }, [() => EM()]), Z(st, Tt)
        };
        Ee(ft, st => {
          var Tt, nr;
          Ea((nr = (Tt = a.user) == null ? void 0 : Tt.data) == null ? void 0 : nr.role, ["admin"]) && st(Mt)
        })
      }
      var Et = O(ft, 2),
        dt = I(Et);
      q9(dt, {
        class: "size-5"
      });
      var Kt = O(dt);
      C(Et);
      var Qt = O(Et, 2),
        Sr = I(Qt);
      Fm(Sr, {
        class: "size-5"
      }), wn(), C(Qt);
      var Ft = O(Qt, 2),
        Ze = I(Ft);
      R9(Ze, {
        class: "size-5"
      }), wn(), C(Ft);
      var Pr = O(Ft, 2);
      {
        var br = st => {
          var Tt = lF(),
            nr = xt(Tt),
            Ur = I(nr),
            Ot = I(Ur);
          z9(Ot, {
            class: "size-5"
          });
          var Fr = O(Ot);
          C(Ur), C(nr);
          var Xr = O(nr, 2),
            mn = I(Xr);
          ch(mn, {
            class: "size-5"
          });
          var sn = O(mn);
          C(Xr), Ue((hn, dn, nn) => {
            cr(nr, "action", `${bb}/payment/create-portal-session`), ce(Fr, ` ${hn??""}`), cr(Xr, "href", dn), ce(sn, ` ${nn??""}`)
          }, [() => Zb(), q0, () => J0()]), Z(st, Tt)
        };
        Ee(Pr, st => {
          var Tt;
          (Tt = a.user.data) != null && Tt.isCustomer && st(br)
        })
      }
      var Rr = O(Pr, 2);
      Rr.__click = async () => {
        var st;
        try {
          Y(x, !0), await a.user.logout(), z(), Xt.warning(NC(), {
            icon: S0
          }), (st = a.onlogout) == null || st.call(a)
        } catch {
          Xt.error(VC())
        } finally {
          Y(x, !1)
        }
      };
      var Dr = I(Rr);
      S0(Dr, {
        class: "size-5"
      });
      var ot = O(Dr);
      C(Rr), C(Jt), C(je), C($);
      var dr = O($, 2);
      w9(dr, {
        get userData() {
          return a.user.data
        },
        get open() {
          return _(d)
        },
        set open(st) {
          Y(d, st, !0)
        }
      }), Ue((st, Tt, nr, Ur, Ot, Fr, Xr, mn, sn, hn, dn, nn, Ke) => {
        Me = qr(Se, 1, "btn relative size-12 p-0 shadow-md", null, Me, {
          "bg-red-500": _(q)
        }), cr(Se, "title", st), cr(vt, "title", a.user.data.name), ce(Ut, a.user.data.name), qr(_t, 1, Tt), ce(wt, `#${a.user.data.id??""}`), ce(tr, `${nr??""}: `), ce(ht, Ur), ce(yr, `Level ${Ot??""}`), ce(Wt, ` (${Fr??""}%) `), cr(Zt, "data-tip", Xr), ce(Ir, mn), cr(Ar, "data-tip", sn), cr(Yr, "data-tip", hn), cr(be, "data-tip", dn), ce(Kt, ` ${nn??""}`), Rr.disabled = _(x), ce(ot, ` ${Ke??""}`)
      }, [() => Ww(), () => ys(ea(a.user.data.id)), () => _g(), () => a.user.data.pixelsPainted.toLocaleString("en-US"), () => Math.floor(a.user.data.level), () => Math.floor(a.user.data.level % 1 * 100), () => sT(), () => Yw(), () => z6(), () => ka.muted ? NP() : FP(), () => ry(), () => a5(), () => Ub()]), Ln("focus", Se, () => {
        Y(F, window.pwaInstallPrompt, !0)
      }), Z(fe, ie)
    };
    Ee(te, fe => {
      a.user.data && a.user.charges !== void 0 && fe(ae)
    })
  }
  Z(m, J), $r()
}
ni(["click"]);
var hF = me('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  dF = me('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  pF = me('<span class="font-flag tooltip ml-0.5"> </span>'),
  fF = me("<span> </span>"),
  mF = me('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  gF = me('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  _F = me('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  vF = me('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  yF = me('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  xF = me('<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>', 1);

function bF(m, a) {
  Wr(a, !0);
  const d = [];
  let x = et("today"),
    A = {
      players: {
        label: Y0(),
        icon: af
      },
      alliances: {
        label: K0(),
        icon: of
      }
    },
    z = et("players"),
    b = zi({
      players: {},
      alliances: {}
    });
  const s = ut(() => b[_(z)][_(x)]);
  tn(() => {
    if (_(s)) return;
    const $ = _(x),
      Se = _(z);
    Se === "players" ? fn.leaderboardRegionPlayers(a.regionId, $).then(Me => {
      b[Se][$] = Me
    }).catch(Me => {
      Xt.error(Me.message)
    }) : Se === "alliances" && fn.leaderboardRegionAlliances(a.regionId, $).then(Me => {
      b[Se][$] = Me
    }).catch(Me => {
      Xt.error(Me.message)
    })
  });
  var F = xF(),
    q = xt(F);
  fi(q, 21, () => Object.entries(A), ([$, {
    label: Se,
    icon: Me
  }]) => $, ($, Se) => {
    var Me = ut(() => I0(_(Se), 2));
    let Pe = () => _(Me)[0],
      Ie = () => _(Me)[1].label,
      Ce = () => _(Me)[1].icon;
    const je = ut(Ce);
    var Ye = hF(),
      qe = I(Ye);
    za(qe);
    var Be, He = O(qe, 2);
    ji(He, () => _(je), (it, mt) => {
      mt(it, {
        get this() {
          return Ce()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var we = O(He);
    C(Ye), Ue(() => {
      cr(qe, "aria-label", Ie()), Be !== (Be = Pe()) && (qe.value = (qe.__value = Pe()) ?? ""), ce(we, ` ${Ie()??""}`)
    }), fg(d, [], qe, () => (Pe(), _(z)), it => Y(z, it)), Z($, Ye)
  }), C(q);
  var J = O(q, 2),
    te = I(J);
  Rg(te, {
    get value() {
      return _(x)
    },
    set value($) {
      Y(x, $, !0)
    }
  }), C(J);
  var ae = O(J, 2);
  {
    var fe = $ => {
        var Se = dF(),
          Me = I(Se),
          Pe = O(Me);
        {
          var Ie = je => {
              var Ye = qi();
              Ue(qe => ce(Ye, qe), [() => nf().toLowerCase()]), Z(je, Ye)
            },
            Ce = je => {
              var Ye = or(),
                qe = xt(Ye);
              {
                var Be = we => {
                    var it = qi();
                    Ue(mt => ce(it, mt), [() => Ig()]), Z(we, it)
                  },
                  He = we => {
                    var it = or(),
                      mt = xt(it);
                    {
                      var Ge = Xe => {
                        var vt = qi();
                        Ue(Ut => ce(vt, Ut), [() => Mg()]), Z(Xe, vt)
                      };
                      Ee(mt, Xe => {
                        _(x) === "month" && Xe(Ge)
                      }, !0)
                    }
                    Z(we, it)
                  };
                Ee(qe, we => {
                  _(x) === "week" ? we(Be) : we(He, !1)
                }, !0)
              }
              Z(je, Ye)
            };
          Ee(Pe, je => {
            _(x) === "today" ? je(Ie) : je(Ce, !1)
          })
        }
        C(Se), Ue(je => ce(Me, `${je??""} `), [() => Cg()]), Z($, Se)
      },
      ie = $ => {
        var Se = or(),
          Me = xt(Se);
        {
          var Pe = Ce => {
              var je = or(),
                Ye = xt(je);
              {
                var qe = He => {
                    const we = ut(() => _(s));
                    var it = gF(),
                      mt = I(it),
                      Ge = I(mt),
                      Xe = O(I(Ge)),
                      vt = I(Xe, !0);
                    C(Xe);
                    var Ut = O(Xe),
                      _t = I(Ut),
                      wt = O(_t, 2, !0);
                    C(Ut), C(Ge), C(mt);
                    var Je = O(mt);
                    fi(Je, 31, () => _(we), zt => zt.id, (zt, bt, Rt) => {
                      const Pt = ut(() => {
                        var Tr;
                        return ((Tr = Dt.data) == null ? void 0 : Tr.id) === _(bt).id
                      });
                      var yt = mF();
                      let sr;
                      var tr = I(yt),
                        tt = I(tr, !0);
                      C(tr);
                      var ht = O(tr),
                        It = I(ht),
                        Bt = I(It);
                      Mo(Bt, {
                        class: "size-10 border",
                        get userId() {
                          return _(bt).id
                        },
                        get pictureUrl() {
                          return _(bt).picture
                        }
                      });
                      var Nt = O(Bt, 2),
                        Ht = I(Nt),
                        yr = I(Ht),
                        Wt = O(yr),
                        Zt = I(Wt);
                      C(Wt), C(Ht);
                      var jt = O(Ht, 2);
                      {
                        var Jt = Tr => {
                          const Ar = ut(() => qo(_(bt).equippedFlag));
                          var xr = pF(),
                            qt = I(xr, !0);
                          C(xr), Ue(() => {
                            cr(xr, "data-tip", _(Ar).name), ce(qt, _(Ar).flag)
                          }), Z(Tr, xr)
                        };
                        Ee(jt, Tr => {
                          "equippedFlag" in _(bt) && _(bt).equippedFlag && Tr(Jt)
                        })
                      }
                      var Lt = O(jt, 2);
                      {
                        var Gt = Tr => {
                          ed(Tr, {
                            get username() {
                              return _(bt).discord
                            },
                            get id() {
                              return _(bt).discordId
                            }
                          })
                        };
                        Ee(Lt, Tr => {
                          _(bt).discord && Tr(Gt)
                        })
                      }
                      var Yt = O(Lt, 2);
                      {
                        var Lr = Tr => {
                          var Ar = fF(),
                            xr = I(Ar, !0);
                          C(Ar), Ue((qt, Yr) => {
                            qr(Ar, 1, `badge badge-sm ml-0.5 border-0 ${qt??""} ${Yr??""}`), ce(xr, _(bt).allianceName)
                          }, [() => Kp(_(bt).allianceId), () => ea(_(bt).allianceId)]), Z(Tr, Ar)
                        };
                        Ee(Yt, Tr => {
                          "allianceName" in _(bt) && _(bt).allianceName && Tr(Lr)
                        })
                      }
                      C(Nt), C(It), C(ht);
                      var Ir = O(ht),
                        Jr = I(Ir, !0);
                      C(Ir), C(yt), Ue((Tr, Ar) => {
                        sr = qr(yt, 1, "", null, sr, {
                          "bg-base-200": _(Pt)
                        }), ce(tt, _(Rt) + 1), qr(Ht, 1, `font-semibold max-sm:ml-2 ${Tr??""} flex gap-1`), ce(yr, `${_(bt).name??""} `), ce(Zt, `#${_(bt).id??""}`), ce(Jr, Ar)
                      }, [() => ea(_(bt).id), () => _(bt).pixelsPainted.toLocaleString("en-US")]), wl(yt, () => Tl, () => ({
                        duration: 200
                      })), Z(zt, yt)
                    }), C(Je), C(it), Ue((zt, bt, Rt) => {
                      ce(vt, zt), ce(_t, `${bt??""} `), ce(wt, Rt)
                    }, [() => xg(), () => Lc(), () => zc().toLowerCase()]), Z(He, it)
                  },
                  Be = He => {
                    var we = or(),
                      it = xt(we);
                    {
                      var mt = Ge => {
                        var Xe = vF(),
                          vt = I(Xe),
                          Ut = I(vt),
                          _t = O(I(Ut)),
                          wt = I(_t, !0);
                        C(_t);
                        var Je = O(_t),
                          zt = I(Je),
                          bt = O(zt, 2, !0);
                        C(Je), C(Ut), C(vt);
                        var Rt = O(vt);
                        fi(Rt, 31, () => _(s), Pt => Pt.id, (Pt, yt, sr) => {
                          const tr = ut(() => {
                            var jt;
                            return ((jt = Dt.data) == null ? void 0 : jt.allianceId) === _(yt).id
                          });
                          var tt = _F();
                          let ht;
                          var It = I(tt),
                            Bt = I(It, !0);
                          C(It);
                          var Nt = O(It),
                            Ht = I(Nt),
                            yr = I(Ht, !0);
                          C(Ht), C(Nt);
                          var Wt = O(Nt),
                            Zt = I(Wt, !0);
                          C(Wt), C(tt), Ue((jt, Jt) => {
                            ht = qr(tt, 1, "", null, ht, {
                              "bg-base-200": _(tr)
                            }), ce(Bt, _(sr) + 1), qr(Ht, 1, `font-semibold ${jt??""}`), ce(yr, _(yt).name), ce(Zt, Jt)
                          }, [() => ea(_(yt).id), () => _(yt).pixelsPainted.toLocaleString("en-US")]), wl(tt, () => Tl, () => ({
                            duration: 200
                          })), Z(Pt, tt)
                        }), C(Rt), C(Xe), Ue((Pt, yt, sr) => {
                          ce(wt, Pt), ce(zt, `${yt??""} `), ce(bt, sr)
                        }, [() => tf(), () => Lc(), () => zc().toLowerCase()]), Z(Ge, Xe)
                      };
                      Ee(it, Ge => {
                        _(z) === "alliances" && Ge(mt)
                      }, !0)
                    }
                    Z(He, we)
                  };
                Ee(Ye, He => {
                  _(z) === "players" ? He(qe) : He(Be, !1)
                })
              }
              Z(Ce, je)
            },
            Ie = Ce => {
              var je = yF();
              Z(Ce, je)
            };
          Ee(Me, Ce => {
            _(s) ? Ce(Pe) : Ce(Ie, !1)
          }, !0)
        }
        Z($, Se)
      };
    Ee(ae, $ => {
      _(s) && _(s).length === 0 ? $(fe) : $(ie, !1)
    })
  }
  Z(m, F), $r()
}
var wF = me('<div class="mt-5"><!></div>'),
  TF = me('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function SF(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15);
  const x = ut(() => qo(a.region.countryId));
  ri(() => {
    const $ = Se => {
      Se.key === "Escape" && d(!1)
    };
    return document.addEventListener("keydown", $), () => document.removeEventListener("keydown", $)
  });
  var A = TF(),
    z = I(A),
    b = O(I(z), 2),
    s = I(b),
    F = I(s, !0);
  C(s);
  var q = O(s, 2),
    J = I(q, !0);
  C(q);
  var te = O(q, 2),
    ae = I(te);
  C(te), C(b);
  var fe = O(b, 2);
  {
    var ie = $ => {
      var Se = wF(),
        Me = I(Se);
      bF(Me, {
        get regionId() {
          return a.region.id
        }
      }), C(Se), ba(2, Se, () => so, () => ({
        duration: 300
      })), Z($, Se)
    };
    Ee(fe, $ => {
      d() && $(ie)
    })
  }
  C(z), wn(2), C(A), Di(A, () => $ => {
    tn(() => {
      d() ? $.show() : $.close()
    })
  }), Ue($ => {
    qr(b, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${$??""}`), cr(s, "data-tip", _(x).name), ce(F, _(x).flag), ce(J, a.region.name), ce(ae, `#${a.region.number??""}`)
  }, [() => ea(a.region.cityId)]), Ln("close", A, () => d(!1)), Z(m, A), $r()
}
async function PF(m) {
  const a = Ne();
  let d = `https://geocoding.wplace.live/v1/autocomplete?text=${encodeURIComponent(m)}${a==="pt"?"&lang=pt":""}`;
  const x = await fetch(d);
  if (!x.ok) {
    const A = await x.text();
    throw console.error(`Geocoding API error: ${A}`), new Error(Ab())
  }
  return x.json()
}
var CF = me('<div class="text-base-content/80 absolute right-3 top-1/2 z-10 -translate-y-1/2 sm:right-6"><button class="btn btn-ghost btn-sm btn-circle hidden group-hover:flex"><!></button></div>'),
  IF = me('<div class="group relative"><button class="hover:bg-base-200 active:bg-base-200 flex w-full gap-3 px-3 py-2 sm:px-6"><!> <div class="sm:pr-8"><h3 class="text-left font-semibold"> </h3> <div class="text-base-content/80 text-left text-sm"> </div></div></button> <!></div>');

function Cm(m, a) {
  Wr(a, !0);
  const d = (s, F) => {
    let q = () => F == null ? void 0 : F().name,
      J = () => F == null ? void 0 : F().label,
      te = () => F == null ? void 0 : F().onclick;
    var ae = IF(),
      fe = I(ae);
    fe.__click = function(...Ye) {
      var qe;
      (qe = te()) == null || qe.apply(this, Ye)
    };
    var ie = I(fe);
    Qp(ie, {
      class: "text-base-content/80 mt-0.5 size-6 min-w-6"
    });
    var $ = O(ie, 2),
      Se = I($),
      Me = I(Se, !0);
    C(Se);
    var Pe = O(Se, 2),
      Ie = I(Pe, !0);
    C(Pe), C($), C(fe);
    var Ce = O(fe, 2);
    {
      var je = Ye => {
        var qe = CF(),
          Be = I(qe);
        Be.__click = function(...we) {
          var it;
          (it = a.onremove) == null || it.apply(this, we)
        };
        var He = I(Be);
        ws(He, {
          class: "size-4"
        }), C(Be), C(qe), Z(Ye, qe)
      };
      Ee(Ce, Ye => {
        a.onremove && Ye(je)
      })
    }
    C(ae), Ue(() => {
      ce(Me, q()), ce(Ie, J())
    }), Z(s, ae)
  };
  var x = or(),
    A = xt(x);
  {
    var z = s => {
        d(s, () => ({
          name: a.location.name,
          label: a.location.label,
          onclick: a.onclick
        }))
      },
      b = s => {
        var F = or(),
          q = xt(F);
        {
          var J = ae => {
              {
                let fe = ut(() => ({
                  name: a.location.name,
                  label: Sg(),
                  onclick: a.onclick
                }));
                d(ae, () => _(fe))
              }
            },
            te = ae => {
              var fe = or(),
                ie = xt(fe);
              {
                var $ = Se => {
                  {
                    let Me = ut(() => ({
                      name: `${a.location.pos.lat.toFixed(4)}, ${a.location.pos.lng.toFixed(4)}`,
                      label: ny(),
                      onclick: a.onclick
                    }));
                    d(Se, () => _(Me))
                  }
                };
                Ee(ie, Se => {
                  a.location.type === "coordinates" && Se($)
                }, !0)
              }
              Z(ae, fe)
            };
          Ee(q, ae => {
            a.location.type === "country" ? ae(J) : ae(te, !1)
          }, !0)
        }
        Z(s, F)
      };
    Ee(A, s => {
      a.location.type === "place" ? s(z) : s(b, !1)
    })
  }
  Z(m, x), $r()
}
ni(["click"]);
var MF = jr('<svg><path d="m336-280 144-144 144 144 56-56-144-144 144-144-56-56-144 144-144-144-56 56 144 144-144 144 56 56ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function AF(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = MF();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var kF = jr('<svg><path d="M300-240q25 0 42.5-17.5T360-300q0-25-17.5-42.5T300-360q-25 0-42.5 17.5T240-300q0 25 17.5 42.5T300-240Zm0-360q25 0 42.5-17.5T360-660q0-25-17.5-42.5T300-720q-25 0-42.5 17.5T240-660q0 25 17.5 42.5T300-600Zm180 180q25 0 42.5-17.5T540-480q0-25-17.5-42.5T480-540q-25 0-42.5 17.5T420-480q0 25 17.5 42.5T480-420Zm180 180q25 0 42.5-17.5T720-300q0-25-17.5-42.5T660-360q-25 0-42.5 17.5T600-300q0 25 17.5 42.5T660-240Zm0-360q25 0 42.5-17.5T720-660q0-25-17.5-42.5T660-720q-25 0-42.5 17.5T600-660q0 25 17.5 42.5T660-600ZM200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm0-560v560-560Z"></path></svg>');

function EF(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = kF();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var LF = me('<button type="button" class="absolute right-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button>'),
  zF = me('<p class="text-base-content/80 pt-4 text-center text-sm"> </p>'),
  DF = me("<!> <!>", 1),
  RF = me('<p class="text-base-content/80 pt-6 text-center text-sm"> </p>'),
  FF = me('<div class="mb-2 flex items-center justify-between px-4 sm:px-7"><h3 class="text-sm font-semibold"> </h3> <button class="btn btn-sm btn-ghost btn-circle tooltip tooltip-bottom before:-translate-x-1/3"><!></button></div> <!> <!>', 1),
  BF = me('<dialog class="modal duration-0"><div class="modal-box sm:max-h-11/12 sm:h-11/12 flex flex-col p-0 max-sm:h-full max-sm:w-full max-sm:max-w-full max-sm:rounded-none"><section class="px-3 pt-3 sm:px-6 sm:pt-6"><form class="relative h-max"><input class="input placeholder:text-base-content/80 input-no-cancel-button w-full pl-10 pr-9" type="search"/> <button type="button" class="absolute left-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button> <!></form></section> <section class="grow overflow-y-auto overflow-x-hidden pb-3 pt-4 sm:pb-6"><!></section></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function OF(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15),
    x = et(""),
    A = et(!1),
    z = et(!1);
  const b = new KE(() => _(x), 400);
  let s = et(null),
    F = et(void 0),
    q = et([]);
  const J = /^([+-]?([1-8]?\d(\.\d+)?|90(\.0+)?))\s*,\s*([+-]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?))$/,
    te = ut(() => {
      const Ge = J.exec(_(x));
      if (Ge) {
        const Xe = parseFloat(Ge[1]),
          vt = parseFloat(Ge[5]);
        return {
          type: "coordinates",
          id: `coords-${Xe}-${vt}`,
          pos: {
            lat: Xe,
            lng: vt
          },
          zoom: a.tileZoom + 2
        }
      }
    }),
    ae = "recent-locations";
  ri(() => {
    const Ge = localStorage.getItem(ae);
    if (Ge) try {
      Y(q, JSON.parse(Ge))
    } catch (Xe) {
      console.error("Failed to parse recent locations from localStorage", Xe)
    }
  }), tn(() => {
    b.current && PF(b.current).then(Ge => {
      Y(F, Ge.features.map(Xe => {
        if (Xe.properties.layer === "country") return {
          type: "country",
          id: Xe.properties.id,
          name: Xe.properties.name,
          bbox: Xe.bbox
        };
        const vt = Xe.properties.label.replace(Xe.properties.name + ",", "").trim();
        return {
          type: "place",
          id: Xe.properties.id,
          name: Xe.properties.name,
          label: vt,
          bbox: Xe.bbox
        }
      })), _(A) && _(F).length > 0 && ie(_(F)[0])
    })
  }), tn(() => {
    _(x) || Y(F, void 0)
  }), tn(() => {
    d() ? setTimeout(() => {
      _(s).focus()
    }, 50) : (Y(x, ""), Y(A, !1), Y(F, void 0))
  });
  async function fe() {
    const {
      tile: Ge,
      pixel: Xe
    } = await fn.getRandomTile(a.season), vt = new Oa(a.tileSize), Ut = Ge.x * a.tileSize + Xe.x, _t = Ge.y * a.tileSize + Xe.y, [wt, Je] = vt.pixelsToLatLon(Ut, _t, a.tileZoom), zt = {
      lat: wt,
      lng: Je
    }, bt = a.tileZoom + 2;
    a.map.flyTo({
      zoom: bt,
      center: zt
    }), $({
      type: "coordinates",
      id: `coords-${wt}-${Je}`,
      pos: zt,
      zoom: bt
    })
  }

  function ie(Ge) {
    Ge.type === "coordinates" ? a.map.flyTo({
      zoom: Ge.zoom,
      center: Ge.pos
    }) : a.map.fitBounds([
      [Ge.bbox[0], Ge.bbox[1]],
      [Ge.bbox[2], Ge.bbox[3]]
    ], {
      padding: 40,
      duration: 1e3
    }), d(!1), Y(F, void 0), $(Ge)
  }

  function $(Ge) {
    Y(q, _(q).filter(vt => vt.id !== Ge.id)), _(q).unshift(Ge);
    const Xe = 15;
    _(q).length > Xe && Y(q, _(q).slice(0, Xe)), Y(q, [..._(q)]), localStorage.setItem(ae, JSON.stringify(_(q)))
  }
  var Se = BF(),
    Me = I(Se),
    Pe = I(Me),
    Ie = I(Pe),
    Ce = I(Ie);
  za(Ce), lo(Ce, Ge => Y(s, Ge), () => _(s));
  var je = O(Ce, 2);
  je.__click = () => d(!1);
  var Ye = I(je);
  j0(Ye, {
    class: "size-5"
  }), C(je);
  var qe = O(je, 2);
  {
    var Be = Ge => {
      var Xe = LF();
      Xe.__click = () => Y(x, "");
      var vt = I(Xe);
      AF(vt, {
        class: "size-4.5"
      }), C(Xe), Z(Ge, Xe)
    };
    Ee(qe, Ge => {
      _(x) && Ge(Be)
    })
  }
  C(Ie), C(Pe);
  var He = O(Pe, 2),
    we = I(He);
  {
    var it = Ge => {
        Cm(Ge, {
          get location() {
            return _(te)
          },
          onclick: () => ie(_(te))
        })
      },
      mt = Ge => {
        var Xe = or(),
          vt = xt(Xe);
        {
          var Ut = wt => {
              var Je = DF(),
                zt = xt(Je);
              fi(zt, 17, () => _(F), Pt => Pt.id, (Pt, yt) => {
                Cm(Pt, {
                  get location() {
                    return _(yt)
                  },
                  onclick: () => ie(_(yt))
                })
              });
              var bt = O(zt, 2);
              {
                var Rt = Pt => {
                  var yt = zF(),
                    sr = I(yt, !0);
                  C(yt), Ue(tr => ce(sr, tr), [() => s6()]), Z(Pt, yt)
                };
                Ee(bt, Pt => {
                  _(F).length === 0 && Pt(Rt)
                })
              }
              Z(wt, Je)
            },
            _t = wt => {
              var Je = FF(),
                zt = xt(Je),
                bt = I(zt),
                Rt = I(bt, !0);
              C(bt);
              var Pt = O(bt, 2);
              Pt.__click = async () => {
                try {
                  await fe(), d(!1)
                } catch (ht) {
                  Xt.error(ht.message)
                } finally {
                  Y(z, !1)
                }
              };
              var yt = I(Pt);
              EF(yt, {
                class: "size-5"
              }), C(Pt), C(zt);
              var sr = O(zt, 2);
              fi(sr, 17, () => _(q), ht => ht.id, (ht, It) => {
                Cm(ht, {
                  get location() {
                    return _(It)
                  },
                  onclick: () => {
                    ie(_(It))
                  },
                  onremove: () => {
                    Y(q, _(q).filter(Bt => Bt.id !== _(It).id)), localStorage.setItem(ae, JSON.stringify(_(q)))
                  }
                })
              });
              var tr = O(sr, 2);
              {
                var tt = ht => {
                  var It = RF(),
                    Bt = I(It, !0);
                  C(It), Ue(Nt => ce(Bt, Nt), [() => u6()]), Z(ht, It)
                };
                Ee(tr, ht => {
                  _(q).length === 0 && ht(tt)
                })
              }
              Ue((ht, It) => {
                ce(Rt, ht), cr(Pt, "data-tip", It), Pt.disabled = _(z)
              }, [() => t6(), () => i6()]), Z(wt, Je)
            };
          Ee(vt, wt => {
            _(F) ? wt(Ut) : wt(_t, !1)
          }, !0)
        }
        Z(Ge, Xe)
      };
    Ee(we, Ge => {
      _(te) ? Ge(it) : Ge(mt, !1)
    })
  }
  C(He), C(Me), wn(2), C(Se), Di(Se, () => Ge => {
    tn(() => {
      d() ? Ge.showModal() : Ge.close()
    })
  }), Ue(Ge => cr(Ce, "placeholder", Ge), [() => U0()]), Ln("close", Se, () => d(!1)), Ln("submit", Ie, () => {
    var Ge;
    _(te) ? ie(_(te)) : b.pending ? Y(A, !0) : (Ge = _(F)) != null && Ge.length && ie(_(F)[0])
  }), Xh(Ce, () => _(x), Ge => Y(x, Ge)), Z(m, Se), $r()
}
ni(["click"]);
var NF = jr('<svg><path fill="currentColor" d="M9 14c1.381 0 2.631-.56 3.536-1.465C13.44 11.631 14 10.381 14 9s-.56-2.631-1.464-3.535C11.631 4.56 10.381 4 9 4s-2.631.56-3.536 1.465C4.56 6.369 4 7.619 4 9s.56 2.631 1.464 3.535A5 5 0 0 0 9 14m0 7c3.518 0 6-1 6-2c0-2-2.354-4-6-4c-3.75 0-6 2-6 4c0 1 2.25 2 6 2m12-9h-2v-2a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2"></path></svg>');

function jF(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = NF();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...d
  })), Z(m, x)
}
var qF = jr('<svg><circle cx="12" cy="12" r="8" fill="none" stroke="currentColor" stroke-width="2"></circle><circle cx="12" cy="12" r="3" fill="currentColor"></circle></svg>');

function VF(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = qF();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...d
  })), Z(m, x)
}
var UF = jr('<svg><rect x="6" y="6" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" rx="2"></rect><rect x="10" y="10" width="4" height="4" fill="currentColor" rx="1"></rect></svg>');

function ZF(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = UF();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...d
  })), Z(m, x)
}
var GF = me("<!> <!>", 1),
  HF = me('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  WF = me('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  $F = me('<div class="mt-3 flex justify-center svelte-15blegn"><span class="loading loading-spinner svelte-15blegn"></span></div>'),
  XF = me('<div class="mt-3 flex justify-center svelte-15blegn"><p class="text-base-content/80 text-sm svelte-15blegn">No one has painted in this area yet.</p></div>'),
  YF = me('<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Ban selected players"><!></button>'),
  KF = me('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  JF = me('<button class="btn btn-xs btn-circle btn-soft btn-primary tooltip tooltip-bottom mr-1 svelte-15blegn" data-tip="Paint selected pixels with transparent color"><!></button>'),
  QF = me('<div class="size-5 svelte-15blegn"></div> <div class="text-base-content/80 ml-0.5 svelte-15blegn">Not painted</div>', 1),
  eB = me("<span> </span>"),
  tB = me('<span class="badge badge-sm badge-error ml-0.5 border-0 svelte-15blegn">DELETED</span>'),
  rB = me('<span class="tooltip svelte-15blegn"><!></span>'),
  nB = me('<span class="tooltip svelte-15blegn"><!></span>'),
  iB = me('<!> <div class="ml-0.5 flex flex-wrap items-center gap-1 svelte-15blegn"><span><span class="svelte-15blegn"> </span> <span class="svelte-15blegn"> </span></span> <!> <!> <div class="ml-0.5 flex items-center svelte-15blegn"><!></div></div>', 1),
  aB = me('<span class="text-primary ml-1 text-xs svelte-15blegn"> </span>'),
  oB = me('<tr><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox pointer-event-none svelte-15blegn"/></th><td class="flex items-center gap-1 svelte-15blegn"><!></td><td class="text-center svelte-15blegn"> <!></td></tr>'),
  sB = me('<div class="max-h-[27vh] overflow-x-hidden overflow-y-auto svelte-15blegn"><table class="table max-w-full svelte-15blegn"><thead class="svelte-15blegn"><tr class="svelte-15blegn"><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox svelte-15blegn"/></th><th class="svelte-15blegn">Player <button class="btn btn-xs btn-circle btn-ghost tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Copy selected players IDs"><!></button> <button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom svelte-15blegn" data-tip="Timeout selected players"><!></button> <!></th><th class="text-center svelte-15blegn"><!> Pixels Painted</th></tr></thead><tbody class="svelte-15blegn"></tbody></table></div>'),
  lB = me('<div class="w-full svelte-15blegn"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t sm:mb-3 sm:shadow-xl svelte-15blegn"><div class="p-3 svelte-15blegn"><div class="flex cursor-grab flex-wrap items-center justify-between gap-1 active:cursor-grabbing svelte-15blegn"><h2 class="flex items-center gap-1 pl-1 text-lg svelte-15blegn"><div class="bg-base-content/20 flex size-6 items-center justify-center rounded-full svelte-15blegn"><!></div> <span class="ml-0.5 svelte-15blegn">Selected area</span> <span class="text-base-content/80 ml-0.5 text-sm svelte-15blegn"> </span></h2> <div class="flex items-center gap-1 svelte-15blegn"><button data-tip="Save selected pixel art"><!></button> <button><!></button> <button><!></button> <button><!></button> <button class="btn btn-circle btn-sm svelte-15blegn"><!></button></div></div> <div class="pb-3 svelte-15blegn"><!></div></div></div></div>');

function cB(m, a) {
  Wr(a, !0);
  let d = zi([]),
    x = et(zi([])),
    A = et(!1),
    z = et(!1),
    b = et(!1),
    s = et(!1),
    F, q, J, te, ae, fe = et(void 0),
    ie = zi({
      x: 0,
      y: 0
    }),
    $, Se;
  const Me = 15e6,
    Pe = new Bp,
    Ie = new Map;
  let Ce = et(0);
  const je = ut(() => {
      _(Ce);
      const oe = new Map;
      for (const K of Ie.values()) oe.set(K.userId, (oe.get(K.userId) ?? 0) + 1);
      return oe
    }),
    Ye = ut(() => {
      _(Ce), Pe.size;
      let oe = 0;
      for (const K of Ie.values()) Pe.has(K.userId) || (oe += 1);
      return oe
    }),
    qe = ut(() => {
      _(Ce);
      const oe = _(Ye);
      return Pe.size === 0 && oe === 0 ? "none" : Pe.size === _(x).length && oe === 0 ? "all" : "some"
    }),
    Be = ut(() => {
      _(Ce);
      let oe = 0;
      for (const K of Pe.values()) K.id !== 0 && (oe += K.painted.latitudes.length);
      for (const K of Ie.values()) Pe.has(K.userId) || (oe += 1);
      return oe
    }),
    He = ut(() => _(Ge) * 2 + 1);
  let we = et("area-select"),
    it = et(!1);
  const mt = 15;
  let Ge = et(mt);
  const Xe = 0,
    vt = 4096,
    Ut = "select-area-info:brush-radius",
    _t = new Bp,
    wt = new Map,
    Je = [],
    zt = () => _(we) === "brush-circle" || _(we) === "brush-square";
  let bt, Rt = !1,
    Pt = !1;

  function yt() {
    Rt && (Rt = !1, bt = void 0)
  }

  function sr() {
    if (Je.length > 0) return;
    const oe = [a.map.dragPan, a.map.scrollZoom, a.map.boxZoom, a.map.keyboard, a.map.doubleClickZoom, a.map.touchZoomRotate].filter(Boolean);
    for (const K of oe) {
      const he = K.isEnabled ? K.isEnabled() !== !1 : !0;
      K.disable && K.disable(), Je.push({
        handler: K,
        wasEnabled: he
      })
    }
  }

  function tr() {
    if (Je.length !== 0) {
      for (const {
          handler: oe,
          wasEnabled: K
        }
        of Je) K && oe.enable && oe.enable();
      Je.length = 0
    }
  }

  function tt() {
    var he, Q;
    if (!$) return;
    const {
      handle: oe,
      pointerId: K
    } = $;
    (he = oe.hasPointerCapture) != null && he.call(oe, K) && ((Q = oe.releasePointerCapture) == null || Q.call(oe, K)), $ = void 0, Se !== void 0 && (document.body.style.userSelect = Se, Se = void 0), ht()
  }

  function ht() {
    var Kt, Qt;
    if (!_(fe)) return;
    const oe = (Qt = (Kt = a.map).getContainer) == null ? void 0 : Qt.call(Kt);
    if (!oe) return;
    const K = oe.getBoundingClientRect(),
      he = _(fe).getBoundingClientRect(),
      Q = he.left - ie.x,
      ze = he.top - ie.y,
      $e = K.left - Q,
      Re = K.right - Q - he.width,
      ft = K.top - ze,
      Mt = K.bottom - ze - he.height;
    let Et = ie.x,
      dt = ie.y;
    Re >= $e ? (Et < $e && (Et = $e), Et > Re && (Et = Re)) : Et = $e, Mt >= ft ? (dt < ft && (dt = ft), dt > Mt && (dt = Mt)) : dt = ft, Et !== ie.x && (ie.x = Et), dt !== ie.y && (ie.y = dt)
  }

  function It(oe) {
    var ft, Mt, Et;
    if ($ || oe.pointerType === "mouse" && oe.button !== 0) return;
    const K = oe.target;
    if (K && K.closest('button, input, textarea, select, a, [role="button"]')) return;
    const he = oe.currentTarget;
    if (!he) return;
    const Q = _(fe);
    if (!Q) return;
    const ze = (Mt = (ft = a.map).getContainer) == null ? void 0 : Mt.call(ft);
    if (!ze) return;
    const $e = ze.getBoundingClientRect(),
      Re = Q.getBoundingClientRect();
    $ = {
      pointerId: oe.pointerId,
      handle: he,
      startX: oe.clientX,
      startY: oe.clientY,
      startPosX: ie.x,
      startPosY: ie.y,
      baseLeft: Re.left - ie.x,
      baseTop: Re.top - ie.y,
      containerRect: $e,
      panelWidth: Re.width,
      panelHeight: Re.height
    }, Se === void 0 && (Se = document.body.style.userSelect), document.body.style.userSelect = "none", (Et = he.setPointerCapture) == null || Et.call(he, oe.pointerId), oe.preventDefault(), oe.stopPropagation()
  }
  ri(() => {
    const oe = window.localStorage.getItem(Ut);
    if (oe !== null) {
      const Ft = Number(oe);
      if (!Number.isNaN(Ft)) {
        const Ze = Math.min(vt, Math.max(Xe, Math.trunc(Ft)));
        Y(Ge, Ze, !0)
      }
    }
    xi.droppletAndPlop.play(), F = jt();
    const K = async Ft => {
      if (_(we) === "user-picker") {
        await Ir(Ft, "select");
        return
      }
      if (zt()) {
        const Ze = Ft.originalEvent;
        j(Ft, "add", {
          silent: !!(Ze != null && Ze.altKey)
        });
        return
      }
      if (d.length >= 2) {
        a.onclose();
        return
      }
      if (d.push(Ft.lngLat), Jt(), xi.plop.play(), d.length === 2) try {
        Y(A, !0), Y(x, await Nt(d[0], d[1]), !0)
      } finally {
        Y(A, !1)
      }
    }, he = async Ft => {
      var Pr, br;
      if (_(we) === "user-picker") {
        (Pr = Ft.preventDefault) == null || Pr.call(Ft);
        const Rr = Ft.originalEvent;
        Rr == null || Rr.preventDefault();
        try {
          await Ir(Ft, "deselect")
        } catch (Dr) {
          console.error(Dr)
        }
        return
      }
      if (!zt()) return;
      (br = Ft.preventDefault) == null || br.call(Ft);
      const Ze = Ft.originalEvent;
      Ze == null || Ze.preventDefault(), j(Ft, "remove")
    }, Q = Ft => {
      if (!zt()) return;
      const Ze = Ft.originalEvent;
      if (!Ze || !Ze.altKey) return;
      const Pr = Ze.button === 2 ? "remove" : "add";
      Ze.preventDefault(), sr(), bt = Pr, Rt = !0, j(Ft, Pr, {
        silent: !0
      })
    }, ze = () => {
      yt()
    }, $e = a.map.on("click", K), Re = a.map.on("contextmenu", he), ft = a.map.on("mousedown", Q), Mt = a.map.on("mouseup", ze), Et = Ft => {
      const Ze = $;
      if (!Ze || Ft.pointerId !== Ze.pointerId) return;
      const Pr = Ft.clientX - Ze.startX,
        br = Ft.clientY - Ze.startY;
      let Rr = Ze.startPosX + Pr,
        Dr = Ze.startPosY + br;
      const ot = Ze.containerRect.left - Ze.baseLeft,
        dr = Ze.containerRect.right - Ze.baseLeft - Ze.panelWidth,
        st = Ze.containerRect.top - Ze.baseTop,
        Tt = Ze.containerRect.bottom - Ze.baseTop - Ze.panelHeight;
      dr >= ot ? (Rr < ot && (Rr = ot), Rr > dr && (Rr = dr)) : Rr = ot, Tt >= st ? (Dr < st && (Dr = st), Dr > Tt && (Dr = Tt)) : Dr = st, ie.x !== Rr && (ie.x = Rr), ie.y !== Dr && (ie.y = Dr)
    }, dt = Ft => {
      const Ze = $;
      !Ze || Ft.pointerId !== Ze.pointerId || tt()
    };
    window.addEventListener("pointermove", Et), window.addEventListener("pointerup", dt), window.addEventListener("pointercancel", dt), window.addEventListener("resize", ht);
    const Kt = Ft => {
        if (Ft.altKey && (Ft.key === "r" || Ft.key === "R")) {
          Y(Ge, mt), Ft.preventDefault(), Lt();
          return
        }
        Ft.key === "Alt" && (Pt || (Pt = !0, zt() && sr()))
      },
      Qt = Ft => {
        Ft.key === "Alt" && (Pt = !1, yt(), tr())
      },
      Sr = () => {
        tt(), !(!Pt && !Rt) && (Pt = !1, yt(), tr())
      };
    return window.addEventListener("keydown", Kt), window.addEventListener("keyup", Qt), window.addEventListener("blur", Sr), () => {
      var Ze, Pr;
      $e.unsubscribe(), Re.unsubscribe(), ft.unsubscribe(), Mt.unsubscribe(), window.removeEventListener("pointermove", Et), window.removeEventListener("pointerup", dt), window.removeEventListener("pointercancel", dt), window.removeEventListener("resize", ht), window.removeEventListener("keydown", Kt), window.removeEventListener("keyup", Qt), window.removeEventListener("blur", Sr), tt(), yt(), tr(), Pt = !1, a.crosshair.clear();
      const Ft = (Pr = (Ze = a.map).getCanvas) == null ? void 0 : Pr.call(Ze);
      Ft && (Ft.style.cursor = ""), F == null || F(), F = void 0
    }
  });

  function Bt() {
    tt(), _(z) || (F == null || F(), F = void 0, Y(we, "area-select"), yt(), tr(), Pt = !1, ie.x = 0, ie.y = 0, Ie.clear(), Y(Ce, _(Ce) + 1), _t.clear(), wt.clear(), a.crosshair.clear(), a.onclose())
  }
  async function Nt(oe, K) {
    const he = new Oa(a.tileSize),
      [Q, ze] = he.latLonToPixelsFloor(oe.lat, oe.lng, a.pixelArtZoom),
      [$e, Re] = he.latLonToPixelsFloor(K.lat, K.lng, a.pixelArtZoom),
      [ft, Mt] = [Math.min(Q, $e), Math.min(ze, Re)],
      [Et, dt] = [Math.max(Q, $e), Math.max(ze, Re)],
      Kt = Et - ft,
      Qt = dt - Mt;
    if (Kt * Qt > Me) return Xt.error(`The selected area is too big. Please select an area smaller than ${Me.toLocaleString()} pixels.`), [];
    const Ft = Math.floor(ft / a.tileSize),
      Ze = Math.floor(Mt / a.tileSize),
      Pr = Math.floor(Et / a.tileSize),
      br = Math.floor(dt / a.tileSize),
      Rr = Pr - Ft + 1,
      Dr = br - Ze + 1,
      ot = new Array(Dr).fill(0).flatMap((Ot, Fr) => new Array(Rr).fill(0).map(async (Xr, mn) => {
        const sn = Ft + mn,
          hn = Ze + Fr;
        let dn = 0,
          nn = 0,
          Ke = a.tileSize - 1,
          St = a.tileSize - 1;
        hn === Ze && (nn = Mt % a.tileSize), sn === Ft && (dn = ft % a.tileSize), hn === br && (St = dt % a.tileSize), sn === Pr && (Ke = Et % a.tileSize);
        const gn = [sn, hn],
          Rn = [dn, nn],
          ln = [Ke, St];
        return {
          response: await fn.getPixelAreaInfo({
            season: a.season,
            tile: gn,
            p0: Rn,
            p1: ln
          }),
          tile: gn,
          p0: Rn,
          p1: ln
        }
      })),
      dr = await Promise.all(ot);
    _t.clear(), wt.clear();
    const st = new Map;
    for (const {
        response: Ot,
        p0: Fr,
        p1: Xr,
        tile: mn
      }
      of dr) {
      const [sn, hn] = mn, [dn, nn] = Fr, [Ke, St] = Xr, kr = Ke - dn + 1, wr = St - nn + 1;
      for (let mr = 0; mr < wr; mr++)
        for (let Mr = 0; Mr < kr; Mr++) {
          const gn = mr * kr + Mr,
            Rn = Ot.paintedBy[gn];
          let ln = st.get(Rn);
          ln || (ln = {
            latitudes: [],
            longitudes: [],
            tileXs: [],
            tileYs: [],
            pixelXs: [],
            pixelYs: [],
            globalPx: [],
            globalPy: [],
            minLat: 1 / 0,
            maxLat: -1 / 0,
            minLon: 1 / 0,
            maxLon: -1 / 0
          }, st.set(Rn, ln));
          const Gn = dn + Mr,
            On = nn + mr,
            Wn = sn * a.tileSize + (Gn + .5),
            ti = hn * a.tileSize + (On + .5),
            [Zn, cn] = he.pixelsToLatLon(Wn, ti, a.pixelArtZoom);
          if (ln.latitudes.push(Zn), ln.longitudes.push(cn), ln.tileXs.push(sn), ln.tileYs.push(hn), ln.pixelXs.push(Gn), ln.pixelYs.push(On), ln.globalPx.push(Wn), ln.globalPy.push(ti), Zn < ln.minLat && (ln.minLat = Zn), Zn > ln.maxLat && (ln.maxLat = Zn), cn < ln.minLon && (ln.minLon = cn), cn > ln.maxLon && (ln.maxLon = cn), Rn !== 0) {
            const kn = `${sn}:${hn}:${Gn}:${On}`,
              Xn = {
                key: kn,
                userId: Rn,
                lat: Zn,
                lon: cn,
                tile: [sn, hn],
                pixel: [Gn, On],
                globalPx: Wn,
                globalPy: ti
              };
            _t.set(kn, Xn);
            const Ri = `${sn}:${hn}`;
            let Ii = wt.get(Ri);
            Ii || (Ii = [], wt.set(Ri, Ii)), Ii.push(Xn)
          }
        }
    }
    const {
      users: Tt
    } = await fn.getMultipleUsersInfoById([...st.keys()]), nr = kb(Tt, Ot => Ot.id), Ur = [...st.entries()].map(([Ot, Fr]) => ({
      ...nr[Ot] ?? {
        id: Ot,
        name: "Player",
        deleted: !0
      },
      painted: Fr
    }));
    return Ur.sort((Ot, Fr) => Ot.id === 0 ? 1 : Fr.id === 0 ? -1 : Fr.painted.latitudes.length - Ot.painted.latitudes.length), Ur
  }
  async function Ht({
    preserveSelection: oe = !1
  } = {}) {
    if (d.length < 2) return;
    const K = oe ? new Set([...Pe.keys()]) : void 0,
      he = oe ? [...Ie.keys()] : void 0;
    try {
      Y(A, !0);
      const Q = await Nt(d[0], d[1]);
      if (Y(x, Q, !0), Pe.clear(), Ie.clear(), Y(Ce, _(Ce) + 1), a.crosshair.clear(), oe && (K != null && K.size)) {
        for (const ze of Q) K.has(ze.id) && Pe.set(ze.id, ze);
        for (const ze of Pe.values())
          for (let $e = 0; $e < ze.painted.latitudes.length; $e++) a.crosshair.place([ze.painted.latitudes[$e], ze.painted.longitudes[$e]])
      }
      if (oe && (he != null && he.length)) {
        let ze = !1;
        for (const $e of he) {
          const Re = _t.get($e);
          Re && (Ie.set($e, Re), ze = !0)
        }
        ze && Y(Ce, _(Ce) + 1)
      }
      for (const ze of Ie.values()) a.crosshair.place([ze.lat, ze.lon])
    } finally {
      Y(A, !1)
    }
  }

  function yr(oe) {
    let K = !1;
    for (const he of oe)(xr(he) || he.id === 0) && (K = !0);
    K && xi.plop.play()
  }

  function Wt(oe) {
    for (let K = 0; K < oe.latitudes.length; K++) a.crosshair.remove([oe.latitudes[K], oe.longitudes[K]])
  }

  function Zt(oe) {
    if (!oe) {
      ae = void 0;
      return
    }
    if (d.length >= 2 && _(we) === "area-select") {
      ae = void 0;
      return
    }
    ae = oe
  }
  tn(() => {
    d.length < 2 && _(we) !== "area-select" && Y(we, "area-select");
    const oe = a.map.getCanvas();
    if (!oe) return;
    const K = _(we) === "user-picker" || _(we) === "brush-circle" || _(we) === "brush-square";
    oe.style.cursor = K ? "crosshair" : "", Lt()
  }), tn(() => {
    const oe = zt();
    oe || yt(), Pt && (oe ? sr() : tr())
  }), tn(() => {
    _(Ge), Lt()
  }), tn(() => {
    typeof window < "u" && window.localStorage.setItem(Ut, String(Math.trunc(_(Ge))))
  }), tn(() => {
    d.length, d.length < 2 ? (ie.x !== 0 && (ie.x = 0), ie.y !== 0 && (ie.y = 0)) : ht(), Jt(), Gt()
  });

  function jt() {
    const oe = a.map.getContainer(),
      K = document.createElement("div");
    K.classList.add("selection-rectangle"), K.style.position = "absolute", K.style.pointerEvents = "none", K.style.display = "none", K.style.zIndex = "6", oe.appendChild(K);
    const he = document.createElement("div");
    he.classList.add("selection-brush"), he.style.position = "absolute", he.style.pointerEvents = "none", he.style.display = "none", he.style.zIndex = "7", oe.appendChild(he);
    const Q = Lr(oe, "horizontal"),
      ze = Lr(oe, "vertical");
    te = {
      horizontal: Q,
      vertical: ze
    }, J = he;
    const $e = dt => {
        Zt({
          x: dt.point.x,
          y: dt.point.y
        }), Jt(), Gt(), Lt();
        const Kt = dt.originalEvent;
        if (!Kt) {
          Rt && yt();
          return
        }
        if (!Rt && Kt.altKey && zt()) {
          let Qt = !1;
          if (Kt.buttons & 1 ? (sr(), bt = "add", Rt = !0, Qt = !0) : Kt.buttons & 2 && (sr(), bt = "remove", Rt = !0, Qt = !0), Qt && bt) {
            j(dt, bt, {
              silent: !0
            });
            return
          }
        }
        if (Rt && bt) {
          if (!Kt.altKey || Kt.buttons === 0) {
            yt();
            return
          }
          j(dt, bt, {
            silent: !0
          })
        }
      },
      Re = dt => {
        const Kt = oe.getBoundingClientRect();
        Zt({
          x: dt.clientX - Kt.left,
          y: dt.clientY - Kt.top
        }), Jt(), Gt(), Lt()
      },
      ft = () => {
        ae = void 0, yt(), Jt(), Gt(), Lt()
      },
      Mt = () => {
        ht(), Jt(), Gt(), Lt()
      },
      Et = dt => {
        if (!zt()) return;
        if (!(dt.altKey || Pt)) {
          Rt && (yt(), tr());
          return
        }
        Pt = !0, sr(), dt.preventDefault(), dt.stopPropagation(), typeof dt.stopImmediatePropagation == "function" && dt.stopImmediatePropagation();
        const Kt = dt.deltaY < 0 ? 1 : -1,
          Qt = (dt.shiftKey ? 10 : 1) * Kt,
          Sr = Math.min(vt, Math.max(Xe, _(Ge) + Qt));
        Sr !== _(Ge) && (Y(Ge, Sr, !0), Lt())
      };
    return a.map.on("mousemove", $e), oe.addEventListener("pointermove", Re), oe.addEventListener("mouseleave", ft), a.map.on("move", Mt), a.map.on("resize", Mt), oe.addEventListener("wheel", Et, {
      passive: !1
    }), q = K, Jt(), Gt(), Lt(), () => {
      a.map.off("mousemove", $e), a.map.off("move", Mt), a.map.off("resize", Mt), oe.removeEventListener("pointermove", Re), oe.removeEventListener("mouseleave", ft), oe.removeEventListener("wheel", Et), K.remove(), q = void 0, ae = void 0, te == null || te.horizontal.remove(), te == null || te.vertical.remove(), te = void 0, J == null || J.remove(), J = void 0
    }
  }

  function Jt() {
    const oe = q;
    if (!oe) return;
    const K = new Oa(a.tileSize);
    let he, Q, ze, $e;
    if (d.length >= 2) {
      const Pr = d.map(br => K.latLonToPixelsFloor(br.lat, br.lng, a.pixelArtZoom));
      he = Math.min(...Pr.map(([br]) => br)), Q = Math.max(...Pr.map(([br]) => br)) + 1, ze = Math.min(...Pr.map(([, br]) => br)), $e = Math.max(...Pr.map(([, br]) => br)) + 1
    } else if (d.length === 1 && ae) {
      const [Pr, br] = K.latLonToPixelsFloor(d[0].lat, d[0].lng, a.pixelArtZoom), Rr = a.map.unproject([ae.x, ae.y]), [Dr, ot] = K.latLonToPixelsFloor(Rr.lat, Rr.lng, a.pixelArtZoom);
      he = Math.min(Pr, Dr), Q = Math.max(Pr, Dr) + 1, ze = Math.min(br, ot), $e = Math.max(br, ot) + 1
    } else {
      oe.style.display = "none";
      return
    }
    const [Re, ft] = K.pixelsToLatLon(he, ze, a.pixelArtZoom), [Mt, Et] = K.pixelsToLatLon(Q, $e, a.pixelArtZoom), dt = a.map.project([ft, Re]), Kt = a.map.project([Et, Mt]);
    let Qt = Math.min(dt.x, Kt.x),
      Sr = Math.max(dt.x, Kt.x),
      Ft = Math.min(dt.y, Kt.y),
      Ze = Math.max(dt.y, Kt.y);
    Sr - Qt < 1 && (Sr = Qt + 1), Ze - Ft < 1 && (Ze = Ft + 1), oe.style.display = "block", oe.style.left = `${Qt}px`, oe.style.top = `${Ft}px`, oe.style.width = `${Sr-Qt}px`, oe.style.height = `${Ze-Ft}px`
  }

  function Lt() {
    const oe = J;
    if (!oe) return;
    if (!(_(we) === "brush-circle" || _(we) === "brush-square") || !ae) {
      oe.style.display = "none";
      return
    }
    const K = new Oa(a.tileSize),
      he = a.map.unproject([ae.x, ae.y]),
      [Q, ze] = K.latLonToPixels(he.lat, he.lng, a.pixelArtZoom),
      $e = _(Ge) + .5,
      [Re, ft] = K.pixelsToLatLon(Q - $e, ze - $e, a.pixelArtZoom),
      [Mt, Et] = K.pixelsToLatLon(Q + $e, ze + $e, a.pixelArtZoom),
      dt = a.map.project([ft, Re]),
      Kt = a.map.project([Et, Mt]),
      Qt = Math.min(dt.x, Kt.x),
      Sr = Math.max(dt.x, Kt.x),
      Ft = Math.min(dt.y, Kt.y),
      Ze = Math.max(dt.y, Kt.y);
    oe.style.display = "block", oe.style.left = `${Qt}px`, oe.style.top = `${Ft}px`, oe.style.width = `${Math.max(Sr-Qt,2)}px`, oe.style.height = `${Math.max(Ze-Ft,2)}px`, oe.style.borderRadius = _(we) === "brush-circle" ? "100%" : "4px", oe.dataset.radius = String(_(Ge))
  }

  function Gt() {
    const oe = te;
    if (oe) {
      if (!ae || d.length >= 2) {
        Yt();
        return
      }
      oe.horizontal.style.display = "block", oe.horizontal.style.top = `${ae.y}px`, oe.horizontal.style.transform = "translateY(-0.5px)", oe.vertical.style.display = "block", oe.vertical.style.left = `${ae.x}px`, oe.vertical.style.transform = "translateX(-0.5px)"
    }
  }

  function Yt() {
    te && (te.horizontal.style.display = "none", te.vertical.style.display = "none")
  }

  function Lr(oe, K) {
    const he = document.createElement("div");
    return he.style.position = "absolute", he.style.pointerEvents = "none", he.style.zIndex = "5", he.style.display = "none", he.style.mixBlendMode = "difference", he.style.backgroundColor = "rgba(255, 255, 255, 0.9)", K === "horizontal" ? (he.style.left = "0", he.style.right = "0", he.style.height = "1px") : (he.style.top = "0", he.style.bottom = "0", he.style.width = "1px"), oe.appendChild(he), he
  }
  async function Ir(oe, K = "select") {
    if (!_(it)) {
      if (_(A)) {
        Xt.info("Wait until the selected area finishes loading.");
        return
      }
      if (d.length < 2) {
        Xt.info("Select an area first to use the user picker.");
        return
      }
      Y(it, !0);
      try {
        const he = new Oa(a.tileSize),
          {
            tile: Q,
            pixel: ze
          } = he.latLonToTileAndPixel(oe.lngLat.lat, oe.lngLat.lng, a.pixelArtZoom),
          {
            paintedBy: $e
          } = await fn.getPixelInfo({
            season: a.season,
            tile: Q,
            pixel: ze,
            isModerator: !0
          });
        if (!$e || $e.id === 0) {
          Xt.info("That pixel is not painted by any player.");
          return
        }
        const Re = _(x).find(Mt => Mt.id === $e.id);
        if (!Re) {
          Xt.info("Selected pixel is outside the selected area.");
          return
        }
        if (K === "deselect") {
          if (!Pe.has(Re.id)) {
            Ar(Re.id) ? (xi.plop.play(), Xt.success(`${Re.name} deselected`)) : Xt.info("That player is not selected.");
            return
          }
          Pe.delete(Re.id), Wt(Re.painted), Ar(Re.id, {
            skipCrosshair: !0
          }), xi.plop.play(), Xt.success(`${Re.name} deselected`);
          return
        }
        if (Pe.has(Re.id)) {
          Xt.info("Player already selected.");
          return
        }
        Pe.set(Re.id, Re), (xr(Re) || Re.id === 0) && xi.plop.play(), Xt.success(`${Re.name} selected`)
      } catch (he) {
        Xt.error(he.message)
      } finally {
        Y(it, !1)
      }
    }
  }

  function Jr(oe, {
    skipCrosshair: K = !1
  } = {}) {
    return Ie.has(oe.key) ? !1 : (Ie.set(oe.key, oe), K || a.crosshair.place([oe.lat, oe.lon]), !0)
  }

  function Tr(oe, {
    skipCrosshair: K = !1
  } = {}) {
    const he = Ie.get(oe);
    return he ? (Ie.delete(oe), K || a.crosshair.remove([he.lat, he.lon]), !0) : !1
  }

  function Ar(oe, {
    skipCrosshair: K = !1
  } = {}) {
    const he = [];
    for (const [ze, $e] of Ie.entries()) $e.userId === oe && he.push(ze);
    let Q = !1;
    for (const ze of he) Tr(ze, {
      skipCrosshair: K
    }) && (Q = !0);
    return Q && Y(Ce, _(Ce) + 1), Q
  }

  function xr(oe, {
    skipCrosshair: K = !1
  } = {}) {
    if (oe.id === 0) return !1;
    const he = oe.painted;
    let Q = !1;
    for (let ze = 0; ze < he.latitudes.length; ze++) {
      const $e = he.tileXs[ze],
        Re = he.tileYs[ze],
        ft = he.pixelXs[ze],
        Mt = he.pixelYs[ze],
        Et = `${$e}:${Re}:${ft}:${Mt}`;
      let dt = _t.get(Et);
      if (!dt) {
        dt = {
          key: Et,
          userId: oe.id,
          lat: he.latitudes[ze],
          lon: he.longitudes[ze],
          tile: [$e, Re],
          pixel: [ft, Mt],
          globalPx: he.globalPx[ze],
          globalPy: he.globalPy[ze]
        }, _t.set(Et, dt);
        const Kt = `${$e}:${Re}`;
        let Qt = wt.get(Kt);
        Qt || (Qt = [], wt.set(Kt, Qt)), Qt.push(dt)
      }
      Jr(dt, {
        skipCrosshair: K
      }) && (Q = !0)
    }
    return Q && Y(Ce, _(Ce) + 1), Q
  }

  function qt(oe) {
    return _(x).find(K => K.id === oe)
  }

  function Yr(oe, {
    silent: K = !1
  } = {}) {
    let he = !1;
    for (const [Q, ze] of oe) {
      if (Pe.has(Q)) continue;
      const $e = qt(Q);
      if (!$e) continue;
      const Re = $e.painted.latitudes.length;
      (_(je).get(Q) ?? 0) + ze >= Re && (Pe.set(Q, $e), he = !0)
    }
    he && !K && xi.plop.play()
  }

  function Le(oe, K) {
    if (_t.size === 0) return [];
    const he = new Oa(a.tileSize),
      [Q, ze] = he.latLonToPixels(oe, K, a.pixelArtZoom),
      $e = _(Ge) + .5,
      Re = Q - $e,
      ft = Q + $e,
      Mt = ze - $e,
      Et = ze + $e,
      dt = Math.floor(Re / a.tileSize),
      Kt = Math.floor(ft / a.tileSize),
      Qt = Math.floor(Mt / a.tileSize),
      Sr = Math.floor(Et / a.tileSize),
      Ft = [];
    for (let Ze = dt; Ze <= Kt; Ze++)
      for (let Pr = Qt; Pr <= Sr; Pr++) {
        const br = `${Ze}:${Pr}`,
          Rr = wt.get(br);
        if (Rr)
          for (const Dr of Rr) {
            const ot = Dr.globalPx - Q,
              dr = Dr.globalPy - ze;
            if (_(we) === "brush-circle") {
              if (ot * ot + dr * dr > $e * $e) continue
            } else if (Math.abs(ot) > $e || Math.abs(dr) > $e) continue;
            Ft.push(Dr)
          }
      }
    return Ft
  }

  function j(oe, K, {
    silent: he = !1
  } = {}) {
    if (_(A)) return he || Xt.info("Wait until the selected area finishes loading."), !1;
    if (d.length < 2) return he || Xt.info("Select an area first to use the brush tool."), !1;
    const Q = Le(oe.lngLat.lat, oe.lngLat.lng);
    if (Q.length === 0) {
      if (!he) {
        const Re = K === "add" ? "No painted pixels found within the brush." : "No selected pixels to remove within the brush.";
        Xt.info(Re)
      }
      return !1
    }
    let ze = !1;
    const $e = new Map;
    if (K === "add")
      for (const Re of Q) Pe.has(Re.userId) || Ie.has(Re.key) || Jr(Re) && (ze = !0, $e.set(Re.userId, ($e.get(Re.userId) ?? 0) + 1));
    else
      for (const Re of Q) Tr(Re.key) && (ze = !0, Pe.has(Re.userId) && Pe.delete(Re.userId));
    return ze ? (K === "add" && $e.size > 0 && Yr($e, {
      silent: he
    }), Y(Ce, _(Ce) + 1), he || xi.plop.play(), !0) : (!he && K === "add" && Xt.info("All pixels inside the brush are already selected."), !1)
  }
  async function E() {
    if (!(_(s) || _(A))) {
      if (d.length < 2) {
        Xt.info("Select an area first to save pixel art.");
        return
      }
      Y(s, !0);
      try {
        const oe = new Oa(a.tileSize);
        let K = 1 / 0,
          he = -1 / 0,
          Q = 1 / 0,
          ze = -1 / 0;
        for (let Rr = 0; Rr < d.length; Rr++) {
          const Dr = d[Rr],
            ot = oe.latLonToPixelsFloor(Dr.lat, Dr.lng, a.pixelArtZoom),
            dr = ot[0],
            st = ot[1];
          dr < K && (K = dr), dr > he && (he = dr), st < Q && (Q = st), st > ze && (ze = st)
        }
        if (!isFinite(K) || !isFinite(he) || !isFinite(Q) || !isFinite(ze)) {
          Xt.error("Unable to determine selected area.");
          return
        }
        const $e = he + 1,
          Re = ze + 1,
          ft = $e - K,
          Mt = Re - Q;
        if (ft <= 0 || Mt <= 0) {
          Xt.error("Selected area has no size.");
          return
        }
        const Et = document.createElement("canvas");
        Et.width = ft, Et.height = Mt;
        const dt = Et.getContext("2d");
        if (!dt) {
          Xt.error("Unable to create drawing context.");
          return
        }
        const Kt = Math.floor(K / a.tileSize),
          Qt = Math.floor(($e - 1) / a.tileSize),
          Sr = Math.floor(Q / a.tileSize),
          Ft = Math.floor((Re - 1) / a.tileSize);
        for (let Rr = Sr; Rr <= Ft; Rr++)
          for (let Dr = Kt; Dr <= Qt; Dr++) {
            const ot = Dr * a.tileSize,
              dr = Rr * a.tileSize,
              st = Math.max(K, ot),
              Tt = Math.max(Q, dr),
              nr = Math.min($e, ot + a.tileSize),
              Ur = Math.min(Re, dr + a.tileSize),
              Ot = nr - st,
              Fr = Ur - Tt;
            if (Ot <= 0 || Fr <= 0) continue;
            const Xr = await fetch(`${A0}/s${a.season}/tiles/${Dr}/${Rr}.png`);
            if (!Xr.ok) throw new Error("Failed to load tile image.");
            const mn = await Xr.blob();
            if ("createImageBitmap" in window) {
              const sn = await createImageBitmap(mn);
              dt.drawImage(sn, st - ot, Tt - dr, Ot, Fr, st - K, Tt - Q, Ot, Fr), sn.close && sn.close()
            } else {
              const sn = URL.createObjectURL(mn),
                hn = await new Promise((dn, nn) => {
                  const Ke = new Image;
                  Ke.crossOrigin = "anonymous", Ke.onload = () => dn(Ke), Ke.onerror = () => nn(new Error("Failed to decode tile image.")), Ke.src = sn
                });
              dt.drawImage(hn, st - ot, Tt - dr, Ot, Fr, st - K, Tt - Q, Ot, Fr), URL.revokeObjectURL(sn)
            }
          }
        const Ze = await new Promise((Rr, Dr) => {
            Et.toBlob(ot => {
              ot ? Rr(ot) : Dr(new Error("Failed to prepare download."))
            }, "image/png")
          }),
          Pr = URL.createObjectURL(Ze),
          br = document.createElement("a");
        br.href = Pr, br.download = `selected-area-${ft}x${Mt}.png`, document.body.appendChild(br), br.click(), document.body.removeChild(br), URL.revokeObjectURL(Pr), Xt.success("Selected area image saved")
      } catch (oe) {
        Xt.error(oe.message)
      } finally {
        Y(s, !1)
      }
    }
  }
  async function D() {
    if (_(b) || _(A)) return;
    const oe = new Map;
    for (const K of Pe.values()) {
      if (K.id === 0) continue;
      const {
        tileXs: he,
        tileYs: Q,
        pixelXs: ze,
        pixelYs: $e
      } = K.painted;
      for (let Re = 0; Re < he.length; Re++) {
        const ft = [he[Re], Q[Re]],
          Mt = [ze[Re], $e[Re]],
          Et = {
            tile: ft,
            pixel: Mt,
            season: a.season
          },
          dt = `${ft[0]}:${ft[1]}:${Mt[0]}:${Mt[1]}`;
        oe.set(dt, Et)
      }
    }
    for (const K of Ie.values()) Pe.has(K.userId) || oe.has(K.key) || oe.set(K.key, {
      tile: K.tile,
      pixel: K.pixel,
      season: a.season
    });
    if (oe.size === 0) {
      Xt.info("Select painted pixels to clear with transparent color");
      return
    }
    Y(b, !0);
    try {
      xi.droppletAndPlop.play();
      const K = await Dg(),
        he = [];
      for (const $e of oe.values()) he.push({
        ...$e,
        colorIdx: 0
      });
      await fn.paint(he, K);
      const Q = gg(0),
        ze = he.map(({
          tile: $e,
          pixel: Re,
          season: ft
        }) => ({
          tile: $e,
          pixel: Re,
          season: ft,
          color: Q
        }));
      await pg(ze), Xt.success("Painted selected pixels with transparent color"), await Ht()
    } catch (K) {
      Xt.error(K.message)
    } finally {
      Y(b, !1)
    }
  }
  const N = oe => ({
    id: oe.id,
    name: oe.name,
    picture: oe.picture,
    allianceId: oe.allianceId ?? void 0,
    allianceName: oe.allianceName ?? void 0,
    timedOut: oe.timedOut,
    banned: oe.banned,
    deleted: oe.deleted
  });

  function X() {
    const oe = new Map;
    for (const K of Pe.values()) K.id !== 0 && oe.set(K.id, K);
    if (Ie.size > 0) {
      let K;
      for (const he of Ie.values()) {
        const Q = he.userId;
        if (Q === 0 || oe.has(Q)) continue;
        if (!K) {
          K = new Map;
          for (const $e of _(x)) K.set($e.id, $e)
        }
        const ze = K.get(Q);
        ze && oe.set(ze.id, ze)
      }
    }
    return [...oe.values()]
  }
  async function ee(oe, K) {
    try {
      Y(z, !0);
      const he = oe.filter(dt => dt.id !== 0);
      if (he.length === 0) {
        Xt.info("Select at least one player");
        return
      }
      let Q = 1 / 0,
        ze = -1 / 0,
        $e = 1 / 0,
        Re = -1 / 0;
      if (d.length >= 2)
        for (const dt of d) {
          const {
            lat: Kt,
            lng: Qt
          } = dt;
          !isFinite(Kt) || !isFinite(Qt) || (Kt < Q && (Q = Kt), Kt > ze && (ze = Kt), Qt < $e && ($e = Qt), Qt > Re && (Re = Qt))
        }
      Q === ze && (Q -= 1e-6, ze += 1e-6), $e === Re && ($e -= 1e-6, Re += 1e-6), a.map.stop();
      const ft = a.map.getCanvas(),
        Mt = Math.max(48, Math.min(ft.width, ft.height) * .08);
      a.map.fitBounds([
        [Math.min($e, Re), Math.min(Q, ze)],
        [Math.max($e, Re), Math.max(Q, ze)]
      ], {
        padding: Mt,
        duration: 0
      });
      const Et = (async () => await Bg(a.map, {
        maxHeight: 1080,
        maxWidth: 1080,
        quality: .8,
        type: "image/jpeg"
      }))();
      a.onmodaction({
        action: K,
        targets: he.map(N),
        image: Et,
        latLon: [(Q + ze) / 2, ($e + Re) / 2],
        zoom: a.map.getZoom(),
        onSuccess: async () => {
          await Ht({
            preserveSelection: !0
          })
        }
      })
    } catch (he) {
      Xt.error(he.message)
    } finally {
      Y(z, !1)
    }
  }
  var pe = or();
  Ln("keydown", Zs, oe => oe.code === "Escape" && Bt());
  var be = xt(pe);
  {
    var ye = oe => {
        yl(oe, {
          class: "bg-warning animate-bounce",
          children: (K, he) => {
            var Q = GF(),
              ze = xt(Q);
            uh(ze, {
              class: "inline size-5"
            });
            var $e = O(ze, 2);
            {
              var Re = Mt => {
                  var Et = qi();
                  Ue(dt => ce(Et, dt), [() => Q0()]), Z(Mt, Et)
                },
                ft = Mt => {
                  var Et = or(),
                    dt = xt(Et);
                  {
                    var Kt = Qt => {
                      var Sr = qi();
                      Ue(Ft => ce(Sr, Ft), [() => ey()]), Z(Qt, Sr)
                    };
                    Ee(dt, Qt => {
                      d.length === 1 && Qt(Kt)
                    }, !0)
                  }
                  Z(Mt, Et)
                };
              Ee($e, Mt => {
                d.length === 0 ? Mt(Re) : Mt(ft, !1)
              })
            }
            Z(K, Q)
          },
          $$slots: {
            default: !0
          }
        })
      },
      Oe = oe => {
        var K = lB();
        let he;
        var Q = I(K),
          ze = I(Q),
          $e = I(ze);
        $e.__pointerdown = It, bs($e, "", {}, {
          "touch-action": "none"
        });
        var Re = I($e),
          ft = I(Re),
          Mt = I(ft);
        uh(Mt, {
          class: "size-4"
        }), C(ft);
        var Et = O(ft, 4),
          dt = I(Et);
        C(Et), C(Re);
        var Kt = O(Re, 2),
          Qt = I(Kt);
        let Sr;
        Qt.__click = E;
        var Ft = I(Qt);
        {
          var Ze = Ke => {
              var St = HF();
              Z(Ke, St)
            },
            Pr = Ke => {
              yg(Ke, {
                class: "size-4"
              })
            };
          Ee(Ft, Ke => {
            _(s) ? Ke(Ze) : Ke(Pr, !1)
          })
        }
        C(Qt);
        var br = O(Qt, 2);
        let Rr;
        br.__click = () => {
          if (_(we) === "brush-circle") {
            Y(we, "area-select");
            return
          }
          if (_(A)) {
            Xt.info("Wait until the selected area finishes loading.");
            return
          }
          if (d.length < 2) {
            Xt.info("Select an area first to use the brush tools.");
            return
          }
          Y(we, "brush-circle")
        };
        var Dr = I(br);
        VF(Dr, {
          class: "size-4"
        }), C(br);
        var ot = O(br, 2);
        let dr;
        ot.__click = () => {
          if (_(we) === "brush-square") {
            Y(we, "area-select");
            return
          }
          if (_(A)) {
            Xt.info("Wait until the selected area finishes loading.");
            return
          }
          if (d.length < 2) {
            Xt.info("Select an area first to use the brush tools.");
            return
          }
          Y(we, "brush-square")
        };
        var st = I(ot);
        ZF(st, {
          class: "size-4"
        }), C(ot);
        var Tt = O(ot, 2);
        let nr;
        Tt.__click = () => {
          if (_(we) === "user-picker") {
            Y(we, "area-select");
            return
          }
          if (_(A)) {
            Xt.info("Wait until the selected area finishes loading.");
            return
          }
          if (d.length < 2) {
            Xt.info("Select an area first to use the user picker.");
            return
          }
          Y(we, "user-picker")
        };
        var Ur = I(Tt);
        {
          var Ot = Ke => {
              var St = WF();
              Z(Ke, St)
            },
            Fr = Ke => {
              jF(Ke, {
                class: "size-4"
              })
            };
          Ee(Ur, Ke => {
            _(it) ? Ke(Ot) : Ke(Fr, !1)
          })
        }
        C(Tt);
        var Xr = O(Tt, 2);
        Xr.__click = Bt;
        var mn = I(Xr);
        ws(mn, {
          class: "size-4"
        }), C(Xr), C(Kt), C($e);
        var sn = O($e, 2),
          hn = I(sn);
        {
          var dn = Ke => {
              var St = $F();
              Z(Ke, St)
            },
            nn = Ke => {
              var St = or(),
                kr = xt(St);
              {
                var wr = Mr => {
                    var gn = XF();
                    Z(Mr, gn)
                  },
                  mr = Mr => {
                    var gn = sB(),
                      Rn = I(gn),
                      ln = I(Rn),
                      Gn = I(ln),
                      On = I(Gn),
                      Wn = I(On);
                    za(Wn), Wn.__click = on => {
                      if (_(qe) === "none") {
                        Ie.clear(), Y(Ce, _(Ce) + 1), a.crosshair.clear();
                        const Er = [];
                        for (const Hn of _(x)) Pe.has(Hn.id) || (Pe.set(Hn.id, Hn), Er.push(Hn));
                        Er.length && yr(Er);
                        return
                      }
                      Pe.clear(), Ie.clear(), Y(Ce, _(Ce) + 1), a.crosshair.clear()
                    }, C(On);
                    var ti = O(On),
                      Zn = O(I(ti));
                    Zn.__click = () => {
                      navigator.clipboard.writeText([...Pe.keys()].filter(on => on !== 0).join(", ")), Xt.success("Player IDs copied to clipboard")
                    };
                    var cn = I(Zn);
                    bg(cn, {
                      class: "size-3"
                    }), C(Zn);
                    var kn = O(Zn, 2);
                    kn.__click = () => {
                      const on = X();
                      ee(on, "timeout")
                    };
                    var Xn = I(kn);
                    ah(Xn, {
                      class: "size-4"
                    }), C(kn);
                    var Ri = O(kn, 2);
                    {
                      var Ii = on => {
                        var Er = YF();
                        Er.__click = () => {
                          const jn = X();
                          ee(jn, "ban")
                        };
                        var Hn = I(Er);
                        Fp(Hn, {
                          class: "size-4"
                        }), C(Er), Ue(() => Er.disabled = _(z)), Z(on, Er)
                      };
                      Ee(Ri, on => {
                        var Er;
                        Ea((Er = Dt.data) == null ? void 0 : Er.role, ["admin", "global_moderator"]) && on(Ii)
                      })
                    }
                    C(ti);
                    var Vi = O(ti),
                      pt = I(Vi);
                    {
                      var $t = on => {
                        var Er = JF();
                        Er.__click = D;
                        var Hn = I(Er);
                        {
                          var jn = Yn => {
                              var vr = KF();
                              Z(Yn, vr)
                            },
                            Cn = Yn => {
                              Mm(Yn, {
                                class: "size-4"
                              })
                            };
                          Ee(Hn, Yn => {
                            _(b) ? Yn(jn) : Yn(Cn, !1)
                          })
                        }
                        C(Er), Ue(() => Er.disabled = _(b) || _(A) || Pe.size === 0 && _(Ye) === 0), Z(on, Er)
                      };
                      Ee(pt, on => {
                        var Er;
                        Ea((Er = Dt.data) == null ? void 0 : Er.role, ["admin", "global_moderator"]) && on($t)
                      })
                    }
                    wn(), C(Vi), C(Gn), C(ln);
                    var Or = O(ln);
                    fi(Or, 23, () => _(x), on => on.id, (on, Er, Hn, jn) => {
                      const Cn = ut(() => Pe.has(_(Er).id)),
                        Yn = ut(() => _(je).get(_(Er).id) ?? 0),
                        vr = ut(() => _(Cn) || _(Yn) > 0);
                      var ar = oB();
                      let gr;
                      ar.__click = () => {
                        _(Cn) ? (Pe.delete(_(Er).id), Wt(_(Er).painted), Ar(_(Er).id, {
                          skipCrosshair: !0
                        })) : (Ar(_(Er).id, {
                          skipCrosshair: !0
                        }), Pe.set(_(Er).id, _(Er)), (xr(_(Er)) || _(Er).id === 0) && xi.plop.play())
                      };
                      var zr = I(ar),
                        Fn = I(zr);
                      za(Fn), C(zr);
                      var xn = O(zr),
                        In = I(xn);
                      {
                        var qn = bn => {
                            var vn = QF();
                            wn(2), Z(bn, vn)
                          },
                          $n = bn => {
                            var vn = iB(),
                              ii = xt(vn);
                            Mo(ii, {
                              class: "size-5 border-0",
                              get userId() {
                                return _(Er).id
                              },
                              get pictureUrl() {
                                return _(Er).picture
                              }
                            });
                            var Kn = O(ii, 2),
                              Vn = I(Kn),
                              ga = I(Vn),
                              ta = I(ga, !0);
                            C(ga);
                            var Fi = O(ga, 2),
                              zn = I(Fi);
                            C(Fi), C(Vn);
                            var ja = O(Vn, 2);
                            {
                              var Sn = ci => {
                                var wi = eB(),
                                  sa = I(wi, !0);
                                C(wi), Ue((Ra, Sa) => {
                                  qr(wi, 1, `badge badge-sm ml-0.5 border-0 ${Ra??""} ${Sa??""}`, "svelte-15blegn"), ce(sa, _(Er).allianceName)
                                }, [() => Kp(_(Er).allianceId), () => ea(_(Er).allianceId)]), Z(ci, wi)
                              };
                              Ee(ja, ci => {
                                _(Er).allianceId && ci(Sn)
                              })
                            }
                            var _n = O(ja, 2);
                            {
                              var Ta = ci => {
                                var wi = tB();
                                Z(ci, wi)
                              };
                              Ee(_n, ci => {
                                _(Er).deleted && ci(Ta)
                              })
                            }
                            var En = O(_n, 2),
                              qa = I(En);
                            {
                              var Ui = ci => {
                                  var wi = rB(),
                                    sa = I(wi);
                                  Fp(sa, {
                                    class: "text-error size-4"
                                  }), C(wi), Ue(Ra => cr(wi, "data-tip", Ra), [() => vg()]), Z(ci, wi)
                                },
                                Va = ci => {
                                  var wi = or(),
                                    sa = xt(wi);
                                  {
                                    var Ra = Sa => {
                                      var la = nB(),
                                        eo = I(la);
                                      ah(eo, {
                                        class: "text-error size-4"
                                      }), C(la), Ue(ca => cr(la, "data-tip", ca), [() => Z0()]), Z(Sa, la)
                                    };
                                    Ee(sa, Sa => {
                                      _(Er).timedOut && Sa(Ra)
                                    }, !0)
                                  }
                                  Z(ci, wi)
                                };
                              Ee(qa, ci => {
                                _(Er).banned ? ci(Ui) : ci(Va, !1)
                              })
                            }
                            C(En), C(Kn), Ue(ci => {
                              qr(Vn, 1, `font-medium ${ci??""} flex gap-1.5`, "svelte-15blegn"), ce(ta, _(Er).name), ce(zn, `#${_(Er).id??""}`)
                            }, [() => ea(_(Er).id)]), Z(bn, vn)
                          };
                        Ee(In, bn => {
                          _(Er).id === 0 ? bn(qn) : bn($n, !1)
                        })
                      }
                      C(xn);
                      var Mn = O(xn),
                        Qr = I(Mn),
                        Tn = O(Qr);
                      {
                        var Bn = bn => {
                          var vn = aB(),
                            ii = I(vn);
                          C(vn), Ue(Kn => ce(ii, `(${Kn??""} selected)`), [() => _(Yn).toLocaleString()]), Z(bn, vn)
                        };
                        Ee(Tn, bn => {
                          !_(Cn) && _(Yn) > 0 && bn(Bn)
                        })
                      }
                      C(Mn), C(ar), Ue(bn => {
                        gr = qr(ar, 1, "hover:bg-base-300 cursor-pointer svelte-15blegn", null, gr, {
                          "bg-base-200": _(vr)
                        }), Nv(Fn, _(Cn)), Fn.indeterminate = !_(Cn) && _(Yn) > 0, ce(Qr, `${bn??""} `)
                      }, [() => _(Er).painted.latitudes.length.toLocaleString()]), Z(on, ar)
                    }), C(Or), C(Rn), C(gn), Ue(() => {
                      Nv(Wn, _(qe) !== "none"), Wn.indeterminate = _(qe) === "some", kn.disabled = _(z)
                    }), Z(Mr, gn)
                  };
                Ee(kr, Mr => {
                  _(x).length === 0 ? Mr(wr) : Mr(mr, !1)
                }, !0)
              }
              Z(Ke, St)
            };
          Ee(hn, Ke => {
            _(A) ? Ke(dn) : Ke(nn, !1)
          })
        }
        C(sn), C(ze), C(Q), C(K), lo(K, Ke => Y(fe, Ke), () => _(fe)), Ue(Ke => {
          he = bs(K, "", he, {
            transform: `translate3d(${ie.x}px, ${ie.y}px, 0)`,
            "will-change": "transform"
          }), ce(dt, `(Pixels: ${Ke??""})`), Sr = qr(Qt, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, Sr, {
            "btn-soft": _(we) !== "brush-circle",
            "btn-primary": _(we) === "brush-circle"
          }), Qt.disabled = _(s) || _(A), Rr = qr(br, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, Rr, {
            "btn-soft": _(we) !== "brush-circle",
            "btn-primary": _(we) === "brush-circle"
          }), cr(br, "data-tip", `Circle brush (Alt + scroll to resize) ¬∑ Size: ${_(He)}`), cr(br, "aria-label", _(we) === "brush-circle" ? "Disable circle brush tool" : `Enable circle brush tool (size ${_(He)})`), cr(br, "aria-pressed", _(we) === "brush-circle"), dr = qr(ot, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, dr, {
            "btn-soft": _(we) !== "brush-square",
            "btn-primary": _(we) === "brush-square"
          }), cr(ot, "data-tip", `Square brush (Alt + scroll to resize) ¬∑ Size: ${_(He)}`), cr(ot, "aria-label", _(we) === "brush-square" ? "Disable square brush tool" : `Enable square brush tool (size ${_(He)})`), cr(ot, "aria-pressed", _(we) === "brush-square"), nr = qr(Tt, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, nr, {
            "btn-soft": _(we) !== "user-picker",
            "btn-primary": _(we) === "user-picker"
          }), cr(Tt, "data-tip", _(we) === "user-picker" ? "User picker enabled. Click pixels to select their painter." : "Enable the user picker to select a player by clicking a pixel."), cr(Tt, "aria-label", _(we) === "user-picker" ? "Disable user picker tool" : "Enable user picker tool"), cr(Tt, "aria-pressed", _(we) === "user-picker")
        }, [() => _(Be).toLocaleString()]), ba(3, Q, () => Sp, () => ({
          duration: 100
        })), Z(oe, K)
      };
    Ee(be, oe => {
      d.length < 2 ? oe(ye) : oe(Oe, !1)
    })
  }
  Z(m, pe), $r()
}
ni(["pointerdown", "click"]);
const uB = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB8AAAAfCAYAAAAfrhY5AAAByUlEQVR4AeyV0VEDMQxEbQqgDEqhFrpg6IJaKIUyaODQ89wqimKf75LM5AOY20harbWyf3gqD/z7N3/I49/j2RfbHFg49t1qvjx/vRVgtocXuMW8GZtp+Xn9JFR+jmCvObeKcI9gHPvkrhklM3OGLMv7S4mwYfAW/Btpss4PkIzMOeQDEQr149sX4dZaCl4aonjL2yyLF1/PvGvKSQwYSp4BT7/H0zOeJSycvmzejE/t+2W9BbL5pts6wDWz2oWDJJr7rXm+iMHZTTqeJ0e8LuvPH83pN6yilvPDYYF6BGmIUZPnqdc1V1NxWZYCqPNgOCAeHYCbYZd5HiIj8bkWP4tD8/hUtdZSa/VZ6slUNYJaa1dLL2NojjAOpQbiZKwoHo3Q49QjbpojYEAEHJhx9NFtYWqum/WGXNvTrGhe8zDVijpEFKcIJ4hTTHxVHc3FtaiDej7VNJUf7XE2Ipv77RkMECtiCiI368W+nfNbW16yOVxbQCYQQENynuuoo8ccYPmZsdVdc3iEF0swGCAA61BS/x/fCvuhB0hXWDj/ejePirMlGBZhQl8w8uT0VljofzNznWpLWJGjUSVzqultYq/55pBrm3/X/BcAAP//XVoCOwAAAAZJREFUAwCtKAFOt0LgOAAAAABJRU5ErkJgggAA";
var hB = jr('<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>');

function t1(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = hB();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var dB = jr('<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>');

function pB(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = dB();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var fB = jr('<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>'),
  mB = jr('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>');

function gB(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = or(),
    A = xt(x);
  {
    var z = s => {
        var F = fB();
        _r(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...d
        })), Z(s, F)
      },
      b = s => {
        var F = mB();
        _r(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...d
        })), Z(s, F)
      };
    Ee(A, s => {
      a.filled ? s(z) : s(b, !1)
    })
  }
  Z(m, x)
}
var _B = me('<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button>'),
  vB = me('<div class="skeleton h-5 w-16"></div>'),
  yB = me('<div class="skeleton mt-1 h-5 w-32"></div>'),
  xB = me('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><div class="bg-base-content/20 flex size-5 items-center justify-center rounded-full text-sm"><img alt="Pumpkin" class="size-5"/></div></div> <div class="flex flex-wrap items-center gap-1"><span class="flex gap-1.5 font-medium text-orange-500"><span> </span> <span> </span></span></div></div>'),
  bB = me('<span class="font-flag tooltip ml-0.5"> </span>'),
  wB = me('<span class="badge badge-dash badge-sm bg-primary/20 text-primary tooltip ml-0.5 gap-1 border-0"><!> </span>'),
  TB = me("<button><!></button>"),
  SB = me("<span> </span> <!>", 1),
  PB = me('<span class="tooltip"><!></span>'),
  CB = me('<span class="tooltip"><!></span>'),
  IB = me("<li><button><!> </button></li>"),
  MB = me("<li><button><!> </button></li>"),
  AB = me("<li><button><!> </button></li>"),
  kB = me('<li><button class="text-error font-medium"><!> </button></li>'),
  EB = me('<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left ml-1"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 shadow-sm"></ul></div>'),
  LB = me('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><!></div> <div class="flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!> <!> <!> <!> <!></div> <!></div>'),
  zB = me('<button class="btn btn-primary"><!> </button>'),
  DB = me("<!> ", 1),
  RB = me("<!> ", 1),
  FB = me('<button class="btn btn-primary"><!></button>'),
  BB = me("<button><!> </button>"),
  OB = me('<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><!> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>');

function NB(m, a) {
  Wr(a, !0);
  let d = et(void 0);
  const x = ut(() => new Oa(a.tileSize));
  let A = et(void 0),
    z = et(void 0),
    b = et(!1),
    s = et(!1);
  const F = ut(() => {
      var tt, ht, It;
      return !!((ht = (tt = _(d)) == null ? void 0 : tt.paintedBy) != null && ht.id) && ((It = Dt.data) == null ? void 0 : It.id) === _(d).paintedBy.id
    }),
    q = ut(() => {
      const [tt, ht] = a.latLon ?? [0, 0], It = _(x).latLonToPixelBoundsLatLon(tt, ht, a.pixelArtZoom), Bt = kg(It), {
        tile: Nt,
        pixel: Ht
      } = _(x).latLonToTileAndPixel(tt, ht, a.pixelArtZoom), yr = _(x).latLonToRegionAndPixel(tt, ht, a.pixelArtZoom);
      return {
        bounds: It,
        center: Bt,
        tile: Nt,
        pixel: Ht,
        regionPixel: yr.pixel
      }
    });
  tn(() => {
    xi.plop.play(), a.crosshair.clearAndPlace(a.latLon)
  });
  let J = 0;
  const te = ({
    pixel: tt,
    tile: ht,
    season: It
  }) => `s${It}:p(${tt[0]},${tt[1]}):t(${ht[0]},${ht[1]})`;
  let ae;
  Gs(() => [_(q), a.season], () => {
    const tt = {
        ..._(q),
        season: a.season
      },
      ht = te(tt);
    if (Y(d, a.pixelInfoCache.get(ht), !0), _(d) !== void 0) return;
    a.pixelInfoCache.size === 0 && (J = 0), J++, J > 6 ? (clearTimeout(ae), ae = setTimeout(async () => fe(tt), 500)) : fe(tt)
  });
  async function fe(tt) {
    var Bt;
    const ht = await fn.getPixelInfo({
      ...tt,
      isModerator: Ea((Bt = Dt.data) == null ? void 0 : Bt.role, ["admin", "global_moderator", "moderator"])
    });
    if (ht.paintedBy !== void 0) {
      const Nt = te(tt);
      a.pixelInfoCache.set(Nt, ht)
    }
    const It = te({
      ..._(q),
      season: a.season
    });
    return Y(d, a.pixelInfoCache.get(It), !0), ht
  }
  ri(() => () => {
    a.crosshair.clear(), xi.smallPlop.play()
  });
  const ie = ut(() => {
    var Bt, Nt, Ht, yr, Wt;
    const tt = [],
      ht = (Nt = (Bt = Dt) == null ? void 0 : Bt.data) == null ? void 0 : Nt.role;
    Ea(ht, ["admin", "global_moderator"]) && !_(F) && tt.push("ban-user"), Ea(ht, ["admin", "global_moderator", "moderator"]) && !_(F) && tt.push("timeout-user"), !_(F) && Dt.data && tt.push("report-user");
    const It = (Ht = _(d)) == null ? void 0 : Ht.paintedBy;
    return (It == null ? void 0 : It.allianceId) === ((yr = Dt.data) == null ? void 0 : yr.allianceId) && ((Wt = Dt.data) == null ? void 0 : Wt.allianceRole) === "admin" && Dt.data.id !== (It == null ? void 0 : It.id) && !_(F) && tt.push("ban-alliance"), tt
  });

  function $(tt) {
    const ht = (async () => await Bg(a.map, {
      maxHeight: 1080,
      maxWidth: 1080,
      quality: .8,
      type: "image/jpeg"
    }))();
    a.onclickmodaction(_(d), ht, a.latLon, tt)
  }
  async function Se() {
    try {
      await fn.claimEventPixel({
        ..._(q),
        season: a.season
      }), Xt.success(S6({
        droplets: 2e3.toLocaleString()
      })), await fe({
        ..._(q),
        season: a.season
      }), await Dt.refresh()
    } catch (tt) {
      Xt.error(tt.message)
    }
  }
  var Me = OB();
  Ln("keypress", Zs, tt => {
    tt.key === "Escape" && a.onclose()
  });
  var Pe = I(Me),
    Ie = I(Pe),
    Ce = I(Ie);
  Ce.__click = () => {
    if (_(A) && _(z)) {
      const tt = _(A) - _(z).clientHeight,
        ht = _(A) / 2 - tt / 2;
      a.map.flyTo({
        center: {
          lat: _(q).center[0],
          lng: _(q).center[1]
        },
        zoom: 17.5,
        offset: [0, -ht]
      })
    }
  };
  var je = I(Ce);
  Qp(je, {
    class: "fill-primary size-5"
  }), C(Ce);
  var Ye = O(Ce, 2),
    qe = I(Ye),
    Be = I(qe);
  C(qe);
  var He = O(qe, 2);
  {
    var we = tt => {
        const ht = ut(() => _(d).region),
          It = ut(() => qo(_(ht).countryId));
        var Bt = _B();
        Bt.__click = () => a.onclickregion(_(ht));
        var Nt = I(Bt),
          Ht = I(Nt, !0);
        C(Nt);
        var yr = O(Nt, 2),
          Wt = I(yr, !0);
        C(yr);
        var Zt = O(yr, 2),
          jt = I(Zt);
        C(Zt), C(Bt), Ue(Jt => {
          qr(Bt, 1, `btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${Jt??""}`), cr(Nt, "data-tip", _(It).name), ce(Ht, _(It).flag), ce(Wt, _(ht).name), ce(jt, `#${_(ht).number??""}`)
        }, [() => ea(_(ht).cityId)]), Z(tt, Bt)
      },
      it = tt => {
        var ht = vB();
        Z(tt, ht)
      };
    Ee(He, tt => {
      var ht;
      (ht = _(d)) != null && ht.region ? tt(we) : tt(it, !1)
    })
  }
  C(Ye), C(Ie);
  var mt = O(Ie, 2);
  mt.__click = function(...tt) {
    var ht;
    (ht = a.onclose) == null || ht.apply(this, tt)
  };
  var Ge = I(mt);
  ws(Ge, {
    class: "size-4"
  }), C(mt), C(Pe);
  var Xe = O(Pe, 2),
    vt = I(Xe);
  {
    var Ut = tt => {
        var ht = yB();
        Z(tt, ht)
      },
      _t = tt => {
        var ht = or(),
          It = xt(ht);
        {
          var Bt = Ht => {
              var yr = qi();
              Ue(Wt => ce(yr, Wt), [() => vP()]), Z(Ht, yr)
            },
            Nt = Ht => {
              var yr = or(),
                Wt = xt(yr);
              {
                var Zt = Jt => {
                    var Lt = xB(),
                      Gt = I(Lt),
                      Yt = I(Gt);
                    C(Gt);
                    var Lr = O(Gt, 2),
                      Ir = I(Lr),
                      Jr = I(Ir);
                    C(Ir), C(Lr);
                    var Tr = O(Lr, 2),
                      Ar = I(Tr),
                      xr = I(Ar),
                      qt = I(xr, !0);
                    C(xr);
                    var Yr = O(xr, 2),
                      Le = I(Yr);
                    C(Yr), C(Ar), C(Tr), C(Lt), Ue((j, E) => {
                      ce(Yt, `${j??""}:`), cr(Jr, "src", uB), ce(qt, E), ce(Le, `#${_(d).paintedBy.eventClaimNumber??""}`)
                    }, [() => I6(), () => m6()]), Z(Jt, Lt)
                  },
                  jt = Jt => {
                    const Lt = ut(() => _(d).paintedBy);
                    var Gt = LB(),
                      Yt = I(Gt),
                      Lr = I(Yt);
                    C(Yt);
                    var Ir = O(Yt, 2),
                      Jr = I(Ir);
                    Mo(Jr, {
                      class: "size-5 border-0",
                      get userId() {
                        return _(Lt).id
                      },
                      get pictureUrl() {
                        return _(Lt).picture
                      }
                    }), C(Ir);
                    var Tr = O(Ir, 2),
                      Ar = I(Tr),
                      xr = I(Ar),
                      qt = I(xr, !0);
                    C(xr);
                    var Yr = O(xr, 2),
                      Le = I(Yr);
                    C(Yr), C(Ar);
                    var j = O(Ar, 2);
                    {
                      var E = Q => {
                        const ze = ut(() => qo(_(Lt).equippedFlag));
                        var $e = bB(),
                          Re = I($e, !0);
                        C($e), Ue(() => {
                          cr($e, "data-tip", _(ze).name), ce(Re, _(ze).flag)
                        }), Z(Q, $e)
                      };
                      Ee(j, Q => {
                        _(Lt).equippedFlag && Q(E)
                      })
                    }
                    var D = O(j, 2);
                    {
                      var N = Q => {
                        ed(Q, {
                          get username() {
                            return _(Lt).discord
                          },
                          get id() {
                            return _(Lt).discordId
                          }
                        })
                      };
                      Ee(D, Q => {
                        _(Lt).discord && Q(N)
                      })
                    }
                    var X = O(D, 2);
                    {
                      var ee = Q => {
                        var ze = wB(),
                          $e = I(ze);
                        wg($e, {
                          size: "none"
                        });
                        var Re = O($e);
                        C(ze), Ue(() => {
                          cr(ze, "data-tip", _(Lt).role), ce(Re, ` ${k0[_(Lt).role]??""}`)
                        }), Z(Q, ze)
                      };
                      Ee(X, Q => {
                        _(Lt).role && _(Lt).role !== "user" && Q(ee)
                      })
                    }
                    var pe = O(X, 2);
                    {
                      var be = Q => {
                        var ze = SB(),
                          $e = xt(ze),
                          Re = I($e, !0);
                        C($e);
                        var ft = O($e, 2);
                        {
                          var Mt = Et => {
                            var dt = TB();
                            dt.__click = () => {
                              navigator.clipboard.writeText(_(Lt).allianceId.toString()), Xt.success(Pg())
                            };
                            var Kt = I(dt);
                            bg(Kt, {
                              class: "size-3"
                            }), C(dt), Ue((Qt, Sr) => {
                              qr(dt, 1, Qt), cr(dt, "title", Sr)
                            }, [() => ys(ea(_(Lt).allianceId)), () => Jb({
                              allianceId: _(Lt).allianceId
                            })]), Z(Et, dt)
                          };
                          Ee(ft, Et => {
                            var dt, Kt, Qt;
                            (((dt = Dt.data) == null ? void 0 : dt.role) === "admin" || ((Kt = Dt.data) == null ? void 0 : Kt.role) === "moderator" || ((Qt = Dt.data) == null ? void 0 : Qt.role) === "global_moderator") && Et(Mt)
                          })
                        }
                        Ue((Et, dt) => {
                          qr($e, 1, `badge badge-sm ml-0.5 border-0 ${Et??""} ${dt??""}`), ce(Re, _(Lt).allianceName)
                        }, [() => Kp(_(Lt).allianceId), () => ea(_(Lt).allianceId)]), Z(Q, ze)
                      };
                      Ee(pe, Q => {
                        _(Lt).allianceId && Q(be)
                      })
                    }
                    var ye = O(pe, 2);
                    {
                      var Oe = Q => {
                          var ze = PB(),
                            $e = I(ze);
                          Fp($e, {
                            class: "text-error size-4"
                          }), C(ze), Ue(Re => cr(ze, "data-tip", Re), [() => vg()]), Z(Q, ze)
                        },
                        oe = Q => {
                          var ze = or(),
                            $e = xt(ze);
                          {
                            var Re = ft => {
                              var Mt = CB(),
                                Et = I(Mt);
                              ah(Et, {
                                class: "text-error size-4"
                              }), C(Mt), Ue(dt => cr(Mt, "data-tip", dt), [() => Z0()]), Z(ft, Mt)
                            };
                            Ee($e, ft => {
                              _(d).paintedBy.timedOut && ft(Re)
                            }, !0)
                          }
                          Z(Q, ze)
                        };
                      Ee(ye, Q => {
                        _(d).paintedBy.banned ? Q(Oe) : Q(oe, !1)
                      })
                    }
                    C(Tr);
                    var K = O(Tr, 2);
                    {
                      var he = Q => {
                        var ze = EB(),
                          $e = I(ze),
                          Re = I($e);
                        Fg(Re, {
                          class: "size-4"
                        }), C($e);
                        var ft = O($e, 2);
                        fi(ft, 21, () => _(ie), $h, (Mt, Et) => {
                          var dt = or(),
                            Kt = xt(dt);
                          {
                            var Qt = Ft => {
                                var Ze = IB(),
                                  Pr = I(Ze);
                                let br;
                                Pr.__click = () => {
                                  $("report-user")
                                };
                                var Rr = I(Pr);
                                lg(Rr, {
                                  class: "size-5"
                                });
                                var Dr = O(Rr);
                                C(Pr), C(Ze), Ue(ot => {
                                  br = qr(Pr, 1, "text-error py-2 font-medium", null, br, {
                                    "cursor-not-allowed": _(F)
                                  }), ce(Dr, ` ${ot??""}`)
                                }, [() => Gb()]), Z(Ft, Ze)
                              },
                              Sr = Ft => {
                                var Ze = or(),
                                  Pr = xt(Ze);
                                {
                                  var br = Dr => {
                                      var ot = MB(),
                                        dr = I(ot);
                                      let st;
                                      dr.__click = () => {
                                        $("timeout")
                                      };
                                      var Tt = I(dr);
                                      ah(Tt, {
                                        class: "size-5"
                                      });
                                      var nr = O(Tt);
                                      C(dr), C(ot), Ue(Ur => {
                                        st = qr(dr, 1, "text-error font-medium", null, st, {
                                          "cursor-not-allowed": _(F)
                                        }), ce(nr, ` ${Ur??""}`)
                                      }, [() => Hb()]), Z(Dr, ot)
                                    },
                                    Rr = Dr => {
                                      var ot = or(),
                                        dr = xt(ot);
                                      {
                                        var st = nr => {
                                            var Ur = AB(),
                                              Ot = I(Ur);
                                            let Fr;
                                            Ot.__click = () => {
                                              $("ban")
                                            };
                                            var Xr = I(Ot);
                                            Fp(Xr, {
                                              class: "size-5"
                                            });
                                            var mn = O(Xr);
                                            C(Ot), C(Ur), Ue(sn => {
                                              Fr = qr(Ot, 1, "text-error font-medium", null, Fr, {
                                                "cursor-not-allowed": _(F)
                                              }), ce(mn, ` ${sn??""}`)
                                            }, [() => Wb()]), Z(nr, Ur)
                                          },
                                          Tt = nr => {
                                            var Ur = or(),
                                              Ot = xt(Ur);
                                            {
                                              var Fr = Xr => {
                                                var mn = kB(),
                                                  sn = I(mn);
                                                sn.__click = async () => {
                                                  Y(s, !0);
                                                  try {
                                                    await fn.banAllianceUser(_(Lt).id), await fe({
                                                      ..._(q),
                                                      season: a.season
                                                    })
                                                  } catch (nn) {
                                                    Xt.error(nn.message)
                                                  } finally {
                                                    Y(s, !1)
                                                  }
                                                };
                                                var hn = I(sn);
                                                pB(hn, {
                                                  class: "size-5"
                                                });
                                                var dn = O(hn);
                                                C(sn), C(mn), Ue(nn => ce(dn, ` ${nn??""}`), [() => X0()]), Z(Xr, mn)
                                              };
                                              Ee(Ot, Xr => {
                                                _(Et) === "ban-alliance" && Xr(Fr)
                                              }, !0)
                                            }
                                            Z(nr, Ur)
                                          };
                                        Ee(dr, nr => {
                                          _(Et) === "ban-user" ? nr(st) : nr(Tt, !1)
                                        }, !0)
                                      }
                                      Z(Dr, ot)
                                    };
                                  Ee(Pr, Dr => {
                                    _(Et) === "timeout-user" ? Dr(br) : Dr(Rr, !1)
                                  }, !0)
                                }
                                Z(Ft, Ze)
                              };
                            Ee(Kt, Ft => {
                              _(Et) === "report-user" ? Ft(Qt) : Ft(Sr, !1)
                            })
                          }
                          Z(Mt, dt)
                        }), C(ft), C(ze), Z(Q, ze)
                      };
                      Ee(K, Q => {
                        _(ie).length > 0 && Q(he)
                      })
                    }
                    C(Gt), Ue((Q, ze) => {
                      var $e;
                      ce(Lr, `${Q??""}:`), qr(Ar, 1, `font-medium ${ze??""} flex gap-1.5`), ce(qt, (($e = Dt.data) == null ? void 0 : $e.id) === _(Lt).id ? Dt.data.name : _(Lt).name), ce(Le, `#${_(Lt).id??""}`)
                    }, [() => bP(), () => ea(_(Lt).id)]), Z(Jt, Gt)
                  };
                Ee(Wt, Jt => {
                  _(d).paintedBy.event ? Jt(Zt) : Jt(jt, !1)
                }, !0)
              }
              Z(Ht, yr)
            };
          Ee(It, Ht => {
            _(d).paintedBy.id === 0 ? Ht(Bt) : Ht(Nt, !1)
          }, !0)
        }
        Z(tt, ht)
      };
    Ee(vt, tt => {
      _(d) === void 0 ? tt(Ut) : tt(_t, !1)
    })
  }
  C(Xe);
  var wt = O(Xe, 2),
    Je = I(wt);
  {
    var zt = tt => {
        var ht = zB();
        ht.__click = () => a.onclickpaint(a.latLon);
        var It = I(ht);
        Il(It, {
          class: "size-4.5"
        });
        var Bt = O(It);
        C(ht), Ue(Nt => {
          ht.disabled = Dt.loading, ce(Bt, ` ${Nt??""}`)
        }, [() => W0()]), Z(tt, ht)
      },
      bt = tt => {
        var ht = or(),
          It = xt(ht);
        {
          var Bt = Nt => {
            var Ht = FB();
            Ht.__click = () => Se();
            var yr = I(Ht);
            {
              var Wt = jt => {
                  var Jt = DB(),
                    Lt = xt(Jt);
                  r2(Lt, {
                    class: "size-4.5"
                  });
                  var Gt = O(Lt);
                  Ue(Yt => ce(Gt, ` ${Yt??""}`), [() => b6()]), Z(jt, Jt)
                },
                Zt = jt => {
                  var Jt = RB(),
                    Lt = xt(Jt);
                  t1(Lt, {
                    class: "size-4.5"
                  });
                  var Gt = O(Lt);
                  Ue(Yt => ce(Gt, ` ${Yt??""}`), [() => v6()]), Z(jt, Jt)
                };
              Ee(yr, jt => {
                _(d).paintedBy.claimed ? jt(Wt) : jt(Zt, !1)
              })
            }
            C(Ht), Ue(() => Ht.disabled = Dt.loading || _(d).paintedBy.claimed), Z(Nt, Ht)
          };
          Ee(It, Nt => {
            Dt.data && Nt(Bt)
          }, !0)
        }
        Z(tt, ht)
      };
    Ee(Je, tt => {
      var ht;
      (ht = _(d)) != null && ht.paintedBy.event ? tt(bt, !1) : tt(zt)
    })
  }
  var Rt = O(Je, 2);
  {
    var Pt = tt => {
      const ht = ut(() => Dt.data.favoriteLocations.find(Wt => Math.abs(Wt.latitude - _(q).center[0]) < 5e-5 && Math.abs(Wt.longitude - _(q).center[1]) < 5e-5)),
        It = ut(() => !_(ht) && Dt.data.favoriteLocations.length >= Dt.data.maxFavoriteLocations);
      var Bt = BB();
      let Nt;
      Bt.__click = async () => {
        try {
          Y(b, !0), _(ht) ? (await fn.deleteFavoriteLocation(_(ht).id), Xt.warning(dC())) : (await fn.favoriteLocation(_(q).center), Xt.success(mC())), xi.smallPlop.play(), Dt.refresh()
        } catch (Wt) {
          Xt.error(Wt.message)
        } finally {
          Y(b, !1)
        }
      };
      var Ht = I(Bt);
      {
        let Wt = ut(() => !!_(ht));
        gB(Ht, {
          class: "size-4.5",
          get filled() {
            return _(Wt)
          }
        })
      }
      var yr = O(Ht);
      C(Bt), Ue(Wt => {
        Nt = qr(Bt, 1, "btn btn-primary btn-soft", null, Nt, {
          "text-yellow-400": !!_(ht)
        }), Bt.disabled = _(b) || _(It), ce(yr, ` ${Wt??""}`)
      }, [() => _(It) ? SP() : IP()]), Z(tt, Bt)
    };
    Ee(Rt, tt => {
      Dt.data && tt(Pt)
    })
  }
  var yt = O(Rt, 2);
  yt.__click = () => a.onclickshare(nA(Ni.url, {
    pos: {
      lat: _(q).center[0],
      lng: _(q).center[1]
    },
    zoom: a.zoom
  }));
  var sr = I(yt);
  Py(sr, {
    class: "size-4.5"
  });
  var tr = O(sr);
  C(yt), C(wt), C(Me), lo(Me, tt => Y(z, tt), () => _(z)), Ue(tt => {
    ce(Be, `Pixel: ${_(q).regionPixel[0]??""}, ${_(q).regionPixel[1]??""}`), ce(tr, ` ${tt??""}`)
  }, [() => kP()]), ef("innerHeight", tt => Y(A, tt, !0)), Z(m, Me), $r()
}
ni(["click"]);

function jB(m) {
  var x;
  const a = document.createElement("div");
  (x = m.parentElement) == null || x.insertBefore(a, m.nextSibling);
  const d = new IntersectionObserver(A => {
    A[0].isIntersecting ? m.classList.remove("stuck") : m.classList.add("stuck")
  }, {
    threshold: 0,
    rootMargin: "0px"
  });
  return d.observe(a), () => {
    a.remove(), d.disconnect()
  }
}
var cg;
(m => {
  function a() {
    let d, x;
    return {
      promise: new Promise((z, b) => {
        d = z, x = b
      }),
      resolve: d,
      reject: x
    }
  }
  m.withResolvers = a
})(cg || (cg = {}));
var qB = jr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>'),
  VB = jr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>');

function UB(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = or(),
    A = xt(x);
  {
    var z = s => {
        var F = qB();
        _r(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...d
        })), Z(s, F)
      },
      b = s => {
        var F = VB();
        _r(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...d
        })), Z(s, F)
      };
    Ee(A, s => {
      a.filled ? s(z) : s(b, !1)
    })
  }
  Z(m, x)
}
var ZB = me("<p><!></p>"),
  GB = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  HB = me('<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <span class="text-sm">Droplets</span></button>'),
  WB = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  $B = me('<!> <span class="text-sm"> </span>', 1),
  XB = me('<span class="text-sm"> </span>'),
  YB = me('<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>'),
  KB = me('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <h3 class="mt-2 text-center text-xl font-bold"> <!></h3> <!> <div><!></div></div>'),
  JB = me('<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium">Flags</h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>');

function QB(m, a) {
  Wr(a, !0);
  const d = (Ce, je = wa, Ye = wa) => {
      const qe = ut(() => {
          var yt;
          return (((yt = Dt.data) == null ? void 0 : yt.droplets) ?? 0) >= s.price
        }),
        Be = ut(() => _(q) === je().id),
        He = ut(() => x.has(je().id));
      var we = KB(),
        it = I(we),
        mt = I(it, !0);
      C(it);
      var Ge = O(it, 2),
        Xe = I(Ge),
        vt = O(Xe);
      {
        var Ut = yt => {
          var sr = ZB(),
            tr = I(sr);
          ch(tr, {
            class: "text-base-content/60 size-4.5 inline pb-0.5"
          }), C(sr), Ue(tt => {
            qr(sr, 1, ys({
              "tooltip inline": !0,
              "lg:before:-translate-x-1/3": (Ye() + 1) % 4 === 0,
              "lg:before:translate-x-1/3": Ye() % 4 === 0,
              "before:-translate-x-1/3": (Ye() + 1) % 2 === 0,
              "before:translate-x-1/3": Ye() % 2 === 0
            })), cr(sr, "data-tip", tt)
          }, [() => h4()]), Z(yt, sr)
        };
        Ee(vt, yt => {
          _(He) && yt(Ut)
        })
      }
      C(Ge);
      var _t = O(Ge, 2);
      {
        var wt = yt => {
          qg(yt, {})
        };
        Ee(_t, yt => {
          je().id === _(J) && yt(wt)
        })
      }
      var Je = O(_t, 2);
      let zt;
      var bt = I(Je);
      {
        var Rt = yt => {
            var sr = HB();
            sr.__click = async () => {
              if (!(_(He) && !await a.promptUserConfirmation(je().name))) try {
                const Bt = je().id;
                Y(q, Bt, !0), await fn.purchase({
                  id: b,
                  amount: 1,
                  variant: Bt
                }), Dt.refresh(), xi.notification1.play();
                const Nt = z.find(Ht => Ht.id === Bt);
                Nt && (Nt.owned = !0), Y(J, Bt, !0)
              } catch (Bt) {
                Xt.error(Bt.message)
              } finally {
                Y(q, void 0)
              }
            };
            var tr = I(sr);
            {
              var tt = Bt => {
                var Nt = GB();
                Z(Bt, Nt)
              };
              Ee(tr, Bt => {
                _(Be) && Bt(tt)
              })
            }
            var ht = O(tr, 2);
            Yp(ht, {
              class: "size-4"
            });
            var It = O(ht);
            wn(), C(sr), Ue(Bt => {
              sr.disabled = !_(qe) || _(Be), ce(It, ` ${Bt??""} `)
            }, [() => s.price.toLocaleString("en-US")]), Z(yt, sr)
          },
          Pt = yt => {
            const sr = ut(() => {
              var Zt;
              return ((Zt = Dt.data) == null ? void 0 : Zt.equippedFlag) === je().id
            });
            var tr = YB();
            let tt;
            tr.__click = async () => {
              try {
                Y(q, je().id, !0);
                const Zt = _(sr) ? 0 : je().id;
                await fn.equipFlag(Zt), Dt.data && (Dt.data.equippedFlag = Zt), Dt.refresh()
              } catch (Zt) {
                Xt.error(Zt.message)
              } finally {
                Y(q, void 0)
              }
            };
            var ht = I(tr),
              It = I(ht, !0);
            C(ht);
            var Bt = O(ht, 2);
            {
              var Nt = Zt => {
                var jt = WB();
                Z(Zt, jt)
              };
              Ee(Bt, Zt => {
                _(Be) && Zt(Nt)
              })
            }
            var Ht = O(Bt, 2);
            {
              var yr = Zt => {
                  var jt = $B(),
                    Jt = xt(jt);
                  ws(Jt, {
                    class: "size-4"
                  });
                  var Lt = O(Jt, 2),
                    Gt = I(Lt, !0);
                  C(Lt), Ue(Yt => ce(Gt, Yt), [() => D5()]), Z(Zt, jt)
                },
                Wt = Zt => {
                  var jt = XB(),
                    Jt = I(jt, !0);
                  C(jt), Ue(Lt => ce(Jt, Lt), [() => B5()]), Z(Zt, jt)
                };
              Ee(Ht, Zt => {
                _(sr) ? Zt(yr) : Zt(Wt, !1)
              })
            }
            C(tr), Ue(Zt => {
              tt = qr(tr, 1, "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10", null, tt, {
                "btn-warning": _(sr)
              }), tr.disabled = _(Be), ce(It, Zt)
            }, [() => E5()]), Z(yt, tr)
          };
        Ee(bt, yt => {
          je().owned ? yt(Pt, !1) : yt(Rt)
        })
      }
      C(Je), C(we), Ue(yt => {
        ce(mt, je().flag), ce(Xe, `${je().name??""} `), zt = qr(Je, 1, "mt-3", null, zt, {
          tooltip: !_(qe)
        }), cr(Je, "data-tip", yt)
      }, [() => rf()]), Z(Ce, we)
    },
    x = new Set([8, 30, 32, 84, 96, 125, 143, 146, 150, 192, 200, 236, 240, 251]),
    A = La.countries.map(Ce => ({
      ...Ce,
      owned: Dt.flagsBitmap.get(Ce.id)
    }));
  A.sort((Ce, je) => Number(je.owned) - Number(Ce.owned));
  const z = zi(A),
    b = 110,
    s = La.products[b];
  let F = et(!1),
    q = et(void 0),
    J = et(void 0);
  var te = JB(),
    ae = I(te),
    fe = I(ae);
  UB(fe, {
    class: "size-5.5",
    filled: !0
  }), wn(2), C(ae);
  var ie = O(ae, 2),
    $ = I(ie, !0);
  C(ie);
  var Se = O(ie, 2);
  fi(Se, 23, () => z, Ce => Ce.id, (Ce, je, Ye) => {
    var qe = or(),
      Be = xt(qe);
    {
      var He = we => {
        d(we, () => _(je), () => _(Ye))
      };
      Ee(Be, we => {
        (_(Ye) < 8 || _(F)) && we(He)
      })
    }
    Z(Ce, qe)
  }), C(Se);
  var Me = O(Se, 2),
    Pe = I(Me);
  Pe.__click = () => {
    Y(F, !_(F))
  };
  var Ie = I(Pe, !0);
  C(Pe), C(Me), C(te), Ue(Ce => {
    ce($, Ce), ce(Ie, _(F) ? "Show less" : "Show more")
  }, [() => M5()]), Z(m, te), $r()
}
ni(["click"]);
var eO = me('<p class="mt-1 text-center text-sm"> </p>'),
  tO = me('<button class="text-base-content/80 absolute left-full top-1/2 ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>'),
  rO = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  nO = me('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>');

function P0(m, a) {
  Wr(a, !0);
  let d = At(a, "amount", 15, 1);
  const x = ut(() => d() * a.unitPrice),
    A = ut(() => Math.floor(a.userDroplets / a.unitPrice));
  let z = et(!1);
  tn(() => {
    d() < 0 && d(0)
  });
  var b = nO(),
    s = I(b),
    F = I(s);
  bi(F, () => a.icon ?? wa), C(s);
  var q = O(s, 2),
    J = I(q, !0);
  C(q);
  var te = O(q, 2);
  {
    var ae = we => {
      var it = eO(),
        mt = I(it, !0);
      C(it), Ue(() => ce(mt, a.subtitle)), Z(we, it)
    };
    Ee(te, we => {
      a.subtitle && we(ae)
    })
  }
  var fe = O(te, 2),
    ie = I(fe);
  ie.__click = () => {
    qv(d, -1)
  };
  var $ = O(ie, 2);
  za($);
  var Se = O($, 2);
  Se.__click = () => {
    qv(d)
  };
  var Me = O(Se, 2);
  {
    var Pe = we => {
      var it = tO();
      it.__click = () => {
        d(_(A))
      }, Z(we, it)
    };
    Ee(Me, we => {
      d() < _(A) && we(Pe)
    })
  }
  C(fe);
  var Ie = O(fe, 2);
  let Ce;
  var je = I(Ie);
  je.__click = async () => {
    try {
      Y(z, !0), await fn.purchase({
        id: a.productId,
        amount: d()
      }), xi.notification1.play(), a.onpurchasecompleted(d())
    } catch (we) {
      Xt.error(we.message)
    } finally {
      Y(z, !1)
    }
  };
  var Ye = I(je);
  {
    var qe = we => {
      var it = rO();
      Z(we, it)
    };
    Ee(Ye, we => {
      _(z) && we(qe)
    })
  }
  var Be = O(Ye, 2);
  Yp(Be, {
    class: "size-4"
  });
  var He = O(Be);
  wn(), C(je), C(Ie), C(b), Ue((we, it, mt) => {
    ce(J, we), Se.disabled = d() >= _(A), cr(Ie, "data-tip", it), Ce = qr(Ie, 1, "", null, Ce, {
      tooltip: a.userDroplets < _(x)
    }), je.disabled = a.userDroplets < _(x) || _(z) || !d(), ce(He, ` ${mt??""} `)
  }, [() => a.title(d()), () => rf(), () => _(x).toLocaleString("en-US")]), Xh($, d), Z(m, b), $r()
}
ni(["click"]);
var iO = jr('<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>');

function aO(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = iO();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var oO = jr('<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>');

function r1(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = oO();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var sO = jr('<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>');

function lO(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = sO();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var cO = jr('<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>');

function uO(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = cO();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var hO = me('<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost">‚úï</button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>'),
  dO = me('<span class="center-absolute absolute"><!></span>'),
  pO = me('<dialog class="modal"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><h3 class="mb-2 text-lg font-bold"> </h3> <p class="text-sm opacity-80"><!></p> <div class="mt-5 flex justify-end gap-2"><button class="btn btn-ghost"> </button> <button class="btn btn-primary"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function fO(m, a) {
  Wr(a, !0);
  let d = At(a, "open", 15),
    x = et(null),
    A = et(zi({
      name: Zv(),
      prev: 1e3,
      new: 1e5
    }));
  ri(() => {
    const Gt = Yt => {
      Yt.key === "Escape" && d(!1)
    };
    return document.addEventListener("keydown", Gt), () => document.removeEventListener("keydown", Gt)
  });
  const z = {
      id: 70,
      product: La.products[70]
    },
    b = {
      id: 80,
      product: La.products[80]
    },
    s = {
      product: La.products[120]
    };
  let F = et(null),
    q = et(null),
    J = et("");
  async function te(Gt) {
    return _(F).showModal(), Y(q, cg.withResolvers(), !0), Y(J, Gt, !0), _(q).promise
  }
  var ae = pO(),
    fe = xt(ae),
    ie = I(fe),
    $ = I(ie);
  {
    var Se = Gt => {
      var Yt = hO(),
        Lr = I(Yt),
        Ir = I(Lr),
        Jr = I(Ir);
      r1(Jr, {
        class: "size-8"
      });
      var Tr = O(Jr, 2),
        Ar = I(Tr, !0);
      C(Tr);
      var xr = O(Tr, 2),
        qt = I(xr);
      {
        let st = ut(() => {
          var Tt;
          return ((Tt = Dt.data) == null ? void 0 : Tt.droplets) ?? 0
        });
        z0(qt, {
          get value() {
            return _(st)
          }
        })
      }
      C(xr), wn(2), C(Ir), C(Lr), Di(Lr, () => jB);
      var Yr = O(Lr, 2),
        Le = I(Yr),
        j = I(Le),
        E = I(j);
      aO(E, {
        class: "size-5.5",
        filled: !0
      });
      var D = O(E, 2),
        N = I(D, !0);
      C(D), C(j);
      var X = O(j, 2),
        ee = I(X, !0);
      C(X);
      var pe = O(X, 2),
        be = I(pe);
      {
        const st = nr => {
          uO(nr, {
            class: "text-primary size-26"
          })
        };
        let Tt = ut(() => Fw());
        P0(be, {
          get productId() {
            return z.id
          },
          title: nr => zw({
            amount: z.product.items[0].amount * nr
          }),
          get subtitle() {
            return _(Tt)
          },
          get unitPrice() {
            return z.product.price
          },
          get userDroplets() {
            return Dt.data.droplets
          },
          onpurchasecompleted: async nr => {
            var Fr, Xr, mn, sn;
            const Ur = (Xr = (Fr = Dt.data) == null ? void 0 : Fr.charges) == null ? void 0 : Xr.max;
            await Dt.refresh();
            const Ot = (sn = (mn = Dt.data) == null ? void 0 : mn.charges) == null ? void 0 : sn.max;
            Ur !== void 0 && Ot !== void 0 && (Y(A, {
              name: Zv(),
              prev: Ur,
              new: Ot
            }, !0), _(x).show())
          },
          icon: st,
          $$slots: {
            icon: !0
          }
        })
      }
      var ye = O(be, 2);
      {
        const st = nr => {
          Yy(nr, {
            class: "text-primary my-3 size-20"
          })
        };
        let Tt = ut(() => Sw());
        P0(ye, {
          get productId() {
            return b.id
          },
          title: nr => xT({
            amount: b.product.items[0].amount * nr
          }),
          get subtitle() {
            return _(Tt)
          },
          get unitPrice() {
            return b.product.price
          },
          get userDroplets() {
            return Dt.data.droplets
          },
          onpurchasecompleted: async nr => {
            var Ot, Fr, Xr;
            const Ur = (Fr = (Ot = Dt.data) == null ? void 0 : Ot.charges) == null ? void 0 : Fr.count;
            await Dt.refresh(), Ur !== void 0 && (Y(A, {
              name: _T(),
              prev: Math.floor(Ur),
              new: Math.floor(Ur + b.product.items[0].amount * nr)
            }, !0), (Xr = _(x)) == null || Xr.show())
          },
          icon: st,
          $$slots: {
            icon: !0
          }
        })
      }
      C(pe), C(Le);
      var Oe = O(Le, 2),
        oe = I(Oe),
        K = I(oe);
      af(K, {
        class: "size-5.5",
        filled: !0
      });
      var he = O(K, 2),
        Q = I(he, !0);
      C(he), C(oe);
      var ze = O(oe, 2),
        $e = I(ze),
        Re = I($e),
        ft = I(Re),
        Mt = I(ft),
        Et = I(Mt);
      D0(Et, {
        get userId() {
          return Dt.data.id
        },
        get level() {
          return Dt.data.level
        },
        get pictureUrl() {
          return Dt.data.picture
        }
      }), C(Mt), C(ft), C(Re);
      var dt = O(Re, 2),
        Kt = I(dt, !0);
      C(dt);
      var Qt = O(dt, 2),
        Sr = I(Qt, !0);
      C(Qt);
      var Ft = O(Qt, 2);
      let Ze;
      var Pr = I(Ft),
        br = I(Pr),
        Rr = I(br);
      Yp(Rr, {
        class: "size-4"
      });
      var Dr = O(Rr);
      wn(), C(br), C(Pr), C(Ft), C($e), C(ze), C(Oe);
      var ot = O(Oe, 2),
        dr = I(ot);
      QB(dr, {
        promptUserConfirmation: te
      }), C(ot), C(Yr), C(Yt), Ue((st, Tt, nr, Ur, Ot, Fr, Xr, mn) => {
        ce(Ar, st), ce(N, Tt), ce(ee, nr), ce(Q, Ur), ce(Kt, Ot), ce(Sr, Fr), cr(Ft, "data-tip", Xr), Ze = qr(Ft, 1, "", null, Ze, {
          tooltip: Dt.data.droplets < s.product.price
        }), br.disabled = Dt.data.droplets < s.product.price, ce(Dr, ` ${mn??""} `)
      }, [() => G0(), () => Iw(), () => kw(), () => P5(), () => Nw(), () => Vw(), () => rf(), () => s.product.price.toLocaleString("en-US")]), ba(2, Yt, () => so), Z(Gt, Yt)
    };
    Ee($, Gt => {
      Dt.data && d() && Gt(Se)
    })
  }
  C(ie);
  var Me = O(ie, 2),
    Pe = I(Me),
    Ie = I(Pe, !0);
  C(Pe), C(Me), C(fe), Di(fe, () => Gt => {
    tn(() => {
      d() ? Gt.show() : Gt.close()
    })
  });
  var Ce = O(fe, 2),
    je = I(Ce),
    Ye = I(je),
    qe = I(Ye),
    Be = I(qe, !0);
  C(qe);
  var He = O(qe, 2),
    we = I(He),
    it = I(we),
    mt = O(it),
    Ge = I(mt);
  C(mt), C(we);
  var Xe = O(we, 2),
    vt = I(Xe);
  lO(vt, {
    class: "size-5"
  }), C(Xe);
  var Ut = O(Xe, 2),
    _t = I(Ut, !0);
  C(Ut), C(He);
  var wt = O(He, 2),
    Je = I(wt),
    zt = I(Je),
    bt = O(zt);
  ih(bt, () => _(A).new, Gt => {
    var Yt = dO(),
      Lr = I(Yt);
    qg(Lr, {}), C(Yt), Z(Gt, Yt)
  }), C(Je), C(wt), C(Ye), C(je);
  var Rt = O(je, 2),
    Pt = I(Rt),
    yt = I(Pt, !0);
  C(Pt), C(Rt), C(Ce), lo(Ce, Gt => Y(x, Gt), () => _(x));
  var sr = O(Ce, 2),
    tr = I(sr),
    tt = I(tr),
    ht = I(tt, !0);
  C(tt);
  var It = O(tt, 2),
    Bt = I(It);
  Jp(Bt, () => _4({
    country: _(J)
  })), C(It);
  var Nt = O(It, 2),
    Ht = I(Nt);
  Ht.__click = () => {
    var Gt;
    (Gt = _(q)) == null || Gt.resolve(!1), _(F).close()
  };
  var yr = I(Ht, !0);
  C(Ht);
  var Wt = O(Ht, 2);
  Wt.__click = () => {
    var Gt;
    (Gt = _(q)) == null || Gt.resolve(!0), _(F).close()
  };
  var Zt = I(Wt, !0);
  C(Wt), C(Nt), C(tr);
  var jt = O(tr, 2),
    Jt = I(jt),
    Lt = I(Jt, !0);
  C(Jt), C(jt), C(sr), lo(sr, Gt => Y(F, Gt), () => _(F)), Ue((Gt, Yt, Lr, Ir, Jr, Tr, Ar) => {
    ce(Ie, Gt), ce(Be, _(A).name), ce(it, `${_(A).prev??""} `), ce(Ge, `(+${_(A).new-_(A).prev})`), ce(_t, _(A).new), ce(zt, `${Yt??""} `), ce(yt, Lr), ce(ht, Ir), ce(yr, Jr), ce(Zt, Tr), ce(Lt, Ar)
  }, [() => xs(), () => xs(), () => xs(), () => f4(), () => Yh(), () => V0(), () => xs()]), Ln("close", fe, () => d(!1)), Z(m, ae), $r()
}
ni(["click"]);
var mO = jr('<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>');

function gO(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = mO();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var _O = jr('<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>');

function vO(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = _O();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var yO = jr('<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>');

function xO(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = yO();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var bO = jr('<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>');

function wO(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = bO();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}
var TO = jr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>');

function SO(m, a) {
  let d = fr(a, ["$$slots", "$$events", "$$legacy"]);
  var x = TO();
  _r(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...d
  })), Z(m, x)
}

function PO(m, a, d) {
  return m < a ? a : m > d ? d : m
}

function CO(m, a) {
  const d = 10 ** a;
  return Math.round(m * d) / d
}
var IO = me('<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>', 1),
  MO = me("<button><!></button>"),
  AO = me('<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>'),
  kO = me('<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>'),
  EO = me('<button class="btn btn-primary shadow-xl"> </button>'),
  LO = me('<a class="badge badge-secondary absolute -left-2 top-0 -translate-x-full translate-y-1/2 font-semibold" target="_blank"> </a>'),
  zO = me('<span class="tooltip badge badge-secondary tooltip-left absolute -left-2 top-0 -translate-x-full translate-y-1/2 font-semibold">CL</span>'),
  DO = me('<div class="relative"><!> <!></div>'),
  RO = me('<button class="btn btn-square shadow-md"><!></button> <button class="btn btn-square relative shadow-md"><!></button>', 1),
  FO = me('<button title="Auto painter" class="btn btn-square shadow-md"><!></button>'),
  BO = me('<div class="flex flex-col items-center gap-3"><!> <button class="btn btn-square relative shadow-md"><!></button> <button class="btn btn-square shadow-md"><!></button> <!></div>'),
  OO = me('<div class="flex flex-col gap-3"><button><!></button></div>'),
  NO = me('<button class="btn btn-sm btn-circle"><!></button>'),
  jO = me('<div class="tooltip tooltip-right"><div class="tooltip-content">Select Area <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button class="btn btn-sm btn-circle" title="Select area"><!></button></div>'),
  qO = me('<button class="btn btn-sm btn-circle"><!></button>'),
  VO = me('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>'),
  UO = me('<div class="btn btn-sm btn-error w-max cursor-auto text-nowrap text-xs sm:text-base"><!> </div>'),
  ZO = me('<button class="btn sm:btn-lg duration text-nowrap text-xs transition-opacity sm:text-base"><!> </button>'),
  GO = me("<span></span>"),
  HO = me('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><!></div></div>'),
  WO = me('<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>'),
  $O = me('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-lg sm:-translate-x-1/2 md:max-w-xl"><!></div>'),
  XO = me('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pb-2 pt-1"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>'),
  YO = me('<div class="disable-pinch-zoom relative h-full overflow-hidden svelte-1uha8ag"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>', 1);

function GN(m, a) {
  Wr(a, !0);
  const d = fm,
    x = Eb,
    A = new Oa(x),
    z = d - .4,
    b = rA(Ni.url),
    s = b.season ?? jv,
    F = new Map;
  let q = et(void 0),
    J = et(14.5),
    te = et(!1);
  const ae = ut(() => {
    var pt;
    return ((pt = Dt.data) == null ? void 0 : pt.id) === 401
  });
  let fe = et(!1),
    ie = et(zi(b.select && b.pos ? {
      name: "pixelSelected",
      latLon: [b.pos.lat, b.pos.lng]
    } : {
      name: "mainMenu"
    }));
  ri(() => {
    Pe().then(Or => Y(q, Or)).catch(Or => {
      Xt.error(F6(), {
        duration: 5e3
      }), console.error("Error setting up map:", Or)
    });
    let pt = [0, 0];

    function $t(Or) {
      var on;
      if (_(q) && _(J) > d + 1) {
        const {
          lat: Er,
          lng: Hn
        } = _(q).unproject([Or.clientX, Or.clientY]), jn = A.latLonToPixels(Er, Hn, d), Cn = Math.floor(jn[0]), Yn = Math.floor(jn[1]);
        if (pt[0] !== Cn || pt[1] !== Yn) {
          const vr = A.latLonToPixelBoundsLatLon(Er, Hn, d),
            ar = Ag(vr, !0);
          (on = _(q).getSource(je)) == null || on.setCoordinates(ar), pt = [Cn, Yn]
        }
      }
    }
    return window.addEventListener("mousemove", $t), () => {
      var Or;
      (Or = _(q)) == null || Or.remove(), window.removeEventListener("mousemove", $t), Me && clearInterval(Me), Im()
    }
  }), Gs(() => [ka.theme], () => {
    if (_(q)) {
      Se = !1;
      const pt = $(ka.theme);
      _(q).setStyle(pt)
    }
  });

  function $(pt) {
    return `https://maps.wplace.live/styles/${pt==="custom-winter"?"liberty":"fiord"}`
  }
  let Se = !1,
    Me;
  async function Pe() {
    const pt = b.pos ? {
      ...b.pos,
      zoom: _(J)
    } : await G6();
    b.zoom !== void 0 && (pt.zoom = b.zoom);
    const $t = await new Promise(jn => {
        const Cn = new yp.Map({
          style: $(ka.theme),
          center: pt,
          zoom: pt.zoom,
          container: "map",
          dragRotate: !1,
          doubleClickZoom: !1,
          pitch: 0,
          maxPitch: 0,
          attributionControl: !1
        });
        Cn.touchZoomRotate.disableRotation(), Cn.on("styledata", Yn => {
          Se || (ka.theme === "custom-winter" && (Cn.setLayoutProperty("poi_transit", "visibility", "none"), Cn.setLayoutProperty("poi_r20", "visibility", "none"), Cn.setLayoutProperty("poi_r7", "visibility", "none"), Cn.setLayoutProperty("poi_r1", "visibility", "none"), Cn.setLayoutProperty("building", "visibility", "none"), Cn.setLayoutProperty("building-3d", "visibility", "none"), Cn.setLayoutProperty("landuse_pitch", "visibility", "none"), Cn.setLayoutProperty("landuse_hospital", "visibility", "none"), Cn.setLayoutProperty("landuse_school", "visibility", "none"), Cn.setLayoutProperty("landuse_residential", "visibility", "none"), Cn.setLayoutProperty("waterway_tunnel", "visibility", "none"), Cn.setFilter("water", ["all", ["!=", "brunnel", "tunnel"],
            ["!=", "class", "swimming_pool"]
          ])), Ce(Cn), He(), Se = !0)
        }), Cn.on("style.load", () => {
          jn(Cn)
        })
      }),
      Or = La.refreshIntervalMs;

    function on() {
      let jn = _(J) > d + 1.5 ? Or : 2.5 * Or;
      try {
        document.visibilityState === "visible" && Ce($t)
      } finally {
        setTimeout(on, jn)
      }
    }
    Me = setTimeout(on, Or), $t.on("load", () => {
      b.discordLinked && (Xt.success(SC()), Ni.url.searchParams.delete("discord-linked"), Rp(Ni.url.toString())), b.twitchMigration && (Xt.success(uM()), Ni.url.searchParams.delete("twitch-migration"), Rp(Ni.url.toString()))
    });
    let Er = _(J);
    $t.on("zoom", () => {
      Y(J, $t.getZoom(), !0);
      const jn = CO(_(J), 1);
      jn != Er && (_(_t) && _(_t).setOpacity(wt(Er)), Er = jn)
    });
    let Hn = "default";
    return $t.on("dragstart", () => {
      const jn = $t.getCanvas();
      Hn = jn.style.cursor, jn.style.cursor = "move"
    }), $t.on("dragend", () => {
      $t.getCanvas().style.cursor = Hn
    }), $t.on("mouseout", () => {
      we()
    }), $t.on("click", async jn => {
      var gr;
      const Cn = jn.lngLat.lat,
        Yn = jn.lngLat.lng,
        vr = [Cn, Yn];
      if (_(ie).name === "paintingPixel" || _(ie).name === "selectArea") return;
      if (_(ie).name === "selectHq") {
        _(ie).hq = vr, (gr = _(Je)) == null || gr.clearAndPlace(vr);
        return
      }
      const ar = $t.getZoom();
      if (ar < z) {
        Xt.info(GC());
        return
      }
      ps({
        lat: Cn,
        lng: Yn
      }, ar), Y(ie, {
        name: "pixelSelected",
        latLon: vr
      }, !0)
    }), $t
  }
  const Ie = "pixel-art-layer";

  function Ce(pt) {
    const $t = window.innerWidth,
      Or = `${A0}/s${jv}/tiles/{x}/{y}.png`;
    if (F.clear(), !pt.style) return;
    pt.getSource(Ie) ? pt.refreshTiles(Ie) : pt.addSource(Ie, {
      type: "raster",
      tiles: [Or],
      minzoom: d,
      maxzoom: d,
      tileSize: $t > 640 ? 550 : 400
    }), pt.getLayer(Ie) || pt.addLayer({
      id: Ie,
      type: "raster",
      source: Ie,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": _(Ge)
      }
    })
  }
  const je = "pixel-hover",
    Ye = 1e-5,
    qe = [
      [0, 0],
      [Ye, 0],
      [Ye, -Ye],
      [0, -Ye]
    ],
    Be = .4;
  async function He() {
    var pt, $t, Or, on;
    if (!((pt = _(q)) != null && pt.getSource(je))) {
      const Er = Ty(await Ap(U6));
      ($t = _(q)) == null || $t.addSource(je, {
        type: "canvas",
        canvas: Er,
        coordinates: qe
      })
    }(Or = _(q)) != null && Or.getLayer(je) || (on = _(q)) == null || on.addLayer({
      id: je,
      type: "raster",
      source: je,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": Be
      }
    })
  }

  function we() {
    var pt, $t;
    ($t = (pt = _(q)) == null ? void 0 : pt.getSource(je)) == null || $t.setCoordinates(qe)
  }
  let it = et(zi(b.opaque ?? !0)),
    mt = et(!0),
    Ge = ut(() => _(mt) ? _(it) ? 1 : .2 : 0);
  tn(() => {
    var pt;
    (pt = _(q)) != null && pt.getLayer(Ie) && _(q).setPaintProperty(Ie, "raster-opacity", _(Ge))
  });
  let Xe = et(void 0),
    vt = et(void 0),
    Ut = et(void 0);
  ri(() => (navigator.permissions.query({
    name: "geolocation"
  }).then(pt => {
    pt.state === "granted" && Y(Ut, navigator.geolocation.watchPosition($t => {
      Y(Xe, $t)
    }, $t => {
      Y(vt, $t)
    }, {
      enableHighAccuracy: !1,
      maximumAge: 1e3,
      timeout: 6e3
    }), !0)
  }), () => {
    _(Ut) && navigator.geolocation.clearWatch(_(Ut))
  }));
  let _t = et(void 0);
  Gs(() => [_(Xe), _(q)], () => {
    var pt, $t;
    if (_(Xe) && _(q)) {
      const Or = {
          lat: _(Xe).coords.latitude,
          lng: _(Xe).coords.longitude
        },
        on = wt(_(J));
      if (!_(_t)) {
        const Er = document.createElement("div");
        Er.classList.add("maplibregl-user-location-dot"), Er.classList.add("cursor-auto"), Y(_t, new yp.Marker({
          element: Er,
          opacity: on
        }).setLngLat(Or).addTo(_(q)))
      }($t = (pt = _(_t)) == null ? void 0 : pt.setLngLat(Or)) == null || $t.setOpacity(on)
    }
  });

  function wt(pt) {
    return pt < d ? "1.0" : PO((pt - d) * .2, .5, 1).toFixed(2)
  }
  let Je = et(void 0);
  tn(() => {
    var pt;
    _(q) && ((pt = Aa(() => _(Je))) == null || pt.clear(), Ap($v).then($t => {
      Y(Je, new Yv({
        id: "select-crosshair",
        map: _(q),
        tileSize: x,
        zoom: d,
        img: $t,
        markerFn: () => {
          const Or = new yp.Marker({
            color: "#0069ff"
          });
          return Or.addClassName("z-20"), Or
        }
      }))
    }))
  });
  let zt = et(void 0);
  tn(() => {
    var pt;
    _(q) && ((pt = Aa(() => _(Je))) == null || pt.clear(), Ap($v).then($t => {
      Y(zt, new Yv({
        id: "paint-crosshair",
        map: _(q),
        tileSize: x,
        zoom: d,
        img: $t
      }))
    }))
  });
  let bt = et(!1),
    Rt = et(zi(Ni.url)),
    Pt = et(zi({
      cityId: 0,
      countryId: 1,
      id: 0,
      name: "None",
      number: 1
    })),
    yt = et(!1);
  const sr = "view-rules";
  let tr = !1;
  tn(() => {
    Dt.data && (!tr && Dt.data.pixelsPainted > 1 && (localStorage.getItem(sr) || (Y(yt, !0), localStorage.setItem(sr, "true"))), tr = !0)
  });
  let tt = et(!1);
  tn(() => {
    var pt;
    Y(tt, !!((pt = Dt.data) != null && pt.needsPhoneVerification))
  });
  let ht = et([]),
    It = ut(() => _(J) < z ? "1.0" : _(J) < z + 2 ? "0.5" : "0.3");
  tn(() => {
    var $t;
    const pt = ($t = Dt.data) == null ? void 0 : $t.favoriteLocations;
    if (pt && _(q)) {
      for (const Or of Aa(() => _(ht))) Or.remove();
      Y(ht, pt.map(Or => {
        const on = document.createElement("div");
        on.classList.add("text-yellow-400"), on.classList.add("cursor-pointer"), on.classList.add("z-10"), on.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`;
        const Er = {
          lat: Or.latitude,
          lng: Or.longitude
        };
        return on.addEventListener("click", jn => {
          jn.stopPropagation(), Bt([Or.latitude, Or.longitude])
        }), new yp.Marker({
          element: on,
          opacity: _(It)
        }).setLngLat(Er).addTo(_(q))
      }))
    }
  });

  function Bt(pt) {
    var Or;
    const $t = {
      lat: pt[0],
      lng: pt[1]
    };
    (Or = _(q)) == null || Or.flyTo({
      center: $t,
      zoom: Math.max(_(J), 15)
    }), ps($t, _(J)), Y(ie, {
      name: "pixelSelected",
      latLon: [$t.lat, $t.lng]
    }, !0)
  }
  tn(() => {
    if (_(ie).name === "paintingPixel")
      for (const pt of _(ht)) pt.addClassName("hidden");
    else
      for (const pt of _(ht)) pt.removeClassName("hidden"), pt.setOpacity(_(It))
  });
  let Nt = Number.MAX_VALUE;
  tn(() => {
    if (Dt.charges !== void 0 && Dt.data) {
      const pt = Dt.data.charges.max,
        $t = Dt.charges;
      Nt < pt && $t >= pt && xi.notification1.play(), Nt = Dt.charges
    }
  });
  let Ht = et(!1),
    yr = Date.now();
  ri(() => {
    const pt = tA(),
      $t = () => {
        var on;
        if (!document.hidden && Date.now() - yr > 30 * Ec.min) {
          if (pt) {
            const Hn = (on = _(q)) == null ? void 0 : on.getCenter();
            Hn && ps(Hn, _(J)), window.location.replace(Ni.url.origin)
          } else Dt.refresh();
          yr = Date.now()
        }
      };
    return document.addEventListener("visibilitychange", $t), () => document.removeEventListener("visibilitychange", $t)
  }), ri(() => {
    function pt() {
      fn.online = !0
    }
    window.addEventListener("online", pt);

    function $t() {
      fn.online = !1
    }
    return window.addEventListener("offline", $t), () => {
      window.removeEventListener("online", pt), window.removeEventListener("offline", $t)
    }
  }), tn(() => {
    if (!fn.online) {
      const pt = setInterval(() => {
        fn.health().then(() => {
          fn.online = !0, !Dt.data && !Dt.loading && Dt.refresh()
        })
      }, 5e3);
      return () => {
        clearInterval(pt)
      }
    }
  }), ri(() => {
    if (!navigator.serviceWorker) {
      setTimeout(() => {
        console.log("Setting up service worker message listener", navigator.serviceWorker), Xt.warning(k6(), {
          duration: 5e3
        })
      });
      return
    }

    function pt($t) {
      $t.data.type && _(q) && Ce(_(q))
    }
    return navigator.serviceWorker.addEventListener("message", pt), () => {
      navigator.serviceWorker.removeEventListener("message", pt)
    }
  });
  let Wt = et(!1),
    Zt = et("report-user"),
    jt = et(void 0),
    Jt = et(void 0),
    Lt = et(void 0),
    Gt = et(0),
    Yt = et(void 0);
  tn(() => {
    _(Wt) || (Y(Yt, void 0), Y(Jt, void 0), Y(jt, void 0), Y(Lt, void 0))
  });
  const Lr = ut(() => {
    var pt;
    return Ea((pt = Dt.data) == null ? void 0 : pt.role, ["admin", "global_moderator", "moderator"])
  });

  function Ir() {
    Y(ie, {
      name: "mainMenu"
    }, !0), we()
  }
  let Jr = !1;
  const Tr = ut(() => {
    var pt;
    return Ea((pt = Dt.data) == null ? void 0 : pt.role, ["admin"])
  });
  let Ar = et(!1),
    xr = et(!1),
    qt = et(!1),
    Yr = et(!1),
    Le = et(!1),
    j = et(!1),
    E = et(!!b.newUser),
    D = et(!1),
    N = et(!!b.alliance),
    X = et(!1);
  const ee = ut(() => _(Ar) || _(xr) || _(qt) || _(Yr) || _(Le) || _(j) || _(E) || _(D) || _(N) || _(X));
  var pe = YO();
  Ln("keydown", Zs, async pt => {
    if (!_(ee) && !(pt.target instanceof HTMLInputElement || pt.target instanceof HTMLTextAreaElement)) switch (pt.code) {
      case "KeyC":
        if (!_(Lr) || _(ie).name === "paintingPixel" || pt.repeat) return;
        Ir(), await hg(), Y(ie, {
          name: "selectArea"
        }, !0);
        break
    }
  }), vb("1uha8ag", pt => {
    var $t = IO();
    wn(6), gb(() => {
      _b.title = "Wplace - Paint the world"
    }), Z(pt, $t)
  });
  var be = xt(pe);
  {
    const pt = vr => {
        var ar = MO();
        ar.__click = () => {
          Y(it, !_(it))
        };
        var gr = I(ar);
        {
          let zr = ut(() => !_(it));
          Ky(gr, {
            class: "size-5",
            get filled() {
              return _(zr)
            }
          })
        }
        C(ar), Ue(zr => {
          cr(ar, "title", zr), qr(ar, 1, ys({
            "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
            "text-base-content/80": _(it),
            "btn-primary btn-soft": !_(it)
          }))
        }, [() => H0()]), Z(vr, ar)
      },
      $t = vr => {
        var ar = kO();
        ar.__click = async () => {
          var xn;
          _(Xe) || Y(Xe, await new Promise((In, qn) => {
            navigator.geolocation.getCurrentPosition($n => {
              In($n)
            }, $n => {
              qn($n)
            })
          })), _(Xe) && (ps({
            lat: _(Xe).coords.latitude,
            lng: _(Xe).coords.longitude
          }, _(J)), (xn = _(q)) == null || xn.flyTo({
            center: {
              lat: _(Xe).coords.latitude,
              lng: _(Xe).coords.longitude
            },
            zoom: 16.5
          }))
        };
        var gr = I(ar);
        {
          var zr = xn => {
              xO(xn, {
                class: "size-5.5 fill-blue-800"
              })
            },
            Fn = xn => {
              var In = AO(),
                qn = I(In);
              vO(qn, {
                class: "size-5.5 fill-red-400"
              }), wn(2), C(In), Z(xn, In)
            };
          Ee(gr, xn => {
            _(Xe) ? xn(zr) : xn(Fn, !1)
          })
        }
        C(ar), Ue(xn => cr(ar, "title", xn), [() => G2()]), Z(vr, ar)
      };
    var ye = O(I(be), 2);
    let Or;
    var Oe = I(ye);
    let on;
    var oe = I(Oe);
    {
      var K = vr => {
          var ar = EO();
          ar.__click = () => {
            var zr;
            Y(Yr, !0), _(q) && ps((zr = _(q)) == null ? void 0 : zr.getCenter(), _(J))
          };
          var gr = I(ar, !0);
          C(ar), Ue(zr => ce(gr, zr), [() => p2()]), Z(vr, ar)
        },
        he = vr => {
          var ar = or(),
            gr = xt(ar);
          {
            var zr = Fn => {
              var xn = DO(),
                In = I(xn);
              {
                var qn = Qr => {
                    var Tn = LO(),
                      Bn = I(Tn, !0);
                    C(Tn), Ue(bn => {
                      var vn;
                      cr(Tn, "href", ((vn = Dt.data) == null ? void 0 : vn.role) === "admin" ? `${Ni.url.origin}/admin/dashboard` : `${Ni.url.origin}/moderation`), ce(Bn, bn)
                    }, [() => {
                      var bn;
                      return k0[((bn = Dt.data) == null ? void 0 : bn.role) ?? "moderator"].toUpperCase()
                    }]), Z(Qr, Tn)
                  },
                  $n = Qr => {
                    var Tn = or(),
                      Bn = xt(Tn);
                    {
                      var bn = vn => {
                        var ii = zO();
                        Ue(Kn => cr(ii, "data-tip", Kn), [() => iM()]), Z(vn, ii)
                      };
                      Ee(Bn, vn => {
                        var ii;
                        Ea((ii = Dt.data) == null ? void 0 : ii.role, ["community_leader"]) && vn(bn)
                      }, !0)
                    }
                    Z(Qr, Tn)
                  };
                Ee(In, Qr => {
                  var Tn;
                  Ea((Tn = Dt.data) == null ? void 0 : Tn.role, ["admin", "moderator", "global_moderator"]) ? Qr(qn) : Qr($n, !1)
                })
              }
              var Mn = O(In, 2);
              uF(Mn, {
                get user() {
                  return Dt
                },
                onlogout: () => {
                  Y(ie, {
                    name: "mainMenu"
                  }, !0)
                },
                onbanappeal: () => {
                  Y(Ar, !0)
                },
                onnotificationclick: () => {
                  Y(xr, !0)
                },
                ontogglepixelarts: Qr => {
                  Y(mt, Qr, !0)
                }
              }), C(xn), ba(3, xn, () => so, () => ({
                duration: 150
              })), Z(Fn, xn)
            };
            Ee(gr, Fn => {
              Dt.data && _(q) && _(ie).name !== "paintingPixel" && Fn(zr)
            }, !0)
          }
          Z(vr, ar)
        };
      Ee(oe, vr => {
        !Dt.loading && !Dt.data ? vr(K) : vr(he, !1)
      })
    }
    var Q = O(oe, 2);
    {
      var ze = vr => {
          var ar = BO(),
            gr = I(ar);
          {
            var zr = Qr => {
              var Tn = RO(),
                Bn = xt(Tn);
              Bn.__click = () => {
                var Vn;
                Y(Le, !0);
                const Kn = (Vn = _(q)) == null ? void 0 : Vn.getCenter();
                Kn && ps(Kn, _(J))
              };
              var bn = I(Bn);
              r1(bn, {
                class: "size-5"
              }), C(Bn);
              var vn = O(Bn, 2);
              vn.__click = () => {
                Y(N, !0)
              };
              var ii = I(vn);
              of(ii, {
                class: "size-5"
              }), C(vn), Ue((Kn, Vn) => {
                cr(Bn, "title", Kn), cr(vn, "title", Vn)
              }, [() => G0(), () => tf()]), Z(Qr, Tn)
            };
            Ee(gr, Qr => {
              Dt.data && Qr(zr)
            })
          }
          var Fn = O(gr, 2);
          Fn.__click = () => {
            Y(j, !0)
          };
          var xn = I(Fn);
          Wy(xn, {
            class: "size-5"
          }), C(Fn);
          var In = O(Fn, 2);
          In.__click = () => {
            Y(qt, !0)
          };
          var qn = I(In);
          SO(qn, {
            class: "size-5"
          }), C(In);
          var $n = O(In, 2);
          {
            var Mn = Qr => {
              var Tn = FO();
              Tn.__click = () => {
                _(q) && Y(ie, {
                  name: "adminAutoPaint"
                }, !0)
              };
              var Bn = I(Tn);
              Il(Bn, {
                class: "size-5"
              }), C(Tn), Z(Qr, Tn)
            };
            Ee($n, Qr => {
              _(Tr) && Qr(Mn)
            })
          }
          C(ar), Ue((Qr, Tn) => {
            cr(Fn, "title", Qr), cr(In, "title", Tn)
          }, [() => Tg(), () => U0()]), ba(3, ar, () => so, () => ({
            duration: 150
          })), Z(vr, ar)
        },
        $e = vr => {
          var ar = or(),
            gr = xt(ar);
          {
            var zr = Fn => {
              var xn = OO(),
                In = I(xn);
              let qn;
              In.__click = () => {
                Y(te, !_(te))
              };
              var $n = I(In);
              {
                var Mn = Tn => {
                    sg(Tn, {
                      class: "size-5"
                    })
                  },
                  Qr = Tn => {
                    jp(Tn, {
                      class: "size-5"
                    })
                  };
                Ee($n, Tn => {
                  _(te) ? Tn(Mn) : Tn(Qr, !1)
                })
              }
              C(In), C(xn), Ue(Tn => {
                cr(In, "title", Tn), qn = qr(In, 1, "btn btn-square not-touchscreen:hidden shadow-md", null, qn, {
                  "btn-primary": _(te)
                })
              }, [() => _(te) ? w2() : P2()]), ba(1, xn, () => so, () => ({
                delay: 150,
                duration: 150
              })), Z(Fn, xn)
            };
            Ee(gr, Fn => {
              _(q) && _(ie).name === "paintingPixel" && Fn(zr)
            }, !0)
          }
          Z(vr, ar)
        };
      Ee(Q, vr => {
        _(q) && _(ie).name !== "paintingPixel" ? vr(ze) : vr($e, !1)
      })
    }
    C(Oe), C(ye);
    var Re = O(ye, 2);
    let Er;
    var ft = I(Re);
    {
      var Mt = vr => {
        var ar = NO();
        ar.__click = () => {
          Y(D, !0)
        };
        var gr = I(ar);
        gO(gr, {
          class: "size-3.5"
        }), C(ar), Ue(zr => cr(ar, "title", zr), [() => M2()]), Z(vr, ar)
      };
      Ee(ft, vr => {
        _(ie).name !== "paintingPixel" && vr(Mt)
      })
    }
    var Et = O(ft, 2),
      dt = I(Et);
    dt.__click = () => {
      var vr;
      (vr = _(q)) == null || vr.zoomIn()
    };
    var Kt = O(dt, 2);
    Kt.__click = () => {
      var vr;
      (vr = _(q)) == null || vr.zoomOut()
    }, C(Et);
    var Qt = O(Et, 2);
    {
      var Sr = vr => {
        var ar = jO(),
          gr = O(I(ar), 2);
        gr.__click = () => {
          Y(ie, {
            name: "selectArea"
          }, !0)
        };
        var zr = I(gr);
        uh(zr, {
          class: "size-4"
        }), C(gr), C(ar), Z(vr, ar)
      };
      Ee(Qt, vr => {
        _(ie).name !== "paintingPixel" && _(Lr) && vr(Sr)
      })
    }
    var Ft = O(Qt, 2);
    {
      var Ze = vr => {
        var ar = qO(),
          gr = I(ar);
        e1(gr, {
          class: "size-4",
          onclick: () => {
            Y(fe, !_(fe))
          }
        }), C(ar), Ue(zr => cr(ar, "title", zr), [() => l5()]), Z(vr, ar)
      };
      Ee(Ft, vr => {
        _(ae) && vr(Ze)
      })
    }
    var Pr = O(Ft, 2);
    {
      var br = vr => {
        var ar = VO();
        ar.__click = () => {
          window.location.replace(Ni.url.origin)
        };
        var gr = I(ar);
        n2(gr, {
          class: "size-3"
        }), C(ar), Ue(zr => cr(ar, "title", zr), [() => a2()]), Z(vr, ar)
      };
      Ee(Pr, vr => {
        _(ie).name !== "paintingPixel" && vr(br)
      })
    }
    C(Re);
    var Rr = O(Re, 2);
    let Hn;
    var Dr = I(Rr);
    {
      var ot = vr => {
        var ar = UO(),
          gr = I(ar);
        i2(gr, {
          class: "size-5"
        });
        var zr = O(gr);
        C(ar), Ue(Fn => ce(zr, ` ${Fn??""}`), [() => B2()]), ba(1, ar, () => so, () => ({
          duration: 1e3
        })), ba(2, ar, () => so), Z(vr, ar)
      };
      Ee(Dr, vr => {
        fn.online || vr(ot)
      })
    }
    var dr = O(Dr, 2);
    {
      var st = vr => {
        var ar = ZO();
        ar.__click = () => {
          var Fn;
          (Fn = _(q)) == null || Fn.flyTo({
            center: _(q).getCenter(),
            zoom: d
          })
        };
        var gr = I(ar);
        wO(gr, {
          class: "size-5"
        });
        var zr = O(gr);
        C(ar), Ue(Fn => ce(zr, ` ${Fn??""}`), [() => j2()]), ba(3, ar, () => so, () => ({
          duration: 300
        })), Z(vr, ar)
      };
      Ee(dr, vr => {
        _(J) < z && vr(st)
      })
    }
    C(Rr);
    var Tt = O(Rr, 2);
    let jn;
    var nr = I(Tt);
    pt(nr), C(Tt);
    var Ur = O(Tt, 2);
    let Cn;
    var Ot = I(Ur);
    {
      var Fr = vr => {
          Xy(vr, {
            class: "z-30",
            onclick: () => {
              var ar;
              (ar = Dt.data) != null && ar.needsPhoneVerification ? (Y(tt, !0), Xt.warning(Uv())) : Dt.charges !== void 0 && Dt.charges < 1 ? Xt.warning(wR, {
                icon: ah
              }) : _(q) && Dt.data ? (xi.smallDropplet.play(), Y(ie, {
                name: "paintingPixel"
              }, !0)) : (Y(Yr, !0), _(q) && ps(_(q).getCenter(), _(J)))
            },
            get disabled() {
              return Dt.loading
            },
            get loading() {
              return Dt.loading
            },
            get charges() {
              return Dt.charges
            }
          })
        },
        Xr = vr => {
          var ar = GO();
          Z(vr, ar)
        };
      Ee(Ot, vr => {
        _(ie).name === "mainMenu" ? vr(Fr) : vr(Xr, !1)
      })
    }
    C(Ur);
    var mn = O(Ur, 2);
    let Yn;
    var sn = I(mn);
    $t(sn), C(mn);
    var hn = O(mn, 2);
    {
      var dn = vr => {
        var ar = or(),
          gr = xt(ar);
        {
          var zr = xn => {
              var In = HO(),
                qn = I(In),
                $n = I(qn);
              NB($n, {
                get latLon() {
                  return _(ie).latLon
                },
                get map() {
                  return _(q)
                },
                get crosshair() {
                  return _(Je)
                },
                get pixelInfoCache() {
                  return F
                },
                get season() {
                  return s
                },
                get tileSize() {
                  return x
                },
                get pixelArtZoom() {
                  return d
                },
                get zoom() {
                  return _(J)
                },
                get opaquePixelArt() {
                  return _(it)
                },
                onclose: () => Y(ie, {
                  name: "mainMenu"
                }, !0),
                onclickshare: Mn => {
                  Y(Rt, Mn, !0), Y(bt, !0)
                },
                onclickpaint: ([Mn, Qr]) => {
                  var Bn, bn, vn;
                  if (!Dt.data) {
                    Y(Yr, !0);
                    return
                  }
                  if ((Bn = Dt.data) != null && Bn.needsPhoneVerification) {
                    Y(tt, !0), Xt.warning(Uv());
                    return
                  }
                  if (Dt.charges !== void 0 && Dt.charges < 1) {
                    Xt.warning($2());
                    return
                  }
                  const Tn = kg(A.latLonToPixelBoundsLatLon(Mn, Qr, d));
                  (bn = _(q)) == null || bn.flyTo({
                    center: {
                      lat: Tn[0],
                      lon: Tn[1]
                    }
                  }), Y(ie, {
                    name: "paintingPixel",
                    clickedLatLon: [Mn, Qr]
                  }, !0), (vn = _(Je)) == null || vn.clear()
                },
                onclickregion: Mn => {
                  Y(Pt, Mn, !0), Y(X, !0)
                },
                onclickmodaction: (Mn, Qr, Tn, Bn) => {
                  var ii, Kn, Vn;
                  (ii = _(q)) == null || ii.setZoom(Math.max(_(J), d + 3.5));
                  const bn = A.latLonToPixelBoundsLatLon(Tn[0], Tn[1], d);
                  if ((Kn = _(q)) == null || Kn.setCenter({
                      lat: bn.min[0],
                      lng: (bn.max[1] + bn.min[1]) / 2
                    }), !(Mn != null && Mn.paintedBy)) {
                    Xt.error(Vv());
                    return
                  }
                  const vn = Mn.paintedBy;
                  Y(jt, Qr, !0), Y(Jt, [{
                    id: vn.id,
                    name: vn.name,
                    picture: vn.picture,
                    allianceId: vn.allianceId ?? void 0,
                    allianceName: vn.allianceName ?? void 0,
                    timedOut: vn.timedOut,
                    banned: vn.banned
                  }], !0), Y(Lt, Tn, !0), Y(Gt, ((Vn = _(q)) == null ? void 0 : Vn.getZoom()) ?? 0, !0), Y(Zt, Bn, !0), Y(Yt, void 0), Y(Wt, !0)
                }
              }), C(qn), C(In), ba(3, qn, () => Sp, () => ({
                duration: 100
              })), Z(xn, In)
            },
            Fn = xn => {
              var In = or(),
                qn = xt(In);
              {
                var $n = Qr => {
                    var Tn = WO(),
                      Bn = I(Tn),
                      bn = I(Bn);
                    B7(bn, {
                      get map() {
                        return _(q)
                      },
                      get clickedLatLon() {
                        return _(ie).clickedLatLon
                      },
                      get tileSize() {
                        return x
                      },
                      get tileZoom() {
                        return d
                      },
                      get season() {
                        return s
                      },
                      get zoom() {
                        return _(J)
                      },
                      get crosshair() {
                        return _(zt)
                      },
                      refreshPixelArt: () => _(q) && Ce(_(q)),
                      hidePixelHover: we,
                      hoverLayerId: je,
                      onclose: () => {
                        Y(ie, {
                          name: "mainMenu"
                        }, !0), we()
                      },
                      get screenLocked() {
                        return _(te)
                      },
                      set screenLocked(vn) {
                        Y(te, vn, !0)
                      },
                      get opaquePixelArt() {
                        return _(it)
                      },
                      set opaquePixelArt(vn) {
                        Y(it, vn, !0)
                      }
                    }), C(Bn), C(Tn), ba(3, Bn, () => Sp, () => ({
                      duration: 100
                    })), Z(Qr, Tn)
                  },
                  Mn = Qr => {
                    var Tn = or(),
                      Bn = xt(Tn);
                    {
                      var bn = ii => {
                          var Kn = $O(),
                            Vn = I(Kn);
                          cB(Vn, {
                            get map() {
                              return _(q)
                            },
                            get tileSize() {
                              return x
                            },
                            get pixelArtZoom() {
                              return fm
                            },
                            get season() {
                              return s
                            },
                            get crosshair() {
                              return _(zt)
                            },
                            onmodaction: ga => {
                              var Ta;
                              const {
                                targets: ta,
                                image: Fi,
                                latLon: zn,
                                zoom: ja,
                                action: Sn,
                                onSuccess: _n
                              } = ga;
                              if (!ta || ta.length === 0) {
                                Xt.error(Vv());
                                return
                              }
                              Y(jt, Fi, !0), Y(Jt, ta, !0), Y(Lt, zn, !0), Y(Gt, ja ?? ((Ta = _(q)) == null ? void 0 : Ta.getZoom()) ?? 0, !0), Y(Zt, Sn, !0), Y(Yt, {
                                onSuccess: _n
                              }, !0), Y(Wt, !0)
                            },
                            onclose: Ir
                          }), C(Kn), Z(ii, Kn)
                        },
                        vn = ii => {
                          var Kn = or(),
                            Vn = xt(Kn);
                          {
                            var ga = Fi => {
                                AE(Fi, {
                                  get map() {
                                    return _(q)
                                  },
                                  get tileSize() {
                                    return x
                                  },
                                  get tileZoom() {
                                    return d
                                  },
                                  get season() {
                                    return s
                                  },
                                  refreshPixelArt: () => _(q) && Ce(_(q)),
                                  onclose: () => {
                                    Y(ie, {
                                      name: "mainMenu"
                                    }, !0)
                                  }
                                })
                              },
                              ta = Fi => {
                                var zn = or(),
                                  ja = xt(zn);
                                {
                                  var Sn = _n => {
                                    var Ta = XO(),
                                      En = I(Ta),
                                      qa = I(En),
                                      Ui = I(qa),
                                      Va = I(Ui),
                                      ci = I(Va);
                                    Jy(ci, {
                                      class: "inline size-4"
                                    });
                                    var wi = O(ci);
                                    C(Va);
                                    var sa = O(Va, 2);
                                    sa.__click = () => {
                                      Y(ie, {
                                        name: "mainMenu"
                                      }, !0)
                                    };
                                    var Ra = I(sa);
                                    ws(Ra, {
                                      class: "size-4"
                                    }), C(sa), C(Ui);
                                    var Sa = O(Ui, 2),
                                      la = I(Sa);
                                    la.__click = async () => {
                                      var ca;
                                      if (_(ie).name === "selectHq") {
                                        const Ti = _(ie).hq;
                                        if (Ti) try {
                                          Y(Ht, !0), await fn.updateAllianceHeadquarters(Ti[0], Ti[1]), (ca = _(Je)) == null || ca.clear(), Y(N, !0), Y(ie, {
                                            name: "mainMenu"
                                          }, !0)
                                        } catch (Zo) {
                                          Xt.error(Zo.message)
                                        } finally {
                                          Y(Ht, !1)
                                        }
                                      }
                                    };
                                    var eo = I(la);
                                    t1(eo, {
                                      class: "size-6"
                                    }), C(la), C(Sa), C(qa), C(En), C(Ta), Ue(ca => {
                                      ce(wi, ` ${ca??""}`), la.disabled = _(ie).hq === void 0 || _(Ht)
                                    }, [() => VP()]), ba(3, En, () => Sp, () => ({
                                      duration: 100
                                    })), Z(_n, Ta)
                                  };
                                  Ee(ja, _n => {
                                    _(ie).name === "selectHq" && _n(Sn)
                                  }, !0)
                                }
                                Z(Fi, zn)
                              };
                            Ee(Vn, Fi => {
                              _(ie).name === "adminAutoPaint" && _(q) ? Fi(ga) : Fi(ta, !1)
                            }, !0)
                          }
                          Z(ii, Kn)
                        };
                      Ee(Bn, ii => {
                        _(ie).name === "selectArea" ? ii(bn) : ii(vn, !1)
                      }, !0)
                    }
                    Z(Qr, Tn)
                  };
                Ee(qn, Qr => {
                  _(ie).name === "paintingPixel" && _(zt) ? Qr($n) : Qr(Mn, !1)
                }, !0)
              }
              Z(xn, In)
            };
          Ee(gr, xn => {
            _(ie).name === "pixelSelected" && _(Je) ? xn(zr) : xn(Fn, !1)
          })
        }
        Z(vr, ar)
      };
      Ee(hn, vr => {
        _(q) && vr(dn)
      })
    }
    C(be), Ue((vr, ar) => {
      Or = qr(ye, 1, "absolute right-2 top-2 z-30", null, Or, {
        hidden: _(fe)
      }), on = qr(Oe, 1, "flex flex-col gap-4", null, on, {
        "items-end": !Dt.data,
        "items-center": Dt.data
      }), Er = qr(Re, 1, "absolute left-2 top-2 z-30 flex flex-col gap-3", null, Er, {
        hidden: _(fe)
      }), cr(dt, "title", vr), cr(Kt, "title", ar), Hn = qr(Rr, 1, "absolute left-1/2 top-2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2", null, Hn, {
        hidden: _(fe)
      }), jn = qr(Tt, 1, "absolute bottom-3 left-3 z-30", null, jn, {
        hidden: _(fe)
      }), Cn = qr(Ur, 1, "absolute bottom-3 left-1/2 z-30 -translate-x-1/2", null, Cn, {
        hidden: _(fe)
      }), Yn = qr(mn, 1, "absolute bottom-3 right-3 z-30", null, Yn, {
        hidden: _(fe)
      })
    }, [() => E2(), () => D2()])
  }
  var nn = O(be, 2);
  xR(nn, {
    get open() {
      return _(Yr)
    },
    set open(pt) {
      Y(Yr, pt, !0)
    }
  });
  var Ke = O(nn, 2);
  fO(Ke, {
    get open() {
      return _(Le)
    },
    set open(pt) {
      Y(Le, pt, !0)
    }
  });
  var St = O(Ke, 2);
  fL(St, {
    get open() {
      return _(E)
    },
    set open(pt) {
      Y(E, pt, !0)
    }
  });
  var kr = O(St, 2);
  LL(kr, {
    get open() {
      return _(D)
    },
    set open(pt) {
      Y(D, pt, !0)
    }
  });
  var wr = O(kr, 2);
  dL(wr, {
    get open() {
      return _(yt)
    },
    set open(pt) {
      Y(yt, pt, !0)
    }
  });
  var mr = O(wr, 2);
  _R(mr, {
    onvisitclick: pt => {
      var $t;
      ($t = _(q)) == null || $t.flyTo({
        center: pt,
        zoom: fm + 1
      }), ps(pt, _(J)), Y6.push({
        pos: pt,
        zoom: _(J)
      }), Y(j, !1)
    },
    get open() {
      return _(j)
    },
    set open(pt) {
      Y(j, pt, !0)
    }
  });
  var Mr = O(mr, 2);
  SF(Mr, {
    get region() {
      return _(Pt)
    },
    get open() {
      return _(X)
    },
    set open(pt) {
      Y(X, pt, !0)
    }
  });
  var gn = O(Mr, 2);
  Bb(gn, {
    get open() {
      return ka.dropletsDialogOpen
    },
    set open(pt) {
      ka.dropletsDialogOpen = pt
    }
  });
  var Rn = O(gn, 2);
  {
    var ln = pt => {
      X8(pt, {
        onhqchange: () => {
          Y(ie, {
            name: "selectHq"
          }, !0), Y(N, !1)
        },
        onhqclick: $t => {
          var Or;
          (Or = _(q)) == null || Or.flyTo({
            center: $t,
            zoom: Math.max(_(J), 15)
          }), Y(ie, {
            name: "pixelSelected",
            latLon: [$t.lat, $t.lng]
          }, !0), Y(N, !1)
        },
        onlastpixelclick: $t => {
          var Or;
          (Or = _(q)) == null || Or.flyTo({
            center: $t,
            zoom: Math.max(_(J), 15)
          }), Y(ie, {
            name: "pixelSelected",
            latLon: [$t.lat, $t.lng]
          }, !0), Y(N, !1)
        },
        get open() {
          return _(N)
        },
        set open($t) {
          Y(N, $t, !0)
        }
      })
    };
    Ee(Rn, pt => {
      _(q) && pt(ln)
    })
  }
  var Gn = O(Rn, 2);
  t9(Gn, {
    get open() {
      return _(tt)
    },
    set open(pt) {
      Y(tt, pt, !0)
    }
  });
  var On = O(Gn, 2);
  {
    var Wn = pt => {
      oL(pt, {
        get url() {
          return _(Rt)
        },
        get map() {
          return _(q)
        },
        hideHover: () => {
          var $t, Or;
          ($t = _(q)) == null || $t.setPaintProperty(je, "raster-opacity", 0), (Or = _(Je)) == null || Or.setCanvasOpacity(0)
        },
        showHover: () => {
          var $t, Or;
          ($t = _(q)) == null || $t.setPaintProperty(je, "raster-opacity", Be), (Or = _(Je)) == null || Or.setCanvasOpacity(1)
        },
        get open() {
          return _(bt)
        },
        set open($t) {
          Y(bt, $t, !0)
        }
      })
    };
    Ee(On, pt => {
      _(q) && pt(Wn)
    })
  }
  var ti = O(On, 2);
  {
    var Zn = pt => {
      $b(pt, {
        get image() {
          return _(jt)
        },
        get targets() {
          return _(Jt)
        },
        get latLon() {
          return _(Lt)
        },
        get zoom() {
          return _(Gt)
        },
        get action() {
          return _(Zt)
        },
        onsuccess: () => {
          var $t, Or;
          (Or = ($t = _(Yt)) == null ? void 0 : $t.onSuccess) == null || Or.call($t)
        },
        get open() {
          return _(Wt)
        },
        set open($t) {
          Y(Wt, $t, !0)
        }
      })
    };
    Ee(ti, pt => {
      _(Jt) && _(Jt).length > 0 && _(jt) && _(Lt) && pt(Zn)
    })
  }
  var cn = O(ti, 2);
  {
    var kn = pt => {
      n9(pt, {
        get userData() {
          return Dt.data
        },
        get open() {
          return _(Ar)
        },
        set open($t) {
          Y(Ar, $t, !0)
        }
      })
    };
    Ee(cn, pt => {
      Dt.data && pt(kn)
    })
  }
  var Xn = O(cn, 2);
  qR(Xn, {
    get open() {
      return _(xr)
    },
    set open(pt) {
      Y(xr, pt, !0)
    }
  });
  var Ri = O(Xn, 2);
  {
    var Ii = pt => {
      OF(pt, {
        get map() {
          return _(q)
        },
        get tileSize() {
          return x
        },
        get season() {
          return s
        },
        get tileZoom() {
          return d
        },
        get open() {
          return _(qt)
        },
        set open($t) {
          Y(qt, $t, !0)
        }
      })
    };
    Ee(Ri, pt => {
      _(q) && pt(Ii)
    })
  }
  var Vi = O(Ri, 2);
  Ee(Vi, pt => {
    _(q)
  }), Z(m, pe), $r()
}
ni(["click"]);
export {
  GN as component
};